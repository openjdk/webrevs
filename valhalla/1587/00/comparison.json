{"files":[{"patch":"@@ -100,1 +100,0 @@\n-        --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    \/\/ ackermann(1,1748) + ackermann(2,1897) + ackermann(3,8) == 9999999 invocations\n+    \/\/ ackermann(1,1748)+ ackermann(2,1897)+ ackermann(3,8); == 9999999 calls\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/AckermannBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.ackermann;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-\n-public class Identity extends AckermannBase {\n-\n-    private static IdentityLong ack_identity(IdentityLong x, IdentityLong y) {\n-        return x.value() == 0 ?\n-                IdentityLong.valueOf(y.value() + 1) :\n-                (y.value() == 0 ?\n-                        ack_identity(IdentityLong.valueOf(x.value() - 1), IdentityLong.valueOf(1)) :\n-                        ack_identity(IdentityLong.valueOf(x.value() - 1), ack_identity(x, IdentityLong.valueOf(y.value() - 1))));\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(OPI)\n-    public long ackermann() {\n-        return ack_identity(IdentityLong.valueOf(X1), IdentityLong.valueOf(Y1)).value()\n-                + ack_identity(IdentityLong.valueOf(X2), IdentityLong.valueOf(Y2)).value()\n-                + ack_identity(IdentityLong.valueOf(X3), IdentityLong.valueOf(Y3)).value();\n-    }\n-\n-    public static class IdentityLong {\n-\n-        public final long v0;\n-\n-        public IdentityLong(long v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public long value() {\n-            return v0;\n-        }\n-\n-        public static IdentityLong valueOf(long value) {\n-            return new IdentityLong(value);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Identity.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.ackermann;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+\n+public class Identity64byte extends AckermannBase {\n+\n+    private static R64byte ack_ref(R64byte x, R64byte y) {\n+        return x.longValue() == 0 ?\n+                new R64byte(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_ref(new R64byte(x.longValue()-1) , new R64byte(1)) :\n+                        ack_ref(new R64byte(x.longValue()-1), ack_ref(x, new R64byte(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Ref() {\n+        return ack_ref(new R64byte(X1), new R64byte(Y1)).longValue()\n+                + ack_ref(new R64byte(X2), new R64byte(Y2)).longValue()\n+                + ack_ref(new R64byte(X3), new R64byte(Y3)).longValue();\n+    }\n+\n+    private static Int64 ack_inter(Int64 x, Int64 y) {\n+        return x.longValue() == 0 ?\n+                new R64byte(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_inter(new R64byte(x.longValue()-1) , new R64byte(1)) :\n+                        ack_inter(new R64byte(x.longValue()-1), ack_inter(x, new R64byte(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Int() {\n+        return ack_inter(new R64byte(X1), new R64byte(Y1)).longValue()\n+                + ack_inter(new R64byte(X2), new R64byte(Y2)).longValue()\n+                + ack_inter(new R64byte(X3), new R64byte(Y3)).longValue();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Identity64byte.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.ackermann;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+\n+public class Identity64int extends AckermannBase {\n+\n+    private static R64int ack_ref(R64int x, R64int y) {\n+        return x.longValue() == 0 ?\n+                new R64int(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_ref(new R64int(x.longValue()-1) , new R64int(1)) :\n+                        ack_ref(new R64int(x.longValue()-1), ack_ref(x, new R64int(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Ref() {\n+        return ack_ref(new R64int(X1), new R64int(Y1)).longValue()\n+                + ack_ref(new R64int(X2), new R64int(Y2)).longValue()\n+                + ack_ref(new R64int(X3), new R64int(Y3)).longValue();\n+    }\n+\n+    private static Int64 ack_inter(Int64 x, Int64 y) {\n+        return x.longValue() == 0 ?\n+                new R64int(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_inter(new R64int(x.longValue()-1) , new R64int(1)) :\n+                        ack_inter(new R64int(x.longValue()-1), ack_inter(x, new R64int(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Int() {\n+        return ack_inter(new R64int(X1), new R64int(Y1)).longValue()\n+                + ack_inter(new R64int(X2), new R64int(Y2)).longValue()\n+                + ack_inter(new R64int(X3), new R64int(Y3)).longValue();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Identity64int.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.ackermann;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+\n+public class Identity64long extends AckermannBase {\n+\n+    private static R64long ack_ref(R64long x, R64long y) {\n+        return x.longValue() == 0 ?\n+                new R64long(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_ref(new R64long(x.longValue()-1) , new R64long(1)) :\n+                        ack_ref(new R64long(x.longValue()-1), ack_ref(x, new R64long(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Ref() {\n+        return ack_ref(new R64long(X1), new R64long(Y1)).longValue()\n+                + ack_ref(new R64long(X2), new R64long(Y2)).longValue()\n+                + ack_ref(new R64long(X3), new R64long(Y3)).longValue();\n+    }\n+\n+    private static Int64 ack_inter(Int64 x, Int64 y) {\n+        return x.longValue() == 0 ?\n+                new R64long(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_inter(new R64long(x.longValue()-1) , new R64long(1)) :\n+                        ack_inter(new R64long(x.longValue()-1), ack_inter(x, new R64long(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Int() {\n+        return ack_inter(new R64long(X1), new R64long(Y1)).longValue()\n+                + ack_inter(new R64long(X2), new R64long(Y2)).longValue()\n+                + ack_inter(new R64long(X3), new R64long(Y3)).longValue();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Identity64long.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.ackermann;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+\n+public class IdentityLong extends AckermannBase {\n+\n+    private static Long ack_Long(Long x, Long y) {\n+        return x == 0 ?\n+                y + 1 :\n+                (y == 0 ?\n+                        ack_Long(x - 1, 1L) :\n+                        ack_Long(x - 1, ack_Long(x, y - 1)));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ref_Long() {\n+        return ack_Long(Long.valueOf(X1), Long.valueOf(Y1))\n+                + ack_Long(Long.valueOf(X2), Long.valueOf(Y2))\n+                + ack_Long(Long.valueOf(X3), Long.valueOf(Y3));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/IdentityLong.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.ackermann;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+\n+public class Inline64byte extends AckermannBase {\n+\n+    private static Q64byte ack_value(Q64byte x, Q64byte y) {\n+        return x.longValue() == 0 ?\n+                new Q64byte(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_value(new Q64byte(x.longValue()-1) , new Q64byte(1)) :\n+                        ack_value(new Q64byte(x.longValue()-1), ack_value(x, new Q64byte(y.longValue()-1))));\n+    }\n+\n+\/\/    @Benchmark\n+\/\/    @OperationsPerInvocation(OPI)\n+\/\/ TODO fix StackOverflowException\n+    public long ack_Val() {\n+        return ack_value(new Q64byte(X1), new Q64byte(Y1)).longValue()\n+                + ack_value(new Q64byte(X2), new Q64byte(Y2)).longValue()\n+                + ack_value(new Q64byte(X3), new Q64byte(Y3)).longValue();\n+    }\n+\n+    private static Q64byte ack_ref(Q64byte x, Q64byte y) {\n+        return x.longValue() == 0 ?\n+                new Q64byte(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_ref(new Q64byte(x.longValue()-1) , new Q64byte(1)) :\n+                        ack_ref(new Q64byte(x.longValue()-1), ack_ref(x, new Q64byte(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Ref() {\n+        return ack_ref(new Q64byte(X1), new Q64byte(Y1)).longValue()\n+                + ack_ref(new Q64byte(X2), new Q64byte(Y2)).longValue()\n+                + ack_ref(new Q64byte(X3), new Q64byte(Y3)).longValue();\n+    }\n+\n+    private static Int64 ack_inter(Int64 x, Int64 y) {\n+        return x.longValue() == 0 ?\n+                new Q64byte(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_inter(new Q64byte(x.longValue()-1) , new Q64byte(1)) :\n+                        ack_inter(new Q64byte(x.longValue()-1), ack_inter(x, new Q64byte(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Int() {\n+        return ack_inter(new Q64byte(X1), new Q64byte(Y1)).longValue()\n+                + ack_inter(new Q64byte(X2), new Q64byte(Y2)).longValue()\n+                + ack_inter(new Q64byte(X3), new Q64byte(Y3)).longValue();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Inline64byte.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.ackermann;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+\n+public class Inline64int extends AckermannBase {\n+\n+    private static Q64int ack_value(Q64int x, Q64int y) {\n+        return x.longValue() == 0 ?\n+                new Q64int(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_value(new Q64int(x.longValue()-1) , new Q64int(1)) :\n+                        ack_value(new Q64int(x.longValue()-1), ack_value(x, new Q64int(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Val() {\n+        return ack_value(new Q64int(X1), new Q64int(Y1)).longValue()\n+                + ack_value(new Q64int(X2), new Q64int(Y2)).longValue()\n+                + ack_value(new Q64int(X3), new Q64int(Y3)).longValue();\n+    }\n+\n+    private static Q64int ack_ref(Q64int x, Q64int y) {\n+        return x.longValue() == 0 ?\n+                new Q64int(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_ref(new Q64int(x.longValue()-1) , new Q64int(1)) :\n+                        ack_ref(new Q64int(x.longValue()-1), ack_ref(x, new Q64int(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Ref() {\n+        return ack_ref(new Q64int(X1), new Q64int(Y1)).longValue()\n+                + ack_ref(new Q64int(X2), new Q64int(Y2)).longValue()\n+                + ack_ref(new Q64int(X3), new Q64int(Y3)).longValue();\n+    }\n+\n+    private static Int64 ack_inter(Int64 x, Int64 y) {\n+        return x.longValue() == 0 ?\n+                new Q64int(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_inter(new Q64int(x.longValue()-1) , new Q64int(1)) :\n+                        ack_inter(new Q64int(x.longValue()-1), ack_inter(x, new Q64int(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Int() {\n+        return ack_inter(new Q64int(X1), new Q64int(Y1)).longValue()\n+                + ack_inter(new Q64int(X2), new Q64int(Y2)).longValue()\n+                + ack_inter(new Q64int(X3), new Q64int(Y3)).longValue();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Inline64int.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.ackermann;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+\n+public class Inline64long extends AckermannBase {\n+\n+    private static Q64long ack_value(Q64long x, Q64long y) {\n+        return x.longValue() == 0 ?\n+                new Q64long(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_value(new Q64long(x.longValue()-1) , new Q64long(1)) :\n+                        ack_value(new Q64long(x.longValue()-1), ack_value(x, new Q64long(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Val() {\n+        return ack_value(new Q64long(X1), new Q64long(Y1)).longValue()\n+                + ack_value(new Q64long(X2), new Q64long(Y2)).longValue()\n+                + ack_value(new Q64long(X3), new Q64long(Y3)).longValue();\n+    }\n+\n+    private static Q64long ack_ref(Q64long x, Q64long y) {\n+        return x.longValue() == 0 ?\n+                new Q64long(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_ref(new Q64long(x.longValue()-1) , new Q64long(1)) :\n+                        ack_ref(new Q64long(x.longValue()-1), ack_ref(x, new Q64long(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Ref() {\n+        return ack_ref(new Q64long(X1), new Q64long(Y1)).longValue()\n+                + ack_ref(new Q64long(X2), new Q64long(Y2)).longValue()\n+                + ack_ref(new Q64long(X3), new Q64long(Y3)).longValue();\n+    }\n+\n+    private static Int64 ack_inter(Int64 x, Int64 y) {\n+        return x.longValue() == 0 ?\n+                new Q64long(y.longValue() + 1) :\n+                (y.longValue() == 0 ?\n+                        ack_inter(new Q64long(x.longValue()-1) , new Q64long(1)) :\n+                        ack_inter(new Q64long(x.longValue()-1), ack_inter(x, new Q64long(y.longValue()-1))));\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(OPI)\n+    public long ack_Int() {\n+        return ack_inter(new Q64long(X1), new Q64long(Y1)).longValue()\n+                + ack_inter(new Q64long(X2), new Q64long(Y2)).longValue()\n+                + ack_inter(new Q64long(X3), new Q64long(Y3)).longValue();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Inline64long.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-public class Primitive extends AckermannBase {\n+public class Primitive64 extends AckermannBase {\n@@ -40,1 +40,1 @@\n-    public long ackermann() {\n+    public long primitive() {\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Primitive64.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Primitive.java","status":"renamed"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.ackermann;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value extends AckermannBase {\n-\n-    private static ValueLong ack_value(ValueLong x, ValueLong y) {\n-        return x.value() == 0 ?\n-                ValueLong.valueOf(y.value() + 1) :\n-                (y.value() == 0 ?\n-                        ack_value(ValueLong.valueOf(x.value() - 1), ValueLong.valueOf(1)) :\n-                        ack_value(ValueLong.valueOf(x.value() - 1), ack_value(x, ValueLong.valueOf(y.value() - 1))));\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(OPI)\n-    public long ackermann_value() {\n-        return ack_value(ValueLong.valueOf(X1), ValueLong.valueOf(Y1)).value()\n-                + ack_value(ValueLong.valueOf(X2), ValueLong.valueOf(Y2)).value()\n-                + ack_value(ValueLong.valueOf(X3), ValueLong.valueOf(Y3)).value();\n-    }\n-\n-    private static InterfaceLong ack_value_as_Int(InterfaceLong x, InterfaceLong y) {\n-        return x.value() == 0 ?\n-                ValueLong.valueOf(y.value() + 1) :\n-                (y.value() == 0 ?\n-                        ack_value_as_Int(ValueLong.valueOf(x.value() - 1), ValueLong.valueOf(1)) :\n-                        ack_value_as_Int(ValueLong.valueOf(x.value() - 1), ack_value_as_Int(x, ValueLong.valueOf(y.value() - 1))));\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(OPI)\n-    public long ackermann_interface() {\n-        return ack_value_as_Int(ValueLong.valueOf(X1), ValueLong.valueOf(Y1)).value()\n-                + ack_value_as_Int(ValueLong.valueOf(X2), ValueLong.valueOf(Y2)).value()\n-                + ack_value_as_Int(ValueLong.valueOf(X3), ValueLong.valueOf(Y3)).value();\n-    }\n-\n-    public static interface InterfaceLong {\n-        public long value();\n-    }\n-\n-    public static value class ValueLong implements InterfaceLong {\n-\n-        public final long v0;\n-\n-        public ValueLong(long v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public long value() {\n-            return v0;\n-        }\n-\n-        public static ValueLong valueOf(long value) {\n-            return new ValueLong(value);\n-        }\n-\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/ackermann\/Value.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,398 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.array;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.array.Identity  -wmb \"org.openjdk.bench.valhalla.acmp.array.Identity.*050\"\n- *\/\n-\n-@Fork(3)\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Identity {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_obj(Object[] objects1, Object[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_ref(IdentityInt[] objects1, IdentityInt[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_ref(IdentityInt[] objects1, IdentityInt[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_obj(Object[] objects1, Object[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals000(ObjState00 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals025(ObjState25 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals050(ObjState50 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals075(ObjState75 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals100(ObjState100 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals000(RefState00 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals025(RefState25 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals050(RefState50 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals075(RefState75 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals100(RefState100 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals000(ObjState00 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals025(ObjState25 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals050(ObjState50 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals075(ObjState75 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals100(ObjState100 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals000(RefState00 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals025(RefState25 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals050(RefState50 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals075(RefState75 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals100(RefState100 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    public static class IdentityInt {\n-\n-        public final int v0;\n-\n-        public IdentityInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = null;\n-            arr2[0] = new IdentityInt(1);\n-            arr1[1] = new IdentityInt(2);\n-            arr2[1] = null;\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new IdentityInt(2 * i);\n-                arr2[i] = new IdentityInt(2 * i + 1);\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = null;\n-            for (int i = 1; i < SIZE; i++) {\n-                arr2[i] = arr1[i] = new IdentityInt(i);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = arr1[i] = null;\n-                        samenulls = false;\n-                    } else {\n-                        arr2[i] = arr1[i] = new IdentityInt(i);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = null;\n-                            arr2[i] = new IdentityInt(2 * i + 1);\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new IdentityInt(2 * i);\n-                            arr2[i] = null;\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new IdentityInt(2 * i);\n-                            arr2[i] = new IdentityInt(2 * i + 1);\n-                            break;\n-                    }\n-                }\n-            }\n-\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ObjState {\n-        Object[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new Object[SIZE];\n-            arr2 = new Object[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class RefState {\n-        IdentityInt[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new IdentityInt[SIZE];\n-            arr2 = new IdentityInt[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ObjState00 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ObjState25 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ObjState50 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ObjState75 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ObjState100 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-    public static class RefState00 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class RefState25 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class RefState50 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class RefState75 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class RefState100 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/Identity.java","additions":0,"deletions":398,"binary":false,"changes":398,"status":"deleted"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ *  For proper results it should be executed:\n+ *  java -jar target\/benchmarks.jar IdentityIsCmpBranch  -wmb IdentityIsCmpBranch.equals050\n+ *\/\n+\n+@Fork(3)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityIsCmpBranch extends StatesR64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Obj(Object[] objects1, Object[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Ref(R64long[] objects1, R64long[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals000(ObjState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals025(ObjState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals050(ObjState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals075(ObjState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals100(ObjState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals000(RefState00 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals025(RefState25 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals050(RefState50 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals075(RefState75 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals100(RefState100 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/IdentityIsCmpBranch.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ *  For proper results it should be executed:\n+ *  java -jar target\/benchmarks.jar IdentityIsCmpResult  -wmb IdentityIsCmpResult.Obj_equals050\n+ *\/\n+\n+@Fork(3)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityIsCmpResult extends StatesR64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static boolean cmp_Obj(Object[] objects1, Object[] objects2) {\n+        boolean s = false;\n+        for (int i = 0; i < SIZE; i++) {\n+            s ^= objects1[i] == objects2[i];\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals000(ObjState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals025(ObjState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals050(ObjState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals075(ObjState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals100(ObjState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/IdentityIsCmpResult.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ *  For proper results it should be executed:\n+ *  java -jar target\/benchmarks.jar IdentityIsNotCmpBranch  -wmb IdentityIsNotCmpBranch.Obj_equals050\n+ *\/\n+\n+@Fork(3)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityIsNotCmpBranch extends StatesR64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Obj(Object[] objects1, Object[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] != objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals000(ObjState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals025(ObjState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals050(ObjState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals075(ObjState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals100(ObjState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/IdentityIsNotCmpBranch.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityIsNotCmpResult extends StatesR64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static boolean cmp_Obj(Object[] objects1, Object[] objects2) {\n+        boolean s = false;\n+        for (int i = 0; i < SIZE; i++) {\n+            s ^= objects1[i] != objects2[i];\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals000(ObjState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals025(ObjState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals050(ObjState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals075(ObjState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public boolean Obj_equals100(ObjState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/IdentityIsNotCmpResult.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineIsCmpBranch64byte extends StatesQ64byte {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Obj(Object[] objects1, Object[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Int(Int64[] objects1, Int64[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Ref(Q64byte[] objects1, Q64byte[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Val(Q64byte[] objects1, Q64byte[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals000(ObjState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals025(ObjState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals050(ObjState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals075(ObjState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals100(ObjState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals000(IntState00 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals025(IntState25 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals050(IntState50 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals075(IntState75 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals100(IntState100 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals000(RefState00 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals025(RefState25 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals050(RefState50 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals075(RefState75 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals100(RefState100 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals000(ValState00 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals025(ValState25 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals050(ValState50 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals075(ValState75 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals100(ValState100 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/InlineIsCmpBranch64byte.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineIsCmpBranch64long extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Obj(Object[] objects1, Object[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Int(Int64[] objects1, Int64[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Ref(Q64long[] objects1, Q64long[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Val(Q64long[] objects1, Q64long[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i] == objects2[i]) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals000(ObjState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals025(ObjState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals050(ObjState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals075(ObjState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals100(ObjState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals000(IntState00 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals025(IntState25 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals050(IntState50 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals075(IntState75 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals100(IntState100 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals000(RefState00 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals025(RefState25 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals050(RefState50 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals075(RefState75 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals100(RefState100 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals000(ValState00 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals025(ValState25 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals050(ValState50 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals075(ValState75 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals100(ValState100 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Ref_equals000(ValState00 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Ref_equals025(ValState25 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Ref_equals050(ValState50 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Ref_equals075(ValState75 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Ref_equals100(ValState100 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Int_equals000(ValState00 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Int_equals025(ValState25 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Int_equals050(ValState50 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Int_equals075(ValState75 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Int_equals100(ValState100 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Obj_equals000(ValState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Obj_equals025(ValState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Obj_equals050(ValState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Obj_equals075(ValState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_as_Obj_equals100(ValState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/InlineIsCmpBranch64long.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.BitSet;\n+import java.util.Random;\n+\n+public class StatesQ64byte {\n+\n+    public static final int SIZE = 100;\n+\n+    private static BitSet indices(Random rnd, int bound, int size) {\n+        return rnd.ints(0, bound)\n+                .distinct()\n+                .limit(size)\n+                .collect(BitSet::new, BitSet::set, BitSet::or);\n+    }\n+\n+    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n+        BitSet eqset = (eq > 0 && eq < 100) ? indices(new Random(42), SIZE, (eq * SIZE) \/ 100) : null;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (eq > 0 && (eq >= 100 || eqset.get(i))) {\n+                arr2[i] = arr1[i] = new Q64byte(i);\n+            } else {\n+                arr1[i] = new Q64byte(2 * i);\n+                arr2[i] = new Q64byte(2 * i + 1);\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class ObjState {\n+        Object[] arr1, arr2;\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class IntState {\n+        Int64[] arr1, arr2;\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class RefState {\n+        Q64byte[] arr1, arr2;\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class ValState {\n+        Q64byte[] arr1, arr2;\n+    }\n+\n+    public static class ObjState00 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+\n+    }\n+\n+    public static class ObjState25 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+\n+    }\n+\n+    public static class ObjState50 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+\n+    }\n+\n+    public static class ObjState75 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+\n+    }\n+\n+    public static class ObjState100 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class IntState00 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class IntState25 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class IntState50 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class IntState75 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class IntState100 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class RefState00 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class RefState25 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class RefState50 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class RefState75 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class RefState100 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class ValState00 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class ValState25 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class ValState50 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class ValState75 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class ValState100 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64byte[SIZE];\n+            arr2 = new Q64byte[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/StatesQ64byte.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.BitSet;\n+import java.util.Random;\n+\n+public class StatesQ64long {\n+\n+    public static final int SIZE = 100;\n+\n+    private static BitSet indices(Random rnd, int bound, int size) {\n+        return rnd.ints(0, bound)\n+                .distinct()\n+                .limit(size)\n+                .collect(BitSet::new, BitSet::set, BitSet::or);\n+    }\n+\n+    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n+        BitSet eqset = (eq > 0 && eq < 100) ? indices(new Random(42), SIZE, (eq * SIZE) \/ 100) : null;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (eq > 0 && (eq >= 100 || eqset.get(i))) {\n+                arr2[i] = arr1[i] = new Q64long(i);\n+            } else {\n+                arr1[i] = new Q64long(2 * i);\n+                arr2[i] = new Q64long(2 * i + 1);\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class ObjState {\n+        Object[] arr1, arr2;\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class IntState {\n+        Int64[] arr1, arr2;\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class RefState {\n+        Q64long[] arr1, arr2;\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class ValState {\n+        Q64long[] arr1, arr2;\n+    }\n+\n+    public static class ObjState00 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+\n+    }\n+\n+    public static class ObjState25 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+\n+    }\n+\n+    public static class ObjState50 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+\n+    }\n+\n+    public static class ObjState75 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+\n+    }\n+\n+    public static class ObjState100 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class IntState00 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class IntState25 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class IntState50 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class IntState75 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class IntState100 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Int64[SIZE];\n+            arr2 = new Int64[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class RefState00 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class RefState25 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class RefState50 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class RefState75 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class RefState100 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class ValState00 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class ValState25 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class ValState50 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class ValState75 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class ValState100 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Q64long[SIZE];\n+            arr2 = new Q64long[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/StatesQ64long.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.array;\n+\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.BitSet;\n+import java.util.Random;\n+\n+public class StatesR64long {\n+\n+    public static final int SIZE = 100;\n+\n+    private static BitSet indices(Random rnd, int bound, int size) {\n+        return rnd.ints(0, bound)\n+                .distinct()\n+                .limit(size)\n+                .collect(BitSet::new, BitSet::set, BitSet::or);\n+    }\n+\n+    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n+        BitSet eqset = (eq > 0 && eq < 100) ? indices(new Random(42), SIZE, (eq * SIZE) \/ 100) : null;\n+        int samenulls = 0;\n+        int distinctnulls = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (eq > 0 && (eq >= 100 || eqset.get(i))) {\n+                if (samenulls > 0) {\n+                    arr2[i] = arr1[i] = new R64long(i);\n+                } else {\n+                    arr2[i] = arr1[i] = null;\n+                    samenulls++;\n+                }\n+            } else {\n+                if (distinctnulls > 1) {\n+                    arr1[i] = new R64long(2 * i);\n+                    arr2[i] = new R64long(2 * i + 1);\n+                } else {\n+                    if (distinctnulls == 0) {\n+                        arr1[i] = null;\n+                        arr2[i] = new R64long(2 * i + 1);\n+                    } else {\n+                        arr1[i] = new R64long(2 * i);\n+                        arr2[i] = null;\n+                    }\n+                    distinctnulls++;\n+                }\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class ObjState {\n+        Object[] arr1, arr2;\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class RefState {\n+        R64long[] arr1, arr2;\n+    }\n+\n+    public static class ObjState00 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+\n+    }\n+\n+    public static class ObjState25 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+\n+    }\n+\n+    public static class ObjState50 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+\n+    }\n+\n+    public static class ObjState75 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+\n+    }\n+\n+    public static class ObjState100 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new Object[SIZE];\n+            arr2 = new Object[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class RefState00 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new R64long[SIZE];\n+            arr2 = new R64long[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class RefState25 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new R64long[SIZE];\n+            arr2 = new R64long[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class RefState50 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new R64long[SIZE];\n+            arr2 = new R64long[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class RefState75 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new R64long[SIZE];\n+            arr2 = new R64long[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class RefState100 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new R64long[SIZE];\n+            arr2 = new R64long[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/StatesR64long.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -1,398 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.array;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.array.Value  -wmb \"org.openjdk.bench.valhalla.acmp.array.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value032 {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_obj(Object[] objects1, Object[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValueInt[] objects1, ValueInt[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValueInt[] objects1, ValueInt[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_obj(Object[] objects1, Object[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals000(ObjState00 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals025(ObjState25 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals050(ObjState50 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals075(ObjState75 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals100(ObjState100 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals000(ObjState00 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals025(ObjState25 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals050(ObjState50 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals075(ObjState75 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals100(ObjState100 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt {\n-\n-        public final int v0;\n-\n-        public ValueInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = null;\n-            arr2[0] = new ValueInt(1);\n-            arr1[1] = new ValueInt(2);\n-            arr2[1] = null;\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new ValueInt(2 * i);\n-                arr2[i] = new ValueInt(2 * i + 1);\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = null;\n-            for (int i = 1; i < SIZE; i++) {\n-                arr2[i] = arr1[i] = new ValueInt(i);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = arr1[i] = null;\n-                        samenulls = false;\n-                    } else {\n-                        arr2[i] = arr1[i] = new ValueInt(i);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = null;\n-                            arr2[i] = new ValueInt(2 * i + 1);\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new ValueInt(2 * i);\n-                            arr2[i] = null;\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new ValueInt(2 * i);\n-                            arr2[i] = new ValueInt(2 * i + 1);\n-                            break;\n-                    }\n-                }\n-            }\n-\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ObjState {\n-        Object[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new Object[SIZE];\n-            arr2 = new Object[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValueInt[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValueInt[SIZE];\n-            arr2 = new ValueInt[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ObjState00 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ObjState25 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ObjState50 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ObjState75 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ObjState100 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/Value032.java","additions":0,"deletions":398,"binary":false,"changes":398,"status":"deleted"},{"patch":"@@ -1,233 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.array;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.array.Value  -wmb \"org.openjdk.bench.valhalla.acmp.array.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value032NullFree {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValueInt[] objects1, ValueInt[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValueInt[] objects1, ValueInt[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt {\n-\n-        public final int v0;\n-\n-        public ValueInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValueInt(2 * i);\n-                arr2[i] = new ValueInt(2 * i + 1);\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr2[i] = arr1[i] = new ValueInt(i);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    arr2[i] = arr1[i] = new ValueInt(i);\n-                } else {\n-                    arr1[i] = new ValueInt(2 * i);\n-                    arr2[i] = new ValueInt(2 * i + 1);\n-                }\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValueInt[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = (ValueInt[]) ValueClass.newNullRestrictedAtomicArray(ValueInt.class, SIZE, new ValueInt(0));\n-            arr2 = (ValueInt[]) ValueClass.newNullRestrictedAtomicArray(ValueInt.class, SIZE, new ValueInt(0));\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/Value032NullFree.java","additions":0,"deletions":233,"binary":false,"changes":233,"status":"deleted"},{"patch":"@@ -1,235 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.array;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.array.Value  -wmb \"org.openjdk.bench.valhalla.acmp.array.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value032NullFreeNonAtomic {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValueInt[] objects1, ValueInt[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValueInt[] objects1, ValueInt[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt {\n-\n-        public final int v0;\n-\n-        public ValueInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValueInt(2 * i);\n-                arr2[i] = new ValueInt(2 * i + 1);\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr2[i] = arr1[i] = new ValueInt(i);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    arr2[i] = arr1[i] = new ValueInt(i);\n-                } else {\n-                    arr1[i] = new ValueInt(2 * i);\n-                    arr2[i] = new ValueInt(2 * i + 1);\n-                }\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValueInt[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = (ValueInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, SIZE, new ValueInt(0));\n-            arr2 = (ValueInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, SIZE, new ValueInt(0));\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/Value032NullFreeNonAtomic.java","additions":0,"deletions":235,"binary":false,"changes":235,"status":"deleted"},{"patch":"@@ -1,400 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.array;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.array.Value  -wmb \"org.openjdk.bench.valhalla.acmp.array.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value128 {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_obj(Object[] objects1, Object[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValueInt4[] objects1, ValueInt4[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValueInt4[] objects1, ValueInt4[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_obj(Object[] objects1, Object[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals000(ObjState00 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals025(ObjState25 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals050(ObjState50 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals075(ObjState75 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals100(ObjState100 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals000(ObjState00 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals025(ObjState25 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals050(ObjState50 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals075(ObjState75 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals100(ObjState100 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt4 {\n-\n-        public final int v0;\n-        public final int v1;\n-        public final int v2;\n-        public final int v3;\n-\n-        public ValueInt4(int v) {\n-            this.v0 = v;\n-            this.v1 = v + 1;\n-            this.v2 = v + 2;\n-            this.v3 = v + 3;\n-        }\n-\n-    }\n-\n-    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = null;\n-            arr2[0] = new ValueInt4(1);\n-            arr1[1] = new ValueInt4(2);\n-            arr2[1] = null;\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new ValueInt4(2 * i);\n-                arr2[i] = new ValueInt4(2 * i + 1);\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = null;\n-            for (int i = 1; i < SIZE; i++) {\n-                arr2[i] = arr1[i] = new ValueInt4(i);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = arr1[i] = null;\n-                        samenulls = false;\n-                    } else {\n-                        arr2[i] = arr1[i] = new ValueInt4(i);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = null;\n-                            arr2[i] = new ValueInt4(2 * i + 1);\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new ValueInt4(2 * i);\n-                            arr2[i] = null;\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new ValueInt4(2 * i);\n-                            arr2[i] = new ValueInt4(2 * i + 1);\n-                            break;\n-                    }\n-                }\n-            }\n-\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ObjState {\n-        Object[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new Object[SIZE];\n-            arr2 = new Object[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValueInt4[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValueInt4[SIZE];\n-            arr2 = new ValueInt4[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ObjState00 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ObjState25 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ObjState50 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ObjState75 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ObjState100 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/Value128.java","additions":0,"deletions":400,"binary":false,"changes":400,"status":"deleted"},{"patch":"@@ -1,235 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.array;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.array.Value  -wmb \"org.openjdk.bench.valhalla.acmp.array.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value128NullFree {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValueInt4[] objects1, ValueInt4[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValueInt4[] objects1, ValueInt4[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt4 {\n-\n-        public final int v0;\n-        public final int v1;\n-        public final int v2;\n-        public final int v3;\n-\n-        public ValueInt4(int v) {\n-            this.v0 = v;\n-            this.v1 = v + 1;\n-            this.v2 = v + 2;\n-            this.v3 = v + 3;\n-        }\n-\n-    }\n-\n-    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValueInt4(2 * i);\n-                arr2[i] = new ValueInt4(2 * i + 1);\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr2[i] = arr1[i] = new ValueInt4(i);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    arr2[i] = arr1[i] = new ValueInt4(i);\n-                } else {\n-                    arr1[i] = new ValueInt4(2 * i);\n-                    arr2[i] = new ValueInt4(2 * i + 1);\n-                }\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValueInt4[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, SIZE, new ValueInt4(0));\n-            arr2 = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, SIZE, new ValueInt4(0));\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/Value128NullFree.java","additions":0,"deletions":235,"binary":false,"changes":235,"status":"deleted"},{"patch":"@@ -1,237 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.array;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.array.Value  -wmb \"org.openjdk.bench.valhalla.acmp.array.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value128NullFreeNonAtomic {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValueInt4[] objects1, ValueInt4[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i] == objects2[i]) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValueInt4[] objects1, ValueInt4[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i] == objects2[i];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 {\n-\n-        public final int v0;\n-        public final int v1;\n-        public final int v2;\n-        public final int v3;\n-\n-        public ValueInt4(int v) {\n-            this.v0 = v;\n-            this.v1 = v + 1;\n-            this.v2 = v + 2;\n-            this.v3 = v + 3;\n-        }\n-\n-    }\n-\n-    private static void populate(Object[] arr1, Object[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValueInt4(2 * i);\n-                arr2[i] = new ValueInt4(2 * i + 1);\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr2[i] = arr1[i] = new ValueInt4(i);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    arr2[i] = arr1[i] = new ValueInt4(i);\n-                } else {\n-                    arr1[i] = new ValueInt4(2 * i);\n-                    arr2[i] = new ValueInt4(2 * i + 1);\n-                }\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValueInt4[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, SIZE, new ValueInt4(0));\n-            arr2 = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, SIZE, new ValueInt4(0));\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/array\/Value128NullFreeNonAtomic.java","additions":0,"deletions":237,"binary":false,"changes":237,"status":"deleted"},{"patch":"@@ -1,473 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.field;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.field.Identity  -wmb \"org.openjdk.bench.valhalla.acmp.field.Identity.*050\"\n- *\/\n-\n-@Fork(3)\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Identity {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_obj(ObjWrapper[] objects1, ObjWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_ref(RefWrapper[] objects1, RefWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_ref(RefWrapper[] objects1, RefWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_obj(ObjWrapper[] objects1, ObjWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals000(ObjState00 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals025(ObjState25 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals050(ObjState50 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals075(ObjState75 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals100(ObjState100 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals000(RefState00 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals025(RefState25 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals050(RefState50 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals075(RefState75 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_ref_equals100(RefState100 st) {\n-        return cmp_branch_ref(st.arr1, st.arr2);\n-    }\n-\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals000(ObjState00 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals025(ObjState25 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals050(ObjState50 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals075(ObjState75 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals100(ObjState100 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals000(RefState00 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals025(RefState25 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals050(RefState50 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals075(RefState75 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_ref_equals100(RefState100 st) {\n-        return cmp_result_ref(st.arr1, st.arr2);\n-    }\n-\n-    public static class IdentityInt {\n-\n-        public final int v0;\n-\n-        public IdentityInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(ObjWrapper[] arr1, ObjWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = new ObjWrapper(null);\n-            arr2[0] = new ObjWrapper(new IdentityInt(1));\n-            arr1[1] = new ObjWrapper(new IdentityInt(2));\n-            arr2[1] = new ObjWrapper(null);\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new ObjWrapper(new IdentityInt(2 * i));\n-                arr2[i] = new ObjWrapper(new IdentityInt(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = new ObjWrapper(null);\n-            for (int i = 1; i < SIZE; i++) {\n-                IdentityInt x = new IdentityInt(i);\n-                arr2[i] = new ObjWrapper(x);\n-                arr1[i] = new ObjWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = new ObjWrapper(null);\n-                        arr1[i] = new ObjWrapper(null);\n-                        samenulls = false;\n-                    } else {\n-                        IdentityInt x = new IdentityInt(i);\n-                        arr2[i] = new ObjWrapper(x);\n-                        arr1[i] = new ObjWrapper(x);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = new ObjWrapper(null);\n-                            arr2[i] = new ObjWrapper(new IdentityInt(2 * i + 1));\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new ObjWrapper(new IdentityInt(2 * i));\n-                            arr2[i] = new ObjWrapper(null);\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new ObjWrapper(new IdentityInt(2 * i));\n-                            arr2[i] = new ObjWrapper(new IdentityInt(2 * i + 1));\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    private static void populate(RefWrapper[] arr1, RefWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = new RefWrapper(null);\n-            arr2[0] = new RefWrapper(new IdentityInt(1));\n-            arr1[1] = new RefWrapper(new IdentityInt(2));\n-            arr2[1] = new RefWrapper(null);\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new RefWrapper(new IdentityInt(2 * i));\n-                arr2[i] = new RefWrapper(new IdentityInt(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = new RefWrapper(null);\n-            for (int i = 1; i < SIZE; i++) {\n-                IdentityInt x = new IdentityInt(i);\n-                arr2[i] = new RefWrapper(x);\n-                arr1[i] = new RefWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = new RefWrapper(null);\n-                        arr1[i] = new RefWrapper(null);\n-                        samenulls = false;\n-                    } else {\n-                        IdentityInt x = new IdentityInt(i);\n-                        arr2[i] = new RefWrapper(x);\n-                        arr1[i] = new RefWrapper(x);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = new RefWrapper(null);\n-                            arr2[i] = new RefWrapper(new IdentityInt(2 * i + 1));\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new RefWrapper(new IdentityInt(2 * i));\n-                            arr2[i] = new RefWrapper(null);\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new RefWrapper(new IdentityInt(2 * i));\n-                            arr2[i] = new RefWrapper(new IdentityInt(2 * i + 1));\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class ObjWrapper {\n-        public final Object f;\n-\n-        public ObjWrapper(Object f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class RefWrapper {\n-        public final IdentityInt f;\n-\n-        public RefWrapper(IdentityInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ObjState {\n-        ObjWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ObjWrapper[SIZE];\n-            arr2 = new ObjWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class RefState {\n-        RefWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new RefWrapper[SIZE];\n-            arr2 = new RefWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ObjState00 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ObjState25 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ObjState50 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ObjState75 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ObjState100 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-    public static class RefState00 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class RefState25 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class RefState50 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class RefState75 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class RefState100 extends RefState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/Identity.java","additions":0,"deletions":473,"binary":false,"changes":473,"status":"deleted"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.field;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ *  For proper results it should be executed:\n+ *  java -jar target\/benchmarks.jar baseline.acmp.IsCmpBranch  -wmb baseline.acmp.IsCmpBranch.equals050\n+ *\/\n+\n+@Fork(3)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineIsCmpBranch64long extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Obj(ObjWrapper[] objects1, ObjWrapper[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i].f == objects2[i].f) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Int(IntWrapper[] objects1, IntWrapper[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i].f == objects2[i].f) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Ref(RefWrapper[] objects1, RefWrapper[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i].f == objects2[i].f) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static int cmp_Val(ValWrapper[] objects1, ValWrapper[] objects2) {\n+        int s = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (objects1[i].f == objects2[i].f) {\n+                s += 1;\n+            } else {\n+                s -= 1;\n+            }\n+        }\n+        return s;\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals000(ObjState00 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals025(ObjState25 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals050(ObjState50 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals075(ObjState75 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Obj_equals100(ObjState100 st) {\n+        return cmp_Obj(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals000(IntState00 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals025(IntState25 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals050(IntState50 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals075(IntState75 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Int_equals100(IntState100 st) {\n+        return cmp_Int(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals000(RefState00 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals025(RefState25 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals050(RefState50 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals075(RefState75 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Ref_equals100(RefState100 st) {\n+        return cmp_Ref(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals000(ValState00 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals025(ValState25 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals050(ValState50 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals075(ValState75 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int Val_equals100(ValState100 st) {\n+        return cmp_Val(st.arr1, st.arr2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/InlineIsCmpBranch64long.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.field;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.BitSet;\n+import java.util.Random;\n+\n+public class StatesQ64long {\n+\n+    public static final int SIZE = 100;\n+\n+    private static BitSet indices(Random rnd, int bound, int size) {\n+        return rnd.ints(0, bound)\n+                .distinct()\n+                .limit(size)\n+                .collect(BitSet::new, BitSet::set, BitSet::or);\n+    }\n+\n+    private static void populate(ObjWrapper[] arr1, ObjWrapper[] arr2, int eq) {\n+        BitSet eqset = (eq > 0 && eq < 100) ? indices(new Random(42), SIZE, (eq * SIZE) \/ 100) : null;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (eq > 0 && (eq >= 100 || eqset.get(i))) {\n+                arr2[i] = arr1[i] = new ObjWrapper(new Q64long(i));\n+            } else {\n+                arr1[i] = new ObjWrapper(new Q64long(2 * i));\n+                arr2[i] = new ObjWrapper(new Q64long(2 * i + 1));\n+            }\n+        }\n+    }\n+\n+    private static void populate(IntWrapper[] arr1, IntWrapper[] arr2, int eq) {\n+        BitSet eqset = (eq > 0 && eq < 100) ? indices(new Random(42), SIZE, (eq * SIZE) \/ 100) : null;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (eq > 0 && (eq >= 100 || eqset.get(i))) {\n+                arr2[i] = arr1[i] = new IntWrapper(new Q64long(i));\n+            } else {\n+                arr1[i] = new IntWrapper(new Q64long(2 * i));\n+                arr2[i] = new IntWrapper(new Q64long(2 * i + 1));\n+            }\n+        }\n+    }\n+\n+    private static void populate(RefWrapper[] arr1, RefWrapper[] arr2, int eq) {\n+        BitSet eqset = (eq > 0 && eq < 100) ? indices(new Random(42), SIZE, (eq * SIZE) \/ 100) : null;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (eq > 0 && (eq >= 100 || eqset.get(i))) {\n+                arr2[i] = arr1[i] = new RefWrapper(new Q64long(i));\n+            } else {\n+                arr1[i] = new RefWrapper(new Q64long(2 * i));\n+                arr2[i] = new RefWrapper(new Q64long(2 * i + 1));\n+            }\n+        }\n+    }\n+\n+    private static void populate(ValWrapper[] arr1, ValWrapper[] arr2, int eq) {\n+        BitSet eqset = (eq > 0 && eq < 100) ? indices(new Random(42), SIZE, (eq * SIZE) \/ 100) : null;\n+        for (int i = 0; i < SIZE; i++) {\n+            if (eq > 0 && (eq >= 100 || eqset.get(i))) {\n+                arr2[i] = arr1[i] = new ValWrapper(new Q64long(i));\n+            } else {\n+                arr1[i] = new ValWrapper(new Q64long(2 * i));\n+                arr2[i] = new ValWrapper(new Q64long(2 * i + 1));\n+            }\n+        }\n+    }\n+\n+    public static class ObjWrapper {\n+        public Object f;\n+\n+        public ObjWrapper(Object f) {\n+            this.f = f;\n+        }\n+    }\n+\n+\n+    @State(Scope.Thread)\n+    public abstract static class ObjState {\n+        ObjWrapper[] arr1, arr2;\n+    }\n+\n+    public static class IntWrapper {\n+        public Int64 f;\n+\n+        public IntWrapper(Int64 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public abstract static class IntState {\n+        IntWrapper[] arr1, arr2;\n+    }\n+\n+    public static class RefWrapper {\n+        public Q64long f;\n+\n+        public RefWrapper(Q64long f) {\n+            this.f = f;\n+        }\n+    }\n+\n+\n+    @State(Scope.Thread)\n+    public abstract static class RefState {\n+        RefWrapper[] arr1, arr2;\n+    }\n+\n+    public static class ValWrapper {\n+        public Q64long f;\n+\n+        public ValWrapper(Q64long f) {\n+            this.f = f;\n+        }\n+    }\n+\n+\n+    @State(Scope.Thread)\n+    public abstract static class ValState {\n+        ValWrapper[] arr1, arr2;\n+    }\n+\n+    public static class ObjState00 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ObjWrapper[SIZE];\n+            arr2 = new ObjWrapper[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+\n+    }\n+\n+    public static class ObjState25 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ObjWrapper[SIZE];\n+            arr2 = new ObjWrapper[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+\n+    }\n+\n+    public static class ObjState50 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ObjWrapper[SIZE];\n+            arr2 = new ObjWrapper[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+\n+    }\n+\n+    public static class ObjState75 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ObjWrapper[SIZE];\n+            arr2 = new ObjWrapper[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+\n+    }\n+\n+    public static class ObjState100 extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ObjWrapper[SIZE];\n+            arr2 = new ObjWrapper[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class IntState00 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new IntWrapper[SIZE];\n+            arr2 = new IntWrapper[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class IntState25 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new IntWrapper[SIZE];\n+            arr2 = new IntWrapper[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class IntState50 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new IntWrapper[SIZE];\n+            arr2 = new IntWrapper[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class IntState75 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new IntWrapper[SIZE];\n+            arr2 = new IntWrapper[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class IntState100 extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new IntWrapper[SIZE];\n+            arr2 = new IntWrapper[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class RefState00 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new RefWrapper[SIZE];\n+            arr2 = new RefWrapper[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class RefState25 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new RefWrapper[SIZE];\n+            arr2 = new RefWrapper[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class RefState50 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new RefWrapper[SIZE];\n+            arr2 = new RefWrapper[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class RefState75 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new RefWrapper[SIZE];\n+            arr2 = new RefWrapper[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class RefState100 extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new RefWrapper[SIZE];\n+            arr2 = new RefWrapper[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+    public static class ValState00 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ValWrapper[SIZE];\n+            arr2 = new ValWrapper[SIZE];\n+            populate(arr1, arr2, 0);\n+        }\n+    }\n+\n+    public static class ValState25 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ValWrapper[SIZE];\n+            arr2 = new ValWrapper[SIZE];\n+            populate(arr1, arr2, 25);\n+        }\n+    }\n+\n+    public static class ValState50 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ValWrapper[SIZE];\n+            arr2 = new ValWrapper[SIZE];\n+            populate(arr1, arr2, 50);\n+        }\n+    }\n+\n+    public static class ValState75 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ValWrapper[SIZE];\n+            arr2 = new ValWrapper[SIZE];\n+            populate(arr1, arr2, 75);\n+        }\n+    }\n+\n+    public static class ValState100 extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr1 = new ValWrapper[SIZE];\n+            arr2 = new ValWrapper[SIZE];\n+            populate(arr1, arr2, 100);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/StatesQ64long.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -1,473 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.field;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.field.Value  -wmb \"org.openjdk.bench.valhalla.acmp.field.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value032 {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_obj(ObjWrapper[] objects1, ObjWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_obj(ObjWrapper[] objects1, ObjWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals000(ObjState00 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals025(ObjState25 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals050(ObjState50 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals075(ObjState75 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals100(ObjState100 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals000(ObjState00 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals025(ObjState25 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals050(ObjState50 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals075(ObjState75 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals100(ObjState100 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt {\n-\n-        public final int v0;\n-\n-        public ValueInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(ObjWrapper[] arr1, ObjWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = new ObjWrapper(null);\n-            arr2[0] = new ObjWrapper(new ValueInt(1));\n-            arr1[1] = new ObjWrapper(new ValueInt(2));\n-            arr2[1] = new ObjWrapper(null);\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new ObjWrapper(new ValueInt(2 * i));\n-                arr2[i] = new ObjWrapper(new ValueInt(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = new ObjWrapper(null);\n-            for (int i = 1; i < SIZE; i++) {\n-                ValueInt x = new ValueInt(i);\n-                arr2[i] = new ObjWrapper(x);\n-                arr1[i] = new ObjWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = new ObjWrapper(null);\n-                        arr1[i] = new ObjWrapper(null);\n-                        samenulls = false;\n-                    } else {\n-                        ValueInt x = new ValueInt(i);\n-                        arr2[i] = new ObjWrapper(x);\n-                        arr1[i] = new ObjWrapper(x);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = new ObjWrapper(null);\n-                            arr2[i] = new ObjWrapper(new ValueInt(2 * i + 1));\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new ObjWrapper(new ValueInt(2 * i));\n-                            arr2[i] = new ObjWrapper(null);\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new ObjWrapper(new ValueInt(2 * i));\n-                            arr2[i] = new ObjWrapper(new ValueInt(2 * i + 1));\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    private static void populate(ValWrapper[] arr1, ValWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = new ValWrapper(null);\n-            arr2[0] = new ValWrapper(new ValueInt(1));\n-            arr1[1] = new ValWrapper(new ValueInt(2));\n-            arr2[1] = new ValWrapper(null);\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new ValWrapper(new ValueInt(2 * i));\n-                arr2[i] = new ValWrapper(new ValueInt(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = new ValWrapper(null);\n-            for (int i = 1; i < SIZE; i++) {\n-                ValueInt x = new ValueInt(i);\n-                arr2[i] = new ValWrapper(x);\n-                arr1[i] = new ValWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = new ValWrapper(null);\n-                        arr1[i] = new ValWrapper(null);\n-                        samenulls = false;\n-                    } else {\n-                        ValueInt x = new ValueInt(i);\n-                        arr2[i] = new ValWrapper(x);\n-                        arr1[i] = new ValWrapper(x);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = new ValWrapper(null);\n-                            arr2[i] = new ValWrapper(new ValueInt(2 * i + 1));\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new ValWrapper(new ValueInt(2 * i));\n-                            arr2[i] = new ValWrapper(null);\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new ValWrapper(new ValueInt(2 * i));\n-                            arr2[i] = new ValWrapper(new ValueInt(2 * i + 1));\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class ObjWrapper {\n-        public Object f;\n-\n-        public ObjWrapper(Object f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ObjState {\n-        ObjWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ObjWrapper[SIZE];\n-            arr2 = new ObjWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValWrapper[SIZE];\n-            arr2 = new ValWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ObjState00 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ObjState25 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ObjState50 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ObjState75 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ObjState100 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/Value032.java","additions":0,"deletions":473,"binary":false,"changes":473,"status":"deleted"},{"patch":"@@ -1,249 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.field;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.field.Value  -wmb \"org.openjdk.bench.valhalla.acmp.field.Value.*050\"\n- *  *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value032NullFree {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt {\n-\n-        public final int v0;\n-\n-        public ValueInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(ValWrapper[] arr1, ValWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValWrapper(new ValueInt(2 * i));\n-                arr2[i] = new ValWrapper(new ValueInt(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                ValueInt x = new ValueInt(i);\n-                arr2[i] = new ValWrapper(x);\n-                arr1[i] = new ValWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    ValueInt x = new ValueInt(i);\n-                    arr2[i] = new ValWrapper(x);\n-                    arr1[i] = new ValWrapper(x);\n-                } else {\n-                    arr1[i] = new ValWrapper(new ValueInt(2 * i));\n-                    arr2[i] = new ValWrapper(new ValueInt(2 * i + 1));\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValWrapper[SIZE];\n-            arr2 = new ValWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/Value032NullFree.java","additions":0,"deletions":249,"binary":false,"changes":249,"status":"deleted"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.field;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.field.Value  -wmb \"org.openjdk.bench.valhalla.acmp.field.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value032NullFreeNonAtomic {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt {\n-\n-        public final int v0;\n-\n-        public ValueInt(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    private static void populate(ValWrapper[] arr1, ValWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValWrapper(new ValueInt(2 * i));\n-                arr2[i] = new ValWrapper(new ValueInt(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                ValueInt x = new ValueInt(i);\n-                arr2[i] = new ValWrapper(x);\n-                arr1[i] = new ValWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    ValueInt x = new ValueInt(i);\n-                    arr2[i] = new ValWrapper(x);\n-                    arr1[i] = new ValWrapper(x);\n-                } else {\n-                    arr1[i] = new ValWrapper(new ValueInt(2 * i));\n-                    arr2[i] = new ValWrapper(new ValueInt(2 * i + 1));\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValWrapper[SIZE];\n-            arr2 = new ValWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/Value032NullFreeNonAtomic.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -1,475 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.field;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.field.Value  -wmb \"org.openjdk.bench.valhalla.acmp.field.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value128 {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_obj(ObjWrapper[] objects1, ObjWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_obj(ObjWrapper[] objects1, ObjWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals000(ObjState00 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals025(ObjState25 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals050(ObjState50 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals075(ObjState75 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_obj_equals100(ObjState100 st) {\n-        return cmp_branch_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals000(ObjState00 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals025(ObjState25 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals050(ObjState50 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals075(ObjState75 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_obj_equals100(ObjState100 st) {\n-        return cmp_result_obj(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt4 {\n-\n-        public final int v0;\n-        public final int v1;\n-        public final int v2;\n-        public final int v3;\n-\n-        public ValueInt4(int v) {\n-            this.v0 = v;\n-            this.v1 = v + 1;\n-            this.v2 = v + 2;\n-            this.v3 = v + 3;\n-        }\n-\n-    }\n-\n-    private static void populate(ObjWrapper[] arr1, ObjWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = new ObjWrapper(null);\n-            arr2[0] = new ObjWrapper(new ValueInt4(1));\n-            arr1[1] = new ObjWrapper(new ValueInt4(2));\n-            arr2[1] = new ObjWrapper(null);\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new ObjWrapper(new ValueInt4(2 * i));\n-                arr2[i] = new ObjWrapper(new ValueInt4(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = new ObjWrapper(null);\n-            for (int i = 1; i < SIZE; i++) {\n-                ValueInt4 x = new ValueInt4(i);\n-                arr2[i] = new ObjWrapper(x);\n-                arr1[i] = new ObjWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = new ObjWrapper(null);\n-                        arr1[i] = new ObjWrapper(null);\n-                        samenulls = false;\n-                    } else {\n-                        ValueInt4 x = new ValueInt4(i);\n-                        arr2[i] = new ObjWrapper(x);\n-                        arr1[i] = new ObjWrapper(x);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = new ObjWrapper(null);\n-                            arr2[i] = new ObjWrapper(new ValueInt4(2 * i + 1));\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new ObjWrapper(new ValueInt4(2 * i));\n-                            arr2[i] = new ObjWrapper(null);\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new ObjWrapper(new ValueInt4(2 * i));\n-                            arr2[i] = new ObjWrapper(new ValueInt4(2 * i + 1));\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    private static void populate(ValWrapper[] arr1, ValWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            arr1[0] = new ValWrapper(null);\n-            arr2[0] = new ValWrapper(new ValueInt4(1));\n-            arr1[1] = new ValWrapper(new ValueInt4(2));\n-            arr2[1] = new ValWrapper(null);\n-            for (int i = 2; i < SIZE; i++) {\n-                arr1[i] = new ValWrapper(new ValueInt4(2 * i));\n-                arr2[i] = new ValWrapper(new ValueInt4(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            arr2[0] = arr1[0] = new ValWrapper(null);\n-            for (int i = 1; i < SIZE; i++) {\n-                ValueInt4 x = new ValueInt4(i);\n-                arr2[i] = new ValWrapper(x);\n-                arr1[i] = new ValWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            boolean samenulls = true;\n-            int distinctnulls = 0;\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    if(samenulls) {\n-                        arr2[i] = new ValWrapper(null);\n-                        arr1[i] = new ValWrapper(null);\n-                        samenulls = false;\n-                    } else {\n-                        ValueInt4 x = new ValueInt4(i);\n-                        arr2[i] = new ValWrapper(x);\n-                        arr1[i] = new ValWrapper(x);\n-                    }\n-                } else {\n-                    switch (distinctnulls) {\n-                        case 0:\n-                            arr1[i] = new ValWrapper(null);\n-                            arr2[i] = new ValWrapper(new ValueInt4(2 * i + 1));\n-                            distinctnulls = 1;\n-                            break;\n-                        case 1:\n-                            arr1[i] = new ValWrapper(new ValueInt4(2 * i));\n-                            arr2[i] = new ValWrapper(null);\n-                            distinctnulls  = 2;\n-                            break;\n-                        default:\n-                            arr1[i] = new ValWrapper(new ValueInt4(2 * i));\n-                            arr2[i] = new ValWrapper(new ValueInt4(2 * i + 1));\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class ObjWrapper {\n-        public Object f;\n-\n-        public ObjWrapper(Object f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ObjState {\n-        ObjWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ObjWrapper[SIZE];\n-            arr2 = new ObjWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValWrapper[SIZE];\n-            arr2 = new ValWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ObjState00 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ObjState25 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ObjState50 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ObjState75 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ObjState100 extends ObjState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/Value128.java","additions":0,"deletions":475,"binary":false,"changes":475,"status":"deleted"},{"patch":"@@ -1,253 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.field;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.field.Value  -wmb \"org.openjdk.bench.valhalla.acmp.field.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value128NullFree {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    public static value class ValueInt4 {\n-\n-        public final int v0;\n-        public final int v1;\n-        public final int v2;\n-        public final int v3;\n-\n-        public ValueInt4(int v) {\n-            this.v0 = v;\n-            this.v1 = v + 1;\n-            this.v2 = v + 2;\n-            this.v3 = v + 3;\n-        }\n-\n-    }\n-\n-    private static void populate(ValWrapper[] arr1, ValWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValWrapper(new ValueInt4(2 * i));\n-                arr2[i] = new ValWrapper(new ValueInt4(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                ValueInt4 x = new ValueInt4(i);\n-                arr2[i] = new ValWrapper(x);\n-                arr1[i] = new ValWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    ValueInt4 x = new ValueInt4(i);\n-                    arr2[i] = new ValWrapper(x);\n-                    arr1[i] = new ValWrapper(x);\n-                } else {\n-                    arr1[i] = new ValWrapper(new ValueInt4(2 * i));\n-                    arr2[i] = new ValWrapper(new ValueInt4(2 * i + 1));\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValWrapper[SIZE];\n-            arr2 = new ValWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/Value128NullFree.java","additions":0,"deletions":253,"binary":false,"changes":253,"status":"deleted"},{"patch":"@@ -1,253 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.field;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.BitSet;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- *  For proper results it should be executed:\n- *  java -jar target\/benchmarks.jar org.openjdk.bench.valhalla.acmp.field.Value  -wmb \"org.openjdk.bench.valhalla.acmp.field.Value.*050\"\n- *\/\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value128NullFreeNonAtomic {\n-\n-    public static final int SIZE = 100;\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int cmp_branch_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        int s = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            if (objects1[i].f == objects2[i].f) {\n-                s += 1;\n-            } else {\n-                s -= 1;\n-            }\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmp_result_val(ValWrapper[] objects1, ValWrapper[] objects2) {\n-        boolean s = false;\n-        for (int i = 0; i < SIZE; i++) {\n-            s ^= objects1[i].f == objects2[i].f;\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals000(ValState00 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals025(ValState25 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals050(ValState50 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals075(ValState75 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int branch_val_equals100(ValState100 st) {\n-        return cmp_branch_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals000(ValState00 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals025(ValState25 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals050(ValState50 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals075(ValState75 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public boolean result_val_equals100(ValState100 st) {\n-        return cmp_result_val(st.arr1, st.arr2);\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 {\n-\n-        public final int v0;\n-        public final int v1;\n-        public final int v2;\n-        public final int v3;\n-\n-        public ValueInt4(int v) {\n-            this.v0 = v;\n-            this.v1 = v + 1;\n-            this.v2 = v + 2;\n-            this.v3 = v + 3;\n-        }\n-\n-    }\n-\n-    private static void populate(ValWrapper[] arr1, ValWrapper[] arr2, int eq) {\n-        if (eq <= 0) {\n-            for (int i = 0; i < SIZE; i++) {\n-                arr1[i] = new ValWrapper(new ValueInt4(2 * i));\n-                arr2[i] = new ValWrapper(new ValueInt4(2 * i + 1));\n-            }\n-        } else if (eq >= 100) {\n-            for (int i = 0; i < SIZE; i++) {\n-                ValueInt4 x = new ValueInt4(i);\n-                arr2[i] = new ValWrapper(x);\n-                arr1[i] = new ValWrapper(x);\n-            }\n-        } else {\n-            BitSet eqset = new Random(42).ints(0, SIZE).distinct().limit(eq * SIZE \/ 100).collect(BitSet::new, BitSet::set, BitSet::or);\n-            for (int i = 0; i < SIZE; i++) {\n-                if (eqset.get(i)) {\n-                    ValueInt4 x = new ValueInt4(i);\n-                    arr2[i] = new ValWrapper(x);\n-                    arr1[i] = new ValWrapper(x);\n-                } else {\n-                    arr1[i] = new ValWrapper(new ValueInt4(2 * i));\n-                    arr2[i] = new ValWrapper(new ValueInt4(2 * i + 1));\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public abstract static class ValState {\n-        ValWrapper[] arr1, arr2;\n-\n-        public void setup(int eq) {\n-            arr1 = new ValWrapper[SIZE];\n-            arr2 = new ValWrapper[SIZE];\n-            populate(arr1, arr2, eq);\n-        }\n-    }\n-\n-    public static class ValState00 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(0);\n-        }\n-    }\n-\n-    public static class ValState25 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(25);\n-        }\n-    }\n-\n-    public static class ValState50 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(50);\n-        }\n-    }\n-\n-    public static class ValState75 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(75);\n-        }\n-    }\n-\n-    public static class ValState100 extends ValState {\n-        @Setup\n-        public void setup() {\n-            setup(100);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/field\/Value128NullFreeNonAtomic.java","additions":0,"deletions":253,"binary":false,"changes":253,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.trivial;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- * to provide proper measurement the benchmark have to be executed in two modes:\n- *  -wm INDI\n- *  -wm BULK\n- *\/\n-@Fork(1)\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Identity {\n-\n-    Object o1 = new IdentityLong(1);\n-    Object o2 = new IdentityLong(2);\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmpEquals(Object a, Object b) {\n-        return a == b;     }\n-\n-    @Benchmark\n-    public boolean isCmp_null_null() {\n-        return cmpEquals(null, null);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_o1_null() {\n-        return cmpEquals(o1, null);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_null_o1() {\n-        return cmpEquals(null, o1);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_o1_o1() {\n-        return cmpEquals(o1, o1);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_o1_o2() {\n-        return cmpEquals(o1, o2);\n-    }\n-\n-    public static class IdentityLong {\n-\n-        public final long v0;\n-\n-        public IdentityLong(long v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public long value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/trivial\/Identity.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.trivial;\n+\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * to provide proper measurement the benchmark have to be executed in two modes:\n+ *  -wm INDI\n+ *  -wm BULK\n+ *\/\n+@Fork(1)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityTrivialEquals {\n+\n+    Object o1 = new R64long(1);\n+    Object o2 = new R64long(2);\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static boolean cmpEquals(Object a, Object b) {\n+        return a == b;     }\n+\n+    @Benchmark\n+    public boolean isCmp_null_null() {\n+        return cmpEquals(null, null);\n+    }\n+\n+    @Benchmark\n+    public boolean isCmp_o1_null() {\n+        return cmpEquals(o1, null);\n+    }\n+\n+    @Benchmark\n+    public boolean isCmp_null_o1() {\n+        return cmpEquals(null, o1);\n+    }\n+\n+    @Benchmark\n+    public boolean isCmp_o1_o1() {\n+        return cmpEquals(o1, o1);\n+    }\n+\n+    @Benchmark\n+    public boolean isCmp_o1_o2() {\n+        return cmpEquals(o1, o2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/trivial\/IdentityTrivialEquals.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.acmp.trivial;\n+\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * to provide proper measurement the benchmark have to be executed in two modes:\n+ *  -wm INDI\n+ *  -wm BULK\n+ *\/\n+\n+@Fork(1)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityTrivialNotEquals {\n+\n+    Object o1 = new R64long(1);\n+    Object o2 = new R64long(2);\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private static boolean cmpNotEquals(Object a, Object b) {\n+        return a != b; \/\/ new acmp\n+    }\n+\n+    @Benchmark\n+    public boolean isNotCmp_null_null() {\n+        return cmpNotEquals(null, null);\n+    }\n+\n+    @Benchmark\n+    public boolean isNotCmp_o1_null() {\n+        return cmpNotEquals(o1, null);\n+    }\n+\n+    @Benchmark\n+    public boolean isNotCmp_null_o1() {\n+        return cmpNotEquals(null, o1);\n+    }\n+\n+    @Benchmark\n+    public boolean isNotCmp_o1_o1() {\n+        return cmpNotEquals(o1, o1);\n+    }\n+\n+    @Benchmark\n+    public boolean isNotCmp_o1_o2() {\n+        return cmpNotEquals(o1, o2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/trivial\/IdentityTrivialNotEquals.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.acmp.trivial;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-\/*\n- * to provide proper measurement the benchmark have to be executed in two modes:\n- *  -wm INDI\n- *  -wm BULK\n- *\/\n-@Fork(value = 1, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value {\n-\n-    Object o1 = new ValueLong(1);\n-    Object o2 = new ValueLong(2);\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static boolean cmpEquals(Object a, Object b) {\n-        return a == b;     }\n-\n-    @Benchmark\n-    public boolean isCmp_null_null() {\n-        return cmpEquals(null, null);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_o1_null() {\n-        return cmpEquals(o1, null);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_null_o1() {\n-        return cmpEquals(null, o1);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_o1_o1() {\n-        return cmpEquals(o1, o1);\n-    }\n-\n-    @Benchmark\n-    public boolean isCmp_o1_o2() {\n-        return cmpEquals(o1, o2);\n-    }\n-\n-    public static value class ValueLong {\n-\n-        public final long v0;\n-\n-        public ValueLong(long v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public long value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/acmp\/trivial\/Value.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class CopyBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/CopyBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Identity extends CopyBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public IdentityInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_ref(IdentityInt[] dst, IdentityInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_ref(IdentityInt[] dst, IdentityInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_ref_as_ref(RefState st1, RefState st2) {\n-        copy_ref(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_ref_as_ref(RefState st1, RefState st2) {\n-        arraycopy_ref(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Identity.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesR32int;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Identity32int extends StatesR32int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        R32int[] src = s.arr;\n+        R32int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_arraycopy(Ref_as_Ref s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Identity32int.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ128int;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        Q128int[] src = s.arr;\n+        Q128int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_arraycopy(Val_as_Val s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        Q128int[] src = s.arr;\n+        Q128int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_arraycopy(Ref_as_Ref s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        Q128int[] src = s.arr;\n+        Q128int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_arraycopy(Val_as_Val s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Inline128int.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ32int;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        Q32int[] src = s.arr;\n+        Q32int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_arraycopy(Val_as_Val s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        Q32int[] src = s.arr;\n+        Q32int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_arraycopy(Ref_as_Ref s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        Q32int[] src = s.arr;\n+        Q32int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_arraycopy(Val_as_Val s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Inline32int.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64byte;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        Q64byte[] src = s.arr;\n+        Q64byte[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_arraycopy(Val_as_Val s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        Q64byte[] src = s.arr;\n+        Q64byte[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_arraycopy(Ref_as_Ref s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        Q64byte[] src = s.arr;\n+        Q64byte[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_arraycopy(Val_as_Val s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Inline64byte.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64int;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        Q64int[] src = s.arr;\n+        Q64int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_arraycopy(Val_as_Val s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        Q64int[] src = s.arr;\n+        Q64int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_arraycopy(Ref_as_Ref s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        Q64int[] src = s.arr;\n+        Q64int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_arraycopy(Val_as_Val s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Inline64int.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQOpt;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.QOpt;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class InlineOpt extends StatesQOpt {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        QOpt<Int32>[] src = s.arr;\n+        QOpt<Int32>[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_arraycopy(Val_as_Val s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        QOpt<Int32>[] src = s.arr;\n+        QOpt<Int32>[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_arraycopy(Ref_as_Ref s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        QOpt<Int32>[] src = s.arr;\n+        QOpt<Int32>[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_arraycopy(Val_as_Val s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/InlineOpt.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Primitive032 extends CopyBase {\n-\n-    public static class PrimitiveState extends SizeState {\n-        public int[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = i;\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void copy_primitive(int[] dst, int[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void arraycopy_primitive(int[] dst, int[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy(PrimitiveState st1, PrimitiveState st2) {\n-        copy_primitive(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy(PrimitiveState st1, PrimitiveState st2) {\n-        arraycopy_primitive(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Primitive032.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive128 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p128int_copy(Primitive128int s, Primitive128int d) {\n+        int[] src = s.arr;\n+        int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p128int_arraycopy(Primitive128int s, Primitive128int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Primitive128.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive32 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p32int_copy(Primitive32int s, Primitive32int d) {\n+        int[] src = s.arr;\n+        int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p32int_arraycopy(Primitive32int s, Primitive32int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Primitive32.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.copy;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64byte_copy(Primitive64byte s, Primitive64byte d) {\n+        byte[] src = s.arr;\n+        byte[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64byte_arraycopy(Primitive64byte s, Primitive64byte d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64int_copy(Primitive64int s, Primitive64int d) {\n+        int[] src = s.arr;\n+        int[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64int_arraycopy(Primitive64int s, Primitive64int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64long_copy(Primitive64long s, Primitive64long d) {\n+        long[] src = s.arr;\n+        long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64long_arraycopy(Primitive64long s, Primitive64long d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Primitive64.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends CopyBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueInt[] dst, ValueInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueInt[] dst, ValueInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Value032.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFree extends CopyBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueInt[] dst, ValueInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueInt[] dst, ValueInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Value032NullFree.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFreeNonAtomic extends CopyBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueInt[] dst, ValueInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueInt[] dst, ValueInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Value032NullFreeNonAtomic.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends CopyBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueInt4[] dst, ValueInt4[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueInt4[] dst, ValueInt4[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Value128.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFree extends CopyBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueInt4[] dst, ValueInt4[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueInt4[] dst, ValueInt4[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Value128NullFree.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFreeNonAtomic extends CopyBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueInt4[] dst, ValueInt4[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueInt4[] dst, ValueInt4[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceInt[] dst, InterfaceInt[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/Value128NullFreeNonAtomic.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class ValueOop extends CopyBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueRef[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceOop[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceOop[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueRef[] dst, ValueRef[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceOop[] dst, InterfaceOop[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueRef[] dst, ValueRef[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceOop[] dst, InterfaceOop[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/ValueOop.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFree extends CopyBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceOop[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceOop[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueRef[] dst, ValueRef[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceOop[] dst, InterfaceOop[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueRef[] dst, ValueRef[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceOop[] dst, InterfaceOop[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/ValueOopNullFree.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.copy;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFreeNonAtomic extends CopyBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceOop[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceOop[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_val(ValueRef[] dst, ValueRef[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_int(InterfaceOop[] dst, InterfaceOop[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i] = src[i];\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_val(ValueRef[] dst, ValueRef[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arraycopy_int(InterfaceOop[] dst, InterfaceOop[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_as_val(ValState st1, ValState st2) {\n-        copy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_val_as_val(ValState st1, ValState st2) {\n-        arraycopy_val(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_as_int(IntState st1, IntState st2) {\n-        copy_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void arraycopy_int_as_int(IntState st1, IntState st2) {\n-        arraycopy_int(st1.arr, st2.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/copy\/ValueOopNullFreeNonAtomic.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class FillBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/FillBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-public class Identity extends FillBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public IdentityInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        public static IdentityInt VALUE = new IdentityInt(42);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        public IdentityInt VALUE = new IdentityInt(42);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public IdentityInt get_ref(int i) {\n-        return new IdentityInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_ref(IdentityInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new IdentityInt(42);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_ref(IdentityInt[] dst) {\n-        Arrays.fill(dst, new IdentityInt(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_ref(IdentityInt[] dst) {\n-        IdentityInt local = get_ref(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_ref(IdentityInt[] dst) {\n-        Arrays.fill(dst, get_ref(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_ref(IdentityInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_ref(IdentityInt[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_ref(IdentityInt[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_ref(IdentityInt[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(RefState st1) {\n-        fill_new_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(RefState st1) {\n-        arrayfill_new_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(RefState st1) {\n-        fill_local_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(RefState st1) {\n-        arrayfill_local_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(RefState st1) {\n-        fill_static_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(RefState st1) {\n-        arrayfill_static_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(RefState st1, InstanceHolder ih) {\n-        fill_instance_ref(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(RefState st1, InstanceHolder ih) {\n-        arrayfill_instance_ref(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Identity.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesR32int;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Identity32int extends StatesR32int {\n+\n+    public static class RefStaticField {\n+        static R32int f = new R32int(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RefInstanceField {\n+        R32int f = new R32int(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        R32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new R32int();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        R32int[] arr = st.arr;\n+        R32int v = new R32int(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fill_fillstat(Ref_as_Ref st) {\n+        R32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst(Ref_as_Ref st, RefInstanceField f) {\n+        R32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new R32int()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new R32int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Identity32int.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesROpt;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.ROpt;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class IdentityOpt extends StatesROpt {\n+\n+    public static class RefStaticField {\n+        static ROpt<Int32> f = ROpt.of(new R32int(42));\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RefInstanceField {\n+        ROpt<Int32> f = ROpt.of(new R32int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        ROpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ROpt.of();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        ROpt<Int32>[] arr = st.arr;\n+        ROpt<Int32> v = ROpt.of(new R32int(42));\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fill_fillstat(Ref_as_Ref st) {\n+        ROpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst(Ref_as_Ref st, RefInstanceField f) {\n+        ROpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, ROpt.of()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, ROpt.of(new R32int(42)));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/IdentityOpt.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ128int;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    public static class RefStaticField {\n+        static Q128int f = new Q128int(42);\n+    }\n+\n+    public static class ValStaticField {\n+        static Q128int f = new Q128int(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RefInstanceField {\n+        Q128int f = new Q128int(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class ValInstanceField {\n+        Q128int f = new Q128int(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q128int();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        Q128int v = new Q128int(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillinst(Val_as_Val st, RefInstanceField f) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillinst(Val_as_Val st, ValInstanceField f) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q128int();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        Q128int v = new Q128int(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q128int()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q128int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillinst(Val_as_Val st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillinst(Val_as_Val st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q128int()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q128int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Inline128int.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ32int;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    public static class RefStaticField {\n+        static Q32int f = new Q32int(42);\n+    }\n+\n+    public static class ValStaticField {\n+        static Q32int f = new Q32int(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RefInstanceField {\n+        Q32int f = new Q32int(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class ValInstanceField {\n+        Q32int f = new Q32int(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q32int();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        Q32int v = new Q32int(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillinst(Val_as_Val st, RefInstanceField f) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillinst(Val_as_Val st, ValInstanceField f) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q32int()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        Q32int v = new Q32int(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q32int()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q32int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillinst(Val_as_Val st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillinst(Val_as_Val st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q32int()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q32int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Inline32int.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64byte;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    public static class RefStaticField {\n+        static Q64byte f = new Q64byte(42);\n+    }\n+\n+    public static class ValStaticField {\n+        static Q64byte f = new Q64byte(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RefInstanceField {\n+        Q64byte f = new Q64byte(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class ValInstanceField {\n+        Q64byte f = new Q64byte(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64byte()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        Q64byte v = new Q64byte(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillinst(Val_as_Val st, RefInstanceField f) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillinst(Val_as_Val st, ValInstanceField f) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64byte()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        Q64byte v = new Q64byte(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q64byte()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q64byte(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillinst(Val_as_Val st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillinst(Val_as_Val st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64byte()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64byte(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Inline64byte.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64int;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    public static class RefStaticField {\n+        static Q64int f = new Q64int(42);\n+    }\n+\n+    public static class ValStaticField {\n+        static Q64int f = new Q64int(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RefInstanceField {\n+        Q64int f = new Q64int(42);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class ValInstanceField {\n+        Q64int f = new Q64int(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64int()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_fill(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        Q64int v = new Q64int(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillinst(Val_as_Val st, RefInstanceField f) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillinst(Val_as_Val st, ValInstanceField f) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64int()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        Q64int v = new Q64int(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q64int()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q64int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillinst(Val_as_Val st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillinst(Val_as_Val st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64int()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Inline64int.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQOpt;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.QOpt;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class InlineOpt extends StatesQOpt {\n+\n+    public static class RefStaticField {\n+        static QOpt<Int32> f = QOpt.of(new R32int(42));\n+    }\n+\n+    public static class ValStaticField {\n+        static QOpt<Int32> f = QOpt.of(new R32int(42));\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RefInstanceField {\n+        QOpt<Int32> f = QOpt.of(new R32int(42));\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class ValInstanceField {\n+        QOpt<Int32> f = QOpt.of(new R32int(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_fill(Val_as_Val st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = QOpt.of();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_fill(Val_as_Val st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        QOpt<Int32> v = QOpt.of(new R32int(42));\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillstat(Val_as_Val st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillinst(Val_as_Val st, RefInstanceField f) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillinst(Val_as_Val st, ValInstanceField f) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = QOpt.of();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill(Ref_as_Ref st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        QOpt<Int32> v = QOpt.of(new R32int(42));\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = RefStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillstat(Ref_as_Ref st) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ValStaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst(Ref_as_Ref st, RefInstanceField f) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillinst(Ref_as_Ref st, ValInstanceField f) {\n+        QOpt<Int32>[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, QOpt.of() );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, QOpt.of(new R32int(42)));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillinst(Val_as_Val st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillinst(Val_as_Val st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, QOpt.of()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, QOpt.of(new R32int(42)));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, RefStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, ValStaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, RefInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, ValInstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/InlineOpt.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-import java.util.Arrays;\n-\n-public class Primitive032 extends FillBase {\n-\n-    public static class PrimitiveState extends SizeState {\n-        public int[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = i;\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void fill_primitive(int[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = 42;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void arrayfill_primitive(int[] dst) {\n-        Arrays.fill(dst, 42);\n-    }\n-\n-    @Benchmark\n-    public void fill(PrimitiveState st1) {\n-        fill_primitive(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill(PrimitiveState st1) {\n-        arrayfill_primitive(st1.arr);\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Primitive032.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.fill1;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Primitive64 extends PrimitiveStates {\n+\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void fill0(Primitive64long st) {\n+        long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = 42;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void fill1(Primitive64long st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = 42;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void arrayfill(Primitive64long st) {\n+        Arrays.fill(st.arr, 42);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Primitive64.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends FillBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        public static ValueInt VALUE = new ValueInt(42);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        public ValueInt VALUE = new ValueInt(42);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(42);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueInt[] dst) {\n-        Arrays.fill(dst, new ValueInt(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueInt[] dst) {\n-        ValueInt local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueInt[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueInt[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueInt[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueInt[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Value032.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,177 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFree extends FillBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        @Strict\n-        @NullRestricted\n-        public static ValueInt VALUE = new ValueInt(42);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt VALUE = new ValueInt(42);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(42);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueInt[] dst) {\n-        Arrays.fill(dst, new ValueInt(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueInt[] dst) {\n-        ValueInt local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueInt[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueInt[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueInt[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueInt[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Value032NullFree.java","additions":0,"deletions":177,"binary":false,"changes":177,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFreeNonAtomic extends FillBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        @Strict\n-        @NullRestricted\n-        public static ValueInt VALUE = new ValueInt(42);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt VALUE = new ValueInt(42);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(42);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueInt[] dst) {\n-        Arrays.fill(dst, new ValueInt(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueInt[] dst) {\n-        ValueInt local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueInt[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueInt[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueInt[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueInt[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Value032NullFreeNonAtomic.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,177 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends FillBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        public static ValueInt4 VALUE = new ValueInt4(42);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        public ValueInt4 VALUE = new ValueInt4(42);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(42);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, new ValueInt4(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueInt4[] dst) {\n-        ValueInt4 local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueInt4[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueInt4[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Value128.java","additions":0,"deletions":177,"binary":false,"changes":177,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFree extends FillBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        @Strict\n-        @NullRestricted\n-        public static ValueInt4 VALUE = new ValueInt4(42);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 VALUE = new ValueInt4(42);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(42);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, new ValueInt4(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueInt4[] dst) {\n-        ValueInt4 local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueInt4[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueInt4[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Value128NullFree.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFreeNonAtomic extends FillBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        @Strict\n-        @NullRestricted\n-        public static ValueInt4 VALUE = new ValueInt4(42);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 VALUE = new ValueInt4(42);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(42);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, new ValueInt4(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueInt4[] dst) {\n-        ValueInt4 local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueInt4[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueInt4[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueInt4[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/Value128NullFreeNonAtomic.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class ValueOop extends FillBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueRef[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        public static ValueRef VALUE = new ValueRef(new IdentityInt(42));\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        public ValueRef VALUE = new ValueRef(new IdentityInt(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueRef get_val(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(42));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueRef[] dst) {\n-        Arrays.fill(dst, new ValueRef(new IdentityInt(42)));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueRef[] dst) {\n-        ValueRef local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueRef[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueRef[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueRef[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueRef[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/ValueOop.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFree extends FillBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        @Strict\n-        @NullRestricted\n-        public static ValueRef VALUE = new ValueRef(new IdentityInt(42));\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        @Strict\n-        @NullRestricted\n-        public ValueRef VALUE = new ValueRef(new IdentityInt(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueRef get_val(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(42));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueRef[] dst) {\n-        Arrays.fill(dst, new ValueRef(new IdentityInt(42)));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueRef[] dst) {\n-        ValueRef local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueRef[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueRef[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueRef[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueRef[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/ValueOopNullFree.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.fill;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import java.util.Arrays;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFreeNonAtomic extends FillBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class StaticHolder {\n-        @Strict\n-        @NullRestricted\n-        public static ValueRef VALUE = new ValueRef(new IdentityInt(42));\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class InstanceHolder {\n-        @Strict\n-        @NullRestricted\n-        public ValueRef VALUE = new ValueRef(new IdentityInt(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueRef get_val(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_new_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(42));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_new_val(ValueRef[] dst) {\n-        Arrays.fill(dst, new ValueRef(new IdentityInt(42)));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_local_val(ValueRef[] dst) {\n-        ValueRef local = get_val(42);\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = local;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_local_val(ValueRef[] dst) {\n-        Arrays.fill(dst, get_val(42));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_static_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = StaticHolder.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_static_val(ValueRef[] dst) {\n-        Arrays.fill(dst, StaticHolder.VALUE);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void fill_instance_val(ValueRef[] dst, InstanceHolder ih) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = ih.VALUE;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void arrayfill_instance_val(ValueRef[] dst, InstanceHolder ih) {\n-        Arrays.fill(dst, ih.VALUE);\n-    }\n-\n-    @Benchmark\n-    public void fill_new(ValState st1) {\n-        fill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_new(ValState st1) {\n-        arrayfill_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_local(ValState st1) {\n-        fill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_local(ValState st1) {\n-        arrayfill_local_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_static(ValState st1) {\n-        fill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_static(ValState st1) {\n-        arrayfill_static_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void fill_instance(ValState st1, InstanceHolder ih) {\n-        fill_instance_val(st1.arr, ih);\n-    }\n-\n-    @Benchmark\n-    public void arrayfill_instance(ValState st1, InstanceHolder ih) {\n-        arrayfill_instance_val(st1.arr, ih);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/fill\/ValueOopNullFreeNonAtomic.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-public class Identity extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public IdentityInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_ref(IdentityInt[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(RefState st1, Blackhole bh) {\n-        read_ref(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Identity.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ128int;\n+import org.openjdk.bench.valhalla.types.Int128;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q128int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q128int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void int_consume(Int128 v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Val_read(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Ref_read(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Int_read(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Val_read(Val_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Ref_read(Val_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Int_read(Val_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Int_to_Int_read(Val_as_Int st) {\n+        Int128[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Inline128int.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ32int;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q32int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q32int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void int_consume(Int32 v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Val_read(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Ref_read(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Int_read(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Val_read(Val_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Ref_read(Val_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Int_read(Val_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Int_to_Int_read(Val_as_Int st) {\n+        Int32[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Inline32int.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64byte;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q64byte v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q64byte v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void int_consume(Int64 v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Val_read(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Ref_read(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Int_read(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Val_read(Val_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Ref_read(Val_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Int_read(Val_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Int_to_Int_read(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Inline64byte.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64int;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q64int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q64int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void int_consume(Int64 v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Val_read(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Ref_read(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Int_read(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Val_read(Val_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Ref_read(Val_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Int_read(Val_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Int_to_Int_read(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Inline64int.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-public class Primitive032 extends ReadBase {\n-\n-    public static class PrimitiveState extends SizeState {\n-        public int[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = i;\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void read_primitive(int[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(PrimitiveState st1, Blackhole bh) {\n-        read_primitive(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Primitive032.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive128int extends PrimitiveStates {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void consume_int(int v0, int v1, int v2, int v3) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p128int_read(Primitive128int st) {\n+        int[] values = st.arr;\n+        for (int i = 0; i < values.length; i+=4) {\n+            consume_int(values[i], values[i+1], values[i+2], values[i+3]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Primitive128int.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive32int extends PrimitiveStates {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void consume_int(int v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p32int_read(Primitive32int st) {\n+        int[] values = st.arr;\n+        for (int i = 0; i < values.length; i++) {\n+            consume_int(values[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Primitive32int.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64byte extends PrimitiveStates {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void consume_byte(byte v0, byte v1, byte v2, byte v3, byte v4, byte v5, byte v6, byte v7) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64byte_read(Primitive64byte st) {\n+        byte[] values = st.arr;\n+        for (int i = 0; i < values.length; i+=8) {\n+            consume_byte(values[i], values[i+1], values[i+2], values[i+3], values[i+4], values[i+5], values[i+6], values[i+7]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Primitive64byte.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64int extends PrimitiveStates {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void consume_int(int v0, int v1) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void read(Primitive64int st) {\n+        int[] values = st.arr;\n+        for (int i = 0; i < values.length; i+=2) {\n+            consume_int(values[i], values[i+1]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Primitive64int.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.read;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64long extends PrimitiveStates {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void consume_long(long v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64long_read(Primitive64long st) {\n+        long[] values = st.arr;\n+        for (int i = 0; i < values.length; i++) {\n+            consume_long(values[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Primitive64long.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class ReadBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/ReadBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Value032.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFree extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Value032NullFree.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFreeNonAtomic extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Value032NullFreeNonAtomic.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Value128.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFree extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Value128NullFree.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFreeNonAtomic extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/Value128NullFreeNonAtomic.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class ValueOop extends ReadBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueRef[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueRef[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/ValueOop.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFree extends ReadBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueRef[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/ValueOopNullFree.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.read;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFreeNonAtomic extends ReadBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueRef[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/read\/ValueOopNullFreeNonAtomic.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-public class Identity extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt4 implements InterfaceInt {\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-        public final int value;\n-        public IdentityInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public IdentityInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt4[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IdentityInt4(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_ref(IdentityInt4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].value);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(RefState st1, Blackhole bh) {\n-        read_ref(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/Identity.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-public class Primitive128 extends ReadBase {\n-\n-    public static class PrimitiveState extends SizeState {\n-        public int[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new int[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = i;\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void read_primitive(int[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i += 4) {\n-            bh.consume(src[i + 3]);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(PrimitiveState st1, Blackhole bh) {\n-        read_primitive(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/Primitive128.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class ReadBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/ReadBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].value);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/Value128.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFree extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].value);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/Value128NullFree.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFreeNonAtomic extends ReadBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueInt4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i]);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_int(InterfaceInt[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].value());\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/Value128NullFreeNonAtomic.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class ValueOop extends ReadBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef4 implements InterfaceOop {\n-        public final IdentityInt prevalue0;\n-        public final IdentityInt prevalue1;\n-        public final IdentityInt prevalue2;\n-        public final IdentityInt value;\n-\n-        public ValueRef4(IdentityInt value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueRef4[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef4(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueRef4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].value);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/ValueOop.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFree extends ReadBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef4 implements InterfaceOop {\n-        public final IdentityInt prevalue0;\n-        public final IdentityInt prevalue1;\n-        public final IdentityInt prevalue2;\n-        public final IdentityInt value;\n-\n-        public ValueRef4(IdentityInt value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef4[]) ValueClass.newNullRestrictedAtomicArray(ValueRef4.class, size, new ValueRef4(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef4(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueRef4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].value);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/ValueOopNullFree.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.readpartial;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFreeNonAtomic extends ReadBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueRef4 implements InterfaceOop {\n-        public final IdentityInt prevalue0;\n-        public final IdentityInt prevalue1;\n-        public final IdentityInt prevalue2;\n-        public final IdentityInt value;\n-\n-        public ValueRef4(IdentityInt value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef4[]) ValueClass.newNullRestrictedAtomicArray(ValueRef4.class, size, new ValueRef4(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef4(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValueRef4[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].value);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/readpartial\/ValueOopNullFreeNonAtomic.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Identity extends SetBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public IdentityInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public IdentityInt get_ref(int i) {\n-        return new IdentityInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceInt get_int(int i) {\n-        return new IdentityInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_ref(IdentityInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new IdentityInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new IdentityInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_ref(IdentityInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_ref(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_ref_as_ref(RefState st1) {\n-        set_new_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_ref_as_ref(RefState st1) {\n-        set_call_ref(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Identity.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.set;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ128int;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_set(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q128int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q128int(i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q128int getRef(int i) {\n+        return new Q128int(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q128int getVal(int i) {\n+        return new Q128int(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_set(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_set(Val_as_Val st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q128int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Inline128int.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.set;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ32int;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_set(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q32int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q32int(i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q32int getRef(int i) {\n+        return new Q32int(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q32int getVal(int i) {\n+        return new Q32int(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_set(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_set(Val_as_Val st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q32int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Inline32int.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.set;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64byte;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_set(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64byte(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64byte(i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64byte getRef(int i) {\n+        return new Q64byte(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64byte getVal(int i) {\n+        return new Q64byte(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_set(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_set(Val_as_Val st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q64byte[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Inline64byte.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.set;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64int;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_set(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64int(i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64int getRef(int i) {\n+        return new Q64int(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64int getVal(int i) {\n+        return new Q64int(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_set(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_set(Val_as_Val st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_set(Ref_as_Ref st) {\n+        Q64int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = getVal(i);\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Inline64int.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Primitive032 extends SetBase {\n-\n-    public static class PrimitiveState extends SizeState {\n-        public int[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = i;\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int get_primitive(int i) {\n-        return i;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void set_primitive(int[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = i;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static void set_call_primitive(int[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_primitive(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set(PrimitiveState st1) {\n-        set_primitive(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call(PrimitiveState st1) {\n-        set_call_primitive(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Primitive032.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.set;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive32 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void set(Primitive32int st) {\n+        int[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Primitive32.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.set;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void set0(Primitive64long st) {\n+        long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = i;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void set1(Primitive64long st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = i;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Primitive64.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class SetBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/SetBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends SetBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceInt get_int(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Value032.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFree extends SetBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceInt get_int(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Value032NullFree.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFreeNonAtomic extends SetBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceInt get_int(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Value032NullFreeNonAtomic.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends SetBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceInt get_int(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Value128.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFree extends SetBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceInt get_int(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Value128NullFree.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFreeNonAtomic extends SetBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueInt4(i);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceInt get_int(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueInt4[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceInt[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/Value128NullFreeNonAtomic.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class ValueOop extends SetBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueRef[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceOop[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceOop[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueRef get_val(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceOop get_int(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(i));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceOop[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(i));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceOop[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/ValueOop.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFree extends SetBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceOop[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceOop[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueRef get_val(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceOop get_int(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(i));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceOop[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(i));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceOop[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/ValueOopNullFree.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.set;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueOopNullFreeNonAtomic extends SetBase {\n-\n-    public static class IdentityInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public interface InterfaceOop {\n-        public IdentityInt value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueRef implements InterfaceOop {\n-\n-        public final IdentityInt value;\n-\n-        public ValueRef(IdentityInt value) {\n-            this.value = value;\n-        }\n-\n-        public IdentityInt value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueRef[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueRef[]) ValueClass.newNullRestrictedAtomicArray(ValueRef.class, size, new ValueRef(new IdentityInt(0)));\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceOop[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceOop[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValueRef(new IdentityInt(i));\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueRef get_val(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public InterfaceOop get_int(int i) {\n-        return new ValueRef(new IdentityInt(i));\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(i));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new_int(InterfaceOop[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = new ValueRef(new IdentityInt(i));\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_val(ValueRef[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_val(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call_int(InterfaceOop[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i] = get_int(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val_as_val(ValState st1) {\n-        set_new_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_new_int_as_int(IntState st1) {\n-        set_new_int(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val_as_val(ValState st1) {\n-        set_call_val(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_int_as_int(IntState st1) {\n-        set_call_int(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/set\/ValueOopNullFreeNonAtomic.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesROpt;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Opt;\n+import org.openjdk.bench.valhalla.types.ROpt;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class IdentityOpt extends StatesROpt {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_fields(Ref_as_Ref st) {\n+        int s = 0;\n+        ROpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].value.intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_sum(Ref_as_Ref st) {\n+        int s = 0;\n+        ROpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].get().intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_sum(Int_as_Int st) {\n+        int s = 0;\n+        Opt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].get().intValue();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/IdentityOpt.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ128int;\n+import org.openjdk.bench.valhalla.types.ByInt;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_fields(Val_as_Val st) {\n+        int s = 0;\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0.v0;\n+            s += arr[i].v0.v1.v0;\n+            s += arr[i].v1.v0.v0;\n+            s += arr[i].v1.v1.v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_fields(Val_as_Ref st) {\n+        int s = 0;\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0.v0;\n+            s += arr[i].v0.v1.v0;\n+            s += arr[i].v1.v0.v0;\n+            s += arr[i].v1.v1.v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_fields(Ref_as_Ref st) {\n+        int s = 0;\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0.v0;\n+            s += arr[i].v0.v1.v0;\n+            s += arr[i].v1.v0.v0;\n+            s += arr[i].v1.v1.v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_sum(Val_as_Val st) {\n+        int s = 0;\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_sum(Val_as_Ref st) {\n+        int s = 0;\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_sum(Ref_as_Ref st) {\n+        int s = 0;\n+        Q128int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Int_sum(Val_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Int_sum(Ref_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_sum(By_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Inline128int.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ32int;\n+import org.openjdk.bench.valhalla.types.ByInt;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_fields(Val_as_Val st) {\n+        int s = 0;\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_fields(Val_as_Ref st) {\n+        int s = 0;\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_fields(Ref_as_Ref st) {\n+        int s = 0;\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_sum(Val_as_Val st) {\n+        int s = 0;\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_sum(Val_as_Ref st) {\n+        int s = 0;\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_sum(Ref_as_Ref st) {\n+        int s = 0;\n+        Q32int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Int_sum(Val_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_sum(By_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Inline32int.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64byte;\n+import org.openjdk.bench.valhalla.types.ByByte;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte Val_as_Val_fields(Val_as_Val st) {\n+        byte s = 0;\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0;\n+            s += arr[i].v0.v1;\n+            s += arr[i].v0.v2;\n+            s += arr[i].v0.v3;\n+            s += arr[i].v1.v0;\n+            s += arr[i].v1.v1;\n+            s += arr[i].v1.v2;\n+            s += arr[i].v1.v3;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte Val_as_Ref_fields(Val_as_Ref st) {\n+        byte s = 0;\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0;\n+            s += arr[i].v0.v1;\n+            s += arr[i].v0.v2;\n+            s += arr[i].v0.v3;\n+            s += arr[i].v1.v0;\n+            s += arr[i].v1.v1;\n+            s += arr[i].v1.v2;\n+            s += arr[i].v1.v3;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte Ref_as_Ref_fields(Ref_as_Ref st) {\n+        byte s = 0;\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0;\n+            s += arr[i].v0.v1;\n+            s += arr[i].v0.v2;\n+            s += arr[i].v0.v3;\n+            s += arr[i].v1.v0;\n+            s += arr[i].v1.v1;\n+            s += arr[i].v1.v2;\n+            s += arr[i].v1.v3;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte Val_as_Val_sum(Val_as_Val st) {\n+        byte s = 0;\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].byteSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte Val_as_Ref_sum(Val_as_Ref st) {\n+        byte s = 0;\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].byteSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte Ref_as_Ref_sum(Ref_as_Ref st) {\n+        byte s = 0;\n+        Q64byte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].byteSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Int_sum(Val_as_By st) {\n+        int s = 0;\n+        ByByte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].byteSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_sum(By_as_By st) {\n+        int s = 0;\n+        ByByte[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].byteSum();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Inline64byte.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQ64int;\n+import org.openjdk.bench.valhalla.types.ByInt;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_fields(Val_as_Val st) {\n+        int s = 0;\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0;\n+            s += arr[i].v1.v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_fields(Val_as_Ref st) {\n+        int s = 0;\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0;\n+            s += arr[i].v1.v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_fields(Ref_as_Ref st) {\n+        int s = 0;\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0.v0;\n+            s += arr[i].v1.v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_sum(Val_as_Val st) {\n+        int s = 0;\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_sum(Val_as_Ref st) {\n+        int s = 0;\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_sum(Ref_as_Ref st) {\n+        int s = 0;\n+        Q64int[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Int_sum(Val_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Int_sum(Ref_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_sum(By_as_By st) {\n+        int s = 0;\n+        ByInt[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].intSum();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Inline64int.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.StatesQOpt;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Opt;\n+import org.openjdk.bench.valhalla.types.QOpt;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class InlineOpt extends StatesQOpt {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_fields(Val_as_Val st) {\n+        int s = 0;\n+        QOpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].value.intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_fields(Val_as_Ref st) {\n+        int s = 0;\n+        QOpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].value.intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_fields(Ref_as_Ref st) {\n+        int s = 0;\n+        QOpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].value.intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_sum(Val_as_Val st) {\n+        int s = 0;\n+        QOpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].get().intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_sum(Val_as_Ref st) {\n+        int s = 0;\n+        QOpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].get().intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_sum(Ref_as_Ref st) {\n+        int s = 0;\n+        QOpt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].get().intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Int_sum(Val_as_Int st) {\n+        int s = 0;\n+        Opt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].get().intValue();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_sum(Int_as_Int st) {\n+        int s = 0;\n+        Opt<Int32>[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].get().intValue();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/InlineOpt.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive128int extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int sum(Primitive128int st) {\n+        int s = 0;\n+        int[] values = st.arr;\n+        for (int i = 0; i < values.length; i++) {\n+            s += values[i];\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Primitive128int.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive32int extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int sum(Primitive32int st) {\n+        int s = 0;\n+        int[] values = st.arr;\n+        for (int i = 0; i < values.length; i++) {\n+            s += values[i];\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Primitive32int.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64byte extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte sum(Primitive64byte st) {\n+        byte s = 0;\n+        byte[] values = st.arr;\n+        for (int i = 0; i < values.length; i++) {\n+            s += values[i];\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Primitive64byte.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64int extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int sum(Primitive64int st) {\n+        int s = 0;\n+        int[] values = st.arr;\n+        for (int i = 0; i < values.length; i++) {\n+            s += values[i];\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Primitive64int.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.sum;\n+\n+import org.openjdk.bench.valhalla.array.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64long extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long sum0(Primitive64long st) {\n+        long s = 0;\n+        long[] values = st.arr;\n+        for (int i = 0; i < values.length; i++) {\n+            s += values[i];\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long sum1(Primitive64long st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            s += st.arr[i];\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/sum\/Primitive64long.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class PrimitiveStates extends SizeBase {\n+\n+    public static abstract class ByteState extends SizeState {\n+        public byte[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = (byte) i;\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = i;\n+            }\n+        }\n+    }\n+\n+    public static abstract class LongState extends SizeState {\n+        public long[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = i;\n+            }\n+        }\n+    }\n+\n+    public static class Primitive32int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Primitive64byte extends ByteState {\n+        @Setup\n+        public void setup() {\n+            arr = new byte[size * 8];\n+            fill();\n+        }\n+    }\n+\n+    public static class Primitive64int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new int[size * 2];\n+            fill();\n+        }\n+    }\n+\n+    public static class Primitive64long extends LongState {\n+        @Setup\n+        public void setup() {\n+            arr = new long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Primitive128int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new int[size * 4];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/PrimitiveStates.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int128;\n+import org.openjdk.bench.valhalla.types.Q128byte;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ128byte extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int128[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q128byte[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q128byte[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128byte(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128byte[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesQ128byte.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.ByInt;\n+import org.openjdk.bench.valhalla.types.Int128;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ128int extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int128[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q128int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q128int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128int(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static abstract class ByState extends SizeState {\n+        public ByInt[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128int(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val_as_By extends StatesQ32int.ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_By extends StatesQ32int.ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class By_as_By extends StatesQ32int.ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new ByInt[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesQ128int.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int128;\n+import org.openjdk.bench.valhalla.types.Q128long;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ128long extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int128[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q128long[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q128long[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q128long(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q128long[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesQ128long.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.ByInt;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ32int extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q32int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int32[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q32int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q32int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q32int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q32int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q32int(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int32[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int32[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static abstract class ByState extends SizeState {\n+        public ByInt[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q32int(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class By_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new ByInt[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesQ32int.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.ByByte;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ64byte extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q64byte[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q64byte[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64byte(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static abstract class ByState extends SizeState {\n+        public ByByte[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64byte(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class By_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new ByByte[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesQ64byte.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.ByInt;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ64int extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q64int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q64int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64int(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static abstract class ByState extends SizeState {\n+        public ByInt[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64int(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val_as_By extends StatesQ32int.ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_By extends StatesQ32int.ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class By_as_By extends StatesQ32int.ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new ByInt[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesQ64int.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Opt;\n+import org.openjdk.bench.valhalla.types.QOpt;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQOpt extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] =  QOpt.of(new R32int(i));\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Opt<Int32>[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] =  QOpt.of(new R32int(i));\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public QOpt<Int32>[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] =  QOpt.of(new R32int(i));\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public QOpt<Int32>[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] =  QOpt.of(new R32int(i));\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Opt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new QOpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new QOpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Opt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new QOpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new QOpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new QOpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new QOpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new QOpt[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesQOpt.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int128;\n+import org.openjdk.bench.valhalla.types.R128int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesR128int extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R128int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int128[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R128int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public R128int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R128int(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new R128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int128[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new R128int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new R128int[size];\n+            fill();\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesR128int.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesR32int extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R32int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int32[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R32int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public R32int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R32int(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int32[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new R32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int32[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new R32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new R32int[size];\n+            fill();\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesR32int.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64byte;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesR64byte extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64byte(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public R64byte[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64byte(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64byte[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64byte[size];\n+            fill();\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesR64byte.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesR64int extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64int(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public R64int[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64int(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64int[size];\n+            fill();\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesR64int.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.array.util;\n+\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Opt;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.bench.valhalla.types.ROpt;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesROpt extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] =  ROpt.of(new R32int(i));\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Opt<Int32>[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] =  ROpt.of(new R32int(i));\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public ROpt<Int32>[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] =  ROpt.of(new R32int(i));\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Opt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new ROpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Opt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new ROpt[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new ROpt[size];\n+            fill();\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/util\/StatesROpt.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Identity extends WalkBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public IdentityInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new IdentityInt(a[i]);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new IdentityInt(a[i]);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_ref(IdentityInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_int(InterfaceInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @Benchmark\n-    public int walk_ref_as_ref(RefState st) {\n-        return walk_ref(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int walk_int_as_int(IntState st) {\n-        return walk_int(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Identity.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Primitive extends WalkBase {\n-\n-    public static class PrimState extends SizeState {\n-        public int[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = makeRandomRing(size);\n-        }\n-\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int walk(PrimState s) {\n-        int steps = 0;\n-        int[] values = s.arr;\n-        for (int i = values[0]; i != 0; i = values[i]) steps++;\n-        return steps;\n-    }\n-\n-}\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Primitive.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends WalkBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt(a[i]);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt(a[i]);\n-            }\n-        }\n-\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_val(ValueInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_int(InterfaceInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @Benchmark\n-    public int walk_val_as_val(ValState st) {\n-        return walk_val(st.arr);\n-    }\n-\n-    @Benchmark\n-       public int walk_int_as_int(IntState st) {\n-        return walk_int(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Value032.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFree extends WalkBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static  class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt(a[i]);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt(a[i]);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_val(ValueInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_int(InterfaceInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @Benchmark\n-    public int walk_val_as_val(ValState st) {\n-        return walk_val(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int walk_int_as_int(IntState st) {\n-        return walk_int(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Value032NullFree.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value032NullFreeNonAtomic extends WalkBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, size, new ValueInt(0));\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt(a[i]);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt(a[i]);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_val(ValueInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_int(InterfaceInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @Benchmark\n-    public int walk_val_as_val(ValState st) {\n-        return walk_val(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int walk_int_as_int(IntState st) {\n-        return walk_int(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Value032NullFreeNonAtomic.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends WalkBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt4(a[i]);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt4(a[i]);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_val(ValueInt4[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_int(InterfaceInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @Benchmark\n-    public int walk_val_as_val(ValState st) {\n-        return walk_val(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int walk_int_as_int(IntState st) {\n-        return walk_int(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Value128.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFree extends WalkBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt4(a[i]);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt4(a[i]);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_val(ValueInt4[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_int(InterfaceInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @Benchmark\n-    public int walk_val_as_val(ValState st) {\n-        return walk_val(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int walk_int_as_int(IntState st) {\n-        return walk_int(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Value128NullFree.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class Value128NullFreeNonAtomic extends WalkBase {\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValueInt4[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt4.class, size, new ValueInt4(0));\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt4(a[i]);\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public InterfaceInt[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[size];\n-            int[] a = makeRandomRing(arr.length);\n-            for (int i = 0; i < a.length; i++) {\n-                arr[i] = new ValueInt4(a[i]);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_val(ValueInt4[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int walk_int(InterfaceInt[] values) {\n-        int steps = 0;\n-        for (int i = values[0].value(); i != 0; i = values[i].value()) steps++;\n-        return steps;\n-    }\n-\n-    @Benchmark\n-    public int walk_val_as_val(ValState st) {\n-        return walk_val(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int walk_int_as_int(IntState st) {\n-        return walk_int(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/Value128NullFreeNonAtomic.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.array.walk;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class WalkBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-    public static void shuffle(int[] a, Random rnd) {\n-        for (int i = a.length; i > 1; i--) {\n-            int idx = rnd.nextInt(i);\n-            int tmp = a[i - 1];\n-            a[i - 1] = a[idx];\n-            a[idx] = tmp;\n-        }\n-\n-    }\n-\n-    public static int[] makeRandomRing(int size) {\n-        int[] A = new int[size - 1];\n-        for (int i = 0; i < A.length; i++) {\n-            A[i] = i + 1;\n-        }\n-        shuffle(A, new Random(42));\n-        int[] a = new int[size];\n-        int x = 0;\n-        for (int i = 0; i < A.length; i++) {\n-            x = a[x] = A[i];\n-        }\n-        a[x] = 0;\n-        return a;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/array\/walk\/WalkBase.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -0,0 +1,631 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesR64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class IdentityArrayCopy extends StatesR64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Obj_copy(Obj_as_Obj s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Int_copy(Obj_as_Obj s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Abs_copy(Obj_as_Obj s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Abs_copy(Obj_as_Obj s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Obj_copy(Int_as_Obj s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Int_copy(Int_as_Obj s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Abs_copy(Int_as_Obj s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Abs_copy(Int_as_Obj s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Obj_to_Obj_copy(Abs_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Obj_copy(Abs_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Obj_copy(Abs_as_Obj s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Obj_copy(Abs_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Int_copy(Abs_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Int_copy(Abs_as_Obj s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Int_copy(Abs_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Abs_copy(Abs_as_Obj s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Abs_copy(Abs_as_Obj s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Ref_copy(Abs_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Obj_copy(Ref_as_Obj s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Int_copy(Ref_as_Obj s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Abs_copy(Ref_as_Obj s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Abs_copy(Ref_as_Obj s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Obj_copy(Int_as_Int s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Int_copy(Int_as_Int s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Abs_copy(Int_as_Int s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Abs_copy(Int_as_Int s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Int_to_Obj_copy(Abs_as_Int s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Obj_copy(Abs_as_Int s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Obj_copy(Abs_as_Int s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Obj_copy(Abs_as_Int s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Int_copy(Abs_as_Int s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Int_copy(Abs_as_Int s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Int_copy(Abs_as_Int s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Abs_copy(Abs_as_Int s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Abs_copy(Abs_as_Int s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Ref_copy(Abs_as_Int s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Obj_copy(Ref_as_Int s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Int_copy(Ref_as_Int s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Abs_copy(Ref_as_Int s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Abs_copy(Ref_as_Int s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Abs_to_Obj_copy(Abs_as_Abs s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Obj_copy(Abs_as_Abs s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Obj_copy(Abs_as_Abs s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Obj_copy(Abs_as_Abs s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Int_copy(Abs_as_Abs s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Int_copy(Abs_as_Abs s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Int_copy(Abs_as_Abs s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Abs_copy(Abs_as_Abs s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Abs_copy(Abs_as_Abs s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Ref_copy(Abs_as_Abs s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Abs_to_Obj_copy(Ref_as_Abs s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Obj_copy(Ref_as_Abs s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Obj_copy(Ref_as_Abs s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Obj_copy(Ref_as_Abs s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Int_copy(Ref_as_Abs s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Int_copy(Ref_as_Abs s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Int_copy(Ref_as_Abs s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Abs_copy(Ref_as_Abs s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Abs_copy(Ref_as_Abs s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Ref_copy(Ref_as_Abs s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Obj_copy(Ref_as_Ref s, Abs_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Int_copy(Ref_as_Ref s, Abs_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Abs_copy(Ref_as_Ref s, Abs_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Abs_copy(Ref_as_Ref s, Ref_as_Abs d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/IdentityArrayCopy.java","additions":631,"deletions":0,"binary":false,"changes":631,"status":"added"},{"patch":"@@ -0,0 +1,1034 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesR64long;\n+import org.openjdk.bench.valhalla.types.A64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class IdentityCopy0 extends StatesR64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Obj_copy(Obj_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Int_copy(Obj_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Abs_copy(Obj_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Abs_copy(Obj_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Obj_copy(Int_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Int_copy(Int_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Abs_copy(Int_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Abs_copy(Int_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Obj_to_Obj_copy(Abs_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Obj_copy(Abs_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Obj_copy(Abs_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Obj_copy(Abs_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Int_copy(Abs_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Int_copy(Abs_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Int_copy(Abs_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Abs_copy(Abs_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Abs_copy(Abs_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Ref_copy(Abs_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Obj_copy(Ref_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Int_copy(Ref_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Abs_copy(Ref_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Abs_copy(Ref_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Obj_copy(Int_as_Int s, Abs_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Int_copy(Int_as_Int s, Abs_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Abs_copy(Int_as_Int s, Abs_as_Abs d) {\n+        Int64[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Abs_copy(Int_as_Int s, Ref_as_Abs d) {\n+        Int64[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Int_to_Obj_copy(Abs_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Obj_copy(Abs_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Obj_copy(Abs_as_Int s, Abs_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Obj_copy(Abs_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Int_copy(Abs_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Int_copy(Abs_as_Int s, Abs_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Int_copy(Abs_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Abs_copy(Abs_as_Int s, Abs_as_Abs d) {\n+        Int64[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Abs_copy(Abs_as_Int s, Ref_as_Abs d) {\n+        Int64[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Ref_copy(Abs_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Obj_copy(Ref_as_Int s, Abs_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Int_copy(Ref_as_Int s, Abs_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Abs_copy(Ref_as_Int s, Abs_as_Abs d) {\n+        Int64[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Abs_copy(Ref_as_Int s, Ref_as_Abs d) {\n+        Int64[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Abs_to_Obj_copy(Abs_as_Abs s, Obj_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Obj_copy(Abs_as_Abs s, Int_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Obj_copy(Abs_as_Abs s, Abs_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Obj_copy(Abs_as_Abs s, Ref_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Int_copy(Abs_as_Abs s, Int_as_Int d) {\n+        A64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Int_copy(Abs_as_Abs s, Abs_as_Int d) {\n+        A64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Int_copy(Abs_as_Abs s, Ref_as_Int d) {\n+        A64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Abs_copy(Abs_as_Abs s, Abs_as_Abs d) {\n+        A64long[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Abs_copy(Abs_as_Abs s, Ref_as_Abs d) {\n+        A64long[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Ref_copy(Abs_as_Abs s, Ref_as_Ref d) {\n+        A64long[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Abs_to_Obj_copy(Ref_as_Abs s, Obj_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Obj_copy(Ref_as_Abs s, Int_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Obj_copy(Ref_as_Abs s, Abs_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Obj_copy(Ref_as_Abs s, Ref_as_Obj d) {\n+        A64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Int_copy(Ref_as_Abs s, Int_as_Int d) {\n+        A64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Int_copy(Ref_as_Abs s, Abs_as_Int d) {\n+        A64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Int_copy(Ref_as_Abs s, Ref_as_Int d) {\n+        A64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Abs_copy(Ref_as_Abs s, Abs_as_Abs d) {\n+        A64long[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Abs_copy(Ref_as_Abs s, Ref_as_Abs d) {\n+        A64long[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Ref_copy(Ref_as_Abs s, Ref_as_Ref d) {\n+        A64long[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        R64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        R64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Obj_copy(Ref_as_Ref s, Abs_as_Obj d) {\n+        R64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        R64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        R64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Int_copy(Ref_as_Ref s, Abs_as_Int d) {\n+        R64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        R64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Abs_copy(Ref_as_Ref s, Abs_as_Abs d) {\n+        R64long[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Abs_copy(Ref_as_Ref s, Ref_as_Abs d) {\n+        R64long[] src = s.arr;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        R64long[] src = s.arr;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/IdentityCopy0.java","additions":1034,"deletions":0,"binary":false,"changes":1034,"status":"added"},{"patch":"@@ -0,0 +1,934 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesR64long;\n+import org.openjdk.bench.valhalla.types.A64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class IdentityCopy1 extends StatesR64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Obj_copy(Obj_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Int_copy(Obj_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Abs_copy(Obj_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Abs_copy(Obj_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Obj_copy(Int_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Int_copy(Int_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Abs_copy(Int_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Abs_copy(Int_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Obj_to_Obj_copy(Abs_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Obj_copy(Abs_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Obj_copy(Abs_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Obj_copy(Abs_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Int_copy(Abs_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Int_copy(Abs_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Int_copy(Abs_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Abs_copy(Abs_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Abs_copy(Abs_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Ref_copy(Abs_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Obj_copy(Ref_as_Obj s, Abs_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Int_copy(Ref_as_Obj s, Abs_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Abs_copy(Ref_as_Obj s, Abs_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Abs_copy(Ref_as_Obj s, Ref_as_Abs d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Obj_copy(Int_as_Int s, Abs_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Int_copy(Int_as_Int s, Abs_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Abs_copy(Int_as_Int s, Abs_as_Abs d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Abs_copy(Int_as_Int s, Ref_as_Abs d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Int_to_Obj_copy(Abs_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Obj_copy(Abs_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Obj_copy(Abs_as_Int s, Abs_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Obj_copy(Abs_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Int_copy(Abs_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Int_copy(Abs_as_Int s, Abs_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Int_copy(Abs_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Abs_copy(Abs_as_Int s, Abs_as_Abs d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Abs_copy(Abs_as_Int s, Ref_as_Abs d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Ref_copy(Abs_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Obj_copy(Ref_as_Int s, Abs_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Int_copy(Ref_as_Int s, Abs_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Abs_copy(Ref_as_Int s, Abs_as_Abs d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Abs_copy(Ref_as_Int s, Ref_as_Abs d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (A64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Abs_to_Obj_copy(Abs_as_Abs s, Obj_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Obj_copy(Abs_as_Abs s, Int_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Obj_copy(Abs_as_Abs s, Abs_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Obj_copy(Abs_as_Abs s, Ref_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Int_copy(Abs_as_Abs s, Int_as_Int d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Int_copy(Abs_as_Abs s, Abs_as_Int d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Int_copy(Abs_as_Abs s, Ref_as_Int d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Abs_copy(Abs_as_Abs s, Abs_as_Abs d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Abs_copy(Abs_as_Abs s, Ref_as_Abs d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Ref_copy(Abs_as_Abs s, Ref_as_Ref d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Abs_to_Obj_copy(Ref_as_Abs s, Obj_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Obj_copy(Ref_as_Abs s, Int_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Obj_copy(Ref_as_Abs s, Abs_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Obj_copy(Ref_as_Abs s, Ref_as_Obj d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Int_copy(Ref_as_Abs s, Int_as_Int d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Int_copy(Ref_as_Abs s, Abs_as_Int d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Int_copy(Ref_as_Abs s, Ref_as_Int d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Abs_copy(Ref_as_Abs s, Abs_as_Abs d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Abs_copy(Ref_as_Abs s, Ref_as_Abs d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Ref_copy(Ref_as_Abs s, Ref_as_Ref d) {\n+        A64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (R64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Obj_copy(Ref_as_Ref s, Abs_as_Obj d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Int_copy(Ref_as_Ref s, Abs_as_Int d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Abs_copy(Ref_as_Ref s, Abs_as_Abs d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Abs_copy(Ref_as_Ref s, Ref_as_Abs d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        R64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/IdentityCopy1.java","additions":934,"deletions":0,"binary":false,"changes":934,"status":"added"},{"patch":"@@ -0,0 +1,1034 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesR64long;\n+import org.openjdk.bench.valhalla.types.A64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class IdentityCopy2 extends StatesR64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Obj_copy(Obj_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Int_copy(Obj_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Abs_copy(Obj_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Abs_copy(Obj_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Obj_copy(Int_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Int_copy(Int_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Abs_copy(Int_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Abs_copy(Int_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Obj_to_Obj_copy(Abs_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Obj_copy(Abs_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Obj_copy(Abs_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Obj_copy(Abs_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Int_copy(Abs_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Int_copy(Abs_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Int_copy(Abs_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Abs_copy(Abs_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Abs_copy(Abs_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Ref_copy(Abs_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Obj_copy(Ref_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Int_copy(Ref_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Abs_copy(Ref_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Abs_copy(Ref_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Obj_copy(Int_as_Int s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Int_copy(Int_as_Int s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Abs_copy(Int_as_Int s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Abs_copy(Int_as_Int s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Int_to_Obj_copy(Abs_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Obj_copy(Abs_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Obj_copy(Abs_as_Int s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Obj_copy(Abs_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Int_copy(Abs_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Int_copy(Abs_as_Int s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Int_copy(Abs_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Abs_copy(Abs_as_Int s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Abs_copy(Abs_as_Int s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Ref_copy(Abs_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Obj_copy(Ref_as_Int s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Int_copy(Ref_as_Int s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Abs_copy(Ref_as_Int s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Abs_copy(Ref_as_Int s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Abs_to_Obj_copy(Abs_as_Abs s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Obj_copy(Abs_as_Abs s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Obj_copy(Abs_as_Abs s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Obj_copy(Abs_as_Abs s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Int_copy(Abs_as_Abs s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Int_copy(Abs_as_Abs s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Int_copy(Abs_as_Abs s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Abs_copy(Abs_as_Abs s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Abs_copy(Abs_as_Abs s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Ref_copy(Abs_as_Abs s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Abs_to_Obj_copy(Ref_as_Abs s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Obj_copy(Ref_as_Abs s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Obj_copy(Ref_as_Abs s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Obj_copy(Ref_as_Abs s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Int_copy(Ref_as_Abs s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Int_copy(Ref_as_Abs s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Int_copy(Ref_as_Abs s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Abs_copy(Ref_as_Abs s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Abs_copy(Ref_as_Abs s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Ref_copy(Ref_as_Abs s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Obj_copy(Ref_as_Ref s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Int_copy(Ref_as_Ref s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Abs_copy(Ref_as_Ref s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Abs_copy(Ref_as_Ref s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        A64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        R64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/IdentityCopy2.java","additions":1034,"deletions":0,"binary":false,"changes":1034,"status":"added"},{"patch":"@@ -0,0 +1,934 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesR64long;\n+import org.openjdk.bench.valhalla.types.A64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class IdentityCopy3 extends StatesR64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Obj_copy(Obj_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Int_copy(Obj_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Abs_as_Obj_to_Abs_copy(Obj_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Abs_copy(Obj_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Obj_copy(Int_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Int_copy(Int_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Obj_to_Abs_copy(Int_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Abs_copy(Int_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Obj_to_Obj_copy(Abs_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Obj_copy(Abs_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Obj_copy(Abs_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Obj_copy(Abs_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Obj_to_Int_copy(Abs_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Int_copy(Abs_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Int_copy(Abs_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Obj_to_Abs_copy(Abs_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Abs_copy(Abs_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Obj_to_Ref_copy(Abs_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Obj_copy(Ref_as_Obj s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Int_copy(Ref_as_Obj s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Obj_to_Abs_copy(Ref_as_Obj s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Abs_copy(Ref_as_Obj s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Obj_copy(Int_as_Int s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Int_copy(Int_as_Int s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Abs_as_Int_to_Abs_copy(Int_as_Int s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Abs_copy(Int_as_Int s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Int_to_Obj_copy(Abs_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Obj_copy(Abs_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Obj_copy(Abs_as_Int s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Obj_copy(Abs_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Int_to_Int_copy(Abs_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Int_copy(Abs_as_Int s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Int_copy(Abs_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Int_to_Abs_copy(Abs_as_Int s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Abs_copy(Abs_as_Int s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Int_to_Ref_copy(Abs_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Obj_copy(Ref_as_Int s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Int_copy(Ref_as_Int s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Int_to_Abs_copy(Ref_as_Int s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Abs_copy(Ref_as_Int s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (A64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Obj_as_Abs_to_Obj_copy(Abs_as_Abs s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Obj_copy(Abs_as_Abs s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Obj_copy(Abs_as_Abs s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Obj_copy(Abs_as_Abs s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Int_as_Abs_to_Int_copy(Abs_as_Abs s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Int_copy(Abs_as_Abs s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Int_copy(Abs_as_Abs s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Abs_as_Abs_to_Abs_copy(Abs_as_Abs s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Abs_copy(Abs_as_Abs s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Abs_to_Ref_as_Abs_to_Ref_copy(Abs_as_Abs s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Abs_to_Obj_copy(Ref_as_Abs s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Obj_copy(Ref_as_Abs s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Obj_copy(Ref_as_Abs s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Obj_copy(Ref_as_Abs s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Abs_to_Int_copy(Ref_as_Abs s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Int_copy(Ref_as_Abs s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Int_copy(Ref_as_Abs s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Abs_to_Abs_copy(Ref_as_Abs s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Abs_copy(Ref_as_Abs s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Abs_to_Ref_copy(Ref_as_Abs s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (R64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Obj_copy(Ref_as_Ref s, Abs_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Int_copy(Ref_as_Ref s, Abs_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Abs_as_Ref_to_Abs_copy(Ref_as_Ref s, Abs_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Abs_copy(Ref_as_Ref s, Ref_as_Abs d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/IdentityCopy3.java","additions":934,"deletions":0,"binary":false,"changes":934,"status":"added"},{"patch":"@@ -0,0 +1,632 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class InlineArrayCopy extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Obj_copy(Obj_as_Obj s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Int_copy(Obj_as_Obj s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Ref_copy(Obj_as_Obj s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Val_copy(Obj_as_Obj s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Obj_copy(Int_as_Obj s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Int_copy(Int_as_Obj s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Ref_copy(Int_as_Obj s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Val_copy(Int_as_Obj s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Obj_copy(Ref_as_Obj s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Int_copy(Ref_as_Obj s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Ref_copy(Ref_as_Obj s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Val_copy(Ref_as_Obj s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_to_Obj_copy(Val_as_Obj s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Obj_copy(Val_as_Obj s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Obj_copy(Val_as_Obj s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Obj_copy(Val_as_Obj s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Int_copy(Val_as_Obj s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Int_copy(Val_as_Obj s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Int_copy(Val_as_Obj s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Ref_copy(Val_as_Obj s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Ref_copy(Val_as_Obj s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Val_copy(Val_as_Obj s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Obj_copy(Int_as_Int s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Int_copy(Int_as_Int s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Ref_copy(Int_as_Int s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Val_copy(Int_as_Int s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Obj_copy(Ref_as_Int s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Int_copy(Ref_as_Int s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Ref_copy(Ref_as_Int s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Val_copy(Ref_as_Int s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Int_to_Obj_copy(Val_as_Int s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Obj_copy(Val_as_Int s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Obj_copy(Val_as_Int s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Obj_copy(Val_as_Int s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Int_copy(Val_as_Int s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Int_copy(Val_as_Int s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Int_copy(Val_as_Int s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Ref_copy(Val_as_Int s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Ref_copy(Val_as_Int s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Val_copy(Val_as_Int s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Obj_copy(Ref_as_Ref s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Int_copy(Ref_as_Ref s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Ref_copy(Ref_as_Ref s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Ref_to_Obj_copy(Val_as_Ref s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Obj_copy(Val_as_Ref s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Obj_copy(Val_as_Ref s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Obj_copy(Val_as_Ref s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Int_copy(Val_as_Ref s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Int_copy(Val_as_Ref s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Int_copy(Val_as_Ref s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Ref_copy(Val_as_Ref s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Ref_copy(Val_as_Ref s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Val_copy(Val_as_Ref s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Val_to_Obj_copy(Val_as_Val s, Obj_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Obj_copy(Val_as_Val s, Int_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Obj_copy(Val_as_Val s, Ref_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Obj_copy(Val_as_Val s, Val_as_Obj d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Int_copy(Val_as_Val s, Int_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Int_copy(Val_as_Val s, Ref_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Int_copy(Val_as_Val s, Val_as_Int d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Ref_copy(Val_as_Val s, Val_as_Ref d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        System.arraycopy(s.arr, 0, d.arr, 0, s.arr.length);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/InlineArrayCopy.java","additions":632,"deletions":0,"binary":false,"changes":632,"status":"added"},{"patch":"@@ -0,0 +1,1034 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class InlineCopy0 extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Obj_copy(Obj_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Int_copy(Obj_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Ref_copy(Obj_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Val_copy(Obj_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Obj_copy(Int_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Int_copy(Int_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Ref_copy(Int_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Val_copy(Int_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Obj_copy(Ref_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Int_copy(Ref_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Ref_copy(Ref_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Val_copy(Ref_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_to_Obj_copy(Val_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Obj_copy(Val_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Obj_copy(Val_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Obj_copy(Val_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Int_copy(Val_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Int_copy(Val_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Int_copy(Val_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Ref_copy(Val_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Ref_copy(Val_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Val_copy(Val_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Obj_copy(Int_as_Int s, Val_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Int_copy(Int_as_Int s, Val_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Ref_copy(Int_as_Int s, Val_as_Ref d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Val_copy(Int_as_Int s, Val_as_Val d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Obj_copy(Ref_as_Int s, Val_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Int_copy(Ref_as_Int s, Val_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Ref_copy(Ref_as_Int s, Val_as_Ref d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Val_copy(Ref_as_Int s, Val_as_Val d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Int_to_Obj_copy(Val_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Obj_copy(Val_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Obj_copy(Val_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Obj_copy(Val_as_Int s, Val_as_Obj d) {\n+        Int64[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Int_copy(Val_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Int_copy(Val_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Int_copy(Val_as_Int s, Val_as_Int d) {\n+        Int64[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Ref_copy(Val_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Ref_copy(Val_as_Int s, Val_as_Ref d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Val_copy(Val_as_Int s, Val_as_Val d) {\n+        Int64[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Obj_copy(Ref_as_Ref s, Val_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Int_copy(Ref_as_Ref s, Val_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Ref_copy(Ref_as_Ref s, Val_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Ref_to_Obj_copy(Val_as_Ref s, Obj_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Obj_copy(Val_as_Ref s, Int_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Obj_copy(Val_as_Ref s, Ref_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Obj_copy(Val_as_Ref s, Val_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Int_copy(Val_as_Ref s, Int_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Int_copy(Val_as_Ref s, Ref_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Int_copy(Val_as_Ref s, Val_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Ref_copy(Val_as_Ref s, Ref_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Ref_copy(Val_as_Ref s, Val_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Val_copy(Val_as_Ref s, Val_as_Val d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Val_to_Obj_copy(Val_as_Val s, Obj_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Obj_copy(Val_as_Val s, Int_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Obj_copy(Val_as_Val s, Ref_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Obj_copy(Val_as_Val s, Val_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Int_copy(Val_as_Val s, Int_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Int_copy(Val_as_Val s, Ref_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Int_copy(Val_as_Val s, Val_as_Int d) {\n+        Q64long[] src = s.arr;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Ref_copy(Val_as_Val s, Val_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        Q64long[] src = s.arr;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/InlineCopy0.java","additions":1034,"deletions":0,"binary":false,"changes":1034,"status":"added"},{"patch":"@@ -0,0 +1,933 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class InlineCopy1 extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Obj_copy(Obj_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Int_copy(Obj_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Ref_copy(Obj_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Val_copy(Obj_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Obj_copy(Int_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Int_copy(Int_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Ref_copy(Int_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Val_copy(Int_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Obj_copy(Ref_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Int_copy(Ref_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Ref_copy(Ref_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Val_copy(Ref_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_to_Obj_copy(Val_as_Obj s, Obj_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Obj_copy(Val_as_Obj s, Int_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Obj_copy(Val_as_Obj s, Ref_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Obj_copy(Val_as_Obj s, Val_as_Obj d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Int_copy(Val_as_Obj s, Int_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Int_copy(Val_as_Obj s, Ref_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Int_copy(Val_as_Obj s, Val_as_Int d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Int64)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Ref_copy(Val_as_Obj s, Ref_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Ref_copy(Val_as_Obj s, Val_as_Ref d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Val_copy(Val_as_Obj s, Val_as_Val d) {\n+        Object[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Obj_copy(Int_as_Int s, Val_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Int_copy(Int_as_Int s, Val_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Ref_copy(Int_as_Int s, Val_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Val_copy(Int_as_Int s, Val_as_Val d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Obj_copy(Ref_as_Int s, Val_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Int_copy(Ref_as_Int s, Val_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Ref_copy(Ref_as_Int s, Val_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Val_copy(Ref_as_Int s, Val_as_Val d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Int_to_Obj_copy(Val_as_Int s, Obj_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Obj_copy(Val_as_Int s, Int_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Obj_copy(Val_as_Int s, Ref_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Obj_copy(Val_as_Int s, Val_as_Obj d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Int_copy(Val_as_Int s, Int_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Int_copy(Val_as_Int s, Ref_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Int_copy(Val_as_Int s, Val_as_Int d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Ref_copy(Val_as_Int s, Ref_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Ref_copy(Val_as_Int s, Val_as_Ref d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Val_copy(Val_as_Int s, Val_as_Val d) {\n+        Int64[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = (Q64long)src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Obj_copy(Ref_as_Ref s, Val_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Int_copy(Ref_as_Ref s, Val_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Ref_copy(Ref_as_Ref s, Val_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Ref_to_Obj_copy(Val_as_Ref s, Obj_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Obj_copy(Val_as_Ref s, Int_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Obj_copy(Val_as_Ref s, Ref_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Obj_copy(Val_as_Ref s, Val_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Int_copy(Val_as_Ref s, Int_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Int_copy(Val_as_Ref s, Ref_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Int_copy(Val_as_Ref s, Val_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Ref_copy(Val_as_Ref s, Ref_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Ref_copy(Val_as_Ref s, Val_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Val_copy(Val_as_Ref s, Val_as_Val d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Val_to_Obj_copy(Val_as_Val s, Obj_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Obj_copy(Val_as_Val s, Int_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Obj_copy(Val_as_Val s, Ref_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Obj_copy(Val_as_Val s, Val_as_Obj d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Int_copy(Val_as_Val s, Int_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Int_copy(Val_as_Val s, Ref_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Int_copy(Val_as_Val s, Val_as_Int d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Ref_copy(Val_as_Val s, Val_as_Ref d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        Q64long[] src = s.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            d.arr[i] = src[i];\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/InlineCopy1.java","additions":933,"deletions":0,"binary":false,"changes":933,"status":"added"},{"patch":"@@ -0,0 +1,1035 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class InlineCopy2 extends StatesQ64long {\n+\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Obj_copy(Obj_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Int_copy(Obj_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Ref_copy(Obj_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Val_copy(Obj_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Obj_copy(Int_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Int_copy(Int_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Ref_copy(Int_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Val_copy(Int_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Obj_copy(Ref_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Int_copy(Ref_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Ref_copy(Ref_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Val_copy(Ref_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_to_Obj_copy(Val_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Obj_copy(Val_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Obj_copy(Val_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Obj_copy(Val_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Int_copy(Val_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Int_copy(Val_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Int_copy(Val_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Ref_copy(Val_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Ref_copy(Val_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Val_copy(Val_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Obj_copy(Int_as_Int s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Int_copy(Int_as_Int s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Ref_copy(Int_as_Int s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Val_copy(Int_as_Int s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Obj_copy(Ref_as_Int s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Int_copy(Ref_as_Int s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Ref_copy(Ref_as_Int s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Val_copy(Ref_as_Int s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Int_to_Obj_copy(Val_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Obj_copy(Val_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Obj_copy(Val_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Obj_copy(Val_as_Int s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Int_copy(Val_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Int_copy(Val_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Int_copy(Val_as_Int s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Ref_copy(Val_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Ref_copy(Val_as_Int s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Val_copy(Val_as_Int s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Obj_copy(Ref_as_Ref s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Int_copy(Ref_as_Ref s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Ref_copy(Ref_as_Ref s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Ref_to_Obj_copy(Val_as_Ref s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Obj_copy(Val_as_Ref s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Obj_copy(Val_as_Ref s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Obj_copy(Val_as_Ref s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Int_copy(Val_as_Ref s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Int_copy(Val_as_Ref s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Int_copy(Val_as_Ref s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Ref_copy(Val_as_Ref s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Ref_copy(Val_as_Ref s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Val_copy(Val_as_Ref s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Val_to_Obj_copy(Val_as_Val s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Obj_copy(Val_as_Val s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Obj_copy(Val_as_Val s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Obj_copy(Val_as_Val s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        Object[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Int_copy(Val_as_Val s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Int_copy(Val_as_Val s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Int_copy(Val_as_Val s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        Int64[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Ref_copy(Val_as_Val s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        Q64long[] dst = d.arr;\n+        for (int i = 0; i < len; i++) {\n+            dst[i] = s.arr[i];\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/InlineCopy2.java","additions":1035,"deletions":0,"binary":false,"changes":1035,"status":"added"},{"patch":"@@ -0,0 +1,935 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.copy;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class InlineCopy3 extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_to_Obj_copy(Obj_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Obj_copy(Obj_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Obj_copy(Obj_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Obj_copy(Obj_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_to_Int_copy(Obj_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Int_copy(Obj_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Int_copy(Obj_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_to_Ref_copy(Obj_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Ref_copy(Obj_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_to_Val_copy(Obj_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_to_Obj_copy(Int_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Obj_copy(Int_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Obj_copy(Int_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Obj_copy(Int_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_to_Int_copy(Int_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Int_copy(Int_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Int_copy(Int_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_to_Ref_copy(Int_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Ref_copy(Int_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_to_Val_copy(Int_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_to_Obj_copy(Ref_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Obj_copy(Ref_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Obj_copy(Ref_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Obj_copy(Ref_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_to_Int_copy(Ref_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Int_copy(Ref_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Int_copy(Ref_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_to_Ref_copy(Ref_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Ref_copy(Ref_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_to_Val_copy(Ref_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_to_Obj_copy(Val_as_Obj s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Obj_copy(Val_as_Obj s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Obj_copy(Val_as_Obj s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Obj_copy(Val_as_Obj s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_to_Int_copy(Val_as_Obj s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Int_copy(Val_as_Obj s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Int_copy(Val_as_Obj s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Int64)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_to_Ref_copy(Val_as_Obj s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Ref_copy(Val_as_Obj s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_to_Val_copy(Val_as_Obj s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Int_to_Obj_copy(Int_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Obj_copy(Int_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Obj_copy(Int_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Obj_copy(Int_as_Int s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_to_Int_copy(Int_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Int_copy(Int_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Int_copy(Int_as_Int s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_to_Ref_copy(Int_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Ref_copy(Int_as_Int s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_to_Val_copy(Int_as_Int s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Int_to_Obj_copy(Ref_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Obj_copy(Ref_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Obj_copy(Ref_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Obj_copy(Ref_as_Int s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_to_Int_copy(Ref_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Int_copy(Ref_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Int_copy(Ref_as_Int s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_to_Ref_copy(Ref_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Ref_copy(Ref_as_Int s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_to_Val_copy(Ref_as_Int s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Int_to_Obj_copy(Val_as_Int s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Obj_copy(Val_as_Int s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Obj_copy(Val_as_Int s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Obj_copy(Val_as_Int s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_to_Int_copy(Val_as_Int s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Int_copy(Val_as_Int s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Int_copy(Val_as_Int s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_to_Ref_copy(Val_as_Int s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Ref_copy(Val_as_Int s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_to_Val_copy(Val_as_Int s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = (Q64long)s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Ref_to_Obj_copy(Ref_as_Ref s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Obj_copy(Ref_as_Ref s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Obj_copy(Ref_as_Ref s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Obj_copy(Ref_as_Ref s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Ref_to_Int_copy(Ref_as_Ref s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Int_copy(Ref_as_Ref s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Int_copy(Ref_as_Ref s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_to_Ref_copy(Ref_as_Ref s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Ref_copy(Ref_as_Ref s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_to_Val_copy(Ref_as_Ref s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Ref_to_Obj_copy(Val_as_Ref s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Obj_copy(Val_as_Ref s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Obj_copy(Val_as_Ref s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Obj_copy(Val_as_Ref s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Ref_to_Int_copy(Val_as_Ref s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Int_copy(Val_as_Ref s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Int_copy(Val_as_Ref s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_to_Ref_copy(Val_as_Ref s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Ref_copy(Val_as_Ref s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_to_Val_copy(Val_as_Ref s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Val_to_Obj_copy(Val_as_Val s, Obj_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Obj_copy(Val_as_Val s, Int_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Obj_copy(Val_as_Val s, Ref_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Obj_copy(Val_as_Val s, Val_as_Obj d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Val_to_Int_copy(Val_as_Val s, Int_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Int_copy(Val_as_Val s, Ref_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Int_copy(Val_as_Val s, Val_as_Int d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Val_to_Ref_copy(Val_as_Val s, Ref_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Ref_copy(Val_as_Val s, Val_as_Ref d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_to_Val_copy(Val_as_Val s, Val_as_Val d) {\n+        int len = s.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            d.arr[i] = s.arr[i];\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/copy\/InlineCopy3.java","additions":935,"deletions":0,"binary":false,"changes":935,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import java.util.Arrays;\n+\n+public class Inline64longFillDef extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_fill0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_fill1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Ref_fill0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Ref_fill1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_fill1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Int_fill0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Int_fill1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Int_fill0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Int_fill1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Int_as_Int_fill0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Int_as_Int_fill1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Obj_fill0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Obj_fill1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Obj_fill0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Obj_fill1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Int_as_Obj_fill0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Int_as_Obj_fill1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Obj_as_Obj_fill0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Obj_as_Obj_fill1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Ref_arrayfill(Val_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Int_arrayfill(Val_as_Int st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Int_arrayfill(Ref_as_Int st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Int_as_Int_arrayfill(Int_as_Int st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_as_Obj_arrayfill(Val_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_as_Obj_arrayfill(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Int_as_Obj_arrayfill(Int_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Obj_as_Obj_arrayfill(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long()  );\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillDef.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillInstInt extends StatesQ64long {\n+\n+\n+    @State(Scope.Thread)\n+    public static class InstanceField {\n+        Q64long f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_fillinst0( Val_as_Val st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_fillinst1( Val_as_Val st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_fillinst0( Val_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_fillinst1( Val_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_fillinst0( Ref_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_fillinst1( Ref_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_fillinst0( Val_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_fillinst1( Val_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_fillinst0( Ref_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_fillinst1( Ref_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_fillinst0( Int_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_fillinst1( Int_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_fillinst0( Val_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_fillinst1( Val_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_fillinst0( Ref_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_fillinst1( Ref_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_fillinst0( Int_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_fillinst1( Int_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_fillinst0( Obj_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_fillinst1( Obj_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_arrayfill_arrayfillinst(Val_as_Val st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_arrayfillinst(Val_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_arrayfillinst(Val_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_arrayfillinst(Ref_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_arrayfillinst(Int_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_arrayfillinst(Val_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_arrayfillinst(Ref_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_arrayfillinst(Int_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_arrayfillinst(Obj_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillInstInt.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillInstObj extends StatesQ64long {\n+\n+\n+    @State(Scope.Thread)\n+    public static class InstanceField {\n+        Object f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_fillinst0(Val_as_Val st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_fillinst1(Val_as_Val st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_fillinst0(Val_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_fillinst1(Val_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_fillinst0(Ref_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_fillinst1(Ref_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_fillinst0(Val_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_fillinst1(Val_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_fillinst0(Ref_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_fillinst1(Ref_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_fillinst0(Int_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_fillinst1(Int_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64) f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_fillinst0(Val_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_fillinst1(Val_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_fillinst0(Ref_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_fillinst1(Ref_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_fillinst0(Int_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_fillinst1(Int_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_fillinst0(Obj_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_fillinst1(Obj_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_arrayfillinst(Val_as_Val st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_arrayfillinst(Val_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_arrayfillinst(Val_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_arrayfillinst(Ref_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_arrayfillinst(Int_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_arrayfillinst(Val_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_arrayfillinst(Ref_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_arrayfillinst(Int_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_arrayfillinst(Obj_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillInstObj.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillInstRef extends StatesQ64long {\n+\n+\n+    @State(Scope.Thread)\n+    public static class InstanceField {\n+        Q64long f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillinst0(Val_as_Val st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillinst1(Val_as_Val st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_fillinst0(Val_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_fillinst1(Val_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst0(Ref_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillinst1(Ref_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_fillinst0(Val_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_fillinst1(Val_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_fillinst0(Ref_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_fillinst1(Ref_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_fillinst0(Int_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_fillinst1(Int_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_fillinst0(Val_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_fillinst1(Val_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_fillinst0(Ref_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_fillinst1(Ref_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_fillinst0(Int_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_fillinst1(Int_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_fillinst0(Obj_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_fillinst1(Obj_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillinst(Val_as_Val st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_arrayfillinst(Val_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_arrayfillinst(Val_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_arrayfillinst(Ref_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_arrayfillinst(Int_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_arrayfillinst(Val_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_arrayfillinst(Ref_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_arrayfillinst(Int_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_arrayfillinst(Obj_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillInstRef.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillInstVal extends StatesQ64long {\n+\n+\n+    @State(Scope.Thread)\n+    public static class InstanceField {\n+        Q64long f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillinst0(Val_as_Val st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillinst1(Val_as_Val st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_fillinst0(Val_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_fillinst1(Val_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillinst0(Ref_as_Ref st, InstanceField f) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillinst1(Ref_as_Ref st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_fillinst0(Val_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_fillinst1(Val_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_fillinst0(Ref_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_fillinst1(Ref_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_fillinst0(Int_as_Int st, InstanceField f) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_fillinst1(Int_as_Int st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_fillinst0(Val_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_fillinst1(Val_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_fillinst0(Ref_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_fillinst1(Ref_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_fillinst0(Int_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_fillinst1(Int_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_fillinst0(Obj_as_Obj st, InstanceField f) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_fillinst1(Obj_as_Obj st, InstanceField f) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = f.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillinst(Val_as_Val st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_arrayfillinst(Val_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillinst(Ref_as_Ref st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_arrayfillinst(Val_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_arrayfillinst(Ref_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_arrayfillinst(Int_as_Int st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_arrayfillinst(Val_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_arrayfillinst(Ref_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_arrayfillinst(Int_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_arrayfillinst(Obj_as_Obj st, InstanceField f) {\n+        Arrays.fill(st.arr, f.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillInstVal.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillInt extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Int64 get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_fill0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_fill1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_fill0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_fill1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_fill0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_fill1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_fill0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_fill1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_fill0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_fill1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_fill0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_fill1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_fill0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_fill1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_fill0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_fill1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_fill0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_fill1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_fill0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Int64 v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_fill1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        Int64 v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_arrayfill(Val_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_arrayfill(Val_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_arrayfill(Ref_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_arrayfill(Int_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_arrayfill(Val_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_arrayfill(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_arrayfill(Int_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_arrayfill(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillInt.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillNew extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_fill0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_fill1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Ref_fill0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Ref_fill1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_fill1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Int_fill0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Int_fill1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Int_fill0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Int_fill1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Int_fill0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Int_fill1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Obj_fill0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Obj_fill1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Obj_fill0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Obj_fill1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Obj_fill0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Obj_fill1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Obj_as_Obj_fill0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Obj_as_Obj_fill1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = new Q64long(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Ref_arrayfill(Val_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Int_arrayfill(Val_as_Int st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Int_arrayfill(Ref_as_Int st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Int_arrayfill(Int_as_Int st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Obj_arrayfill(Val_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Obj_arrayfill(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Obj_arrayfill(Int_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Obj_as_Obj_arrayfill(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, new Q64long(42));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillNew.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillObj extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Object get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_fill0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_fill1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_fill0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_fill1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_fill0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_fill1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_fill0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_fill1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_fill0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_fill1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_fill0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_fill1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64)v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_fill0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_fill1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_fill0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_fill1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_fill0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_fill1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_fill0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Object v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_fill1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        Object v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_arrayfill(Val_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_arrayfill(Val_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_arrayfill(Ref_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_arrayfill(Int_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_arrayfill(Val_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_arrayfill(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_arrayfill(Int_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_arrayfill(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillObj.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillRef extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64long get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fill0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fill1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_fill0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_fill1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fill0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fill1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_fill0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_fill1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_fill0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_fill1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_fill0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_fill1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_fill0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_fill1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_fill0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_fill1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_fill0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_fill1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_fill0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_fill1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_arrayfill(Val_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_arrayfill(Val_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_arrayfill(Ref_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_arrayfill(Int_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_arrayfill(Val_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_arrayfill(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_arrayfill(Int_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_arrayfill(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillRef.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillStatInt extends StatesQ64long {\n+\n+    public static class StaticField {\n+        static Int64 f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_fillstat0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_fillstat1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_fillstat0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_fillstat1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_fillstat0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_fillstat1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_fillstat0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_fillstat1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_fillstat0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_fillstat1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_fillstat0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_fillstat1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_fillstat0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_fillstat1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_fillstat0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_fillstat1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_fillstat0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_fillstat1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_fillstat0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_fillstat1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_arrayfillstat(Val_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_arrayfillstat(Val_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_arrayfillstat(Ref_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_arrayfillstat(Int_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_arrayfillstat(Val_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_arrayfillstat(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_arrayfillstat(Int_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_arrayfillstat(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillStatInt.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillStatObj extends StatesQ64long {\n+\n+    public static class StaticField {\n+        static Object f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_fillstat0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_fillstat1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_fillstat0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_fillstat1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_fillstat0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_fillstat1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_fillstat0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64) StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_fillstat1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64) StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_fillstat0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64) StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_fillstat1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64) StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_fillstat0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64) StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_fillstat1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64) StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_fillstat0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_fillstat1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_fillstat0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_fillstat1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_fillstat0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_fillstat1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_fillstat0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_fillstat1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_arrayfillstat(Val_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_arrayfillstat(Val_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_arrayfillstat(Ref_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_arrayfillstat(Int_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_arrayfillstat(Val_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_arrayfillstat(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_arrayfillstat(Int_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_arrayfillstat(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillStatObj.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillStatRef extends StatesQ64long {\n+\n+    public static class StaticField {\n+        static Q64long f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillstat0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_fillstat1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_fillstat0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_fillstat1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillstat0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_fillstat1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_fillstat0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_fillstat1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_fillstat0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_fillstat1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_fillstat0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_fillstat1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_fillstat0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_fillstat1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_fillstat0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_fillstat1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_fillstat0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_fillstat1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_fillstat0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_fillstat1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_arrayfillstat(Val_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_arrayfillstat(Val_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_arrayfillstat(Ref_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_arrayfillstat(Int_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_arrayfillstat(Val_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_arrayfillstat(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_arrayfillstat(Int_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_arrayfillstat(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillStatRef.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillStatVal extends StatesQ64long {\n+\n+    public static class StaticField {\n+        static Q64long f = new Q64long(42);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillstat0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fillstat1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_fillstat0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_fillstat1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillstat0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fillstat1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_fillstat0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_fillstat1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_fillstat0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_fillstat1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_fillstat0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_fillstat1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_fillstat0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_fillstat1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_fillstat0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_fillstat1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_fillstat0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_fillstat1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_fillstat0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_fillstat1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = StaticField.f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfillstat(Val_as_Val st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_arrayfillstat(Val_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfillstat(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_arrayfillstat(Val_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_arrayfillstat(Ref_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_arrayfillstat(Int_as_Int st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_arrayfillstat(Val_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_arrayfillstat(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_arrayfillstat(Int_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_arrayfillstat(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, StaticField.f);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillStatVal.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.fill;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+import java.util.Arrays;\n+\n+public class Inline64longFillVal extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64long get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fill0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_fill1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_fill0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_fill1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fill0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_fill1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_fill0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_fill1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_fill0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_fill1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_fill0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_fill1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_fill0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_fill1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_fill0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_fill1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_fill0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_fill1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_fill0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        Q64long v = get(42);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_fill1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        Q64long v = get(42);\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = v;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_arrayfill(Val_as_Val st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_arrayfill(Val_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_arrayfill(Ref_as_Ref st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_arrayfill(Val_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_arrayfill(Ref_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_arrayfill(Int_as_Int st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_arrayfill(Val_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_arrayfill(Ref_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_arrayfill(Int_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_arrayfill(Obj_as_Obj st) {\n+        Arrays.fill(st.arr, get(42));\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/fill\/Inline64longFillVal.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.read;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64long extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q64long v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q64long v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void int_consume(Int64 v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void obj_consume(Object v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Val_read(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Ref_read(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Int_read(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Val_to_Obj_read(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Val_read(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Ref_read(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Int_read(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Ref_to_Obj_read(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Int_to_Int_read(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Int_to_Obj_read(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_as_Obj_to_Obj_read(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_as_Ref_to_Val_read(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_as_Ref_to_Ref_read(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_as_Ref_to_Int_read(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_as_Ref_to_Obj_read(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_as_Int_to_Int_read(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_as_Int_to_Obj_read(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_as_Obj_to_Obj_read(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i]);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/read\/Inline64long.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.set;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64longSetInt extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Int64 get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_set0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Val_set1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_set0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Ref_set1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_set0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Ref_set1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_set0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Int_set1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_set0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Int_set1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_set0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Int_set1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_set0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_as_Obj_set1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_set0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_as_Obj_set1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_set0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_as_Obj_set1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_set0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_as_Obj_set1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/set\/Inline64longSetInt.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.set;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64longSetNew extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_set0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Val_set1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Ref_set0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Ref_set1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_set0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Ref_set1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Int_set0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Int_set1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Int_set0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Int_set1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Int_set0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Int_set1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Obj_set0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_as_Obj_set1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Obj_set0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_as_Obj_set1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Obj_set0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Int_as_Obj_set1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Obj_as_Obj_set0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Obj_as_Obj_set1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = new Q64long(i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/set\/Inline64longSetNew.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.set;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64longSetObj extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Object get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_set0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Val_set1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_set0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Ref_set1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_set0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Ref_set1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Q64long)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_set0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Int_set1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_set0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Int_set1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_set0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (Int64)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Int_set1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = (Int64)get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_set0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_as_Obj_set1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_set0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_as_Obj_set1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_set0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_as_Obj_set1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_set0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_as_Obj_set1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/set\/Inline64longSetObj.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.set;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64longSetRef extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64long get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_set0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Val_set1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_set0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Ref_set1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_set0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Ref_set1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_set0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Int_set1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_set0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Int_set1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_set0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Int_set1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_set0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_as_Obj_set1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_set0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_as_Obj_set1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_set0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_as_Obj_set1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_set0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_as_Obj_set1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/set\/Inline64longSetRef.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.set;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64longSetVal extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64long get(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_set0(Val_as_Val st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Val_set1(Val_as_Val st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_set0(Val_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Ref_set1(Val_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_set0(Ref_as_Ref st) {\n+        Q64long[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Ref_set1(Ref_as_Ref st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_set0(Val_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Int_set1(Val_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_set0(Ref_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Int_set1(Ref_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_set0(Int_as_Int st) {\n+        Int64[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Int_set1(Int_as_Int st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_set0(Val_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_as_Obj_set1(Val_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_set0(Ref_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_as_Obj_set1(Ref_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_set0(Int_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_as_Obj_set1(Int_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_set0(Obj_as_Obj st) {\n+        Object[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = get(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_as_Obj_set1(Obj_as_Obj st) {\n+        int len = st.arr.length;\n+        for (int i = 0; i < len; i++) {\n+            st.arr[i] = get(i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/set\/Inline64longSetVal.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.sum;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesR64long;\n+import org.openjdk.bench.valhalla.types.A64long;\n+import org.openjdk.bench.valhalla.types.ByLong;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Identity64long extends StatesR64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Ref_fields(Ref_as_Ref st) {\n+        long s = 0;\n+        R64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Abs_sum(Ref_as_Abs st) {\n+        long s = 0;\n+        A64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Int_sum(Ref_as_By st) {\n+        long s = 0;\n+        ByLong[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Abs_as_Abs_sum(Abs_as_Abs st) {\n+        long s = 0;\n+        A64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Abs_as_Int_sum(Abs_as_By st) {\n+        long s = 0;\n+        ByLong[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Int_as_Int_sum(By_as_By st) {\n+        long s = 0;\n+        ByLong[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/sum\/Identity64long.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.sum;\n+\n+import org.openjdk.bench.valhalla.arraytotal.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.ByLong;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64long extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Val_fields0(Val_as_Val st) {\n+        long s = 0;\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Val_fields1(Val_as_Val st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Ref_fields0(Val_as_Ref st) {\n+        long s = 0;\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Ref_fields1(Val_as_Ref st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Ref_fields0(Ref_as_Ref st) {\n+        long s = 0;\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Ref_fields1(Ref_as_Ref st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].v0;\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Val_sum0(Val_as_Val st) {\n+        long s = 0;\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Val_sum1(Val_as_Val st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Ref_sum0(Val_as_Ref st) {\n+        long s = 0;\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Ref_sum1(Val_as_Ref st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Int_sum0(Val_as_By st) {\n+        long s = 0;\n+        ByLong[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Val_as_Int_sum1(Val_as_By st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Ref_sum0(Ref_as_Ref st) {\n+        long s = 0;\n+        Q64long[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Ref_sum1(Ref_as_Ref st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Int_sum0(Ref_as_By st) {\n+        long s = 0;\n+        ByLong[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Ref_as_Int_sum1(Ref_as_By st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Int_as_Int_sum0(By_as_By st) {\n+        long s = 0;\n+        ByLong[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            s += arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Int_as_Int_sum1(By_as_By st) {\n+        long s = 0;\n+        int len = st.arr.length;\n+        for(int i=0; i < len; i++) {\n+            s += st.arr[i].longSum();\n+        }\n+        return s;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/sum\/Inline64long.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.util;\n+\n+import org.openjdk.bench.valhalla.types.ByLong;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ64long extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q64long[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q64long[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64long(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static abstract class ByState extends SizeState {\n+        public ByLong[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Q64long(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class By_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new ByLong[size];\n+            fill();\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/util\/StatesQ64long.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.arraytotal.util;\n+\n+import org.openjdk.bench.valhalla.types.ByLong;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.bench.valhalla.types.A64long;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesR64long extends SizeBase {\n+\n+    public static abstract class ObjState extends SizeState {\n+        public Object[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class AbsState extends SizeState {\n+        public A64long[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64long(i);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public R64long[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64long(i);\n+            }\n+        }\n+    }\n+\n+    \/\/ naming convention: <runtime array type>_as_<static array type>\n+\n+    public static class Obj_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Abs_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new A64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Abs_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new A64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Abs_as_Abs extends AbsState {\n+        @Setup\n+        public void setup() {\n+            arr = new A64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Abs extends AbsState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static abstract class ByState extends SizeState {\n+        public ByLong[] arr;\n+        void fill() {\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new R64long(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Abs_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new A64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class By_as_By extends ByState {\n+        @Setup\n+        public void setup() {\n+            arr = new ByLong[size];\n+            fill();\n+        }\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/arraytotal\/util\/StatesR64long.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.callconv;\n+\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class Inline64byte {\n+\n+    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n+\n+    public abstract static class InvocationLogic {\n+        public abstract Q64byte compute(Q64byte v1);\n+        public abstract Q64byte compute(Q64byte v1, Q64byte v2);\n+        public abstract Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4);\n+        public abstract Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4, Q64byte v5, Q64byte v6, Q64byte v7, Q64byte v8);\n+    }\n+\n+    public static class InvokeImpl1 extends InvocationLogic {\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4, Q64byte v5, Q64byte v6, Q64byte v7, Q64byte v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl2 extends InvocationLogic {\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4, Q64byte v5, Q64byte v6, Q64byte v7, Q64byte v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl3 extends InvocationLogic {\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64byte compute(Q64byte v1, Q64byte v2, Q64byte v3, Q64byte v4, Q64byte v5, Q64byte v6, Q64byte v7, Q64byte v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+\n+    private static InvocationLogic getImpl(int i, int targets) {\n+        switch (i % targets) {\n+            case 0:\n+                return new InvokeImpl1();\n+            case 1:\n+                return new InvokeImpl2();\n+            case 2:\n+                return new InvokeImpl3();\n+        }\n+        return null;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class StateTargets0 {\n+        InvokeImpl1[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new InvokeImpl1[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = new InvokeImpl1();\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class StateTargets {\n+        InvocationLogic[] arr;\n+\n+        public void init(int targets) {\n+            arr = new InvocationLogic[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = getImpl(i, targets);\n+            }\n+        }\n+    }\n+\n+    public static class StateTargets1 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(1);\n+        }\n+    }\n+\n+    public static class StateTargets2 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(2);\n+        }\n+    }\n+\n+    public static class StateTargets3 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(3);\n+        }\n+    }\n+\n+    Q64byte a0 = new Q64byte(42);\n+    Q64byte a1 = new Q64byte(43);\n+    Q64byte a2 = new Q64byte(44);\n+    Q64byte a3 = new Q64byte(45);\n+    Q64byte a4 = new Q64byte(46);\n+    Q64byte a5 = new Q64byte(47);\n+    Q64byte a6 = new Q64byte(48);\n+    Q64byte a7 = new Q64byte(49);\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args1(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args2(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args4(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args8(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args1_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args2_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args4_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args8_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args1_targets1(StateTargets1 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args2_targets1(StateTargets1 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args4_targets1(StateTargets1 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args8_targets1(StateTargets1 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args1_targets2(StateTargets2 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args2_targets2(StateTargets2 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args4_targets2(StateTargets2 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args8_targets2(StateTargets2 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args1_targets3(StateTargets3 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args2_targets3(StateTargets3 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args4_targets3(StateTargets3 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64byte_args8_targets3(StateTargets3 st) {\n+        return args8(st.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Inline64byte.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.callconv;\n+\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class Inline64int {\n+\n+    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n+\n+    public abstract static class InvocationLogic {\n+        public abstract Q64int compute(Q64int v1);\n+        public abstract Q64int compute(Q64int v1, Q64int v2);\n+        public abstract Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4);\n+        public abstract Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4, Q64int v5, Q64int v6, Q64int v7, Q64int v8);\n+    }\n+\n+    public static class InvokeImpl1 extends InvocationLogic {\n+\n+        @Override\n+        public Q64int compute(Q64int v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4, Q64int v5, Q64int v6, Q64int v7, Q64int v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl2 extends InvocationLogic {\n+\n+        @Override\n+        public Q64int compute(Q64int v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4, Q64int v5, Q64int v6, Q64int v7, Q64int v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl3 extends InvocationLogic {\n+\n+        @Override\n+        public Q64int compute(Q64int v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64int compute(Q64int v1, Q64int v2, Q64int v3, Q64int v4, Q64int v5, Q64int v6, Q64int v7, Q64int v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+\n+    private static InvocationLogic getImpl(int i, int targets) {\n+        switch (i % targets) {\n+            case 0:\n+                return new InvokeImpl1();\n+            case 1:\n+                return new InvokeImpl2();\n+            case 2:\n+                return new InvokeImpl3();\n+        }\n+        return null;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class StateTargets0 {\n+        InvokeImpl1[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new InvokeImpl1[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = new InvokeImpl1();\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class StateTargets {\n+        InvocationLogic[] arr;\n+\n+        public void init(int targets) {\n+            arr = new InvocationLogic[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = getImpl(i, targets);\n+            }\n+        }\n+    }\n+\n+    public static class StateTargets1 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(1);\n+        }\n+    }\n+\n+    public static class StateTargets2 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(2);\n+        }\n+    }\n+\n+    public static class StateTargets3 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(3);\n+        }\n+    }\n+\n+    Q64int a0 = new Q64int(42);\n+    Q64int a1 = new Q64int(43);\n+    Q64int a2 = new Q64int(44);\n+    Q64int a3 = new Q64int(45);\n+    Q64int a4 = new Q64int(46);\n+    Q64int a5 = new Q64int(47);\n+    Q64int a6 = new Q64int(48);\n+    Q64int a7 = new Q64int(49);\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args1(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args2(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args4(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args8(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args1_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args2_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args4_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args8_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args1_targets1(StateTargets1 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args2_targets1(StateTargets1 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args4_targets1(StateTargets1 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args8_targets1(StateTargets1 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args1_targets2(StateTargets2 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args2_targets2(StateTargets2 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args4_targets2(StateTargets2 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args8_targets2(StateTargets2 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args1_targets3(StateTargets3 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args2_targets3(StateTargets3 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args4_targets3(StateTargets3 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64int_args8_targets3(StateTargets3 st) {\n+        return args8(st.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Inline64int.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.callconv;\n+\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class Inline64long {\n+\n+    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n+\n+    public abstract static class InvocationLogic {\n+        public abstract Q64long compute(Q64long v1);\n+        public abstract Q64long compute(Q64long v1, Q64long v2);\n+        public abstract Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4);\n+        public abstract Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4, Q64long v5, Q64long v6, Q64long v7, Q64long v8);\n+    }\n+\n+    public static class InvokeImpl1 extends InvocationLogic {\n+\n+        @Override\n+        public Q64long compute(Q64long v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4, Q64long v5, Q64long v6, Q64long v7, Q64long v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl2 extends InvocationLogic {\n+\n+        @Override\n+        public Q64long compute(Q64long v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4, Q64long v5, Q64long v6, Q64long v7, Q64long v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl3 extends InvocationLogic {\n+\n+        @Override\n+        public Q64long compute(Q64long v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public Q64long compute(Q64long v1, Q64long v2, Q64long v3, Q64long v4, Q64long v5, Q64long v6, Q64long v7, Q64long v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+\n+    private static InvocationLogic getImpl(int i, int targets) {\n+        switch (i % targets) {\n+            case 0:\n+                return new InvokeImpl1();\n+            case 1:\n+                return new InvokeImpl2();\n+            case 2:\n+                return new InvokeImpl3();\n+        }\n+        return null;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class StateTargets0 {\n+        InvokeImpl1[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new InvokeImpl1[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = new InvokeImpl1();\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class StateTargets {\n+        InvocationLogic[] arr;\n+\n+        public void init(int targets) {\n+            arr = new InvocationLogic[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = getImpl(i, targets);\n+            }\n+        }\n+    }\n+\n+    public static class StateTargets1 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(1);\n+        }\n+    }\n+\n+    public static class StateTargets2 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(2);\n+        }\n+    }\n+\n+    public static class StateTargets3 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(3);\n+        }\n+    }\n+\n+    Q64long a0 = new Q64long(42);\n+    Q64long a1 = new Q64long(43);\n+    Q64long a2 = new Q64long(44);\n+    Q64long a3 = new Q64long(45);\n+    Q64long a4 = new Q64long(46);\n+    Q64long a5 = new Q64long(47);\n+    Q64long a6 = new Q64long(48);\n+    Q64long a7 = new Q64long(49);\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args1(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args2(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args4(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args8(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args1_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args2_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args4_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args8_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7).longValue();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args1_targets1(StateTargets1 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args2_targets1(StateTargets1 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args4_targets1(StateTargets1 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args8_targets1(StateTargets1 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args1_targets2(StateTargets2 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args2_targets2(StateTargets2 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args4_targets2(StateTargets2 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args8_targets2(StateTargets2 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args1_targets3(StateTargets3 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args2_targets3(StateTargets3 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args4_targets3(StateTargets3 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long Q64long_args8_targets3(StateTargets3 st) {\n+        return args8(st.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Inline64long.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Primitive1 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public abstract static class InvocationLogic {\n-        public abstract int compute(int v1);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    int a0 = 42;\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void primitive_args1(Blackhole bh, StateTargets st) {\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(a0));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Primitive1.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Primitive2 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public abstract static class InvocationLogic {\n-        public abstract int compute(int v1, int v2);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    int a0 = 42;\n-    int a1 = 43;\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void primitive_args2(Blackhole bh, StateTargets st) {\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(a0, a1));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Primitive2.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Primitive4 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public abstract static class InvocationLogic {\n-        public abstract int compute(int v1, int v2, int v3, int v4);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2, int v3, int v4) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2, int v3, int v4) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2, int v3, int v4) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    int a0 = 42;\n-    int a1 = 43;\n-    int a2 = 44;\n-    int a3 = 45;\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void primitive_args4(Blackhole bh, StateTargets st) {\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(a0, a1, a2, a3));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Primitive4.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Primitive8 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public abstract static class InvocationLogic {\n-        public abstract int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    int a0 = 42;\n-    int a1 = 43;\n-    int a2 = 44;\n-    int a3 = 45;\n-    int a4 = 46;\n-    int a5 = 47;\n-    int a6 = 48;\n-    int a7 = 49;\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void primitive_args8(Blackhole bh, StateTargets st) {\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(a0, a1, a2, a3, a4, a5, a6, a7));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Primitive8.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.callconv;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class PrimitiveByte {\n+\n+    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n+\n+    public abstract static class InvocationLogic {\n+        public abstract byte compute(byte v1);\n+        public abstract byte compute(byte v1, byte v2);\n+        public abstract byte compute(byte v1, byte v2, byte v3, byte v4);\n+        public abstract byte compute(byte v1, byte v2, byte v3, byte v4, byte v5, byte v6, byte v7, byte v8);\n+    }\n+\n+    public static class InvokeImpl1 extends InvocationLogic {\n+\n+        @Override\n+        public byte compute(byte v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2, byte v3, byte v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2, byte v3, byte v4, byte v5, byte v6, byte v7, byte v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl2 extends InvocationLogic {\n+\n+        @Override\n+        public byte compute(byte v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2, byte v3, byte v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2, byte v3, byte v4, byte v5, byte v6, byte v7, byte v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl3 extends InvocationLogic {\n+\n+        @Override\n+        public byte compute(byte v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2, byte v3, byte v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public byte compute(byte v1, byte v2, byte v3, byte v4, byte v5, byte v6, byte v7, byte v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+\n+    private static InvocationLogic getImpl(int i, int targets) {\n+        switch (i % targets) {\n+            case 0:\n+                return new InvokeImpl1();\n+            case 1:\n+                return new InvokeImpl2();\n+            case 2:\n+                return new InvokeImpl3();\n+        }\n+        return null;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class StateTargets0 {\n+        InvokeImpl1[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new InvokeImpl1[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = new InvokeImpl1();\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class StateTargets {\n+        InvocationLogic[] arr;\n+\n+        public void init(int targets) {\n+            arr = new InvocationLogic[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = getImpl(i, targets);\n+            }\n+        }\n+    }\n+\n+    public static class StateTargets1 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(1);\n+        }\n+    }\n+\n+    public static class StateTargets2 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(2);\n+        }\n+    }\n+\n+    public static class StateTargets3 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(3);\n+        }\n+    }\n+\n+    byte a0 = 42;\n+    byte a1 = 43;\n+    byte a2 = 44;\n+    byte a3 = 45;\n+    byte a4 = 46;\n+    byte a5 = 47;\n+    byte a6 = 48;\n+    byte a7 = 49;\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public byte args1(InvocationLogic[] logic) {\n+        byte r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public byte args2(InvocationLogic[] logic) {\n+        byte r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public byte args4(InvocationLogic[] logic) {\n+        byte r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public byte args8(InvocationLogic[] logic) {\n+        byte r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args1_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        byte r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args2_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        byte r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args4_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        byte r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args8_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        byte r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args1_targets1(StateTargets1 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args2_targets1(StateTargets1 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args4_targets1(StateTargets1 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args8_targets1(StateTargets1 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args1_targets2(StateTargets2 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args2_targets2(StateTargets2 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args4_targets2(StateTargets2 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args8_targets2(StateTargets2 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args1_targets3(StateTargets3 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args2_targets3(StateTargets3 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args4_targets3(StateTargets3 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte byte_args8_targets3(StateTargets3 st) {\n+        return args8(st.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/PrimitiveByte.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -0,0 +1,362 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.callconv;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class PrimitiveInt {\n+\n+    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n+\n+    public abstract static class InvocationLogic {\n+        public abstract int compute(int v1);\n+        public abstract int compute(int v1, int v2);\n+        public abstract int compute(int v1, int v2, int v3, int v4);\n+        public abstract int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8);\n+    }\n+\n+    public static class InvokeImpl1 extends InvocationLogic {\n+\n+        @Override\n+        public int compute(int v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2, int v3, int v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl2 extends InvocationLogic {\n+\n+        @Override\n+        public int compute(int v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2, int v3, int v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {\n+            return v1;\n+        }\n+    }\n+\n+    public static class InvokeImpl3 extends InvocationLogic {\n+\n+        @Override\n+        public int compute(int v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2, int v3, int v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public int compute(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {\n+            return v1;\n+        }\n+    }\n+\n+    private static InvocationLogic getImpl(int i, int targets) {\n+        switch (i % targets) {\n+            case 0:\n+                return new InvokeImpl1();\n+            case 1:\n+                return new InvokeImpl2();\n+            case 2:\n+                return new InvokeImpl3();\n+        }\n+        return null;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class StateTargets0 {\n+        InvokeImpl1[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new InvokeImpl1[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = new InvokeImpl1();\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class StateTargets {\n+        InvocationLogic[] arr;\n+\n+        public void init(int targets) {\n+            arr = new InvocationLogic[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = getImpl(i, targets);\n+            }\n+        }\n+    }\n+\n+    public static class StateTargets1 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(1);\n+        }\n+    }\n+\n+    public static class StateTargets2 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(2);\n+        }\n+    }\n+\n+    public static class StateTargets3 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(3);\n+        }\n+    }\n+\n+    int a0 = 42;\n+    int a1 = 43;\n+    int a2 = 44;\n+    int a3 = 45;\n+    int a4 = 46;\n+    int a5 = 47;\n+    int a6 = 48;\n+    int a7 = 49;\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int args1(InvocationLogic[] logic) {\n+        int r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int args2(InvocationLogic[] logic) {\n+        int r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int args4(InvocationLogic[] logic) {\n+        int r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int args8(InvocationLogic[] logic) {\n+        int r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args1_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        int r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args2_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        int r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args4_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        int r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args8_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        int r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args1_targets1(StateTargets1 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args2_targets1(StateTargets1 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args4_targets1(StateTargets1 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args8_targets1(StateTargets1 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args1_targets2(StateTargets2 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args2_targets2(StateTargets2 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args4_targets2(StateTargets2 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args8_targets2(StateTargets2 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args1_targets3(StateTargets3 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args2_targets3(StateTargets3 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args4_targets3(StateTargets3 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int int_args8_targets3(StateTargets3 st) {\n+        return args8(st.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/PrimitiveInt.java","additions":362,"deletions":0,"binary":false,"changes":362,"status":"added"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.callconv;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class PrimitiveLong {\n+\n+    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n+\n+    public abstract static class InvocationLogic {\n+        public abstract long compute(long v1);\n+        public abstract long compute(long v1, long v2);\n+        public abstract long compute(long v1, long v2, long v3, long v4);\n+        public abstract long compute(long v1, long v2, long v3, long v4, long v5, long v6, long v7, long v8);\n+    }\n+\n+    public static class InvokeImpl1 extends InvocationLogic {\n+\n+        @Override\n+        public long compute(long v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2, long v3, long v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2, long v3, long v4, long v5, long v6, long v7, long v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl2 extends InvocationLogic {\n+\n+        @Override\n+        public long compute(long v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2, long v3, long v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2, long v3, long v4, long v5, long v6, long v7, long v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+    public static class InvokeImpl3 extends InvocationLogic {\n+\n+        @Override\n+        public long compute(long v1) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2, long v3, long v4) {\n+            return v1;\n+        }\n+\n+        @Override\n+        public long compute(long v1, long v2, long v3, long v4, long v5, long v6, long v7, long v8) {\n+            return v1;\n+        }\n+\n+    }\n+\n+\n+    private static InvocationLogic getImpl(int i, int targets) {\n+        switch (i % targets) {\n+            case 0:\n+                return new InvokeImpl1();\n+            case 1:\n+                return new InvokeImpl2();\n+            case 2:\n+                return new InvokeImpl3();\n+        }\n+        return null;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class StateTargets0 {\n+        InvokeImpl1[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new InvokeImpl1[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = new InvokeImpl1();\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class StateTargets {\n+        InvocationLogic[] arr;\n+\n+        public void init(int targets) {\n+            arr = new InvocationLogic[SIZE];\n+            for(int i=0; i < arr.length; i++) {\n+                arr[i] = getImpl(i, targets);\n+            }\n+        }\n+    }\n+\n+    public static class StateTargets1 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(1);\n+        }\n+    }\n+\n+    public static class StateTargets2 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(2);\n+        }\n+    }\n+\n+    public static class StateTargets3 extends StateTargets {\n+        @Setup\n+        public void setup() {\n+            init(3);\n+        }\n+    }\n+\n+    long a0 = 42;\n+    long a1 = 43;\n+    long a2 = 44;\n+    long a3 = 45;\n+    long a4 = 46;\n+    long a5 = 47;\n+    long a6 = 48;\n+    long a7 = 49;\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args1(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args2(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args4(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3);\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public long args8(InvocationLogic[] logic) {\n+        long r = 0;\n+        for(InvocationLogic t : logic) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args1_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args2_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args4_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args8_targets0(StateTargets0 st) {\n+        InvokeImpl1[] arr = st.arr;\n+        long r = 0;\n+        for(InvocationLogic t : arr) {\n+            r += t.compute(a0, a1, a2, a3, a4, a5, a6, a7);\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args1_targets1(StateTargets1 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args2_targets1(StateTargets1 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args4_targets1(StateTargets1 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args8_targets1(StateTargets1 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args1_targets2(StateTargets2 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args2_targets2(StateTargets2 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args4_targets2(StateTargets2 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args8_targets2(StateTargets2 st) {\n+        return args8(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args1_targets3(StateTargets3 st) {\n+        return args1(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args2_targets3(StateTargets3 st) {\n+        return args2(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args4_targets3(StateTargets3 st) {\n+        return args4(st.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long long_args8_targets3(StateTargets3 st) {\n+        return args8(st.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/PrimitiveLong.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value1 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public static value class ValueInt1 {\n-\n-        public final int v0;\n-\n-        public ValueInt1(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-        public static ValueInt1 valueOf(int value) {\n-            return new ValueInt1(value);\n-        }\n-    }\n-\n-    public abstract static class InvocationLogic {\n-        public abstract ValueInt1 compute(ValueInt1 v1);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    ValueInt1 a0 = ValueInt1.valueOf(42);\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args1(Blackhole bh, StateTargets st) {\n-        ValueInt1 v0 = a0;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Value1.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value2 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public static value class ValueInt1 {\n-\n-        public final int v0;\n-\n-        public ValueInt1(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-        public static ValueInt1 valueOf(int value) {\n-            return new ValueInt1(value);\n-        }\n-    }\n-\n-    public static value class ValueInt2 {\n-\n-        public final int v0, v1;\n-\n-        public ValueInt2(int v0, int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-        public static ValueInt2 valueOf(int v0, int v1) {\n-            return new ValueInt2(v0, v1);\n-        }\n-    }\n-\n-    public abstract static class InvocationLogic {\n-        public abstract ValueInt1 compute(ValueInt1 v1, ValueInt1 v2);\n-        public abstract ValueInt2 compute(ValueInt2 v1);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    ValueInt1 a0 = ValueInt1.valueOf(42);\n-    ValueInt1 a1 = ValueInt1.valueOf(43);\n-    ValueInt2 b0 = ValueInt2.valueOf(42, 43);\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args2(Blackhole bh, StateTargets st) {\n-        ValueInt1 v0 = a0;\n-        ValueInt1 v1 = a1;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0, v1));\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args1(Blackhole bh, StateTargets st) {\n-        ValueInt2 v0 = b0;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Value2.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,224 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value4 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public static value class ValueInt1 {\n-\n-        public final int v0;\n-\n-        public ValueInt1(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-        public static ValueInt1 valueOf(int value) {\n-            return new ValueInt1(value);\n-        }\n-    }\n-\n-    public static value class ValueInt2 {\n-\n-        public final int v0, v1;\n-\n-        public ValueInt2(int v0, int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-        public static ValueInt2 valueOf(int v0, int v1) {\n-            return new ValueInt2(v0, v1);\n-        }\n-    }\n-\n-    public static value class ValueInt4 {\n-\n-        public final int v0, v1, v2, v3;\n-\n-        public ValueInt4(int v0, int v1, int v2, int v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-        public static ValueInt4 valueOf(int v0, int v1, int v2, int v3) {\n-            return new ValueInt4(v0, v1, v2, v3);\n-        }\n-    }\n-\n-    public abstract static class InvocationLogic {\n-        public abstract ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4);\n-        public abstract ValueInt2 compute(ValueInt2 v1, ValueInt2 v2);\n-        public abstract ValueInt4 compute(ValueInt4 v1);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1, ValueInt2 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt4 compute(ValueInt4 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1, ValueInt2 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt4 compute(ValueInt4 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1, ValueInt2 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt4 compute(ValueInt4 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    ValueInt1 a0 = ValueInt1.valueOf(42);\n-    ValueInt1 a1 = ValueInt1.valueOf(43);\n-    ValueInt1 a2 = ValueInt1.valueOf(44);\n-    ValueInt1 a3 = ValueInt1.valueOf(45);\n-\n-    ValueInt2 b0 = ValueInt2.valueOf(42, 43);\n-    ValueInt2 b1 = ValueInt2.valueOf(44, 45);\n-\n-    ValueInt4 c0 = ValueInt4.valueOf(42, 43, 44, 45);\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args4(Blackhole bh, StateTargets st) {\n-        ValueInt1 v0 = a0;\n-        ValueInt1 v1 = a1;\n-        ValueInt1 v2 = a2;\n-        ValueInt1 v3 = a3;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0, v1, v2, v3));\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args2(Blackhole bh, StateTargets st) {\n-        ValueInt2 v0 = b0;\n-        ValueInt2 v1 = b1;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0, v1));\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args1(Blackhole bh, StateTargets st) {\n-        ValueInt4 v0 = c0;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Value4.java","additions":0,"deletions":224,"binary":false,"changes":224,"status":"deleted"},{"patch":"@@ -1,288 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.callconv;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value8 {\n-\n-    public static final int SIZE = 96;  \/\/ must be divisible by 2 and 3 and around 100\n-\n-    public static value class ValueInt1 {\n-\n-        public final int v0;\n-\n-        public ValueInt1(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-        public static ValueInt1 valueOf(int value) {\n-            return new ValueInt1(value);\n-        }\n-    }\n-\n-    public static value class ValueInt2 {\n-\n-        public final int v0, v1;\n-\n-        public ValueInt2(int v0, int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-        public static ValueInt2 valueOf(int v0, int v1) {\n-            return new ValueInt2(v0, v1);\n-        }\n-    }\n-\n-    public static value class ValueInt4 {\n-\n-        public final int v0, v1, v2, v3;\n-\n-        public ValueInt4(int v0, int v1, int v2, int v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-        public static ValueInt4 valueOf(int v0, int v1, int v2, int v3) {\n-            return new ValueInt4(v0, v1, v2, v3);\n-        }\n-    }\n-\n-    public static value class ValueInt8 {\n-\n-        public final int v0, v1, v2, v3, v4, v5, v6, v7;\n-\n-        public ValueInt8(int v0, int v1, int v2, int v3, int v4, int v5, int v6, int v7) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-            this.v4 = v4;\n-            this.v5 = v5;\n-            this.v6 = v6;\n-            this.v7 = v7;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-        public static ValueInt8 valueOf(int v0, int v1, int v2, int v3, int v4, int v5, int v6, int v7) {\n-            return new ValueInt8(v0, v1, v2, v3, v4, v5, v6, v7);\n-        }\n-    }\n-\n-    public abstract static class InvocationLogic {\n-        public abstract ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4, ValueInt1 v5, ValueInt1 v6, ValueInt1 v7, ValueInt1 v8);\n-        public abstract ValueInt2 compute(ValueInt2 v1, ValueInt2 v2, ValueInt2 v3, ValueInt2 v4);\n-        public abstract ValueInt4 compute(ValueInt4 v1, ValueInt4 v2);\n-        public abstract ValueInt8 compute(ValueInt8 v1);\n-    }\n-\n-    public static class InvokeImpl1 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4, ValueInt1 v5, ValueInt1 v6, ValueInt1 v7, ValueInt1 v8) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1, ValueInt2 v2, ValueInt2 v3, ValueInt2 v4) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt4 compute(ValueInt4 v1, ValueInt4 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt8 compute(ValueInt8 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl2 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4, ValueInt1 v5, ValueInt1 v6, ValueInt1 v7, ValueInt1 v8) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1, ValueInt2 v2, ValueInt2 v3, ValueInt2 v4) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt4 compute(ValueInt4 v1, ValueInt4 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt8 compute(ValueInt8 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    public static class InvokeImpl3 extends InvocationLogic {\n-        @Override\n-        public ValueInt1 compute(ValueInt1 v1, ValueInt1 v2, ValueInt1 v3, ValueInt1 v4, ValueInt1 v5, ValueInt1 v6, ValueInt1 v7, ValueInt1 v8) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt2 compute(ValueInt2 v1, ValueInt2 v2, ValueInt2 v3, ValueInt2 v4) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt4 compute(ValueInt4 v1, ValueInt4 v2) {\n-            return v1;\n-        }\n-        @Override\n-        public ValueInt8 compute(ValueInt8 v1) {\n-            return v1;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class StateTargets {\n-        InvocationLogic[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new InvocationLogic[SIZE];\n-            Arrays.setAll(arr, i -> getImpl(i, 3));\n-        }\n-\n-        private  InvocationLogic getImpl(int i, int targets) {\n-            return switch (i % targets) {\n-                case 0 -> new InvokeImpl1();\n-                case 1 -> new InvokeImpl2();\n-                default -> new InvokeImpl3();\n-            };\n-        }\n-    }\n-\n-    ValueInt1 a0 = ValueInt1.valueOf(42);\n-    ValueInt1 a1 = ValueInt1.valueOf(43);\n-    ValueInt1 a2 = ValueInt1.valueOf(44);\n-    ValueInt1 a3 = ValueInt1.valueOf(45);\n-    ValueInt1 a4 = ValueInt1.valueOf(46);\n-    ValueInt1 a5 = ValueInt1.valueOf(47);\n-    ValueInt1 a6 = ValueInt1.valueOf(48);\n-    ValueInt1 a7 = ValueInt1.valueOf(49);\n-\n-    ValueInt2 b0 = ValueInt2.valueOf(42, 43);\n-    ValueInt2 b1 = ValueInt2.valueOf(44, 45);\n-    ValueInt2 b2 = ValueInt2.valueOf(46, 47);\n-    ValueInt2 b3 = ValueInt2.valueOf(48, 49);\n-\n-    ValueInt4 c0 = ValueInt4.valueOf(42, 43, 44, 45);\n-    ValueInt4 c1 = ValueInt4.valueOf(46, 47, 48, 49);\n-\n-    ValueInt8 d0 = ValueInt8.valueOf(42, 43, 44, 45, 46, 47, 48, 49);\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args8(Blackhole bh, StateTargets st) {\n-        ValueInt1 v0 = a0;\n-        ValueInt1 v1 = a1;\n-        ValueInt1 v2 = a2;\n-        ValueInt1 v3 = a3;\n-        ValueInt1 v4 = a4;\n-        ValueInt1 v5 = a5;\n-        ValueInt1 v6 = a6;\n-        ValueInt1 v7 = a7;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0, v1, v2, v3, v4, v5, v6, v7));\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args4(Blackhole bh, StateTargets st) {\n-        ValueInt2 v0 = b0;\n-        ValueInt2 v1 = b1;\n-        ValueInt2 v2 = b2;\n-        ValueInt2 v3 = b3;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0, v1, v2, v3));\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args2(Blackhole bh, StateTargets st) {\n-        ValueInt4 v0 = c0;\n-        ValueInt4 v1 = c1;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0, v1));\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE)\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void value_args1(Blackhole bh, StateTargets st) {\n-        ValueInt8 v0 = d0;\n-        InvocationLogic[] arr = st.arr;\n-        for (InvocationLogic t : arr) {\n-            bh.consume(t.compute(v0));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/callconv\/Value8.java","additions":0,"deletions":288,"binary":false,"changes":288,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class CopyBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/CopyBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Identity extends CopyBase {\n-\n-    public static class RefWrapper {\n-        public IdentityInt f;\n-\n-        public RefWrapper(IdentityInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        public InterfaceInt f;\n-\n-        public IntWrapper(IdentityInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public RefWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new RefWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new RefWrapper(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public IntWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IntWrapper(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy(RefWrapper[] dst, RefWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_int(IntWrapper[] dst, RefWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_ref(RefWrapper[] dst, IntWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = (IdentityInt) src[i].f;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void copy_ref(RefState st1, RefState st2) {\n-        copy(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_ref_to_int(IntState st1, RefState st2) {\n-        copy_to_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_to_ref(RefState st1, IntState st2) {\n-        copy_to_ref(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Identity.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(RefState s, ValState d) {\n+        RefWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(ValState s, RefState d) {\n+        ValWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(ValState s, ValState d) {\n+        ValWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Inline128int.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(RefState s, ValState d) {\n+        RefWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(ValState s, RefState d) {\n+        ValWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(ValState s, ValState d) {\n+        ValWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Inline32int.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(RefState s, ValState d) {\n+        RefWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(ValState s, RefState d) {\n+        ValWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(ValState s, ValState d) {\n+        ValWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Inline64byte.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(RefState s, ValState d) {\n+        RefWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(ValState s, RefState d) {\n+        ValWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(ValState s, ValState d) {\n+        ValWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Inline64int.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64long extends StatesQ64long {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Obj_copy(ObjState s, ObjState d) {\n+        ObjWrapper[] src = s.arr;\n+        ObjWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Int_copy(ObjState s, IntState d) {\n+        ObjWrapper[] src = s.arr;\n+        IntWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = (Int64) src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_copy(ObjState s, RefState d) {\n+        ObjWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = (Q64long)src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_copy(ObjState s, ValState d) {\n+        ObjWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = (Q64long) src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Obj_copy(IntState s, ObjState d) {\n+        IntWrapper[] src = s.arr;\n+        ObjWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Int_copy(IntState s, IntState d) {\n+        IntWrapper[] src = s.arr;\n+        IntWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_copy(IntState s, RefState d) {\n+        IntWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = (Q64long)src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_copy(IntState s, ValState d) {\n+        IntWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = (Q64long) src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_copy(RefState s, ObjState d) {\n+        RefWrapper[] src = s.arr;\n+        ObjWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_copy(RefState s, IntState d) {\n+        RefWrapper[] src = s.arr;\n+        IntWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_copy(RefState s, RefState d) {\n+        RefWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_copy(RefState s, ValState d) {\n+        RefWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_copy(ValState s, ObjState d) {\n+        ValWrapper[] src = s.arr;\n+        ObjWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_copy(ValState s, IntState d) {\n+        ValWrapper[] src = s.arr;\n+        IntWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_copy(ValState s, RefState d) {\n+        ValWrapper[] src = s.arr;\n+        RefWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_copy(ValState s, ValState d) {\n+        ValWrapper[] src = s.arr;\n+        ValWrapper[] dst = d.arr;\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i].f = src[i].f;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Inline64long.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive128 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p128int_copy(Primitive128int s, Primitive128int d) {\n+        P128int[] src = s.arr;\n+        P128int[] dst = d.arr;\n+        for(int i=0; i<src.length; i++) {\n+            dst[i].f0 = src[i].f0;\n+            dst[i].f1 = src[i].f1;\n+            dst[i].f2 = src[i].f2;\n+            dst[i].f3 = src[i].f3;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Primitive128.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive32 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p32int_copy(Primitive32int s, Primitive32int d) {\n+        P32int[] src = s.arr;\n+        P32int[] dst = d.arr;\n+        for(int i=0; i<src.length; i++) {\n+            dst[i].f0 = src[i].f0;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Primitive32.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.copy;\n+\n+import org.openjdk.bench.valhalla.field.util.PrimitiveStates;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Primitive64 extends PrimitiveStates {\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64byte_copy(Primitive64byte s, Primitive64byte d) {\n+        P64byte[] src = s.arr;\n+        P64byte[] dst = d.arr;\n+        for(int i=0; i<src.length; i++) {\n+            dst[i].f0 = src[i].f0;\n+            dst[i].f1 = src[i].f1;\n+            dst[i].f2 = src[i].f2;\n+            dst[i].f3 = src[i].f3;\n+            dst[i].f4 = src[i].f4;\n+            dst[i].f5 = src[i].f5;\n+            dst[i].f6 = src[i].f6;\n+            dst[i].f7 = src[i].f7;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64int_copy(Primitive64int s, Primitive64int d) {\n+        P64int[] src = s.arr;\n+        P64int[] dst = d.arr;\n+        for(int i=0; i<src.length; i++) {\n+            dst[i].f0 = src[i].f0;\n+            dst[i].f1 = src[i].f1;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void p64long_copy(Primitive64long s, Primitive64long d) {\n+        P64long[] src = s.arr;\n+        P64long[] dst = d.arr;\n+        for(int i=0; i<src.length; i++) {\n+            dst[i].f0 = src[i].f0;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Primitive64.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends CopyBase {\n-\n-    public static class ValWrapper {\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        public InterfaceInt f;\n-\n-        public IntWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public IntWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IntWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy(ValWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_int(IntWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_val(ValWrapper[] dst, IntWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = (ValueInt) src[i].f;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void copy_val(ValState st1, ValState st2) {\n-        copy(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_to_int(IntState st1, ValState st2) {\n-        copy_to_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_to_val(ValState st1, IntState st2) {\n-        copy_to_val(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Value032.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032NullFree extends CopyBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        public InterfaceInt f;\n-\n-        public IntWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public IntWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IntWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy(ValWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_int(IntWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_val(ValWrapper[] dst, IntWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = (ValueInt) src[i].f;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void copy_val(ValState st1, ValState st2) {\n-        copy(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_to_int(IntState st1, ValState st2) {\n-        copy_to_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_to_val(ValState st1, IntState st2) {\n-        copy_to_val(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Value032NullFree.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032NullFreeNonAtomic extends CopyBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        public InterfaceInt f;\n-\n-        public IntWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public IntWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IntWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy(ValWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_int(IntWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_val(ValWrapper[] dst, IntWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = (ValueInt) src[i].f;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void copy_val(ValState st1, ValState st2) {\n-        copy(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_to_int(IntState st1, ValState st2) {\n-        copy_to_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_to_val(ValState st1, IntState st2) {\n-        copy_to_val(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Value032NullFreeNonAtomic.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends CopyBase {\n-\n-    public static class ValWrapper {\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        public InterfaceInt f;\n-\n-        public IntWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public IntWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IntWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy(ValWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_int(IntWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_val(ValWrapper[] dst, IntWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = (ValueInt4) src[i].f;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void copy_val(ValState st1, ValState st2) {\n-        copy(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_to_int(IntState st1, ValState st2) {\n-        copy_to_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_to_val(ValState st1, IntState st2) {\n-        copy_to_val(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Value128.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128NullFree extends CopyBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        public InterfaceInt f;\n-\n-        public IntWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public IntWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IntWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy(ValWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_int(IntWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_val(ValWrapper[] dst, IntWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = (ValueInt4) src[i].f;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void copy_val(ValState st1, ValState st2) {\n-        copy(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_to_int(IntState st1, ValState st2) {\n-        copy_to_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_to_val(ValState st1, IntState st2) {\n-        copy_to_val(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Value128NullFree.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.copy;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128NullFreeNonAtomic extends CopyBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        public InterfaceInt f;\n-\n-        public IntWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    public static class IntState extends SizeState {\n-        public IntWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new IntWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy(ValWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_int(IntWrapper[] dst, ValWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = src[i].f;\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void copy_to_val(ValWrapper[] dst, IntWrapper[] src) {\n-        for (int i = 0; i < src.length; i++) {\n-            dst[i].f = (ValueInt4) src[i].f;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void copy_val(ValState st1, ValState st2) {\n-        copy(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_val_to_int(IntState st1, ValState st2) {\n-        copy_to_int(st1.arr, st2.arr);\n-    }\n-\n-    @Benchmark\n-    public void copy_int_to_val(ValState st1, IntState st2) {\n-        copy_to_val(st1.arr, st2.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/copy\/Value128NullFreeNonAtomic.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-public class Identity extends ReadBase {\n-\n-    public static class RefWrapper {\n-        public IdentityInt f;\n-\n-        public RefWrapper(IdentityInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public RefWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new RefWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new RefWrapper(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_ref(RefWrapper[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].f);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(RefState st1, Blackhole bh) {\n-        read_ref(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Identity.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.read;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ128int;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q128int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q128int v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Inline128int.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.read;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ32int;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q32int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q32int v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Inline32int.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.read;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64byte;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q64byte v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q64byte v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Inline64byte.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.read;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64int;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q64int v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q64int v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Inline64int.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.read;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64long extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void val_consume(Q64long v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void ref_consume(Q64long v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void int_consume(Int64 v) {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void obj_consume(Object v) {\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Int_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Obj_read(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            val_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            ref_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Int_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            int_consume(arr[i].f);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Obj_read(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for(int i=0; i < arr.length; i++) {\n+            obj_consume(arr[i].f);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Inline64long.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class ReadBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/ReadBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends ReadBase {\n-\n-    public static class ValWrapper {\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValWrapper[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].f);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Value032.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032NullFree extends ReadBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValWrapper[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].f);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Value032NullFree.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032NullFreeNonAtomic extends ReadBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValWrapper[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].f);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Value032NullFreeNonAtomic.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends ReadBase {\n-\n-    public static class ValWrapper {\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValWrapper[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].f);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Value128.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128NullFree extends ReadBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValWrapper[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].f);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Value128NullFree.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.read;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128NullFreeNonAtomic extends ReadBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-\n-    public static class ValState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void read_val(ValWrapper[] src, Blackhole bh) {\n-        for (int i = 0; i < src.length; i++) {\n-            bh.consume(src[i].f);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void read(ValState st1, Blackhole bh) {\n-        read_val(st1.arr, bh);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/read\/Value128NullFreeNonAtomic.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Identity extends SetBase {\n-\n-    public static class RefWrapper {\n-        public IdentityInt f;\n-\n-        public RefWrapper(IdentityInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public RefWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new RefWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new RefWrapper(new IdentityInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public IdentityInt get_ref(int i) {\n-        return new IdentityInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new(RefWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = new IdentityInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call(RefWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = get_ref(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_ref(RefState st1) {\n-        set_new(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_ref(RefState st1) {\n-        set_call(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Identity.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.set;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ128int;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline128int extends StatesQ128int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q128int getRef(int i) {\n+        return new Q128int(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q128int getVal(int i) {\n+        return new Q128int(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q128int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q128int()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q128int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q128int()  ;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Inline128int.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.set;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ32int;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline32int extends StatesQ32int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q32int getRef(int i) {\n+        return new Q32int(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q32int getVal(int i) {\n+        return new Q32int(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q32int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q32int()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q32int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q32int()  ;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Inline32int.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.set;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64byte;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64byte extends StatesQ64byte {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64byte getRef(int i) {\n+        return new Q64byte(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64byte getVal(int i) {\n+        return new Q64byte(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64byte(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64byte()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64byte(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64byte()  ;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Inline64byte.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.set;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64int;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64int extends StatesQ64int {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64int getRef(int i) {\n+        return new Q64int(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64int getVal(int i) {\n+        return new Q64int(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64int()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64int(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64int()  ;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Inline64int.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.set;\n+\n+import org.openjdk.bench.valhalla.field.util.StatesQ64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+\n+public class Inline64long extends StatesQ64long {\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Object getObj(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Int64 getInt(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64long getRef(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static Q64long getVal(int i) {\n+        return new Q64long(i);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = (Q64long) getObj(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = (Q64long) getInt(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Val_set(ValState st) {\n+        ValWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64long()  ;\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void New_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64long(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Obj_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = (Q64long) getObj(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Int_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = (Q64long) getInt(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Ref_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getRef(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Val_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = getVal(i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void Def_to_Ref_set(RefState st) {\n+        RefWrapper[] arr = st.arr;\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i].f = new Q64long()  ;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Inline64long.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-public class SetBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-\n-        @Param({\n-                \"100\",      \/\/ tiny size, to fit into all caches and check codegeneration quality\n-                \"1000000\"   \/\/ large size, to be out of all caches and memory effects\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/SetBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032 extends SetBase {\n-\n-    public static class ValWrapper {\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = get_val(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val(RefState st1) {\n-        set_new(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val(RefState st1) {\n-        set_call(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Value032.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032NullFree extends SetBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = get_val(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val(RefState st1) {\n-        set_new(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val(RefState st1) {\n-        set_call(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Value032NullFree.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value032NullFreeNonAtomic extends SetBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt f;\n-\n-        public ValWrapper(ValueInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceInt {\n-        public final int value;\n-        public ValueInt(int value) {\n-            this.value = value;\n-        }\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-\n-    public static class RefState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt get_val(int i) {\n-        return new ValueInt(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = new ValueInt(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = get_val(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val(RefState st1) {\n-        set_new(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val(RefState st1) {\n-        set_call(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Value032NullFreeNonAtomic.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128 extends SetBase {\n-\n-    public static class ValWrapper {\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class RefState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = get_val(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val(RefState st1) {\n-        set_new(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val(RefState st1) {\n-        set_call(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Value128.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128NullFree extends SetBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class RefState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = get_val(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val(RefState st1) {\n-        set_new(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val(RefState st1) {\n-        set_call(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Value128NullFree.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.field.set;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value128NullFreeNonAtomic extends SetBase {\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        public ValueInt4 f;\n-\n-        public ValWrapper(ValueInt4 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4 implements InterfaceInt {\n-\n-        public final int prevalue0;\n-        public final int prevalue1;\n-        public final int prevalue2;\n-\n-        public final int value;\n-\n-        public ValueInt4(int value) {\n-            this.prevalue0 = value;\n-            this.prevalue1 = value;\n-            this.prevalue2 = value;\n-            this.value = value;\n-        }\n-\n-        public int value() {\n-            return value;\n-        }\n-\n-    }\n-\n-    public static class RefState extends SizeState {\n-        public ValWrapper[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[size];\n-            for (int i = 0; i < size; i++) {\n-                arr[i] = new ValWrapper(new ValueInt4(i));\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueInt4 get_val(int i) {\n-        return new ValueInt4(i);\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_new(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = new ValueInt4(i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public void set_call(ValWrapper[] dst) {\n-        for (int i = 0; i < dst.length; i++) {\n-            dst[i].f = get_val(i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void set_new_val(RefState st1) {\n-        set_new(st1.arr);\n-    }\n-\n-    @Benchmark\n-    public void set_call_val(RefState st1) {\n-        set_call(st1.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/set\/Value128NullFreeNonAtomic.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.util;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class PrimitiveStates extends SizeBase {\n+\n+    public static class P64byte {\n+\n+        public byte f0;\n+        public byte f1;\n+        public byte f2;\n+        public byte f3;\n+        public byte f4;\n+        public byte f5;\n+        public byte f6;\n+        public byte f7;\n+\n+        public P64byte(long v) {\n+            this((byte) (v >>> 56), (byte) (v >>> 48), (byte) (v >>> 40), (byte) (v >>> 32), (byte) (v >>> 24), (byte) (v >>> 16), (byte) (v >>> 8), (byte) (v));\n+        }\n+\n+        public P64byte(byte v0, byte v1, byte v2, byte v3, byte v4, byte v5, byte v6, byte v7) {\n+            this.f0 = v0;\n+            this.f1 = v1;\n+            this.f2 = v2;\n+            this.f3 = v3;\n+            this.f4 = v4;\n+            this.f5 = v5;\n+            this.f6 = v6;\n+            this.f7 = v7;\n+        }\n+\n+    }\n+\n+    public static class Primitive64byte extends SizeState {\n+        public P64byte[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new P64byte[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new P64byte(i);\n+            }\n+        }\n+    }\n+\n+\n+    public static class P64int {\n+\n+        public int f0;\n+        public int f1;\n+\n+        public P64int(long v) {\n+            this((int) (v >>> 32), (int) v);\n+        }\n+\n+        public P64int(int hi, int lo) {\n+            this.f0 = hi;\n+            this.f1 = lo;\n+        }\n+\n+    }\n+\n+    public static class Primitive64int extends SizeState {\n+        public P64int[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new P64int[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new P64int(i);\n+            }\n+        }\n+    }\n+\n+    public static class P64long {\n+\n+        public long f0;\n+\n+        public P64long(long v0) {\n+            this.f0 = v0;\n+        }\n+\n+    }\n+\n+    public static class Primitive64long extends SizeState {\n+        public P64long[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new P64long[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new P64long(i);\n+            }\n+        }\n+    }\n+\n+\n+    public static class P32int {\n+\n+        public int f0;\n+\n+        public P32int(int val) {\n+            this.f0 = val;\n+        }\n+    }\n+\n+    public static class Primitive32int extends SizeState {\n+        public P32int[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new P32int[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new P32int(i);\n+            }\n+        }\n+    }\n+\n+    public static class P128int {\n+\n+        public int f0;\n+        public int f1;\n+        public int f2;\n+        public int f3;\n+\n+        public P128int(long v) {\n+            this(0, 0, (int) (v >>> 32), (int) v);\n+        }\n+\n+        public P128int(int v0, int v1, int v2, int v3) {\n+            this.f0 = v0;\n+            this.f1 = v1;\n+            this.f2 = v2;\n+            this.f3 = v3;\n+        }\n+    }\n+\n+    public static class Primitive128int extends SizeState {\n+        public P128int[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new P128int[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new P128int(i);\n+            }\n+        }\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/util\/PrimitiveStates.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.util;\n+\n+import org.openjdk.bench.valhalla.types.Int128;\n+import org.openjdk.bench.valhalla.types.Q128int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ128int extends SizeBase {\n+\n+    public static class ObjWrapper {\n+        public Object f;\n+\n+        public ObjWrapper(Object f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ObjState extends SizeState {\n+        public ObjWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ObjWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ObjWrapper(new Q128int(i));\n+            }\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public Int128 f;\n+\n+        public IntWrapper(Int128 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntState extends SizeState {\n+        public IntWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Q128int(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class RefWrapper {\n+        public Q128int f;\n+\n+        public RefWrapper(Q128int f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class RefState extends SizeState {\n+        public RefWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new RefWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new RefWrapper(new Q128int(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class ValWrapper {\n+        public Q128int f;\n+\n+        public ValWrapper(Q128int f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ValState extends SizeState {\n+        public ValWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ValWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ValWrapper(new Q128int(i));\n+            }\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/util\/StatesQ128int.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.util;\n+\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ32int extends SizeBase {\n+\n+    public static class ObjWrapper {\n+        public Object f;\n+\n+        public ObjWrapper(Object f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ObjState extends SizeState {\n+        public ObjWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ObjWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ObjWrapper(new Q32int(i));\n+            }\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public Int32 f;\n+\n+        public IntWrapper(Int32 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntState extends SizeState {\n+        public IntWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Q32int(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class RefWrapper {\n+        public Q32int f;\n+\n+        public RefWrapper(Q32int f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class RefState extends SizeState {\n+        public RefWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new RefWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new RefWrapper(new Q32int(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class ValWrapper {\n+        public Q32int f;\n+\n+        public ValWrapper(Q32int f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ValState extends SizeState {\n+        public ValWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ValWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ValWrapper(new Q32int(i));\n+            }\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/util\/StatesQ32int.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.util;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64byte;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ64byte extends SizeBase {\n+\n+    public static class ObjWrapper {\n+        public Object f;\n+\n+        public ObjWrapper(Object f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ObjState extends SizeState {\n+        public ObjWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ObjWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ObjWrapper(new Q64byte(i));\n+            }\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public Int64 f;\n+\n+        public IntWrapper(Int64 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntState extends SizeState {\n+        public IntWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Q64byte(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class RefWrapper {\n+        public Q64byte f;\n+\n+        public RefWrapper(Q64byte f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class RefState extends SizeState {\n+        public RefWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new RefWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new RefWrapper(new Q64byte(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class ValWrapper {\n+        public Q64byte f;\n+\n+        public ValWrapper(Q64byte f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ValState extends SizeState {\n+        public ValWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ValWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ValWrapper(new Q64byte(i));\n+            }\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/util\/StatesQ64byte.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.util;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64int;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ64int extends SizeBase {\n+\n+    public static class ObjWrapper {\n+        public Object f;\n+\n+        public ObjWrapper(Object f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ObjState extends SizeState {\n+        public ObjWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ObjWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ObjWrapper(new Q64int(i));\n+            }\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public Int64 f;\n+\n+        public IntWrapper(Int64 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntState extends SizeState {\n+        public IntWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Q64int(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class RefWrapper {\n+        public Q64int f;\n+\n+        public RefWrapper(Q64int f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class RefState extends SizeState {\n+        public RefWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new RefWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new RefWrapper(new Q64int(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class ValWrapper {\n+        public Q64int f;\n+\n+        public ValWrapper(Q64int f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ValState extends SizeState {\n+        public ValWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ValWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ValWrapper(new Q64int(i));\n+            }\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/util\/StatesQ64int.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.field.util;\n+\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class StatesQ64long extends SizeBase {\n+\n+    public static class ObjWrapper {\n+        public Object f;\n+\n+        public ObjWrapper(Object f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ObjState extends SizeState {\n+        public ObjWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ObjWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ObjWrapper(new Q64long(i));\n+            }\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public Int64 f;\n+\n+        public IntWrapper(Int64 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntState extends SizeState {\n+        public IntWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Q64long(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class RefWrapper {\n+        public Q64long f;\n+\n+        public RefWrapper(Q64long f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class RefState extends SizeState {\n+        public RefWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new RefWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new RefWrapper(new Q64long(i));\n+            }\n+        }\n+    }\n+\n+\n+    public static class ValWrapper {\n+        public Q64long f;\n+\n+        public ValWrapper(Q64long f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class ValState extends SizeState {\n+        public ValWrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new ValWrapper[size];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new ValWrapper(new Q64long(i));\n+            }\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/field\/util\/StatesQ64long.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.hash;\n-\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value1 {\n-\n-    public static value class ValueInt1Hash {\n-\n-        public final int v0;\n-\n-        public ValueInt1Hash(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    public static value class ValueInt1 {\n-\n-        public final int v0;\n-\n-        public ValueInt1(int v0) {\n-            this.v0 = v0;\n-        }\n-\n-        public int value() {\n-            return v0;\n-        }\n-\n-    }\n-\n-\n-    @Benchmark\n-    public int explicit() {\n-        return new ValueInt1Hash(42).hashCode();\n-    }\n-\n-    @Benchmark\n-    public int implicit() {\n-        return new ValueInt1(42).hashCode();\n-    }\n-\n-    @Benchmark\n-    public int direct() {\n-        return System.identityHashCode(new ValueInt1(42));\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/hash\/Value1.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.hash;\n-\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value8 {\n-\n-    public static value class ValueInt8 {\n-\n-        public final int v0, v1, v2, v3, v4, v5, v6, v7;\n-\n-        public ValueInt8(int v0, int v1, int v2, int v3, int v4, int v5, int v6, int v7) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-            this.v4 = v4;\n-            this.v5 = v5;\n-            this.v6 = v6;\n-            this.v7 = v7;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-    }\n-\n-    public static value class ValueInt8Hash {\n-\n-        public final int v0, v1, v2, v3, v4, v5, v6, v7;\n-\n-        public ValueInt8Hash(int v0, int v1, int v2, int v3, int v4, int v5, int v6, int v7) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-            this.v4 = v4;\n-            this.v5 = v5;\n-            this.v6 = v6;\n-            this.v7 = v7;\n-        }\n-\n-        public int value0() {\n-            return v0;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return (((((((v0 * 31) + v1) * 31 + v2) * 31 + v3) * 31 + v4) * 31 + v5) * 31 + v6) * 31 + v7;\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public int explicit() {\n-        return new ValueInt8Hash(42, 43, 44, 45, 46, 47, 48, 49).hashCode();\n-    }\n-\n-    @Benchmark\n-    public int implicit() {\n-        return new ValueInt8(42, 43, 44, 45, 46, 47, 48, 49).hashCode();\n-    }\n-\n-    @Benchmark\n-    public int direct() {\n-        return System.identityHashCode(new ValueInt8(42, 43, 44, 45, 46, 47, 48, 49));\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/hash\/Value8.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityArray {\n+\n+    public static final int SIZE = 128;\n+\n+    public interface MyInterface {\n+        public int my_method();\n+    }\n+\n+    public static class Ref1 implements MyInterface {\n+        public final int f0;\n+        public Ref1(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static class Ref2 implements MyInterface {\n+        public final int f0;\n+        public Ref2(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static class Ref3 implements MyInterface {\n+        public final int f0;\n+        public Ref3(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class IntState {\n+        public MyInterface[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Ref1State {\n+        public Ref1[] arr;\n+    }\n+\n+    public static class Ref1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Ref1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Ref1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Ref2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Ref3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref3(i);\n+            }\n+        }\n+    }\n+\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceInt(MyInterface[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Ref1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_r(Ref1_as_Ref st0, Ref1_as_Ref st1, Ref1_as_Ref st2, Ref1_as_Ref st3, Ref1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_r(Ref1_as_Int st0, Ref1_as_Int st1, Ref1_as_Int st2, Ref1_as_Int st3, Ref1_as_Int st4, Ref1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_i(Int1_as_Int st0, Int1_as_Int st1, Int1_as_Int st2, Int1_as_Int st3, Int1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_ri(Ref1_as_Int st0, Int1_as_Int st1, Ref1_as_Int st2, Int1_as_Int st3, Ref1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_r(Ref1_as_Int st0, Ref2_as_Int st1, Ref1_as_Int st2, Ref2_as_Int st3, Ref1_as_Int st4, Ref2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_i(Int1_as_Int st0, Int2_as_Int st1, Int1_as_Int st2, Int2_as_Int st3, Int1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_ri(Ref1_as_Int st0, Int1_as_Int st1, Ref2_as_Int st2, Int1_as_Int st3, Ref1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_r(Ref1_as_Int st0, Ref2_as_Int st1, Ref3_as_Int st2, Ref1_as_Int st3, Ref2_as_Int st4, Ref3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_i(Int1_as_Int st0, Int2_as_Int st1, Int3_as_Int st2, Int1_as_Int st3, Int2_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_ri(Ref1_as_Int st0, Int2_as_Int st1, Ref3_as_Int st2, Int1_as_Int st3, Ref2_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/IdentityArray.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class IdentityField {\n+\n+    public static final int SIZE = 128;\n+\n+    public interface MyInterface {\n+        public int my_method();\n+    }\n+\n+    public static class Ref1 implements MyInterface {\n+        public final int f0;\n+        public Ref1(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static class Ref2 implements MyInterface {\n+        public final int f0;\n+        public Ref2(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static class Ref3 implements MyInterface {\n+        public final int f0;\n+        public Ref3(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static class Ref1Wrapper {\n+        public Ref1 f;\n+\n+        public Ref1Wrapper(Ref1 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public MyInterface f;\n+\n+        public IntWrapper(MyInterface f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Ref1State {\n+        public Ref1Wrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new Ref1Wrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref1Wrapper(new Ref1(i));\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class IntStateBase {\n+        public IntWrapper[] arr;\n+    }\n+\n+    public static class Int1State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Ref1(i));\n+            }\n+        }\n+    }\n+\n+    public static class Int2State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Ref2(i));\n+            }\n+        }\n+    }\n+\n+    public static class Int3State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Ref3(i));\n+            }\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Ref1Wrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceInt(IntWrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref(Ref1State st0, Ref1State st1, Ref1State st2, Ref1State st3, Ref1State st4, Ref1State st5) {\n+        return reduceRef(st0.arr) +\n+                reduceRef(st1.arr) +\n+                reduceRef(st2.arr) +\n+                reduceRef(st3.arr) +\n+                reduceRef(st4.arr) +\n+                reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int(Int1State st0, Int1State st1, Int1State st2, Int1State st3, Int1State st4, Int1State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int(Int1State st0, Int2State st1, Int1State st2, Int2State st3, Int1State st4, Int2State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int(Int1State st0, Int2State st1, Int3State st2, Int1State st3, Int2State st4, Int3State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/IdentityField.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,552 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineArray0 {\n+\n+    public static final int SIZE = 128;\n+\n+    public interface MyInterface {\n+        public int my_method();\n+    }\n+\n+    public static value class Val1 implements MyInterface {\n+        public final int f0;\n+        public Val1(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val2 implements MyInterface {\n+        public final int f0;\n+        public Val2(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val3 implements MyInterface {\n+        public final int f0;\n+        public Val3(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class IntState {\n+        public MyInterface[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Ref1State {\n+        public Val1[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Val1State {\n+        public Val1[] arr;\n+    }\n+\n+    public static class Val1_as_Val extends Val1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceInt(MyInterface[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceVal(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Val_v(Val1_as_Val st0, Val1_as_Val st1, Val1_as_Val st2, Val1_as_Val st3, Val1_as_Val st4, Val1_as_Val st5) {\n+        return reduceVal(st0.arr) +\n+               reduceVal(st1.arr) +\n+               reduceVal(st2.arr) +\n+               reduceVal(st3.arr) +\n+               reduceVal(st4.arr) +\n+               reduceVal(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_v(Val1_as_Ref st0, Val1_as_Ref st1, Val1_as_Ref st2, Val1_as_Ref st3, Val1_as_Ref st4, Val1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_r(Ref1_as_Ref st0, Ref1_as_Ref st1, Ref1_as_Ref st2, Ref1_as_Ref st3, Ref1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_vr(Val1_as_Ref st0, Ref1_as_Ref st1, Val1_as_Ref st2, Ref1_as_Ref st3, Val1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_v(Val1_as_Int st0, Val1_as_Int st1, Val1_as_Int st2, Val1_as_Int st3, Val1_as_Int st4, Val1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_r(Ref1_as_Int st0, Ref1_as_Int st1, Ref1_as_Int st2, Ref1_as_Int st3, Ref1_as_Int st4, Ref1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_i(Int1_as_Int st0, Int1_as_Int st1, Int1_as_Int st2, Int1_as_Int st3, Int1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_vr(Val1_as_Int st0, Ref1_as_Int st1, Val1_as_Int st2, Ref1_as_Int st3, Val1_as_Int st4, Ref1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_vi(Val1_as_Int st0, Int1_as_Int st1, Val1_as_Int st2, Int1_as_Int st3, Val1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_ri(Ref1_as_Int st0, Int1_as_Int st1, Ref1_as_Int st2, Int1_as_Int st3, Ref1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_vri(Val1_as_Int st0, Ref1_as_Int st1, Int1_as_Int st2, Val1_as_Int st3, Ref1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_v(Val1_as_Int st0, Val2_as_Int st1, Val1_as_Int st2, Val2_as_Int st3, Val1_as_Int st4, Val2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_r(Ref1_as_Int st0, Ref2_as_Int st1, Ref1_as_Int st2, Ref2_as_Int st3, Ref1_as_Int st4, Ref2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_i(Int1_as_Int st0, Int2_as_Int st1, Int1_as_Int st2, Int2_as_Int st3, Int1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_vr(Val1_as_Int st0, Ref2_as_Int st1, Val2_as_Int st2, Ref1_as_Int st3, Val1_as_Int st4, Ref2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_vi(Val1_as_Int st0, Int2_as_Int st1, Val2_as_Int st2, Int1_as_Int st3, Val1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_ri(Ref1_as_Int st0, Int1_as_Int st1, Ref2_as_Int st2, Int1_as_Int st3, Ref1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_vri(Val1_as_Int st0, Ref1_as_Int st1, Int1_as_Int st2, Val2_as_Int st3, Ref2_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_v(Val1_as_Int st0, Val2_as_Int st1, Val3_as_Int st2, Val1_as_Int st3, Val2_as_Int st4, Val3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_r(Ref1_as_Int st0, Ref2_as_Int st1, Ref3_as_Int st2, Ref1_as_Int st3, Ref2_as_Int st4, Ref3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_i(Int1_as_Int st0, Int2_as_Int st1, Int3_as_Int st2, Int1_as_Int st3, Int2_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_vr(Val1_as_Int st0, Ref2_as_Int st1, Val3_as_Int st2, Ref1_as_Int st3, Val2_as_Int st4, Ref3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_vi(Val1_as_Int st0, Int2_as_Int st1, Val3_as_Int st2, Int1_as_Int st3, Val3_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_ri(Ref1_as_Int st0, Int2_as_Int st1, Ref3_as_Int st2, Int1_as_Int st3, Ref2_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_vri(Val1_as_Int st0, Ref2_as_Int st1, Int3_as_Int st2, Val2_as_Int st3, Ref3_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/InlineArray0.java","additions":552,"deletions":0,"binary":false,"changes":552,"status":"added"},{"patch":"@@ -0,0 +1,555 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineArray1 {\n+\n+    public static final int SIZE = 128;\n+\n+    public interface MyInterface {\n+        public int my_method();\n+    }\n+\n+    public static value class Val1 implements MyInterface {\n+        public final int f0;\n+        public Val1(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val2 implements MyInterface {\n+        public final int f0;\n+        public Val2(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val3 implements MyInterface {\n+        public final int f0;\n+        public Val3(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class IntState {\n+        public MyInterface[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Ref1State {\n+        public Val1[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Val1State {\n+        public Val1[] arr;\n+    }\n+\n+    public static class Val1_as_Val extends Val1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int1_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int2_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Int3_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new MyInterface[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceInt(MyInterface[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceVal(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].my_method();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Val_v(Val1_as_Val st0, Val1_as_Val st1, Val1_as_Val st2, Val1_as_Val st3, Val1_as_Val st4, Val1_as_Val st5) {\n+        return reduceVal(st0.arr) +\n+               reduceVal(st1.arr) +\n+               reduceVal(st2.arr) +\n+               reduceVal(st3.arr) +\n+               reduceVal(st4.arr) +\n+               reduceVal(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_v(Val1_as_Ref st0, Val1_as_Ref st1, Val1_as_Ref st2, Val1_as_Ref st3, Val1_as_Ref st4, Val1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_r(Ref1_as_Ref st0, Ref1_as_Ref st1, Ref1_as_Ref st2, Ref1_as_Ref st3, Ref1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_vr(Val1_as_Ref st0, Ref1_as_Ref st1, Val1_as_Ref st2, Ref1_as_Ref st3, Val1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_v(Val1_as_Int st0, Val1_as_Int st1, Val1_as_Int st2, Val1_as_Int st3, Val1_as_Int st4, Val1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_r(Ref1_as_Int st0, Ref1_as_Int st1, Ref1_as_Int st2, Ref1_as_Int st3, Ref1_as_Int st4, Ref1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_i(Int1_as_Int st0, Int1_as_Int st1, Int1_as_Int st2, Int1_as_Int st3, Int1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+               reduceInt(st1.arr) +\n+               reduceInt(st2.arr) +\n+               reduceInt(st3.arr) +\n+               reduceInt(st4.arr) +\n+               reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_vr(Val1_as_Int st0, Ref1_as_Int st1, Val1_as_Int st2, Ref1_as_Int st3, Val1_as_Int st4, Ref1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_vi(Val1_as_Int st0, Int1_as_Int st1, Val1_as_Int st2, Int1_as_Int st3, Val1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_ri(Ref1_as_Int st0, Int1_as_Int st1, Ref1_as_Int st2, Int1_as_Int st3, Ref1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int_vri(Val1_as_Int st0, Ref1_as_Int st1, Int1_as_Int st2, Val1_as_Int st3, Ref1_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_v(Val1_as_Int st0, Val2_as_Int st1, Val1_as_Int st2, Val2_as_Int st3, Val1_as_Int st4, Val2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_r(Ref1_as_Int st0, Ref2_as_Int st1, Ref1_as_Int st2, Ref2_as_Int st3, Ref1_as_Int st4, Ref2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_i(Int1_as_Int st0, Int2_as_Int st1, Int1_as_Int st2, Int2_as_Int st3, Int1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_vr(Val1_as_Int st0, Ref2_as_Int st1, Val2_as_Int st2, Ref1_as_Int st3, Val1_as_Int st4, Ref2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_vi(Val1_as_Int st0, Int2_as_Int st1, Val2_as_Int st2, Int1_as_Int st3, Val1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_ri(Ref1_as_Int st0, Int1_as_Int st1, Ref2_as_Int st2, Int1_as_Int st3, Ref1_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int_vri(Val1_as_Int st0, Ref1_as_Int st1, Int1_as_Int st2, Val2_as_Int st3, Ref2_as_Int st4, Int2_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_v(Val1_as_Int st0, Val2_as_Int st1, Val3_as_Int st2, Val1_as_Int st3, Val2_as_Int st4, Val3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_r(Ref1_as_Int st0, Ref2_as_Int st1, Ref3_as_Int st2, Ref1_as_Int st3, Ref2_as_Int st4, Ref3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_i(Int1_as_Int st0, Int2_as_Int st1, Int3_as_Int st2, Int1_as_Int st3, Int2_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_vr(Val1_as_Int st0, Ref2_as_Int st1, Val3_as_Int st2, Ref1_as_Int st3, Val2_as_Int st4, Ref3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_vi(Val1_as_Int st0, Int2_as_Int st1, Val3_as_Int st2, Int1_as_Int st3, Val3_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_ri(Ref1_as_Int st0, Int2_as_Int st1, Ref3_as_Int st2, Int1_as_Int st3, Ref2_as_Int st4, Int3_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int_vri(Val1_as_Int st0, Ref2_as_Int st1, Int3_as_Int st2, Val2_as_Int st3, Ref3_as_Int st4, Int1_as_Int st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/InlineArray1.java","additions":555,"deletions":0,"binary":false,"changes":555,"status":"added"},{"patch":"@@ -0,0 +1,547 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineArrayHashExplicit {\n+\n+    public static final int SIZE = 128;\n+\n+    public static value class Val1  {\n+        public final int f0;\n+        public Val1(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int hashCode() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val2  {\n+        public final int f0;\n+        public Val2(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int hashCode() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val3  {\n+        public final int f0;\n+        public Val3(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int hashCode() {\n+            return f0;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class ObjState {\n+        public Object[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Ref1State {\n+        public Val1[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Val1State {\n+        public Val1[] arr;\n+    }\n+\n+    public static class Val1_as_Val extends Val1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Obj1_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val2_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref2_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Obj2_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val3_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref3_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Obj3_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceObj(Object[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].hashCode();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].hashCode();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceVal(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].hashCode();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Val_v(Val1_as_Val st0, Val1_as_Val st1, Val1_as_Val st2, Val1_as_Val st3, Val1_as_Val st4, Val1_as_Val st5) {\n+        return reduceVal(st0.arr) +\n+               reduceVal(st1.arr) +\n+               reduceVal(st2.arr) +\n+               reduceVal(st3.arr) +\n+               reduceVal(st4.arr) +\n+               reduceVal(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_v(Val1_as_Ref st0, Val1_as_Ref st1, Val1_as_Ref st2, Val1_as_Ref st3, Val1_as_Ref st4, Val1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_r(Ref1_as_Ref st0, Ref1_as_Ref st1, Ref1_as_Ref st2, Ref1_as_Ref st3, Ref1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_vr(Val1_as_Ref st0, Ref1_as_Ref st1, Val1_as_Ref st2, Ref1_as_Ref st3, Val1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_v(Val1_as_Obj st0, Val1_as_Obj st1, Val1_as_Obj st2, Val1_as_Obj st3, Val1_as_Obj st4, Val1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+               reduceObj(st1.arr) +\n+               reduceObj(st2.arr) +\n+               reduceObj(st3.arr) +\n+               reduceObj(st4.arr) +\n+               reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_r(Ref1_as_Obj st0, Ref1_as_Obj st1, Ref1_as_Obj st2, Ref1_as_Obj st3, Ref1_as_Obj st4, Ref1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+               reduceObj(st1.arr) +\n+               reduceObj(st2.arr) +\n+               reduceObj(st3.arr) +\n+               reduceObj(st4.arr) +\n+               reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_o(Obj1_as_Obj st0, Obj1_as_Obj st1, Obj1_as_Obj st2, Obj1_as_Obj st3, Obj1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+               reduceObj(st1.arr) +\n+               reduceObj(st2.arr) +\n+               reduceObj(st3.arr) +\n+               reduceObj(st4.arr) +\n+               reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_vr(Val1_as_Obj st0, Ref1_as_Obj st1, Val1_as_Obj st2, Ref1_as_Obj st3, Val1_as_Obj st4, Ref1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_vo(Val1_as_Obj st0, Obj1_as_Obj st1, Val1_as_Obj st2, Obj1_as_Obj st3, Val1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_ro(Ref1_as_Obj st0, Obj1_as_Obj st1, Ref1_as_Obj st2, Obj1_as_Obj st3, Ref1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_vro(Val1_as_Obj st0, Ref1_as_Obj st1, Obj1_as_Obj st2, Val1_as_Obj st3, Ref1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_v(Val1_as_Obj st0, Val2_as_Obj st1, Val1_as_Obj st2, Val2_as_Obj st3, Val1_as_Obj st4, Val2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_r(Ref1_as_Obj st0, Ref2_as_Obj st1, Ref1_as_Obj st2, Ref2_as_Obj st3, Ref1_as_Obj st4, Ref2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_o(Obj1_as_Obj st0, Obj2_as_Obj st1, Obj1_as_Obj st2, Obj2_as_Obj st3, Obj1_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_vr(Val1_as_Obj st0, Ref2_as_Obj st1, Val2_as_Obj st2, Ref1_as_Obj st3, Val1_as_Obj st4, Ref2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_vo(Val1_as_Obj st0, Obj2_as_Obj st1, Val2_as_Obj st2, Obj1_as_Obj st3, Val1_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_ro(Ref1_as_Obj st0, Obj1_as_Obj st1, Ref2_as_Obj st2, Obj1_as_Obj st3, Ref1_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_vro(Val1_as_Obj st0, Ref1_as_Obj st1, Obj1_as_Obj st2, Val2_as_Obj st3, Ref2_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_v(Val1_as_Obj st0, Val2_as_Obj st1, Val3_as_Obj st2, Val1_as_Obj st3, Val2_as_Obj st4, Val3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_r(Ref1_as_Obj st0, Ref2_as_Obj st1, Ref3_as_Obj st2, Ref1_as_Obj st3, Ref2_as_Obj st4, Ref3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_o(Obj1_as_Obj st0, Obj2_as_Obj st1, Obj3_as_Obj st2, Obj1_as_Obj st3, Obj2_as_Obj st4, Obj3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_vr(Val1_as_Obj st0, Ref2_as_Obj st1, Val3_as_Obj st2, Ref1_as_Obj st3, Val2_as_Obj st4, Ref3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_vo(Val1_as_Obj st0, Obj2_as_Obj st1, Val3_as_Obj st2, Obj1_as_Obj st3, Val3_as_Obj st4, Obj3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_ro(Ref1_as_Obj st0, Obj2_as_Obj st1, Ref3_as_Obj st2, Obj1_as_Obj st3, Ref2_as_Obj st4, Obj3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_vro(Val1_as_Obj st0, Ref2_as_Obj st1, Obj3_as_Obj st2, Val2_as_Obj st3, Ref3_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/InlineArrayHashExplicit.java","additions":547,"deletions":0,"binary":false,"changes":547,"status":"added"},{"patch":"@@ -0,0 +1,535 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineArrayHashImplicit {\n+\n+    public static final int SIZE = 128;\n+\n+    public static value class Val1  {\n+        public final int f0;\n+        public Val1(int f0) {\n+            this.f0 = f0;\n+        }\n+    }\n+\n+    public static value class Val2  {\n+        public final int f0;\n+        public Val2(int f0) {\n+            this.f0 = f0;\n+        }\n+    }\n+\n+    public static value class Val3  {\n+        public final int f0;\n+        public Val3(int f0) {\n+            this.f0 = f0;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class ObjState {\n+        public Object[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Ref1State {\n+        public Val1[] arr;\n+    }\n+\n+    @State(Scope.Thread)\n+    public static abstract class Val1State {\n+        public Val1[] arr;\n+    }\n+\n+    public static class Val1_as_Val extends Val1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val1_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Ref extends Ref1State {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref1_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val1[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Obj1_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val2_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref2_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val2[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Obj2_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val2(i);\n+            }\n+        }\n+    }\n+\n+    public static class Val3_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Ref3_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Val3[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+    public static class Obj3_as_Obj extends ObjState {\n+        @Setup\n+        public void setup() {\n+            arr = new Object[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val3(i);\n+            }\n+        }\n+    }\n+\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceObj(Object[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].hashCode();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].hashCode();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceVal(Val1[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].hashCode();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Val_v(Val1_as_Val st0, Val1_as_Val st1, Val1_as_Val st2, Val1_as_Val st3, Val1_as_Val st4, Val1_as_Val st5) {\n+        return reduceVal(st0.arr) +\n+               reduceVal(st1.arr) +\n+               reduceVal(st2.arr) +\n+               reduceVal(st3.arr) +\n+               reduceVal(st4.arr) +\n+               reduceVal(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_v(Val1_as_Ref st0, Val1_as_Ref st1, Val1_as_Ref st2, Val1_as_Ref st3, Val1_as_Ref st4, Val1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_r(Ref1_as_Ref st0, Ref1_as_Ref st1, Ref1_as_Ref st2, Ref1_as_Ref st3, Ref1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref_vr(Val1_as_Ref st0, Ref1_as_Ref st1, Val1_as_Ref st2, Ref1_as_Ref st3, Val1_as_Ref st4, Ref1_as_Ref st5) {\n+        return reduceRef(st0.arr) +\n+               reduceRef(st1.arr) +\n+               reduceRef(st2.arr) +\n+               reduceRef(st3.arr) +\n+               reduceRef(st4.arr) +\n+               reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_v(Val1_as_Obj st0, Val1_as_Obj st1, Val1_as_Obj st2, Val1_as_Obj st3, Val1_as_Obj st4, Val1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+               reduceObj(st1.arr) +\n+               reduceObj(st2.arr) +\n+               reduceObj(st3.arr) +\n+               reduceObj(st4.arr) +\n+               reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_r(Ref1_as_Obj st0, Ref1_as_Obj st1, Ref1_as_Obj st2, Ref1_as_Obj st3, Ref1_as_Obj st4, Ref1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+               reduceObj(st1.arr) +\n+               reduceObj(st2.arr) +\n+               reduceObj(st3.arr) +\n+               reduceObj(st4.arr) +\n+               reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_o(Obj1_as_Obj st0, Obj1_as_Obj st1, Obj1_as_Obj st2, Obj1_as_Obj st3, Obj1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+               reduceObj(st1.arr) +\n+               reduceObj(st2.arr) +\n+               reduceObj(st3.arr) +\n+               reduceObj(st4.arr) +\n+               reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_vr(Val1_as_Obj st0, Ref1_as_Obj st1, Val1_as_Obj st2, Ref1_as_Obj st3, Val1_as_Obj st4, Ref1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_vo(Val1_as_Obj st0, Obj1_as_Obj st1, Val1_as_Obj st2, Obj1_as_Obj st3, Val1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_ro(Ref1_as_Obj st0, Obj1_as_Obj st1, Ref1_as_Obj st2, Obj1_as_Obj st3, Ref1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Obj_vro(Val1_as_Obj st0, Ref1_as_Obj st1, Obj1_as_Obj st2, Val1_as_Obj st3, Ref1_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_v(Val1_as_Obj st0, Val2_as_Obj st1, Val1_as_Obj st2, Val2_as_Obj st3, Val1_as_Obj st4, Val2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_r(Ref1_as_Obj st0, Ref2_as_Obj st1, Ref1_as_Obj st2, Ref2_as_Obj st3, Ref1_as_Obj st4, Ref2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_o(Obj1_as_Obj st0, Obj2_as_Obj st1, Obj1_as_Obj st2, Obj2_as_Obj st3, Obj1_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_vr(Val1_as_Obj st0, Ref2_as_Obj st1, Val2_as_Obj st2, Ref1_as_Obj st3, Val1_as_Obj st4, Ref2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_vo(Val1_as_Obj st0, Obj2_as_Obj st1, Val2_as_Obj st2, Obj1_as_Obj st3, Val1_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_ro(Ref1_as_Obj st0, Obj1_as_Obj st1, Ref2_as_Obj st2, Obj1_as_Obj st3, Ref1_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Obj_vro(Val1_as_Obj st0, Ref1_as_Obj st1, Obj1_as_Obj st2, Val2_as_Obj st3, Ref2_as_Obj st4, Obj2_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_v(Val1_as_Obj st0, Val2_as_Obj st1, Val3_as_Obj st2, Val1_as_Obj st3, Val2_as_Obj st4, Val3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_r(Ref1_as_Obj st0, Ref2_as_Obj st1, Ref3_as_Obj st2, Ref1_as_Obj st3, Ref2_as_Obj st4, Ref3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_o(Obj1_as_Obj st0, Obj2_as_Obj st1, Obj3_as_Obj st2, Obj1_as_Obj st3, Obj2_as_Obj st4, Obj3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_vr(Val1_as_Obj st0, Ref2_as_Obj st1, Val3_as_Obj st2, Ref1_as_Obj st3, Val2_as_Obj st4, Ref3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_vo(Val1_as_Obj st0, Obj2_as_Obj st1, Val3_as_Obj st2, Obj1_as_Obj st3, Val3_as_Obj st4, Obj3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_ro(Ref1_as_Obj st0, Obj2_as_Obj st1, Ref3_as_Obj st2, Obj1_as_Obj st3, Ref2_as_Obj st4, Obj3_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Obj_vro(Val1_as_Obj st0, Ref2_as_Obj st1, Obj3_as_Obj st2, Val2_as_Obj st3, Ref3_as_Obj st4, Obj1_as_Obj st5) {\n+        return reduceObj(st0.arr) +\n+                reduceObj(st1.arr) +\n+                reduceObj(st2.arr) +\n+                reduceObj(st3.arr) +\n+                reduceObj(st4.arr) +\n+                reduceObj(st5.arr);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/InlineArrayHashImplicit.java","additions":535,"deletions":0,"binary":false,"changes":535,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineField {\n+\n+    public static final int SIZE = 128;\n+\n+    public interface MyInterface {\n+        public int my_method();\n+    }\n+\n+    public static value class Val1 implements MyInterface {\n+        public final int f0;\n+        public Val1(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val2 implements MyInterface {\n+        public final int f0;\n+        public Val2(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val3 implements MyInterface {\n+        public final int f0;\n+        public Val3(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static class Val1Wrapper {\n+        public Val1 f;\n+\n+        public Val1Wrapper(Val1 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class Ref1Wrapper {\n+        public Val1 f;\n+\n+        public Ref1Wrapper(Val1 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public MyInterface f;\n+\n+        public IntWrapper(MyInterface f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Val1State {\n+        public Val1Wrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new Val1Wrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1Wrapper(new Val1(i));\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Ref1State {\n+        public Ref1Wrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new Ref1Wrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref1Wrapper(new Val1(i));\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class IntStateBase {\n+        public IntWrapper[] arr;\n+    }\n+\n+    public static class Int1State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Val1(i));\n+            }\n+        }\n+    }\n+\n+    public static class Int2State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Val2(i));\n+            }\n+        }\n+    }\n+\n+    public static class Int3State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Val3(i));\n+            }\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceVal(Val1Wrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Ref1Wrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceInt(IntWrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Val(Val1State st0, Val1State st1, Val1State st2, Val1State st3, Val1State st4, Val1State st5) {\n+        return reduceVal(st0.arr) +\n+                reduceVal(st1.arr) +\n+                reduceVal(st2.arr) +\n+                reduceVal(st3.arr) +\n+                reduceVal(st4.arr) +\n+                reduceVal(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref(Ref1State st0, Ref1State st1, Ref1State st2, Ref1State st3, Ref1State st4, Ref1State st5) {\n+        return reduceRef(st0.arr) +\n+                reduceRef(st1.arr) +\n+                reduceRef(st2.arr) +\n+                reduceRef(st3.arr) +\n+                reduceRef(st4.arr) +\n+                reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int(Int1State st0, Int1State st1, Int1State st2, Int1State st3, Int1State st4, Int1State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int(Int1State st0, Int2State st1, Int1State st2, Int2State st3, Int1State st4, Int2State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int(Int1State st0, Int2State st1, Int3State st2, Int1State st3, Int2State st4, Int3State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/InlineField.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineField1 {\n+\n+    public static final int SIZE = 128;\n+\n+    public interface MyInterface {\n+        public int my_method();\n+    }\n+\n+    public static value class Val1 implements MyInterface {\n+        public final int f0;\n+        public Val1(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val2 implements MyInterface {\n+        public final int f0;\n+        public Val2(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static value class Val3 implements MyInterface {\n+        public final int f0;\n+        public Val3(int f0) {\n+            this.f0 = f0;\n+        }\n+        @Override\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int my_method() {\n+            return f0;\n+        }\n+    }\n+\n+    public static class Val1Wrapper {\n+        public Val1 f;\n+\n+        public Val1Wrapper(Val1 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class Ref1Wrapper {\n+        public Val1 f;\n+\n+        public Ref1Wrapper(Val1 f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    public static class IntWrapper {\n+        public MyInterface f;\n+\n+        public IntWrapper(MyInterface f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Val1State {\n+        public Val1Wrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new Val1Wrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Val1Wrapper(new Val1(i));\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Ref1State {\n+        public Ref1Wrapper[] arr;\n+        @Setup\n+        public void setup() {\n+            arr = new Ref1Wrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new Ref1Wrapper(new Val1(i));\n+            }\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class IntStateBase {\n+        public IntWrapper[] arr;\n+    }\n+\n+    public static class Int1State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Val1(i));\n+            }\n+        }\n+    }\n+\n+    public static class Int2State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Val2(i));\n+            }\n+        }\n+    }\n+\n+    public static class Int3State extends IntStateBase {\n+        @Setup\n+        public void setup() {\n+            arr = new IntWrapper[SIZE];\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = new IntWrapper(new Val3(i));\n+            }\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceVal(Val1Wrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceRef(Ref1Wrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int reduceInt(IntWrapper[] arr) {\n+        int r = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            r += arr[i].f.my_method();\n+        }\n+        return r;\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Val(Val1State st0, Val1State st1, Val1State st2, Val1State st3, Val1State st4, Val1State st5) {\n+        return reduceVal(st0.arr) +\n+                reduceVal(st1.arr) +\n+                reduceVal(st2.arr) +\n+                reduceVal(st3.arr) +\n+                reduceVal(st4.arr) +\n+                reduceVal(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Ref(Ref1State st0, Ref1State st1, Ref1State st2, Ref1State st3, Ref1State st4, Ref1State st5) {\n+        return reduceRef(st0.arr) +\n+                reduceRef(st1.arr) +\n+                reduceRef(st2.arr) +\n+                reduceRef(st3.arr) +\n+                reduceRef(st4.arr) +\n+                reduceRef(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target1_Int(Int1State st0, Int1State st1, Int1State st2, Int1State st3, Int1State st4, Int1State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target2_Int(Int1State st0, Int2State st1, Int1State st2, Int2State st3, Int1State st4, Int2State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE * 6)\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public int target3_Int(Int1State st0, Int2State st1, Int3State st2, Int1State st3, Int2State st4, Int3State st5) {\n+        return reduceInt(st0.arr) +\n+                reduceInt(st1.arr) +\n+                reduceInt(st2.arr) +\n+                reduceInt(st3.arr) +\n+                reduceInt(st4.arr) +\n+                reduceInt(st5.arr);\n+    }\n+\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/InlineField1.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class InlineRec {\n+\n+    @Param(\"100\")\n+    public int depth;\n+\n+    public static value class V {\n+        final int v;\n+\n+        public V(int v) {\n+            this.v = v;\n+        }\n+\n+        public V addL(V y) {\n+            return this.v == 0 ? y : new V(this.v - 1).addL(new V(y.v + 1));\n+        }\n+\n+        public V addR(V y) {\n+            return y.v == 0 ? this : new V(this.v + 1).addR(new V(y.v - 1));\n+        }\n+    }\n+\n+    public static V s_addL(V x, V y) {\n+        return x.v == 0 ? y : s_addL(new V(x.v - 1), new V(y.v + 1));\n+    }\n+\n+    public static V s_addR(V x, V y) {\n+        return y.v == 0 ? x : s_addR(new V(x.v + 1), new V(y.v - 1));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int statL() {\n+        return s_addL(new V(depth), new V(depth)).v;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int statR() {\n+        return s_addR(new V(depth), new V(depth)).v;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int instL() {\n+        return new V(depth).addL(new V(depth)).v;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int instR() {\n+        return new V(depth).addR(new V(depth)).v;\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/InlineRec.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -1,309 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.array;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Identity {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt0 implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IdentityInt1 implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IdentityInt2 implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt2(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Ref0State {\n-        public IdentityInt0[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt0[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Ref1State {\n-        public IdentityInt1[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt1[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Ref2State {\n-        public IdentityInt2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt2[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt2(i);\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(InterfaceInt[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_ref(IdentityInt0[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Ref0State st0, Ref0State st1, Ref0State st2, Ref0State st3, Ref0State st4, Ref0State st5) {\n-        return reduce_ref(st0.arr) +\n-               reduce_ref(st1.arr) +\n-               reduce_ref(st2.arr) +\n-               reduce_ref(st3.arr) +\n-               reduce_ref(st4.arr) +\n-               reduce_ref(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_r(Ref0State st0, Ref0State st1, Ref0State st2, Ref0State st3, Ref0State st4, Ref0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_i(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_ri(Ref0State st0, Int0State st1, Ref0State st2, Int0State st3, Ref0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_r(Ref0State st0, Ref0State st1, Ref0State st2, Ref1State st3, Ref1State st4, Ref1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_i(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_ri(Ref0State st0, Int0State st1, Ref0State st2, Int1State st3, Ref1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_r(Ref0State st0, Ref0State st1, Ref1State st2, Ref1State st3, Ref2State st4, Ref2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_i(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_ri(Ref0State st0, Int0State st1, Ref1State st2, Int1State st3, Ref2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/array\/Identity.java","additions":0,"deletions":309,"binary":false,"changes":309,"status":"deleted"},{"patch":"@@ -1,308 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.array;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt0 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt1 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt2 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val0State {\n-        public ValueInt0[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt0[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val1State {\n-        public ValueInt1[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt1[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val22State {\n-        public ValueInt2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt2[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2(i);\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(InterfaceInt[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_val(ValueInt0[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Val0State st0, Val0State st1, Val0State st2, Val0State st3, Val0State st4, Val0State st5) {\n-        return reduce_val(st0.arr) +\n-               reduce_val(st1.arr) +\n-               reduce_val(st2.arr) +\n-               reduce_val(st3.arr) +\n-               reduce_val(st4.arr) +\n-               reduce_val(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_v(Val0State st0, Val0State st1, Val0State st2, Val0State st3, Val0State st4, Val0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_i(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_vi(Val0State st0, Int0State st1, Val0State st2, Int0State st3, Val0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_v(Val0State st0, Val0State st1, Val0State st2, Val1State st3, Val1State st4, Val1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_i(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_vi(Val0State st0, Int0State st1, Val0State st2, Int1State st3, Val1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_v(Val0State st0, Val0State st1, Val1State st2, Val1State st3, Val22State st4, Val22State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_i(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_vi(Val0State st0, Int0State st1, Val1State st2, Int1State st3, Val22State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/array\/Value.java","additions":0,"deletions":308,"binary":false,"changes":308,"status":"deleted"},{"patch":"@@ -1,309 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.array;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class ValueNullFree {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt0 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt1 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt2 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val0State {\n-        public ValueInt0[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt0[]) ValueClass.newNullRestrictedAtomicArray(ValueInt0.class, SIZE, new ValueInt0(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val1State {\n-        public ValueInt1[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt1[]) ValueClass.newNullRestrictedAtomicArray(ValueInt1.class, SIZE, new ValueInt1(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val22State {\n-        public ValueInt2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt2[]) ValueClass.newNullRestrictedAtomicArray(ValueInt2.class, SIZE, new ValueInt2(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2(i);\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(InterfaceInt[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_val(ValueInt0[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Val0State st0, Val0State st1, Val0State st2, Val0State st3, Val0State st4, Val0State st5) {\n-        return reduce_val(st0.arr) +\n-               reduce_val(st1.arr) +\n-               reduce_val(st2.arr) +\n-               reduce_val(st3.arr) +\n-               reduce_val(st4.arr) +\n-               reduce_val(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_v(Val0State st0, Val0State st1, Val0State st2, Val0State st3, Val0State st4, Val0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_i(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_vi(Val0State st0, Int0State st1, Val0State st2, Int0State st3, Val0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_v(Val0State st0, Val0State st1, Val0State st2, Val1State st3, Val1State st4, Val1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_i(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_vi(Val0State st0, Int0State st1, Val0State st2, Int1State st3, Val1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_v(Val0State st0, Val0State st1, Val1State st2, Val1State st3, Val22State st4, Val22State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_i(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_vi(Val0State st0, Int0State st1, Val1State st2, Int1State st3, Val22State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/array\/ValueNullFree.java","additions":0,"deletions":309,"binary":false,"changes":309,"status":"deleted"},{"patch":"@@ -1,313 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.array;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class ValueNullFreeNonAtomic {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt0 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt1 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt2 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public InterfaceInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceInt[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val0State {\n-        public ValueInt0[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt0[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt0.class, SIZE, new ValueInt0(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt0(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val1State {\n-        public ValueInt1[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt1[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt1.class, SIZE, new ValueInt1(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt1(i);\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Val22State {\n-        public ValueInt2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt2[]) ValueClass.newNullRestrictedNonAtomicArray(ValueInt2.class, SIZE, new ValueInt2(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2(i);\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(InterfaceInt[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_val(ValueInt0[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Val0State st0, Val0State st1, Val0State st2, Val0State st3, Val0State st4, Val0State st5) {\n-        return reduce_val(st0.arr) +\n-               reduce_val(st1.arr) +\n-               reduce_val(st2.arr) +\n-               reduce_val(st3.arr) +\n-               reduce_val(st4.arr) +\n-               reduce_val(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_v(Val0State st0, Val0State st1, Val0State st2, Val0State st3, Val0State st4, Val0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_i(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1_vi(Val0State st0, Int0State st1, Val0State st2, Int0State st3, Val0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_v(Val0State st0, Val0State st1, Val0State st2, Val1State st3, Val1State st4, Val1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_i(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2_vi(Val0State st0, Int0State st1, Val0State st2, Int1State st3, Val1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_v(Val0State st0, Val0State st1, Val1State st2, Val1State st3, Val22State st4, Val22State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_i(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3_vi(Val0State st0, Int0State st1, Val1State st2, Int1State st3, Val22State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/array\/ValueNullFreeNonAtomic.java","additions":0,"deletions":313,"binary":false,"changes":313,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.field;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Identity {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static class IdentityInt0 implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IdentityInt1 implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IdentityInt2 implements InterfaceInt {\n-        public final int value;\n-        public IdentityInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        final InterfaceInt f;\n-\n-        public IntWrapper(InterfaceInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class RefWrapper {\n-        final IdentityInt0 f;\n-\n-        public RefWrapper(IdentityInt0 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new IdentityInt0(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new IdentityInt1(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new IdentityInt2(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Ref0State {\n-        public RefWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new RefWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new RefWrapper(new IdentityInt0(i));\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(IntWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_ref(RefWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Ref0State st0, Ref0State st1, Ref0State st2, Ref0State st3, Ref0State st4, Ref0State st5) {\n-        return reduce_ref(st0.arr) +\n-               reduce_ref(st1.arr) +\n-               reduce_ref(st2.arr) +\n-               reduce_ref(st3.arr) +\n-               reduce_ref(st4.arr) +\n-               reduce_ref(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/field\/Identity.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.field;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class Value {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt0 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt1 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt2 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        final InterfaceInt f;\n-\n-        public IntWrapper(InterfaceInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-        final ValueInt0 f;\n-\n-        public ValWrapper(ValueInt0 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt0(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt1(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt2(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Ref0State {\n-        public ValWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValWrapper(new ValueInt0(i));\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(IntWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_val(ValWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Ref0State st0, Ref0State st1, Ref0State st2, Ref0State st3, Ref0State st4, Ref0State st5) {\n-        return reduce_val(st0.arr) +\n-               reduce_val(st1.arr) +\n-               reduce_val(st2.arr) +\n-               reduce_val(st3.arr) +\n-               reduce_val(st4.arr) +\n-               reduce_val(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/field\/Value.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.field;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class ValueNullFree {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    public static value class ValueInt0 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt1 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static value class ValueInt2 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        final InterfaceInt f;\n-\n-        public IntWrapper(InterfaceInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        final ValueInt0 f;\n-\n-        public ValWrapper(ValueInt0 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt0(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt1(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt2(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Ref0State {\n-        public ValWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValWrapper(new ValueInt0(i));\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(IntWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_val(ValWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Ref0State st0, Ref0State st1, Ref0State st2, Ref0State st3, Ref0State st4, Ref0State st5) {\n-        return reduce_val(st0.arr) +\n-               reduce_val(st1.arr) +\n-               reduce_val(st2.arr) +\n-               reduce_val(st3.arr) +\n-               reduce_val(st4.arr) +\n-               reduce_val(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/field\/ValueNullFree.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,236 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.invoke.field;\n-\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@BenchmarkMode(Mode.AverageTime)\n-@State(Scope.Thread)\n-public class ValueNullFreeNonAtomic {\n-\n-    \/*\n-        virtual method invocations:\n-        target0 - statically known target method.\n-        target1 - the single invoked method (should be inlined)\n-        target2 - two invoked method (should be inlined, cache-inline)\n-        target3 - thee invoked method (shouldn't be inlined)\n-\n-     *\/\n-\n-\n-    public static final int SIZE = 128;\n-\n-    public interface InterfaceInt {\n-        public int value();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt0 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt0(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt1 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt1(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt2 implements InterfaceInt {\n-        public final int value;\n-        public ValueInt2(int value) {\n-            this.value = value;\n-        }\n-        @Override\n-        public int value() {\n-            return value;\n-        }\n-    }\n-\n-    public static class IntWrapper {\n-        final InterfaceInt f;\n-\n-        public IntWrapper(InterfaceInt f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    public static class ValWrapper {\n-        @Strict\n-        @NullRestricted\n-        final ValueInt0 f;\n-\n-        public ValWrapper(ValueInt0 f) {\n-            this.f = f;\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int0State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt0(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int1State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt1(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Int2State {\n-        public IntWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IntWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IntWrapper(new ValueInt2(i));\n-            }\n-        }\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class Ref0State {\n-        public ValWrapper[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValWrapper[SIZE];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValWrapper(new ValueInt0(i));\n-            }\n-        }\n-    }\n-\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_int(IntWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int reduce_val(ValWrapper[] arr) {\n-        int r = 0;\n-        for (int i = 0; i < arr.length; i++) {\n-            r += arr[i].f.value();\n-        }\n-        return r;\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target0(Ref0State st0, Ref0State st1, Ref0State st2, Ref0State st3, Ref0State st4, Ref0State st5) {\n-        return reduce_val(st0.arr) +\n-               reduce_val(st1.arr) +\n-               reduce_val(st2.arr) +\n-               reduce_val(st3.arr) +\n-               reduce_val(st4.arr) +\n-               reduce_val(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target1(Int0State st0, Int0State st1, Int0State st2, Int0State st3, Int0State st4, Int0State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target2(Int0State st0, Int0State st1, Int0State st2, Int1State st3, Int1State st4, Int1State st5) {\n-        return reduce_int(st0.arr) +\n-               reduce_int(st1.arr) +\n-               reduce_int(st2.arr) +\n-               reduce_int(st3.arr) +\n-               reduce_int(st4.arr) +\n-               reduce_int(st5.arr);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(SIZE * 6)\n-    @CompilerControl(CompilerControl.Mode.INLINE)\n-    public int target3(Int0State st0, Int0State st1, Int1State st2, Int1State st3, Int2State st4, Int2State st5) {\n-        return reduce_int(st0.arr) +\n-                reduce_int(st1.arr) +\n-                reduce_int(st2.arr) +\n-                reduce_int(st3.arr) +\n-                reduce_int(st4.arr) +\n-                reduce_int(st5.arr);\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/invoke\/field\/ValueNullFreeNonAtomic.java","additions":0,"deletions":236,"binary":false,"changes":236,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.mandelbrot;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-\n-public class Identity extends MandelbrotBase {\n-\n-    @Benchmark\n-    public int[][] mandelbrot() {\n-        for (int x = 0; x < size; x++) {\n-            for (int y = 0; y < size; y++) {\n-                points[x][y] = count(coordToComplex(x, y, size, size));\n-            }\n-        }\n-        return points;\n-    }\n-\n-    private IdentityComplex coordToComplex(int x, int y, int width, int height) {\n-        double cx = ((double) x) \/ (((double) width) \/ 2.0) - 1.0;\n-        double cy = ((double) y) \/ (((double) height) \/ 2.0) - 1.0;\n-        return new IdentityComplex(cy * SCALE, cx * SCALE);\n-    }\n-\n-    private static int count(IdentityComplex c) {\n-        IdentityComplex z = c;\n-        for (int i = 1; i < MAX_ITER; i++) {\n-            if (z.length() >= 2.0) return i;\n-            z = z.mul(z).add(c);\n-        }\n-        return MAX_ITER;\n-    }\n-\n-    public static class IdentityComplex {\n-\n-        public final double re;\n-        public final double im;\n-\n-        public IdentityComplex(double re, double im) {\n-            this.re =  re;\n-            this.im =  im;\n-        }\n-\n-        public double re() { return re; }\n-\n-        public double im() { return im; }\n-\n-        public IdentityComplex add(IdentityComplex that) {\n-            return new IdentityComplex(this.re + that.re, this.im + that.im);\n-        }\n-\n-        public IdentityComplex mul(IdentityComplex that) {\n-            return new IdentityComplex(this.re * that.re - this.im * that.im,\n-                    this.re * that.im + this.im * that.re);\n-        }\n-\n-        public double length() {\n-            return Math.sqrt(re * re + im * im);\n-        }\n-\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/mandelbrot\/Identity.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.mandelbrot;\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@Warmup(iterations = 3, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@OutputTimeUnit(TimeUnit.SECONDS)\n-@BenchmarkMode(Mode.Throughput)\n-@State(Scope.Thread)\n-public abstract class MandelbrotBase {\n-\n-    @Param(\"500\")\n-    int size;\n-\n-    public static final double SCALE = 2.0;\n-    public static final int MAX_ITER = 400;\n-\n-    int[][] points; \/\/ color points\n-\n-    @Setup()\n-    public void setup() {\n-        points = new int[size][size];\n-    }\n-\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/mandelbrot\/MandelbrotBase.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.mandelbrot;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-\n-public class Primitive extends MandelbrotBase {\n-\n-    @Benchmark\n-    public int[][] mandelbrot() {\n-        for (int x = 0; x < size; x++) {\n-            for (int y = 0; y < size; y++) {\n-                points[x][y] = count(x, y, size, size);\n-            }\n-        }\n-        return points;\n-    }\n-\n-    private int count(int x, int y, int width, int height) {\n-        double cx = (((double) x) \/ (((double) width) \/ 2.0) - 1.0) * SCALE;\n-        double cy = (((double) y) \/ (((double) height) \/ 2.0) - 1.0) * SCALE;\n-        double zx = cx;\n-        double zy = cy;\n-        for (int i = 1; i < MAX_ITER; i++) {\n-            if (Math.sqrt(zx * zx + zy * zy) >= 2.0) return i;\n-            double tx = zx * zx - zy * zy + cx;\n-            double ty = 2 * zx * zy + cy;\n-            zx = tx;\n-            zy = ty;\n-        }\n-        return MAX_ITER;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/mandelbrot\/Primitive.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.mandelbrot;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.Fork;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value extends MandelbrotBase {\n-\n-    private ValueComplex coordToComplex(int x, int y, int width, int height) {\n-        double cx = ((double) x) \/ (((double) width) \/ 2.0) - 1.0;\n-        double cy = ((double) y) \/ (((double) height) \/ 2.0) - 1.0;\n-        return new ValueComplex(cy * SCALE, cx * SCALE);\n-    }\n-\n-    private static int count(ValueComplex c) {\n-        ValueComplex z = c;\n-        for (int i = 1; i < MAX_ITER; i++) {\n-            if (z.length() >= 2.0) return i;\n-            z = z.mul(z).add(c);\n-        }\n-        return MAX_ITER;\n-    }\n-\n-    @Benchmark\n-    public int[][] mandelbrot_value() {\n-        for (int x = 0; x < size; x++) {\n-            for (int y = 0; y < size; y++) {\n-                points[x][y] = count(coordToComplex(x, y, size, size));\n-            }\n-        }\n-        return points;\n-    }\n-\n-    private Complex coordToComplex_interface(int x, int y, int width, int height) {\n-        double cx = ((double) x) \/ (((double) width) \/ 2.0) - 1.0;\n-        double cy = ((double) y) \/ (((double) height) \/ 2.0) - 1.0;\n-        return new ValueComplex(cy * SCALE, cx * SCALE);\n-    }\n-\n-    private static int count_interface(Complex c) {\n-        Complex z = c;\n-        for (int i = 1; i < MAX_ITER; i++) {\n-            if (z.length() >= 2.0) return i;\n-            z = z.mul(z).add(c);\n-        }\n-        return MAX_ITER;\n-    }\n-\n-    @Benchmark\n-    public int[][] mandelbrot_interface() {\n-        for (int x = 0; x < size; x++) {\n-            for (int y = 0; y < size; y++) {\n-                points[x][y] = count_interface(coordToComplex_interface(x, y, size, size));\n-            }\n-        }\n-        return points;\n-    }\n-\n-    public static interface Complex {\n-        public Complex add(Complex that);\n-        public Complex mul(Complex that);\n-        public double length();\n-        public double re();\n-        public double im();\n-    }\n-\n-    public static value class ValueComplex implements Complex {\n-\n-        public final double re;\n-        public final double im;\n-\n-        public ValueComplex(double re, double im) {\n-            this.re =  re;\n-            this.im =  im;\n-        }\n-\n-        @Override\n-        public double re() { return re; }\n-\n-        @Override\n-        public double im() { return im; }\n-\n-        public ValueComplex add(ValueComplex that) {\n-            return new ValueComplex(this.re + that.re, this.im + that.im);\n-        }\n-\n-        @Override\n-        public Complex add(Complex that) {\n-            return new ValueComplex(this.re + that.re(), this.im + that.im());\n-        }\n-\n-        public ValueComplex mul(ValueComplex that) {\n-            return new ValueComplex(this.re * that.re - this.im * that.im,\n-                    this.re * that.im + this.im * that.re);\n-        }\n-\n-        @Override\n-        public Complex mul(Complex that) {\n-            return new ValueComplex(this.re * that.re() - this.im * that.im(),\n-                    this.re * that.im() + this.im * that.re());\n-        }\n-\n-        public double length() {\n-            return Math.sqrt(re * re + im * im);\n-        }\n-\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/mandelbrot\/Value.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.matrix;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 3, time = 8)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class Base {\n+\n+\n+    @Param({\n+            \"20\",\n+            \"100\",\n+            \"360\",\n+    })\n+    public int size;\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/Base.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import org.openjdk.bench.valhalla.types.Complex;\n+import org.openjdk.bench.valhalla.types.RComplex;\n@@ -31,0 +33,1 @@\n+public abstract class Identity extends Base {\n@@ -32,1 +35,2 @@\n-public class Identity extends MatrixBase {\n+    public static final Complex IZERO = new RComplex(0,0);\n+    public static final RComplex RZERO = new RComplex(0,0);\n@@ -34,2 +38,7 @@\n-    public static IdentityComplex[][] create_matrix_ref(int size) {\n-        return new IdentityComplex[size][size];\n+    private static void populate(Complex[][] m) {\n+        int size = m.length;\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                m[i][j] = new RComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n+            }\n+        }\n@@ -38,3 +47,3 @@\n-    public static Complex[][] create_matrix_int(int size) {\n-        return new Complex[size][size];\n-    }\n+    public static class Ref extends Identity {\n+        RComplex[][] A;\n+        RComplex[][] B;\n@@ -42,3 +51,7 @@\n-    public static abstract class RefState extends SizeState {\n-        IdentityComplex[][] A;\n-        IdentityComplex[][] B;\n+        @Setup\n+        public void setup() {\n+            A = new RComplex[size][size];\n+            populate(A);\n+            B = new RComplex[size][size];\n+            populate(B);\n+        }\n@@ -46,2 +59,5 @@\n-        static void populate(IdentityComplex[][] m) {\n-            int size = m.length;\n+        @Benchmark\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public RComplex[][] multiply() {\n+            int size = A.length;\n+            RComplex[][] R = new RComplex[size][size];\n@@ -50,1 +66,5 @@\n-                    m[i][j] = new IdentityComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n+                    RComplex s = RZERO;\n+                    for (int k = 0; k < size; k++) {\n+                        s = s.add(A[i][k].mul(B[k][j]));\n+                    }\n+                    R[i][j] = s;\n@@ -53,0 +73,1 @@\n+            return R;\n@@ -56,1 +77,1 @@\n-    public static abstract class IntState extends SizeState {\n+    public static class Int extends Identity {\n@@ -60,11 +81,0 @@\n-        static void populate(Complex[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j] = new IdentityComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class Ref_as_Ref extends RefState {\n@@ -73,55 +83,4 @@\n-            populate(A = create_matrix_ref(size));\n-            populate(B = create_matrix_ref(size));\n-        }\n-    }\n-\n-    public static class Ref_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_ref(size));\n-            populate(B = create_matrix_ref(size));\n-        }\n-    }\n-\n-    public static class Int_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_int(size));\n-            populate(B = create_matrix_int(size));\n-        }\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public IdentityComplex[][] mult_ref_as_ref(Ref_as_Ref st) {\n-        IdentityComplex[][] A = st.A;\n-        IdentityComplex[][] B = st.B;\n-        int size = st.size;\n-        IdentityComplex[][] R = create_matrix_ref(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                IdentityComplex s = new IdentityComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_ref_as_int(Ref_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_ref(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new IdentityComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n+            A = new Complex[size][size];\n+            populate(A);\n+            B = new Complex[size][size];\n+            populate(B);\n@@ -129,2 +88,0 @@\n-        return R;\n-    }\n@@ -132,12 +89,12 @@\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_int_as_int(Int_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_int(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new IdentityComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n+        @Benchmark\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public Complex[][] multiply() {\n+            int size = A.length;\n+            Complex[][] R = new Complex[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    Complex s = IZERO;\n+                    for (int k = 0; k < size; k++) {\n+                        s = s.add(A[i][k].mul(B[k][j]));\n+                    }\n+                    R[i][j] = s;\n@@ -145,1 +102,0 @@\n-                R[i][j] = s;\n@@ -147,0 +103,1 @@\n+            return R;\n@@ -148,46 +105,0 @@\n-        return R;\n-    }\n-\n-    public interface Complex {\n-        double re();\n-        double im();\n-        Complex add(Complex that);\n-        Complex mul(Complex that);\n-    }\n-\n-    public static class IdentityComplex implements Complex {\n-\n-        private final double re;\n-        private final double im;\n-\n-        public IdentityComplex(double re, double im) {\n-            this.re =  re;\n-            this.im =  im;\n-        }\n-\n-        @Override\n-        public double re() { return re; }\n-\n-        @Override\n-        public double im() { return im; }\n-\n-        @Override\n-        public IdentityComplex add(Complex that) {\n-            return new IdentityComplex(this.re + that.re(), this.im + that.im());\n-        }\n-\n-        public IdentityComplex add(IdentityComplex that) {\n-            return new IdentityComplex(this.re + that.re, this.im + that.im);\n-        }\n-\n-        @Override\n-        public IdentityComplex mul(Complex that) {\n-            return new IdentityComplex(this.re * that.re() - this.im * that.im(),\n-                    this.re * that.im() + this.im * that.re());\n-        }\n-\n-        public IdentityComplex mul(IdentityComplex that) {\n-            return new IdentityComplex(this.re * that.re - this.im * that.im,\n-                    this.re * that.im + this.im * that.re);\n-        }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/Identity.java","additions":52,"deletions":141,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.matrix;\n+\n+import org.openjdk.bench.valhalla.types.Complex;\n+import org.openjdk.bench.valhalla.types.QComplex;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public abstract class Inline extends Base {\n+\n+    public static final Complex IZERO = new QComplex(0,0);\n+    public static final QComplex VZERO = new QComplex(0,0);\n+    public static final QComplex RZERO = new QComplex(0,0);\n+\n+    private static void populate(Complex[][] m) {\n+        int size = m.length;\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                m[i][j] = new QComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n+            }\n+        }\n+    }\n+\n+\/\/    public static class Ref extends Inline {\n+\/\/\n+\/\/    }\n+\n+    public static class Ref extends Inline {\n+        QComplex[][] A;\n+        QComplex[][] B;\n+\n+        @Setup\n+        public void setup() {\n+            A = new QComplex[size][size];\n+            populate(A);\n+            B = new QComplex[size][size];\n+            populate(B);\n+        }\n+\n+        @Benchmark\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public QComplex[][] multiply() {\n+            int size = A.length;\n+            QComplex[][] R = new QComplex[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    QComplex s = RZERO;\n+                    for (int k = 0; k < size; k++) {\n+                        s = s.add(A[i][k].mul(B[k][j]));\n+                    }\n+                    R[i][j] = s;\n+                }\n+            }\n+            return R;\n+        }\n+\n+\/\/        @Benchmark\n+\/\/        public QComplex[][] multiplyCacheFriendly() {\n+\/\/            int size = A.length;\n+\/\/            QComplex[][] R = new QComplex[size][size];\n+\/\/            for (int i = 0; i < size; i++) {\n+\/\/                for (int k = 0; k < size; k++) {\n+\/\/                    QComplex aik = A[i][k];\n+\/\/                    for (int j = 0; j < size; j++) {\n+\/\/                        R[i][j] = R[i][j].add(aik.mul(B[k][j]));\n+\/\/                    }\n+\/\/                }\n+\/\/            }\n+\/\/            return R;\n+\/\/        }\n+\n+    }\n+\n+    public static class Val extends Inline {\n+        QComplex[][] A;\n+        QComplex[][] B;\n+\n+        @Setup\n+        public void setup() {\n+            A = new QComplex[size][size];\n+            populate(A);\n+            B = new QComplex[size][size];\n+            populate(B);\n+        }\n+\n+        @Benchmark\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public QComplex[][] multiply() {\n+            int size = A.length;\n+            QComplex[][] R = new QComplex[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    QComplex s = VZERO;\n+                    for (int k = 0; k < size; k++) {\n+                        s = s.add(A[i][k].mul(B[k][j]));\n+                    }\n+                    R[i][j] = s;\n+                }\n+            }\n+            return R;\n+        }\n+\n+\/\/        @Benchmark\n+\/\/        public QComplex[][] multiplyCacheFriendly() {\n+\/\/            int size = A.length;\n+\/\/            QComplex[][] R = new QComplex[size][size];\n+\/\/            for (int i = 0; i < size; i++) {\n+\/\/                for (int k = 0; k < size; k++) {\n+\/\/                    QComplex aik = A[i][k];\n+\/\/                    for (int j = 0; j < size; j++) {\n+\/\/                        R[i][j] = R[i][j].add(aik.mul(B[k][j]));\n+\/\/                    }\n+\/\/                }\n+\/\/            }\n+\/\/            return R;\n+\/\/        }\n+\n+    }\n+\n+    public static class Int extends Inline {\n+        Complex[][] A;\n+        Complex[][] B;\n+\n+        @Setup\n+        public void setup() {\n+            A = new Complex[size][size];\n+            populate(A);\n+            B = new Complex[size][size];\n+            populate(B);\n+        }\n+\n+        @Benchmark\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public Complex[][] multiply() {\n+            int size = A.length;\n+            Complex[][] R = new Complex[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    Complex s = IZERO;\n+                    for (int k = 0; k < size; k++) {\n+                        s = s.add(A[i][k].mul(B[k][j]));\n+                    }\n+                    R[i][j] = s;\n+                }\n+            }\n+            return R;\n+        }\n+    }\n+\n+    public static class ICov extends Inline {\n+        Complex[][] A;\n+        Complex[][] B;\n+\n+        @Setup\n+        public void setup() {\n+            A = new QComplex[size][size];\n+            populate(A);\n+            B = new QComplex[size][size];\n+            populate(B);\n+        }\n+\n+        @Benchmark\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public Complex[][] multiply() {\n+            int size = A.length;\n+            Complex[][] R = new QComplex[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    Complex s = IZERO;\n+                    for (int k = 0; k < size; k++) {\n+                        s = s.add(A[i][k].mul(B[k][j]));\n+                    }\n+                    R[i][j] = s;\n+                }\n+            }\n+            return R;\n+        }\n+\n+\/\/        @Benchmark\n+\/\/        public Complex[][] multiplyCacheFriendly() {\n+\/\/            int size = A.length;\n+\/\/            Complex[][] R = new QComplex[size][size];\n+\/\/            for (int i = 0; i < size; i++) {\n+\/\/                for (int k = 0; k < size; k++) {\n+\/\/                    Complex aik = A[i][k];\n+\/\/                    for (int j = 0; j < size; j++) {\n+\/\/                        R[i][j] = R[i][j].add(aik.mul(B[k][j]));\n+\/\/                    }\n+\/\/                }\n+\/\/            }\n+\/\/            return R;\n+\/\/        }\n+\n+    }\n+\n+    public static class RCov extends Inline {\n+        QComplex[][] A;\n+        QComplex[][] B;\n+\n+        @Setup\n+        public void setup() {\n+            A = new QComplex[size][size];\n+            populate(A);\n+            B = new QComplex[size][size];\n+            populate(B);\n+        }\n+\n+        @Benchmark\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public QComplex[][] multiply() {\n+            int size = A.length;\n+            QComplex[][] R = new QComplex[size][size];\n+            for (int i = 0; i < size; i++) {\n+                for (int j = 0; j < size; j++) {\n+                    QComplex s = RZERO;\n+                    for (int k = 0; k < size; k++) {\n+                        s = s.add(A[i][k].mul(B[k][j]));\n+                    }\n+                    R[i][j] = s;\n+                }\n+            }\n+            return R;\n+        }\n+\n+\/\/        @Benchmark\n+\/\/        public Complex[][] multiplyCacheFriendly() {\n+\/\/            int size = A.length;\n+\/\/            Complex[][] R = new QComplex[size][size];\n+\/\/            for (int i = 0; i < size; i++) {\n+\/\/                for (int k = 0; k < size; k++) {\n+\/\/                    Complex aik = A[i][k];\n+\/\/                    for (int j = 0; j < size; j++) {\n+\/\/                        R[i][j] = R[i][j].add(aik.mul(B[k][j]));\n+\/\/                    }\n+\/\/                }\n+\/\/            }\n+\/\/            return R;\n+\/\/        }\n+\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/Inline.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.matrix;\n-\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Fork(3)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations = 5, time = 3)\n-@Measurement(iterations = 3, time = 8)\n-@BenchmarkMode(Mode.AverageTime)\n-public class MatrixBase {\n-\n-    @State(Scope.Thread)\n-    public static abstract class SizeState {\n-        @Param({\n-                \"20\",\n-                \"360\",\n-        })\n-        public int size;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/MatrixBase.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public class Primitive extends MatrixBase {\n+public class Primitive extends Base {\n@@ -33,3 +33,2 @@\n-    public static class PrimState extends SizeState {\n-        double[][] A;\n-        double[][] B;\n+    double[][] A;\n+    double[][] B;\n@@ -37,5 +36,5 @@\n-        @Setup\n-        public void setup() {\n-            A = populate(new double[size][size * 2]);\n-            B = populate(new double[size][size * 2]);\n-        }\n+    @Setup\n+    public void setup() {\n+        A = populate(new double[size][size*2]);\n+        B = populate(new double[size][size*2]);\n+    }\n@@ -43,7 +42,6 @@\n-        private double[][] populate(double[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j * 2] = ThreadLocalRandom.current().nextDouble();\n-                    m[i][j * 2 + 1] = ThreadLocalRandom.current().nextDouble();\n-                }\n+    private double[][] populate(double[][] m) {\n+        int size = m.length;\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                m[i][j*2+0] = ThreadLocalRandom.current().nextDouble();\n+                m[i][j*2+1] = ThreadLocalRandom.current().nextDouble();\n@@ -51,1 +49,0 @@\n-            return m;\n@@ -53,1 +50,1 @@\n-\n+        return m;\n@@ -58,4 +55,2 @@\n-    public double[][] multiply(PrimState st) {\n-        double[][] A = st.A;\n-        double[][] B = st.B;\n-        int size = st.size;\n+    public double[][] multiply() {\n+        int size = A.length;\n@@ -68,1 +63,1 @@\n-                    double are = A[i][k * 2];\n+                    double are = A[i][k * 2 + 0];\n@@ -70,1 +65,1 @@\n-                    double bre = B[k][j * 2];\n+                    double bre = B[k][j * 2 + 0];\n@@ -75,1 +70,1 @@\n-                R[i][j * 2] = s_re;\n+                R[i][j * 2 + 0] = s_re;\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/Primitive.java","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,197 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.matrix;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value extends MatrixBase {\n-\n-    public static ValueComplex[][] create_matrix_val(int size) {\n-        return new ValueComplex[size][size];\n-    }\n-\n-    public static Complex[][] create_matrix_int(int size) {\n-        return new Complex[size][size];\n-    }\n-\n-    public static abstract class ValState extends SizeState {\n-        ValueComplex[][] A;\n-        ValueComplex[][] B;\n-\n-        static void populate(ValueComplex[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j] = new ValueComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n-                }\n-            }\n-        }\n-    }\n-\n-    public static abstract class IntState extends SizeState {\n-        Complex[][] A;\n-        Complex[][] B;\n-\n-        static void populate(Complex[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j] = new ValueComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class Val_as_Val extends ValState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_val(size));\n-            populate(B = create_matrix_val(size));\n-        }\n-    }\n-\n-    public static class Val_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_val(size));\n-            populate(B = create_matrix_val(size));\n-        }\n-    }\n-\n-    public static class Int_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_int(size));\n-            populate(B = create_matrix_int(size));\n-        }\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueComplex[][] mult_val_as_val(Val_as_Val st) {\n-        ValueComplex[][] A = st.A;\n-        ValueComplex[][] B = st.B;\n-        int size = st.size;\n-        ValueComplex[][] R = create_matrix_val(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                ValueComplex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_val_as_int(Val_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_val(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_int_as_int(Int_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_int(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    public interface Complex {\n-        double re();\n-        double im();\n-        Complex add(Complex that);\n-        Complex mul(Complex that);\n-    }\n-\n-    public static value class ValueComplex implements Complex {\n-\n-        private final double re;\n-        private final double im;\n-\n-        public ValueComplex(double re, double im) {\n-            this.re =  re;\n-            this.im =  im;\n-        }\n-\n-        @Override\n-        public double re() { return re; }\n-\n-        @Override\n-        public double im() { return im; }\n-\n-        @Override\n-        public ValueComplex add(Complex that) {\n-            return new ValueComplex(this.re + that.re(), this.im + that.im());\n-        }\n-\n-        public ValueComplex add(ValueComplex that) {\n-            return new ValueComplex(this.re + that.re, this.im + that.im);\n-        }\n-\n-        @Override\n-        public ValueComplex mul(Complex that) {\n-            return new ValueComplex(this.re * that.re() - this.im * that.im(),\n-                    this.re * that.im() + this.im * that.re());\n-        }\n-\n-        public ValueComplex mul(ValueComplex that) {\n-            return new ValueComplex(this.re * that.re - this.im * that.im,\n-                    this.re * that.im + this.im * that.re);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/Value.java","additions":0,"deletions":197,"binary":false,"changes":197,"status":"deleted"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.matrix;\n-\n-import jdk.internal.value.ValueClass;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueNullFree extends MatrixBase {\n-\n-    public static ValueComplex[][] create_matrix_val(int size) {\n-            ValueComplex[][] x;\n-            x = new ValueComplex[size][];\n-            for (int i = 0; i < size; i++) {\n-                x[i] = (ValueComplex[]) ValueClass.newNullRestrictedAtomicArray(ValueComplex.class, size, new ValueComplex(0, 0));\n-            }\n-            return x;\n-    }\n-\n-    public static Complex[][] create_matrix_int(int size) {\n-        return new Complex[size][size];\n-    }\n-\n-    public static abstract class ValState extends SizeState {\n-        ValueComplex[][] A;\n-        ValueComplex[][] B;\n-\n-        static void populate(ValueComplex[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j] = new ValueComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n-                }\n-            }\n-        }\n-    }\n-\n-    public static abstract class IntState extends SizeState {\n-        Complex[][] A;\n-        Complex[][] B;\n-\n-        static void populate(Complex[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j] = new ValueComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class Val_as_Val extends ValState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_val(size));\n-            populate(B = create_matrix_val(size));\n-        }\n-    }\n-\n-    public static class Val_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_val(size));\n-            populate(B = create_matrix_val(size));\n-        }\n-    }\n-\n-    public static class Int_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_int(size));\n-            populate(B = create_matrix_int(size));\n-        }\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueComplex[][] mult_val_as_val(Val_as_Val st) {\n-        ValueComplex[][] A = st.A;\n-        ValueComplex[][] B = st.B;\n-        int size = st.size;\n-        ValueComplex[][] R = create_matrix_val(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                ValueComplex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_val_as_int(Val_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_val(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_int_as_int(Int_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_int(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    public interface Complex {\n-        double re();\n-        double im();\n-        Complex add(Complex that);\n-        Complex mul(Complex that);\n-    }\n-\n-    public static value class ValueComplex implements Complex {\n-\n-        private final double re;\n-        private final double im;\n-\n-        public ValueComplex(double re, double im) {\n-            this.re =  re;\n-            this.im =  im;\n-        }\n-\n-        @Override\n-        public double re() { return re; }\n-\n-        @Override\n-        public double im() { return im; }\n-\n-        @Override\n-        public ValueComplex add(Complex that) {\n-            return new ValueComplex(this.re + that.re(), this.im + that.im());\n-        }\n-\n-        public ValueComplex add(ValueComplex that) {\n-            return new ValueComplex(this.re + that.re, this.im + that.im);\n-        }\n-\n-        @Override\n-        public ValueComplex mul(Complex that) {\n-            return new ValueComplex(this.re * that.re() - this.im * that.im(),\n-                    this.re * that.im() + this.im * that.re());\n-        }\n-\n-        public ValueComplex mul(ValueComplex that) {\n-            return new ValueComplex(this.re * that.re - this.im * that.im,\n-                    this.re * that.im + this.im * that.re);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/ValueNullFree.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -1,206 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.matrix;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueNullFreeNonAtomic extends MatrixBase {\n-\n-    public static ValueComplex[][] create_matrix_val(int size) {\n-            ValueComplex[][] x;\n-            x = new ValueComplex[size][];\n-            for (int i = 0; i < size; i++) {\n-                x[i] = (ValueComplex[]) ValueClass.newNullRestrictedNonAtomicArray(ValueComplex.class, size, new ValueComplex(0, 0));\n-            }\n-            return x;\n-    }\n-\n-    public static Complex[][] create_matrix_int(int size) {\n-        return new Complex[size][size];\n-    }\n-\n-    public static abstract class ValState extends SizeState {\n-        ValueComplex[][] A;\n-        ValueComplex[][] B;\n-\n-        static void populate(ValueComplex[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j] = new ValueComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n-                }\n-            }\n-        }\n-    }\n-\n-    public static abstract class IntState extends SizeState {\n-        Complex[][] A;\n-        Complex[][] B;\n-\n-        static void populate(Complex[][] m) {\n-            int size = m.length;\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    m[i][j] = new ValueComplex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());\n-                }\n-            }\n-        }\n-    }\n-\n-    public static class Val_as_Val extends ValState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_val(size));\n-            populate(B = create_matrix_val(size));\n-        }\n-    }\n-\n-    public static class Val_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_val(size));\n-            populate(B = create_matrix_val(size));\n-        }\n-    }\n-\n-    public static class Int_as_Int extends IntState {\n-        @Setup\n-        public void setup() {\n-            populate(A = create_matrix_int(size));\n-            populate(B = create_matrix_int(size));\n-        }\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public ValueComplex[][] mult_val_as_val(Val_as_Val st) {\n-        ValueComplex[][] A = st.A;\n-        ValueComplex[][] B = st.B;\n-        int size = st.size;\n-        ValueComplex[][] R = create_matrix_val(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                ValueComplex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_val_as_int(Val_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_val(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public Complex[][] mult_int_as_int(Int_as_Int st) {\n-        Complex[][] A = st.A;\n-        Complex[][] B = st.B;\n-        int size = st.size;\n-        Complex[][] R = create_matrix_int(size);\n-        for (int i = 0; i < size; i++) {\n-            for (int j = 0; j < size; j++) {\n-                Complex s = new ValueComplex(0,0);\n-                for (int k = 0; k < size; k++) {\n-                    s = s.add(A[i][k].mul(B[k][j]));\n-                }\n-                R[i][j] = s;\n-            }\n-        }\n-        return R;\n-    }\n-\n-    public interface Complex {\n-        double re();\n-        double im();\n-        Complex add(Complex that);\n-        Complex mul(Complex that);\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueComplex implements Complex {\n-\n-        private final double re;\n-        private final double im;\n-\n-        public ValueComplex(double re, double im) {\n-            this.re =  re;\n-            this.im =  im;\n-        }\n-\n-        @Override\n-        public double re() { return re; }\n-\n-        @Override\n-        public double im() { return im; }\n-\n-        @Override\n-        public ValueComplex add(Complex that) {\n-            return new ValueComplex(this.re + that.re(), this.im + that.im());\n-        }\n-\n-        public ValueComplex add(ValueComplex that) {\n-            return new ValueComplex(this.re + that.re, this.im + that.im);\n-        }\n-\n-        @Override\n-        public ValueComplex mul(Complex that) {\n-            return new ValueComplex(this.re * that.re() - this.im * that.im(),\n-                    this.re * that.im() + this.im * that.re());\n-        }\n-\n-        public ValueComplex mul(ValueComplex that) {\n-            return new ValueComplex(this.re * that.re - this.im * that.im,\n-                    this.re * that.im + this.im * that.re);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/matrix\/ValueNullFreeNonAtomic.java","additions":0,"deletions":206,"binary":false,"changes":206,"status":"deleted"},{"patch":"@@ -1,440 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.sum;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Identity extends SumBase {\n-\n-    public interface InterfaceSum {\n-        public int sum();\n-    }\n-\n-    public static class IdentityInt implements InterfaceSum {\n-        public final int v0;\n-        public IdentityInt(int value) {\n-            this.v0 = value;\n-        }\n-        public int sum() {\n-            return v0;\n-        }\n-    }\n-\n-    public static class IdentityInt2_by_int implements InterfaceSum {\n-        public final int v0, v1;\n-\n-        public IdentityInt2_by_int(int v0, int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1;\n-        }\n-    }\n-\n-    public static class IdentityInt2_by_Int implements InterfaceSum {\n-        public final IdentityInt v0, v1;\n-\n-        public IdentityInt2_by_Int(IdentityInt v0, IdentityInt v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public IdentityInt2_by_Int(int v0, int v1) {\n-            this(new IdentityInt(v0), new IdentityInt(v1));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    public static class IdentityInt4_by_int implements InterfaceSum {\n-        public final int v0, v1, v2, v3;\n-\n-        public IdentityInt4_by_int(int v0, int v1, int v2, int v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1 + v2 + v3;\n-        }\n-    }\n-\n-    public static class IdentityInt4_by_Int implements InterfaceSum {\n-        public final IdentityInt v0, v1, v2, v3;\n-\n-        public IdentityInt4_by_Int(IdentityInt v0, IdentityInt v1, IdentityInt v2, IdentityInt v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public IdentityInt4_by_Int(int v0, int v1, int v2, int v3) {\n-            this(new IdentityInt(v0), new IdentityInt(v1), new IdentityInt(v2), new IdentityInt(v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum() + v2.sum() + v3.sum();\n-        }\n-    }\n-\n-    public static class IdentityInt4_by_int2 implements InterfaceSum {\n-        public final IdentityInt2_by_int v0, v1;\n-\n-        public IdentityInt4_by_int2(IdentityInt2_by_int v0, IdentityInt2_by_int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public IdentityInt4_by_int2(int v0, int v1, int v2, int v3) {\n-            this(new IdentityInt2_by_int(v0, v1), new IdentityInt2_by_int(v2, v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    public static class IdentityInt4_by_Int2 implements InterfaceSum {\n-\n-        public final IdentityInt2_by_Int v0, v1;\n-\n-        public IdentityInt4_by_Int2(IdentityInt2_by_Int v0, IdentityInt2_by_Int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public IdentityInt4_by_Int2(int v0, int v1, int v2, int v3) {\n-            this(new IdentityInt2_by_Int(v0, v1), new IdentityInt2_by_Int(v2, v3));\n-        }\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-\n-    }\n-\n-    public static class RefState_of_Int extends SizeState {\n-        public IdentityInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class RefState_of_Int2_by_int extends SizeState {\n-        public IdentityInt2_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt2_by_int[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class RefState_of_Int2_by_Int extends SizeState {\n-        public IdentityInt2_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt2_by_Int[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class RefState_of_Int4_by_int extends SizeState {\n-        public IdentityInt4_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt4_by_int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class RefState_of_Int4_by_Int extends SizeState {\n-        public IdentityInt4_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt4_by_Int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class RefState_of_Int4_by_int2 extends SizeState {\n-        public IdentityInt4_by_int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt4_by_int2[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class RefState_of_Int4_by_Int2 extends SizeState {\n-        public IdentityInt4_by_Int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new IdentityInt4_by_Int2[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new IdentityInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_interface(InterfaceSum[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_ref_of_Int(IdentityInt[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_ref_of_Int2_by_int(IdentityInt2_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_ref_of_Int2_by_Int(IdentityInt2_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_ref_of_Int4_by_int(IdentityInt4_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_ref_of_Int4_by_Int(IdentityInt4_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_ref_of_Int4_by_int2(IdentityInt4_by_int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_ref_of_Int4_by_Int2(IdentityInt4_by_Int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int(IntState_of_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_int(IntState_of_Int2_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_Int(IntState_of_Int2_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int(IntState_of_Int4_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int(IntState_of_Int4_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int2(IntState_of_Int4_by_int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int2(IntState_of_Int4_by_Int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_ref_of_Int(RefState_of_Int st) {\n-        return sum_ref_of_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_ref_of_Int2_by_int(RefState_of_Int2_by_int st) {\n-        return sum_ref_of_Int2_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_ref_of_Int2_by_Int(RefState_of_Int2_by_Int st) {\n-        return sum_ref_of_Int2_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_ref_of_Int4_by_int(RefState_of_Int4_by_int st) {\n-        return sum_ref_of_Int4_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_ref_of_Int4_by_Int(RefState_of_Int4_by_Int st) {\n-        return sum_ref_of_Int4_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_ref_of_Int4_by_int2(RefState_of_Int4_by_int2 st) {\n-        return sum_ref_of_Int4_by_int2(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_ref_of_Int4_by_Int2(RefState_of_Int4_by_Int2 st) {\n-        return sum_ref_of_Int4_by_Int2(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sum\/Identity.java","additions":0,"deletions":440,"binary":false,"changes":440,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.sum;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-public class Primitive extends SumBase {\n-\n-    public static class PrimitiveState extends SizeState {\n-        public int[] arr;\n-\n-        @Setup\n-        public void setup() {\n-            arr = new int[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = i;\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int sum_primitive(int[] src) {\n-        int s = 0;\n-        for (int v : src) {\n-            s += v;\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int sum_primitive1(int[] src) {\n-        int s = 0;\n-        for (int i = 0; i < src.length; i += 2) {\n-            s += src[i] + src[i + 1];\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private static int sum_primitive2(int[] src) {\n-        int s = 0;\n-        for (int i = 0; i < src.length; i += 4) {\n-            s += src[i] + src[i + 1] + src[i + 2] + src[i + 3];\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    public void sum(PrimitiveState st) {\n-        sum_primitive(st.arr);\n-    }\n-    @Benchmark\n-    public void sum1(PrimitiveState st) {\n-        sum_primitive1(st.arr);\n-    }\n-    @Benchmark\n-    public void sum2(PrimitiveState st) {\n-        sum_primitive2(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sum\/Primitive.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,442 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.sum;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\"})\n-public class Value extends SumBase {\n-\n-    public interface InterfaceSum {\n-        public int sum();\n-    }\n-\n-    public static value class ValueInt implements InterfaceSum {\n-        public final int v0;\n-        public ValueInt(int value) {\n-            this.v0 = value;\n-        }\n-        public int sum() {\n-            return v0;\n-        }\n-    }\n-\n-    public static value class ValueInt2_by_int implements InterfaceSum {\n-        public final int v0, v1;\n-\n-        public ValueInt2_by_int(int v0, int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1;\n-        }\n-    }\n-\n-    public static value class ValueInt2_by_Int implements InterfaceSum {\n-        public final ValueInt v0, v1;\n-\n-        public ValueInt2_by_Int(ValueInt v0, ValueInt v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt2_by_Int(int v0, int v1) {\n-            this(new ValueInt(v0), new ValueInt(v1));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    public static value class ValueInt4_by_int implements InterfaceSum {\n-        public final int v0, v1, v2, v3;\n-\n-        public ValueInt4_by_int(int v0, int v1, int v2, int v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1 + v2 + v3;\n-        }\n-    }\n-\n-    public static value class ValueInt4_by_Int implements InterfaceSum {\n-        public final ValueInt v0, v1, v2, v3;\n-\n-        public ValueInt4_by_Int(ValueInt v0, ValueInt v1, ValueInt v2, ValueInt v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public ValueInt4_by_Int(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt(v0), new ValueInt(v1), new ValueInt(v2), new ValueInt(v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum() + v2.sum() + v3.sum();\n-        }\n-    }\n-\n-    public static value  class ValueInt4_by_int2 implements InterfaceSum {\n-        public final ValueInt2_by_int v0, v1;\n-\n-        public ValueInt4_by_int2(ValueInt2_by_int v0, ValueInt2_by_int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt4_by_int2(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt2_by_int(v0, v1), new ValueInt2_by_int(v2, v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    public static value class ValueInt4_by_Int2 implements InterfaceSum {\n-\n-        public final ValueInt2_by_Int v0, v1;\n-\n-        public ValueInt4_by_Int2(ValueInt2_by_Int v0, ValueInt2_by_Int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt4_by_Int2(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt2_by_Int(v0, v1), new ValueInt2_by_Int(v2, v3));\n-        }\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-\n-    }\n-\n-    public static class ValState_of_Int extends SizeState {\n-        public ValueInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int2_by_int extends SizeState {\n-        public ValueInt2_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt2_by_int[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int2_by_Int extends SizeState {\n-        public ValueInt2_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt2_by_Int[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_int extends SizeState {\n-        public ValueInt4_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4_by_int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_Int extends SizeState {\n-        public ValueInt4_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4_by_Int[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_int2 extends SizeState {\n-        public ValueInt4_by_int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4_by_int2[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_Int2 extends SizeState {\n-        public ValueInt4_by_Int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new ValueInt4_by_Int2[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_interface(InterfaceSum[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int(ValueInt[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int2_by_int(ValueInt2_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int2_by_Int(ValueInt2_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_int(ValueInt4_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_Int(ValueInt4_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_int2(ValueInt4_by_int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_Int2(ValueInt4_by_Int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int(IntState_of_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_int(IntState_of_Int2_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_Int(IntState_of_Int2_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int(IntState_of_Int4_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int(IntState_of_Int4_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int2(IntState_of_Int4_by_int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int2(IntState_of_Int4_by_Int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int(ValState_of_Int st) {\n-        return sum_val_of_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int2_by_int(ValState_of_Int2_by_int st) {\n-        return sum_val_of_Int2_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int2_by_Int(ValState_of_Int2_by_Int st) {\n-        return sum_val_of_Int2_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_int(ValState_of_Int4_by_int st) {\n-        return sum_val_of_Int4_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_Int(ValState_of_Int4_by_Int st) {\n-        return sum_val_of_Int4_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_int2(ValState_of_Int4_by_int2 st) {\n-        return sum_val_of_Int4_by_int2(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_Int2(ValState_of_Int4_by_Int2 st) {\n-        return sum_val_of_Int4_by_Int2(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sum\/Value.java","additions":0,"deletions":442,"binary":false,"changes":442,"status":"deleted"},{"patch":"@@ -1,452 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.sum;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueNullFree extends SumBase {\n-\n-    public interface InterfaceSum {\n-        public int sum();\n-    }\n-\n-    public static value class ValueInt implements InterfaceSum {\n-        public final int v0;\n-        public ValueInt(int value) {\n-            this.v0 = value;\n-        }\n-        public int sum() {\n-            return v0;\n-        }\n-    }\n-\n-    public static value class ValueInt2_by_int implements InterfaceSum {\n-        public final int v0, v1;\n-\n-        public ValueInt2_by_int(int v0, int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1;\n-        }\n-    }\n-\n-    public static value class ValueInt2_by_Int implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt v0, v1;\n-\n-        public ValueInt2_by_Int(ValueInt v0, ValueInt v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt2_by_Int(int v0, int v1) {\n-            this(new ValueInt(v0), new ValueInt(v1));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    public static value class ValueInt4_by_int implements InterfaceSum {\n-        public final int v0, v1, v2, v3;\n-\n-        public ValueInt4_by_int(int v0, int v1, int v2, int v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1 + v2 + v3;\n-        }\n-    }\n-\n-    public static value class ValueInt4_by_Int implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt v0, v1, v2, v3;\n-\n-        public ValueInt4_by_Int(ValueInt v0, ValueInt v1, ValueInt v2, ValueInt v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public ValueInt4_by_Int(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt(v0), new ValueInt(v1), new ValueInt(v2), new ValueInt(v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum() + v2.sum() + v3.sum();\n-        }\n-    }\n-\n-    public static value  class ValueInt4_by_int2 implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt2_by_int v0, v1;\n-\n-        public ValueInt4_by_int2(ValueInt2_by_int v0, ValueInt2_by_int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt4_by_int2(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt2_by_int(v0, v1), new ValueInt2_by_int(v2, v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    public static value class ValueInt4_by_Int2 implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt2_by_Int v0, v1;\n-\n-        public ValueInt4_by_Int2(ValueInt2_by_Int v0, ValueInt2_by_Int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt4_by_Int2(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt2_by_Int(v0, v1), new ValueInt2_by_Int(v2, v3));\n-        }\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-\n-    }\n-\n-    public static class ValState_of_Int extends SizeState {\n-        public ValueInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[])ValueClass.newNullRestrictedAtomicArray(ValueInt.class, size * 4, new ValueInt(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int2_by_int extends SizeState {\n-        public ValueInt2_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt2_by_int[])ValueClass.newNullRestrictedAtomicArray(ValueInt2_by_int.class, size * 2, new ValueInt2_by_int(0, 0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int2_by_Int extends SizeState {\n-        public ValueInt2_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt2_by_Int[])ValueClass.newNullRestrictedAtomicArray(ValueInt2_by_Int.class, size * 4, new ValueInt2_by_Int(0, 0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_int extends SizeState {\n-        public ValueInt4_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_int[])ValueClass.newNullRestrictedAtomicArray(ValueInt4_by_int.class, size, new ValueInt4_by_int(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_Int extends SizeState {\n-        public ValueInt4_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_Int[])ValueClass.newNullRestrictedAtomicArray(ValueInt4_by_Int.class, size, new ValueInt4_by_Int(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_int2 extends SizeState {\n-        public ValueInt4_by_int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_int2[])ValueClass.newNullRestrictedAtomicArray(ValueInt4_by_int2.class, size, new ValueInt4_by_int2(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_Int2 extends SizeState {\n-        public ValueInt4_by_Int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_Int2[])ValueClass.newNullRestrictedAtomicArray(ValueInt4_by_Int2.class, size, new ValueInt4_by_Int2(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_interface(InterfaceSum[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int(ValueInt[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int2_by_int(ValueInt2_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int2_by_Int(ValueInt2_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_int(ValueInt4_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_Int(ValueInt4_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_int2(ValueInt4_by_int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_Int2(ValueInt4_by_Int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int(IntState_of_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_int(IntState_of_Int2_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_Int(IntState_of_Int2_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int(IntState_of_Int4_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int(IntState_of_Int4_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int2(IntState_of_Int4_by_int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int2(IntState_of_Int4_by_Int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int(ValState_of_Int st) {\n-        return sum_val_of_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int2_by_int(ValState_of_Int2_by_int st) {\n-        return sum_val_of_Int2_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int2_by_Int(ValState_of_Int2_by_Int st) {\n-        return sum_val_of_Int2_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_int(ValState_of_Int4_by_int st) {\n-        return sum_val_of_Int4_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_Int(ValState_of_Int4_by_Int st) {\n-        return sum_val_of_Int4_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_int2(ValState_of_Int4_by_int2 st) {\n-        return sum_val_of_Int4_by_int2(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_Int2(ValState_of_Int4_by_Int2 st) {\n-        return sum_val_of_Int4_by_Int2(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sum\/ValueNullFree.java","additions":0,"deletions":452,"binary":false,"changes":452,"status":"deleted"},{"patch":"@@ -1,460 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.valhalla.sum;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"})\n-public class ValueNullFreeNonAtomic extends SumBase {\n-\n-    public interface InterfaceSum {\n-        public int sum();\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt implements InterfaceSum {\n-        public final int v0;\n-        public ValueInt(int value) {\n-            this.v0 = value;\n-        }\n-        public int sum() {\n-            return v0;\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt2_by_int implements InterfaceSum {\n-        public final int v0, v1;\n-\n-        public ValueInt2_by_int(int v0, int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1;\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt2_by_Int implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt v0, v1;\n-\n-        public ValueInt2_by_Int(ValueInt v0, ValueInt v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt2_by_Int(int v0, int v1) {\n-            this(new ValueInt(v0), new ValueInt(v1));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4_by_int implements InterfaceSum {\n-        public final int v0, v1, v2, v3;\n-\n-        public ValueInt4_by_int(int v0, int v1, int v2, int v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public int sum() {\n-            return v0 + v1 + v2 + v3;\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4_by_Int implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt v0, v1, v2, v3;\n-\n-        public ValueInt4_by_Int(ValueInt v0, ValueInt v1, ValueInt v2, ValueInt v3) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-            this.v2 = v2;\n-            this.v3 = v3;\n-        }\n-\n-        public ValueInt4_by_Int(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt(v0), new ValueInt(v1), new ValueInt(v2), new ValueInt(v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum() + v2.sum() + v3.sum();\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4_by_int2 implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt2_by_int v0, v1;\n-\n-        public ValueInt4_by_int2(ValueInt2_by_int v0, ValueInt2_by_int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt4_by_int2(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt2_by_int(v0, v1), new ValueInt2_by_int(v2, v3));\n-        }\n-\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-    }\n-\n-    @LooselyConsistentValue\n-    public static value class ValueInt4_by_Int2 implements InterfaceSum {\n-        @Strict\n-        @NullRestricted\n-        public final ValueInt2_by_Int v0, v1;\n-\n-        public ValueInt4_by_Int2(ValueInt2_by_Int v0, ValueInt2_by_Int v1) {\n-            this.v0 = v0;\n-            this.v1 = v1;\n-        }\n-\n-        public ValueInt4_by_Int2(int v0, int v1, int v2, int v3) {\n-            this(new ValueInt2_by_Int(v0, v1), new ValueInt2_by_Int(v2, v3));\n-        }\n-        public int sum() {\n-            return v0.sum() + v1.sum();\n-        }\n-\n-    }\n-\n-    public static class ValState_of_Int extends SizeState {\n-        public ValueInt[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt[])ValueClass.newNullRestrictedNonAtomicArray(ValueInt.class, size * 4, new ValueInt(0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 4];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt(i);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int2_by_int extends SizeState {\n-        public ValueInt2_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt2_by_int[])ValueClass.newNullRestrictedNonAtomicArray(ValueInt2_by_int.class, size * 2, new ValueInt2_by_int(0, 0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int2_by_Int extends SizeState {\n-        public ValueInt2_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt2_by_Int[])ValueClass.newNullRestrictedNonAtomicArray(ValueInt2_by_Int.class, size * 4, new ValueInt2_by_Int(0, 0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int2_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size * 2];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt2_by_Int(2 * i, 2 * i + 1);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_int extends SizeState {\n-        public ValueInt4_by_int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_int[])ValueClass.newNullRestrictedNonAtomicArray(ValueInt4_by_int.class, size, new ValueInt4_by_int(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_Int extends SizeState {\n-        public ValueInt4_by_Int[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_Int[])ValueClass.newNullRestrictedNonAtomicArray(ValueInt4_by_Int.class, size, new ValueInt4_by_Int(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_int2 extends SizeState {\n-        public ValueInt4_by_int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_int2[])ValueClass.newNullRestrictedNonAtomicArray(ValueInt4_by_int2.class, size, new ValueInt4_by_int2(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class ValState_of_Int4_by_Int2 extends SizeState {\n-        public ValueInt4_by_Int2[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = (ValueInt4_by_Int2[])ValueClass.newNullRestrictedNonAtomicArray(ValueInt4_by_Int2.class, size, new ValueInt4_by_Int2(0, 0, 0,  0));\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    public static class IntState_of_Int4_by_Int2 extends SizeState {\n-        public InterfaceSum[] arr;\n-        @Setup\n-        public void setup() {\n-            arr = new InterfaceSum[size];\n-            for (int i = 0; i < arr.length; i++) {\n-                arr[i] = new ValueInt4_by_Int2(4 * i, 4 * i + 1, 4 * i + 2, 4 * i + 3);\n-            }\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_interface(InterfaceSum[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int(ValueInt[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int2_by_int(ValueInt2_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int2_by_Int(ValueInt2_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_int(ValueInt4_by_int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_Int(ValueInt4_by_Int[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_int2(ValueInt4_by_int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int sum_val_of_Int4_by_Int2(ValueInt4_by_Int2[] src) {\n-        int s = 0;\n-        for (var v : src) {\n-            s += v.sum();\n-        }\n-        return s;\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int(IntState_of_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_int(IntState_of_Int2_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int2_by_Int(IntState_of_Int2_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int(IntState_of_Int4_by_int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int(IntState_of_Int4_by_Int st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_int2(IntState_of_Int4_by_int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_interface_of_Int4_by_Int2(IntState_of_Int4_by_Int2 st) {\n-        return sum_interface(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int(ValState_of_Int st) {\n-        return sum_val_of_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int2_by_int(ValState_of_Int2_by_int st) {\n-        return sum_val_of_Int2_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int2_by_Int(ValState_of_Int2_by_Int st) {\n-        return sum_val_of_Int2_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_int(ValState_of_Int4_by_int st) {\n-        return sum_val_of_Int4_by_int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_Int(ValState_of_Int4_by_Int st) {\n-        return sum_val_of_Int4_by_Int(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_int2(ValState_of_Int4_by_int2 st) {\n-        return sum_val_of_Int4_by_int2(st.arr);\n-    }\n-\n-    @Benchmark\n-    public int sum_val_of_Int4_by_Int2(ValState_of_Int4_by_Int2 st) {\n-        return sum_val_of_Int4_by_Int2(st.arr);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sum\/ValueNullFreeNonAtomic.java","additions":0,"deletions":460,"binary":false,"changes":460,"status":"deleted"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.traversal;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.R32int;\n+import org.openjdk.bench.valhalla.util.Utils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class Identity32 extends SizeBase {\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int32[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new R32int(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public R32int[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new R32int(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int32[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new R32int[size];\n+            fill();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_walk(Int_as_Int s) {\n+        int steps = 0;\n+        Int32[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_walk(Ref_as_Ref s) {\n+        int steps = 0;\n+        R32int[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/traversal\/Identity32.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.traversal;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.bench.valhalla.types.A64long;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.R64long;\n+import org.openjdk.bench.valhalla.util.Utils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class Identity64 extends SizeBase {\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new R64long(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static abstract class AbsState extends SizeState {\n+        public A64long[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new R64long(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public R64long[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new R64long(a[i]);\n+            }\n+        }\n+    }\n+\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Abs_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new A64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Abs_as_Abs extends AbsState {\n+        @Setup\n+        public void setup() {\n+            arr = new A64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Abs extends AbsState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new R64long[size];\n+            fill();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_walk(Int_as_Int s) {\n+        int steps = 0;\n+        Int64[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Abs_as_Int_walk(Abs_as_Int s) {\n+        int steps = 0;\n+        Int64[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Int_walk(Ref_as_Int s) {\n+        int steps = 0;\n+        Int64[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Abs_as_Abs_walk(Abs_as_Abs s) {\n+        int steps = 0;\n+        A64long[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Abs_walk(Ref_as_Abs s) {\n+        int steps = 0;\n+        A64long[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_walk(Ref_as_Ref s) {\n+        int steps = 0;\n+        A64long[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/traversal\/Identity64.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.traversal;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.bench.valhalla.types.Int32;\n+import org.openjdk.bench.valhalla.types.Q32int;\n+import org.openjdk.bench.valhalla.util.Utils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class Inline32 extends SizeBase {\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int32[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new Q32int(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q32int[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new Q32int(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q32int[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new Q32int(a[i]);\n+            }\n+        }\n+    }\n+\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int32[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q32int[size];\n+            fill();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_walk(Int_as_Int s) {\n+        int steps = 0;\n+        Int32[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_walk(Ref_as_Ref s) {\n+        int steps = 0;\n+        Q32int[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_walk(Val_as_Val s) {\n+        int steps = 0;\n+        Q32int[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/traversal\/Inline32.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.traversal;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.bench.valhalla.types.Int64;\n+import org.openjdk.bench.valhalla.types.Q64long;\n+import org.openjdk.bench.valhalla.util.Utils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class Inline64 extends SizeBase {\n+\n+    public static abstract class IntState extends SizeState {\n+        public Int64[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new Q64long(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static abstract class RefState extends SizeState {\n+        public Q64long[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new Q64long(a[i]);\n+            }\n+        }\n+    }\n+\n+    public static abstract class ValState extends SizeState {\n+        public Q64long[] arr;\n+        void fill() {\n+            int[] a = Utils.makeRandomRing(arr.length);\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = new Q64long(a[i]);\n+            }\n+        }\n+    }\n+\n+\n+    public static class Int_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Int64[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Int extends IntState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Ref_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Ref extends RefState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    public static class Val_as_Val extends ValState {\n+        @Setup\n+        public void setup() {\n+            arr = new Q64long[size];\n+            fill();\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Int_as_Int_walk(Int_as_Int s) {\n+        int steps = 0;\n+        Int64[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Int_walk(Ref_as_Int s) {\n+        int steps = 0;\n+        Int64[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Int_walk(Val_as_Int s) {\n+        int steps = 0;\n+        Int64[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Ref_as_Ref_walk(Ref_as_Ref s) {\n+        int steps = 0;\n+        Q64long[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Ref_walk(Val_as_Ref s) {\n+        int steps = 0;\n+        Q64long[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int Val_as_Val_walk(Val_as_Val s) {\n+        int steps = 0;\n+        Q64long[] values = s.arr;\n+        for (int i = values[0].intValue(); i != 0; i = values[i].intValue()) steps++;\n+        return steps;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/traversal\/Inline64.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.traversal;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.bench.valhalla.util.Utils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class Primitive32 extends SizeBase {\n+\n+    public static class IntState extends SizeState {\n+        public int[] arr;\n+\n+        @Setup\n+        public void setup() {\n+            int[] a = Utils.makeRandomRing(size);\n+            arr = new int[a.length];\n+            System.arraycopy(a, 0, arr, 0, a.length);\n+        }\n+\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int walk(IntState s) {\n+        int steps = 0;\n+        int[] values = s.arr;\n+        for (int i = values[0]; i != 0; i = values[i]) steps++;\n+        return steps;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/traversal\/Primitive32.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.traversal;\n+\n+import org.openjdk.bench.valhalla.util.SizeBase;\n+import org.openjdk.bench.valhalla.util.Utils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+public class Primitive64 extends SizeBase {\n+\n+    public static class LongState extends SizeState {\n+        public long[] arr;\n+\n+        @Setup\n+        public void setup() {\n+            int[] a = Utils.makeRandomRing(size);\n+            arr = new long[a.length];\n+            for (int i = 0; i < a.length; i++) {\n+                arr[i] = a[i];\n+            }\n+        }\n+\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int walk(LongState s) {\n+        int steps = 0;\n+        long[] values = s.arr;\n+        for (int i = (int) values[0]; i != 0; i = (int) values[i]) steps++;\n+        return steps;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/traversal\/Primitive64.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public abstract class A64long implements Int64, ByLong {\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/A64long.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface ByByte {\n+\n+    public byte byteSum();\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/ByByte.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface ByInt {\n+\n+    public int intSum();\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/ByInt.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface ByLong {\n+\n+    public long longSum();\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/ByLong.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface Complex {\n+\n+    double re();\n+\n+    double im();\n+\n+    Complex add(Complex that);\n+\n+    Complex mul(Complex that);\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Complex.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface Int128 {\n+\n+    public int intValue();\n+\n+    public long longValue();\n+\n+    public long hiValue();\n+\n+    public long loValue();\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Int128.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface Int32 extends Comparable<Int32>  {\n+\n+    public long longValue();\n+\n+    public int intValue();\n+\n+    public Int32 neg();\n+\n+    public Int32 add(Int32 o);\n+\n+    public Int32 sub(Int32 o);\n+\n+    public Int32 mult(Int32 o);\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Int32.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface Int64 {\n+\n+    public long longValue();\n+\n+    public int intValue();\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Int64.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public interface Opt<T> {\n+\n+    public T get();\n+    public boolean isPresent();\n+    public boolean isEmpty();\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Opt.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q128byte implements Int128, ByByte {\n+\n+    public final Q64byte v0;\n+    public final Q64byte v1;\n+\n+    public Q128byte(long v) {\n+        this(0, v);\n+    }\n+\n+    public Q128byte(long hi, long lo) {\n+        this.v0 = new Q64byte(hi);\n+        this.v1 = new Q64byte(lo);\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return v1.intValue();\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return loValue();\n+    }\n+\n+    @Override\n+    public long hiValue() {\n+        return v0.longValue();\n+    }\n+\n+    @Override\n+    public long loValue() {\n+        return v1.longValue();\n+    }\n+\n+    @Override\n+    public byte byteSum() {\n+        return (byte) (v0.byteSum() + v1.byteSum());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q128byte.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q128int implements Int128, ByInt {\n+\n+    public final Q64int v0;\n+    public final Q64int v1;\n+\n+    public Q128int() {\n+        this(0, 0);\n+    }\n+\n+    public Q128int(long v) {\n+        this(0, v);\n+    }\n+\n+    public Q128int(long hi, long lo) {\n+        this.v0 = new Q64int(hi);\n+        this.v1 = new Q64int(lo);\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return v1.intValue();\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return loValue();\n+    }\n+\n+    @Override\n+    public long hiValue() {\n+        return v0.longValue();\n+    }\n+\n+    @Override\n+    public long loValue() {\n+        return v1.longValue();\n+    }\n+\n+    @Override\n+    public int intSum() {\n+        return v0.intSum() + v1.intSum();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q128int.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q128long implements Int128, ByLong {\n+\n+    public final long v0;\n+    public final long v1;\n+\n+    public Q128long(long v) {\n+        this(0, v);\n+    }\n+\n+    public Q128long(long hi, long lo) {\n+        this.v0 = hi;\n+        this.v1 = lo;\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return (int)longValue();\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return loValue();\n+    }\n+\n+    @Override\n+    public long hiValue() {\n+        return v0;\n+    }\n+\n+    @Override\n+    public long loValue() {\n+        return v1;\n+    }\n+\n+    @Override\n+    public long longSum() {\n+        return v0 + v1;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q128long.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q32byte implements Int32, ByByte {\n+\n+    public final byte v0;\n+    public final byte v1;\n+    public final byte v2;\n+    public final byte v3;\n+\n+    public Q32byte() {\n+        this(0);\n+    }\n+\n+    public Q32byte(int v) {\n+        this((byte) (v >>> 24), (byte) (v >>> 16), (byte) (v >>> 8), (byte) (v));\n+    }\n+\n+    public Q32byte(byte v0, byte v1, byte v2, byte v3) {\n+        this.v0 = v0;\n+        this.v1 = v1;\n+        this.v2 = v2;\n+        this.v3 = v3;\n+    }\n+\n+    private static final int MASK = 0xFF;\n+\n+    @Override\n+    public long longValue() {\n+        return (long) intValue();\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return (((v0 & MASK) << 24) | ((v1 & MASK) << 16) | ((v2 & MASK) << 8) | (v3 & MASK));\n+    }\n+\n+    @Override\n+    public Int32 neg() {\n+        return new Q32byte(-intValue());\n+    }\n+\n+    @Override\n+    public Int32 add(Int32 o) {\n+        return new Q32byte(intValue() + o.intValue());\n+    }\n+\n+    @Override\n+    public Int32 sub(Int32 o) {\n+        return new Q32byte(intValue() - o.intValue());\n+    }\n+\n+    @Override\n+    public Int32 mult(Int32 o) {\n+        return new Q32byte(intValue() * o.intValue());\n+    }\n+\n+    @Override\n+    public int compareTo(Int32 o) {\n+        return Integer.compare(intValue(), o.intValue());\n+    }\n+\n+    @Override\n+    public byte byteSum() {\n+        return (byte) (v0 + v1 + v2 + v3);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q32byte.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q32int implements Int32, ByInt {\n+\n+    public final int v0;\n+\n+    public Q32int() {\n+        v0 = 0;\n+    }\n+\n+    public Q32int(int val) {\n+        this.v0 = val;\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return (long)v0;\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return v0;\n+    }\n+\n+    @Override\n+    public Int32 neg() {\n+        return new Q32int(-v0);\n+    }\n+\n+    @Override\n+    public Int32 add(Int32 o) {\n+        return new Q32int(v0 + o.intValue());\n+    }\n+\n+    public Int32 add(Q32int o) {\n+        return new Q32int(v0 + o.v0);\n+    }\n+\n+    @Override\n+    public Int32 sub(Int32 o) {\n+        return new Q32int(v0 - o.intValue());\n+    }\n+\n+    public Int32 sub(Q32int o) {\n+        return new Q32int(v0 - o.v0);\n+    }\n+\n+    @Override\n+    public Int32 mult(Int32 o) {\n+        return new Q32int(v0 * o.intValue());\n+    }\n+\n+    public Int32 mult(Q32int o) {\n+        return new Q32int(v0 * o.v0);\n+    }\n+\n+    @Override\n+    public int compareTo(Int32 o) {\n+        return Integer.compare(v0, o.intValue());\n+    }\n+\n+    public int compareTo(Q32int o) {\n+        return Integer.compare(v0, o.v0);\n+    }\n+\n+    @Override\n+    public int intSum() {\n+        return v0;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q32int.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q64byte implements Int64, ByByte {\n+\n+    public final Q32byte v0;\n+    public final Q32byte v1;\n+\n+    public Q64byte() {\n+        this.v0 = new Q32byte();\n+        this.v1 = new Q32byte();\n+    }\n+\n+    public Q64byte(long v) {\n+        this((int) (v >>> 32), (int) v);\n+    }\n+\n+    public Q64byte(int hi, int lo) {\n+        this.v0 = new Q32byte(hi);\n+        this.v1 = new Q32byte(lo);\n+    }\n+\n+    private static final long MASK = 0xFFFFFFFFL;\n+\n+    @Override\n+    public long longValue() {\n+        return (v0.intValue() & MASK) << 32 | (v1.intValue() & MASK);\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return v1.intValue();\n+    }\n+\n+    @Override\n+    public byte byteSum() {\n+        return (byte) (v0.byteSum() + v1.byteSum());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q64byte.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q64int implements Int64, ByInt {\n+\n+    public final Q32int v0;\n+    public final Q32int v1;\n+\n+    public Q64int() {\n+        this(0);\n+    }\n+\n+    public Q64int(long v) {\n+        this((int) (v >>> 32), (int) v);\n+    }\n+\n+    public Q64int(int hi, int lo) {\n+        this.v0 = new Q32int(hi);\n+        this.v1 = new Q32int(lo);\n+    }\n+\n+    private static final long MASK = 0xFFFFFFFFL;\n+\n+    @Override\n+    public long longValue() {\n+        return (v0.intValue() & MASK) << 32 | (v1.intValue() & MASK);\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return v1.intValue();\n+    }\n+\n+    @Override\n+    public int intSum() {\n+        return v0.intSum() + v1.intSum();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q64int.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class Q64long implements Int64, ByLong {\n+\n+    public final long v0;\n+\n+    public Q64long() {\n+        this(0);\n+    }\n+\n+    public Q64long(long v0) {\n+        this.v0 = v0;\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return v0;\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return (int)v0;\n+    }\n+\n+    @Override\n+    public long longSum() {\n+        return v0;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/Q64long.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public value class QComplex implements Complex {\n+\n+    public final double re;\n+    public final double im;\n+\n+    public QComplex(double re, double im) {\n+        this.re =  re;\n+        this.im =  im;\n+    }\n+\n+    @Override\n+    public double re() { return re; }\n+\n+    @Override\n+    public double im() { return im; }\n+\n+    @Override\n+    public QComplex add(Complex that) {\n+        return new QComplex(this.re + that.re(), this.im + that.im());\n+    }\n+\n+    public QComplex add(QComplex that) {\n+        return new QComplex(this.re + that.re, this.im + that.im);\n+    }\n+\n+    @Override\n+    public QComplex mul(Complex that) {\n+        return new QComplex(this.re * that.re() - this.im * that.im(),\n+                           this.re * that.im() + this.im * that.re());\n+    }\n+\n+    public QComplex mul(QComplex that) {\n+        return new QComplex(this.re * that.re - this.im * that.im,\n+                           this.re * that.im + this.im * that.re);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/QComplex.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+import java.util.NoSuchElementException;\n+\n+public value class QOpt<T> implements Opt<T> {\n+\n+    public final T value;\n+\n+    private QOpt(T value) {\n+        this.value = value;\n+    }\n+\n+    public static <T> QOpt<T> of() {\n+        return new QOpt<>(null);\n+    }\n+\n+    public static <T> QOpt<T> of(T value) {\n+        return new QOpt<>(value);\n+    }\n+\n+    public T get() {\n+        if (value == null) {\n+            throw new NoSuchElementException(\"No value present\");\n+        }\n+        return value;\n+    }\n+\n+    public boolean isPresent() {\n+        return value != null;\n+    }\n+\n+    public boolean isEmpty() {\n+        return value == null;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/QOpt.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class R128int implements Int128, ByInt {\n+\n+    public final int v0;\n+    public final int v1;\n+    public final int v2;\n+    public final int v3;\n+\n+    public R128int(long v) {\n+        this(0, 0, (int) (v >>> 32), (int) v);\n+    }\n+\n+    public R128int(int v0, int v1, int v2, int v3) {\n+        this.v0 = v0;\n+        this.v1 = v1;\n+        this.v2 = v2;\n+        this.v3 = v3;\n+    }\n+\n+    private static final long MASK = 0xFFFFFFFFL;\n+\n+    @Override\n+    public int intValue() {\n+        return v3;\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return loValue();\n+    }\n+\n+    @Override\n+    public long hiValue() {\n+        return (v0 & MASK) << 32 | (v1 & MASK);\n+    }\n+\n+    @Override\n+    public long loValue() {\n+        return (v2 & MASK) << 32 | (v3 & MASK);\n+    }\n+\n+    @Override\n+    public int intSum() {\n+        return v0 + v1 + v2 + v3;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/R128int.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class R128long implements Int128, ByLong {\n+\n+    public final long v0;\n+    public final long v1;\n+\n+    public R128long(long v) {\n+        this(0, v);\n+    }\n+\n+    public R128long(long hi, long lo) {\n+        this.v0 = hi;\n+        this.v1 = lo;\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return (int)loValue();\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return loValue();\n+    }\n+\n+    @Override\n+    public long hiValue() {\n+        return v0;\n+    }\n+\n+    @Override\n+    public long loValue() {\n+        return v1;\n+    }\n+\n+    @Override\n+    public long longSum() {\n+        return v0 + v1;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/R128long.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class R32byte implements Int32, ByByte {\n+\n+    public final byte v0;\n+    public final byte v1;\n+    public final byte v2;\n+    public final byte v3;\n+\n+    public R32byte(int v) {\n+        this((byte) (v >>> 24), (byte) (v >>> 16), (byte) (v >>> 8), (byte) (v));\n+    }\n+\n+    public R32byte(byte v0, byte v1, byte v2, byte v3) {\n+        this.v0 = v0;\n+        this.v1 = v1;\n+        this.v2 = v2;\n+        this.v3 = v3;\n+    }\n+\n+    private static final int MASK = 0xFF;\n+\n+    @Override\n+    public long longValue() {\n+        return (long) intValue();\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return (((v0 & MASK) << 24) | ((v1 & MASK) << 16) | ((v2 & MASK) << 8) | (v3 & MASK));\n+    }\n+\n+    @Override\n+    public Int32 neg() {\n+        return new R32byte(-intValue());\n+    }\n+\n+    @Override\n+    public Int32 add(Int32 o) {\n+        return new R32byte(intValue() + o.intValue());\n+    }\n+\n+    @Override\n+    public Int32 sub(Int32 o) {\n+        return new R32byte(intValue() - o.intValue());\n+    }\n+\n+    @Override\n+    public Int32 mult(Int32 o) {\n+        return new R32byte(intValue() * o.intValue());\n+    }\n+\n+    @Override\n+    public int compareTo(Int32 o) {\n+        return Integer.compare(intValue(), o.intValue());\n+    }\n+\n+    @Override\n+    public byte byteSum() {\n+        return (byte) (v0 + v1 + v2 + v3);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/R32byte.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class R32int implements Int32, ByInt {\n+\n+    public final int v0;\n+\n+    public R32int() {\n+        this.v0 = 0;\n+    }\n+\n+    public R32int(int val) {\n+        this.v0 = val;\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return v0;\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return v0;\n+    }\n+\n+    @Override\n+    public Int32 neg() {\n+        return new R32int(-v0);\n+    }\n+\n+    @Override\n+    public Int32 add(Int32 o) {\n+        return new R32int(v0 + o.intValue());\n+    }\n+\n+    public Int32 add(R32int o) {\n+        return new R32int(v0 + o.v0);\n+    }\n+\n+    @Override\n+    public Int32 sub(Int32 o) {\n+        return new R32int(v0 - o.intValue());\n+    }\n+\n+    public Int32 sub(R32int o) {\n+        return new R32int(v0 - o.v0);\n+    }\n+\n+    @Override\n+    public Int32 mult(Int32 o) {\n+        return new R32int(v0 * o.intValue());\n+    }\n+\n+    public Int32 mult(R32int o) {\n+        return new R32int(v0 * o.v0);\n+    }\n+\n+    @Override\n+    public int compareTo(Int32 o) {\n+        return Integer.compare(v0, o.intValue());\n+    }\n+\n+    public int compareTo(R32int o) {\n+        return Integer.compare(v0, o.v0);\n+    }\n+\n+    @Override\n+    public int intSum() {\n+        return v0;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/R32int.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class R64byte implements Int64, ByByte {\n+\n+    public final byte v0;\n+    public final byte v1;\n+    public final byte v2;\n+    public final byte v3;\n+    public final byte v4;\n+    public final byte v5;\n+    public final byte v6;\n+    public final byte v7;\n+\n+    public R64byte(long v) {\n+        this((byte) (v >>> 56), (byte) (v >>> 48), (byte) (v >>> 40), (byte) (v >>> 32), (byte) (v >>> 24), (byte) (v >>> 16), (byte) (v >>> 8), (byte) (v));\n+    }\n+\n+    public R64byte(byte v0, byte v1, byte v2, byte v3, byte v4, byte v5, byte v6, byte v7) {\n+        this.v0 = v0;\n+        this.v1 = v1;\n+        this.v2 = v2;\n+        this.v3 = v3;\n+        this.v4 = v4;\n+        this.v5 = v5;\n+        this.v6 = v6;\n+        this.v7 = v7;\n+    }\n+\n+    private static final long MASK = 0xFFL;\n+    private static final int IMASK = 0xFF;\n+\n+    @Override\n+    public long longValue() {\n+        return ((v0 & MASK) << 56) | ((v1 & MASK) << 48) | ((v2 & MASK) << 40) | ((v3 & MASK) << 32) | ((v4 & MASK) << 24) | ((v5 & MASK) << 16) | ((v6 & MASK) << 8) | (v7 & MASK);\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return ((v4 & IMASK) << 24) | ((v5 & IMASK) << 16) | ((v6 & IMASK) << 8) | (v7 & IMASK);\n+    }\n+\n+    @Override\n+    public byte byteSum() {\n+        return (byte) (v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/R64byte.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class R64int implements Int64, ByInt {\n+\n+    public final int v0;\n+    public final int v1;\n+\n+    public R64int(long v) {\n+        this((int) (v >>> 32), (int) v);\n+    }\n+\n+    public R64int(int hi, int lo) {\n+        this.v0 = hi;\n+        this.v1 = lo;\n+    }\n+\n+    private static final long MASK = 0xFFFFFFFFL;\n+\n+    @Override\n+    public long longValue() {\n+        return (v0 & MASK) << 32 | (v1 & MASK);\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return v1;\n+    }\n+\n+    @Override\n+    public int intSum() {\n+        return v0 + v1 ;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/R64int.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class R64long extends A64long  {\n+\n+    public final long v0;\n+\n+    public R64long(long v0) {\n+        this.v0 = v0;\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        return v0;\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        return (int) v0;\n+    }\n+\n+    @Override\n+    public long longSum() {\n+        return v0;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/R64long.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+public class RComplex implements Complex {\n+\n+    public final double re;\n+    public final double im;\n+\n+    public RComplex(double re, double im) {\n+        this.re =  re;\n+        this.im =  im;\n+    }\n+\n+    @Override\n+    public double re() { return re; }\n+\n+    @Override\n+    public double im() { return im; }\n+\n+    @Override\n+    public RComplex add(Complex that) {\n+        return new RComplex(this.re + that.re(), this.im + that.im());\n+    }\n+\n+    public RComplex add(RComplex that) {\n+        return new RComplex(this.re + that.re, this.im + that.im);\n+    }\n+\n+    @Override\n+    public RComplex mul(Complex that) {\n+        return new RComplex(this.re * that.re() - this.im * that.im(),\n+                           this.re * that.im() + this.im * that.re());\n+    }\n+\n+    public RComplex mul(RComplex that) {\n+        return new RComplex(this.re * that.re - this.im * that.im,\n+                           this.re * that.im + this.im * that.re);\n+    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/RComplex.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.types;\n+\n+import java.util.NoSuchElementException;\n+\n+public class ROpt<T> implements Opt<T> {\n+\n+    public T value;\n+\n+    private <T> ROpt() {\n+        this.value = null;\n+    }\n+\n+    private ROpt(T value) {\n+        this.value = value;\n+    }\n+\n+    public static <T> ROpt<T> of() {\n+        return new ROpt<>(null);\n+    }\n+\n+    public static <T> ROpt<T> of(T value) {\n+        return new ROpt<>(value);\n+    }\n+\n+    public T get() {\n+        if (value == null) {\n+            throw new NoSuchElementException(\"No value present\");\n+        }\n+        return value;\n+    }\n+\n+    public boolean isPresent() {\n+        return value != null;\n+    }\n+\n+    public boolean isEmpty() {\n+        return value == null;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/types\/ROpt.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,1 @@\n-package org.openjdk.bench.valhalla.sum;\n-\n+package org.openjdk.bench.valhalla.util;\n@@ -43,1 +42,1 @@\n-public class SumBase {\n+public class SizeBase {\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/util\/SizeBase.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sum\/SumBase.java","status":"renamed"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.valhalla.util;\n+\n+import java.util.Random;\n+\n+public class Utils {\n+\n+    public static void shuffle(int[] a, Random rnd) {\n+        for (int i = a.length; i > 1; i--) {\n+            int idx = rnd.nextInt(i);\n+            int tmp = a[i - 1];\n+            a[i - 1] = a[idx];\n+            a[idx] = tmp;\n+        }\n+\n+    }\n+\n+    public static int[] makeRandomRing(int size) {\n+        int[] A = new int[size - 1];\n+        for (int i = 0; i < A.length; i++) {\n+            A[i] = i + 1;\n+        }\n+        shuffle(A, new Random(42));\n+        int[] a = new int[size];\n+        int x = 0;\n+        for (int i = 0; i < A.length; i++) {\n+            x = a[x] = A[i];\n+        }\n+        a[x] = 0;\n+        return a;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/util\/Utils.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"}]}