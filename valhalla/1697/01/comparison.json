{"files":[{"patch":"@@ -330,2 +330,2 @@\n-      runs-on: 'macos-13'\n-      xcode-toolset-version: '14.3.1'\n+      runs-on: 'macos-15-intel'\n+      xcode-toolset-version: '16.4'\n@@ -343,2 +343,2 @@\n-      runs-on: 'macos-14'\n-      xcode-toolset-version: '15.4'\n+      runs-on: 'macos-15'\n+      xcode-toolset-version: '16.4'\n@@ -435,1 +435,1 @@\n-      runs-on: macos-14\n+      runs-on: macos-15\n@@ -437,1 +437,1 @@\n-      xcode-toolset-version: '15.4'\n+      xcode-toolset-version: '16.4'\n","filename":".github\/workflows\/main.yml","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-TOOL_BLOCKED_CERTS = $(JAVA_SMALL) -Xlog:disable -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n+TOOL_BLOCKED_CERTS = $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n","filename":"make\/ToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,0 +447,3 @@\n+  UTIL_ADD_JVM_ARG_IF_OK([-Xlog:all=off:stdout],boot_jdk_jvmargs,[$JAVA])\n+  UTIL_ADD_JVM_ARG_IF_OK([-Xlog:all=warning:stderr],boot_jdk_jvmargs,[$JAVA])\n+\n","filename":"make\/autoconf\/boot-jdk.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,5 +35,0 @@\n-#\n-# we should use this one instead of the 4260<-ff0d\n-#4260\t2212  \n-4260\tff0d\n-#\n","filename":"make\/data\/charsetmapping\/IBM930.c2b","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-#      Warning:\n-#      \"our old\" implementation seems agree with above \"new\" mappings\n-#      except the entries   4260 <-> 2212. To keep the \"compatbility\"\n-#      with the \"old\" implementation, I changed the entries \"temporarily\"\n-#      4260 <-> 2212\n-#      4260 <-  ff0d\n-#\n@@ -410,2 +403,1 @@\n-#4260\tFF0D\n-4260\t2212\n+4260\tFF0D\n","filename":"make\/data\/charsetmapping\/IBM930.map","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-os := $(shell uname -o)\n-cpu := $(shell uname -p)\n+OS := $(shell uname -o)\n+CPU := $(shell uname -m)\n@@ -64,1 +64,1 @@\n-me := $(cpu)-$(if $(findstring Linux,$(os)),linux-gnu)\n+ME := $(CPU)-$(if $(findstring Linux,$(OS)),linux-gnu)\n@@ -66,1 +66,1 @@\n-$(info Building on platform $(me))\n+$(info Building on platform $(ME))\n@@ -72,2 +72,2 @@\n-  platforms := $(me)\n-  host_platforms := $(platforms)\n+  PLATFORMS := $(ME)\n+  HOST_PLATFORMS := $(PLATFORMS)\n@@ -75,2 +75,2 @@\n-  platforms := $(subst $(COMMA), , $(TARGETS))\n-  host_platforms := $(me)\n+  PLATFORMS := $(subst $(COMMA), , $(TARGETS))\n+  HOST_PLATFORMS := $(ME)\n@@ -78,3 +78,3 @@\n-target_platforms := $(platforms)\n-$(info host_platforms $(host_platforms))\n-$(info target_platforms $(target_platforms))\n+TARGET_PLATFORMS := $(PLATFORMS)\n+$(info HOST_PLATFORMS $(HOST_PLATFORMS))\n+$(info TARGET_PLATFORMS $(TARGET_PLATFORMS))\n@@ -82,1 +82,1 @@\n-all compile : $(platforms)\n+all compile : $(PLATFORMS)\n@@ -85,1 +85,1 @@\n-  $(foreach p,$(filter-out $(me),$(platforms)),$(eval $(p) : $$(me)))\n+  $(foreach p,$(filter-out $(ME),$(PLATFORMS)),$(eval $(p) : $$(ME)))\n@@ -91,1 +91,1 @@\n-submakevars = HOST=$@ BUILD=$(me) RESULT=$(RESULT) OUTPUT_ROOT=$(OUTPUT_ROOT)\n+SUBMAKEVARS = HOST=$@ BUILD=$(ME) RESULT=$(RESULT) OUTPUT_ROOT=$(OUTPUT_ROOT)\n@@ -93,1 +93,1 @@\n-$(host_platforms) :\n+$(HOST_PLATFORMS) :\n@@ -95,3 +95,3 @@\n-\t@echo 'Targets: $(target_platforms)'\n-\tfor p in $(filter $@, $(target_platforms)) $(filter-out $@, $(target_platforms)); do \\\n-\t  $(MAKE) -f Tools.gmk download-rpms $(submakevars) \\\n+\t@echo 'Targets: $(TARGET_PLATFORMS)'\n+\tfor p in $(filter $@, $(TARGET_PLATFORMS)) $(filter-out $@, $(TARGET_PLATFORMS)); do \\\n+\t  $(MAKE) -f Tools.gmk download-rpms $(SUBMAKEVARS) \\\n@@ -99,1 +99,1 @@\n-\t  $(MAKE) -f Tools.gmk all $(submakevars) \\\n+\t  $(MAKE) -f Tools.gmk all $(SUBMAKEVARS) \\\n@@ -101,1 +101,1 @@\n-\t  $(MAKE) -f Tools.gmk ccache $(submakevars) \\\n+\t  $(MAKE) -f Tools.gmk ccache $(SUBMAKEVARS) \\\n@@ -106,1 +106,1 @@\n-today := $(shell date +%Y%m%d)\n+TODAY := $(shell date +%Y%m%d)\n@@ -109,1 +109,1 @@\n-  $(1)-to-$(2)_tar = $$(RESULT)\/sdk-$(1)-to-$(2)-$$(today).tar.gz\n+  $(1)-to-$(2)_tar = $$(RESULT)\/sdk-$(1)-to-$(2)-$$(TODAY).tar.gz\n@@ -114,1 +114,1 @@\n-$(foreach p,$(host_platforms),$(foreach t,$(target_platforms),$(eval $(call Mktar,$(p),$(t)))))\n+$(foreach p,$(HOST_PLATFORMS),$(foreach t,$(TARGET_PLATFORMS),$(eval $(call Mktar,$(p),$(t)))))\n@@ -122,1 +122,1 @@\n-\trm -rf $(addprefix ..\/..\/build\/devkit\/, result $(host_platforms))\n+\trm -rf $(addprefix ..\/..\/build\/devkit\/, result $(HOST_PLATFORMS))\n@@ -127,1 +127,1 @@\n-.PHONY : all compile tars $(configs) $(host_platforms) clean dist-clean\n+.PHONY : all compile tars $(HOST_PLATFORMS) clean dist-clean\n","filename":"make\/devkit\/Makefile","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-uppercase = $(shell echo $1 | tr a-z A-Z)\n+lowercase = $(shell echo $1 | tr A-Z a-z)\n@@ -107,3 +107,3 @@\n-gcc_ver_only := 14.2.0\n-binutils_ver_only := 2.43\n-ccache_ver_only := 4.10.2\n+GCC_VER_ONLY := 14.2.0\n+BINUTILS_VER_ONLY := 2.43\n+CCACHE_VER_ONLY := 4.10.2\n@@ -111,4 +111,4 @@\n-mpfr_ver_only := 4.2.1\n-gmp_ver_only := 6.3.0\n-mpc_ver_only := 1.3.1\n-gdb_ver_only := 15.2\n+MPFR_VER_ONLY := 4.2.1\n+GMP_VER_ONLY := 6.3.0\n+MPC_VER_ONLY := 1.3.1\n+GDB_VER_ONLY := 15.2\n@@ -116,1 +116,1 @@\n-dependencies := gcc binutils ccache mpfr gmp mpc gdb\n+DEPENDENCIES := GCC BINUTILS CCACHE MPFR GMP MPC GDB\n@@ -118,1 +118,1 @@\n-$(foreach dep,$(dependencies),$(eval $(dep)_ver := $(dep)-$($(dep)_ver_only)))\n+$(foreach dep,$(DEPENDENCIES),$(eval $(dep)_VER := $(call lowercase,$(dep)-$($(dep)_VER_ONLY))))\n@@ -120,7 +120,7 @@\n-GCC := http:\/\/ftp.gnu.org\/pub\/gnu\/gcc\/$(gcc_ver)\/$(gcc_ver).tar.xz\n-BINUTILS := http:\/\/ftp.gnu.org\/pub\/gnu\/binutils\/$(binutils_ver).tar.gz\n-CCACHE := https:\/\/github.com\/ccache\/ccache\/releases\/download\/v$(ccache_ver_only)\/$(ccache_ver).tar.xz\n-MPFR := https:\/\/www.mpfr.org\/$(mpfr_ver)\/$(mpfr_ver).tar.bz2\n-GMP := http:\/\/ftp.gnu.org\/pub\/gnu\/gmp\/$(gmp_ver).tar.bz2\n-MPC := http:\/\/ftp.gnu.org\/pub\/gnu\/mpc\/$(mpc_ver).tar.gz\n-GDB := http:\/\/ftp.gnu.org\/gnu\/gdb\/$(gdb_ver).tar.xz\n+GCC_URL := https:\/\/ftp.gnu.org\/pub\/gnu\/gcc\/$(GCC_VER)\/$(GCC_VER).tar.xz\n+BINUTILS_URL := https:\/\/ftp.gnu.org\/pub\/gnu\/binutils\/$(BINUTILS_VER).tar.gz\n+CCACHE_URL := https:\/\/github.com\/ccache\/ccache\/releases\/download\/v$(CCACHE_VER_ONLY)\/$(CCACHE_VER).tar.xz\n+MPFR_URL := https:\/\/www.mpfr.org\/$(MPFR_VER)\/$(MPFR_VER).tar.bz2\n+GMP_URL := https:\/\/ftp.gnu.org\/pub\/gnu\/gmp\/$(GMP_VER).tar.bz2\n+MPC_URL := https:\/\/ftp.gnu.org\/pub\/gnu\/mpc\/$(MPC_VER).tar.gz\n+GDB_URL := https:\/\/ftp.gnu.org\/gnu\/gdb\/$(GDB_VER).tar.xz\n@@ -183,1 +183,1 @@\n-rpms := $(SYSROOT)\/rpms_unpacked\n+RPMS := $(SYSROOT)\/rpms_unpacked\n@@ -186,1 +186,1 @@\n-libs := $(SYSROOT)\/libs_patched\n+LIBS := $(SYSROOT)\/libs_patched\n@@ -204,1 +204,1 @@\n-  $(1)_DIRNAME ?= $(basename $(basename $(notdir $($(1)))))\n+  $(1)_DIRNAME ?= $(basename $(basename $(notdir $($(1)_URL))))\n@@ -215,1 +215,1 @@\n-  $(1)_FILE = $(DOWNLOAD)\/$(notdir $($(1)))\n+  $(1)_FILE = $(DOWNLOAD)\/$(notdir $($(1)_URL))\n@@ -227,1 +227,1 @@\n-\twget -P $(DOWNLOAD) $$($(1))\n+\twget -P $(DOWNLOAD) $$($(1)_URL)\n@@ -231,1 +231,1 @@\n-$(foreach dep,$(dependencies),$(eval $(call Download,$(call uppercase,$(dep)))))\n+$(foreach dep,$(DEPENDENCIES),$(eval $(call Download,$(dep))))\n@@ -253,1 +253,1 @@\n-  $$(rpms) : $(SYSROOT)\/$(notdir $(1)).unpacked\n+  $$(RPMS) : $(SYSROOT)\/$(notdir $(1)).unpacked\n@@ -280,1 +280,1 @@\n-$(libs) : $(rpms)\n+$(LIBS) : $(RPMS)\n@@ -296,1 +296,1 @@\n-  $(SYSROOT)\/usr\/include\/ffi.h: $(rpms)\n+  $(SYSROOT)\/usr\/include\/ffi.h: $(RPMS)\n@@ -299,1 +299,1 @@\n-  $(SYSROOT)\/usr\/include\/ffitarget.h: $(rpms)\n+  $(SYSROOT)\/usr\/include\/ffitarget.h: $(RPMS)\n@@ -308,1 +308,1 @@\n-$(foreach dep,$(dependencies),$(eval $(dep) = $(TARGETDIR)\/$($(dep)_ver).done))\n+$(foreach dep,$(DEPENDENCIES),$(eval $(dep) = $(TARGETDIR)\/$($(dep)_VER).done))\n@@ -348,1 +348,1 @@\n-  $$(BUILDDIR)\/$$(binutils_ver)-$(subst \/,-,$(1))\/Makefile \\\n+  $$(BUILDDIR)\/$$(BINUTILS_VER)-$(subst \/,-,$(1))\/Makefile \\\n@@ -350,1 +350,1 @@\n-  $$(BUILDDIR)\/$$(binutils_ver)-$(subst \/,-,$(1))\/Makefile \\\n+  $$(BUILDDIR)\/$$(BINUTILS_VER)-$(subst \/,-,$(1))\/Makefile \\\n@@ -353,2 +353,2 @@\n-  bfdlib += $$(TARGETDIR)\/$$(binutils_ver)-$(subst \/,-,$(1)).done\n-  bfdmakes += $$(BUILDDIR)\/$$(binutils_ver)-$(subst \/,-,$(1))\/Makefile\n+  BFDLIB += $$(TARGETDIR)\/$$(BINUTILS_VER)-$(subst \/,-,$(1)).done\n+  BFDMAKES += $$(BUILDDIR)\/$$(BINUTILS_VER)-$(subst \/,-,$(1))\/Makefile\n@@ -361,2 +361,2 @@\n-$(bfdlib) : MAKECMD = all-libiberty all-bfd\n-$(bfdlib) : INSTALLCMD = install-libiberty install-bfd\n+$(BFDLIB) : MAKECMD = all-libiberty all-bfd\n+$(BFDLIB) : INSTALLCMD = install-libiberty install-bfd\n@@ -366,1 +366,1 @@\n-$(bfdmakes) : CONFIG = --target=$(TARGET) \\\n+$(BFDMAKES) : CONFIG = --target=$(TARGET) \\\n@@ -372,1 +372,1 @@\n-$(bfdmakes) : TOOLS = $(call declare_tools,_FOR_TARGET,$(TARGET)-) $(call declare_tools,,$(TARGET)-)\n+$(BFDMAKES) : TOOLS = $(call declare_tools,_FOR_TARGET,$(TARGET)-) $(call declare_tools,,$(TARGET)-)\n@@ -376,7 +376,7 @@\n-$(gcc) \\\n-    $(binutils) \\\n-    $(gmp) \\\n-    $(mpfr) \\\n-    $(mpc) \\\n-    $(bfdmakes) \\\n-    $(ccache) : ENVS += $(TOOLS)\n+$(GCC) \\\n+    $(BINUTILS) \\\n+    $(GMP) \\\n+    $(MPFR) \\\n+    $(MPC) \\\n+    $(BFDMAKES) \\\n+    $(CCACHE) : ENVS += $(TOOLS)\n@@ -389,1 +389,1 @@\n-$(BUILDDIR)\/$(binutils_ver)\/Makefile : CONFIG += --enable-64-bit-bfd --libdir=$(PREFIX)\/$(word 1,$(LIBDIRS))\n+$(BUILDDIR)\/$(BINUTILS_VER)\/Makefile : CONFIG += --enable-64-bit-bfd --libdir=$(PREFIX)\/$(word 1,$(LIBDIRS))\n@@ -400,2 +400,2 @@\n-$(bfdmakes) \\\n-$(BUILDDIR)\/$(binutils_ver)\/Makefile \\\n+$(BFDMAKES) \\\n+$(BUILDDIR)\/$(BINUTILS_VER)\/Makefile \\\n@@ -420,1 +420,1 @@\n-$(BUILDDIR)\/$(mpfr_ver)\/Makefile \\\n+$(BUILDDIR)\/$(MPFR_VER)\/Makefile \\\n@@ -435,1 +435,1 @@\n-$(BUILDDIR)\/$(gmp_ver)\/Makefile \\\n+$(BUILDDIR)\/$(GMP_VER)\/Makefile \\\n@@ -452,1 +452,1 @@\n-$(BUILDDIR)\/$(mpc_ver)\/Makefile \\\n+$(BUILDDIR)\/$(MPC_VER)\/Makefile \\\n@@ -471,1 +471,1 @@\n-  $(BUILDDIR)\/$(gcc_ver)\/Makefile : CONFIG += --enable-__cxa_atexit\n+  $(BUILDDIR)\/$(GCC_VER)\/Makefile : CONFIG += --enable-__cxa_atexit\n@@ -475,1 +475,1 @@\n-  $(BUILDDIR)\/$(gcc_ver)\/Makefile : CONFIG +=  --with-float=hard\n+  $(BUILDDIR)\/$(GCC_VER)\/Makefile : CONFIG +=  --with-float=hard\n@@ -490,1 +490,1 @@\n-$(BUILDDIR)\/$(gcc_ver)\/Makefile \\\n+$(BUILDDIR)\/$(GCC_VER)\/Makefile \\\n@@ -512,1 +512,1 @@\n-$(gcc) : $(binutils)\n+$(GCC) : $(BINUTILS)\n@@ -515,3 +515,3 @@\n-$(BUILDDIR)\/$(gcc_ver)\/Makefile : $(gmp) $(mpfr) $(mpc)\n-$(mpfr) : $(gmp)\n-$(mpc) : $(gmp) $(mpfr)\n+$(BUILDDIR)\/$(GCC_VER)\/Makefile : $(GMP) $(MPFR) $(MPC)\n+$(MPFR) : $(GMP)\n+$(MPC) : $(GMP) $(MPFR)\n@@ -522,1 +522,1 @@\n-  $(BUILDDIR)\/$(gdb_ver)\/Makefile: $(GDB_CFG)\n+  $(BUILDDIR)\/$(GDB_VER)\/Makefile: $(GDB_CFG)\n@@ -535,1 +535,1 @@\n-  $(gdb): $(gcc)\n+  $(GDB): $(GCC)\n@@ -537,1 +537,1 @@\n-  $(BUILDDIR)\/$(gdb_ver)\/Makefile:\n+  $(BUILDDIR)\/$(GDB_VER)\/Makefile:\n@@ -546,1 +546,1 @@\n-$(BUILDDIR)\/$(ccache_ver)\/Makefile \\\n+$(BUILDDIR)\/$(CCACHE_VER)\/Makefile \\\n@@ -557,1 +557,1 @@\n-gccpatch = $(TARGETDIR)\/gcc-patched\n+GCC_PATCHED = $(TARGETDIR)\/gcc-patched\n@@ -562,1 +562,1 @@\n-  $(gccpatch) : $(gcc) link_libs\n+  $(GCC_PATCHED) : $(GCC) link_libs\n@@ -590,1 +590,1 @@\n-  $(gccpatch) :\n+  $(GCC_PATCHED) :\n@@ -618,1 +618,1 @@\n-\techo 'DEVKIT_NAME=\"$(gcc_ver) - $(LINUX_VERSION)\"' >> $@\n+\techo 'DEVKIT_NAME=\"$(GCC_VER) - $(LINUX_VERSION)\"' >> $@\n@@ -654,2 +654,2 @@\n-  missing-links := $(addprefix $(PREFIX)\/bin\/, \\\n-      addr2line ar as c++ c++filt dwp elfedit g++ gcc gcc-$(gcc_ver_only) gprof ld ld.bfd \\\n+  MISSING_LINKS := $(addprefix $(PREFIX)\/bin\/, \\\n+      addr2line ar as c++ c++filt dwp elfedit g++ gcc gcc-$(GCC_VER_ONLY) gprof ld ld.bfd \\\n@@ -660,1 +660,1 @@\n-$(PREFIX)\/lib\/bfd-plugins\/liblto_plugin.so: $(PREFIX)\/libexec\/gcc\/$(TARGET)\/$(gcc_ver_only)\/liblto_plugin.so\n+$(PREFIX)\/lib\/bfd-plugins\/liblto_plugin.so: $(PREFIX)\/libexec\/gcc\/$(TARGET)\/$(GCC_VER_ONLY)\/liblto_plugin.so\n@@ -665,1 +665,1 @@\n-missing-links += $(PREFIX)\/lib\/bfd-plugins\/liblto_plugin.so\n+MISSING_LINKS += $(PREFIX)\/lib\/bfd-plugins\/liblto_plugin.so\n@@ -669,4 +669,4 @@\n-bfdlib : $(bfdlib)\n-binutils : $(binutils)\n-rpms : $(rpms)\n-libs : $(libs)\n+bfdlib : $(BFDLIB)\n+binutils : $(BINUTILS)\n+rpms : $(RPMS)\n+libs : $(LIBS)\n@@ -674,3 +674,3 @@\n-gcc : sysroot $(gcc) $(gccpatch)\n-gdb : $(gdb)\n-all : binutils gcc bfdlib $(PREFIX)\/devkit.info $(missing-links) $(SYSROOT_LINKS) \\\n+gcc : sysroot $(GCC) $(GCC_PATCHED)\n+gdb : $(GDB)\n+all : binutils gcc bfdlib $(PREFIX)\/devkit.info $(MISSING_LINKS) $(SYSROOT_LINKS) \\\n@@ -680,1 +680,1 @@\n-ccache : $(ccache)\n+ccache : $(CCACHE)\n","filename":"make\/devkit\/Tools.gmk","additions":76,"deletions":76,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  wget http:\/\/yum.oracle.com\/repo\/OracleLinux\/OL6\/latest\/i386\/getPackage\/m4-$M4_VERSION.el6.i686.rpm\n+  wget https:\/\/yum.oracle.com\/repo\/OracleLinux\/OL6\/latest\/i386\/getPackage\/m4-$M4_VERSION.el6.i686.rpm\n","filename":"make\/devkit\/createAutoconfBundle.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2562,4 +2562,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,7 +386,0 @@\n-\n-\/\/ JSR 292\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;  \/\/ Not needed on aarch64\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FrameMap_aarch64.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -234,2 +234,1 @@\n-      if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-          nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -460,42 +459,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On aarch64, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":44,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,2 +144,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -161,8 +159,0 @@\n- private:\n-\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n- public:\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -122,2 +122,0 @@\n-  adjust_unextended_sp();\n-\n@@ -229,1 +227,0 @@\n-  adjust_unextended_sp();\n@@ -479,1 +476,1 @@\n-    assert(sender_pc == nm->deopt_mh_handler_begin() || sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5896,32 +5896,0 @@\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  Address dst(rthread, JavaThread::held_monitor_count_offset());\n-#ifdef ASSERT\n-  ldr(tmp, dst);\n-  increment(tmp);\n-  str(tmp, dst);\n-  Label ok;\n-  tbz(tmp, 63, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#else\n-  increment(dst);\n-#endif\n-}\n-\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  Address dst(rthread, JavaThread::held_monitor_count_offset());\n-#ifdef ASSERT\n-  ldr(tmp, dst);\n-  decrement(tmp);\n-  str(tmp, dst);\n-  Label ok;\n-  tbz(tmp, 63, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#else\n-  decrement(dst);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1026,3 +1026,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-  assert(call->raw_destination() == owner(), \"destination should be empty\");\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1266,2 +1266,0 @@\n-  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n@@ -1270,1 +1268,0 @@\n-  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -1286,44 +1283,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n-    __ cbzw(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ ldr(rscratch1, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-    __ cbz(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ Save return value potentially containing the exception oop in callee-saved R19.\n-    __ mov(r19, r0);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    \/\/ Restore potential return value.\n-    __ mov(r0, r19);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n-    __ cbzw(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -225,0 +226,1 @@\n+  \/\/   N3: 0xd8e\n@@ -227,0 +229,1 @@\n+  \/\/   V3: 0xd84\n@@ -228,1 +231,2 @@\n-                          model_is(0xd40) || model_is(0xd4f))) {\n+                          model_is(0xd40) || model_is(0xd4f) ||\n+                          model_is(0xd8e) || model_is(0xd84))) {\n@@ -263,1 +267,3 @@\n-  if (_cpu == CPU_ARM && (model_is(0xd40) || model_is(0xd4f))) {\n+  \/\/   V3: 0xd84\n+  if (_cpu == CPU_ARM &&\n+      (model_is(0xd40) || model_is(0xd4f) || model_is(0xd84))) {\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1157,4 +1157,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REGP_mask();\n-}\n-\n@@ -1251,17 +1247,0 @@\n-  enc_class preserve_SP %{\n-    \/\/ preserve mark\n-    address mark = __ inst_mark();\n-    DEBUG_ONLY(int off0 = __ offset());\n-    \/\/ FP is preserved across all calls, even compiled calls.\n-    \/\/ Use it to preserve SP in places where the callee might change the SP.\n-    __ mov(Rmh_SP_save, SP);\n-    DEBUG_ONLY(int off1 = __ offset());\n-    assert(off1 - off0 == 4, \"correct size prediction\");\n-    \/\/ restore mark\n-    __ set_inst_mark(mark);\n-  %}\n-\n-  enc_class restore_SP %{\n-    __ mov(SP, Rmh_SP_save);\n-  %}\n-\n@@ -8802,1 +8781,0 @@\n-  predicate(! ((CallStaticJavaNode*)n)->is_method_handle_invoke());\n@@ -8811,14 +8789,0 @@\n-\/\/ Call Java Static Instruction (method handle version)\n-instruct CallStaticJavaHandle( method meth ) %{\n-  match(CallStaticJava);\n-  predicate(((CallStaticJavaNode*)n)->is_method_handle_invoke());\n-  effect(USE meth);\n-  \/\/ FP is saved by all callees (for interpreter stack correction).\n-  \/\/ We use it here for a similar purpose, in {preserve,restore}_FP.\n-\n-  ins_cost(CALL_COST);\n-  format %{ \"CALL,static\/MethodHandle ==> \" %}\n-  ins_encode( SetInstMark, preserve_SP, Java_Static_Call( meth ), restore_SP, call_epilog, ClearInstMark );\n-  ins_pipe(simple_call);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,2 +435,1 @@\n-  return ((far ? 3 : 1) + (_method_handle_invoke ? 1 : 0)) *\n-    NativeInstruction::instruction_size;\n+  return (far ? 3 : 1) * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -177,5 +177,0 @@\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  assert(Rmh_SP_save == FP, \"Fix register used for saving SP for MethodHandle calls\");\n-  return FP_opr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_FrameMap_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,8 +278,0 @@\n-static void restore_sp_for_method_handle(StubAssembler* sasm) {\n-  \/\/ Restore SP from its saved reg (FP) if the exception PC is a MethodHandle call site.\n-  __ ldr_s32(Rtemp, Address(Rthread, JavaThread::is_method_handle_return_offset()));\n-  __ cmp(Rtemp, 0);\n-  __ mov(SP, Rmh_SP_save, ne);\n-}\n-\n-\n@@ -342,1 +334,0 @@\n-    restore_sp_for_method_handle(sasm);\n@@ -375,3 +366,0 @@\n-  \/\/ JSR292 extension\n-  restore_sp_for_method_handle(sasm);\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -332,50 +332,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.  The unextended SP might also be the saved SP\n-\/\/ for MethodHandle call sites.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-  assert(nm->is_method_handle_return(original_pc) == is_method_handle_return, \"must be\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-void frame::adjust_unextended_sp() {\n-  \/\/ same as on x86\n-\n-  \/\/ If we are returning to a compiled MethodHandle call site, the\n-  \/\/ saved_fp will in fact be a saved value of the unextended SP.  The\n-  \/\/ simplest way to tell whether we are returning to such a call site\n-  \/\/ is as follows:\n-\n-  nmethod* sender_nm = (_cb == nullptr) ? nullptr : _cb->as_nmethod_or_null();\n-  if (sender_nm != nullptr) {\n-    \/\/ If the sender PC is a deoptimization point, get the original\n-    \/\/ PC.  For MethodHandle call site the unextended_sp is stored in\n-    \/\/ saved_fp.\n-    if (sender_nm->is_deopt_mh_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_mh_original_pc(sender_nm, _fp));\n-      _unextended_sp = _fp;\n-    }\n-    else if (sender_nm->is_deopt_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_original_pc(sender_nm, _unextended_sp));\n-    }\n-    else if (sender_nm->is_method_handle_return(_pc)) {\n-      _unextended_sp = _fp;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,0 @@\n-  void adjust_unextended_sp();\n@@ -94,8 +93,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return = false);\n-  static void verify_deopt_mh_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-    verify_deopt_original_pc(nm, unextended_sp, true);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,2 +115,0 @@\n-  adjust_unextended_sp();\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,1 +367,0 @@\n-#define Rmh_SP_save      FP \/\/ for C1\n","filename":"src\/hotspot\/cpu\/arm\/register_arm.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -267,5 +267,0 @@\n-  \/\/ Restore SP from its saved reg (FP) if the exception PC is a MethodHandle call site.\n-  __ ldr(Rtemp, Address(Rthread, JavaThread::is_method_handle_return_offset()));\n-  __ cmp(Rtemp, 0);\n-  __ mov(SP, Rmh_SP_save, ne);\n-\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -377,9 +377,0 @@\n-\n-\/\/ JSR 292\n-\/\/ On PPC64, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics, nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c1_FrameMap_ppc.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-  assert(!decode(i1, i2), \"already patched\");\n+  assert(!decode(i1, i2) || NMethodRelocation, \"already patched\");\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2476,4 +2476,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return RegMask();\n-}\n-\n@@ -3437,1 +3433,0 @@\n-    call->_method_handle_invoke = _method_handle_invoke;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1642,1 +1642,0 @@\n-  Register tmp3 = R10_ARG8;\n@@ -1658,1 +1657,0 @@\n-  __ ld(tmp3, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n@@ -1660,1 +1658,0 @@\n-  __ std(tmp3, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n@@ -1663,1 +1660,0 @@\n-  __ std(zero, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n@@ -1684,1 +1680,0 @@\n-  Register tmp3 = R10_ARG8;\n@@ -1695,51 +1690,2 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n-    __ cmpwi(CR0, R0, 0);\n-    __ beq(CR0, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ ld(R0, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n-    __ cmpdi(CR0, R0, 0);\n-    __ beq(CR0, L_skip_vthread_code);\n-\n-    \/\/ Save return value potentially containing the exception oop\n-    Register ex_oop = R15_esp;   \/\/ nonvolatile register\n-    __ mr(ex_oop, R3_RET);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    \/\/ Restore potental return value\n-    __ mr(R3_RET, ex_oop);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ li(tmp1, 0);\n-    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n-    __ cmpwi(CR0, R0, 0);\n-    __ beq(CR0, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ li(tmp1, 0);\n-    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ ld(tmp2, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n-  __ ld_ptr(tmp3, ContinuationEntry::parent_offset(), R1_SP);\n-  __ std(tmp2, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-  __ st_ptr(tmp3, JavaThread::cont_entry_offset(), R16_thread);\n+  __ ld_ptr(tmp2, ContinuationEntry::parent_offset(), R1_SP);\n+  __ st_ptr(tmp2, JavaThread::cont_entry_offset(), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":56,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -380,5 +380,0 @@\n-\/\/ JSR 292\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;  \/\/ Not needed on riscv\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_FrameMap_riscv.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1690,0 +1690,1 @@\n+  assert(!UseRVV, \"sanity\");\n@@ -1762,0 +1763,84 @@\n+void C2_MacroAssembler::arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3,\n+                                          BasicType eltype)\n+{\n+  assert(UseRVV, \"sanity\");\n+  assert(StubRoutines::riscv::arrays_hashcode_powers_of_31() != nullptr, \"sanity\");\n+  assert_different_registers(ary, cnt, result, tmp1, tmp2, tmp3, t0, t1);\n+\n+  \/\/ The MaxVectorSize should have been set by detecting RVV max vector register\n+  \/\/ size when check UseRVV (i.e. MaxVectorSize == VM_Version::_initial_vector_length).\n+  \/\/ Let's use T_INT as all hashCode calculations eventually deal with ints.\n+  const int lmul = 2;\n+  const int stride = MaxVectorSize \/ sizeof(jint) * lmul;\n+\n+  const int elsize_bytes = arrays_hashcode_elsize(eltype);\n+  const int elsize_shift = exact_log2(elsize_bytes);\n+\n+  switch (eltype) {\n+    case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode_v(unsigned byte) {\"); break;\n+    case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode_v(char) {\");          break;\n+    case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode_v(byte) {\");          break;\n+    case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode_v(short) {\");         break;\n+    case T_INT:     BLOCK_COMMENT(\"arrays_hashcode_v(int) {\");           break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  const Register pow31_highest = tmp1;\n+  const Register ary_end       = tmp2;\n+  const Register consumed      = tmp3;\n+\n+  const VectorRegister v_sum    = v2;\n+  const VectorRegister v_src    = v4;\n+  const VectorRegister v_coeffs = v6;\n+  const VectorRegister v_tmp    = v8;\n+\n+  const address adr_pows31 = StubRoutines::riscv::arrays_hashcode_powers_of_31()\n+                           + sizeof(jint);\n+  Label VEC_LOOP, DONE, SCALAR_TAIL, SCALAR_TAIL_LOOP;\n+\n+  \/\/ NB: at this point (a) 'result' already has some value,\n+  \/\/ (b) 'cnt' is not 0 or 1, see java code for details.\n+\n+  andi(t0, cnt, ~(stride - 1));\n+  beqz(t0, SCALAR_TAIL);\n+\n+  la(t1, ExternalAddress(adr_pows31));\n+  lw(pow31_highest, Address(t1, -1 * sizeof(jint)));\n+\n+  vsetvli(consumed, cnt, Assembler::e32, Assembler::m2);\n+  vle32_v(v_coeffs, t1); \/\/ 31^^(stride - 1) ... 31^^0\n+  vmv_v_x(v_sum, x0);\n+\n+  bind(VEC_LOOP);\n+  arrays_hashcode_elload_v(v_src, v_tmp, ary, eltype);\n+  vmul_vv(v_src, v_src, v_coeffs);\n+  vmadd_vx(v_sum, pow31_highest, v_src);\n+  mulw(result, result, pow31_highest);\n+  shadd(ary, consumed, ary, t0, elsize_shift);\n+  subw(cnt, cnt, consumed);\n+  andi(t1, cnt, ~(stride - 1));\n+  bnez(t1, VEC_LOOP);\n+\n+  vmv_s_x(v_tmp, x0);\n+  vredsum_vs(v_sum, v_sum, v_tmp);\n+  vmv_x_s(t0, v_sum);\n+  addw(result, result, t0);\n+  beqz(cnt, DONE);\n+\n+  bind(SCALAR_TAIL);\n+  shadd(ary_end, cnt, ary, t0, elsize_shift);\n+\n+  bind(SCALAR_TAIL_LOOP);\n+  arrays_hashcode_elload(t0, Address(ary), eltype);\n+  slli(t1, result, 5);      \/\/ optimize 31 * result\n+  subw(result, t1, result); \/\/ with result<<5 - result\n+  addw(result, result, t0);\n+  addi(ary, ary, elsize_bytes);\n+  bne(ary, ary_end, SCALAR_TAIL_LOOP);\n+\n+  bind(DONE);\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode_v\");\n+}\n+\n@@ -1764,8 +1849,8 @@\n-  case T_BOOLEAN: return sizeof(jboolean);\n-  case T_BYTE:    return sizeof(jbyte);\n-  case T_SHORT:   return sizeof(jshort);\n-  case T_CHAR:    return sizeof(jchar);\n-  case T_INT:     return sizeof(jint);\n-  default:\n-    ShouldNotReachHere();\n-    return -1;\n+    case T_BOOLEAN: return sizeof(jboolean);\n+    case T_BYTE:    return sizeof(jbyte);\n+    case T_SHORT:   return sizeof(jshort);\n+    case T_CHAR:    return sizeof(jchar);\n+    case T_INT:     return sizeof(jint);\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n@@ -1777,8 +1862,38 @@\n-  \/\/ T_BOOLEAN used as surrogate for unsigned byte\n-  case T_BOOLEAN: lbu(dst, src);   break;\n-  case T_BYTE:     lb(dst, src);   break;\n-  case T_SHORT:    lh(dst, src);   break;\n-  case T_CHAR:    lhu(dst, src);   break;\n-  case T_INT:      lw(dst, src);   break;\n-  default:\n-    ShouldNotReachHere();\n+    \/\/ T_BOOLEAN used as surrogate for unsigned byte\n+    case T_BOOLEAN: lbu(dst, src);   break;\n+    case T_BYTE:     lb(dst, src);   break;\n+    case T_SHORT:    lh(dst, src);   break;\n+    case T_CHAR:    lhu(dst, src);   break;\n+    case T_INT:      lw(dst, src);   break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload_v(VectorRegister vdst,\n+                                                 VectorRegister vtmp,\n+                                                 Register src,\n+                                                 BasicType eltype) {\n+  assert_different_registers(vdst, vtmp);\n+  switch (eltype) {\n+    case T_BOOLEAN:\n+      vle8_v(vtmp, src);\n+      vzext_vf4(vdst, vtmp);\n+      break;\n+    case T_BYTE:\n+      vle8_v(vtmp, src);\n+      vsext_vf4(vdst, vtmp);\n+      break;\n+    case T_CHAR:\n+      vle16_v(vtmp, src);\n+      vzext_vf2(vdst, vtmp);\n+      break;\n+    case T_SHORT:\n+      vle16_v(vtmp, src);\n+      vsext_vf2(vdst, vtmp);\n+      break;\n+    case T_INT:\n+      vle32_v(vdst, src);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":131,"deletions":16,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -95,2 +95,0 @@\n-\n-  \/\/ helper function for arrays_hashcode\n@@ -100,0 +98,6 @@\n+  void arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                         Register tmp1, Register tmp2, Register tmp3,\n+                         BasicType eltype);\n+  void arrays_hashcode_elload_v(VectorRegister vdst, VectorRegister vtmp,\n+                                Register src, BasicType eltype);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -220,2 +220,1 @@\n-      if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-          nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -430,43 +429,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  assert_cond(nm != nullptr);\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On riscv, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":45,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,2 +182,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -188,5 +186,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,2 +117,0 @@\n-  adjust_unextended_sp();\n-\n@@ -218,1 +216,0 @@\n-  adjust_unextended_sp();\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -228,30 +228,0 @@\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  Address dst(xthread, JavaThread::held_monitor_count_offset());\n-  ld(tmp, dst);\n-  addi(tmp, tmp, 1);\n-  sd(tmp, dst);\n-#ifdef ASSERT\n-  Label ok;\n-  test_bit(tmp, tmp, 63);\n-  beqz(tmp, ok);\n-  STOP(\"assert(held monitor count overflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#endif\n-}\n-\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  Address dst(xthread, JavaThread::held_monitor_count_offset());\n-  ld(tmp, dst);\n-  subi(tmp, tmp, 1);\n-  sd(tmp, dst);\n-#ifdef ASSERT\n-  Label ok;\n-  test_bit(tmp, tmp, 63);\n-  beqz(tmp, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -852,3 +852,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2155,4 +2155,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REG_mask();\n-}\n-\n@@ -10998,0 +10994,1 @@\n+  predicate(!UseRVV);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4083,0 +4083,22 @@\n+\/\/ fast ArraysSupport.vectorizedHashCode\n+instruct varrays_hashcode(iRegP_R11 ary, iRegI_R12 cnt, iRegI_R10 result, immI basic_type,\n+                          vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5,\n+                          vReg_V6 v6, vReg_V7 v7, vReg_V8 v8, vReg_V9 v9,\n+                          iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3,\n+                          rFlagsReg cr)\n+%{\n+  predicate(UseRVV);\n+  match(Set result (VectorizedHashCode (Binary ary cnt) (Binary result basic_type)));\n+  effect(USE_KILL ary, USE_KILL cnt, USE basic_type,\n+         TEMP v2, TEMP v3, TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v8, TEMP v9,\n+         TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary,$cnt,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode_v($ary$$Register, $cnt$$Register, $result$$Register,\n+                         $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                         (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -888,2 +888,0 @@\n-  __ ld(t0, Address(xthread, JavaThread::held_monitor_count_offset()));\n-  __ sd(t0, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n@@ -892,1 +890,0 @@\n-  __ sd(zr, Address(xthread, JavaThread::held_monitor_count_offset()));\n@@ -908,44 +905,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n-    __ beqz(t0, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ ld(t0, Address(xthread, JavaThread::jni_monitor_count_offset()));\n-    __ beqz(t0, L_skip_vthread_code);\n-\n-    \/\/ Save return value potentially containing the exception oop in callee-saved x9\n-    __ mv(x9, x10);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    \/\/ Restore potential return value\n-    __ mv(x10, x9);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n-    __ beqz(t0, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ ld(t0, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ sd(t0, Address(xthread, JavaThread::held_monitor_count_offset()));\n-\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  do_stub(compiler, arrays_hashcode_powers_of_31)                       \\\n+  do_arch_entry(riscv, compiler, arrays_hashcode_powers_of_31,          \\\n+            arrays_hashcode_powers_of_31, arrays_hashcode_powers_of_31) \\\n","filename":"src\/hotspot\/cpu\/riscv\/stubDeclarations_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6627,0 +6627,18 @@\n+  address generate_arrays_hashcode_powers_of_31() {\n+    assert(UseRVV, \"sanity\");\n+    const int lmul = 2;\n+    const int stride = MaxVectorSize \/ sizeof(jint) * lmul;\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"arrays_hashcode_powers_of_31\");\n+    address start = __ pc();\n+    for (int i = stride; i >= 0; i--) {\n+        jint power_of_31 = 1;\n+        for (int j = i; j > 0; j--) {\n+          power_of_31 = java_multiply(power_of_31, 31);\n+        }\n+        __ emit_int32(power_of_31);\n+    }\n+\n+    return start;\n+  }\n+\n@@ -6821,0 +6839,4 @@\n+    if (UseVectorizedHashCodeIntrinsic && UseRVV) {\n+      StubRoutines::riscv::_arrays_hashcode_powers_of_31 = generate_arrays_hashcode_powers_of_31();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -285,7 +285,0 @@\n-\/\/ JSR 292\n-\/\/ On ZARCH_64, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_FrameMap_s390.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1983,5 +1983,0 @@\n-\/\/ Copied from sparc.\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return RegMask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -329,7 +329,0 @@\n-\/\/ JSR 292\n-\/\/ On x86, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics, nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -225,2 +225,1 @@\n-        if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-            nm->method()->is_method_handle_intrinsic()) {\n+        if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -449,41 +448,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it) original_pc: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" name: %s\", p2i(original_pc), p2i(unextended_sp), nm->name());\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On x86, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,2 +141,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -153,7 +151,0 @@\n- private:\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n- public:\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -117,2 +117,0 @@\n-  adjust_unextended_sp();\n-\n@@ -215,1 +213,0 @@\n-  adjust_unextended_sp();\n@@ -459,1 +456,1 @@\n-    assert(sender_pc == nm->deopt_mh_handler_begin() || sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2552,8 +2552,0 @@\n-void MacroAssembler::inc_held_monitor_count() {\n-  incrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-void MacroAssembler::dec_held_monitor_count() {\n-  decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n@@ -6587,1 +6579,1 @@\n-  cmpptr(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n+  cmpptr(count, 8 << shift); \/\/ Short arrays (< 32 bytes) fill by element\n@@ -6650,1 +6642,0 @@\n-        Label L_fill_64_bytes_loop;\n@@ -6655,1 +6646,0 @@\n-        align(16);\n@@ -6657,0 +6647,25 @@\n+        \/\/ align data for 64-byte chunks\n+        Label L_fill_64_bytes_loop, L_align_64_bytes_loop;\n+        if (EnableX86ECoreOpts) {\n+            \/\/ align 'big' arrays to cache lines to minimize split_stores\n+            cmpptr(count, 96 << shift);\n+            jcc(Assembler::below, L_fill_64_bytes_loop);\n+\n+            \/\/ Find the bytes needed for alignment\n+            movptr(rtmp, to);\n+            andptr(rtmp, 0x1c);\n+            jcc(Assembler::zero, L_fill_64_bytes_loop);\n+            negptr(rtmp);           \/\/ number of bytes to fill 32-rtmp. it filled by 2 mov by 32\n+            addptr(rtmp, 32);\n+            shrptr(rtmp, 2 - shift);\/\/ get number of elements from bytes\n+            subptr(count, rtmp);    \/\/ adjust count by number of elements\n+\n+            align(16);\n+            BIND(L_align_64_bytes_loop);\n+            movdl(Address(to, 0), xtmp);\n+            addptr(to, 4);\n+            subptr(rtmp, 1 << shift);\n+            jcc(Assembler::greater, L_align_64_bytes_loop);\n+        }\n+\n+        align(16);\n@@ -6664,0 +6679,1 @@\n+        align(16);\n@@ -6708,0 +6724,1 @@\n+      align(16);\n@@ -6716,3 +6733,3 @@\n-  \/\/ fill trailing 4 bytes\n-  BIND(L_fill_4_bytes);\n-  testl(count, 1<<shift);\n+\n+  Label L_fill_4_bytes_loop;\n+  testl(count, 1 << shift);\n@@ -6720,0 +6737,3 @@\n+\n+  align(16);\n+  BIND(L_fill_4_bytes_loop);\n@@ -6721,0 +6741,6 @@\n+  addptr(to, 4);\n+\n+  BIND(L_fill_4_bytes);\n+  subptr(count, 1 << shift);\n+  jccb(Assembler::greaterEqual, L_fill_4_bytes_loop);\n+\n@@ -6723,1 +6749,0 @@\n-    addptr(to, 4);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -514,3 +514,0 @@\n-  void inc_held_monitor_count();\n-  void dec_held_monitor_count();\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1628,2 +1628,0 @@\n-  __ movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  __ movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n@@ -1632,1 +1630,0 @@\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n@@ -1656,43 +1653,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ cmpptr(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ rax may hold an exception oop, save it before the call\n-    __ push(rax);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    __ pop(rax);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1709,5 +1709,0 @@\n-\/\/ Register for saving SP into on method handle invokes. Not used on x86_64.\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-    return NO_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -668,1 +668,1 @@\n-jlong CgroupSubsystem::memory_limit_in_bytes() {\n+jlong CgroupSubsystem::memory_limit_in_bytes(julong upper_bound) {\n@@ -674,3 +674,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  log_trace(os, container)(\"total physical memory: \" JULONG_FORMAT, phys_mem);\n-  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(upper_bound);\n@@ -844,4 +842,2 @@\n-jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n-  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound);\n@@ -850,4 +846,2 @@\n-jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  julong host_swap = os::Linux::host_swap();\n-  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(upper_mem_bound, upper_swap_bound);\n@@ -856,3 +850,2 @@\n-jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes(julong upper_bound) {\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(upper_bound);\n@@ -897,3 +890,2 @@\n-void CgroupSubsystem::print_version_specific_info(outputStream* st) {\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n-  memory_controller()->controller()->print_version_specific_info(st, phys_mem);\n+void CgroupSubsystem::print_version_specific_info(outputStream* st, julong upper_mem_bound) {\n+  memory_controller()->controller()->print_version_specific_info(st, upper_mem_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -236,2 +236,2 @@\n-    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n-    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) = 0;\n@@ -243,1 +243,1 @@\n-    virtual void print_version_specific_info(outputStream* st, julong host_mem) = 0;\n+    virtual void print_version_specific_info(outputStream* st, julong upper_mem_bound) = 0;\n@@ -254,1 +254,1 @@\n-    jlong memory_limit_in_bytes();\n+    jlong memory_limit_in_bytes(julong upper_bound);\n@@ -275,3 +275,3 @@\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_and_swap_usage_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound);\n+    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound);\n+    jlong memory_soft_limit_in_bytes(julong upper_bound);\n@@ -282,1 +282,1 @@\n-    void print_version_specific_info(outputStream* st);\n+    void print_version_specific_info(outputStream* st, julong upper_mem_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-void verbose_log(julong read_mem_limit, julong host_mem) {\n+void verbose_log(julong read_mem_limit, julong upper_mem_bound) {\n@@ -142,1 +142,1 @@\n-    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+    if (mem_limit < 0 || read_mem_limit >= upper_mem_bound) {\n@@ -149,1 +149,1 @@\n-        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        assert(read_mem_limit >= upper_mem_bound, \"Expected read value exceeding upper memory bound\");\n@@ -154,2 +154,2 @@\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                               reason, mem_limit, host_mem);\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", upper bound is \" JLONG_FORMAT,\n+                               reason, mem_limit, upper_mem_bound);\n@@ -160,1 +160,1 @@\n-jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong upper_bound) {\n@@ -163,2 +163,2 @@\n-  if (memlimit >= phys_mem) {\n-    verbose_log(memlimit, phys_mem);\n+  if (memlimit >= upper_bound) {\n+    verbose_log(memlimit, upper_bound);\n@@ -167,1 +167,1 @@\n-    verbose_log(memlimit, phys_mem);\n+    verbose_log(memlimit, upper_bound);\n@@ -184,1 +184,1 @@\n-jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n+jlong CgroupV1MemoryController::read_mem_swap(julong upper_memsw_bound) {\n@@ -187,1 +187,1 @@\n-  if (memswlimit >= host_total_memsw) {\n+  if (memswlimit >= upper_memsw_bound) {\n@@ -195,2 +195,2 @@\n-jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n-  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n+  jlong memory_swap = read_mem_swap(upper_mem_bound + upper_swap_bound);\n@@ -205,1 +205,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n+    jlong memlimit = read_memory_limit_in_bytes(upper_mem_bound);\n@@ -223,3 +223,3 @@\n-jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n-  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n-  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(upper_mem_bound, upper_swap_bound);\n+  jlong memory_limit = read_memory_limit_in_bytes(upper_mem_bound);\n@@ -241,1 +241,1 @@\n-jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n@@ -244,1 +244,1 @@\n-  if (memsoftlimit >= phys_mem) {\n+  if (memsoftlimit >= upper_bound) {\n@@ -339,1 +339,1 @@\n-jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong upper_bound) {\n@@ -342,1 +342,1 @@\n-  if (kmem_limit >= phys_mem) {\n+  if (kmem_limit >= upper_bound) {\n@@ -354,1 +354,1 @@\n-void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong mem_bound) {\n@@ -356,1 +356,1 @@\n-  jlong kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n+  jlong kmem_limit = kernel_memory_limit_in_bytes(mem_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) override;\n-    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n+    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n@@ -90,1 +90,1 @@\n-    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_limit_in_bytes(julong upper_bound);\n@@ -92,1 +92,1 @@\n-    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    void print_version_specific_info(outputStream* st, julong upper_mem_bound) override;\n@@ -104,1 +104,1 @@\n-    jlong read_mem_swap(julong host_total_memsw);\n+    jlong read_mem_swap(julong upper_memsw_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong upper_bound) {\n@@ -227,2 +227,2 @@\n-jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem,\n-                                                               julong host_swap \/* unused in cg v2 *\/) {\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong upper_mem_bound,\n+                                                               julong upper_swap_bound \/* unused in cg v2 *\/) {\n@@ -235,1 +235,1 @@\n-    return read_memory_limit_in_bytes(phys_mem);\n+    return read_memory_limit_in_bytes(upper_mem_bound);\n@@ -239,1 +239,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n+    jlong memory_limit = read_memory_limit_in_bytes(upper_mem_bound);\n@@ -255,1 +255,1 @@\n-jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) {\n@@ -279,1 +279,1 @@\n-jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong upper_bound) {\n@@ -290,1 +290,1 @@\n-    if (limit < 0 || read_limit >= phys_mem) {\n+    if (limit < 0 || read_limit >= upper_bound) {\n@@ -297,1 +297,1 @@\n-        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        assert(read_limit >= upper_bound, \"Expected mem limit to exceed upper memory bound\");\n@@ -300,2 +300,2 @@\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                               reason, limit, phys_mem);\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", upper bound is \" JLONG_FORMAT,\n+                               reason, limit, upper_bound);\n@@ -330,1 +330,1 @@\n-void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong upper_mem_bound) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp) override;\n-    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_and_swap_limit_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n+    jlong memory_and_swap_usage_in_bytes(julong upper_mem_bound, julong upper_swap_bound) override;\n@@ -126,1 +126,1 @@\n-    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    void print_version_specific_info(outputStream* st, julong upper_mem_bound) override;\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-    any_mem_cpu_limit_present = cgroup_subsystem->memory_limit_in_bytes() > 0 ||\n-                                     os::Linux::active_processor_count() != cgroup_subsystem->active_processor_count();\n+    any_mem_cpu_limit_present = memory_limit_in_bytes() > 0 ||\n+                                os::Linux::active_processor_count() != active_processor_count();\n@@ -106,0 +106,17 @@\n+bool OSContainer::available_memory_in_container(julong& value) {\n+  jlong mem_limit = memory_limit_in_bytes();\n+  jlong mem_usage = memory_usage_in_bytes();\n+\n+  if (mem_limit > 0 && mem_usage <= 0) {\n+    log_debug(os, container)(\"container memory usage failed: \" JLONG_FORMAT, mem_usage);\n+  }\n+\n+  if (mem_limit <= 0 || mem_usage <= 0) {\n+    return false;\n+  }\n+\n+  value = mem_limit > mem_usage ? static_cast<julong>(mem_limit - mem_usage) : 0;\n+\n+  return true;\n+}\n+\n@@ -108,1 +125,2 @@\n-  return cgroup_subsystem->memory_limit_in_bytes();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  return cgroup_subsystem->memory_limit_in_bytes(phys_mem);\n@@ -113,1 +131,3 @@\n-  return cgroup_subsystem->memory_and_swap_limit_in_bytes();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  julong host_swap = os::Linux::host_swap();\n+  return cgroup_subsystem->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n@@ -118,1 +138,3 @@\n-  return cgroup_subsystem->memory_and_swap_usage_in_bytes();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  julong host_swap = os::Linux::host_swap();\n+  return cgroup_subsystem->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n@@ -123,1 +145,2 @@\n-  return cgroup_subsystem->memory_soft_limit_in_bytes();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  return cgroup_subsystem->memory_soft_limit_in_bytes(phys_mem);\n@@ -153,1 +176,2 @@\n-  cgroup_subsystem->print_version_specific_info(st);\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  cgroup_subsystem->print_version_specific_info(st, phys_mem);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  static bool available_memory_in_container(julong& value);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -216,11 +216,6 @@\n-julong os::Linux::available_memory_in_container() {\n-  julong avail_mem = static_cast<julong>(-1L);\n-  if (OSContainer::is_containerized()) {\n-    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n-    jlong mem_usage;\n-    if (mem_limit > 0 && (mem_usage = OSContainer::memory_usage_in_bytes()) < 1) {\n-      log_debug(os, container)(\"container memory usage failed: \" JLONG_FORMAT \", using host value\", mem_usage);\n-    }\n-    if (mem_limit > 0 && mem_usage > 0) {\n-      avail_mem = mem_limit > mem_usage ? (julong)mem_limit - (julong)mem_usage : 0;\n-    }\n+bool os::available_memory(physical_memory_size_type& value) {\n+  julong avail_mem = 0;\n+  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(avail_mem)) {\n+    log_trace(os)(\"available container memory: \" JULONG_FORMAT, avail_mem);\n+    value = static_cast<physical_memory_size_type>(avail_mem);\n+    return true;\n@@ -228,2 +223,0 @@\n-  return avail_mem;\n-}\n@@ -231,1 +224,0 @@\n-bool os::available_memory(physical_memory_size_type& value) {\n@@ -236,6 +228,1 @@\n-  julong avail_mem = available_memory_in_container();\n-  if (avail_mem != static_cast<julong>(-1L)) {\n-    log_trace(os)(\"available container memory: \" JULONG_FORMAT, avail_mem);\n-    value = static_cast<physical_memory_size_type>(avail_mem);\n-    return true;\n-  }\n+  julong avail_mem = static_cast<julong>(-1L);\n@@ -267,0 +254,7 @@\n+  julong free_mem = 0;\n+  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(free_mem)) {\n+    log_trace(os)(\"free container memory: \" JULONG_FORMAT, free_mem);\n+    value = static_cast<physical_memory_size_type>(free_mem);\n+    return true;\n+  }\n+\n@@ -273,6 +267,0 @@\n-  julong free_mem = available_memory_in_container();\n-  if (free_mem != static_cast<julong>(-1L)) {\n-    log_trace(os)(\"free container memory: \" JULONG_FORMAT, free_mem);\n-    value = static_cast<physical_memory_size_type>(free_mem);\n-    return true;\n-  }\n@@ -284,1 +272,1 @@\n-  free_mem = (julong)si.freeram * si.mem_unit;\n+  julong free_mem = (julong)si.freeram * si.mem_unit;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -624,3 +624,1 @@\n-        address deopt = nm->is_method_handle_return(pc) ?\n-          nm->deopt_mh_handler_begin() :\n-          nm->deopt_handler_begin();\n+        address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2800,3 +2800,1 @@\n-          address deopt = nm->is_method_handle_return(pc) ?\n-            nm->deopt_mh_handler_begin() :\n-            nm->deopt_handler_begin();\n+          address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-                 DeoptMH,        \/\/ Offset where MethodHandle deopt handler lives\n@@ -87,1 +86,0 @@\n-    _values[DeoptMH       ] = -1;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,8 +313,0 @@\n-  \/\/ Emit the MethodHandle deopt handler code (if required).\n-  if (has_method_handle_invokes()) {\n-    \/\/ We can use the same code as for the normal deopt handler, we\n-    \/\/ just need a different entry point address.\n-    code_offsets->set_value(CodeOffsets::DeoptMH, assembler->emit_deopt_handler());\n-    CHECK_BAILOUT();\n-  }\n-\n@@ -577,1 +569,0 @@\n-, _has_method_handle_invokes(false)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  bool               _has_method_handle_invokes;  \/\/ True if this method has MethodHandle invokes.\n@@ -185,4 +184,0 @@\n-  \/\/ JSR 292\n-  bool     has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,3 +158,0 @@\n-  \/\/ JSR 292\n-  static LIR_Opr method_handle_invoke_SP_save_opr();\n-\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,0 @@\n-  , _is_method_handle_invoke(false)\n@@ -208,1 +207,0 @@\n-  , _is_method_handle_invoke(info->_is_method_handle_invoke)\n@@ -223,1 +221,1 @@\n-  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, _is_method_handle_invoke, maybe_return_as_fields);\n+  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, maybe_return_as_fields);\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool is_method_handle_invoke = false, bool maybe_return_as_fields = false) {\n+  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool maybe_return_as_fields = false) {\n@@ -259,1 +259,1 @@\n-                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop, return_scalarized,\n+                             reexecute, rethrow_exception, return_oop, return_scalarized,\n@@ -273,1 +273,0 @@\n-  bool              _is_method_handle_invoke;    \/\/ true if the associated call site is a MethodHandle call site.\n@@ -299,3 +298,0 @@\n-  bool     is_method_handle_invoke() const { return _is_method_handle_invoke;     }\n-  void set_is_method_handle_invoke(bool x) {        _is_method_handle_invoke = x; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -747,5 +747,0 @@\n-      if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &&\n-          opJavaCall->is_method_handle_invoke()) {\n-        opJavaCall->_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();\n-        do_temp(opJavaCall->_method_handle_invoke_SP_save_opr);\n-      }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1198,1 +1198,0 @@\n-  LIR_Opr   _method_handle_invoke_SP_save_opr;  \/\/ Used in LIR_OpVisitState::visit to store the reference to FrameMap::method_handle_invoke_SP_save_opr.\n@@ -1208,1 +1207,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n@@ -1217,1 +1215,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -483,6 +483,0 @@\n-  \/\/ JSR 292\n-  \/\/ Record if this method has MethodHandle invokes.\n-  if (op->is_method_handle_invoke()) {\n-    compilation()->set_has_method_handle_invokes(true);\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3180,2 +3180,0 @@\n-  \/\/ JSR 292\n-  \/\/ Preserve the SP over MethodHandle call sites, if needed.\n@@ -3183,10 +3181,0 @@\n-  bool is_method_handle_invoke = (\/\/ %%% FIXME: Are both of these relevant?\n-                                  target->is_method_handle_intrinsic() ||\n-                                  target->is_compiled_lambda_form());\n-  if (is_method_handle_invoke) {\n-    info->set_is_method_handle_invoke(true);\n-    if(FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-        __ move(FrameMap::stack_pointer(), FrameMap::method_handle_invoke_SP_save_opr());\n-    }\n-  }\n-\n@@ -3225,7 +3213,0 @@\n-  \/\/ JSR 292\n-  \/\/ Restore the SP after MethodHandle call sites, if needed.\n-  if (is_method_handle_invoke\n-      && FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-    __ move(FrameMap::method_handle_invoke_SP_save_opr(), FrameMap::stack_pointer());\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -676,3 +676,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -757,2 +754,0 @@\n-      \/\/ Set flag if return address is a method handle call site.\n-      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -795,2 +790,0 @@\n-  \/\/ Set flag if return address is a method handle call site.\n-  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"oops\/methodCounters.hpp\"\n+#include \"oops\/methodData.hpp\"\n@@ -351,0 +353,6 @@\n+    case MetaspaceObj::MethodCountersType:\n+      log_method_counters((MethodCounters*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::MethodDataType:\n+      log_method_data((MethodData*)src, requested_addr, type_name, bytes, current);\n+      break;\n@@ -392,0 +400,12 @@\n+void AOTMapLogger::log_method_counters(MethodCounters* mc, address requested_addr, const char* type_name,\n+                                      int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  mc->method()->external_name());\n+}\n+\n+void AOTMapLogger::log_method_data(MethodData* md, address requested_addr, const char* type_name,\n+                                   int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  md->method()->external_name());\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -101,0 +101,4 @@\n+  static void log_method_counters(MethodCounters* mc, address requested_addr, const char* type_name, int bytes,\n+  Thread* current);\n+  static void log_method_data(MethodData* md, address requested_addr, const char* type_name, int bytes,\n+  Thread* current);\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4910,0 +4910,2 @@\n+        signature++;\n+        length--;\n@@ -4911,2 +4913,2 @@\n-        const char* const p = skip_over_field_name(signature + 1, true, --length);\n-\n+        const char* const p = skip_over_field_name(signature, true, length);\n+        assert(p == nullptr || p > signature, \"must parse one character at least\");\n@@ -4914,1 +4916,3 @@\n-        if (p && (p - signature) > 1 && p[0] == JVM_SIGNATURE_ENDCLASS) {\n+        if (p != nullptr                             && \/\/ Parse of field name succeeded.\n+            p - signature < static_cast<int>(length) && \/\/ There is at least one character left to parse.\n+            p[0] == JVM_SIGNATURE_ENDCLASS) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-  loader_data->add_class(ik);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -31,2 +32,2 @@\n-bool DefaultICProtectionBehaviour::lock(nmethod* method) {\n-  if (is_safe(method)) {\n+bool DefaultICProtectionBehaviour::lock(nmethod* nm) {\n+  if (is_safe(nm)) {\n@@ -39,1 +40,1 @@\n-void DefaultICProtectionBehaviour::unlock(nmethod* method) {\n+void DefaultICProtectionBehaviour::unlock(nmethod* nm) {\n@@ -43,2 +44,2 @@\n-bool DefaultICProtectionBehaviour::is_safe(nmethod* method) {\n-  return SafepointSynchronize::is_at_safepoint() || CompiledIC_lock->owned_by_self();\n+bool DefaultICProtectionBehaviour::is_safe(nmethod* nm) {\n+  return SafepointSynchronize::is_at_safepoint() || CompiledIC_lock->owned_by_self() || (NMethodState_lock->owned_by_self() && nm->is_not_installed());\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-  virtual bool lock(nmethod* method) = 0;\n-  virtual void unlock(nmethod* method) = 0;\n-  virtual bool is_safe(nmethod* method) = 0;\n+  virtual bool lock(nmethod* nm) = 0;\n+  virtual void unlock(nmethod* nm) = 0;\n+  virtual bool is_safe(nmethod* nm) = 0;\n@@ -45,3 +45,3 @@\n-  virtual bool lock(nmethod* method);\n-  virtual void unlock(nmethod* method);\n-  virtual bool is_safe(nmethod* method);\n+  virtual bool lock(nmethod* nm);\n+  virtual void unlock(nmethod* nm);\n+  virtual bool is_safe(nmethod* nm);\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -331,1 +331,0 @@\n-  friend class VMStructs;\n@@ -679,1 +678,0 @@\n-  friend class VMStructs;\n@@ -703,1 +701,0 @@\n-  friend class VMStructs;\n@@ -740,1 +737,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-  static CodeBlobType get_code_blob_type(nmethod* nm) {\n+  static CodeBlobType get_code_blob_type(const nmethod* nm) {\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-bool CompiledICLocker::is_safe(nmethod* method) {\n-  return CompiledICProtectionBehaviour::current()->is_safe(method);\n+bool CompiledICLocker::is_safe(nmethod* nm) {\n+  return CompiledICProtectionBehaviour::current()->is_safe(nm);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static bool is_safe(nmethod* method);\n+  static bool is_safe(nmethod* nm);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-                                              bool        is_method_handle_invoke,\n@@ -305,1 +304,0 @@\n-  last_pd->set_is_method_handle_invoke(is_method_handle_invoke);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,0 @@\n-                      bool        is_method_handle_invoke = false,\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  friend class VMStructs;\n@@ -71,1 +70,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -468,8 +468,0 @@\n-bool nmethod::is_method_handle_return(address return_pc) {\n-  if (!has_method_handle_invokes())  return false;\n-  PcDesc* pd = pc_desc_at(return_pc);\n-  if (pd == nullptr)\n-    return false;\n-  return pd->is_method_handle_invoke();\n-}\n-\n@@ -776,1 +768,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"clearing of IC's only allowed at safepoint\");\n+  assert(SafepointSynchronize::is_at_safepoint() || (NMethodState_lock->owned_by_self() && is_not_installed()), \"clearing of IC's only allowed at safepoint or when not installed\");\n@@ -1168,1 +1160,2 @@\n-    + align_up(debug_info->data_size()           , oopSize);\n+    + align_up(debug_info->data_size()           , oopSize)\n+    + align_up(ImmutableDataReferencesCounterSize, oopSize);\n@@ -1245,1 +1238,0 @@\n-  _has_method_handle_invokes  = 0;\n@@ -1328,1 +1320,0 @@\n-    _deopt_mh_handler_offset = 0;\n@@ -1399,0 +1390,252 @@\n+\n+nmethod::nmethod(const nmethod &nm) : CodeBlob(nm._name, nm._kind, nm._size, nm._header_size)\n+{\n+\n+  if (nm._oop_maps != nullptr) {\n+    _oop_maps                   = nm._oop_maps->clone();\n+  } else {\n+    _oop_maps                   = nullptr;\n+  }\n+\n+  _size                         = nm._size;\n+  _relocation_size              = nm._relocation_size;\n+  _content_offset               = nm._content_offset;\n+  _code_offset                  = nm._code_offset;\n+  _data_offset                  = nm._data_offset;\n+  _frame_size                   = nm._frame_size;\n+\n+  S390_ONLY( _ctable_offset     = nm._ctable_offset; )\n+\n+  _header_size                  = nm._header_size;\n+  _frame_complete_offset        = nm._frame_complete_offset;\n+\n+  _kind                         = nm._kind;\n+\n+  _caller_must_gc_arguments     = nm._caller_must_gc_arguments;\n+\n+#ifndef PRODUCT\n+  _asm_remarks.share(nm._asm_remarks);\n+  _dbg_strings.share(nm._dbg_strings);\n+#endif\n+\n+  \/\/ Allocate memory and copy mutable data to C heap\n+  _mutable_data_size            = nm._mutable_data_size;\n+  if (_mutable_data_size > 0) {\n+    _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+    if (_mutable_data == nullptr) {\n+      vm_exit_out_of_memory(_mutable_data_size, OOM_MALLOC_ERROR, \"nmethod: no space for mutable data\");\n+    }\n+    memcpy(mutable_data_begin(), nm.mutable_data_begin(), nm.mutable_data_size());\n+  } else {\n+    _mutable_data               = nullptr;\n+  }\n+\n+  _deoptimization_generation    = 0;\n+  _gc_epoch                     = CodeCache::gc_epoch();\n+  _method                       = nm._method;\n+  _osr_link                     = nullptr;\n+\n+  \/\/ Increment number of references to immutable data to share it between nmethods\n+  _immutable_data_size          = nm._immutable_data_size;\n+  if (_immutable_data_size > 0) {\n+    _immutable_data             = nm._immutable_data;\n+    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n+  } else {\n+    _immutable_data             = blob_end();\n+  }\n+\n+  _exception_cache              = nullptr;\n+  _gc_data                      = nullptr;\n+  _oops_do_mark_nmethods        = nullptr;\n+  _oops_do_mark_link            = nullptr;\n+  _compiled_ic_data             = nullptr;\n+\n+  if (nm._osr_entry_point != nullptr) {\n+    _osr_entry_point            = (nm._osr_entry_point - (address) &nm) + (address) this;\n+  } else {\n+    _osr_entry_point            = nullptr;\n+  }\n+\n+  _entry_offset                 = nm._entry_offset;\n+  _verified_entry_offset        = nm._verified_entry_offset;\n+  _entry_bci                    = nm._entry_bci;\n+\n+  _skipped_instructions_size    = nm._skipped_instructions_size;\n+  _stub_offset                  = nm._stub_offset;\n+  _exception_offset             = nm._exception_offset;\n+  _deopt_handler_offset         = nm._deopt_handler_offset;\n+  _unwind_handler_offset        = nm._unwind_handler_offset;\n+  _num_stack_arg_slots          = nm._num_stack_arg_slots;\n+  _oops_size                    = nm._oops_size;\n+#if INCLUDE_JVMCI\n+  _metadata_size                = nm._metadata_size;\n+#endif\n+  _nul_chk_table_offset         = nm._nul_chk_table_offset;\n+  _handler_table_offset         = nm._handler_table_offset;\n+  _scopes_pcs_offset            = nm._scopes_pcs_offset;\n+  _scopes_data_offset           = nm._scopes_data_offset;\n+#if INCLUDE_JVMCI\n+  _speculations_offset          = nm._speculations_offset;\n+#endif\n+\n+  _orig_pc_offset               = nm._orig_pc_offset;\n+  _compile_id                   = nm._compile_id;\n+  _comp_level                   = nm._comp_level;\n+  _compiler_type                = nm._compiler_type;\n+  _is_unloading_state           = nm._is_unloading_state;\n+  _state                        = not_installed;\n+\n+  _has_unsafe_access            = nm._has_unsafe_access;\n+  _has_wide_vectors             = nm._has_wide_vectors;\n+  _has_monitors                 = nm._has_monitors;\n+  _has_scoped_access            = nm._has_scoped_access;\n+  _has_flushed_dependencies     = nm._has_flushed_dependencies;\n+  _is_unlinked                  = nm._is_unlinked;\n+  _load_reported                = nm._load_reported;\n+\n+  _deoptimization_status        = nm._deoptimization_status;\n+\n+  if (nm._pc_desc_container != nullptr) {\n+    _pc_desc_container          = new PcDescContainer(scopes_pcs_begin());\n+  } else {\n+    _pc_desc_container          = nullptr;\n+  }\n+\n+  \/\/ Copy nmethod contents excluding header\n+  \/\/ - Constant part          (doubles, longs and floats used in nmethod)\n+  \/\/ - Code part:\n+  \/\/   - Code body\n+  \/\/   - Exception handler\n+  \/\/   - Stub code\n+  \/\/   - OOP table\n+  memcpy(consts_begin(), nm.consts_begin(), nm.data_end() - nm.consts_begin());\n+\n+  post_init();\n+}\n+\n+nmethod* nmethod::relocate(CodeBlobType code_blob_type) {\n+  assert(NMethodRelocation, \"must enable use of function\");\n+\n+  \/\/ Locks required to be held by caller to ensure the nmethod\n+  \/\/ is not modified or purged from code cache during relocation\n+  assert_lock_strong(CodeCache_lock);\n+  assert_lock_strong(Compile_lock);\n+  assert(CompiledICLocker::is_safe(this), \"mt unsafe call\");\n+\n+  if (!is_relocatable()) {\n+    return nullptr;\n+  }\n+\n+  run_nmethod_entry_barrier();\n+  nmethod* nm_copy = new (size(), code_blob_type) nmethod(*this);\n+\n+  if (nm_copy == nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Fix relocation\n+  RelocIterator iter(nm_copy);\n+  CodeBuffer src(this);\n+  CodeBuffer dst(nm_copy);\n+  while (iter.next()) {\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+    \/\/ Direct calls may no longer be in range and the use of a trampoline may now be required.\n+    \/\/ Instead, allow trampoline relocations to update their owners and perform the necessary checks.\n+    if (iter.reloc()->is_call()) {\n+      address trampoline = trampoline_stub_Relocation::get_trampoline_for(iter.reloc()->addr(), nm_copy);\n+      if (trampoline != nullptr) {\n+        continue;\n+      }\n+    }\n+#endif\n+\n+    iter.reloc()->fix_relocation_after_move(&src, &dst);\n+  }\n+\n+  \/\/ To make dependency checking during class loading fast, record\n+  \/\/ the nmethod dependencies in the classes it is dependent on.\n+  \/\/ This allows the dependency checking code to simply walk the\n+  \/\/ class hierarchy above the loaded class, checking only nmethods\n+  \/\/ which are dependent on those classes.  The slow way is to\n+  \/\/ check every nmethod for dependencies which makes it linear in\n+  \/\/ the number of methods compiled.  For applications with a lot\n+  \/\/ classes the slow way is too slow.\n+  for (Dependencies::DepStream deps(nm_copy); deps.next(); ) {\n+    if (deps.type() == Dependencies::call_site_target_value) {\n+      \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n+      oop call_site = deps.argument_oop(0);\n+      MethodHandles::add_dependent_nmethod(call_site, nm_copy);\n+    } else {\n+      InstanceKlass* ik = deps.context_type();\n+      if (ik == nullptr) {\n+        continue;  \/\/ ignore things like evol_method\n+      }\n+      \/\/ record this nmethod as dependent on this klass\n+      ik->add_dependent_nmethod(nm_copy);\n+    }\n+  }\n+\n+  MutexLocker ml_NMethodState_lock(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ Verify the nm we copied from is still valid\n+  if (!is_marked_for_deoptimization() && is_in_use()) {\n+    assert(method() != nullptr && method()->code() == this, \"should be if is in use\");\n+\n+    nm_copy->clear_inline_caches();\n+\n+    \/\/ Attempt to start using the copy\n+    if (nm_copy->make_in_use()) {\n+      ICache::invalidate_range(nm_copy->code_begin(), nm_copy->code_size());\n+\n+      methodHandle mh(Thread::current(), nm_copy->method());\n+      nm_copy->method()->set_code(mh, nm_copy);\n+\n+      make_not_used();\n+\n+      nm_copy->post_compiled_method_load_event();\n+\n+      nm_copy->log_relocated_nmethod(this);\n+\n+      return nm_copy;\n+    }\n+  }\n+\n+  nm_copy->make_not_used();\n+\n+  return nullptr;\n+}\n+\n+bool nmethod::is_relocatable() {\n+  if (!is_java_method()) {\n+    return false;\n+  }\n+\n+  if (!is_in_use()) {\n+    return false;\n+  }\n+\n+  if (is_osr_method()) {\n+    return false;\n+  }\n+\n+  if (is_marked_for_deoptimization()) {\n+    return false;\n+  }\n+\n+#if INCLUDE_JVMCI\n+  if (jvmci_nmethod_data() != nullptr && jvmci_nmethod_data()->has_mirror()) {\n+    return false;\n+  }\n+#endif\n+\n+  if (is_unloading()) {\n+    return false;\n+  }\n+\n+  if (has_evol_metadata()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -1403,0 +1646,4 @@\n+void* nmethod::operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw () {\n+  return CodeCache::allocate(nmethod_size, code_blob_type);\n+}\n+\n@@ -1476,5 +1723,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = code_offset() + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -1490,5 +1732,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = _stub_offset + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -1536,1 +1773,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset  + align_up(speculations_len, oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -1538,1 +1775,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -1571,0 +1808,1 @@\n+    set_immutable_data_references_counter(1);\n@@ -1637,0 +1875,34 @@\n+\n+void nmethod::log_relocated_nmethod(nmethod* original) const {\n+  if (LogCompilation && xtty != nullptr) {\n+    ttyLocker ttyl;\n+    xtty->begin_elem(\"relocated nmethod\");\n+    log_identity(xtty);\n+    xtty->print(\" entry='\" INTPTR_FORMAT \"' size='%d'\", p2i(code_begin()), size());\n+\n+    const char* original_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(original));\n+    xtty->print(\" original_address='\" INTPTR_FORMAT \"'\", p2i(original));\n+    xtty->print(\" original_code_heap='%s'\", original_code_heap_name);\n+\n+    const char* new_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(this));\n+    xtty->print(\" new_address='\" INTPTR_FORMAT \"'\", p2i(this));\n+    xtty->print(\" new_code_heap='%s'\", new_code_heap_name);\n+\n+    LOG_OFFSET(xtty, relocation);\n+    LOG_OFFSET(xtty, consts);\n+    LOG_OFFSET(xtty, insts);\n+    LOG_OFFSET(xtty, stub);\n+    LOG_OFFSET(xtty, scopes_data);\n+    LOG_OFFSET(xtty, scopes_pcs);\n+    LOG_OFFSET(xtty, dependencies);\n+    LOG_OFFSET(xtty, handler_table);\n+    LOG_OFFSET(xtty, nul_chk_table);\n+    LOG_OFFSET(xtty, oops);\n+    LOG_OFFSET(xtty, metadata);\n+\n+    xtty->method(method());\n+    xtty->stamp();\n+    xtty->end_elem();\n+  }\n+}\n+\n@@ -2169,1 +2441,9 @@\n-    os::free(_immutable_data);\n+    int reference_count = get_immutable_data_references_counter();\n+    assert(reference_count > 0, \"immutable data has no references\");\n+\n+    set_immutable_data_references_counter(reference_count - 1);\n+    \/\/ Free memory if this is the last nmethod referencing immutable data\n+    if (reference_count == 0) {\n+      os::free(_immutable_data);\n+    }\n+\n@@ -2172,0 +2452,1 @@\n+\n@@ -2715,9 +2996,0 @@\n-  \/\/ Search for MethodHandle invokes and tag the nmethod.\n-  for (int i = 0; i < count; i++) {\n-    if (pcs[i].is_method_handle_invoke()) {\n-      set_has_method_handle_invokes(true);\n-      break;\n-    }\n-  }\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_offset != -1), \"must have deopt mh handler\");\n-\n@@ -3736,1 +4008,0 @@\n-  if (has_method_handle_invokes() && (pos == deopt_mh_handler_begin())) label = \"[Deopt MH Handler Code]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":306,"deletions":35,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-  friend class VMStructs;\n@@ -159,0 +158,1 @@\n+\/\/  - Nmethod reference counter\n@@ -172,0 +172,2 @@\n+  #define ImmutableDataReferencesCounterSize ((int)sizeof(int))\n+\n@@ -235,3 +237,0 @@\n-  \/\/ All deoptee's at a MethodHandle call site will resume execution\n-  \/\/ at this location described by this offset.\n-  int _deopt_mh_handler_offset;\n@@ -276,1 +275,0 @@\n-          _has_method_handle_invokes:1,\/\/ Has this method MethodHandle invokes?\n@@ -343,0 +341,2 @@\n+  nmethod(const nmethod &nm);\n+\n@@ -345,0 +345,1 @@\n+  void* operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw();\n@@ -577,0 +578,6 @@\n+  \/\/ Relocate the nmethod to the code heap identified by code_blob_type.\n+  \/\/ Returns nullptr if the code heap does not have enough space, the\n+  \/\/ nmethod is unrelocatable, or the nmethod is invalidated during relocation,\n+  \/\/ otherwise the relocated nmethod. The original nmethod will be marked not entrant.\n+  nmethod* relocate(CodeBlobType code_blob_type);\n+\n@@ -593,0 +600,2 @@\n+  bool is_relocatable();\n+\n@@ -615,1 +624,0 @@\n-  address deopt_mh_handler_begin() const { return           header_begin() + _deopt_mh_handler_offset ; }\n@@ -646,1 +654,1 @@\n-  address speculations_end      () const { return            immutable_data_end(); }\n+  address speculations_end      () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -648,1 +656,1 @@\n-  address scopes_data_end       () const { return            immutable_data_end(); }\n+  address scopes_data_end       () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -651,0 +659,2 @@\n+  address immutable_data_references_counter_begin () const { return immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+\n@@ -757,3 +767,0 @@\n-  bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }\n-  void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }\n-\n@@ -840,2 +847,0 @@\n-  \/\/ MethodHandle\n-  bool is_method_handle_return(address return_pc);\n@@ -845,1 +850,0 @@\n-  inline bool is_deopt_mh_entry(address pc);\n@@ -979,0 +983,3 @@\n+  inline int  get_immutable_data_references_counter()           { return *((int*)immutable_data_references_counter_begin());  }\n+  inline void set_immutable_data_references_counter(int count)  { *((int*)immutable_data_references_counter_begin()) = count; }\n+\n@@ -1047,0 +1054,1 @@\n+  void log_relocated_nmethod(nmethod* original) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc) || is_deopt_mh_entry(pc); }\n+inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc); }\n@@ -40,4 +40,0 @@\n-inline bool nmethod::is_deopt_mh_entry(address pc) {\n-  return pc == deopt_mh_handler_begin();\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,6 +43,5 @@\n-    PCDESC_is_method_handle_invoke   = 1 << 1,\n-    PCDESC_return_oop                = 1 << 2,\n-    PCDESC_rethrow_exception         = 1 << 3,\n-    PCDESC_has_ea_local_in_scope     = 1 << 4,\n-    PCDESC_arg_escape                = 1 << 5,\n-    PCDESC_return_scalarized         = 1 << 6\n+    PCDESC_return_oop                = 1 << 1,\n+    PCDESC_rethrow_exception         = 1 << 2,\n+    PCDESC_has_ea_local_in_scope     = 1 << 3,\n+    PCDESC_arg_escape                = 1 << 4,\n+    PCDESC_return_scalarized         = 1 << 5\n@@ -89,3 +88,0 @@\n-  bool     is_method_handle_invoke()       const { return (_flags & PCDESC_is_method_handle_invoke) != 0;     }\n-  void set_is_method_handle_invoke(bool z)       { set_flag(PCDESC_is_method_handle_invoke, z); }\n-\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -409,1 +409,0 @@\n-\n@@ -414,0 +413,2 @@\n+  \/\/ We either relocate a nmethod residing in CodeCache or just generated code from CodeBuffer\n+  assert(src->blob() == nullptr || nativeCall_at(owner())->raw_destination() == owner(), \"destination should be empty\");\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/compiler\/abstractCompiler.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -866,0 +866,6 @@\n+ImmutableOopMapSet* ImmutableOopMapSet::clone() const {\n+  address buffer = NEW_C_HEAP_ARRAY(unsigned char, _size, mtCode);\n+  memcpy(buffer, (address)this, _size);\n+  return (ImmutableOopMapSet*)buffer;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -351,0 +351,2 @@\n+  ImmutableOopMapSet* clone() const;\n+\n@@ -482,1 +484,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonBarrierSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonMonitoringSupport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,3 +38,1 @@\n-class G1BlockOffsetTable: public CHeapObj<mtGC> {\n-  friend class VMStructs;\n-\n+class G1BlockOffsetTable : public CHeapObj<mtGC> {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-#include \"gc\/g1\/g1RootProcessor.hpp\"\n@@ -2672,2 +2671,1 @@\n-  uint num_workers = workers()->active_workers();\n-  G1ParallelCleaningTask unlink_task(num_workers, class_unloading_occurred);\n+  G1ParallelCleaningTask unlink_task(class_unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-    G1RootProcessor root_processor(_g1h, 1);\n+    G1RootProcessor root_processor(_g1h, false \/* is_parallel *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-G1ParallelCleaningTask::G1ParallelCleaningTask(uint num_workers,\n-                                               bool unloading_occurred) :\n+G1ParallelCleaningTask::G1ParallelCleaningTask(bool unloading_occurred) :\n@@ -57,1 +56,1 @@\n-  _code_cache_task(num_workers, unloading_occurred),\n+  _code_cache_task(unloading_occurred),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-  G1ParallelCleaningTask(uint num_workers,\n-                         bool unloading_occurred);\n+  G1ParallelCleaningTask(bool unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, uint n_workers) :\n+G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, bool is_parallel) :\n@@ -52,1 +52,3 @@\n-    _srs(n_workers) {}\n+    _nmethod_marking_scope(),\n+    _threads_claim_token_scope(),\n+    _is_parallel(is_parallel) {}\n@@ -178,2 +180,1 @@\n-    bool is_par = n_workers() > 1;\n-    Threads::possibly_parallel_oops_do(is_par,\n+    Threads::possibly_parallel_oops_do(_is_parallel,\n@@ -212,4 +213,0 @@\n-\n-uint G1RootProcessor::n_workers() const {\n-  return _srs.n_threads();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -51,1 +52,3 @@\n-  StrongRootsScope _srs;\n+  NMethodMarkingScope _nmethod_marking_scope;\n+  ThreadsClaimTokenScope _threads_claim_token_scope;\n+  bool _is_parallel;\n@@ -75,1 +78,1 @@\n-  G1RootProcessor(G1CollectedHeap* g1h, uint n_workers);\n+  G1RootProcessor(G1CollectedHeap* g1h, bool is_parallel);\n@@ -91,3 +94,0 @@\n-\n-  \/\/ Number of worker threads used by the root processor.\n-  uint n_workers() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootProcessor.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -753,1 +754,1 @@\n-    G1RootProcessor root_processor(_g1h, num_workers);\n+    G1RootProcessor root_processor(_g1h, num_workers > 1 \/* is_parallel *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -64,1 +65,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -1089,1 +1089,2 @@\n-  StrongRootsScope _strong_roots_scope; \/\/ needed for Threads::possibly_parallel_threads_do\n+  NMethodMarkingScope _nmethod_marking_scope;\n+  ThreadsClaimTokenScope _threads_claim_token_scope;\n@@ -1097,1 +1098,2 @@\n-      _strong_roots_scope(active_workers),\n+      _nmethod_marking_scope(),\n+      _threads_claim_token_scope(),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -105,2 +105,0 @@\n-  void push_depth(ScannerTask task);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,4 +53,0 @@\n-inline void PSPromotionManager::push_depth(ScannerTask task) {\n-  claimed_stack_depth()->push(task);\n-}\n-\n@@ -65,1 +61,1 @@\n-    push_depth(ScannerTask(p));\n+    claimed_stack_depth()->push(ScannerTask(p));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -253,0 +253,6 @@\n+  if (UseNUMA && !_eden_space->is_empty()) {\n+    \/\/ Eden expansion is not supported with NUMA, when eden is not empty.\n+    \/\/ See also MutableNUMASpace::initialize.\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/cSpaceCounters.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,10 @@\n+\/\/ Return true iff an access to bt is single-copy atomic.\n+\n+\/\/ The JMM requires atomicity for all accesses to fields of primitive\n+\/\/ types other than double and long. In practice, HotSpot assumes that\n+\/\/ on all processors, accesses to memory operands of wordSize and\n+\/\/ smaller are atomic.\n+static bool access_is_atomic(BasicType bt) {\n+  return type2aelembytes(bt) <= wordSize;\n+}\n+\n@@ -143,1 +153,1 @@\n-  bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+  bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(value->type());\n@@ -157,1 +167,1 @@\n-  if (is_atomic && !needs_patching) {\n+  if ((is_volatile || needs_atomic) && !needs_patching) {\n@@ -172,1 +182,1 @@\n-  bool is_atomic = is_volatile || AlwaysAtomicAccesses;\n+  bool needs_atomic = AlwaysAtomicAccesses && !access_is_atomic(result->type());\n@@ -184,1 +194,1 @@\n-  } else if (is_atomic && !needs_patching) {\n+  } else if ((is_volatile || needs_atomic) && !needs_patching) {\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectorCounters.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcPolicyCounters.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/generationCounters.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/hSpaceCounters.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-CodeCacheUnloadingTask::CodeCacheUnloadingTask(uint num_workers, bool unloading_occurred) :\n+CodeCacheUnloadingTask::CodeCacheUnloadingTask(bool unloading_occurred) :\n@@ -35,1 +35,0 @@\n-  _num_workers(num_workers),\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-  const uint                _num_workers;\n@@ -43,1 +42,1 @@\n-  CodeCacheUnloadingTask(uint num_workers, bool unloading_occurred);\n+  CodeCacheUnloadingTask(bool unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,15 +37,0 @@\n-\n-StrongRootsScope::StrongRootsScope(uint n_threads) : _n_threads(n_threads) {\n-  \/\/ No need for thread claim for statically-known sequential case (_n_threads == 0)\n-  \/\/ For positive values, clients of this class often unify sequential\/parallel\n-  \/\/ cases, so they expect the thread claim token to be updated.\n-  if (_n_threads != 0) {\n-    Threads::change_thread_claim_token();\n-  }\n-}\n-\n-StrongRootsScope::~StrongRootsScope() {\n-  if (_n_threads != 0) {\n-    Threads::assert_all_threads_claimed();\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/strongRootsScope.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,13 +36,0 @@\n-\/\/ Sets up and tears down the required state for sequential\/parallel root processing.\n-class StrongRootsScope : public MarkScope {\n-  \/\/ Number of threads participating in the roots processing.\n-  \/\/ 0 means statically-known sequential root processing; used only by Serial GC\n-  const uint _n_threads;\n-\n- public:\n-  StrongRootsScope(uint n_threads);\n-  ~StrongRootsScope();\n-\n-  uint n_threads() const { return _n_threads; }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/strongRootsScope.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-  _degen_point(ShenandoahGC::_degenerated_outside_cycle) {\n+  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n+  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahGCRequest_lock\", true) {\n@@ -231,1 +232,3 @@\n-    os::naked_short_sleep(sleep);\n+\n+    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+    ml.wait(sleep);\n@@ -346,0 +349,10 @@\n+void ShenandoahControlThread::notify_control_thread(GCCause::Cause cause) {\n+  \/\/ Although setting gc request is under _controller_lock, the read side (run_service())\n+  \/\/ does not take the lock. We need to enforce following order, so that read side sees\n+  \/\/ latest requested gc cause when the flag is set.\n+  MonitorLocker controller(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _requested_gc_cause = cause;\n+  _gc_requested.set();\n+  controller.notify();\n+}\n+\n@@ -357,2 +370,1 @@\n-    _requested_gc_cause = cause;\n-    _gc_requested.set();\n+    notify_control_thread(cause);\n@@ -375,6 +387,1 @@\n-    \/\/ Although setting gc request is under _gc_waiters_lock, but read side (run_service())\n-    \/\/ does not take the lock. We need to enforce following order, so that read side sees\n-    \/\/ latest requested gc cause when the flag is set.\n-    _requested_gc_cause = cause;\n-    _gc_requested.set();\n-\n+    notify_control_thread(cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-  friend class VMStructs;\n-\n@@ -50,0 +48,3 @@\n+  \/\/ This lock is used to coordinate waking up the control thread\n+  Monitor _control_lock;\n+\n@@ -59,0 +60,2 @@\n+  \/\/ Sets the requested cause and flag and notifies the control thread\n+  void notify_control_thread(GCCause::Cause cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2262,2 +2262,1 @@\n-      uint num_workers = _workers->active_workers();\n-      ShenandoahClassUnloadingTask unlink_task(phase, num_workers, unloading_occurred);\n+      ShenandoahClassUnloadingTask unlink_task(phase, unloading_occurred);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-                                                           uint num_workers,\n@@ -39,1 +38,1 @@\n-  _code_cache_task(num_workers, unloading_occurred),\n+  _code_cache_task(unloading_occurred),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-                               uint num_workers,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n+#include \"code\/nmethod.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -43,0 +43,2 @@\n+  NMethodMarkingScope _nmethod_marking_scope;\n+  ThreadsClaimTokenScope _threads_claim_token_scope;\n@@ -51,1 +53,3 @@\n-  _mark(mark) {\n+  _mark(mark),\n+  _nmethod_marking_scope(),\n+  _threads_claim_token_scope() {\n@@ -101,1 +105,0 @@\n-    StrongRootsScope scope(nworkers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading()) {\n+    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading() || (NMethodState_lock->owned_by_self() && nm->is_not_installed())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading()) {\n+    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading() || (NMethodState_lock->owned_by_self() && nm->is_not_installed())) {\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-friend class VMStructs;\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-#include <stdlib.h> \/\/ for environment variables\n-\n@@ -84,4 +82,1 @@\n-  \/\/ environment information\n-  void generate_environment_variables_events();\n-\n-   \/\/ system processes information\n+  \/\/ system processes information\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -233,2 +233,1 @@\n-  DEBUG_ONLY(volatile bool _out_of_stack_walking_enabled;)\n-  DEBUG_ONLY(volatile u8 _out_of_stack_walking_iterations;)\n+  DEBUG_ONLY(volatile bool _out_of_stack_walking_enabled = true;)\n@@ -286,4 +285,0 @@\n-\n-  u8 out_of_stack_walking_iterations() const {\n-    return AtomicAccess::load(&_out_of_stack_walking_iterations);\n-  }\n@@ -397,1 +392,0 @@\n-        DEBUG_ONLY(AtomicAccess::inc(&_out_of_stack_walking_iterations);)\n@@ -591,1 +585,1 @@\n-void JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n+bool JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n@@ -594,0 +588,3 @@\n+    return true;\n+  } else {\n+    return false;\n@@ -596,7 +593,0 @@\n-\n-u8 JfrCPUTimeThreadSampling::out_of_stack_walking_iterations() {\n-  if (_instance != nullptr && _instance->_sampler != nullptr) {\n-    return _instance->_sampler->out_of_stack_walking_iterations();\n-  }\n-  return 0;\n-}\n@@ -875,1 +865,1 @@\n-static void set_out_of_stack_walking_enabled(bool runnable) {\n+bool JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n@@ -877,0 +867,1 @@\n+  return false;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -142,3 +142,1 @@\n-  DEBUG_ONLY(static void set_out_of_stack_walking_enabled(bool runnable);)\n-\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n+  DEBUG_ONLY(static bool set_out_of_stack_walking_enabled(bool runnable);)\n@@ -165,2 +163,1 @@\n-  DEBUG_ONLY(static void set_out_of_stack_walking_enabled(bool runnable));\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n+  DEBUG_ONLY(static bool set_out_of_stack_walking_enabled(bool runnable));\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1144,1 +1144,1 @@\n-void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n+void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool return_oop, JVMCI_TRAPS) {\n@@ -1188,1 +1188,1 @@\n-      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n+      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, return_oop,\n@@ -1246,6 +1246,0 @@\n-      vmIntrinsics::ID iid = method->intrinsic_id();\n-      bool is_mh_invoke = false;\n-      if (direct_call) {\n-        is_mh_invoke = !method->is_static() && (iid == vmIntrinsics::_compiledLambdaForm ||\n-                (MethodHandles::is_signature_polymorphic(iid) && MethodHandles::is_signature_polymorphic_intrinsic(iid)));\n-      }\n@@ -1253,1 +1247,1 @@\n-      record_scope(next_pc_offset, stream, flags, true, is_mh_invoke, return_oop, JVMCI_CHECK);\n+      record_scope(next_pc_offset, stream, flags, true, return_oop, JVMCI_CHECK);\n@@ -1345,3 +1339,0 @@\n-    case DEOPT_MH_HANDLER_ENTRY:\n-      _offsets.set_value(CodeOffsets::DeoptMH, pc_offset);\n-      break;\n@@ -1375,0 +1366,1 @@\n+    case DEOPT_MH_HANDLER_ENTRY:\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -414,1 +414,1 @@\n-  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS);\n+  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool return_oop, JVMCI_TRAPS);\n@@ -417,1 +417,1 @@\n-    record_scope(pc_offset, stream, debug_info_flags, full_info, false \/* is_mh_invoke *\/, false \/* return_oop *\/, JVMCIENV);\n+    record_scope(pc_offset, stream, debug_info_flags, full_info, false \/* return_oop *\/, JVMCIENV);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -231,3 +231,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -308,2 +305,0 @@\n-      \/\/ Set flag if return address is a method handle call site.\n-      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -346,3 +341,0 @@\n-  \/\/ Set flag if return address is a method handle call site.\n-  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -140,0 +140,5 @@\n+  \/\/ Returns true if this nmethod has a mirror\n+  bool has_mirror() const {\n+    return _nmethod_mirror_index != -1;\n+  }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -245,1 +245,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n@@ -259,1 +258,0 @@\n-  nonstatic_field(JavaThread,                  _held_monitor_count,                           intx)                                  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,4 +120,0 @@\n-  if (c != nullptr) {\n-    ASAN_UNPOISON_MEMORY_REGION(c->base(), c->word_size() * BytesPerWord);\n-  }\n-\n@@ -246,3 +242,0 @@\n-  \/\/ It is valid to poison the chunk payload area at this point since its physically separated from\n-  \/\/ the chunk meta info.\n-  ASAN_POISON_MEMORY_REGION(c->base(), c->word_size() * BytesPerWord);\n@@ -306,3 +299,0 @@\n-  if (enlarged) {\n-    ASAN_UNPOISON_MEMORY_REGION(c->base() + old_word_size, (c->word_size() - old_word_size) * BytesPerWord);\n-  }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -116,0 +116,2 @@\n+  ASAN_UNPOISON_MEMORY_REGION((char*)p, word_size * BytesPerWord);\n+\n@@ -196,0 +198,2 @@\n+  ASAN_POISON_MEMORY_REGION((char*)p, word_size * BytesPerWord);\n+\n@@ -241,4 +245,0 @@\n-  \/\/ Poison the memory region. It will be unpoisoned later on a per-chunk base for chunks that are\n-  \/\/ handed to arenas.\n-  ASAN_POISON_MEMORY_REGION(rs.base(), rs.size());\n-\n@@ -293,4 +293,0 @@\n-  \/\/ Undo the poisoning before potentially unmapping memory. This ensures that future mappings at\n-  \/\/ the same address do not unexpectedly fail with use-after-poison.\n-  ASAN_UNPOISON_MEMORY_REGION(_rs.base(), _rs.size());\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/memory\/metaspaceCounters.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -861,4 +861,0 @@\n-\n-    \/\/ Add to class loader list first before creating the mirror\n-    \/\/ (same order as class file parsing)\n-    loader_data->add_class(this);\n@@ -866,0 +862,3 @@\n+  \/\/ Add to class loader list first before creating the mirror\n+  \/\/ (same order as class file parsing)\n+  loader_data->add_class(this);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/classLoaderData.hpp\"\n@@ -315,1 +314,0 @@\n-  InstanceKlass* compiling_klass = method->method_holder();\n@@ -344,7 +342,1 @@\n-  ClassLoaderData* loader_data = nullptr;\n-  if (_holder != nullptr) {\n-    loader_data = _holder->class_loader_data();\n-  } else {\n-    loader_data = java_lang_ClassLoader::loader_data(SystemDictionary::java_system_loader()); \/\/ default CLD\n-  }\n-  _comp_deps.prepare(loader_data);\n+  _comp_deps.prepare();\n@@ -378,3 +370,2 @@\n-  ClassLoaderData* loader_data = _method->klass()->class_loader_data();\n-  _init_deps.prepare(loader_data);\n-  _ci_records.prepare(loader_data);\n+  _init_deps.prepare();\n+  _ci_records.prepare();\n@@ -772,1 +763,1 @@\n-void TrainingData::DepList<T>::prepare(ClassLoaderData* loader_data) {\n+void TrainingData::DepList<T>::prepare() {\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"classfile\/classLoaderData.hpp\"\n@@ -405,1 +404,1 @@\n-    void prepare(ClassLoaderData* loader_data);\n+    void prepare();\n@@ -482,4 +481,0 @@\n-  ClassLoaderData* class_loader_data() {\n-    assert(has_holder(), \"\");\n-    return holder()->class_loader_data();\n-  }\n@@ -623,2 +618,2 @@\n-      void prepare(ClassLoaderData* loader_data) {\n-        _data.prepare(loader_data);\n+      void prepare() {\n+        _data.prepare();\n@@ -642,2 +637,2 @@\n-    void prepare(ClassLoaderData* loader_data) {\n-      ciMethod__inline_instructions_size.prepare(loader_data);\n+    void prepare() {\n+      ciMethod__inline_instructions_size.prepare();\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -184,4 +184,0 @@\n-    if (method()->is_method_handle_intrinsic() ||\n-        method()->is_compiled_lambda_form()) {\n-      call->set_method_handle_invoke(true);\n-    }\n@@ -501,0 +497,4 @@\n+  virtual ciMethod* callee_method() {\n+    return _callee;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  virtual ciMethod* callee_method() { ShouldNotReachHere(); }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1406,14 +1406,15 @@\n-      \/\/ Recover symbolic info for method resolution.\n-      ciMethod* caller = jvms()->method();\n-      ciBytecodeStream iter(caller);\n-      iter.force_bci(jvms()->bci());\n-\n-      bool             not_used1;\n-      ciSignature*     not_used2;\n-      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-      ciKlass*         holder       = iter.get_declared_method_holder();\n-      if (orig_callee->is_method_handle_intrinsic()) {\n-        assert(_override_symbolic_info, \"required\");\n-        orig_callee = method();\n-        holder = method()->holder();\n-      }\n+      if (cg->callee_method() == nullptr) {\n+        \/\/ Recover symbolic info for method resolution.\n+        ciMethod* caller = jvms()->method();\n+        ciBytecodeStream iter(caller);\n+        iter.force_bci(jvms()->bci());\n+\n+        bool             not_used1;\n+        ciSignature*     not_used2;\n+        ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+        ciKlass*         holder       = iter.get_declared_method_holder();\n+        if (orig_callee->is_method_handle_intrinsic()) {\n+          assert(_override_symbolic_info, \"required\");\n+          orig_callee = method();\n+          holder = method()->holder();\n+        }\n@@ -1421,1 +1422,1 @@\n-      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+        ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1423,2 +1424,2 @@\n-      Node* receiver_node = in(TypeFunc::Parms);\n-      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+        Node* receiver_node = in(TypeFunc::Parms);\n+        const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1426,5 +1427,9 @@\n-      int  not_used3;\n-      bool call_does_dispatch;\n-      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                         call_does_dispatch, not_used3);  \/\/ out-parameters\n-      if (!call_does_dispatch) {\n+        int  not_used3;\n+        bool call_does_dispatch;\n+        ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                           call_does_dispatch, not_used3);  \/\/ out-parameters\n+        if (!call_does_dispatch) {\n+          cg->set_callee_method(callee);\n+        }\n+      }\n+      if (cg->callee_method() != nullptr) {\n@@ -1432,1 +1437,0 @@\n-        cg->set_callee_method(callee);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -800,1 +800,0 @@\n-  bool    _method_handle_invoke;\n@@ -808,1 +807,0 @@\n-      _method_handle_invoke(false),\n@@ -820,2 +818,0 @@\n-  void  set_method_handle_invoke(bool f)   { _method_handle_invoke = f; }\n-  bool  is_method_handle_invoke() const    { return _method_handle_invoke; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -672,1 +672,0 @@\n-      _has_method_handle_invokes(false),\n@@ -958,1 +957,0 @@\n-      _has_method_handle_invokes(false),\n@@ -2610,0 +2608,6 @@\n+      if (should_stress_inlining()) {\n+        \/\/ randomly add repeated inline attempt if stress-inlining\n+        cg->call_node()->set_generator(cg);\n+        C->igvn_worklist()->push(cg->call_node());\n+        continue;\n+      }\n@@ -5962,0 +5966,155 @@\n+\n+#ifndef PRODUCT\n+\/\/ Collects all the control inputs from nodes on the worklist and from their data dependencies\n+static void find_candidate_control_inputs(Unique_Node_List& worklist, Unique_Node_List& candidates) {\n+  \/\/ Follow non-control edges until we reach CFG nodes\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    const Node* n = worklist.at(i);\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in == nullptr || in->is_Root()) {\n+        continue;\n+      }\n+      if (in->is_CFG()) {\n+        if (in->is_Call()) {\n+          \/\/ The return value of a call is only available if the call did not result in an exception\n+          Node* control_proj_use = in->as_Call()->proj_out(TypeFunc::Control)->unique_out();\n+          if (control_proj_use->is_Catch()) {\n+            Node* fall_through = control_proj_use->as_Catch()->proj_out(CatchProjNode::fall_through_index);\n+            candidates.push(fall_through);\n+            continue;\n+          }\n+        }\n+\n+        if (in->is_Multi()) {\n+          \/\/ We got here by following data inputs so we should only have one control use\n+          \/\/ (no IfNode, etc)\n+          assert(!n->is_MultiBranch(), \"unexpected node type: %s\", n->Name());\n+          candidates.push(in->as_Multi()->proj_out(TypeFunc::Control));\n+        } else {\n+          candidates.push(in);\n+        }\n+      } else {\n+        worklist.push(in);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Returns the candidate node that is a descendant to all the other candidates\n+static Node* pick_control(Unique_Node_List& candidates) {\n+  Unique_Node_List worklist;\n+  worklist.copy(candidates);\n+\n+  \/\/ Traverse backwards through the CFG\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    const Node* n = worklist.at(i);\n+    if (n->is_Root()) {\n+      continue;\n+    }\n+    for (uint j = 0; j < n->req(); j++) {\n+      \/\/ Skip backedge of loops to avoid cycles\n+      if (n->is_Loop() && j == LoopNode::LoopBackControl) {\n+        continue;\n+      }\n+\n+      Node* pred = n->in(j);\n+      if (pred != nullptr && pred != n && pred->is_CFG()) {\n+        worklist.push(pred);\n+        \/\/ if pred is an ancestor of n, then pred is an ancestor to at least one candidate\n+        candidates.remove(pred);\n+      }\n+    }\n+  }\n+\n+  assert(candidates.size() == 1, \"unexpected control flow\");\n+  return candidates.at(0);\n+}\n+\n+\/\/ Initialize a parameter input for a debug print call, using a placeholder for jlong and jdouble\n+static void debug_print_init_parm(Node* call, Node* parm, Node* half, int* pos) {\n+  call->init_req((*pos)++, parm);\n+  const BasicType bt = parm->bottom_type()->basic_type();\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    call->init_req((*pos)++, half);\n+  }\n+}\n+\n+Node* Compile::make_debug_print_call(const char* str, address call_addr, PhaseGVN* gvn,\n+                              Node* parm0, Node* parm1,\n+                              Node* parm2, Node* parm3,\n+                              Node* parm4, Node* parm5,\n+                              Node* parm6) const {\n+  Node* str_node = gvn->transform(new ConPNode(TypeRawPtr::make(((address) str))));\n+  const TypeFunc* type = OptoRuntime::debug_print_Type(parm0, parm1, parm2, parm3, parm4, parm5, parm6);\n+  Node* call = new CallLeafNode(type, call_addr, \"debug_print\", TypeRawPtr::BOTTOM);\n+\n+  \/\/ find the most suitable control input\n+  Unique_Node_List worklist, candidates;\n+  if (parm0 != nullptr) { worklist.push(parm0);\n+  if (parm1 != nullptr) { worklist.push(parm1);\n+  if (parm2 != nullptr) { worklist.push(parm2);\n+  if (parm3 != nullptr) { worklist.push(parm3);\n+  if (parm4 != nullptr) { worklist.push(parm4);\n+  if (parm5 != nullptr) { worklist.push(parm5);\n+  if (parm6 != nullptr) { worklist.push(parm6);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+  find_candidate_control_inputs(worklist, candidates);\n+  Node* control = nullptr;\n+  if (candidates.size() == 0) {\n+    control = C->start()->proj_out(TypeFunc::Control);\n+  } else {\n+    control = pick_control(candidates);\n+  }\n+\n+  \/\/ find all the previous users of the control we picked\n+  GrowableArray<Node*> users_of_control;\n+  for (DUIterator_Fast kmax, i = control->fast_outs(kmax); i < kmax; i++) {\n+    Node* use = control->fast_out(i);\n+    if (use->is_CFG() && use != control) {\n+      users_of_control.push(use);\n+    }\n+  }\n+\n+  \/\/ we do not actually care about IO and memory as it uses neither\n+  call->init_req(TypeFunc::Control,   control);\n+  call->init_req(TypeFunc::I_O,       top());\n+  call->init_req(TypeFunc::Memory,    top());\n+  call->init_req(TypeFunc::FramePtr,  C->start()->proj_out(TypeFunc::FramePtr));\n+  call->init_req(TypeFunc::ReturnAdr, top());\n+\n+  int pos = TypeFunc::Parms;\n+  call->init_req(pos++, str_node);\n+  if (parm0 != nullptr) { debug_print_init_parm(call, parm0, top(), &pos);\n+  if (parm1 != nullptr) { debug_print_init_parm(call, parm1, top(), &pos);\n+  if (parm2 != nullptr) { debug_print_init_parm(call, parm2, top(), &pos);\n+  if (parm3 != nullptr) { debug_print_init_parm(call, parm3, top(), &pos);\n+  if (parm4 != nullptr) { debug_print_init_parm(call, parm4, top(), &pos);\n+  if (parm5 != nullptr) { debug_print_init_parm(call, parm5, top(), &pos);\n+  if (parm6 != nullptr) { debug_print_init_parm(call, parm6, top(), &pos);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n+\n+  call = gvn->transform(call);\n+  Node* call_control_proj = gvn->transform(new ProjNode(call, TypeFunc::Control));\n+\n+  \/\/ rewire previous users to have the new call as control instead\n+  PhaseIterGVN* igvn = gvn->is_IterGVN();\n+  for (int i = 0; i < users_of_control.length(); i++) {\n+    Node* use = users_of_control.at(i);\n+    for (uint j = 0; j < use->req(); j++) {\n+      if (use->in(j) == control) {\n+        if (igvn != nullptr) {\n+          igvn->replace_input_of(use, j, call_control_proj);\n+        } else {\n+          gvn->hash_delete(use);\n+          use->set_req(j, call_control_proj);\n+          gvn->hash_insert(use);\n+        }\n+      }\n+    }\n+  }\n+\n+  return call;\n+}\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":161,"deletions":2,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -361,2 +361,0 @@\n-  \/\/ JSR 292\n-  bool                  _has_method_handle_invokes; \/\/ True if this method has MethodHandle invokes.\n@@ -690,4 +688,0 @@\n-  \/\/ JSR 292\n-  bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n@@ -1142,1 +1136,2 @@\n-  bool should_delay_inlining() { return AlwaysIncrementalInline || (StressIncrementalInlining && (random() % 2) == 0); }\n+  bool should_stress_inlining() { return StressIncrementalInlining && (random() % 2) == 0; }\n+  bool should_delay_inlining() { return AlwaysIncrementalInline || should_stress_inlining(); }\n@@ -1365,0 +1360,22 @@\n+\n+#ifndef PRODUCT\n+private:\n+  \/\/ getting rid of the template makes things easier\n+  Node* make_debug_print_call(const char* str, address call_addr, PhaseGVN* gvn,\n+                              Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                              Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                              Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                              Node* parm6 = nullptr) const;\n+\n+public:\n+  \/\/ Creates a CallLeafNode for a runtime call that prints a static string and the values of the\n+  \/\/ nodes passed as arguments.\n+  \/\/ This function also takes care of doing the necessary wiring, including finding a suitable control\n+  \/\/ based on the nodes that need to be printed. Note that passing nodes that have incompatible controls\n+  \/\/ is undefined behavior.\n+  template <typename... TT, typename... NN>\n+  Node* make_debug_print(const char* str, PhaseGVN* gvn, NN... in) {\n+    address call_addr = CAST_FROM_FN_PTR(address, SharedRuntime::debug_print<TT...>);\n+    return make_debug_print_call(str, call_addr, gvn, in...);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-        break;\n+        \/\/ If MemBarStoreStore has a precedent edge add it to the worklist (like MemBarRelease)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -976,11 +976,0 @@\n-\n-  \/\/ If the call is a MethodHandle invoke, we need to exclude the\n-  \/\/ register which is used to save the SP value over MH invokes from\n-  \/\/ the mask.  Otherwise this register could be used for\n-  \/\/ deoptimization information.\n-  if (op == Op_CallStaticJava) {\n-    MachCallStaticJavaNode* mcallstaticjava = (MachCallStaticJavaNode*) mcall;\n-    if (mcallstaticjava->_method_handle_invoke)\n-      proj->_rout.OR(Matcher::method_handle_invoke_SP_save_mask());\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1671,0 +1671,24 @@\n+Node* PhaseIdealLoop::find_last_store_in_outer_loop(Node* store, const IdealLoopTree* outer_loop) {\n+  assert(store != nullptr && store->is_Store(), \"starting point should be a store node\");\n+  \/\/ Follow the memory uses until we get out of the loop.\n+  \/\/ Store nodes in the outer loop body were moved by PhaseIdealLoop::try_move_store_after_loop.\n+  \/\/ Because of the conditions in try_move_store_after_loop (no other usage in the loop body\n+  \/\/ except for the phi node associated with the loop head), we have the guarantee of a\n+  \/\/ linear memory subgraph within the outer loop body.\n+  Node* last = store;\n+  Node* unique_next = store;\n+  do {\n+    last = unique_next;\n+    for (DUIterator_Fast imax, l = last->fast_outs(imax); l < imax; l++) {\n+      Node* use = last->fast_out(l);\n+      if (use->is_Store() && use->in(MemNode::Memory) == last) {\n+        if (is_member(outer_loop, get_ctrl(use))) {\n+          assert(unique_next == last, \"memory node should only have one usage in the loop body\");\n+          unique_next = use;\n+        }\n+      }\n+    }\n+  } while (last != unique_next);\n+  return last;\n+}\n+\n@@ -1761,0 +1785,20 @@\n+  \/\/ Store nodes that were moved to the outer loop by PhaseIdealLoop::try_move_store_after_loop\n+  \/\/ do not have an associated Phi node. Such nodes are attached to the false projection of the CountedLoopEnd node,\n+  \/\/ right after the execution of the inner CountedLoop.\n+  \/\/ We have to make sure that such stores in the post loop have the right memory inputs from the main loop\n+  \/\/ The moved store node is always attached right after the inner loop exit, and just before the safepoint\n+  const Node* if_false = main_end->proj_out(false);\n+  for (DUIterator j = if_false->outs(); if_false->has_out(j); j++) {\n+    Node* store = if_false->out(j);\n+    if (store->is_Store()) {\n+      \/\/ We only make changes if the memory input of the store is outside the outer loop body,\n+      \/\/ as this is when we would normally expect a Phi as input. If the memory input\n+      \/\/ is in the loop body as well, then we can safely assume it is still correct as the entire\n+      \/\/ body was cloned as a unit\n+      if (!is_member(outer_loop, get_ctrl(store->in(MemNode::Memory)))) {\n+        Node* mem_out = find_last_store_in_outer_loop(store, outer_loop);\n+        Node* store_new = old_new[store->_idx];\n+        store_new->set_req(MemNode::Memory, mem_out);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1387,0 +1387,3 @@\n+  \/\/ Find the last store in the body of an OuterStripMinedLoop when following memory uses\n+  Node *find_last_store_in_outer_loop(Node* store, const IdealLoopTree* outer_loop);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -803,2 +803,0 @@\n-  if (_method_handle_invoke)\n-    st->print(\"MethodHandle \");\n@@ -825,4 +823,1 @@\n-  \/\/ If this call is a MethodHandle invoke we have to use a different\n-  \/\/ debugmask which does not include the register we use to save the\n-  \/\/ SP over MH invokes.\n-  RegMask** debugmask = _method_handle_invoke ? m->idealreg2mhdebugmask : m->idealreg2debugmask;\n+  RegMask** debugmask = m->idealreg2debugmask;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1000,1 +1000,0 @@\n-  bool      _method_handle_invoke;   \/\/ Tells if the call has to preserve SP\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-RegMask Matcher::mh_caller_save_regmask;\n-RegMask Matcher::mh_caller_save_regmask_exclude_soe;\n@@ -117,15 +115,0 @@\n-  idealreg2mhdebugmask[Op_RegI] = nullptr;\n-  idealreg2mhdebugmask[Op_RegN] = nullptr;\n-  idealreg2mhdebugmask[Op_RegL] = nullptr;\n-  idealreg2mhdebugmask[Op_RegF] = nullptr;\n-  idealreg2mhdebugmask[Op_RegD] = nullptr;\n-  idealreg2mhdebugmask[Op_RegP] = nullptr;\n-  idealreg2mhdebugmask[Op_VecA] = nullptr;\n-  idealreg2mhdebugmask[Op_VecS] = nullptr;\n-  idealreg2mhdebugmask[Op_VecD] = nullptr;\n-  idealreg2mhdebugmask[Op_VecX] = nullptr;\n-  idealreg2mhdebugmask[Op_VecY] = nullptr;\n-  idealreg2mhdebugmask[Op_VecZ] = nullptr;\n-  idealreg2mhdebugmask[Op_RegFlags] = nullptr;\n-  idealreg2mhdebugmask[Op_RegVectMask] = nullptr;\n-\n@@ -501,1 +484,1 @@\n-#define NOF_STACK_MASKS (3*13)\n+#define NOF_STACK_MASKS (2*13)\n@@ -516,45 +499,6 @@\n-  idealreg2spillmask  [Op_RegN] = &rms[0];\n-  idealreg2spillmask  [Op_RegI] = &rms[1];\n-  idealreg2spillmask  [Op_RegL] = &rms[2];\n-  idealreg2spillmask  [Op_RegF] = &rms[3];\n-  idealreg2spillmask  [Op_RegD] = &rms[4];\n-  idealreg2spillmask  [Op_RegP] = &rms[5];\n-\n-  idealreg2debugmask  [Op_RegN] = &rms[6];\n-  idealreg2debugmask  [Op_RegI] = &rms[7];\n-  idealreg2debugmask  [Op_RegL] = &rms[8];\n-  idealreg2debugmask  [Op_RegF] = &rms[9];\n-  idealreg2debugmask  [Op_RegD] = &rms[10];\n-  idealreg2debugmask  [Op_RegP] = &rms[11];\n-\n-  idealreg2mhdebugmask[Op_RegN] = &rms[12];\n-  idealreg2mhdebugmask[Op_RegI] = &rms[13];\n-  idealreg2mhdebugmask[Op_RegL] = &rms[14];\n-  idealreg2mhdebugmask[Op_RegF] = &rms[15];\n-  idealreg2mhdebugmask[Op_RegD] = &rms[16];\n-  idealreg2mhdebugmask[Op_RegP] = &rms[17];\n-\n-  idealreg2spillmask  [Op_VecA] = &rms[18];\n-  idealreg2spillmask  [Op_VecS] = &rms[19];\n-  idealreg2spillmask  [Op_VecD] = &rms[20];\n-  idealreg2spillmask  [Op_VecX] = &rms[21];\n-  idealreg2spillmask  [Op_VecY] = &rms[22];\n-  idealreg2spillmask  [Op_VecZ] = &rms[23];\n-\n-  idealreg2debugmask  [Op_VecA] = &rms[24];\n-  idealreg2debugmask  [Op_VecS] = &rms[25];\n-  idealreg2debugmask  [Op_VecD] = &rms[26];\n-  idealreg2debugmask  [Op_VecX] = &rms[27];\n-  idealreg2debugmask  [Op_VecY] = &rms[28];\n-  idealreg2debugmask  [Op_VecZ] = &rms[29];\n-\n-  idealreg2mhdebugmask[Op_VecA] = &rms[30];\n-  idealreg2mhdebugmask[Op_VecS] = &rms[31];\n-  idealreg2mhdebugmask[Op_VecD] = &rms[32];\n-  idealreg2mhdebugmask[Op_VecX] = &rms[33];\n-  idealreg2mhdebugmask[Op_VecY] = &rms[34];\n-  idealreg2mhdebugmask[Op_VecZ] = &rms[35];\n-\n-  idealreg2spillmask  [Op_RegVectMask] = &rms[36];\n-  idealreg2debugmask  [Op_RegVectMask] = &rms[37];\n-  idealreg2mhdebugmask[Op_RegVectMask] = &rms[38];\n+  int index = 0;\n+  for (int i = Op_RegN; i <= Op_RegVectMask; ++i) {\n+    idealreg2spillmask[i] = &rms[index++];\n+    idealreg2debugmask[i] = &rms[index++];\n+  }\n+  assert(index == NOF_STACK_MASKS, \"wrong size\");\n@@ -747,15 +691,0 @@\n-  *idealreg2mhdebugmask[Op_RegN] = *idealreg2spillmask[Op_RegN];\n-  *idealreg2mhdebugmask[Op_RegI] = *idealreg2spillmask[Op_RegI];\n-  *idealreg2mhdebugmask[Op_RegL] = *idealreg2spillmask[Op_RegL];\n-  *idealreg2mhdebugmask[Op_RegF] = *idealreg2spillmask[Op_RegF];\n-  *idealreg2mhdebugmask[Op_RegD] = *idealreg2spillmask[Op_RegD];\n-  *idealreg2mhdebugmask[Op_RegP] = *idealreg2spillmask[Op_RegP];\n-  *idealreg2mhdebugmask[Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n-\n-  *idealreg2mhdebugmask[Op_VecA] = *idealreg2spillmask[Op_VecA];\n-  *idealreg2mhdebugmask[Op_VecS] = *idealreg2spillmask[Op_VecS];\n-  *idealreg2mhdebugmask[Op_VecD] = *idealreg2spillmask[Op_VecD];\n-  *idealreg2mhdebugmask[Op_VecX] = *idealreg2spillmask[Op_VecX];\n-  *idealreg2mhdebugmask[Op_VecY] = *idealreg2spillmask[Op_VecY];\n-  *idealreg2mhdebugmask[Op_VecZ] = *idealreg2spillmask[Op_VecZ];\n-\n@@ -766,1 +695,0 @@\n-  RegMask* mh_caller_save_mask = exclude_soe ? &mh_caller_save_regmask_exclude_soe : &mh_caller_save_regmask;\n@@ -782,15 +710,0 @@\n-\n-  idealreg2mhdebugmask[Op_RegN]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegI]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegL]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegF]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegP]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegVectMask]->SUBTRACT(*mh_caller_save_mask);\n-\n-  idealreg2mhdebugmask[Op_VecA]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecS]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecX]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecY]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecZ]->SUBTRACT(*mh_caller_save_mask);\n@@ -1020,1 +933,0 @@\n-      mh_caller_save_regmask.Insert(i);\n@@ -1027,1 +939,0 @@\n-      mh_caller_save_regmask_exclude_soe.Insert(i);\n@@ -1031,6 +942,0 @@\n-  \/\/ Also exclude the register we use to save the SP for MethodHandle\n-  \/\/ invokes to from the corresponding MH debug masks\n-  const RegMask sp_save_mask = method_handle_invoke_SP_save_mask();\n-  mh_caller_save_regmask.OR(sp_save_mask);\n-  mh_caller_save_regmask_exclude_soe.OR(sp_save_mask);\n-\n@@ -1312,1 +1217,0 @@\n-  bool             is_method_handle_invoke = false;  \/\/ for special kill effects\n@@ -1338,2 +1242,0 @@\n-      is_method_handle_invoke = call_java->is_method_handle_invoke();\n-      mcall_java->_method_handle_invoke = is_method_handle_invoke;\n@@ -1342,3 +1244,0 @@\n-      if (is_method_handle_invoke) {\n-        C->set_has_method_handle_invokes(true);\n-      }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":108,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-  friend class VMStructs;\n-\n@@ -182,1 +180,0 @@\n-  RegMask *idealreg2mhdebugmask[_last_machine_leaf];\n@@ -190,2 +187,0 @@\n-  static RegMask mh_caller_save_regmask;\n-  static RegMask mh_caller_save_regmask_exclude_soe;\n@@ -431,2 +426,0 @@\n-  static const RegMask method_handle_invoke_SP_save_mask();\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4456,4 +4456,1 @@\n-  if (outcnt() != 2) {\n-    assert(Opcode() == Op_Initialize, \"Only seen when there are no use of init memory\");\n-    assert(outcnt() == 1, \"Only control then\");\n-  }\n+  assert(outcnt() > 0 && outcnt() <= 2, \"Only one or two out edges allowed\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1069,1 +1069,0 @@\n-  bool is_method_handle_invoke = false;\n@@ -1082,1 +1081,0 @@\n-    \/\/ Is the call a MethodHandle call?\n@@ -1084,4 +1082,0 @@\n-      if (mcall->as_MachCallJava()->_method_handle_invoke) {\n-        assert(C->has_method_handle_invokes(), \"must have been set during call generation\");\n-        is_method_handle_invoke = true;\n-      }\n@@ -1287,1 +1281,0 @@\n-      is_method_handle_invoke,\n@@ -1466,3 +1459,0 @@\n-  if (C->has_method_handle_invokes())\n-    total_req += deopt_handler_req;  \/\/ deopt MH handler\n-\n@@ -1903,7 +1893,0 @@\n-\n-    \/\/ Emit the MethodHandle deopt handler code (if required).\n-    if (C->has_method_handle_invokes() && !C->failing()) {\n-      \/\/ We can use the same code as for the normal deopt handler, we\n-      \/\/ just need a different entry point address.\n-      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(masm));\n-    }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,4 +92,3 @@\n-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, after Apply Memop Reordering\") \\\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, after Adjusting Pre-loop Limit\") \\\n-  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, after Adding Speculative Runtime Checks\") \\\n-  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, after Apply\") \\\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 2, after Adjusting Pre-loop Limit\") \\\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 3, after Adding Speculative Runtime Checks\") \\\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 4, after Apply\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1836,0 +1836,56 @@\n+#ifndef PRODUCT\n+static void debug_print_convert_type(const Type** fields, int* argp, Node *parm) {\n+  const BasicType bt = parm->bottom_type()->basic_type();\n+  fields[(*argp)++] = Type::get_const_basic_type(bt);\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    fields[(*argp)++] = Type::HALF;\n+  }\n+}\n+\n+static void update_arg_cnt(const Node* parm, int* arg_cnt) {\n+  (*arg_cnt)++;\n+  const BasicType bt = parm->bottom_type()->basic_type();\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    (*arg_cnt)++;\n+  }\n+}\n+\n+const TypeFunc* OptoRuntime::debug_print_Type(Node* parm0, Node* parm1,\n+                                        Node* parm2, Node* parm3,\n+                                        Node* parm4, Node* parm5,\n+                                        Node* parm6) {\n+  int argcnt = 1;\n+  if (parm0 != nullptr) { update_arg_cnt(parm0, &argcnt);\n+  if (parm1 != nullptr) { update_arg_cnt(parm1, &argcnt);\n+  if (parm2 != nullptr) { update_arg_cnt(parm2, &argcnt);\n+  if (parm3 != nullptr) { update_arg_cnt(parm3, &argcnt);\n+  if (parm4 != nullptr) { update_arg_cnt(parm4, &argcnt);\n+  if (parm5 != nullptr) { update_arg_cnt(parm5, &argcnt);\n+  if (parm6 != nullptr) { update_arg_cnt(parm6, &argcnt);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+\n+  \/\/ create input type (domain)\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ static string pointer\n+\n+  if (parm0 != nullptr) { debug_print_convert_type(fields, &argp, parm0);\n+  if (parm1 != nullptr) { debug_print_convert_type(fields, &argp, parm1);\n+  if (parm2 != nullptr) { debug_print_convert_type(fields, &argp, parm2);\n+  if (parm3 != nullptr) { debug_print_convert_type(fields, &argp, parm3);\n+  if (parm4 != nullptr) { debug_print_convert_type(fields, &argp, parm4);\n+  if (parm5 != nullptr) { debug_print_convert_type(fields, &argp, parm5);\n+  if (parm6 != nullptr) { debug_print_convert_type(fields, &argp, parm6);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -1969,3 +2025,0 @@\n-\n-    \/\/ Check if the exception PC is a MethodHandle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":56,"deletions":3,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -752,0 +752,10 @@\n+#ifndef PRODUCT\n+  \/\/ Signature for runtime calls in debug printing nodes, which depends on which nodes are actually passed\n+  \/\/ Note: we do not allow more than 7 node arguments as GraphKit::make_runtime_call only allows 8, and we need\n+  \/\/ one for the static string\n+  static const TypeFunc* debug_print_Type(Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                                          Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                                          Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                                          Node* parm6 = nullptr);\n+#endif \/\/ PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,0 +56,5 @@\n+  static constexpr uint STACKED_CONCAT_UPPER_BOUND = 256; \/\/ argument limit for a merged concat.\n+                                                          \/\/ The value 256 was derived by measuring\n+                                                          \/\/ compilation time on variable length sequences\n+                                                          \/\/ of stackable concatenations and chosen to keep\n+                                                          \/\/ a safe margin to any critical point.\n@@ -298,0 +303,2 @@\n+\n+  uint arguments_appended = 0;\n@@ -306,0 +313,1 @@\n+      arguments_appended += other->num_arguments();\n@@ -308,0 +316,12 @@\n+      arguments_appended++;\n+    }\n+    \/\/ Check if this concatenation would result in an excessive number of arguments\n+    \/\/ -- leading to high memory use, compilation time, and later, a large number of IR nodes\n+    \/\/ -- and bail out in that case.\n+    if (arguments_appended > STACKED_CONCAT_UPPER_BOUND) {\n+#ifndef PRODUCT\n+      if (PrintOptimizeStringConcat) {\n+        tty->print_cr(\"Merge candidate of length %d exceeds argument limit\", arguments_appended);\n+      }\n+#endif\n+      return nullptr;\n@@ -683,1 +703,1 @@\n-            if (merged->validate_control_flow() && merged->validate_mem_flow()) {\n+            if (merged != nullptr && merged->validate_control_flow() && merged->validate_mem_flow()) {\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  _mem_ref_for_main_loop_alignment(nullptr),\n+  _vpointer_for_main_loop_alignment(nullptr),\n@@ -458,1 +458,2 @@\n-\/\/ 9) Reorder the memory slices to co-locate members of the memory packs.\n+\/\/ 9) The packs are split and filtered, to ensure correctness and that\n+\/\/    all packs have corresponding vector nodes implemented in the backend.\n@@ -460,3 +461,7 @@\n-\/\/ 10) Generate ideal vector nodes for the final set of packs and where necessary,\n-\/\/    inserting scalar promotion, vector creation from multiple scalars, and\n-\/\/    extraction of scalar values from vectors.\n+\/\/ 10) VTransform (see vtransform.hpp)\n+\/\/     - construct from PackSet\n+\/\/     - schedule (detect circles)\n+\/\/     - apply\n+\/\/       - align main loop\n+\/\/       - add runtime checks (aliasing and alignment)\n+\/\/       - build new loop with vector C2 nodes\n@@ -501,1 +506,1 @@\n-  return schedule_and_apply();\n+  return do_vtransform();\n@@ -663,31 +668,0 @@\n-void VLoopMemorySlices::find_memory_slices() {\n-  assert(_heads.is_empty(), \"not yet computed\");\n-  assert(_tails.is_empty(), \"not yet computed\");\n-  CountedLoopNode* cl = _vloop.cl();\n-\n-  \/\/ Iterate over all memory phis\n-  for (DUIterator_Fast imax, i = cl->fast_outs(imax); i < imax; i++) {\n-    PhiNode* phi = cl->fast_out(i)->isa_Phi();\n-    if (phi != nullptr && _vloop.in_bb(phi) && phi->is_memory_phi()) {\n-      Node* phi_tail = phi->in(LoopNode::LoopBackControl);\n-      if (phi_tail != phi->in(LoopNode::EntryControl)) {\n-        _heads.push(phi);\n-        _tails.push(phi_tail->as_Mem());\n-      }\n-    }\n-  }\n-\n-  NOT_PRODUCT( if (_vloop.is_trace_memory_slices()) { print(); } )\n-}\n-\n-#ifndef PRODUCT\n-void VLoopMemorySlices::print() const {\n-  tty->print_cr(\"\\nVLoopMemorySlices::print: %s\",\n-                heads().length() > 0 ? \"\" : \"NONE\");\n-  for (int m = 0; m < heads().length(); m++) {\n-    tty->print(\"%6d \", m);  heads().at(m)->dump();\n-    tty->print(\"       \");  tails().at(m)->dump();\n-  }\n-}\n-#endif\n-\n@@ -696,0 +670,1 @@\n+  assert(head != nullptr && tail != nullptr, \"must be slice with memory state loop\");\n@@ -1579,1 +1554,1 @@\n-    _mem_ref_for_main_loop_alignment = mem;\n+    _vpointer_for_main_loop_alignment = &vpointer(mem);\n@@ -1949,1 +1924,3 @@\n-bool SuperWord::schedule_and_apply() const {\n+\/\/ Build VTransform from SuperWord Packset, and eventually apply it (create new vectorized C2 loop).\n+\/\/ See description at top of \"vtransform.hpp\".\n+bool SuperWord::do_vtransform() const {\n@@ -1962,1 +1939,1 @@\n-                        _mem_ref_for_main_loop_alignment,\n+                        _vpointer_for_main_loop_alignment,\n@@ -1991,0 +1968,1 @@\n+\/\/ See description at top of \"vtransform.hpp\".\n@@ -2005,3 +1983,0 @@\n-  _graph.apply_memops_reordering_with_schedule();\n-  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl());\n-\n@@ -2019,92 +1994,0 @@\n-\/\/ We prepare the memory graph for the replacement of scalar memops with vector memops.\n-\/\/ We reorder all slices in parallel, ensuring that the memops inside each slice are\n-\/\/ ordered according to the _schedule. This means that all packed memops are consecutive\n-\/\/ in the memory graph after the reordering.\n-void VTransformGraph::apply_memops_reordering_with_schedule() const {\n-#ifndef PRODUCT\n-  assert(is_scheduled(), \"must be already scheduled\");\n-  if (_trace._info) {\n-    print_memops_schedule();\n-  }\n-#endif\n-\n-  ResourceMark rm;\n-  int max_slices = phase()->C->num_alias_types();\n-  \/\/ When iterating over the schedule, we keep track of the current memory state,\n-  \/\/ which is the Phi or a store in the loop.\n-  GrowableArray<Node*> current_state_in_slice(max_slices, max_slices, nullptr);\n-  \/\/ The memory state after the loop is the last store inside the loop. If we reorder the\n-  \/\/ loop we may have a different last store, and we need to adjust the uses accordingly.\n-  GrowableArray<Node*> old_last_store_in_slice(max_slices, max_slices, nullptr);\n-\n-  const GrowableArray<PhiNode*>& mem_slice_head = _vloop_analyzer.memory_slices().heads();\n-\n-  \/\/ (1) Set up the initial memory state from Phi. And find the old last store.\n-  for (int i = 0; i < mem_slice_head.length(); i++) {\n-    Node* phi  = mem_slice_head.at(i);\n-    assert(phi->is_Phi(), \"must be phi\");\n-    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n-    current_state_in_slice.at_put(alias_idx, phi);\n-\n-    \/\/ If we have a memory phi, we have a last store in the loop, find it over backedge.\n-    StoreNode* last_store = phi->in(2)->as_Store();\n-    old_last_store_in_slice.at_put(alias_idx, last_store);\n-  }\n-\n-  \/\/ (2) Walk over schedule, append memops to the current state\n-  \/\/     of that slice. If it is a Store, we take it as the new state.\n-  for_each_memop_in_schedule([&] (MemNode* n) {\n-    assert(n->is_Load() || n->is_Store(), \"only loads or stores\");\n-    int alias_idx = phase()->C->get_alias_index(n->adr_type());\n-    Node* current_state = current_state_in_slice.at(alias_idx);\n-    if (current_state == nullptr) {\n-      \/\/ If there are only loads in a slice, we never update the memory\n-      \/\/ state in the loop, hence there is no phi for the memory state.\n-      \/\/ We just keep the old memory state that was outside the loop.\n-      assert(n->is_Load() && !in_bb(n->in(MemNode::Memory)),\n-             \"only loads can have memory state from outside loop\");\n-    } else {\n-      igvn().replace_input_of(n, MemNode::Memory, current_state);\n-      if (n->is_Store()) {\n-        current_state_in_slice.at_put(alias_idx, n);\n-      }\n-    }\n-  });\n-\n-  \/\/ (3) For each slice, we add the current state to the backedge\n-  \/\/     in the Phi. Further, we replace uses of the old last store\n-  \/\/     with uses of the new last store (current_state).\n-  GrowableArray<Node*> uses_after_loop;\n-  for (int i = 0; i < mem_slice_head.length(); i++) {\n-    Node* phi  = mem_slice_head.at(i);\n-    int alias_idx = phase()->C->get_alias_index(phi->adr_type());\n-    Node* current_state = current_state_in_slice.at(alias_idx);\n-    assert(current_state != nullptr, \"slice is mapped\");\n-    assert(current_state != phi, \"did some work in between\");\n-    assert(current_state->is_Store(), \"sanity\");\n-    igvn().replace_input_of(phi, 2, current_state);\n-\n-    \/\/ Replace uses of old last store with current_state (new last store)\n-    \/\/ Do it in two loops: first find all the uses, and change the graph\n-    \/\/ in as second loop so that we do not break the iterator.\n-    Node* last_store = old_last_store_in_slice.at(alias_idx);\n-    assert(last_store != nullptr, \"we have a old last store\");\n-    uses_after_loop.clear();\n-    for (DUIterator_Fast kmax, k = last_store->fast_outs(kmax); k < kmax; k++) {\n-      Node* use = last_store->fast_out(k);\n-      if (!in_bb(use)) {\n-        uses_after_loop.push(use);\n-      }\n-    }\n-    for (int k = 0; k < uses_after_loop.length(); k++) {\n-      Node* use = uses_after_loop.at(k);\n-      for (uint j = 0; j < use->req(); j++) {\n-        Node* def = use->in(j);\n-        if (def == last_store) {\n-          igvn().replace_input_of(use, j, current_state);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n@@ -2115,0 +1998,1 @@\n+  \/\/ Apply: transform the node and connect with inputs (no backedges).\n@@ -2124,0 +2008,10 @@\n+\n+  \/\/ Cleanup: connect backedges\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+    vtn->apply_backedge(apply_state);\n+  }\n+\n+  \/\/ Memory uses after the loop: used to connect to old last store,\n+  \/\/ now need to connect to new last store.\n+  apply_state.fix_memory_state_uses_after_loop();\n@@ -2777,1 +2671,1 @@\n-LoadNode::ControlDependency VTransformLoadVectorNode::control_dependency() const {\n+LoadNode::ControlDependency SuperWordVTransformBuilder::load_control_dependency(const Node_List* pack) const {\n@@ -2779,2 +2673,2 @@\n-  for (int i = 0; i < nodes().length(); i++) {\n-    Node* n = nodes().at(i);\n+  for (uint i = 0; i < pack->size(); i++) {\n+    Node* n = pack->at(i);\n@@ -2798,3 +2692,3 @@\n-void VTransform::determine_mem_ref_and_aw_for_main_loop_alignment() {\n-  if (_mem_ref_for_main_loop_alignment != nullptr) {\n-    assert(VLoop::vectors_should_be_aligned(), \"mem_ref only set if filtered for alignment\");\n+void VTransform::determine_vpointer_and_aw_for_main_loop_alignment() {\n+  if (_vpointer_for_main_loop_alignment != nullptr) {\n+    assert(VLoop::vectors_should_be_aligned(), \"vpointer_for_main_loop_alignment only set if filtered for alignment\");\n@@ -2804,1 +2698,1 @@\n-  MemNode const* mem_ref = nullptr;\n+  VPointer const* vpointer = nullptr;\n@@ -2806,0 +2700,1 @@\n+  bool vpointer_is_load = false;\n@@ -2811,1 +2706,0 @@\n-    MemNode* p0 = vtn->nodes().at(0)->as_Mem();\n@@ -2813,1 +2707,3 @@\n-    int vw = p0->memory_size() * vtn->nodes().length();\n+    int vw = vtn->vpointer().size();\n+    bool vtn_is_load = vtn->is_load_in_loop();\n+\n@@ -2823,2 +2719,2 @@\n-    bool prefer_store = mem_ref != nullptr && SuperWordAutomaticAlignment == 1 && mem_ref->is_Load() && p0->is_Store();\n-    bool prefer_load  = mem_ref != nullptr && SuperWordAutomaticAlignment == 2 && mem_ref->is_Store() && p0->is_Load();\n+    bool prefer_store = SuperWordAutomaticAlignment == 1 &&  vpointer_is_load && !vtn_is_load;\n+    bool prefer_load  = SuperWordAutomaticAlignment == 2 && !vpointer_is_load &&  vtn_is_load;\n@@ -2826,0 +2722,1 @@\n+      vpointer = &vtn->vpointer();\n@@ -2827,1 +2724,1 @@\n-      mem_ref = p0;\n+      vpointer_is_load = vtn_is_load;\n@@ -2830,2 +2727,2 @@\n-  assert(mem_ref != nullptr && max_aw > 0, \"found mem_ref and aw\");\n-  _mem_ref_for_main_loop_alignment = mem_ref;\n+  assert(vpointer != nullptr && max_aw > 0, \"found vpointer and aw\");\n+  _vpointer_for_main_loop_alignment = vpointer;\n@@ -2845,1 +2742,1 @@\n-\/\/ the address of \"_mem_ref_for_main_loop_alignment\" to \"_aw_for_main_loop_alignment\", which is a\n+\/\/ the address of \"_vpointer_for_main_loop_alignment\" to \"_aw_for_main_loop_alignment\", which is a\n@@ -2849,3 +2746,7 @@\n-  determine_mem_ref_and_aw_for_main_loop_alignment();\n-  const MemNode* align_to_ref = _mem_ref_for_main_loop_alignment;\n-  const int aw                = _aw_for_main_loop_alignment;\n+  determine_vpointer_and_aw_for_main_loop_alignment();\n+\n+  assert(cl()->is_main_loop(), \"can only do alignment for main loop\");\n+  assert(_vpointer_for_main_loop_alignment != nullptr &&\n+         _vpointer_for_main_loop_alignment->is_valid() &&\n+         _aw_for_main_loop_alignment > 0,\n+         \"must have alignment reference and aw\");\n@@ -2862,2 +2763,2 @@\n-  assert(align_to_ref != nullptr && aw > 0, \"must have alignment reference and aw\");\n-  assert(cl()->is_main_loop(), \"can only do alignment for main loop\");\n+  const VPointer& p = *_vpointer_for_main_loop_alignment;\n+  const int aw      = _aw_for_main_loop_alignment;\n@@ -2878,4 +2779,1 @@\n-  const VPointer& p = vpointer(align_to_ref);\n-  assert(p.is_valid(), \"sanity\");\n-\n-  \/\/ For the main-loop, we want the address of align_to_ref to be memory aligned\n+  \/\/ For the main-loop, we want the address of vpointer p to be memory aligned\n@@ -3016,3 +2914,1 @@\n-    tty->print(\"  align_to_ref:\");\n-    align_to_ref->dump();\n-    tty->print(\"  \");\n+    tty->print(\"  vpointer_for_main_loop_alignment\");\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":58,"deletions":162,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ VPointer, and the alignment width (aw) for which we align the main-loop,\n@@ -415,1 +415,1 @@\n-  MemNode const* _mem_ref_for_main_loop_alignment;\n+  VPointer const* _vpointer_for_main_loop_alignment;\n@@ -660,1 +660,1 @@\n-  bool schedule_and_apply() const;\n+  bool do_vtransform() const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,4 @@\n+\n+  \/\/ Build vtnodes for all uses of nodes from the loop, and connect them\n+  \/\/ as outputs to the nodes in the loop.\n+  build_uses_after_loop();\n@@ -53,2 +57,2 @@\n-  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n-    Node* n = _vloop_analyzer.body().body().at(i);\n+  for (uint i = 0; i < _vloop.lpt()->_body.size(); i++) {\n+    Node* n = _vloop.lpt()->_body.at(i);\n@@ -64,0 +68,2 @@\n+    } else if (n->is_CountedLoop()) {\n+      vtn = new (_vtransform.arena()) VTransformCountedLoopNode(_vtransform, n->as_CountedLoop());\n@@ -124,2 +130,2 @@\n-  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n-    Node* n = _vloop_analyzer.body().body().at(i);\n+  for (uint i = 0; i < _vloop.lpt()->_body.size(); i++) {\n+    Node* n = _vloop.lpt()->_body.at(i);\n@@ -138,6 +144,3 @@\n-      continue; \/\/ Is \"root\", has no dependency.\n-    } else if (n->is_Phi()) {\n-      \/\/ CountedLoop Phi's: ignore backedge (and entry value).\n-      assert(n->in(0) == _vloop.cl(), \"only Phi's from the CountedLoop allowed\");\n-      init_req_with_scalar(n, vtn, 0);\n-      continue;\n+      \/\/ Avoid self-loop, it only creates unnecessary issues in scheduling.\n+      init_req_with_scalar(n, vtn, LoopNode::EntryControl);\n+      init_req_with_scalar(n, vtn, LoopNode::LoopBackControl);\n@@ -150,0 +153,26 @@\n+\/\/ Build vtnodes for all uses of nodes from the loop, and connect them\n+\/\/ as outputs to the nodes in the loop.\n+void SuperWordVTransformBuilder::build_uses_after_loop() {\n+  for (uint i = 0; i < _vloop.lpt()->_body.size(); i++) {\n+    Node* n = _vloop.lpt()->_body.at(i);\n+    VTransformNode* vtn = get_vtnode(n);\n+\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* use = n->fast_out(i);\n+\n+      if (!_vloop.in_bb(use)) {\n+        VTransformNode* vtn_use = get_vtnode_or_wrap_as_outer(use);\n+\n+        \/\/ Set all edges\n+        for (uint j = 0; j < use->req(); j++) {\n+          Node* def = use->in(j);\n+          if (n == def && vtn_use->in_req(j) != vtn) {\n+            assert(vtn_use->in_req(j) == nullptr, \"should not yet be set\");\n+            vtn_use->init_req(j, vtn);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -162,1 +191,2 @@\n-    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, properties, vector_p, p0->adr_type());\n+    const LoadNode::ControlDependency control_dependency = load_control_dependency(pack);\n+    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, properties, vector_p, p0->adr_type(), control_dependency);\n@@ -212,1 +242,0 @@\n-  vtn->set_nodes(pack);\n@@ -279,2 +308,2 @@\n-      BasicType element_type = p0->is_Convert() ? p0->in(1)->bottom_type()->basic_type() : _vloop_analyzer.types().velt_basic_type(p0);\n-      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type == T_LONG) {\n+      BasicType element_bt = p0->is_Convert() ? p0->in(1)->bottom_type()->basic_type() : _vloop_analyzer.types().velt_basic_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_bt == T_LONG) {\n@@ -287,1 +316,1 @@\n-      VTransformNode* replicate = new (_vtransform.arena()) VTransformReplicateNode(_vtransform, pack->size(), element_type);\n+      VTransformNode* replicate = new (_vtransform.arena()) VTransformReplicateNode(_vtransform, pack->size(), element_bt);\n@@ -310,0 +339,1 @@\n+  assert(vtn == get_vtnode_or_null(n), \"consistency\");\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":45,"deletions":15,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  void build_uses_after_loop();\n@@ -85,0 +86,1 @@\n+  LoadNode::ControlDependency load_control_dependency(const Node_List* pack) const;\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+  VStatus body_status = _body.construct();\n+  if (!body_status.is_success()) {\n+    return body_status;\n+  }\n+\n@@ -195,5 +200,0 @@\n-  VStatus body_status = _body.construct();\n-  if (!body_status.is_success()) {\n-    return body_status;\n-  }\n-\n@@ -209,0 +209,58 @@\n+\/\/ There are 2 kinds of slices:\n+\/\/ - No memory phi: only loads. All have the same input memory state from before the loop.\n+\/\/ - With memory phi. Chain of memory operations inside the loop.\n+void VLoopMemorySlices::find_memory_slices() {\n+  Compile* C = _vloop.phase()->C;\n+  \/\/ We iterate over the body, which is topologically sorted. Hence, if there is a phi\n+  \/\/ in a slice, we will find it first, and the loads and stores afterwards.\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n+    if (n->is_memory_phi()) {\n+      \/\/ Memory slice with stores (and maybe loads)\n+      PhiNode* phi = n->as_Phi();\n+      int alias_idx = C->get_alias_index(phi->adr_type());\n+      assert(_inputs.at(alias_idx) == nullptr, \"did not yet touch this slice\");\n+      _inputs.at_put(alias_idx, phi->in(1));\n+      _heads.at_put(alias_idx, phi);\n+    } else if (n->is_Load()) {\n+      LoadNode* load = n->as_Load();\n+      int alias_idx = C->get_alias_index(load->adr_type());\n+      PhiNode* head = _heads.at(alias_idx);\n+      if (head == nullptr) {\n+        \/\/ We did not find a phi on this slice yet -> must be a slice with only loads.\n+        assert(_inputs.at(alias_idx) == nullptr || _inputs.at(alias_idx) == load->in(1),\n+               \"not yet touched or the same input\");\n+        _inputs.at_put(alias_idx, load->in(1));\n+      } \/\/ else: the load belongs to a slice with a phi that already set heads and inputs.\n+#ifdef ASSERT\n+    } else if (n->is_Store()) {\n+      \/\/ Found a store. Make sure it is in a slice with a Phi.\n+      StoreNode* store = n->as_Store();\n+      int alias_idx = C->get_alias_index(store->adr_type());\n+      PhiNode* head = _heads.at(alias_idx);\n+      assert(head != nullptr, \"should have found a mem phi for this slice\");\n+#endif\n+    }\n+  }\n+  NOT_PRODUCT( if (_vloop.is_trace_memory_slices()) { print(); } )\n+}\n+\n+#ifndef PRODUCT\n+void VLoopMemorySlices::print() const {\n+  tty->print_cr(\"\\nVLoopMemorySlices::print: %s\",\n+                heads().length() > 0 ? \"\" : \"NONE\");\n+  for (int i = 0; i < _inputs.length(); i++) {\n+    Node* input = _inputs.at(i);\n+    PhiNode* head = _heads.at(i);\n+    if (input != nullptr) {\n+      tty->print(\"%3d input\", i);  input->dump();\n+      if (head == nullptr) {\n+        tty->print_cr(\"    load only\");\n+      } else {\n+        tty->print(\"    head \");  head->dump();\n+      }\n+    }\n+  }\n+}\n+#endif\n+\n@@ -270,1 +328,0 @@\n-  const GrowableArray<MemNode*>& mem_slice_tails = _memory_slices.tails();\n@@ -280,1 +337,4 @@\n-    MemNode* tail = mem_slice_tails.at(i);\n+    \/\/ If there is no head (memory-phi) for this slice, then we have either no memops\n+    \/\/ in the loop, or only loads. We do not need to add any memory edges in that case.\n+    if (head == nullptr) { continue; }\n+    MemNode* tail = head->in(2)->as_Mem();\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":67,"deletions":7,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -382,31 +382,0 @@\n-\/\/ Submodule of VLoopAnalyzer.\n-\/\/ Find the memory slices in the loop.\n-class VLoopMemorySlices : public StackObj {\n-private:\n-  const VLoop& _vloop;\n-\n-  GrowableArray<PhiNode*> _heads;\n-  GrowableArray<MemNode*> _tails;\n-\n-public:\n-  VLoopMemorySlices(Arena* arena, const VLoop& vloop) :\n-    _vloop(vloop),\n-    _heads(arena, 8, 0, nullptr),\n-    _tails(arena, 8, 0, nullptr) {};\n-  NONCOPYABLE(VLoopMemorySlices);\n-\n-  void find_memory_slices();\n-\n-  const GrowableArray<PhiNode*>& heads() const { return _heads; }\n-  const GrowableArray<MemNode*>& tails() const { return _tails; }\n-\n-  \/\/ Get all memory nodes of a slice, in reverse order\n-  void get_slice_in_reverse_order(PhiNode* head, MemNode* tail, GrowableArray<MemNode*>& slice) const;\n-\n-  bool same_memory_slice(MemNode* m1, MemNode* m2) const;\n-\n-#ifndef PRODUCT\n-  void print() const;\n-#endif\n-};\n-\n@@ -464,0 +433,67 @@\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ Find the memory slices in the loop. There are 3 kinds of slices:\n+\/\/ 1. no use in loop:                     inputs(i) = nullptr,   heads(i) = nullptr\n+\/\/ 2. stores in loop:                     inputs(i) = entry_mem, heads(i) = phi_mem\n+\/\/\n+\/\/    <mem state before loop> = entry_mem\n+\/\/                      |\n+\/\/         CountedLoop  |  +-----------------------+\n+\/\/                   |  v  v                       |\n+\/\/                   phi_mem                       |\n+\/\/                     |                           |\n+\/\/                   <stores (and maybe loads)>    |\n+\/\/                     |                           |\n+\/\/                     +---------------------------+\n+\/\/                     |\n+\/\/    <mem uses after loop>\n+\/\/\n+\/\/    Note: the mem uses after the loop are dependent on the last store in the loop.\n+\/\/          Once we vectorize, we may reorder the loads and stores, and replace\n+\/\/          scalar mem ops with vector mem ops. We will have to make sure that all\n+\/\/          uses after the loop use the new last store.\n+\/\/          See: VTransformApplyState::fix_memory_state_uses_after_loop\n+\/\/\n+\/\/ 3. only loads but no stores in loop:   inputs(i) = entry_mem, heads(i) = nullptr\n+\/\/\n+\/\/    <mem state before loop> = entry_mem\n+\/\/     |                 |\n+\/\/     |   CountedLoop   |\n+\/\/     |             |   |\n+\/\/     |            <loads in loop>\n+\/\/     |\n+\/\/    <mem uses after loop>\n+\/\/\n+\/\/    Note: the mem uses after the loop are NOT dependent any mem ops in the loop,\n+\/\/          since there are no stores.\n+\/\/\n+class VLoopMemorySlices : public StackObj {\n+private:\n+  const VLoop& _vloop;\n+  const VLoopBody& _body;\n+\n+  GrowableArray<Node*>    _inputs;\n+  GrowableArray<PhiNode*> _heads;\n+\n+public:\n+  VLoopMemorySlices(Arena* arena, const VLoop& vloop, const VLoopBody& body) :\n+    _vloop(vloop),\n+    _body(body),\n+    _inputs(arena, num_slices(), num_slices(), nullptr),\n+    _heads(arena, num_slices(), num_slices(), nullptr) {};\n+  NONCOPYABLE(VLoopMemorySlices);\n+\n+  const GrowableArray<Node*>& inputs() const { return _inputs; }\n+  const GrowableArray<PhiNode*>& heads() const { return _heads; }\n+\n+  void find_memory_slices();\n+  void get_slice_in_reverse_order(PhiNode* head, MemNode* tail, GrowableArray<MemNode*>& slice) const;\n+  bool same_memory_slice(MemNode* m1, MemNode* m2) const;\n+\n+private:\n+#ifndef PRODUCT\n+  void print() const;\n+#endif\n+\n+  int num_slices() const { return _vloop.phase()->C->num_alias_types(); }\n+};\n+\n@@ -740,1 +776,0 @@\n-  VLoopMemorySlices    _memory_slices;\n@@ -742,0 +777,1 @@\n+  VLoopMemorySlices    _memory_slices;\n@@ -752,1 +788,0 @@\n-    _memory_slices   (&_arena, vloop),\n@@ -754,0 +789,1 @@\n+    _memory_slices   (&_arena, vloop, _body),\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":69,"deletions":33,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -81,0 +81,4 @@\n+\n+        \/\/ Skip LoopPhi backedge.\n+        if ((use->isa_LoopPhi() != nullptr || use->isa_CountedLoop() != nullptr) && use->in_req(2) == vtn) { continue; }\n+\n@@ -123,0 +127,5 @@\n+    \/\/ If an Outer node has both inputs and outputs, we will most likely have cycles in the final graph.\n+    \/\/ This is not a correctness problem, but it just will prevent vectorization. If this ever happens\n+    \/\/ try to find a way to avoid the cycle somehow.\n+    assert(vtn->isa_Outer() == nullptr || (vtn->has_strong_in_edge() != (vtn->out_strong_edges() > 0)),\n+           \"Outer nodes should either be inputs or outputs, but not both, otherwise we may get cycles\");\n@@ -720,0 +729,51 @@\n+void VTransformApplyState::init_memory_states_and_uses_after_loop() {\n+  const GrowableArray<Node*>& inputs = _vloop_analyzer.memory_slices().inputs();\n+  const GrowableArray<PhiNode*>& heads = _vloop_analyzer.memory_slices().heads();\n+  for (int i = 0; i < inputs.length(); i++) {\n+    PhiNode* head = heads.at(i);\n+    if (head != nullptr) {\n+      \/\/ Slice with Phi (i.e. with stores) -> start with the phi (phi_mem)\n+      _memory_states.at_put(i, head);\n+\n+      \/\/ Remember uses outside the loop of the last memory state (store).\n+      StoreNode* last_store = head->in(2)->as_Store();\n+      assert(vloop().in_bb(last_store), \"backedge store should be in the loop\");\n+      for (DUIterator_Fast jmax, j = last_store->fast_outs(jmax); j < jmax; j++) {\n+        Node* use = last_store->fast_out(j);\n+        if (!vloop().in_bb(use)) {\n+          for (uint k = 0; k < use->req(); k++) {\n+            if (use->in(k) == last_store) {\n+              _memory_state_uses_after_loop.push(MemoryStateUseAfterLoop(use, k, i));\n+            }\n+          }\n+        }\n+      }\n+    } else {\n+      \/\/ Slice without Phi (i.e. only loads) -> use the input state (entry_mem)\n+      _memory_states.at_put(i, inputs.at(i));\n+    }\n+  }\n+}\n+\n+\/\/ We may have reordered the scalar stores, or replaced them with vectors. Now\n+\/\/ the last memory state in the loop may have changed. Thus, we need to change\n+\/\/ the uses of the old last memory state the new last memory state.\n+void VTransformApplyState::fix_memory_state_uses_after_loop() {\n+  for (int i = 0; i < _memory_state_uses_after_loop.length(); i++) {\n+    MemoryStateUseAfterLoop& use = _memory_state_uses_after_loop.at(i);\n+    Node* last_state = memory_state(use._alias_idx);\n+    phase()->igvn().replace_input_of(use._use, use._in_idx, last_state);\n+  }\n+}\n+\n+void VTransformNode::apply_vtn_inputs_to_node(Node* n, VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  for (uint i = 0; i < req(); i++) {\n+    VTransformNode* vtn_def = in_req(i);\n+    if (vtn_def != nullptr) {\n+      Node* def = apply_state.transformed_node(vtn_def);\n+      phase->igvn().replace_input_of(n, i, def);\n+    }\n+  }\n+}\n+\n@@ -721,1 +781,8 @@\n-  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n+  apply_vtn_inputs_to_node(_node, apply_state);\n+  \/\/ The memory state has to be applied separately: the vtn does not hold it. This allows reordering.\n+  Node* mem = apply_state.memory_state(_node->adr_type());\n+  apply_state.phase()->igvn().replace_input_of(_node, 1, mem);\n+  if (_node->is_Store()) {\n+    apply_state.set_memory_state(_node->adr_type(), _node);\n+  }\n+\n@@ -726,1 +793,1 @@\n-  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n+  apply_vtn_inputs_to_node(_node, apply_state);\n@@ -731,1 +798,6 @@\n-  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* in0 = apply_state.transformed_node(in_req(0));\n+  Node* in1 = apply_state.transformed_node(in_req(1));\n+  phase->igvn().replace_input_of(_node, 0, in0);\n+  phase->igvn().replace_input_of(_node, 1, in1);\n+  \/\/ Note: the backedge is hooked up later.\n@@ -735,0 +807,17 @@\n+\/\/ Cleanup backedges. In the schedule, the backedges come after their phis. Hence,\n+\/\/ we only have the transformed backedges after the phis are already transformed.\n+\/\/ We hook the backedges into the phis now, during cleanup.\n+void VTransformLoopPhiNode::apply_backedge(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  if (_node->is_memory_phi()) {\n+    \/\/ Memory phi\/backedge\n+    \/\/ The last memory state of that slice is the backedge.\n+    Node* last_state = apply_state.memory_state(_node->adr_type());\n+    phase->igvn().replace_input_of(_node, 2, last_state);\n+  } else {\n+    \/\/ Data phi\/backedge\n+    Node* in2 = apply_state.transformed_node(in_req(2));\n+    phase->igvn().replace_input_of(_node, 2, in2);\n+  }\n+}\n+\n@@ -736,1 +825,4 @@\n-  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n+  \/\/ We do not modify the inputs of the CountedLoop (and certainly not its backedge)\n+  if (!_node->is_CountedLoop()) {\n+    apply_vtn_inputs_to_node(_node, apply_state);\n+  }\n@@ -741,1 +833,1 @@\n-  \/\/ This was just wrapped. Now we simply unwrap without touching the inputs.\n+  apply_vtn_inputs_to_node(_node, apply_state);\n@@ -800,1 +892,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -815,1 +907,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -827,1 +919,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -846,1 +938,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -855,1 +947,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -864,1 +956,1 @@\n-  LoadNode* first = nodes().at(0)->as_Load();\n+  \/\/ The memory state has to be applied separately: the vtn does not hold it. This allows reordering.\n@@ -866,2 +958,1 @@\n-  \/\/ first has the correct memory state, determined by VTransformGraph::apply_memops_reordering_with_schedule\n-  Node* mem  = first->in(MemNode::Memory);\n+  Node* mem  = apply_state.memory_state(_adr_type);\n@@ -883,2 +974,1 @@\n-  LoadVectorNode* vn = LoadVectorNode::make(sopc, ctrl, mem, adr, _adr_type, vlen, bt,\n-                                            control_dependency());\n+  LoadVectorNode* vn = LoadVectorNode::make(sopc, ctrl, mem, adr, _adr_type, vlen, bt, _control_dependency);\n@@ -886,1 +976,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n+  register_new_node_from_vectorization(apply_state, vn);\n@@ -894,1 +984,1 @@\n-  StoreNode* first = nodes().at(0)->as_Store();\n+  \/\/ The memory state has to be applied separately: the vtn does not hold it. This allows reordering.\n@@ -896,2 +986,1 @@\n-  \/\/ first has the correct memory state, determined by VTransformGraph::apply_memops_reordering_with_schedule\n-  Node* mem  = first->in(MemNode::Memory);\n+  Node* mem  = apply_state.memory_state(_adr_type);\n@@ -903,6 +992,0 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n-  return VTransformApplyResult::make_vector(vn, vn->vect_type());\n-}\n-\n-void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(VTransformApplyState& apply_state, Node* vn) const {\n-  PhaseIdealLoop* phase = apply_state.phase();\n@@ -910,5 +993,2 @@\n-\n-  for (int i = 0; i < _nodes.length(); i++) {\n-    Node* n = _nodes.at(i);\n-    phase->igvn().replace_node(n, vn);\n-  }\n+  apply_state.set_memory_state(_adr_type, vn);\n+  return VTransformApplyResult::make_vector(vn, vn->vect_type());\n@@ -947,9 +1027,0 @@\n-void VTransformGraph::print_memops_schedule() const {\n-  tty->print_cr(\"\\nVTransformGraph::print_memops_schedule:\");\n-  int i = 0;\n-  for_each_memop_in_schedule([&] (MemNode* mem) {\n-    tty->print(\" %3d: \", i++);\n-    mem->dump();\n-  });\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":110,"deletions":39,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-\/\/   - From SuperWord, with the SuperWordVTransformBuilder.\n+\/\/   - From SuperWord PackSet, with the SuperWordVTransformBuilder.\n@@ -52,0 +52,2 @@\n+\/\/   - Align the main loop, by adjusting pre loop limit.\n+\/\/   - Add speculative runtime checks (alignment and aliasing).\n@@ -53,1 +55,7 @@\n-\/\/     possibly replacing old scalar C2 nodes.\n+\/\/     possibly replacing old scalar C2 nodes. We apply each vtnode in order\n+\/\/     of the schedule, so that all input vtnodes are already applied, i.e.\n+\/\/     all input vtnodes have already generated the transformed C2 nodes.\n+\/\/   - We also build the new memory graph on the fly. The schedule may have\n+\/\/     reordered the memory operations, and so we cannot use the old memory\n+\/\/     graph, but must build it from the scheduled order. We keep track of\n+\/\/     the current memory state in VTransformApplyState.\n@@ -68,0 +76,1 @@\n+class VTransformCountedLoopNode;\n@@ -179,1 +188,0 @@\n-  void apply_memops_reordering_with_schedule() const;\n@@ -190,3 +198,0 @@\n-  template<typename Callback>\n-  void for_each_memop_in_schedule(Callback callback) const;\n-\n@@ -196,1 +201,0 @@\n-  void print_memops_schedule() const;\n@@ -218,1 +222,1 @@\n-  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ VPointer, and the alignment width (aw) for which we align the main-loop,\n@@ -220,1 +224,1 @@\n-  MemNode const* _mem_ref_for_main_loop_alignment;\n+  VPointer const* _vpointer_for_main_loop_alignment;\n@@ -225,1 +229,1 @@\n-             MemNode const* mem_ref_for_main_loop_alignment,\n+             VPointer const* vpointer_for_main_loop_alignment,\n@@ -234,1 +238,1 @@\n-    _mem_ref_for_main_loop_alignment(mem_ref_for_main_loop_alignment),\n+    _vpointer_for_main_loop_alignment(vpointer_for_main_loop_alignment),\n@@ -260,1 +264,1 @@\n-  void determine_mem_ref_and_aw_for_main_loop_alignment();\n+  void determine_vpointer_and_aw_for_main_loop_alignment();\n@@ -274,1 +278,1 @@\n-\/\/ -> keep track of the already transformed nodes\n+\/\/ -> keep track of the already transformed nodes and the memory state.\n@@ -284,0 +288,22 @@\n+  \/\/ We keep track of the current memory state in each slice. If the slice has only\n+  \/\/ loads (and no phi), then this is always the input memory state from before the\n+  \/\/ loop. If there is a memory phi, this is initially the memory phi, and each time\n+  \/\/ a store is processed, it is updated to that store.\n+  GrowableArray<Node*> _memory_states;\n+\n+  \/\/ We need to keep track of the memory uses after the loop, for the slices that\n+  \/\/ have a memory phi.\n+  \/\/   use->in(in_idx) = <last memory state in loop of slice alias_idx>\n+  class MemoryStateUseAfterLoop : public StackObj {\n+  public:\n+    Node* _use;\n+    int _in_idx;\n+    int _alias_idx;\n+\n+    MemoryStateUseAfterLoop(Node* use, int in_idx, int alias_idx) :\n+      _use(use), _in_idx(in_idx), _alias_idx(alias_idx) {}\n+    MemoryStateUseAfterLoop() : MemoryStateUseAfterLoop(nullptr, 0, 0) {}\n+  };\n+\n+  GrowableArray<MemoryStateUseAfterLoop> _memory_state_uses_after_loop;\n+\n@@ -287,1 +313,2 @@\n-    _vtnode_idx_to_transformed_node(num_vtnodes, num_vtnodes, nullptr)\n+    _vtnode_idx_to_transformed_node(num_vtnodes, num_vtnodes, nullptr),\n+    _memory_states(num_slices(), num_slices(), nullptr)\n@@ -289,0 +316,1 @@\n+    init_memory_states_and_uses_after_loop();\n@@ -297,0 +325,19 @@\n+\n+  Node* memory_state(int alias_idx) const { return _memory_states.at(alias_idx); }\n+  void set_memory_state(int alias_idx, Node* n) { _memory_states.at_put(alias_idx, n); }\n+\n+  Node* memory_state(const TypePtr* adr_type) const {\n+    int alias_idx = phase()->C->get_alias_index(adr_type);\n+    return memory_state(alias_idx);\n+  }\n+\n+  void set_memory_state(const TypePtr* adr_type, Node* n) {\n+    int alias_idx = phase()->C->get_alias_index(adr_type);\n+    return set_memory_state(alias_idx, n);\n+  }\n+\n+  void fix_memory_state_uses_after_loop();\n+\n+private:\n+  int num_slices() const { return _vloop_analyzer.memory_slices().heads().length(); }\n+  void init_memory_states_and_uses_after_loop();\n@@ -436,0 +483,2 @@\n+  virtual VTransformLoopPhiNode* isa_LoopPhi() { return nullptr; }\n+  virtual VTransformCountedLoopNode* isa_CountedLoop() { return nullptr; }\n@@ -451,3 +500,2 @@\n-\n-  Node* find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const;\n-\n+  virtual void apply_backedge(VTransformApplyState& apply_state) const {};\n+  void apply_vtn_inputs_to_node(Node* n, VTransformApplyState& apply_state) const;\n@@ -513,0 +561,1 @@\n+  virtual VTransformLoopPhiNode* isa_LoopPhi() override { return this; }\n@@ -514,0 +563,1 @@\n+  virtual void apply_backedge(VTransformApplyState& apply_state) const override;\n@@ -534,0 +584,10 @@\n+\/\/ Identity transform for CountedLoop, the only CFG node with a backedge.\n+class VTransformCountedLoopNode : public VTransformCFGNode {\n+public:\n+  VTransformCountedLoopNode(VTransform& vtransform, CountedLoopNode* n) :\n+    VTransformCFGNode(vtransform, n) {}\n+\n+  virtual VTransformCountedLoopNode* isa_CountedLoop() override { return this; }\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CountedLoop\"; };)\n+};\n+\n@@ -635,2 +695,0 @@\n-protected:\n-  GrowableArray<Node*> _nodes;\n@@ -639,12 +697,1 @@\n-    VTransformNode(vtransform, req),\n-    _properties(properties),\n-    _nodes(vtransform.arena(),\n-           properties.vector_length(),\n-           properties.vector_length(),\n-           nullptr) {}\n-\n-  void set_nodes(const Node_List* pack) {\n-    for (uint k = 0; k < pack->size(); k++) {\n-      _nodes.at_put(k, pack->at(k));\n-    }\n-  }\n+    VTransformNode(vtransform, req), _properties(properties) {}\n@@ -752,1 +799,0 @@\n-  const GrowableArray<Node*>& nodes() const { return _nodes; }\n@@ -759,0 +805,3 @@\n+private:\n+  const LoadNode::ControlDependency _control_dependency;\n+\n@@ -761,2 +810,6 @@\n-  VTransformLoadVectorNode(VTransform& vtransform, const VTransformVectorNodeProperties properties, const VPointer& vpointer, const TypePtr* adr_type) :\n-    VTransformMemVectorNode(vtransform, 3, properties, vpointer, adr_type) {}\n+  VTransformLoadVectorNode(VTransform& vtransform,\n+                           const VTransformVectorNodeProperties properties,\n+                           const VPointer& vpointer,\n+                           const TypePtr* adr_type,\n+                           const LoadNode::ControlDependency control_dependency) :\n+    VTransformMemVectorNode(vtransform, 3, properties, vpointer, adr_type), _control_dependency(control_dependency) {}\n@@ -780,26 +833,0 @@\n-\n-\/\/ Invoke callback on all memops, in the order of the schedule.\n-template<typename Callback>\n-void VTransformGraph::for_each_memop_in_schedule(Callback callback) const {\n-  assert(_schedule.length() == _vtnodes.length(), \"schedule was computed\");\n-\n-  for (int i = 0; i < _schedule.length(); i++) {\n-    VTransformNode* vtn = _schedule.at(i);\n-\n-    \/\/ We must ignore nodes outside the loop.\n-    if (vtn->isa_Outer() != nullptr) { continue; }\n-\n-    VTransformMemopScalarNode* scalar = vtn->isa_MemopScalar();\n-    if (scalar != nullptr) {\n-      callback(scalar->node());\n-    }\n-\n-    VTransformMemVectorNode* vector = vtn->isa_MemVector();\n-    if (vector != nullptr) {\n-      for (int j = 0; j < vector->nodes().length(); j++) {\n-        callback(vector->nodes().at(j)->as_Mem());\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":87,"deletions":60,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -1555,1 +1556,3 @@\n-      address((jlong) blob) { }\n+      address((jlong) blob),\n+      code_begin((jlong) blob->code_begin()),\n+      is_nmethod((jboolean) blob->is_nmethod()) { }\n@@ -1561,0 +1564,2 @@\n+  const jlong       code_begin;\n+  const jboolean    is_nmethod;\n@@ -1567,1 +1572,1 @@\n-  jobjectArray result = env->NewObjectArray(4, clazz, nullptr);\n+  jobjectArray result = env->NewObjectArray(6, clazz, nullptr);\n@@ -1585,0 +1590,8 @@\n+  obj = longBox(thread, env, cb->code_begin);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 4, obj);\n+\n+  obj = booleanBox(thread, env, cb->is_nmethod);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 5, obj);\n+\n@@ -1634,0 +1647,38 @@\n+WB_ENTRY(void, WB_RelocateNMethodFromMethod(JNIEnv* env, jobject o, jobject method, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION(env);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  nmethod* code = mh->code();\n+  if (code != nullptr) {\n+    MutexLocker ml_Compile_lock(Compile_lock);\n+    CompiledICLocker ic_locker(code);\n+    MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    code->relocate(static_cast<CodeBlobType>(blob_type));\n+  }\n+WB_END\n+\n+WB_ENTRY(void, WB_RelocateNMethodFromAddr(JNIEnv* env, jobject o, jlong addr, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  CHECK_JNI_EXCEPTION(env);\n+  void* address = (void*) addr;\n+\n+  if (address == nullptr) {\n+    return;\n+  }\n+\n+  MutexLocker ml_Compile_lock(Compile_lock);\n+  MutexLocker ml_CompiledIC_lock(CompiledIC_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ Verify that nmethod address is still valid\n+  CodeBlob* blob = CodeCache::find_blob(address);\n+  if (blob != nullptr && blob->is_nmethod()) {\n+    nmethod* code = blob->as_nmethod();\n+    if (code->is_in_use()) {\n+      CompiledICLocker ic_locker(code);\n+      code->relocate(static_cast<CodeBlobType>(blob_type));\n+    }\n+  }\n+WB_END\n+\n@@ -2769,1 +2820,1 @@\n-WB_ENTRY(void, WB_BusyWait(JNIEnv* env, jobject wb, jint time))\n+WB_ENTRY(void, WB_BusyWaitCPUTime(JNIEnv* env, jobject wb, jint time))\n@@ -2780,2 +2831,1 @@\n-    JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE);\n-    return JNI_TRUE;\n+    return JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE) ? JNI_TRUE : JNI_FALSE;\n@@ -2787,8 +2837,0 @@\n-WB_ENTRY(jlong, WB_CPUSamplerOutOfStackWalkingIterations(JNIEnv* env, jobject wb))\n-  #if defined(ASSERT) && INCLUDE_JFR && defined(LINUX)\n-    return (jlong)JfrCPUTimeThreadSampling::out_of_stack_walking_iterations();\n-  #else\n-    return 0;\n-  #endif\n-WB_END\n-\n@@ -3026,0 +3068,3 @@\n+  {CC\"relocateNMethodFromMethod0\", CC\"(Ljava\/lang\/reflect\/Executable;I)V\",\n+                                                      (void*)&WB_RelocateNMethodFromMethod },\n+  {CC\"relocateNMethodFromAddr\", CC\"(JI)V\",            (void*)&WB_RelocateNMethodFromAddr },\n@@ -3154,1 +3199,1 @@\n-  {CC\"busyWait\", CC\"(I)V\",                            (void*)&WB_BusyWait},\n+  {CC\"busyWaitCPUTime\", CC\"(I)V\",                     (void*)&WB_BusyWaitCPUTime},\n@@ -3156,1 +3201,0 @@\n-  {CC\"cpuSamplerOutOfStackWalkingIterations\", CC\"()J\",(void*)&WB_CPUSamplerOutOfStackWalkingIterations},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":59,"deletions":15,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -1522,0 +1523,4 @@\n+static size_t clamp_by_size_t_max(uint64_t value) {\n+  return (size_t)MIN2(value, (uint64_t)std::numeric_limits<size_t>::max());\n+}\n+\n@@ -1523,16 +1528,13 @@\n-  julong phys_mem;\n-\n-  \/\/ If the user specified one of these options, they\n-  \/\/ want specific memory sizing so do not limit memory\n-  \/\/ based on compressed oops addressability.\n-  \/\/ Also, memory limits will be calculated based on\n-  \/\/ available os physical memory, not our MaxRAM limit,\n-  \/\/ unless MaxRAM is also specified.\n-  bool override_coop_limit = (!FLAG_IS_DEFAULT(MaxRAMPercentage) ||\n-                           !FLAG_IS_DEFAULT(MinRAMPercentage) ||\n-                           !FLAG_IS_DEFAULT(InitialRAMPercentage) ||\n-                           !FLAG_IS_DEFAULT(MaxRAM));\n-  if (override_coop_limit) {\n-    if (FLAG_IS_DEFAULT(MaxRAM)) {\n-      phys_mem = static_cast<julong>(os::physical_memory());\n-      FLAG_SET_ERGO(MaxRAM, (uint64_t)phys_mem);\n+  uint64_t physical_memory;\n+\n+  \/\/ Check if the user has configured any limit on the amount of RAM we may use.\n+  bool has_ram_limit = !FLAG_IS_DEFAULT(MaxRAMPercentage) ||\n+                       !FLAG_IS_DEFAULT(MinRAMPercentage) ||\n+                       !FLAG_IS_DEFAULT(InitialRAMPercentage) ||\n+                       !FLAG_IS_DEFAULT(MaxRAM);\n+\n+  if (has_ram_limit) {\n+    if (!FLAG_IS_DEFAULT(MaxRAM)) {\n+      \/\/ The user has configured MaxRAM, use that instead of physical memory\n+      \/\/ reported by the OS.\n+      physical_memory = MaxRAM;\n@@ -1540,1 +1542,4 @@\n-      phys_mem = (julong)MaxRAM;\n+      \/\/ The user has configured a limit, make sure MaxRAM reflects the physical\n+      \/\/ memory limit that heap sizing takes into account.\n+      physical_memory = os::physical_memory();\n+      FLAG_SET_ERGO(MaxRAM, physical_memory);\n@@ -1543,2 +1548,4 @@\n-    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(static_cast<julong>(os::physical_memory()), (julong)MaxRAM)\n-                                       : (julong)MaxRAM;\n+    \/\/ If the user did not specify any limit, choose the lowest of the available\n+    \/\/ physical memory and MaxRAM. MaxRAM is typically set to 128GB on 64-bit\n+    \/\/ architecture.\n+    physical_memory = MIN2(os::physical_memory(), MaxRAM);\n@@ -1547,3 +1554,3 @@\n-  \/\/ If the maximum heap size has not been set with -Xmx,\n-  \/\/ then set it as fraction of the size of physical memory,\n-  \/\/ respecting the maximum and minimum sizes of the heap.\n+  \/\/ If the maximum heap size has not been set with -Xmx, then set it as\n+  \/\/ fraction of the size of physical memory, respecting the maximum and\n+  \/\/ minimum sizes of the heap.\n@@ -1551,2 +1558,6 @@\n-    julong reasonable_max = (julong)(((double)phys_mem * MaxRAMPercentage) \/ 100);\n-    const julong reasonable_min = (julong)(((double)phys_mem * MinRAMPercentage) \/ 100);\n+    uint64_t min_memory = (uint64_t)(((double)physical_memory * MinRAMPercentage) \/ 100);\n+    uint64_t max_memory = (uint64_t)(((double)physical_memory * MaxRAMPercentage) \/ 100);\n+\n+    const size_t reasonable_min = clamp_by_size_t_max(min_memory);\n+    size_t reasonable_max = clamp_by_size_t_max(max_memory);\n+\n@@ -1559,1 +1570,1 @@\n-      reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);\n+      reasonable_max = MAX2(reasonable_max, MaxHeapSize);\n@@ -1564,1 +1575,1 @@\n-      reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);\n+      reasonable_max = MIN2(reasonable_max, ErgoHeapSizeLimit);\n@@ -1574,1 +1585,1 @@\n-      reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);\n+      reasonable_max = MAX2(reasonable_max, InitialHeapSize);\n@@ -1576,1 +1587,1 @@\n-      reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);\n+      reasonable_max = MAX2(reasonable_max, MinHeapSize);\n@@ -1585,2 +1596,2 @@\n-          log_debug(gc, heap, coops)(\"HeapBaseMinAddress must be at least %zu\"\n-                                     \" (%zuG) which is greater than value given %zu\",\n+          log_debug(gc, heap, coops)(\"HeapBaseMinAddress must be at least %zu \"\n+                                     \"(%zuG) which is greater than value given %zu\",\n@@ -1594,0 +1605,1 @@\n+\n@@ -1595,2 +1607,2 @@\n-      \/\/ Limit the heap size to the maximum possible when using compressed oops\n-      julong max_coop_heap = (julong)max_heap_for_compressed_oops();\n+      size_t heap_end = HeapBaseMinAddress + MaxHeapSize;\n+      size_t max_coop_heap = max_heap_for_compressed_oops();\n@@ -1598,3 +1610,4 @@\n-      if (HeapBaseMinAddress + MaxHeapSize < max_coop_heap) {\n-        \/\/ Heap should be above HeapBaseMinAddress to get zero based compressed oops\n-        \/\/ but it should be not less than default MaxHeapSize.\n+      \/\/ Limit the heap size to the maximum possible when using compressed oops\n+      if (heap_end < max_coop_heap) {\n+        \/\/ Heap should be above HeapBaseMinAddress to get zero based compressed\n+        \/\/ oops but it should be not less than default MaxHeapSize.\n@@ -1604,4 +1617,3 @@\n-      \/\/ If user specified flags prioritizing os physical\n-      \/\/ memory limits, then disable compressed oops if\n-      \/\/ limits exceed max_coop_heap and UseCompressedOops\n-      \/\/ was not specified.\n+      \/\/ If the user has configured any limit on the amount of RAM we may use,\n+      \/\/ then disable compressed oops if the calculated max exceeds max_coop_heap\n+      \/\/ and UseCompressedOops was not specified.\n@@ -1609,5 +1621,5 @@\n-        if (FLAG_IS_ERGO(UseCompressedOops) && override_coop_limit) {\n-          aot_log_info(aot)(\"UseCompressedOops disabled due to\"\n-            \" max heap %zu > compressed oop heap %zu. \"\n-            \"Please check the setting of MaxRAMPercentage %5.2f.\"\n-            ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);\n+        if (FLAG_IS_ERGO(UseCompressedOops) && has_ram_limit) {\n+          aot_log_info(aot)(\"UseCompressedOops disabled due to \"\n+                            \"max heap %zu > compressed oop heap %zu. \"\n+                            \"Please check the setting of MaxRAMPercentage %5.2f.\",\n+                            reasonable_max, max_coop_heap, MaxRAMPercentage);\n@@ -1616,1 +1628,1 @@\n-          reasonable_max = MIN2(reasonable_max, max_coop_heap);\n+          reasonable_max = max_coop_heap;\n@@ -1622,2 +1634,2 @@\n-    log_trace(gc, heap)(\"  Maximum heap size %zu\", (size_t) reasonable_max);\n-    FLAG_SET_ERGO(MaxHeapSize, (size_t)reasonable_max);\n+    log_trace(gc, heap)(\"  Maximum heap size %zu\", reasonable_max);\n+    FLAG_SET_ERGO(MaxHeapSize, reasonable_max);\n@@ -1629,4 +1641,2 @@\n-    julong reasonable_minimum = (julong)(OldSize + NewSize);\n-\n-    reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);\n-\n+    size_t reasonable_minimum = clamp_by_size_t_max((uint64_t)OldSize + (uint64_t)NewSize);\n+    reasonable_minimum = MIN2(reasonable_minimum, MaxHeapSize);\n@@ -1636,1 +1646,2 @@\n-      julong reasonable_initial = (julong)(((double)phys_mem * InitialRAMPercentage) \/ 100);\n+      uint64_t initial_memory = (uint64_t)(((double)physical_memory * InitialRAMPercentage) \/ 100);\n+      size_t reasonable_initial = clamp_by_size_t_max(initial_memory);\n@@ -1639,2 +1650,2 @@\n-      reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)MinHeapSize);\n-      reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);\n+      reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, MinHeapSize);\n+      reasonable_initial = MIN2(reasonable_initial, MaxHeapSize);\n@@ -1645,0 +1656,1 @@\n+\n@@ -1648,1 +1660,1 @@\n-      FLAG_SET_ERGO(MinHeapSize, MIN2((size_t)reasonable_minimum, InitialHeapSize));\n+      FLAG_SET_ERGO(MinHeapSize, MIN2(reasonable_minimum, InitialHeapSize));\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":67,"deletions":55,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,4 +56,3 @@\n-  freeze_pinned_monitor = 4,\n-  freeze_exception = 5,\n-  freeze_not_mounted = 6,\n-  freeze_unsupported = 7\n+  freeze_exception = 4,\n+  freeze_not_mounted = 5,\n+  freeze_unsupported = 6\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-  values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_held_monitor_count_offset())), \"parent held monitor count\");\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,5 +82,0 @@\n-#ifdef _LP64\n-  int64_t   _parent_held_monitor_count;\n-#else\n-  int32_t   _parent_held_monitor_count;\n-#endif\n@@ -97,1 +92,0 @@\n-  static ByteSize parent_held_monitor_count_offset() { return byte_offset_of(ContinuationEntry, _parent_held_monitor_count); }\n@@ -106,1 +100,0 @@\n-  int64_t parent_held_monitor_count() const { return (int64_t)_parent_held_monitor_count; }\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1762,5 +1762,2 @@\n-  assert((current->held_monitor_count() == 0 && current->jni_monitor_count() == 0),\n-         \"Held monitor count should not be used for lightweight locking: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n-\n-  if (entry->is_pinned() || current->held_monitor_count() > 0) {\n-    log_develop_debug(continuations)(\"PINNED due to critical section\/hold monitor\");\n+  if (entry->is_pinned()) {\n+    log_develop_debug(continuations)(\"PINNED due to critical section\");\n@@ -1768,1 +1765,1 @@\n-    freeze_result res = entry->is_pinned() ? freeze_pinned_cs : freeze_pinned_monitor;\n+    const freeze_result res = freeze_pinned_cs;\n@@ -1825,2 +1822,0 @@\n-  } else if (thread->held_monitor_count() > 0) {\n-    return freeze_pinned_monitor;\n@@ -1862,1 +1857,0 @@\n-      intx monitor_count = entry->parent_held_monitor_count();\n@@ -1869,2 +1863,0 @@\n-      } else if (monitor_count > 0) {\n-        return freeze_pinned_monitor;\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -639,6 +639,1 @@\n-\n-  \/\/ If the deopt call site is a MethodHandle invoke call site we have\n-  \/\/ to adjust the unpack_sp.\n-  nmethod* deoptee_nm = deoptee.cb()->as_nmethod_or_null();\n-  if (deoptee_nm != nullptr && deoptee_nm->is_method_handle_return(deoptee.pc()))\n-    unpack_sp = deoptee.unextended_sp();\n+  assert(unpack_sp == deoptee.unextended_sp(), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,4 +213,1 @@\n-    if (nm->is_method_handle_return(pc()))\n-      return nm->deopt_mh_handler_begin() - pc_return_offset;\n-    else\n-      return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_begin() - pc_return_offset;\n@@ -365,3 +362,1 @@\n-  address deopt = nm->is_method_handle_return(pc()) ?\n-                        nm->deopt_mh_handler_begin() :\n-                        nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,4 @@\n-    return nm->get_original_pc(this);\n+    address original_pc = nm->get_original_pc(this);\n+    assert(nm->insts_contains_inclusive(original_pc),\n+           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n+    return original_pc;\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1595,0 +1595,3 @@\n+  product(bool, NMethodRelocation, false, EXPERIMENTAL,                     \\\n+          \"Enables use of experimental function nmethod::relocate()\")       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -480,1 +480,0 @@\n-  _is_method_handle_return(0),\n@@ -493,2 +492,0 @@\n-  _held_monitor_count(0),\n-  _jni_monitor_count(0),\n@@ -932,21 +929,0 @@\n-    \/\/ Check for monitor counts being out of sync.\n-    assert(held_monitor_count() == jni_monitor_count(),\n-           \"held monitor count should be equal to jni: %zd != %zd\",\n-           held_monitor_count(), jni_monitor_count());\n-    \/\/ All in-use monitors, including JNI-locked ones, should have been released above.\n-    assert(held_monitor_count() == 0, \"Failed to unlock %zd object monitors\",\n-           held_monitor_count());\n-  } else {\n-    \/\/ Check for monitor counts being out of sync.\n-    assert(held_monitor_count() == jni_monitor_count(),\n-           \"held monitor count should be equal to jni: %zd != %zd\",\n-           held_monitor_count(), jni_monitor_count());\n-    \/\/ It is possible that a terminating thread failed to unlock monitors it locked\n-    \/\/ via JNI so we don't assert the count is zero.\n-  }\n-\n-  if (CheckJNICalls && jni_monitor_count() > 0) {\n-    \/\/ We would like a fatal here, but due to we never checked this before there\n-    \/\/ is a lot of tests which breaks, even with an error log.\n-    log_debug(jni)(\"JavaThread %s (tid: %zu) with Objects still locked by JNI MonitorEnter.\",\n-                   exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n@@ -1993,20 +1969,0 @@\n-\/\/ Slow-path increment of the held monitor counts. JNI locking is always\n-\/\/ this slow-path.\n-void JavaThread::inc_held_monitor_count(intx i, bool jni) {\n-#ifdef SUPPORT_MONITOR_COUNT\n-  \/\/ Nothing to do. Just do some sanity check.\n-  assert(_held_monitor_count == 0, \"counter should not be used\");\n-  assert(_jni_monitor_count == 0, \"counter should not be used\");\n-#endif \/\/ SUPPORT_MONITOR_COUNT\n-}\n-\n-\/\/ Slow-path decrement of the held monitor counts. JNI unlocking is always\n-\/\/ this slow-path.\n-void JavaThread::dec_held_monitor_count(intx i, bool jni) {\n-#ifdef SUPPORT_MONITOR_COUNT\n-  \/\/ Nothing to do. Just do some sanity check.\n-  assert(_held_monitor_count == 0, \"counter should not be used\");\n-  assert(_jni_monitor_count == 0, \"counter should not be used\");\n-#endif \/\/ SUPPORT_MONITOR_COUNT\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -454,1 +454,0 @@\n-  volatile int     _is_method_handle_return;     \/\/ true (== 1) if the current exception PC is a MethodHandle call site.\n@@ -481,3 +480,0 @@\n-  \/\/ It's signed for error detection.\n-  intx _held_monitor_count;  \/\/ used by continuations for fast lock detection\n-  intx _jni_monitor_count;\n@@ -667,7 +663,0 @@\n-  void inc_held_monitor_count(intx i = 1, bool jni = false);\n-  void dec_held_monitor_count(intx i = 1, bool jni = false);\n-\n-  intx held_monitor_count() { return _held_monitor_count; }\n-  intx jni_monitor_count()  { return _jni_monitor_count;  }\n-  void clear_jni_monitor_count() { _jni_monitor_count = 0; }\n-\n@@ -824,1 +813,0 @@\n-  void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }\n@@ -874,1 +862,0 @@\n-  static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }\n@@ -908,2 +895,0 @@\n-  static ByteSize held_monitor_count_offset() { return byte_offset_of(JavaThread, _held_monitor_count); }\n-  static ByteSize jni_monitor_count_offset()  { return byte_offset_of(JavaThread, _jni_monitor_count); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,5 @@\n-NonJavaThread::List NonJavaThread::_the_list;\n+DeferredStatic<NonJavaThread::List> NonJavaThread::_the_list;\n+\n+void NonJavaThread::init() {\n+  _the_list.initialize();\n+}\n@@ -56,2 +60,2 @@\n-  _protect_enter(_the_list._protect.enter()),\n-  _current(AtomicAccess::load_acquire(&_the_list._head))\n+  _protect_enter(_the_list->_protect.enter()),\n+  _current(AtomicAccess::load_acquire(&_the_list->_head))\n@@ -61,1 +65,1 @@\n-  _the_list._protect.exit(_protect_enter);\n+  _the_list->_protect.exit(_protect_enter);\n@@ -79,2 +83,2 @@\n-  AtomicAccess::release_store(&_next, _the_list._head);\n-  AtomicAccess::release_store(&_the_list._head, this);\n+  AtomicAccess::release_store(&_next, _the_list->_head);\n+  AtomicAccess::release_store(&_the_list->_head, this);\n@@ -88,1 +92,1 @@\n-    NonJavaThread* volatile* p = &_the_list._head;\n+    NonJavaThread* volatile* p = &_the_list->_head;\n@@ -100,1 +104,1 @@\n-  _the_list._protect.synchronize();\n+  _the_list->_protect.synchronize();\n@@ -347,1 +351,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/deferredStatic.hpp\"\n@@ -31,3 +32,1 @@\n-  friend class VMStructs;\n-\n-  NonJavaThread* volatile _next;\n+  friend class Threads;\n@@ -36,1 +35,6 @@\n-  static List _the_list;\n+  static DeferredStatic<List> _the_list;\n+\n+  \/\/ Deferred static initialization\n+  static void init();\n+\n+  NonJavaThread* volatile _next;\n@@ -106,1 +110,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1955,1 +1955,0 @@\n-  current->inc_held_monitor_count(relock_count); \/\/ Deopt never entered these counts.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -273,0 +273,40 @@\n+\n+#ifdef COMPILER2\n+\/\/ Runtime methods for printf-style debug nodes (same printing format as fieldDescriptor::print_on_for)\n+void SharedRuntime::debug_print_value(jboolean x) {\n+  tty->print_cr(\"boolean %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jbyte x) {\n+  tty->print_cr(\"byte %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jshort x) {\n+  tty->print_cr(\"short %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jchar x) {\n+  tty->print_cr(\"char %c %d\", isprint(x) ? x : ' ', x);\n+}\n+\n+void SharedRuntime::debug_print_value(jint x) {\n+  tty->print_cr(\"int %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jlong x) {\n+  tty->print_cr(\"long \" JLONG_FORMAT, x);\n+}\n+\n+void SharedRuntime::debug_print_value(jfloat x) {\n+  tty->print_cr(\"float %f\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jdouble x) {\n+  tty->print_cr(\"double %lf\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(oopDesc* x) {\n+  x->print();\n+}\n+#endif \/\/ COMPILER2\n+\n@@ -534,3 +574,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -551,2 +588,0 @@\n-    \/\/ Set flag if return address is a method handle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n@@ -2083,1 +2118,0 @@\n-      current->dec_held_monitor_count();\n@@ -2105,14 +2139,0 @@\n-\/\/ This is only called when CheckJNICalls is true, and only\n-\/\/ for virtual thread termination.\n-JRT_LEAF(void,  SharedRuntime::log_jni_monitor_still_held())\n-  assert(CheckJNICalls, \"Only call this when checking JNI usage\");\n-  if (log_is_enabled(Debug, jni)) {\n-    JavaThread* current = JavaThread::current();\n-    int64_t vthread_id = java_lang_Thread::thread_id(current->vthread());\n-    int64_t carrier_id = java_lang_Thread::thread_id(current->threadObj());\n-    log_debug(jni)(\"VirtualThread (tid: \" INT64_FORMAT \", carrier id: \" INT64_FORMAT\n-                   \") exiting with Objects still locked by JNI MonitorEnter.\",\n-                   vthread_id, carrier_id);\n-  }\n-JRT_END\n-\n@@ -2607,0 +2627,1 @@\n+volatile uint AdapterHandlerLibrary::_id_counter = 0;\n@@ -2699,1 +2720,3 @@\n-  return AdapterHandlerEntry::allocate(fingerprint);\n+  uint id = (uint)AtomicAccess::add((int*)&_id_counter, 1);\n+  assert(id > 0, \"we can never overflow because AOT cache cannot contain more than 2^32 methods\");\n+  return AdapterHandlerEntry::allocate(id, fingerprint);\n@@ -3183,2 +3206,2 @@\n-  const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n-  const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+  const char* name = AdapterHandlerLibrary::name(handler);\n+  const uint32_t id = AdapterHandlerLibrary::id(handler);\n@@ -3291,2 +3314,2 @@\n-    const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n-    const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+    const char* name = AdapterHandlerLibrary::name(handler);\n+    const uint32_t id = AdapterHandlerLibrary::id(handler);\n@@ -3437,0 +3460,1 @@\n+  uint max_id = 0;\n@@ -3438,1 +3462,7 @@\n-  _aot_adapter_handler_table.iterate([](AdapterHandlerEntry* entry) {\n+  \/* It is possible that some adapters generated in assembly phase are not stored in the cache.\n+   * That implies adapter ids of the adapters in the cache may not be contiguous.\n+   * If the size of the _aot_adapter_handler_table is used to initialize _id_counter, then it may\n+   * result in collision of adapter ids between AOT stored handlers and runtime generated handlers.\n+   * To avoid such situation, initialize the _id_counter with the largest adapter id among the AOT stored handlers.\n+   *\/\n+  _aot_adapter_handler_table.iterate([&](AdapterHandlerEntry* entry) {\n@@ -3441,0 +3471,1 @@\n+    max_id = MAX2(max_id, entry->id());\n@@ -3442,0 +3473,3 @@\n+  \/\/ Set adapter id to the maximum id found in the AOTCache\n+  assert(_id_counter == 0, \"Did not expect new AdapterHandlerEntry to be created at this stage\");\n+  _id_counter = max_id;\n@@ -3832,2 +3866,2 @@\n-const char* AdapterHandlerLibrary::name(AdapterFingerPrint* fingerprint) {\n-  return fingerprint->as_basic_args_string();\n+const char* AdapterHandlerLibrary::name(AdapterHandlerEntry* handler) {\n+  return handler->fingerprint()->as_basic_args_string();\n@@ -3836,3 +3870,2 @@\n-uint32_t AdapterHandlerLibrary::id(AdapterFingerPrint* fingerprint) {\n-  unsigned int hash = fingerprint->compute_hash();\n-  return hash;\n+uint32_t AdapterHandlerLibrary::id(AdapterHandlerEntry* handler) {\n+  return handler->id();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":64,"deletions":31,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -412,3 +413,0 @@\n-  \/\/ Issue UL warning for unlocked JNI monitor on virtual thread termination\n-  static void log_jni_monitor_still_held();\n-\n@@ -665,0 +663,33 @@\n+#ifdef COMPILER2\n+  \/\/ Runtime methods for printf-style debug nodes\n+  static void debug_print_value(jboolean x);\n+  static void debug_print_value(jbyte x);\n+  static void debug_print_value(jshort x);\n+  static void debug_print_value(jchar x);\n+  static void debug_print_value(jint x);\n+  static void debug_print_value(jlong x);\n+  static void debug_print_value(jfloat x);\n+  static void debug_print_value(jdouble x);\n+  static void debug_print_value(oopDesc* x);\n+\n+  template <typename T, typename... Rest>\n+  static void debug_print_rec(T arg, Rest... args) {\n+    debug_print_value(arg);\n+    debug_print_rec(args...);\n+  }\n+\n+  static void debug_print_rec() {}\n+\n+  \/\/ template is required here as we need to know the exact signature at compile-time\n+  template <typename... TT>\n+  static void debug_print(const char *str, TT... args) {\n+    \/\/ these three lines are the manual expansion of JRT_LEAF ... JRT_END, does not work well with templates\n+    DEBUG_ONLY(NoHandleMark __hm;)\n+    os::verify_stack_alignment();\n+    DEBUG_ONLY(NoSafepointVerifier __nsv;)\n+\n+    tty->print_cr(\"%s\", str);\n+    debug_print_rec(args...);\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -713,0 +744,1 @@\n+  uint _id;\n@@ -727,1 +759,1 @@\n-  AdapterHandlerEntry(AdapterFingerPrint* fingerprint) :\n+  AdapterHandlerEntry(int id, AdapterFingerPrint* fingerprint) :\n@@ -730,0 +762,1 @@\n+    _id(id),\n@@ -751,2 +784,2 @@\n-  static AdapterHandlerEntry* allocate(AdapterFingerPrint* fingerprint) {\n-    return new(0) AdapterHandlerEntry(fingerprint);\n+  static AdapterHandlerEntry* allocate(uint id, AdapterFingerPrint* fingerprint) {\n+    return new(0) AdapterHandlerEntry(id, fingerprint);\n@@ -834,0 +867,1 @@\n+  uint id() const { return _id; }\n@@ -862,0 +896,1 @@\n+  static volatile uint _id_counter; \/\/ counter for generating unique adapter ids, range = [1,UINT_MAX]\n@@ -901,2 +936,2 @@\n-  static const char* name(AdapterFingerPrint* fingerprint);\n-  static uint32_t id(AdapterFingerPrint* fingerprint);\n+  static const char* name(AdapterHandlerEntry* handler);\n+  static uint32_t id(AdapterHandlerEntry* handler);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":43,"deletions":8,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -484,1 +484,0 @@\n-      current->inc_held_monitor_count(1, true);\n@@ -503,1 +502,0 @@\n-    current->dec_held_monitor_count(1, true);\n@@ -1306,2 +1304,1 @@\n-    intx rec = mid->complete_exit(_thread);\n-    _thread->dec_held_monitor_count(rec + 1);\n+    mid->complete_exit(_thread);\n@@ -1333,3 +1330,0 @@\n-  assert(current->held_monitor_count() == 0, \"Should not be possible\");\n-  \/\/ All monitors (including entered via JNI) have been unlocked above, so we need to clear jni count.\n-  current->clear_jni_monitor_count();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,2 +64,0 @@\n-  current->dec_held_monitor_count();\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,0 +450,3 @@\n+  \/\/ Deferred \"static\" initialization\n+  NonJavaThread::init();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"oops\/instanceClassLoaderKlass.hpp\"\n@@ -65,1 +64,0 @@\n-#include \"oops\/instanceMirrorKlass.hpp\"\n@@ -67,1 +65,0 @@\n-#include \"oops\/instanceStackChunkKlass.hpp\"\n@@ -89,1 +86,0 @@\n-#include \"runtime\/java.hpp\"\n@@ -545,1 +541,0 @@\n-  nonstatic_field(nmethod,                     _deopt_mh_handler_offset,                      int)                                   \\\n@@ -617,1 +612,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n@@ -1723,1 +1717,0 @@\n-  declare_constant(PcDesc::PCDESC_is_method_handle_invoke)                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -323,2 +323,0 @@\n-  friend class VMStructs;\n-\n@@ -726,0 +724,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static char charAt(byte[] value, int index) {\n+    static char charAt(byte[] value, int index) {\n@@ -49,1 +49,1 @@\n-    public static boolean canEncode(char cp) {\n+    static boolean canEncode(char cp) {\n@@ -53,1 +53,1 @@\n-    public static boolean canEncode(int cp) {\n+    static boolean canEncode(int cp) {\n@@ -57,1 +57,1 @@\n-    public static byte coderFromChar(char cp) {\n+    static byte coderFromChar(char cp) {\n@@ -61,1 +61,1 @@\n-    public static int length(byte[] value) {\n+    static int length(byte[] value) {\n@@ -65,13 +65,1 @@\n-    public static int codePointAt(byte[] value, int index, int end) {\n-        return value[index] & 0xff;\n-    }\n-\n-    public static int codePointBefore(byte[] value, int index) {\n-        return value[index - 1] & 0xff;\n-    }\n-\n-    public static int codePointCount(byte[] value, int beginIndex, int endIndex) {\n-        return endIndex - beginIndex;\n-    }\n-\n-    public static char[] toChars(byte[] value) {\n+    static char[] toChars(byte[] value) {\n@@ -83,1 +71,1 @@\n-    public static byte[] inflate(byte[] value, int off, int len) {\n+    static byte[] inflate(byte[] value, int off, int len) {\n@@ -89,1 +77,1 @@\n-    public static void getChars(byte[] value, int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n+    static void getChars(byte[] value, int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n@@ -93,1 +81,1 @@\n-    public static void getBytes(byte[] value, int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n+    static void getBytes(byte[] value, int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n@@ -98,1 +86,1 @@\n-    public static boolean equals(byte[] value, byte[] other) {\n+    static boolean equals(byte[] value, byte[] other) {\n@@ -111,1 +99,1 @@\n-    public static int compareTo(byte[] value, byte[] other) {\n+    static int compareTo(byte[] value, byte[] other) {\n@@ -117,1 +105,1 @@\n-    public static int compareTo(byte[] value, byte[] other, int len1, int len2) {\n+    static int compareTo(byte[] value, byte[] other, int len1, int len2) {\n@@ -124,1 +112,1 @@\n-    public static int compareToUTF16(byte[] value, byte[] other) {\n+    static int compareToUTF16(byte[] value, byte[] other) {\n@@ -133,1 +121,1 @@\n-    public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2) {\n+    static int compareToUTF16(byte[] value, byte[] other, int len1, int len2) {\n@@ -152,1 +140,1 @@\n-    public static int compareToCI(byte[] value, byte[] other) {\n+    static int compareToCI(byte[] value, byte[] other) {\n@@ -172,1 +160,1 @@\n-    public static int compareToCI_UTF16(byte[] value, byte[] other) {\n+    static int compareToCI_UTF16(byte[] value, byte[] other) {\n@@ -194,1 +182,1 @@\n-    public static int hashCode(byte[] value) {\n+    static int hashCode(byte[] value) {\n@@ -199,1 +187,1 @@\n-    public static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n+    static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n@@ -218,1 +206,1 @@\n-    public static int indexOf(byte[] value, byte[] str) {\n+    static int indexOf(byte[] value, byte[] str) {\n@@ -229,1 +217,1 @@\n-    public static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) {\n+    static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) {\n@@ -251,2 +239,2 @@\n-    public static int lastIndexOf(byte[] src, int srcCount,\n-                                  byte[] tgt, int tgtCount, int fromIndex) {\n+    static int lastIndexOf(byte[] src, int srcCount,\n+                           byte[] tgt, int tgtCount, int fromIndex) {\n@@ -279,1 +267,1 @@\n-    public static int lastIndexOf(final byte[] value, int ch, int fromIndex) {\n+    static int lastIndexOf(final byte[] value, int ch, int fromIndex) {\n@@ -292,1 +280,1 @@\n-    public static String replace(byte[] value, char oldChar, char newChar) {\n+    static String replace(byte[] value, char oldChar, char newChar) {\n@@ -329,2 +317,2 @@\n-    public static String replace(byte[] value, int valLen, byte[] targ,\n-                                 int targLen, byte[] repl, int replLen)\n+    static String replace(byte[] value, int valLen, byte[] targ,\n+                          int targLen, byte[] repl, int replLen)\n@@ -380,2 +368,2 @@\n-    public static boolean regionMatchesCI(byte[] value, int toffset,\n-                                          byte[] other, int ooffset, int len) {\n+    static boolean regionMatchesCI(byte[] value, int toffset,\n+                                   byte[] other, int ooffset, int len) {\n@@ -394,2 +382,2 @@\n-    public static boolean regionMatchesCI_UTF16(byte[] value, int toffset,\n-                                                byte[] other, int ooffset, int len) {\n+    static boolean regionMatchesCI_UTF16(byte[] value, int toffset,\n+                                         byte[] other, int ooffset, int len) {\n@@ -416,1 +404,1 @@\n-    public static String toLowerCase(String str, byte[] value, Locale locale) {\n+    static String toLowerCase(String str, byte[] value, Locale locale) {\n@@ -483,1 +471,1 @@\n-    public static String toUpperCase(String str, byte[] value, Locale locale) {\n+    static String toUpperCase(String str, byte[] value, Locale locale) {\n@@ -563,1 +551,1 @@\n-    public static String trim(byte[] value) {\n+    static String trim(byte[] value) {\n@@ -576,1 +564,1 @@\n-    public static int indexOfNonWhitespace(byte[] value) {\n+    static int indexOfNonWhitespace(byte[] value) {\n@@ -589,3 +577,2 @@\n-    public static int lastIndexOfNonWhitespace(byte[] value) {\n-        int length = value.length;\n-        int right = length;\n+    static int lastIndexOfNonWhitespace(byte[] value) {\n+        int right = value.length;\n@@ -602,1 +589,1 @@\n-    public static String strip(byte[] value) {\n+    static String strip(byte[] value) {\n@@ -612,1 +599,1 @@\n-    public static String stripLeading(byte[] value) {\n+    static String stripLeading(byte[] value) {\n@@ -617,1 +604,1 @@\n-    public static String stripTrailing(byte[] value) {\n+    static String stripTrailing(byte[] value) {\n@@ -716,1 +703,1 @@\n-    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n+    static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n@@ -723,1 +710,1 @@\n-    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n+    static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n@@ -731,6 +718,1 @@\n-    public static void putChar(byte[] val, int index, int c) {\n-        \/\/assert (canEncode(c));\n-        val[index] = (byte)(c);\n-    }\n-\n-    public static char getChar(byte[] val, int index) {\n+    static char getChar(byte[] val, int index) {\n@@ -740,13 +722,1 @@\n-    public static byte[] toBytes(int[] val, int off, int len) {\n-        byte[] ret = new byte[len];\n-        for (int i = 0; i < len; i++) {\n-            int cp = val[off++];\n-            if (!canEncode(cp)) {\n-                return null;\n-            }\n-            ret[i] = (byte)cp;\n-        }\n-        return ret;\n-    }\n-\n-    public static byte[] toBytes(char c) {\n+    static byte[] toBytes(char c) {\n@@ -756,1 +726,1 @@\n-    public static String newString(byte[] val, int index, int len) {\n+    static String newString(byte[] val, int index, int len) {\n@@ -766,1 +736,1 @@\n-    public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+    static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n@@ -774,1 +744,1 @@\n-    public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+    static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -827,1 +797,1 @@\n-        public long estimateSize() { return (long)(fence - index); }\n+        public long estimateSize() { return fence - index; }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":47,"deletions":77,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    public static byte[] newBytesFor(int len) {\n+    static byte[] newBytesFor(int len) {\n@@ -63,1 +63,1 @@\n-    public static int newBytesLength(int len) {\n+    static int newBytesLength(int len) {\n@@ -92,1 +92,1 @@\n-    public static int length(byte[] value) {\n+    static int length(byte[] value) {\n@@ -114,1 +114,1 @@\n-    public static int codePointAt(byte[] value, int index, int end) {\n+    static int codePointAt(byte[] value, int index, int end) {\n@@ -137,1 +137,1 @@\n-    public static int codePointBefore(byte[] value, int index) {\n+    static int codePointBefore(byte[] value, int index) {\n@@ -158,1 +158,1 @@\n-    public static int codePointCount(byte[] value, int beginIndex, int endIndex) {\n+    static int codePointCount(byte[] value, int beginIndex, int endIndex) {\n@@ -162,1 +162,1 @@\n-    public static char[] toChars(byte[] value) {\n+    static char[] toChars(byte[] value) {\n@@ -176,1 +176,1 @@\n-    public static byte[] toBytes(char[] value, int off, int len) {\n+    static byte[] toBytes(char[] value, int off, int len) {\n@@ -221,1 +221,1 @@\n-    public static byte[] compress(final char[] val, final int off, final int count) {\n+    static byte[] compress(final char[] val, final int off, final int count) {\n@@ -248,1 +248,1 @@\n-    public static byte[] compress(final byte[] val, final int off, final int count) {\n+    static byte[] compress(final byte[] val, final int off, final int count) {\n@@ -282,1 +282,1 @@\n-    public static byte[] compress(final int[] val, int off, final int count) {\n+    static byte[] compress(final int[] val, int off, final int count) {\n@@ -392,1 +392,1 @@\n-    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+    static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -407,1 +407,1 @@\n-    public static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+    static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -423,1 +423,1 @@\n-    public static byte[] toBytes(int[] val, int index, int len) {\n+    static byte[] toBytes(int[] val, int index, int len) {\n@@ -431,1 +431,1 @@\n-    public static byte[] toBytes(char c) {\n+    static byte[] toBytes(char c) {\n@@ -445,1 +445,1 @@\n-    public static void getChars(byte[] value, int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n+    static void getChars(byte[] value, int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n@@ -456,1 +456,1 @@\n-    public static void getBytes(byte[] value, int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n+    static void getBytes(byte[] value, int srcBegin, int srcEnd, byte[] dst, int dstBegin) {\n@@ -465,1 +465,1 @@\n-    public static int compareTo(byte[] value, byte[] other) {\n+    static int compareTo(byte[] value, byte[] other) {\n@@ -474,1 +474,1 @@\n-    public static int compareTo(byte[] value, byte[] other, int len1, int len2) {\n+    static int compareTo(byte[] value, byte[] other, int len1, int len2) {\n@@ -494,1 +494,1 @@\n-    public static int compareToLatin1(byte[] value, byte[] other) {\n+    static int compareToLatin1(byte[] value, byte[] other) {\n@@ -498,1 +498,1 @@\n-    public static int compareToLatin1(byte[] value, byte[] other, int len1, int len2) {\n+    static int compareToLatin1(byte[] value, byte[] other, int len1, int len2) {\n@@ -502,1 +502,1 @@\n-    public static int compareToCI(byte[] value, byte[] other) {\n+    static int compareToCI(byte[] value, byte[] other) {\n@@ -515,2 +515,2 @@\n-            int cp1 = (int)getChar(value, k1);\n-            int cp2 = (int)getChar(other, k2);\n+            int cp1 = getChar(value, k1);\n+            int cp2 = getChar(other, k2);\n@@ -591,1 +591,1 @@\n-    public static int compareToCI_Latin1(byte[] value, byte[] other) {\n+    static int compareToCI_Latin1(byte[] value, byte[] other) {\n@@ -595,1 +595,1 @@\n-    public static int hashCode(byte[] value) {\n+    static int hashCode(byte[] value) {\n@@ -600,1 +600,1 @@\n-    public static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n+    static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n@@ -611,1 +611,1 @@\n-    public static int indexOf(byte[] value, byte[] str) {\n+    static int indexOf(byte[] value, byte[] str) {\n@@ -622,1 +622,1 @@\n-    public static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) {\n+    static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) {\n@@ -660,1 +660,1 @@\n-    public static int indexOfLatin1(byte[] value, byte[] str) {\n+    static int indexOfLatin1(byte[] value, byte[] str) {\n@@ -671,1 +671,1 @@\n-    public static int indexOfLatin1(byte[] src, int srcCount, byte[] tgt, int tgtCount, int fromIndex) {\n+    static int indexOfLatin1(byte[] src, int srcCount, byte[] tgt, int tgtCount, int fromIndex) {\n@@ -677,1 +677,1 @@\n-    public static int indexOfLatin1Unsafe(byte[] src, int srcCount, byte[] tgt, int tgtCount, int fromIndex) {\n+    static int indexOfLatin1Unsafe(byte[] src, int srcCount, byte[] tgt, int tgtCount, int fromIndex) {\n@@ -733,2 +733,2 @@\n-    public static int lastIndexOf(byte[] src, int srcCount,\n-                                  byte[] tgt, int tgtCount, int fromIndex) {\n+    static int lastIndexOf(byte[] src, int srcCount,\n+                           byte[] tgt, int tgtCount, int fromIndex) {\n@@ -768,1 +768,1 @@\n-    public static int lastIndexOf(byte[] value, int ch, int fromIndex) {\n+    static int lastIndexOf(byte[] value, int ch, int fromIndex) {\n@@ -801,1 +801,1 @@\n-    public static String replace(byte[] value, char oldChar, char newChar) {\n+    static String replace(byte[] value, char oldChar, char newChar) {\n@@ -832,3 +832,3 @@\n-    public static String replace(byte[] value, int valLen, boolean valLat1,\n-                                 byte[] targ, int targLen, boolean targLat1,\n-                                 byte[] repl, int replLen, boolean replLat1)\n+    static String replace(byte[] value, int valLen, boolean valLat1,\n+                          byte[] targ, int targLen, boolean targLat1,\n+                          byte[] repl, int replLen, boolean replLat1)\n@@ -947,2 +947,2 @@\n-    public static boolean regionMatchesCI(byte[] value, int toffset,\n-                                          byte[] other, int ooffset, int len) {\n+    static boolean regionMatchesCI(byte[] value, int toffset,\n+                                   byte[] other, int ooffset, int len) {\n@@ -952,3 +952,3 @@\n-    public static boolean regionMatchesCI_Latin1(byte[] value, int toffset,\n-                                                 byte[] other, int ooffset,\n-                                                 int len) {\n+    static boolean regionMatchesCI_Latin1(byte[] value, int toffset,\n+                                          byte[] other, int ooffset,\n+                                          int len) {\n@@ -958,1 +958,1 @@\n-    public static String toLowerCase(String str, byte[] value, Locale locale) {\n+    static String toLowerCase(String str, byte[] value, Locale locale) {\n@@ -968,1 +968,1 @@\n-            int cp = (int)getChar(value, first);\n+            int cp = getChar(value, first);\n@@ -991,1 +991,1 @@\n-            int cp = (int)getChar(value, i);\n+            int cp = getChar(value, i);\n@@ -1006,1 +1006,1 @@\n-        if (bits < 0 || bits > 0xff) {\n+        if (bits > 0xff) {\n@@ -1062,1 +1062,1 @@\n-    public static String toUpperCase(String str, byte[] value, Locale locale) {\n+    static String toUpperCase(String str, byte[] value, Locale locale) {\n@@ -1072,1 +1072,1 @@\n-            int cp = (int)getChar(value, first);\n+            int cp = getChar(value, first);\n@@ -1096,1 +1096,1 @@\n-            int cp = (int)getChar(value, i);\n+            int cp = getChar(value, i);\n@@ -1107,1 +1107,1 @@\n-        if (bits < 0 || bits > 0xff) {\n+        if (bits > 0xff) {\n@@ -1167,1 +1167,1 @@\n-    public static String trim(byte[] value) {\n+    static String trim(byte[] value) {\n@@ -1182,1 +1182,1 @@\n-    public static int indexOfNonWhitespace(byte[] value) {\n+    static int indexOfNonWhitespace(byte[] value) {\n@@ -1195,3 +1195,2 @@\n-    public static int lastIndexOfNonWhitespace(byte[] value) {\n-        int length = value.length >>> 1;\n-        int right = length;\n+    static int lastIndexOfNonWhitespace(byte[] value) {\n+        int right = value.length >>> 1;\n@@ -1208,1 +1207,1 @@\n-    public static String strip(byte[] value) {\n+    static String strip(byte[] value) {\n@@ -1219,1 +1218,1 @@\n-    public static String stripLeading(byte[] value) {\n+    static String stripLeading(byte[] value) {\n@@ -1225,1 +1224,1 @@\n-    public static String stripTrailing(byte[] value) {\n+    static String stripTrailing(byte[] value) {\n@@ -1325,1 +1324,1 @@\n-    public static String newString(byte[] val, int index, int len) {\n+    static String newString(byte[] val, int index, int len) {\n@@ -1391,1 +1390,1 @@\n-        public long estimateSize() { return (long)(fence - index); }\n+        public long estimateSize() { return fence - index; }\n@@ -1476,1 +1475,1 @@\n-        public long estimateSize() { return (long)(fence - index); }\n+        public long estimateSize() { return fence - index; }\n@@ -1486,1 +1485,1 @@\n-    public static void putCharSB(byte[] val, int index, int c) {\n+    static void putCharSB(byte[] val, int index, int c) {\n@@ -1491,1 +1490,1 @@\n-    public static void putCharsSB(byte[] val, int index, char[] ca, int off, int end) {\n+    static void putCharsSB(byte[] val, int index, char[] ca, int off, int end) {\n@@ -1502,1 +1501,1 @@\n-    public static void putCharsSB(byte[] val, int index, CharSequence s, int off, int end) {\n+    static void putCharsSB(byte[] val, int index, CharSequence s, int off, int end) {\n@@ -1509,1 +1508,1 @@\n-    public static int codePointAtSB(byte[] val, int index, int end) {\n+    static int codePointAtSB(byte[] val, int index, int end) {\n@@ -1513,1 +1512,1 @@\n-    public static int codePointBeforeSB(byte[] val, int index) {\n+    static int codePointBeforeSB(byte[] val, int index) {\n@@ -1517,1 +1516,1 @@\n-    public static int codePointCountSB(byte[] val, int beginIndex, int endIndex) {\n+    static int codePointCountSB(byte[] val, int beginIndex, int endIndex) {\n@@ -1521,1 +1520,1 @@\n-    public static boolean contentEquals(byte[] v1, byte[] v2, int len) {\n+    static boolean contentEquals(byte[] v1, byte[] v2, int len) {\n@@ -1531,1 +1530,1 @@\n-    public static boolean contentEquals(byte[] value, CharSequence cs, int len) {\n+    static boolean contentEquals(byte[] value, CharSequence cs, int len) {\n@@ -1541,1 +1540,1 @@\n-    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n+    static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4) {\n@@ -1550,1 +1549,1 @@\n-    public static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n+    static void putCharsAt(byte[] value, int i, char c1, char c2, char c3, char c4, char c5) {\n@@ -1560,1 +1559,1 @@\n-    public static char charAt(byte[] value, int index) {\n+    static char charAt(byte[] value, int index) {\n@@ -1565,1 +1564,1 @@\n-    public static void reverse(byte[] val, int count) {\n+    static void reverse(byte[] val, int count) {\n@@ -1600,1 +1599,1 @@\n-    public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+    static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -1609,1 +1608,1 @@\n-    public static int lastIndexOfLatin1(byte[] src, int srcCount,\n+    static int lastIndexOfLatin1(byte[] src, int srcCount,\n@@ -1662,1 +1661,1 @@\n-    public static void checkIndex(int off, byte[] val) {\n+    static void checkIndex(int off, byte[] val) {\n@@ -1666,1 +1665,1 @@\n-    public static void checkOffset(int off, byte[] val) {\n+    static void checkOffset(int off, byte[] val) {\n@@ -1670,1 +1669,1 @@\n-    public static void checkBoundsBeginEnd(int begin, int end, byte[] val) {\n+    static void checkBoundsBeginEnd(int begin, int end, byte[] val) {\n@@ -1674,1 +1673,1 @@\n-    public static void checkBoundsOffCount(int offset, int count, byte[] val) {\n+    static void checkBoundsOffCount(int offset, int count, byte[] val) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":80,"deletions":81,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-     * @param invocationName unused\n+     * @param invocationName unused, {@code null} is permitted\n@@ -175,1 +175,1 @@\n-     * @throws NullPointerException     if any argument is {@code null}\n+     * @throws NullPointerException     if any argument is {@code null}, unless noted otherwise\n@@ -178,1 +178,1 @@\n-     *                                  second parameter of type {@code int} and with {@code int} as its return type,\n+     *                                  second parameter of type {@code int} and with {@code int} as its return type\n@@ -181,1 +181,1 @@\n-     *                                  {@code Class} or {@code EnumDesc}.\n+     *                                  {@code Class} or {@code EnumDesc}\n@@ -183,1 +183,1 @@\n-     *                                  when {@code target} is a {@code Boolean.class}.\n+     *                                  when {@code target} is a {@code Boolean.class}\n@@ -258,2 +258,3 @@\n-     * If no element in the {@code labels} array matches the target, then\n-     * the method of the call site return the length of the {@code labels} array.\n+     * If for a given {@code target} there is no element in the {@code labels}\n+     * fulfilling one of the above conditions, then the method of the call\n+     * site returns the length of the {@code labels} array.\n@@ -263,1 +264,4 @@\n-     * both  or an {@link IndexOutOfBoundsException} is thrown.\n+     * or an {@link IndexOutOfBoundsException} is thrown.\n+     *\n+     * @apiNote It is permissible for the {@code labels} array to contain {@code String}\n+     * values that do not represent any enum constants at runtime.\n@@ -268,1 +272,1 @@\n-     * @param invocationName unused\n+     * @param invocationName unused, {@code null} is permitted\n@@ -275,6 +279,9 @@\n-     * @throws NullPointerException if any argument is {@code null}\n-     * @throws IllegalArgumentException if any element in the labels array is null, if the\n-     * invocation type is not a method type whose first parameter type is an enum type,\n-     * second parameter of type {@code int} and whose return type is {@code int},\n-     * or if {@code labels} contains an element that is not of type {@code String} or\n-     * {@code Class} of the target enum type.\n+     * @throws NullPointerException     if any argument is {@code null}, unless noted otherwise\n+     * @throws IllegalArgumentException if any element in the labels array is null\n+     * @throws IllegalArgumentException if any element in the labels array is an empty {@code String}\n+     * @throws IllegalArgumentException if the invocation type is not a method type\n+     *                                  whose first parameter type is an enum type,\n+     *                                  second parameter of type {@code int} and\n+     *                                  whose return type is {@code int}\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code String} or\n+     *                                  {@code Class} equal to the target enum type\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.internal.misc.ThreadTracker;\n@@ -1397,11 +1396,1 @@\n-    private static class ThreadTrackHolder {\n-        static final ThreadTracker TRACKER = new ThreadTracker();\n-    }\n-\n-    private static Object tryBeginLookup() {\n-        return ThreadTrackHolder.TRACKER.tryBegin();\n-    }\n-\n-    private static void endLookup(Object key) {\n-        ThreadTrackHolder.TRACKER.end(key);\n-    }\n+    private static final ScopedValue<Boolean> IN_LOOKUP = ScopedValue.newInstance();\n@@ -1410,2 +1399,1 @@\n-        Object key = tryBeginLookup();\n-        if (key == null) {\n+        if (IN_LOOKUP.isBound()) {\n@@ -1414,1 +1402,1 @@\n-        try {\n+        return ScopedValue.where(IN_LOOKUP, true).call(() -> {\n@@ -1426,3 +1414,1 @@\n-        } finally {\n-            endLookup(key);\n-        }\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/net\/URL.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1940,1 +1940,1 @@\n-                TemporalField field = FIELD_MAP.get(cur);\n+                TemporalField field = getField(cur);\n@@ -2188,3 +2188,7 @@\n-    \/** Map of letters to fields. *\/\n-    private static final Map<Character, TemporalField> FIELD_MAP = new HashMap<>();\n-    static {\n+    \/**\n+     * Returns the TemporalField for the given pattern character.\n+     *\n+     * @param ch the pattern character\n+     * @return the TemporalField for the given pattern character, or null if not applicable\n+     *\/\n+    private static TemporalField getField(char ch) {\n@@ -2192,38 +2196,41 @@\n-        FIELD_MAP.put('G', ChronoField.ERA);                       \/\/ SDF, LDML (different to both for 1\/2 chars)\n-        FIELD_MAP.put('y', ChronoField.YEAR_OF_ERA);               \/\/ SDF, LDML\n-        FIELD_MAP.put('u', ChronoField.YEAR);                      \/\/ LDML (different in SDF)\n-        FIELD_MAP.put('Q', IsoFields.QUARTER_OF_YEAR);             \/\/ LDML (removed quarter from 310)\n-        FIELD_MAP.put('q', IsoFields.QUARTER_OF_YEAR);             \/\/ LDML (stand-alone)\n-        FIELD_MAP.put('M', ChronoField.MONTH_OF_YEAR);             \/\/ SDF, LDML\n-        FIELD_MAP.put('L', ChronoField.MONTH_OF_YEAR);             \/\/ SDF, LDML (stand-alone)\n-        FIELD_MAP.put('D', ChronoField.DAY_OF_YEAR);               \/\/ SDF, LDML\n-        FIELD_MAP.put('d', ChronoField.DAY_OF_MONTH);              \/\/ SDF, LDML\n-        FIELD_MAP.put('F', ChronoField.ALIGNED_WEEK_OF_MONTH);     \/\/ SDF, LDML\n-        FIELD_MAP.put('E', ChronoField.DAY_OF_WEEK);               \/\/ SDF, LDML (different to both for 1\/2 chars)\n-        FIELD_MAP.put('c', ChronoField.DAY_OF_WEEK);               \/\/ LDML (stand-alone)\n-        FIELD_MAP.put('e', ChronoField.DAY_OF_WEEK);               \/\/ LDML (needs localized week number)\n-        FIELD_MAP.put('a', ChronoField.AMPM_OF_DAY);               \/\/ SDF, LDML\n-        FIELD_MAP.put('H', ChronoField.HOUR_OF_DAY);               \/\/ SDF, LDML\n-        FIELD_MAP.put('k', ChronoField.CLOCK_HOUR_OF_DAY);         \/\/ SDF, LDML\n-        FIELD_MAP.put('K', ChronoField.HOUR_OF_AMPM);              \/\/ SDF, LDML\n-        FIELD_MAP.put('h', ChronoField.CLOCK_HOUR_OF_AMPM);        \/\/ SDF, LDML\n-        FIELD_MAP.put('m', ChronoField.MINUTE_OF_HOUR);            \/\/ SDF, LDML\n-        FIELD_MAP.put('s', ChronoField.SECOND_OF_MINUTE);          \/\/ SDF, LDML\n-        FIELD_MAP.put('S', ChronoField.NANO_OF_SECOND);            \/\/ LDML (SDF uses milli-of-second number)\n-        FIELD_MAP.put('A', ChronoField.MILLI_OF_DAY);              \/\/ LDML\n-        FIELD_MAP.put('n', ChronoField.NANO_OF_SECOND);            \/\/ 310 (proposed for LDML)\n-        FIELD_MAP.put('N', ChronoField.NANO_OF_DAY);               \/\/ 310 (proposed for LDML)\n-        FIELD_MAP.put('g', JulianFields.MODIFIED_JULIAN_DAY);\n-        \/\/ 310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4\n-        \/\/ 310 - Z - matches SimpleDateFormat and LDML\n-        \/\/ 310 - V - time-zone id, matches LDML\n-        \/\/ 310 - v - general timezone names, not matching exactly with LDML because LDML specify to fall back\n-        \/\/           to 'VVVV' if general-nonlocation unavailable but here it's not falling back because of lack of data\n-        \/\/ 310 - p - prefix for padding\n-        \/\/ 310 - X - matches LDML, almost matches SDF for 1, exact match 2&3, extended 4&5\n-        \/\/ 310 - x - matches LDML\n-        \/\/ 310 - w, W, and Y are localized forms matching LDML\n-        \/\/ LDML - B - day periods\n-        \/\/ LDML - U - cycle year name, not supported by 310 yet\n-        \/\/ LDML - l - deprecated\n-        \/\/ LDML - j - not relevant\n+        return switch (ch) {\n+            case 'G' -> ChronoField.ERA;                       \/\/ SDF, LDML (different to both for 1\/2 chars)\n+            case 'y' -> ChronoField.YEAR_OF_ERA;               \/\/ SDF, LDML\n+            case 'u' -> ChronoField.YEAR;                      \/\/ LDML (different in SDF)\n+            case 'Q' -> IsoFields.QUARTER_OF_YEAR;             \/\/ LDML (removed quarter from 310)\n+            case 'q' -> IsoFields.QUARTER_OF_YEAR;             \/\/ LDML (stand-alone)\n+            case 'M' -> ChronoField.MONTH_OF_YEAR;             \/\/ SDF, LDML\n+            case 'L' -> ChronoField.MONTH_OF_YEAR;             \/\/ SDF, LDML (stand-alone)\n+            case 'D' -> ChronoField.DAY_OF_YEAR;               \/\/ SDF, LDML\n+            case 'd' -> ChronoField.DAY_OF_MONTH;              \/\/ SDF, LDML\n+            case 'F' -> ChronoField.ALIGNED_WEEK_OF_MONTH;     \/\/ SDF, LDML\n+            case 'E' -> ChronoField.DAY_OF_WEEK;               \/\/ SDF, LDML (different to both for 1\/2 chars)\n+            case 'c' -> ChronoField.DAY_OF_WEEK;               \/\/ LDML (stand-alone)\n+            case 'e' -> ChronoField.DAY_OF_WEEK;               \/\/ LDML (needs localized week number)\n+            case 'a' -> ChronoField.AMPM_OF_DAY;               \/\/ SDF, LDML\n+            case 'H' -> ChronoField.HOUR_OF_DAY;               \/\/ SDF, LDML\n+            case 'k' -> ChronoField.CLOCK_HOUR_OF_DAY;         \/\/ SDF, LDML\n+            case 'K' -> ChronoField.HOUR_OF_AMPM;              \/\/ SDF, LDML\n+            case 'h' -> ChronoField.CLOCK_HOUR_OF_AMPM;        \/\/ SDF, LDML\n+            case 'm' -> ChronoField.MINUTE_OF_HOUR;            \/\/ SDF, LDML\n+            case 's' -> ChronoField.SECOND_OF_MINUTE;          \/\/ SDF, LDML\n+            case 'S' -> ChronoField.NANO_OF_SECOND;            \/\/ LDML (SDF uses milli-of-second number)\n+            case 'A' -> ChronoField.MILLI_OF_DAY;              \/\/ LDML\n+            case 'n' -> ChronoField.NANO_OF_SECOND;            \/\/ 310 (proposed for LDML)\n+            case 'N' -> ChronoField.NANO_OF_DAY;               \/\/ 310 (proposed for LDML)\n+            case 'g' -> JulianFields.MODIFIED_JULIAN_DAY;\n+            default -> null;\n+            \/\/ 310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4\n+            \/\/ 310 - Z - matches SimpleDateFormat and LDML\n+            \/\/ 310 - V - time-zone id, matches LDML\n+            \/\/ 310 - v - general timezone names, not matching exactly with LDML because LDML specify to fall back\n+            \/\/           to 'VVVV' if general-nonlocation unavailable but here it's not falling back because of lack of data\n+            \/\/ 310 - p - prefix for padding\n+            \/\/ 310 - X - matches LDML, almost matches SDF for 1, exact match 2&3, extended 4&5\n+            \/\/ 310 - x - matches LDML\n+            \/\/ 310 - w, W, and Y are localized forms matching LDML\n+            \/\/ LDML - B - day periods\n+            \/\/ LDML - U - cycle year name, not supported by 310 yet\n+            \/\/ LDML - l - deprecated\n+            \/\/ LDML - j - not relevant\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":49,"deletions":42,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -289,1 +289,26 @@\n-    private static final String SHA512TRUNCATED = \"SHA512\/2\";\n+    \/\/ for special handling SHA-512\/224, SHA-512\/256, SHA512\/224, SHA512\/256\n+    static int indexOfRealSlash(String s, int fromIndex) {\n+        while (true) {\n+            int pos = s.indexOf('\/', fromIndex);\n+            \/\/ 512\/2\n+            if (pos > 3 && pos + 1 < s.length()\n+                    && s.charAt(pos - 3) == '5'\n+                    && s.charAt(pos - 2) == '1'\n+                    && s.charAt(pos - 1) == '2'\n+                    && s.charAt(pos + 1) == '2') {\n+                fromIndex = pos + 1;\n+                \/\/ see 512\/2, find next\n+            } else {\n+                return pos;\n+            }\n+        }\n+    }\n+\n+    static String reqNonEmpty(String in, String msg)\n+            throws NoSuchAlgorithmException {\n+        in = in.trim();\n+        if (in.isEmpty()) {\n+            throw new NoSuchAlgorithmException(msg);\n+        }\n+        return in;\n+    }\n@@ -308,16 +333,15 @@\n-\n-        \/\/ check if the transformation contains algorithms with \"\/\" in their\n-        \/\/ name which can cause the parsing logic to go wrong\n-        int sha512Idx = transformation.toUpperCase(Locale.ENGLISH)\n-                .indexOf(SHA512TRUNCATED);\n-        int startIdx = (sha512Idx == -1 ? 0 :\n-                sha512Idx + SHA512TRUNCATED.length());\n-        int endIdx = transformation.indexOf('\/', startIdx);\n-\n-        boolean algorithmOnly = (endIdx == -1);\n-        String algo = (algorithmOnly ? transformation.trim() :\n-                transformation.substring(0, endIdx).trim());\n-        if (algo.isEmpty()) {\n-            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n-                                   \"algorithm not specified-\"\n-                                   + transformation);\n+        int endIdx = indexOfRealSlash(transformation, 0);\n+        if (endIdx == -1) { \/\/ algo only, done\n+            return new String[] { reqNonEmpty(transformation,\n+                        \"Invalid transformation: algorithm not specified\")\n+            };\n+        }\n+        \/\/ must be algo\/mode\/padding\n+        String algo = reqNonEmpty(transformation.substring(0, endIdx),\n+                    \"Invalid transformation: algorithm not specified\");\n+\n+        int startIdx = endIdx + 1;\n+        endIdx = indexOfRealSlash(transformation, startIdx);\n+        if (endIdx == -1) {\n+            throw new NoSuchAlgorithmException(\n+                    \"Invalid transformation format: \" + transformation);\n@@ -325,2 +349,9 @@\n-        if (algorithmOnly) { \/\/ done\n-            return new String[] { algo };\n+        String mode = reqNonEmpty(transformation.substring(startIdx,\n+                endIdx), \"Invalid transformation: missing mode\");\n+\n+        startIdx = endIdx + 1;\n+        endIdx = indexOfRealSlash(transformation, startIdx);\n+        if (endIdx == -1) {\n+            return new String[] { algo, mode,\n+                    reqNonEmpty(transformation.substring(startIdx),\n+                            \"Invalid transformation: missing padding\") };\n@@ -328,16 +359,2 @@\n-            \/\/ continue parsing mode and padding\n-            startIdx = endIdx+1;\n-            endIdx = transformation.indexOf('\/', startIdx);\n-            if (endIdx == -1) {\n-                throw new NoSuchAlgorithmException(\"Invalid transformation\"\n-                            + \" format:\" + transformation);\n-            }\n-            String mode = transformation.substring(startIdx, endIdx).trim();\n-            String padding = transformation.substring(endIdx+1).trim();\n-            \/\/ ensure mode and padding are specified\n-            if (mode.isEmpty() || padding.isEmpty()) {\n-                throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n-                                   \"missing mode and\/or padding-\"\n-                                   + transformation);\n-            }\n-            return new String[] { algo, mode, padding };\n+            throw new NoSuchAlgorithmException(\n+                    \"Invalid transformation format: \" + transformation);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":52,"deletions":35,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-        \/** Monitor held *\/          MONITOR,\n@@ -72,2 +71,1 @@\n-        \/** Transient failure: continuation pinned due to native frame *\/   TRANSIENT_FAIL_PINNED_NATIVE(Pinned.NATIVE),\n-        \/** Transient failure: continuation pinned due to a held monitor *\/ TRANSIENT_FAIL_PINNED_MONITOR(Pinned.MONITOR);\n+        \/** Transient failure: continuation pinned due to native frame *\/   TRANSIENT_FAIL_PINNED_NATIVE(Pinned.NATIVE);\n@@ -88,2 +86,1 @@\n-            case 4 -> Pinned.MONITOR;\n-            case 5 -> Pinned.EXCEPTION;\n+            case 4 -> Pinned.EXCEPTION;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -38,1 +37,0 @@\n-import javax.crypto.spec.SecretKeySpec;\n@@ -194,3 +192,3 @@\n-        TlsKey              (\"key\", false),\n-        TlsIv               (\"iv\",  true),\n-        TlsUpdateNplus1     (\"traffic upd\", false);\n+        TlsKey              (\"key\"),\n+        TlsIv               (\"iv\"),\n+        TlsUpdateNplus1     (\"traffic upd\");\n@@ -199,1 +197,0 @@\n-        private final boolean isIv;\n@@ -201,1 +198,1 @@\n-        KeySchedule(String label, boolean isIv) {\n+        KeySchedule(String label) {\n@@ -203,1 +200,0 @@\n-            this.isIv = isIv;\n@@ -207,3 +203,5 @@\n-            if (this == KeySchedule.TlsUpdateNplus1)\n-                return cs.hashAlg.hashLength;\n-            return isIv ? cs.bulkCipher.ivSize : cs.bulkCipher.keySize;\n+            return switch (this) {\n+                case TlsUpdateNplus1 -> cs.hashAlg.hashLength;\n+                case TlsIv -> cs.bulkCipher.ivSize;\n+                case TlsKey -> cs.bulkCipher.keySize;\n+            };\n@@ -213,1 +211,1 @@\n-            return isIv ? algorithm : cs.bulkCipher.algorithm;\n+            return this == TlsKey ? cs.bulkCipher.algorithm : algorithm;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTrafficKeyDerivation.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.HashMap;\n@@ -41,1 +40,1 @@\n-import java.util.Map;\n+import java.util.Objects;\n@@ -46,2 +45,7 @@\n-public record LanguageTag(String language, String script, String region, String privateuse,\n-                          List<String> extlangs, List<String> variants, List<String> extensions) {\n+public record LanguageTag(String language,\n+                          String script,\n+                          String region,\n+                          String privateuse,\n+                          List<String> extlangs,\n+                          List<String> variants,\n+                          List<String> extensions) {\n@@ -56,72 +60,0 @@\n-    \/\/ Map contains legacy language tags and its preferred mappings from\n-    \/\/ http:\/\/www.ietf.org\/rfc\/rfc5646.txt\n-    \/\/ Keys are lower-case strings.\n-    private static final Map<String, String[]> LEGACY;\n-\n-    static {\n-        \/\/ grandfathered = irregular           ; non-redundant tags registered\n-        \/\/               \/ regular             ; during the RFC 3066 era\n-        \/\/\n-        \/\/ irregular     = \"en-GB-oed\"         ; irregular tags do not match\n-        \/\/               \/ \"i-ami\"             ; the 'langtag' production and\n-        \/\/               \/ \"i-bnn\"             ; would not otherwise be\n-        \/\/               \/ \"i-default\"         ; considered 'well-formed'\n-        \/\/               \/ \"i-enochian\"        ; These tags are all valid,\n-        \/\/               \/ \"i-hak\"             ; but most are deprecated\n-        \/\/               \/ \"i-klingon\"         ; in favor of more modern\n-        \/\/               \/ \"i-lux\"             ; subtags or subtag\n-        \/\/               \/ \"i-mingo\"           ; combination\n-        \/\/               \/ \"i-navajo\"\n-        \/\/               \/ \"i-pwn\"\n-        \/\/               \/ \"i-tao\"\n-        \/\/               \/ \"i-tay\"\n-        \/\/               \/ \"i-tsu\"\n-        \/\/               \/ \"sgn-BE-FR\"\n-        \/\/               \/ \"sgn-BE-NL\"\n-        \/\/               \/ \"sgn-CH-DE\"\n-        \/\/\n-        \/\/ regular       = \"art-lojban\"        ; these tags match the 'langtag'\n-        \/\/               \/ \"cel-gaulish\"       ; production, but their subtags\n-        \/\/               \/ \"no-bok\"            ; are not extended language\n-        \/\/               \/ \"no-nyn\"            ; or variant subtags: their meaning\n-        \/\/               \/ \"zh-guoyu\"          ; is defined by their registration\n-        \/\/               \/ \"zh-hakka\"          ; and all of these are deprecated\n-        \/\/               \/ \"zh-min\"            ; in favor of a more modern\n-        \/\/               \/ \"zh-min-nan\"        ; subtag or sequence of subtags\n-        \/\/               \/ \"zh-xiang\"\n-\n-        final String[][] entries = {\n-          \/\/{\"tag\",         \"preferred\"},\n-            {\"art-lojban\",  \"jbo\"},\n-            {\"cel-gaulish\", \"xtg-x-cel-gaulish\"},   \/\/ fallback\n-            {\"en-GB-oed\",   \"en-GB-x-oed\"},         \/\/ fallback\n-            {\"i-ami\",       \"ami\"},\n-            {\"i-bnn\",       \"bnn\"},\n-            {\"i-default\",   \"en-x-i-default\"},      \/\/ fallback\n-            {\"i-enochian\",  \"und-x-i-enochian\"},    \/\/ fallback\n-            {\"i-hak\",       \"hak\"},\n-            {\"i-klingon\",   \"tlh\"},\n-            {\"i-lux\",       \"lb\"},\n-            {\"i-mingo\",     \"see-x-i-mingo\"},       \/\/ fallback\n-            {\"i-navajo\",    \"nv\"},\n-            {\"i-pwn\",       \"pwn\"},\n-            {\"i-tao\",       \"tao\"},\n-            {\"i-tay\",       \"tay\"},\n-            {\"i-tsu\",       \"tsu\"},\n-            {\"no-bok\",      \"nb\"},\n-            {\"no-nyn\",      \"nn\"},\n-            {\"sgn-BE-FR\",   \"sfb\"},\n-            {\"sgn-BE-NL\",   \"vgt\"},\n-            {\"sgn-CH-DE\",   \"sgg\"},\n-            {\"zh-guoyu\",    \"cmn\"},\n-            {\"zh-hakka\",    \"hak\"},\n-            {\"zh-min\",      \"nan-x-zh-min\"},        \/\/ fallback\n-            {\"zh-min-nan\",  \"nan\"},\n-            {\"zh-xiang\",    \"hsn\"},\n-        };\n-        LEGACY = HashMap.newHashMap(entries.length);\n-        for (String[] e : entries) {\n-            LEGACY.put(LocaleUtils.toLowerString(e[0]), e);\n-        }\n-    }\n-\n@@ -178,8 +110,4 @@\n-        \/\/ Check if the tag is a legacy language tag\n-        String[] gfmap = LEGACY.get(LocaleUtils.toLowerString(languageTag));\n-        if (gfmap != null) {\n-            \/\/ use preferred mapping\n-            itr = new StringTokenIterator(gfmap[1], SEP);\n-        } else {\n-            itr = new StringTokenIterator(languageTag, SEP);\n-        }\n+        \/\/ Check if the tag is a legacy tag\n+        var pref = legacyToPreferred(LocaleUtils.toLowerString(languageTag));\n+        \/\/ If legacy use preferred mapping, otherwise use the tag as is\n+        itr = new StringTokenIterator(Objects.requireNonNullElse(pref, languageTag), SEP);\n@@ -403,0 +331,2 @@\n+        StringBuilder bldr = new StringBuilder(tag.length());\n+        String[] subtags = tag.split(SEP);\n@@ -405,3 +335,12 @@\n-        String potentialLegacy = tag.toLowerCase(Locale.ROOT);\n-        if (LEGACY.containsKey(potentialLegacy)) {\n-            return LEGACY.get(potentialLegacy)[0];\n+        if (legacyToPreferred(tag.toLowerCase(Locale.ROOT)) != null) {\n+            \/\/ Fold the legacy tag\n+            for (int i = 0; i < subtags.length ; i++) {\n+                \/\/ 2 ALPHA Region subtag(s) are upper, all other subtags are lower\n+                if (i > 0 && subtags[i].length() == 2) {\n+                    bldr.append(LocaleUtils.toUpperString(subtags[i])).append(SEP);\n+                } else {\n+                    bldr.append(LocaleUtils.toLowerString(subtags[i])).append(SEP);\n+                }\n+            }\n+            bldr.setLength(bldr.length() - 1); \/\/ Remove trailing '-'\n+            return bldr.toString();\n@@ -410,2 +349,0 @@\n-        StringBuilder bldr = new StringBuilder(tag.length());\n-        String[] subtags = tag.split(\"-\");\n@@ -438,1 +375,1 @@\n-                bldr.append(\"-\");\n+                bldr.append(SEP);\n@@ -570,0 +507,41 @@\n+    \/*\n+     * Converts a legacy tag to its preferred mapping if it exists, otherwise null.\n+     * The keys are mapped and stored as lower case. (Folded on demand).\n+     * See http:\/\/www.ietf.org\/rfc\/rfc5646.txt Section 2.1 and 2.2.8 for the\n+     * full syntax and case accurate legacy tags.\n+     *\/\n+    private static String legacyToPreferred(String tag) {\n+        if (tag.length() < 5) {\n+            return null;\n+        }\n+        return switch (tag) {\n+            case \"art-lojban\" ->  \"jbo\";\n+            case \"cel-gaulish\" -> \"xtg-x-cel-gaulish\";   \/\/ fallback\n+            case \"en-gb-oed\" ->   \"en-GB-x-oed\";         \/\/ fallback\n+            case \"i-ami\" ->       \"ami\";\n+            case \"i-bnn\" ->       \"bnn\";\n+            case \"i-default\" ->   \"en-x-i-default\";      \/\/ fallback\n+            case \"i-enochian\" ->  \"und-x-i-enochian\";    \/\/ fallback\n+            case \"i-hak\",\n+                 \"zh-hakka\" ->    \"hak\";\n+            case \"i-klingon\" ->   \"tlh\";\n+            case \"i-lux\" ->       \"lb\";\n+            case \"i-mingo\" ->     \"see-x-i-mingo\";       \/\/ fallback\n+            case \"i-navajo\" ->    \"nv\";\n+            case \"i-pwn\" ->       \"pwn\";\n+            case \"i-tao\" ->       \"tao\";\n+            case \"i-tay\" ->       \"tay\";\n+            case \"i-tsu\" ->       \"tsu\";\n+            case \"no-bok\" ->      \"nb\";\n+            case \"no-nyn\" ->      \"nn\";\n+            case \"sgn-be-fr\" ->   \"sfb\";\n+            case \"sgn-be-nl\" ->   \"vgt\";\n+            case \"sgn-ch-de\" ->   \"sgg\";\n+            case \"zh-guoyu\" ->    \"cmn\";\n+            case \"zh-min\" ->      \"nan-x-zh-min\";        \/\/ fallback\n+            case \"zh-min-nan\" ->  \"nan\";\n+            case \"zh-xiang\" ->    \"hsn\";\n+            default -> null;\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/LanguageTag.java","additions":68,"deletions":90,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.io.InvalidObjectException;\n@@ -1552,27 +1553,13 @@\n-\n-        String csName = (String) s.readObject();\n-        byte[] data = (byte[]) s.readObject();\n-\n-        int cspace = 0;         \/\/ ColorSpace.CS_* constant if known\n-        boolean isKnownPredefinedCS = false;\n-        if (csName != null) {\n-            isKnownPredefinedCS = true;\n-            if (csName.equals(\"CS_sRGB\")) {\n-                cspace = ColorSpace.CS_sRGB;\n-            } else if (csName.equals(\"CS_CIEXYZ\")) {\n-                cspace = ColorSpace.CS_CIEXYZ;\n-            } else if (csName.equals(\"CS_PYCC\")) {\n-                cspace = ColorSpace.CS_PYCC;\n-            } else if (csName.equals(\"CS_GRAY\")) {\n-                cspace = ColorSpace.CS_GRAY;\n-            } else if (csName.equals(\"CS_LINEAR_RGB\")) {\n-                cspace = ColorSpace.CS_LINEAR_RGB;\n-            } else {\n-                isKnownPredefinedCS = false;\n-            }\n-        }\n-\n-        if (isKnownPredefinedCS) {\n-            resolvedDeserializedProfile = getInstance(cspace);\n-        } else {\n-            resolvedDeserializedProfile = getInstance(data);\n+        try {\n+            String csName = (String) s.readObject();\n+            byte[] data = (byte[]) s.readObject();\n+            resolvedDeserializedProfile = switch (csName) {\n+                case \"CS_sRGB\" -> getInstance(ColorSpace.CS_sRGB);\n+                case \"CS_CIEXYZ\" -> getInstance(ColorSpace.CS_CIEXYZ);\n+                case \"CS_PYCC\" -> getInstance(ColorSpace.CS_PYCC);\n+                case \"CS_GRAY\" -> getInstance(ColorSpace.CS_GRAY);\n+                case \"CS_LINEAR_RGB\" -> getInstance(ColorSpace.CS_LINEAR_RGB);\n+                case null, default -> getInstance(data);\n+            };\n+        } catch (ClassCastException | IllegalArgumentException e) {\n+            throw new InvalidObjectException(\"Invalid ICC Profile Data\", e);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":14,"deletions":27,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -67,0 +67,16 @@\n+     * The bean is created based on a name relative to a class-loader.\n+     * This name should be a {@linkplain ClassLoader##binary-name binary name} of a class such as \"a.b.C\".\n+     * <p>\n+     * The given name can indicate either a serialized object or a class.\n+     * We first try to treat the {@code beanName} as a serialized object\n+     * name then as a class name.\n+     * <p>\n+     * When using the {@code beanName} as a serialized object name we convert the\n+     * given {@code beanName} to a resource pathname and add a trailing \".ser\" suffix.\n+     * We then try to load a serialized object from that resource.\n+     * <p>\n+     * For example, given a {@code beanName} of \"x.y\", {@code Beans.instantiate} would first\n+     * try to read a serialized object from the resource \"x\/y.ser\" and if\n+     * that failed it would try to load the class \"x.y\" and create an\n+     * instance of that class.\n+     *\n@@ -87,0 +103,16 @@\n+     * The bean is created based on a name relative to a class-loader.\n+     * This name should be a {@linkplain ClassLoader##binary-name binary name} of a class such as \"a.b.C\".\n+     * <p>\n+     * The given name can indicate either a serialized object or a class.\n+     * We first try to treat the {@code beanName} as a serialized object\n+     * name then as a class name.\n+     * <p>\n+     * When using the {@code beanName} as a serialized object name we convert the\n+     * given {@code beanName} to a resource pathname and add a trailing \".ser\" suffix.\n+     * We then try to load a serialized object from that resource.\n+     * <p>\n+     * For example, given a {@code beanName} of \"x.y\", {@code Beans.instantiate} would first\n+     * try to read a serialized object from the resource \"x\/y.ser\" and if\n+     * that failed it would try to load the class \"x.y\" and create an\n+     * instance of that class.\n+     *\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Beans.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.Serial;\n+\n@@ -39,0 +41,1 @@\n+    @Serial\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/ScriptException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -34,1 +34,1 @@\n-     * Java class file format Magic number (0xCAFEBABE)\n+     * Java class file format Magic number: {@value}.\n@@ -42,1 +42,1 @@\n-     * Major version number of class files for Java 1.1.\n+     * Major version number of class files for Java 1.1: {@value}.\n@@ -49,1 +49,1 @@\n-     * Minor version number of class files for Java 1.1.\n+     * Minor version number of class files for Java 1.1: {@value}.\n@@ -56,1 +56,1 @@\n-     * Major version number of class files for Java 1.2.\n+     * Major version number of class files for Java 1.2: {@value}.\n@@ -63,1 +63,1 @@\n-     * Minor version number of class files for Java 1.2.\n+     * Minor version number of class files for Java 1.2: {@value}.\n@@ -70,1 +70,1 @@\n-     * Major version number of class files for Java 1.2.\n+     * Major version number of class files for Java 1.2: {@value}.\n@@ -77,1 +77,1 @@\n-     * Minor version number of class files for Java 1.3.\n+     * Minor version number of class files for Java 1.3: {@value}.\n@@ -84,1 +84,1 @@\n-     * Major version number of class files for Java 1.3.\n+     * Major version number of class files for Java 1.3: {@value}.\n@@ -91,1 +91,1 @@\n-     * Minor version number of class files for Java 1.4.\n+     * Minor version number of class files for Java 1.4: {@value}.\n@@ -98,1 +98,1 @@\n-     * Major version number of class files for Java 1.4.\n+     * Major version number of class files for Java 1.4: {@value}.\n@@ -105,1 +105,1 @@\n-     * Minor version number of class files for Java 1.5.\n+     * Minor version number of class files for Java 1.5: {@value}.\n@@ -112,1 +112,1 @@\n-     * Major version number of class files for Java 1.6.\n+     * Major version number of class files for Java 1.6: {@value}.\n@@ -119,1 +119,1 @@\n-     * Minor version number of class files for Java 1.6.\n+     * Minor version number of class files for Java 1.6: {@value}.\n@@ -126,1 +126,1 @@\n-     * Major version number of class files for Java 1.7.\n+     * Major version number of class files for Java 1.7: {@value}.\n@@ -133,1 +133,1 @@\n-     * Minor version number of class files for Java 1.7.\n+     * Minor version number of class files for Java 1.7: {@value}.\n@@ -140,1 +140,1 @@\n-     * Major version number of class files for Java 1.8.\n+     * Major version number of class files for Java 1.8: {@value}.\n@@ -147,1 +147,1 @@\n-     * Minor version number of class files for Java 1.8.\n+     * Minor version number of class files for Java 1.8: {@value}.\n@@ -154,1 +154,1 @@\n-     * Major version number of class files for Java 9.\n+     * Major version number of class files for Java 9: {@value}.\n@@ -161,1 +161,1 @@\n-     * Minor version number of class files for Java 9.\n+     * Minor version number of class files for Java 9: {@value}.\n@@ -168,1 +168,1 @@\n-     * @deprecated Use {@link #MAJOR_9} instead\n+     * @deprecated Use {@link #MAJOR_9} ({@value}) instead.\n@@ -174,1 +174,1 @@\n-     * @deprecated Use {@link #MINOR_9} instead\n+     * @deprecated Use {@link #MINOR_9} ({@value}) instead.\n@@ -180,1 +180,1 @@\n-     * Major version number of class files for Java 10.\n+     * Major version number of class files for Java 10: {@value}.\n@@ -187,1 +187,1 @@\n-     * Minor version number of class files for Java 10.\n+     * Minor version number of class files for Java 10: {@value}.\n@@ -194,1 +194,1 @@\n-     * Major version number of class files for Java 11.\n+     * Major version number of class files for Java 11: {@value}.\n@@ -201,1 +201,1 @@\n-     * Minor version number of class files for Java 11.\n+     * Minor version number of class files for Java 11: {@value}.\n@@ -208,1 +208,1 @@\n-     * Major version number of class files for Java 12.\n+     * Major version number of class files for Java 12: {@value}.\n@@ -215,1 +215,1 @@\n-     * Minor version number of class files for Java 12.\n+     * Minor version number of class files for Java 12: {@value}.\n@@ -222,1 +222,1 @@\n-     * Major version number of class files for Java 13.\n+     * Major version number of class files for Java 13: {@value}.\n@@ -229,1 +229,1 @@\n-     * Minor version number of class files for Java 13.\n+     * Minor version number of class files for Java 13: {@value}.\n@@ -236,1 +236,1 @@\n-     * Minor version number of class files for Java 14.\n+     * Minor version number of class files for Java 14: {@value}.\n@@ -244,1 +244,1 @@\n-     * Minor version number of class files for Java 15.\n+     * Minor version number of class files for Java 15: {@value}.\n@@ -252,1 +252,1 @@\n-     * Minor version number of class files for Java 16.\n+     * Minor version number of class files for Java 16: {@value}.\n@@ -260,1 +260,1 @@\n-     * Minor version number of class files for Java 17.\n+     * Minor version number of class files for Java 17: {@value}.\n@@ -268,1 +268,1 @@\n-     * Minor version number of class files for Java 18.\n+     * Minor version number of class files for Java 18: {@value}.\n@@ -276,1 +276,1 @@\n-     * Minor version number of class files for Java 19.\n+     * Minor version number of class files for Java 19: {@value}.\n@@ -284,1 +284,41 @@\n-     * Major version number of class files for Java 14.\n+     * Minor version number of class files for Java 20: {@value}.\n+     *\n+     * @see #MAJOR_20\n+     * @since 6.8.0\n+     *\/\n+    public static final short MINOR_20 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 21: {@value}.\n+     *\n+     * @see #MAJOR_21\n+     * @since 6.8.0\n+     *\/\n+    public static final short MINOR_21 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 22: {@value}.\n+     *\n+     * @see #MAJOR_22\n+     * @since 6.10.0\n+     *\/\n+    public static final short MINOR_22 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 23: {@value}.\n+     *\n+     * @see #MAJOR_23\n+     * @since 6.10.0\n+     *\/\n+    public static final short MINOR_23 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 24: {@value}.\n+     *\n+     * @see #MAJOR_24\n+     * @since 6.10.0\n+     *\/\n+    public static final short MINOR_24 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 14: {@value}.\n@@ -292,1 +332,1 @@\n-     * Major version number of class files for Java 15.\n+     * Major version number of class files for Java 15: {@value}.\n@@ -300,1 +340,1 @@\n-     * Major version number of class files for Java 16.\n+     * Major version number of class files for Java 16: {@value}.\n@@ -308,1 +348,1 @@\n-     * Major version number of class files for Java 17.\n+     * Major version number of class files for Java 17: {@value}.\n@@ -316,1 +356,1 @@\n-     * Major version number of class files for Java 18.\n+     * Major version number of class files for Java 18: {@value}.\n@@ -324,1 +364,1 @@\n-     * Major version number of class files for Java 19.\n+     * Major version number of class files for Java 19: {@value}.\n@@ -332,1 +372,41 @@\n-     * Default major version number. Class file is for Java 1.1.\n+     * Major version number of class files for Java 20: {@value}.\n+     *\n+     * @see #MINOR_20\n+     * @since 6.8.0\n+     *\/\n+    public static final short MAJOR_20 = 64;\n+\n+    \/**\n+     * Major version number of class files for Java 21: {@value}.\n+     *\n+     * @see #MINOR_21\n+     * @since 6.8.0\n+     *\/\n+    public static final short MAJOR_21 = 65;\n+\n+    \/**\n+     * Major version number of class files for Java 22: {@value}.\n+     *\n+     * @see #MINOR_22\n+     * @since 6.10.0\n+     *\/\n+    public static final short MAJOR_22 = 66;\n+\n+    \/**\n+     * Major version number of class files for Java 23: {@value}.\n+     *\n+     * @see #MINOR_23\n+     * @since 6.10.0\n+     *\/\n+    public static final short MAJOR_23 = 67;\n+\n+    \/**\n+     * Major version number of class files for Java 24: {@value}.\n+     *\n+     * @see #MINOR_24\n+     * @since 6.10.0\n+     *\/\n+    public static final short MAJOR_24 = 68;\n+\n+    \/**\n+     * Default major version number. Class file is for Java 1.1: {@value}.\n@@ -339,1 +419,1 @@\n-     * Default major version number. Class file is for Java 1.1.\n+     * Default major version number. Class file is for Java 1.1: {@value}.\n@@ -346,1 +426,1 @@\n-     * Maximum value for an unsigned short.\n+     * Maximum value for an unsigned short: {@value}.\n@@ -351,1 +431,1 @@\n-     * Maximum value for an unsigned byte.\n+     * Maximum value for an unsigned byte: {@value}.\n@@ -356,1 +436,1 @@\n-     * One of the access flags for fields, methods, or classes.\n+     * One of the access flags for fields, methods, or classes: {@value}.\n@@ -370,1 +450,1 @@\n-     * One of the access flags for fields, methods, or classes.\n+     * One of the access flags for fields, methods, or classes: {@value}.\n@@ -377,1 +457,1 @@\n-     * One of the access flags for fields, methods, or classes.\n+     * One of the access flags for fields, methods, or classes: {@value}.\n@@ -384,1 +464,1 @@\n-     * One of the access flags for fields, methods, or classes.\n+     * One of the access flags for fields, methods, or classes: {@value}.\n@@ -391,1 +471,1 @@\n-     * One of the access flags for fields, methods, or classes.\n+     * One of the access flags for fields, methods, or classes: {@value}.\n@@ -398,1 +478,1 @@\n-     * One of the access flags for the Module attribute.\n+     * One of the access flags for the Module attribute: {@value}.\n@@ -405,1 +485,1 @@\n-     * One of the access flags for classes.\n+     * One of the access flags for classes: {@value}.\n@@ -412,1 +492,1 @@\n-     * One of the access flags for methods.\n+     * One of the access flags for methods: {@value}.\n@@ -419,1 +499,1 @@\n-     * One of the access flags for the Module attribute.\n+     * One of the access flags for the Module attribute: {@value}.\n@@ -426,1 +506,1 @@\n-     * One of the access flags for methods.\n+     * One of the access flags for methods: {@value}.\n@@ -433,1 +513,1 @@\n-     * One of the access flags for the Module attribute.\n+     * One of the access flags for the Module attribute: {@value}.\n@@ -440,1 +520,1 @@\n-     * One of the access flags for fields.\n+     * One of the access flags for fields: {@value}.\n@@ -447,1 +527,1 @@\n-     * One of the access flags for fields.\n+     * One of the access flags for fields: {@value}.\n@@ -454,1 +534,1 @@\n-     * One of the access flags for methods.\n+     * One of the access flags for methods: {@value}.\n@@ -461,1 +541,1 @@\n-     * One of the access flags for methods.\n+     * One of the access flags for methods: {@value}.\n@@ -468,1 +548,1 @@\n-     * One of the access flags for classes.\n+     * One of the access flags for classes: {@value}.\n@@ -475,1 +555,1 @@\n-     * One of the access flags for methods or classes.\n+     * One of the access flags for methods or classes: {@value}.\n@@ -482,1 +562,1 @@\n-     * One of the access flags for methods.\n+     * One of the access flags for methods: {@value}.\n@@ -489,1 +569,1 @@\n-     * One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute.\n+     * One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute: {@value}.\n@@ -496,1 +576,1 @@\n-     * One of the access flags for classes.\n+     * One of the access flags for classes: {@value}.\n@@ -503,1 +583,1 @@\n-     * One of the access flags for fields or classes.\n+     * One of the access flags for fields or classes: {@value}.\n@@ -511,1 +591,1 @@\n-     * One of the access flags for MethodParameter or Module attributes.\n+     * One of the access flags for MethodParameter or Module attributes: {@value}.\n@@ -518,1 +598,1 @@\n-     * One of the access flags for classes.\n+     * One of the access flags for classes: {@value}.\n@@ -525,1 +605,1 @@\n-     * One of the access flags for fields, methods, or classes.\n+     * One of the access flags for fields, methods, or classes: {@value}.\n@@ -534,1 +614,1 @@\n-     * One of the access flags for fields, methods, or classes. ACC_MODULE is negative as a short.\n+     * One of the access flags for fields, methods, or classes. ACC_MODULE is negative as a short: {@value}.\n@@ -556,1 +636,1 @@\n-     * Marks a constant pool entry as type UTF-8.\n+     * Marks a constant pool entry as type UTF-8: {@value}.\n@@ -569,1 +649,1 @@\n-     * Marks a constant pool entry as type Integer.\n+     * Marks a constant pool entry as type Integer: {@value}.\n@@ -577,1 +657,1 @@\n-     * Marks a constant pool entry as type Float.\n+     * Marks a constant pool entry as type Float: {@value}.\n@@ -585,1 +665,1 @@\n-     * Marks a constant pool entry as type Long.\n+     * Marks a constant pool entry as type Long: {@value}.\n@@ -593,1 +673,1 @@\n-     * Marks a constant pool entry as type Double.\n+     * Marks a constant pool entry as type Double: {@value}.\n@@ -601,1 +681,1 @@\n-     * Marks a constant pool entry as a Class\n+     * Marks a constant pool entry as a Class: {@value}.\n@@ -609,1 +689,1 @@\n-     * Marks a constant pool entry as a Field Reference.\n+     * Marks a constant pool entry as a Field Reference: {@value}.\n@@ -617,1 +697,1 @@\n-     * Marks a constant pool entry as type String\n+     * Marks a constant pool entry as type String: {@value}.\n@@ -625,1 +705,1 @@\n-     * Marks a constant pool entry as a Method Reference.\n+     * Marks a constant pool entry as a Method Reference: {@value}.\n@@ -633,1 +713,1 @@\n-     * Marks a constant pool entry as an Interface Method Reference.\n+     * Marks a constant pool entry as an Interface Method Reference: {@value}.\n@@ -641,1 +721,1 @@\n-     * Marks a constant pool entry as a name and type.\n+     * Marks a constant pool entry as a name and type: {@value}.\n@@ -649,1 +729,1 @@\n-     * Marks a constant pool entry as a Method Handle.\n+     * Marks a constant pool entry as a Method Handle: {@value}.\n@@ -657,1 +737,1 @@\n-     * Marks a constant pool entry as a Method Type.\n+     * Marks a constant pool entry as a Method Type: {@value}.\n@@ -665,1 +745,1 @@\n-     * Marks a constant pool entry as dynamically computed.\n+     * Marks a constant pool entry as dynamically computed: {@value}.\n@@ -667,2 +747,2 @@\n-     * @see <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\"> Change request for JEP\n-     *      309<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/jvms-4.html#jvms-4.4.10\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n@@ -674,1 +754,1 @@\n-     * Marks a constant pool entry as an Invoke Dynamic\n+     * Marks a constant pool entry as an Invoke Dynamic: {@value}.\n@@ -682,1 +762,1 @@\n-     * Marks a constant pool entry as a Module Reference.\n+     * Marks a constant pool entry as a Module Reference: {@value}.\n@@ -691,1 +771,1 @@\n-     * Marks a constant pool entry as a Package Reference.\n+     * Marks a constant pool entry as a Package Reference: {@value}.\n@@ -708,1 +788,1 @@\n-     * initialization method&quot;. This is &quot;&lt;clinit&gt;&quot;.\n+     * initialization method&quot;. This is {@value}.\n@@ -714,1 +794,1 @@\n-     * &quot;&lt;init&gt;&quot;.\n+     * {@value}.\n@@ -719,1 +799,1 @@\n-     * The names of the interfaces implemented by arrays\n+     * The names of the interfaces implemented by arrays.\n@@ -724,1 +804,1 @@\n-     * Maximum Constant Pool entries. One of the limitations of the Java Virtual Machine.\n+     * Maximum Constant Pool entries: {@value}. One of the limitations of the Java Virtual Machine.\n@@ -732,7 +812,11 @@\n-     * Maximum code size (plus one; the code size must be LESS than this) One of the limitations of the Java Virtual\n-     * Machine. Note vmspec2 page 152 (\"Limitations\") says: \"The amount of code per non-native, non-abstract method is\n-     * limited to 65536 bytes by the sizes of the indices in the exception_table of the Code attribute (4.7.3), in the\n-     * LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\" However this should be taken\n-     * as an upper limit rather than the defined maximum. On page 134 (4.8.1 Static Constants) of the same spec, it says:\n-     * \"The value of the code_length item must be less than 65536.\" The entry in the Limitations section has been removed\n-     * from later versions of the spec; it is not present in the Java SE 8 edition.\n+     * Maximum code size (plus one; the code size must be LESS than this): {@value}.\n+     * <p>\n+     * One of the limitations of the Java Virtual Machine. Note vmspec2 page 152 (\"Limitations\") says:\n+     * <\/p>\n+     * <pre>\"The amount of code per non-native, non-abstract method is limited to 65536 bytes by the sizes of the indices in the exception_table of the Code\n+     * attribute (4.7.3), in the LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\" However this should be taken as an\n+     * upper limit rather than the defined maximum. On page 134 (4.8.1 Static Constants) of the same spec, it says: \"The value of the code_length item must be\n+     * less than 65536.\"<\/pre>\n+     * <p>\n+     * The entry in the Limitations section has been removed from later versions of the specification; it is not present in the Java SE 8 edition.\n+     * <\/p>\n@@ -740,2 +824,2 @@\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\"> The Java Virtual\n-     *      Machine Specification, Java SE 8 Edition, page 104, chapter 4.7.<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\"> The Java Virtual Machine Specification, Java SE 8\n+     *      Edition, page 104, chapter 4.7.<\/a>\n@@ -746,1 +830,1 @@\n-     * The maximum number of dimensions in an array ({@value}). One of the limitations of the Java Virtual Machine.\n+     * The maximum number of dimensions in an array: {@value}. One of the limitations of the Java Virtual Machine.\n@@ -754,1 +838,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -762,1 +846,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -770,1 +854,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -778,1 +862,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -786,1 +870,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -794,1 +878,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -802,1 +886,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -810,1 +894,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -818,1 +902,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -826,1 +910,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -834,1 +918,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -842,1 +926,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -850,1 +934,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -858,1 +942,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -866,1 +950,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -874,1 +958,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -882,1 +966,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -890,1 +974,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -898,1 +982,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -906,1 +990,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -914,1 +998,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -922,1 +1006,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -930,1 +1014,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -938,1 +1022,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -946,1 +1030,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -954,1 +1038,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -962,1 +1046,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -970,1 +1054,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -978,1 +1062,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -986,1 +1070,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -994,1 +1078,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1002,1 +1086,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1010,1 +1094,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1018,1 +1102,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1026,1 +1110,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1034,1 +1118,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1042,1 +1126,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1050,1 +1134,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1058,1 +1142,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1066,1 +1150,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1074,1 +1158,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1082,1 +1166,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1090,1 +1174,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1098,1 +1182,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1106,1 +1190,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1114,1 +1198,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1122,1 +1206,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1130,1 +1214,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1138,1 +1222,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1146,1 +1230,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1154,1 +1238,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1162,1 +1246,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1170,1 +1254,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1178,1 +1262,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1186,1 +1270,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1194,1 +1278,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1202,1 +1286,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1210,1 +1294,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1218,1 +1302,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1226,1 +1310,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1234,1 +1318,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1242,1 +1326,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1250,1 +1334,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1258,1 +1342,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1266,1 +1350,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1274,1 +1358,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1282,1 +1366,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1290,1 +1374,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1298,1 +1382,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1306,1 +1390,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1314,1 +1398,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1322,1 +1406,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1330,1 +1414,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1338,1 +1422,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1346,1 +1430,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1354,1 +1438,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1362,1 +1446,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1370,1 +1454,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1378,1 +1462,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1386,1 +1470,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1394,1 +1478,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1402,1 +1486,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1410,1 +1494,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1418,1 +1502,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1426,1 +1510,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1434,1 +1518,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1442,1 +1526,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1450,1 +1534,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1458,1 +1542,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1466,1 +1550,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1474,1 +1558,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1482,1 +1566,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1490,1 +1574,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1498,1 +1582,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1506,1 +1590,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1514,1 +1598,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1522,1 +1606,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1530,1 +1614,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1538,1 +1622,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1546,1 +1630,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1554,1 +1638,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1562,1 +1646,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1570,1 +1654,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1578,1 +1662,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1586,1 +1670,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1594,1 +1678,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1602,1 +1686,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1610,1 +1694,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1618,1 +1702,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1626,1 +1710,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1634,1 +1718,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1642,1 +1726,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1650,1 +1734,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1658,1 +1742,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1666,1 +1750,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1674,1 +1758,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1682,1 +1766,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1690,1 +1774,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1698,1 +1782,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1706,1 +1790,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1714,1 +1798,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1722,1 +1806,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1730,1 +1814,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1738,1 +1822,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1746,1 +1830,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1754,1 +1838,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1762,1 +1846,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1770,1 +1854,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1778,1 +1862,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1786,1 +1870,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1794,1 +1878,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1802,1 +1886,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1810,1 +1894,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1818,1 +1902,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1826,1 +1910,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1834,1 +1918,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1842,1 +1926,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1850,1 +1934,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1858,1 +1942,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1866,1 +1950,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1874,1 +1958,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1882,1 +1966,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1890,1 +1974,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1898,1 +1982,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1906,1 +1990,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1914,1 +1998,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1922,1 +2006,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1930,1 +2014,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1938,1 +2022,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1946,1 +2030,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1954,1 +2038,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1962,1 +2046,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1970,1 +2054,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1978,1 +2062,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1986,1 +2070,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -1994,1 +2078,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2002,1 +2086,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2010,1 +2094,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2018,1 +2102,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2026,1 +2110,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2034,1 +2118,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2042,1 +2126,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2050,1 +2134,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2058,1 +2142,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2066,1 +2150,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2074,1 +2158,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2082,1 +2166,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2090,1 +2174,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2098,1 +2182,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2106,1 +2190,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2114,1 +2198,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2122,1 +2206,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2130,1 +2214,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2138,1 +2222,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2146,1 +2230,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2154,1 +2238,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2162,1 +2246,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2170,1 +2254,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2178,1 +2262,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2186,1 +2270,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2194,1 +2278,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2202,1 +2286,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2210,1 +2294,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2218,1 +2302,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2226,1 +2310,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2234,1 +2318,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2242,1 +2326,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2250,1 +2334,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2258,1 +2342,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2266,1 +2350,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2274,1 +2358,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2282,1 +2366,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2290,1 +2374,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2298,1 +2382,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2306,1 +2390,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2314,1 +2398,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2322,1 +2406,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2330,1 +2414,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2338,1 +2422,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2346,1 +2430,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2354,1 +2438,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2362,1 +2446,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2370,1 +2454,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2378,1 +2462,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2386,1 +2470,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2394,1 +2478,1 @@\n-     * Java VM opcode.\n+     * Java VM opcode {@value}.\n@@ -2402,1 +2486,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2410,1 +2494,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2421,1 +2505,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2432,1 +2516,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2443,1 +2527,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2454,1 +2538,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2465,1 +2549,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2476,1 +2560,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2487,1 +2571,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2498,1 +2582,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2509,1 +2593,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2520,1 +2604,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2531,1 +2615,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2542,1 +2626,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2553,1 +2637,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2564,1 +2648,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2575,1 +2659,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2586,1 +2670,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2597,1 +2681,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2608,1 +2692,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2619,1 +2703,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2630,1 +2714,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2641,1 +2725,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2652,1 +2736,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2663,1 +2747,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2674,1 +2758,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2685,1 +2769,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2693,1 +2777,1 @@\n-     * JVM internal opcode.\n+     * JVM internal opcode {@value}.\n@@ -2701,1 +2785,1 @@\n-     * BCEL virtual instruction for pushing an arbitrary data type onto the stack. Will be converted to the appropriate JVM\n+     * BCEL virtual instruction for pushing an arbitrary data type onto the stack: {@value}. Will be converted to the appropriate JVM\n@@ -2707,1 +2791,1 @@\n-     * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH. Will be converted to the appropriate JVM opcode when\n+     * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH: {@value}. Will be converted to the appropriate JVM opcode when\n@@ -2712,1 +2796,3 @@\n-    \/** Illegal opcode. *\/\n+    \/**\n+     * Illegal opcode: {@value}.\n+     *\/\n@@ -2715,1 +2801,3 @@\n-    \/** Illegal opcode. *\/\n+    \/**\n+     * Illegal opcode: {@value}.\n+     *\/\n@@ -2718,1 +2806,3 @@\n-    \/** Illegal opcode. *\/\n+    \/**\n+     * Illegal opcode: {@value}.\n+     *\/\n@@ -2721,1 +2811,3 @@\n-    \/** Mnemonic for an illegal opcode. *\/\n+    \/**\n+     * Mnemonic for an illegal opcode: {@value}.\n+     *\/\n@@ -2724,1 +2816,3 @@\n-    \/** Mnemonic for an illegal type. *\/\n+    \/**\n+     * Mnemonic for an illegal type: {@value}.\n+     *\/\n@@ -2728,1 +2822,1 @@\n-     * Boolean data type.\n+     * Boolean data type: {@value}.\n@@ -2736,1 +2830,1 @@\n-     * Char data type.\n+     * Char data type: {@value}.\n@@ -2744,1 +2838,1 @@\n-     * Float data type.\n+     * Float data type: {@value}.\n@@ -2752,1 +2846,1 @@\n-     * Double data type.\n+     * Double data type: {@value}.\n@@ -2760,1 +2854,1 @@\n-     * Byte data type.\n+     * Byte data type: {@value}.\n@@ -2768,1 +2862,1 @@\n-     * Short data type.\n+     * Short data type: {@value}.\n@@ -2776,1 +2870,1 @@\n-     * Int data type.\n+     * Int data type: {@value}.\n@@ -2784,1 +2878,1 @@\n-     * Long data type.\n+     * Long data type: {@value}.\n@@ -2830,1 +2924,1 @@\n-    private static final String[] SHORT_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\", \"V\",\n+    public static final String[] SHORT_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\", \"V\",\n@@ -3039,1 +3133,3 @@\n-    public static final short KNOWN_ATTRIBUTES = 27; \/\/ count of attributes\n+    public static final byte ATTR_RECORD = 27;\n+\n+    public static final short KNOWN_ATTRIBUTES = 28; \/\/ count of attributes\n@@ -3043,1 +3139,1 @@\n-        \"StackMapTable\", \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\", \"ModuleMainClass\", \"NestHost\", \"NestMembers\"};\n+        \"StackMapTable\", \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\", \"ModuleMainClass\", \"NestHost\", \"NestMembers\", \"Record\"};\n@@ -3073,0 +3169,1 @@\n+\n@@ -3093,0 +3190,1 @@\n+\n@@ -3100,1 +3198,1 @@\n-     * @param index\n+     * @param index index into {@code ACCESS_NAMES}.\n@@ -3110,1 +3208,1 @@\n-     * @param index\n+     * @param index index into {@code ACCESS_NAMES}.\n@@ -3121,1 +3219,1 @@\n-     * @param index\n+     * @param index index into {@code CLASS_TYPE_NAMES}.\n@@ -3131,1 +3229,1 @@\n-     * @param index\n+     * @param index index into {@code CONSTANT_NAMES}.\n@@ -3143,1 +3241,1 @@\n-     * @param index\n+     * @param index index into {@code CONSUME_STACK}.\n@@ -3160,1 +3258,1 @@\n-     * @param index\n+     * @param index index into {@code ITEM_NAMES}.\n@@ -3170,1 +3268,1 @@\n-     * @param index\n+     * @param index index into {@code METHODHANDLE_NAMES}.\n@@ -3180,1 +3278,1 @@\n-     * @param index\n+     * @param index index into {@code NO_OF_OPERANDS}.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Const.java","additions":463,"deletions":365,"binary":false,"changes":828,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -55,1 +55,0 @@\n-\n@@ -70,0 +69,1 @@\n+\n@@ -73,1 +73,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/ExceptionConst.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -177,1 +177,1 @@\n-     * Lookups class somewhere found on your CLASSPATH, or wherever the repository instance looks for it.\n+     * Lookups class somewhere found on your CLASSPATH, or whereever the repository instance looks for it.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Repository.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Sept 2025\n@@ -33,1 +33,3 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     * Access flags.\n+     *\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter.\n@@ -38,0 +40,3 @@\n+    \/**\n+     * Constructs a new instance.\n+     *\/\n@@ -42,1 +47,3 @@\n-     * @param a initial access flags\n+     * Constructs a new instance.\n+     *\n+     * @param accessFlags initial access flags.\n@@ -44,2 +51,2 @@\n-    public AccessFlags(final int a) {\n-        access_flags = a;\n+    public AccessFlags(final int accessFlags) {\n+        access_flags = accessFlags;\n@@ -49,0 +56,2 @@\n+     * Gets access flags.\n+     *\n@@ -56,1 +65,3 @@\n-     * @return Access flags of the object aka. \"modifiers\".\n+     * Gets access flags.\n+     *\n+     * @return Access flags of the object also known as modifiers.\n@@ -62,0 +73,5 @@\n+    \/**\n+     * Tests whether the abstract bit is on.\n+     *\n+     * @return whether the abstract bit is on.\n+     *\/\n@@ -63,1 +79,1 @@\n-        return (access_flags & Const.ACC_ABSTRACT) != 0;\n+        return test(Const.ACC_ABSTRACT);\n@@ -66,0 +82,5 @@\n+    \/**\n+     * Sets the abstract bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -70,0 +91,5 @@\n+    \/**\n+     * Tests whether the annotation bit is on.\n+     *\n+     * @return whether the annotation bit is on.\n+     *\/\n@@ -71,1 +97,1 @@\n-        return (access_flags & Const.ACC_ANNOTATION) != 0;\n+        return test(Const.ACC_ANNOTATION);\n@@ -74,0 +100,5 @@\n+    \/**\n+     * Sets the annotation bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -77,1 +108,5 @@\n-\n+    \/**\n+     * Tests whether the enum bit is on.\n+     *\n+     * @return whether the enum bit is on.\n+     *\/\n@@ -79,1 +114,1 @@\n-        return (access_flags & Const.ACC_ENUM) != 0;\n+        return test(Const.ACC_ENUM);\n@@ -82,0 +117,5 @@\n+    \/**\n+     * Sets the enum bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -86,0 +126,5 @@\n+    \/**\n+     * Tests whether the final bit is on.\n+     *\n+     * @return whether the final bit is on.\n+     *\/\n@@ -87,1 +132,1 @@\n-        return (access_flags & Const.ACC_FINAL) != 0;\n+        return test(Const.ACC_FINAL);\n@@ -90,0 +135,5 @@\n+    \/**\n+     * Sets the final bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -94,0 +144,5 @@\n+    \/**\n+     * Tests whether the interface bit is on.\n+     *\n+     * @return whether the interface bit is on.\n+     *\/\n@@ -95,1 +150,1 @@\n-        return (access_flags & Const.ACC_INTERFACE) != 0;\n+        return test(Const.ACC_INTERFACE);\n@@ -98,0 +153,5 @@\n+    \/**\n+     * Sets the interface bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -102,0 +162,5 @@\n+    \/**\n+     * Tests whether the native bit is on.\n+     *\n+     * @return whether the native bit is on.\n+     *\/\n@@ -103,1 +168,1 @@\n-        return (access_flags & Const.ACC_NATIVE) != 0;\n+        return test(Const.ACC_NATIVE);\n@@ -106,0 +171,5 @@\n+    \/**\n+     * Sets the native bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -110,0 +180,5 @@\n+    \/**\n+     * Tests whether the private bit is on.\n+     *\n+     * @return whether the private bit is on.\n+     *\/\n@@ -111,1 +186,1 @@\n-        return (access_flags & Const.ACC_PRIVATE) != 0;\n+        return test(Const.ACC_PRIVATE);\n@@ -114,0 +189,5 @@\n+    \/**\n+     * Sets the private bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -118,0 +198,5 @@\n+    \/**\n+     * Tests whether the protected bit is on.\n+     *\n+     * @return whether the protected bit is on.\n+     *\/\n@@ -119,1 +204,1 @@\n-        return (access_flags & Const.ACC_PROTECTED) != 0;\n+        return test(Const.ACC_PROTECTED);\n@@ -122,0 +207,5 @@\n+    \/**\n+     * Sets the protected bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -126,0 +216,5 @@\n+    \/**\n+     * Tests whether the public bit is on.\n+     *\n+     * @return whether the public bit is on.\n+     *\/\n@@ -127,1 +222,1 @@\n-        return (access_flags & Const.ACC_PUBLIC) != 0;\n+        return test(Const.ACC_PUBLIC);\n@@ -130,0 +225,5 @@\n+    \/**\n+     * Sets the public bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -134,0 +234,5 @@\n+    \/**\n+     * Tests whether the static bit is on.\n+     *\n+     * @return whether the static bit is on.\n+     *\/\n@@ -135,1 +240,1 @@\n-        return (access_flags & Const.ACC_STATIC) != 0;\n+        return test(Const.ACC_STATIC);\n@@ -138,0 +243,5 @@\n+    \/**\n+     * Sets the static bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -142,0 +252,5 @@\n+    \/**\n+     * Tests whether the strict bit is on.\n+     *\n+     * @return whether the strict bit is on.\n+     *\/\n@@ -143,1 +258,1 @@\n-        return (access_flags & Const.ACC_STRICT) != 0;\n+        return test(Const.ACC_STRICT);\n@@ -146,0 +261,5 @@\n+    \/**\n+     * Sets the strict bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -150,0 +270,5 @@\n+    \/**\n+     * Tests whether the synchronized bit is on.\n+     *\n+     * @return whether the synchronized bit is on.\n+     *\/\n@@ -151,1 +276,1 @@\n-        return (access_flags & Const.ACC_SYNCHRONIZED) != 0;\n+        return test(Const.ACC_SYNCHRONIZED);\n@@ -154,0 +279,5 @@\n+    \/**\n+     * Sets the synchronized bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -158,0 +288,5 @@\n+    \/**\n+     * Tests whether the synthetic bit is on.\n+     *\n+     * @return whether the synthetic bit is on.\n+     *\/\n@@ -159,1 +294,1 @@\n-        return (access_flags & Const.ACC_SYNTHETIC) != 0;\n+        return test(Const.ACC_SYNTHETIC);\n@@ -162,0 +297,5 @@\n+    \/**\n+     * Sets the synthetic bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -166,0 +306,5 @@\n+    \/**\n+     * Tests whether the transient bit is on.\n+     *\n+     * @return whether the varargs bit is on.\n+     *\/\n@@ -167,1 +312,1 @@\n-        return (access_flags & Const.ACC_TRANSIENT) != 0;\n+        return test(Const.ACC_TRANSIENT);\n@@ -170,0 +315,5 @@\n+    \/**\n+     * Sets the varargs bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -174,0 +324,5 @@\n+    \/**\n+     * Tests whether the varargs bit is on.\n+     *\n+     * @return whether the varargs bit is on.\n+     *\/\n@@ -175,1 +330,1 @@\n-        return (access_flags & Const.ACC_VARARGS) != 0;\n+        return test(Const.ACC_VARARGS);\n@@ -178,0 +333,5 @@\n+    \/**\n+     * Sets the varargs bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -182,0 +342,5 @@\n+    \/**\n+     * Tests whether the volatile bit is on.\n+     *\n+     * @return whether the volatile bit is on.\n+     *\/\n@@ -183,1 +348,1 @@\n-        return (access_flags & Const.ACC_VOLATILE) != 0;\n+        return test(Const.ACC_VOLATILE);\n@@ -186,0 +351,5 @@\n+    \/**\n+     * Sets the volatile bit.\n+     *\n+     * @param flag The new value.\n+     *\/\n@@ -191,1 +361,1 @@\n-     * Set access flags aka \"modifiers\".\n+     * Sets access flags also known as modifiers.\n@@ -210,1 +380,1 @@\n-     * Set access flags aka \"modifiers\".\n+     * Sets access flags aka \"modifiers\".\n@@ -217,0 +387,10 @@\n+\n+    \/**\n+     * Tests whether the bit is on.\n+     *\n+     * @param test the bit to test.\n+     * @return whether the bit is on.\n+     *\/\n+    private boolean test(final short test) {\n+        return (access_flags & test) != 0;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AccessFlags.java","additions":206,"deletions":26,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +29,1 @@\n+import jdk.xml.internal.Utils;\n@@ -35,0 +35,1 @@\n+ * @LastModified: Sept 2025\n@@ -40,1 +41,1 @@\n-    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {\n+    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attributes) {\n@@ -42,2 +43,2 @@\n-        return Stream.of(attrs).filter(Annotations.class::isInstance).flatMap(e -> Stream.of(((Annotations) e).getAnnotationEntries()))\n-            .toArray(AnnotationEntry[]::new);\n+        return Utils.streamOfIfNonNull(attributes).filter(Annotations.class::isInstance).flatMap(e -> Stream.of(((Annotations) e).getAnnotationEntries()))\n+                .toArray(AnnotationEntry[]::new);\n@@ -58,1 +59,0 @@\n-        annotationEntry.elementValuePairs = new ArrayList<>();\n@@ -72,1 +72,1 @@\n-    private List<ElementValuePair> elementValuePairs;\n+    private final List<ElementValuePair> elementValuePairs;\n@@ -78,0 +78,1 @@\n+        this.elementValuePairs = new ArrayList<>();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationEntry.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        this.annotationTable = annotationTable;\n+        setAnnotationTable(annotationTable);\n@@ -111,3 +111,0 @@\n-        if (annotationTable == null) {\n-            return 0;\n-        }\n@@ -132,1 +129,1 @@\n-        this.annotationTable = annotationTable;\n+        this.annotationTable = annotationTable != null ? annotationTable : AnnotationEntry.EMPTY_ARRAY;\n@@ -154,3 +151,0 @@\n-        if (annotationTable == null) {\n-            return;\n-        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Annotations.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {\n+    public ArrayElementValue(final int type, final ElementValue[] elementValues, final ConstantPool cpool) {\n@@ -39,1 +39,1 @@\n-        this.elementValues = datums;\n+        this.elementValues = elementValues != null ? elementValues : EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ArrayElementValue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -184,0 +184,2 @@\n+        case Const.ATTR_RECORD:\n+            return new Record(nameIndex, length, dataInput, constantPool);\n@@ -282,1 +284,1 @@\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", e); \/\/ never happens\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Attribute.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +29,1 @@\n+import jdk.xml.internal.Utils;\n@@ -38,0 +38,1 @@\n+ * @LastModified: Sept 2025\n@@ -41,0 +42,2 @@\n+    static final BootstrapMethod[] EMPTY_ARRAY = {};\n+\n@@ -57,1 +60,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -81,1 +84,1 @@\n-        this.bootstrapArguments = bootstrapArguments;\n+        setBootstrapArguments(bootstrapArguments);\n@@ -90,1 +93,1 @@\n-        } catch (final CloneNotSupportedException e) {\n+        } catch (final CloneNotSupportedException ignore) {\n@@ -135,1 +138,1 @@\n-        this.bootstrapArguments = bootstrapArguments;\n+        this.bootstrapArguments = Utils.createEmptyArrayIfNull(bootstrapArguments);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethod.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        this.bootstrapMethods = bootstrapMethods;\n+        setBootstrapMethods(bootstrapMethods);\n@@ -65,1 +65,1 @@\n-     * Construct object from Input stream.\n+     * Constructs object from Input stream.\n@@ -138,1 +138,1 @@\n-        this.bootstrapMethods = bootstrapMethods;\n+        this.bootstrapMethods = bootstrapMethods != null ? bootstrapMethods : BootstrapMethod.EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethods.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-     * <p>\n-     * Note that the detail message associated with {@code cause} is <i>not<\/i> automatically incorporated in this runtime exception's detail message.\n@@ -54,2 +52,2 @@\n-     * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that\n-     *                the cause is nonexistent or unknown.)\n+     * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method). A {@code null} value is permitted, and indicates that\n+     *                the cause is nonexistent or unknown.\n@@ -66,2 +64,2 @@\n-     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that the\n-     *              cause is nonexistent or unknown.)\n+     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method). A {@code null} value is permitted, and indicates that the\n+     *              cause is nonexistent or unknown.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassFormatException.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/\"> JVM specification 1.0<\/a>. See this paper for further details about\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\"> JVM specification 1.0<\/a>. See this paper for further details about\n@@ -60,1 +60,1 @@\n-    private final boolean isZip; \/\/ Loaded from zip file\n+    private final boolean isZip; \/\/ Loaded from ZIP file\n@@ -94,1 +94,1 @@\n-     * @param zipFile zip file name\n+     * @param zipFile ZIP file name\n@@ -107,1 +107,1 @@\n-     * not include verification of the byte code as it is performed by the java interpreter).\n+     * not include verification of the byte code as it is performed by the Java interpreter).\n@@ -154,1 +154,1 @@\n-            \/\/ if(file.available() > 0) {\n+            \/\/ if (file.available() > 0) {\n@@ -158,1 +158,1 @@\n-            \/\/ if(!(isZip && (buf.length == 1))) {\n+            \/\/ if (!(isZip && (buf.length == 1))) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassParser.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.xml.internal.Utils;\n@@ -62,1 +63,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -96,1 +97,1 @@\n-         * Read exception table that contains all regions where an exception handler is active, i.e., a try { ... } catch()\n+         * Read exception table that contains all regions where an exception handler is active, i.e., a try { ... } catch ()\n@@ -110,1 +111,1 @@\n-            attributes[i] = Attribute.readAttribute(file, constantPool);\n+            attributes[i] = readAttribute(file, constantPool);\n@@ -134,2 +135,2 @@\n-        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n+        this.code = Utils.createEmptyArrayIfNull(code);\n+        this.exceptionTable = Utils.createEmptyArrayIfNull(exceptionTable, CodeException[].class);\n@@ -266,0 +267,14 @@\n+    \/**\n+     * Gets the local variable type table attribute {@link LocalVariableTypeTable}.\n+     * @return LocalVariableTypeTable of Code, if it has one, null otherwise.\n+     * @since 6.10.0\n+     *\/\n+    public LocalVariableTypeTable getLocalVariableTypeTable() {\n+        for (final Attribute attribute : attributes) {\n+            if (attribute instanceof LocalVariableTypeTable) {\n+                return (LocalVariableTypeTable) attribute;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -280,0 +295,14 @@\n+    \/**\n+     * Finds the attribute of {@link StackMap} instance.\n+     * @return StackMap of Code, if it has one, else null.\n+     * @since 6.8.0\n+     *\/\n+    public StackMap getStackMap() {\n+        for (final Attribute attribute : attributes) {\n+            if (attribute instanceof StackMap) {\n+                return (StackMap) attribute;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -292,1 +321,1 @@\n-        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n+        this.code = Utils.createEmptyArrayIfNull(code);\n@@ -300,1 +329,1 @@\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n+        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Code.java","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -62,1 +62,1 @@\n-    static final CodeException[] EMPTY_CODE_EXCEPTION_ARRAY = {};\n+    static final CodeException[] EMPTY_ARRAY = {};\n@@ -67,1 +67,1 @@\n-    \/** active. startPc is inclusive, endPc exclusive. *\/\n+    \/** Active. startPc is inclusive, endPc exclusive. *\/\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/CodeException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -39,1 +39,3 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    static final Constant[] EMPTY_ARRAY = {};\n+\n+    private static BCELComparator<Constant> bcelComparator = new BCELComparator<Constant>() {\n@@ -42,4 +44,2 @@\n-        public boolean equals(final Object o1, final Object o2) {\n-            final Constant THIS = (Constant) o1;\n-            final Constant THAT = (Constant) o2;\n-            return Objects.equals(THIS.toString(), THAT.toString());\n+        public boolean equals(final Constant a, final Constant b) {\n+            return a == b || a != null && b != null && Objects.equals(a.toString(), b.toString());\n@@ -49,3 +49,2 @@\n-        public int hashCode(final Object o) {\n-            final Constant THIS = (Constant) o;\n-            return THIS.toString().hashCode();\n+        public int hashCode(final Constant o) {\n+            return o != null ? Objects.hashCode(o.toString()) : 0;\n@@ -56,1 +55,1 @@\n-     * @return Comparison strategy object\n+     * @return Comparison strategy object.\n@@ -58,1 +57,1 @@\n-    public static BCELComparator getComparator() {\n+    public static BCELComparator<Constant> getComparator() {\n@@ -116,1 +115,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n+    public static void setComparator(final BCELComparator<Constant> comparator) {\n@@ -151,1 +150,1 @@\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", e); \/\/ never happens\n@@ -177,1 +176,1 @@\n-        return bcelComparator.equals(this, obj);\n+        return obj instanceof Constant && bcelComparator.equals(this, (Constant) obj);\n@@ -188,1 +187,1 @@\n-     * Returns value as defined by given BCELComparator strategy. By default return the hashcode of the result of\n+     * Returns value as defined by given BCELComparator strategy. By default return the hash code of the result of\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Constant.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,5 +31,5 @@\n- * @see     ConstantFieldref\n- * @see     ConstantMethodref\n- * @see     ConstantInterfaceMethodref\n- * @see     ConstantInvokeDynamic\n- * @LastModified: Jun 2019\n+ * @see ConstantFieldref\n+ * @see ConstantMethodref\n+ * @see ConstantInterfaceMethodref\n+ * @see ConstantInvokeDynamic\n+ * @LastModified: Sept 2025\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantCP.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @see     Constant\n- * @LastModified: Jun 2019\n+ * @see Constant\n+ * @LastModified: Sept 2025\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantDouble.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @see     Constant\n- * @LastModified: Jun 2019\n+ * @see Constant\n+ * @LastModified: Sept 2025\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantFloat.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @see     Constant\n- * @LastModified: Jun 2019\n+ * @see Constant\n+ * @LastModified: Sept 2025\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInteger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @see     Constant\n- * @LastModified: Jan 2020\n+ * @see Constant\n+ * @LastModified: Sept 2025\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantLong.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,4 @@\n-     * @return object representing the constant, e.g., Long for ConstantLong\n+     * Gets the object representing the constant, e.g., Long for ConstantLong.\n+     *\n+     * @param constantPool the constant.\n+     * @return object representing the constant, e.g., Long for ConstantLong.\n@@ -34,1 +37,1 @@\n-    Object getConstantValue(ConstantPool cp);\n+    Object getConstantValue(ConstantPool constantPool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantObject.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -76,1 +76,1 @@\n-        this.constantPool = constantPool;\n+        setConstantPool(constantPool);\n@@ -91,0 +91,1 @@\n+         * constantPool[0] is currently unused by the implementation.\n@@ -291,1 +292,1 @@\n-        if (c.getTag() != tag) {\n+        if (c == null || c.getTag() != tag) {\n@@ -316,5 +317,1 @@\n-        \/\/ Previous check ensures this won't throw a ClassCastException\n-        final T c = castTo.cast(constantPool[index]);\n-        if (c == null\n-            \/\/ the 0th element is always null\n-            && index != 0) {\n+        if (index > 1) {\n@@ -322,2 +319,3 @@\n-            if (prev == null || prev.getTag() != Const.CONSTANT_Double && prev.getTag() != Const.CONSTANT_Long) {\n-                throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n+            if (prev != null && (prev.getTag() == Const.CONSTANT_Double || prev.getTag() == Const.CONSTANT_Long)) {\n+                throw new ClassFormatException(\"Constant pool at index \" + index + \" is invalid. The index is unused due to the preceeding \"\n+                        + Const.getConstantName(prev.getTag()) + \".\");\n@@ -326,0 +324,5 @@\n+        \/\/ Previous check ensures this won't throw a ClassCastException\n+        final T c = castTo.cast(constantPool[index]);\n+        if (c == null) {\n+            throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n+        }\n@@ -405,1 +408,1 @@\n-        return constantPool == null ? 0 : constantPool.length;\n+        return constantPool.length;\n@@ -424,1 +427,1 @@\n-        this.constantPool = constantPool;\n+        this.constantPool = constantPool != null ? constantPool : Constant.EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantPool.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * <li>{@value #SYS_PROP_CACHE_MAX_ENTRIES} (since 6.4): The size of the cache, by default 0, meaning caching is\n+ * <li>{@link #SYS_PROP_CACHE_MAX_ENTRIES} (since 6.4): The size of the cache, by default 0, meaning caching is\n@@ -41,1 +41,1 @@\n- * <li>{@value #SYS_PROP_CACHE_MAX_ENTRY_SIZE} (since 6.0): The maximum size of the values to cache, by default 200, 0\n+ * <li>{@link #SYS_PROP_CACHE_MAX_ENTRY_SIZE} (since 6.0): The maximum size of the values to cache, by default 200, 0\n@@ -43,1 +43,1 @@\n- * <li>{@value #SYS_PROP_STATISTICS} (since 6.0): Prints statistics on the console when the JVM exits.<\/li>\n+ * <li>{@link #SYS_PROP_STATISTICS} (since 6.0): Prints statistics on the console when the JVM exits.<\/li>\n@@ -61,1 +61,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -65,1 +65,1 @@\n-    private static class Cache {\n+    private static final class Cache {\n@@ -85,1 +85,1 @@\n-            return Cache.MAX_ENTRIES > 0 && MAX_ENTRY_SIZE > 0;\n+            return MAX_ENTRIES > 0 && MAX_ENTRY_SIZE > 0;\n@@ -120,0 +120,5 @@\n+    \/\/ Avoid Spotbugs complaint about Write to static field\n+    private static void countCreated() {\n+        created++;\n+    }\n+\n@@ -206,1 +211,1 @@\n-        created++;\n+        countCreated();\n@@ -215,1 +220,1 @@\n-        created++;\n+        countCreated();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantUtf8.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantValue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Deprecated.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import jdk.xml.internal.Utils;\n@@ -27,3 +28,2 @@\n- * Traverses a JavaClass with another Visitor object 'piggy-backed' that is\n- * applied to all components of a JavaClass object. I.e. this class supplies the\n- * traversal strategy, other classes can make use of it.\n+ * Traverses a JavaClass with another Visitor object 'piggy-backed' that is applied to all components of a JavaClass\n+ * object. I.e. this class supplies the traversal strategy, other classes can make use of it.\n@@ -31,0 +31,1 @@\n+ * @LastModified: Sept 2025\n@@ -49,1 +50,1 @@\n-        Stream.of(node).forEach(e -> e.accept(this));\n+        Utils.streamOfIfNonNull(node).forEach(e -> e.accept(this));\n@@ -510,0 +511,15 @@\n+    @Override\n+    public void visitRecord(final Record record) {\n+        stack.push(record);\n+        record.accept(visitor);\n+        accept(record.getComponents());\n+        stack.pop();\n+    }\n+\n+    @Override\n+    public void visitRecordComponent(final RecordComponentInfo recordComponentInfo) {\n+        stack.push(recordComponentInfo);\n+        recordComponentInfo.accept(visitor);\n+        stack.pop();\n+    }\n+\n@@ -534,0 +550,14 @@\n+        stack.push(var);\n+        var.accept(visitor);\n+        accept(var.getTypesOfLocals());\n+        accept(var.getTypesOfStackItems());\n+        stack.pop();\n+    }\n+\n+    \/**\n+     * Visits a {@link StackMapType} object.\n+     * @param var object to visit\n+     * @since 6.8.0\n+     *\/\n+    @Override\n+    public void visitStackMapType(final StackMapType var) {\n@@ -552,0 +582,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/DescendingVisitor.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -70,0 +70,1 @@\n+    static final ElementValue[] EMPTY_ARRAY = {};\n@@ -127,1 +128,1 @@\n-                evalues[j] = ElementValue.readElementValue(input, cpool, arrayNesting);\n+                evalues[j] = readElementValue(input, cpool, arrayNesting);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ElementValue.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -318,0 +318,9 @@\n+    \/**\n+     * Visits a {@link StackMapType} object.\n+     * @param obj object to visit\n+     * @since 6.8.0\n+     *\/\n+    @Override\n+    public void visitStackMapType(final StackMapType obj) {\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EmptyVisitor.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.xml.internal.Utils;\n@@ -46,1 +47,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -63,1 +64,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -88,1 +89,1 @@\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n+        this.exceptionIndexTable = Utils.createEmptyArrayIfNull(exceptionIndexTable);\n@@ -159,1 +160,1 @@\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n+        this.exceptionIndexTable = Utils.createEmptyArrayIfNull(exceptionIndexTable);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ExceptionTable.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    private static BCELComparator<Field> bcelComparator = new BCELComparator<Field>() {\n@@ -48,4 +48,2 @@\n-        public boolean equals(final Object o1, final Object o2) {\n-            final Field THIS = (Field) o1;\n-            final Field THAT = (Field) o2;\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+        public boolean equals(final Field a, final Field b) {\n+            return a == b || a != null && b != null && Objects.equals(a.getName(), b.getName()) && Objects.equals(a.getSignature(), b.getSignature());\n@@ -55,3 +53,2 @@\n-        public int hashCode(final Object o) {\n-            final Field THIS = (Field) o;\n-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n+        public int hashCode(final Field o) {\n+            return o != null ? Objects.hash(o.getSignature(), o.getName()) : 0;\n@@ -62,1 +59,1 @@\n-     * Empty array.\n+     * @return Comparison strategy object.\n@@ -64,6 +61,1 @@\n-    static final Field[] EMPTY_FIELD_ARRAY = {};\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n+    public static BCELComparator<Field> getComparator() {\n@@ -74,1 +66,1 @@\n-     * @param comparator Comparison strategy object\n+     * @param comparator Comparison strategy object.\n@@ -76,1 +68,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n+    public static void setComparator(final BCELComparator<Field> comparator) {\n@@ -81,1 +73,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -83,1 +75,1 @@\n-     * @param file Input stream\n+     * @param file Input stream.\n@@ -136,1 +128,1 @@\n-        return bcelComparator.equals(this, obj);\n+        return obj instanceof Field && bcelComparator.equals(this, (Field) obj);\n@@ -152,0 +144,2 @@\n+     * See https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.2.2\n+     *\n@@ -155,1 +149,1 @@\n-        return Type.getReturnType(getSignature());\n+        return Type.getType(getSignature());\n@@ -159,1 +153,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n+     * Return value as defined by given BCELComparator strategy. By default return the hash code of the field's name XOR\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Field.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Sept 2025\n@@ -75,1 +75,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -91,1 +91,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -140,1 +140,1 @@\n-            throw new IllegalStateException(e);\n+            throw new UnsupportedOperationException(e);\n@@ -155,4 +155,2 @@\n-        if (attributes != null) {\n-            for (final Attribute attribute : attributes) {\n-                attribute.dump(file);\n-            }\n+        for (final Attribute attribute : attributes) {\n+            attribute.dump(file);\n@@ -174,0 +172,16 @@\n+    \/**\n+     * Gets attribute for given tag.\n+     * @return Attribute for given tag, null if not found.\n+     * Refer to {@link com.sun.org.apache.bcel.internal.Const#ATTR_UNKNOWN} constants named ATTR_* for possible values.\n+     * @since 6.10.0\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public final <T extends Attribute> T getAttribute(final byte tag) {\n+        for (final Attribute attribute : getAttributes()) {\n+            if (attribute.getTag() == tag) {\n+                return (T) attribute;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -224,1 +238,1 @@\n-     * @return String representation of object's type signature (java style)\n+     * @return String representation of object's type signature (Java style)\n@@ -241,2 +255,2 @@\n-        this.attributes = attributes;\n-        this.attributes_count = attributes != null ? attributes.length : 0; \/\/ init deprecated field\n+        this.attributes = attributes != null ? attributes : Attribute.EMPTY_ARRAY;\n+        this.attributes_count = this.attributes.length; \/\/ init deprecated field\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/FieldOrMethod.java","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final InnerClass[] EMPTY_INNER_CLASSE_ARRAY = {};\n+    private static final InnerClass[] EMPTY_ARRAY = {};\n@@ -60,1 +60,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -85,1 +85,1 @@\n-        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n+        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_ARRAY;\n@@ -144,1 +144,1 @@\n-        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n+        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClasses.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+\n+package com.sun.org.apache.bcel.internal.classfile;\n+\n+\/**\n+ * Thrown when the BCEL attempts to read a class file and determines that a class is malformed or otherwise cannot be interpreted as a class file.\n+ *\n+ * @since 6.8.0\n+ *\/\n+public class InvalidMethodSignatureException extends ClassFormatException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    \/**\n+     * Constructs a new instance with the specified invalid signature as the message.\n+     *\n+     * @param signature The invalid signature is saved for later retrieval by the {@link #getMessage()} method.\n+     *\/\n+    public InvalidMethodSignatureException(final String signature) {\n+        super(signature);\n+    }\n+\n+    \/**\n+     * Constructs a new instance with the specified invalid signature as the message and a cause.\n+     *\n+     * @param signature The invalid signature is saved for later retrieval by the {@link #getMessage()} method.\n+     * @param cause     the cause (which is saved for later retrieval by the {@link #getCause()} method). A {@code null} value is permitted, and indicates that\n+     *                  the cause is nonexistent or unknown.\n+     *\/\n+    public InvalidMethodSignatureException(final String signature, final Throwable cause) {\n+        super(signature, cause);\n+    }\n+\n+}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InvalidMethodSignatureException.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.xml.internal.Utils;\n@@ -49,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -70,1 +71,1 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    private static BCELComparator<JavaClass> bcelComparator = new BCELComparator<JavaClass>() {\n@@ -73,4 +74,2 @@\n-        public boolean equals(final Object o1, final Object o2) {\n-            final JavaClass THIS = (JavaClass) o1;\n-            final JavaClass THAT = (JavaClass) o2;\n-            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n+        public boolean equals(final JavaClass a, final JavaClass b) {\n+            return a == b || a != null && b != null && Objects.equals(a.getClassName(), b.getClassName());\n@@ -80,3 +79,2 @@\n-        public int hashCode(final Object o) {\n-            final JavaClass THIS = (JavaClass) o;\n-            return THIS.getClassName().hashCode();\n+        public int hashCode(final JavaClass o) {\n+            return o != null ? Objects.hashCode(o.getClassName()) : 0;\n@@ -87,1 +85,1 @@\n-     * @return Comparison strategy object\n+     * @return Comparison strategy object.\n@@ -89,1 +87,1 @@\n-    public static BCELComparator getComparator() {\n+    public static BCELComparator<JavaClass> getComparator() {\n@@ -103,1 +101,1 @@\n-     * @param comparator Comparison strategy object\n+     * @param comparator Comparison strategy object.\n@@ -105,1 +103,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n+    public static void setComparator(final BCELComparator<JavaClass> comparator) {\n@@ -131,0 +129,1 @@\n+    private boolean isRecord;\n@@ -133,0 +132,1 @@\n+    private boolean computedRecord;\n@@ -180,3 +180,1 @@\n-        if (interfaces == null) {\n-            interfaces = Const.EMPTY_INT_ARRAY;\n-        }\n+        interfaces = Utils.createEmptyArrayIfNull(interfaces);\n@@ -187,1 +185,1 @@\n-            fields = Field.EMPTY_FIELD_ARRAY;\n+            fields = Field.EMPTY_ARRAY;\n@@ -190,1 +188,1 @@\n-            methods = Method.EMPTY_METHOD_ARRAY;\n+            methods = Method.EMPTY_ARRAY;\n@@ -257,0 +255,13 @@\n+    private void computeIsRecord() {\n+        if (computedRecord) {\n+            return;\n+        }\n+        for (final Attribute attribute : this.attributes) {\n+            if (attribute instanceof Record) {\n+                isRecord = true;\n+                break;\n+            }\n+        }\n+        this.computedRecord = true;\n+    }\n+\n@@ -387,1 +398,41 @@\n-        return bcelComparator.equals(this, obj);\n+        return obj instanceof JavaClass && bcelComparator.equals(this, (JavaClass) obj);\n+    }\n+\n+    \/**\n+     * Finds a visible field by name and type in this class and its super classes.\n+     * @param fieldName the field name to find\n+     * @param fieldType the field type to find\n+     * @return field matching given name and type, null if field is not found or not accessible from this class.\n+     * @throws ClassNotFoundException\n+     * @since 6.8.0\n+     *\/\n+    public Field findField(final String fieldName, final Type fieldType) throws ClassNotFoundException {\n+        for (final Field field : fields) {\n+            if (field.getName().equals(fieldName)) {\n+                final Type fType = Type.getType(field.getSignature());\n+                \/*\n+                 * TODO: Check if assignment compatibility is sufficient. What does Sun do?\n+                 *\/\n+                if (fType.equals(fieldType)) {\n+                    return field;\n+                }\n+            }\n+        }\n+\n+        final JavaClass superclass = getSuperClass();\n+        if (superclass != null && !\"java.lang.Object\".equals(superclass.getClassName())) {\n+            final Field f = superclass.findField(fieldName, fieldType);\n+            if (f != null && (f.isPublic() || f.isProtected() || !f.isPrivate() && packageName.equals(superclass.getPackageName()))) {\n+                return f;\n+            }\n+        }\n+        final JavaClass[] implementedInterfaces = getInterfaces();\n+        if (implementedInterfaces != null) {\n+            for (final JavaClass implementedInterface : implementedInterfaces) {\n+                final Field f = implementedInterface.findField(fieldName, fieldType);\n+                if (f != null) {\n+                    return f;\n+                }\n+            }\n+        }\n+        return null;\n@@ -391,1 +442,1 @@\n-     * Get all interfaces implemented by this JavaClass (transitively).\n+     * Gets all interfaces implemented by this JavaClass (transitively).\n@@ -412,1 +463,1 @@\n-        return allInterfaces.toArray(JavaClass.EMPTY_ARRAY);\n+        return allInterfaces.toArray(EMPTY_ARRAY);\n@@ -427,0 +478,16 @@\n+    \/**\n+     * Gets attribute for given tag.\n+     * @return Attribute for given tag, null if not found.\n+     * Refer to {@link com.sun.org.apache.bcel.internal.Const#ATTR_UNKNOWN} constants named ATTR_* for possible values.\n+     * @since 6.10.0\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public final <T extends Attribute> T getAttribute(final byte tag) {\n+        for (final Attribute attribute : getAttributes()) {\n+            if (attribute.getTag() == tag) {\n+                return (T) attribute;\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -498,1 +565,1 @@\n-     * Get interfaces directly implemented by this JavaClass.\n+     * Gets interfaces directly implemented by this JavaClass.\n@@ -590,1 +657,1 @@\n-     * @return the superclass for this JavaClass object, or null if this is java.lang.Object\n+     * @return the superclass for this JavaClass object, or null if this is {@link Object}\n@@ -610,1 +677,1 @@\n-        return allSuperClasses.toArray(JavaClass.EMPTY_ARRAY);\n+        return allSuperClasses.toArray(EMPTY_ARRAY);\n@@ -614,2 +681,2 @@\n-     * returns the super class name of this class. In the case that this class is java.lang.Object, it will return itself\n-     * (java.lang.Object). This is probably incorrect but isn't fixed at this time to not break existing clients.\n+     * returns the super class name of this class. In the case that this class is {@link Object}, it will return itself\n+     * ({@link Object}). This is probably incorrect but isn't fixed at this time to not break existing clients.\n@@ -631,1 +698,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n+     * Return value as defined by given BCELComparator strategy. By default return the hash code of the class name.\n@@ -648,1 +715,1 @@\n-        if (this.equals(inter)) {\n+        if (equals(inter)) {\n@@ -667,1 +734,1 @@\n-        if (this.equals(superclass)) {\n+        if (equals(superclass)) {\n@@ -701,0 +768,11 @@\n+    \/**\n+     * Tests whether this class was declared as a record\n+     *\n+     * @return true if a record attribute is present, false otherwise.\n+     * @since 6.9.0\n+     *\/\n+    public boolean isRecord() {\n+        computeIsRecord();\n+        return this.isRecord;\n+    }\n+\n@@ -709,1 +787,1 @@\n-        this.attributes = attributes;\n+        this.attributes = attributes != null ? attributes : Attribute.EMPTY_ARRAY;\n@@ -737,1 +815,1 @@\n-        this.fields = fields;\n+        this.fields = fields != null ? fields : Field.EMPTY_ARRAY;\n@@ -741,1 +819,1 @@\n-     * Set File name of class, aka SourceFile attribute value\n+     * Sets File name of class, aka SourceFile attribute value\n@@ -751,1 +829,1 @@\n-        this.interfaceNames = interfaceNames;\n+        this.interfaceNames = Utils.createEmptyArrayIfNull(interfaceNames, String[].class);\n@@ -758,1 +836,1 @@\n-        this.interfaces = interfaces;\n+        this.interfaces = Utils.createEmptyArrayIfNull(interfaces);\n@@ -772,1 +850,1 @@\n-        this.methods = methods;\n+        this.methods = methods != null ? methods : Method.EMPTY_ARRAY;\n@@ -790,1 +868,1 @@\n-     * Set absolute path to file this class was read from.\n+     * Sets absolute path to file this class was read from.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/JavaClass.java","additions":115,"deletions":37,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    \/** number in source file *\/\n+    \/** Number in source file *\/\n@@ -47,1 +47,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumber.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -47,1 +47,1 @@\n-     * Construct object from input stream.\n+     * Constructs a new instance from a data input stream.\n@@ -64,2 +64,2 @@\n-    \/*\n-     * @param nameIndex Index of name\n+    \/**\n+     * Constructs a new instance.\n@@ -67,0 +67,1 @@\n+     * @param nameIndex Index of name\n@@ -68,1 +69,0 @@\n-     *\n@@ -70,1 +70,0 @@\n-     *\n@@ -79,3 +78,5 @@\n-    \/*\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n+    \/**\n+     * Constructs a new instance from another.\n+     * <p>\n+     * Note that both objects use the same references (shallow copy). Use copy() for a physical copy.\n+     * <\/p>\n@@ -193,1 +194,1 @@\n-        this.lineNumberTable = lineNumberTable;\n+        this.lineNumberTable = lineNumberTable != null ? lineNumberTable : LineNumber.EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumberTable.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+    private static final LocalVariable[] EMPTY_ARRAY = {};\n+\n@@ -46,1 +48,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -71,1 +73,1 @@\n-        this.localVariableTable = localVariableTable != null ? localVariableTable : LocalVariable.EMPTY_ARRAY;\n+        this.localVariableTable = localVariableTable != null ? localVariableTable : EMPTY_ARRAY;\n@@ -170,1 +172,1 @@\n-        return localVariableTable == null ? 0 : localVariableTable.length;\n+        return localVariableTable.length;\n@@ -179,1 +181,1 @@\n-        this.localVariableTable = localVariableTable;\n+        this.localVariableTable = localVariableTable != null ? localVariableTable : EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTable.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+    private static final LocalVariable[] EMPTY_ARRAY = {};\n+\n@@ -70,1 +72,0 @@\n-\n@@ -73,1 +74,0 @@\n-\n@@ -100,1 +100,0 @@\n-\n@@ -122,1 +121,0 @@\n-\n@@ -140,1 +138,1 @@\n-        this.localVariableTypeTable = localVariableTable;\n+        this.localVariableTypeTable = localVariableTable != null ? localVariableTable : EMPTY_ARRAY;\n@@ -149,1 +147,0 @@\n-\n@@ -152,1 +149,0 @@\n-\n@@ -157,1 +153,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTypeTable.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    private static BCELComparator<Method> bcelComparator = new BCELComparator<Method>() {\n@@ -46,4 +46,2 @@\n-        public boolean equals(final Object o1, final Object o2) {\n-            final Method THIS = (Method) o1;\n-            final Method THAT = (Method) o2;\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+        public boolean equals(final Method a, final Method b) {\n+            return a == b || a != null && b != null && Objects.equals(a.getName(), b.getName()) && Objects.equals(a.getSignature(), b.getSignature());\n@@ -53,3 +51,2 @@\n-        public int hashCode(final Object o) {\n-            final Method THIS = (Method) o;\n-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n+        public int hashCode(final Method o) {\n+            return o != null ? Objects.hash(o.getSignature(), o.getName()) : 0;\n@@ -60,1 +57,1 @@\n-     * Empty array.\n+     * @return Comparison strategy object.\n@@ -62,6 +59,1 @@\n-    static final Method[] EMPTY_METHOD_ARRAY = {};\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n+    public static BCELComparator<Method> getComparator() {\n@@ -72,1 +64,1 @@\n-     * @param comparator Comparison strategy object\n+     * @param comparator Comparison strategy object.\n@@ -74,1 +66,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n+    public static void setComparator(final BCELComparator<Method> comparator) {\n@@ -78,1 +70,1 @@\n-    \/\/ annotations defined on the parameters of a method\n+    \/** Annotations defined on the parameters of a method. *\/\n@@ -88,1 +80,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -145,1 +137,1 @@\n-        return bcelComparator.equals(this, obj);\n+        return obj instanceof Method && bcelComparator.equals(this, (Method) obj);\n@@ -192,1 +184,1 @@\n-     * @return LocalVariableTable of code attribute if any, i.e. the call is forwarded to the Code atribute.\n+     * @return LocalVariableTable of code attribute if any, i.e. the call is forwarded to the Code attribute.\n@@ -202,0 +194,13 @@\n+    \/**\n+     * Gets the local variable type table attribute {@link LocalVariableTypeTable}.\n+     * @return LocalVariableTypeTable of code attribute if any, i.e. the call is forwarded to the Code attribute.\n+     * @since 6.10.0\n+     *\/\n+    public LocalVariableTypeTable getLocalVariableTypeTable() {\n+        final Code code = getCode();\n+        if (code == null) {\n+            return null;\n+        }\n+        return code.getLocalVariableTypeTable();\n+    }\n+\n@@ -221,1 +226,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n+     * Return value as defined by given BCELComparator strategy. By default return the hash code of the method's name XOR\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Method.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+ * <p>\n+ * Implements {@link Node} as of 6.7.0.\n+ * <\/p>\n@@ -49,1 +52,1 @@\n-     * Construct object from input stream.\n+     * Constructs an instance from a DataInput.\n@@ -78,1 +81,1 @@\n-     * Dump object to file stream on binary format.\n+     * Dumps object to file stream on binary format.\n@@ -97,1 +100,4 @@\n-     * Returns the name of the parameter.\n+     * Gets the name of the parameter.\n+     *\n+     * @param constantPool The pool to query.\n+     * @return Constant from the given pool.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameter.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final MethodParameter[] EMPTY_METHOD_PARAMETER_ARRAY = {};\n+    private static final MethodParameter[] EMPTY_ARRAY = {};\n@@ -47,1 +47,1 @@\n-    private MethodParameter[] parameters = EMPTY_METHOD_PARAMETER_ARRAY;\n+    private MethodParameter[] parameters = EMPTY_ARRAY;\n@@ -51,1 +51,0 @@\n-\n@@ -68,1 +67,0 @@\n-\n@@ -99,1 +97,1 @@\n-        this.parameters = parameters;\n+        this.parameters = parameters != null ? parameters : EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameters.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,7 @@\n+    private static String getClassNameAtIndex(final ConstantPool cp, final int index, final boolean compactClassName) {\n+        final String className = cp.getConstantString(index, Const.CONSTANT_Class);\n+        if (compactClassName) {\n+            return Utility.compactClassName(className, false);\n+        }\n+        return className;\n+    }\n@@ -49,1 +56,0 @@\n-    private final int moduleVersionIndex;\n@@ -51,0 +57,1 @@\n+    private final int moduleVersionIndex;\n@@ -56,0 +63,1 @@\n+\n@@ -59,1 +67,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -116,2 +124,0 @@\n-    \/\/ TODO add more getters and setters?\n-\n@@ -189,0 +195,19 @@\n+    \/**\n+     * Gets flags for this module.\n+     * @return module flags\n+     * @since 6.10.0\n+     *\/\n+    public int getModuleFlags() {\n+        return moduleFlags;\n+    }\n+\n+    \/**\n+     * Gets module name.\n+     * @param cp Array of constants\n+     * @return module name\n+     * @since 6.10.0\n+     *\/\n+    public String getModuleName(final ConstantPool cp) {\n+        return cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module);\n+    }\n+\n@@ -213,0 +238,25 @@\n+    \/**\n+     * Gets the array of class names for this module's uses.\n+     * @param constantPool Array of constants usually obtained from the ClassFile object\n+     * @param compactClassName false for original constant pool value, true to replace '\/' with '.'\n+     * @return array of used class names\n+     * @since 6.10.0\n+     *\/\n+    public String[] getUsedClassNames(final ConstantPool constantPool, final boolean compactClassName) {\n+        final String[] usedClassNames = new String[usesCount];\n+        for (int i = 0; i < usesCount; i++) {\n+            usedClassNames[i] = getClassNameAtIndex(constantPool, usesIndex[i], compactClassName);\n+        }\n+        return usedClassNames;\n+    }\n+\n+    \/**\n+     * Gets version for this module.\n+     * @param cp Array of constants\n+     * @return version from constant pool, \"0\" if version index is 0\n+     * @since 6.10.0\n+     *\/\n+    public String getVersion(final ConstantPool cp) {\n+        return moduleVersionIndex == 0 ? \"0\" : cp.getConstantString(moduleVersionIndex, Const.CONSTANT_Utf8);\n+    }\n+\n@@ -221,1 +271,1 @@\n-        buf.append(\"  name:    \").append(Utility.pathToPackage(cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module))).append(\"\\n\");\n+        buf.append(\"  name:    \").append(Utility.pathToPackage(getModuleName(cp))).append(\"\\n\");\n@@ -223,1 +273,1 @@\n-        final String version = moduleVersionIndex == 0 ? \"0\" : cp.getConstantString(moduleVersionIndex, Const.CONSTANT_Utf8);\n+        final String version = getVersion(cp);\n@@ -243,2 +293,2 @@\n-            final String className = cp.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"    \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String className = getClassNameAtIndex(cp, index, true);\n+            buf.append(\"    \").append(className).append(\"\\n\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Module.java","additions":58,"deletions":8,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+    private static String getToModuleNameAtIndex(final ConstantPool constantPool, final int index) {\n+        return constantPool.getConstantString(index, Const.CONSTANT_Module);\n+    }\n@@ -42,0 +45,1 @@\n+\n@@ -45,1 +49,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -71,2 +75,0 @@\n-    \/\/ TODO add more getters and setters?\n-\n@@ -100,0 +102,33 @@\n+    \/**\n+     * Gets the flags for this ModuleExports.\n+     * @return the exportsFlags\n+     * @since 6.10.0\n+     *\/\n+    public int getExportsFlags() {\n+        return exportsFlags;\n+    }\n+\n+    \/**\n+     * Gets the exported package name.\n+     * @param constantPool the constant pool from the ClassFile\n+     * @return the exported package name\n+     * @since 6.10.0\n+     *\/\n+    public String getPackageName(final ConstantPool constantPool) {\n+        return constantPool.constantToString(exportsIndex, Const.CONSTANT_Package);\n+    }\n+\n+    \/**\n+     * Gets an array of module names for this ModuleExports.\n+     * @param constantPool Array of constants usually obtained from the ClassFile object\n+     * @return array of module names following 'exports to'\n+     * @since 6.10.0\n+     *\/\n+    public String[] getToModuleNames(final ConstantPool constantPool) {\n+        final String[] toModuleNames = new String[exportsToCount];\n+        for (int i = 0; i < exportsToCount; i++) {\n+            toModuleNames[i] = getToModuleNameAtIndex(constantPool, exportsToIndex[i]);\n+        }\n+        return toModuleNames;\n+    }\n+\n@@ -113,2 +148,2 @@\n-        final String packageName = constantPool.constantToString(exportsIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(packageName, false));\n+        final String packageName = getPackageName(constantPool);\n+        buf.append(packageName);\n@@ -118,2 +153,2 @@\n-            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n+            final String moduleName = getToModuleNameAtIndex(constantPool, index);\n+            buf.append(\"      \").append(moduleName).append(\"\\n\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleExports.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleMainClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+    private static String getToModuleNameAtIndex(final ConstantPool constantPool, final int index) {\n+        return constantPool.getConstantString(index, Const.CONSTANT_Module);\n+    }\n@@ -42,0 +45,1 @@\n+\n@@ -45,1 +49,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -71,2 +75,0 @@\n-    \/\/ TODO add more getters and setters?\n-\n@@ -100,0 +102,33 @@\n+    \/**\n+     * Gets the flags for this ModuleOpens.\n+     * @return the opensFlags\n+     * @since 6.10.0\n+     *\/\n+    public int getOpensFlags() {\n+        return opensFlags;\n+    }\n+\n+    \/**\n+     * Gets the opened package name.\n+     * @param constantPool the constant pool from the ClassFile\n+     * @return the opened package name\n+     * @since 6.10.0\n+     *\/\n+    public String getPackageName(final ConstantPool constantPool) {\n+        return constantPool.constantToString(opensIndex, Const.CONSTANT_Package);\n+    }\n+\n+    \/**\n+     * Gets an array of module names for this ModuleOpens.\n+     * @param constantPool Array of constants usually obtained from the ClassFile object\n+     * @return array of module names following 'opens to'\n+     * @since 6.10.0\n+     *\/\n+    public String[] getToModuleNames(final ConstantPool constantPool) {\n+        final String[] toModuleNames = new String[opensToCount];\n+        for (int i = 0; i < opensToCount; i++) {\n+            toModuleNames[i] = getToModuleNameAtIndex(constantPool, opensToIndex[i]);\n+        }\n+        return toModuleNames;\n+    }\n+\n@@ -113,2 +148,2 @@\n-        final String packageName = constantPool.constantToString(opensIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(packageName, false));\n+        final String packageName = getPackageName(constantPool);\n+        buf.append(packageName);\n@@ -118,2 +153,2 @@\n-            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n+            final String moduleName = getToModuleNameAtIndex(constantPool, index);\n+            buf.append(\"      \").append(moduleName).append(\"\\n\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleOpens.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.xml.internal.Utils;\n@@ -36,1 +37,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -43,1 +44,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -68,1 +69,1 @@\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n+        this.packageIndexTable = Utils.createEmptyArrayIfNull(packageIndexTable);\n@@ -148,1 +149,1 @@\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n+        this.packageIndexTable = Utils.createEmptyArrayIfNull(packageIndexTable);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModulePackages.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,7 @@\n+    private static String getImplementationClassNameAtIndex(final ConstantPool constantPool, final int index, final boolean compactClassName) {\n+        final String className = constantPool.getConstantString(index, Const.CONSTANT_Class);\n+        if (compactClassName) {\n+            return Utility.compactClassName(className, false);\n+        }\n+        return className;\n+    }\n@@ -41,0 +48,1 @@\n+\n@@ -44,1 +52,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -69,2 +77,0 @@\n-    \/\/ TODO add more getters and setters?\n-\n@@ -97,0 +103,25 @@\n+    \/**\n+     * Gets the array of implementation class names for this ModuleProvides.\n+     * @param constantPool Array of constants usually obtained from the ClassFile object\n+     * @param compactClassName false for original constant pool value, true to replace '\/' with '.'\n+     * @return array of implementation class names\n+     * @since 6.10.0\n+     *\/\n+    public String[] getImplementationClassNames(final ConstantPool constantPool, final boolean compactClassName) {\n+        final String[] implementationClassNames = new String[providesWithCount];\n+        for (int i = 0; i < providesWithCount; i++) {\n+            implementationClassNames[i] = getImplementationClassNameAtIndex(constantPool, providesWithIndex[i], compactClassName);\n+        }\n+        return implementationClassNames;\n+    }\n+\n+    \/**\n+     * Gets the interface name for this ModuleProvides.\n+     * @param constantPool Array of constants usually obtained from the ClassFile object\n+     * @return interface name\n+     * @since 6.10.0\n+     *\/\n+    public String getInterfaceName(final ConstantPool constantPool) {\n+        return constantPool.constantToString(providesIndex, Const.CONSTANT_Class);\n+    }\n+\n@@ -110,2 +141,2 @@\n-        final String interfaceName = constantPool.constantToString(providesIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(interfaceName, false));\n+        final String interfaceName = getInterfaceName(constantPool);\n+        buf.append(interfaceName);\n@@ -114,2 +145,2 @@\n-            final String className = constantPool.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"      \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String className = getImplementationClassNameAtIndex(constantPool, index, true);\n+            buf.append(\"      \").append(className).append(\"\\n\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleProvides.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -66,2 +66,0 @@\n-    \/\/ TODO add more getters and setters?\n-\n@@ -92,0 +90,29 @@\n+    \/**\n+     * Gets the module name from the constant pool.\n+     * @param constantPool Array of constants usually obtained from the ClassFile object\n+     * @return module name\n+     * @since 6.10.0\n+     *\/\n+    public String getModuleName(final ConstantPool constantPool) {\n+        return constantPool.constantToString(requiresIndex, Const.CONSTANT_Module);\n+    }\n+\n+    \/**\n+     * Gets the flags for this ModuleRequires.\n+     * @return the requiresFlags\n+     * @since 6.10.0\n+     *\/\n+    public int getRequiresFlags() {\n+        return requiresFlags;\n+    }\n+\n+    \/**\n+     * Gets the required version from the constant pool.\n+     * @param constantPool Array of constants usually obtained from the ClassFile object\n+     * @return required version, \"0\" if version index is 0.\n+     * @since 6.10.0\n+     *\/\n+    public String getVersion(final ConstantPool constantPool) {\n+        return requiresVersionIndex == 0 ? \"0\" : constantPool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n+    }\n+\n@@ -105,2 +132,2 @@\n-        final String moduleName = constantPool.constantToString(requiresIndex, Const.CONSTANT_Module);\n-        buf.append(Utility.compactClassName(moduleName, false));\n+        final String moduleName = getModuleName(constantPool);\n+        buf.append(moduleName);\n@@ -108,1 +135,1 @@\n-        final String version = requiresVersionIndex == 0 ? \"0\" : constantPool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n+        final String version = getVersion(constantPool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleRequires.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.xml.internal.Utils;\n@@ -37,1 +38,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -44,1 +45,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -69,1 +70,1 @@\n-        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n+        this.classes = Utils.createEmptyArrayIfNull(classes);\n@@ -149,1 +150,1 @@\n-        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n+        this.classes = Utils.createEmptyArrayIfNull(classes);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/NestMembers.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    void accept(Visitor obj);\n+    void accept(Visitor visitor);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Node.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/PMGClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,4 @@\n-    public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attrs) {\n+    public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attributes) {\n+        if (attributes == null) {\n+            return EMPTY_ARRAY;\n+        }\n@@ -42,2 +45,2 @@\n-        final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n-        for (final Attribute attribute : attrs) {\n+        final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attributes.length);\n+        for (final Attribute attribute : attributes) {\n@@ -46,1 +49,4 @@\n-                Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getParameterAnnotationEntries());\n+                final ParameterAnnotationEntry[] parameterAnnotationEntries = runtimeAnnotations.getParameterAnnotationEntries();\n+                if (parameterAnnotationEntries != null) {\n+                    Collections.addAll(accumulatedAnnotations, parameterAnnotationEntries);\n+                }\n@@ -49,1 +55,1 @@\n-        return accumulatedAnnotations.toArray(ParameterAnnotationEntry.EMPTY_ARRAY);\n+        return accumulatedAnnotations.toArray(EMPTY_ARRAY);\n@@ -55,1 +61,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotationEntry.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+    private static final ParameterAnnotationEntry[] EMPTY_ARRAY = {};\n+\n@@ -41,0 +43,2 @@\n+     * Constructs a new instance.\n+     *\n@@ -58,0 +62,2 @@\n+     * Constructs a new instance.\n+     *\n@@ -123,1 +129,1 @@\n-        this.parameterAnnotationTable = parameterAnnotationTable;\n+        this.parameterAnnotationTable = parameterAnnotationTable != null ? parameterAnnotationTable : EMPTY_ARRAY;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotations.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+\n+package com.sun.org.apache.bcel.internal.classfile;\n+\n+import java.io.DataInput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.util.Args;\n+\n+\/**\n+ * Extends {@link Attribute} and records the classes and\n+ * interfaces that are authorized to claim membership in the nest hosted by the\n+ * current class or interface. There may be at most one Record attribute in a\n+ * ClassFile structure.\n+ *\n+ * @see Attribute\n+ * @since 6.9.0\n+ *\/\n+public final class Record extends Attribute {\n+\n+    private static final RecordComponentInfo[] EMPTY_RCI_ARRAY = {};\n+\n+    private static RecordComponentInfo[] readComponents(final DataInput input, final ConstantPool constantPool)\n+            throws IOException {\n+        final int classCount = input.readUnsignedShort();\n+        final RecordComponentInfo[] components = new RecordComponentInfo[classCount];\n+        for (int i = 0; i < classCount; i++) {\n+            components[i] = new RecordComponentInfo(input, constantPool);\n+        }\n+        return components;\n+    }\n+\n+    private RecordComponentInfo[] components;\n+\n+    \/**\n+     * Constructs object from input stream.\n+     *\n+     * @param nameIndex    Index in constant pool\n+     * @param length       Content length in bytes\n+     * @param input        Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    Record(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n+            throws IOException {\n+        this(nameIndex, length, readComponents(input, constantPool), constantPool);\n+    }\n+\n+    \/**\n+     * Constructs a new instance using components.\n+     *\n+     * @param nameIndex    Index in constant pool\n+     * @param length       Content length in bytes\n+     * @param classes      Array of Record Component Info elements\n+     * @param constantPool Array of constants\n+     *\/\n+    public Record(final int nameIndex, final int length, final RecordComponentInfo[] classes,\n+            final ConstantPool constantPool) {\n+        super(Const.ATTR_RECORD, nameIndex, length, constantPool);\n+        this.components = classes != null ? classes : EMPTY_RCI_ARRAY;\n+        Args.requireU2(this.components.length, \"attributes.length\");\n+    }\n+\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. For example, the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitRecord(this);\n+    }\n+\n+    \/**\n+     * Copies this instance and its components.\n+     *\n+     * @return a deep copy of this instance and its components.\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final Record c = (Record) clone();\n+        if (components.length > 0) {\n+            c.components = components.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n+\n+    \/**\n+     * Dumps this instance into a file stream in binary format.\n+     *\n+     * @param file output stream.\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    @Override\n+    public void dump(final DataOutputStream file) throws IOException {\n+        super.dump(file);\n+        file.writeShort(components.length);\n+        for (final RecordComponentInfo component : components) {\n+            component.dump(file);\n+        }\n+    }\n+\n+    \/**\n+     * Gets all the record components.\n+     *\n+     * @return array of Record Component Info elements.\n+     *\/\n+    public RecordComponentInfo[] getComponents() {\n+        return components;\n+    }\n+\n+    \/**\n+     * Converts this instance to a String suitable for debugging.\n+     *\n+     * @return String a String suitable for debugging.\n+     *\/\n+    @Override\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder();\n+        buf.append(\"Record(\");\n+        buf.append(components.length);\n+        buf.append(\"):\\n\");\n+        for (final RecordComponentInfo component : components) {\n+            buf.append(\"  \").append(component.toString()).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+    }\n+\n+}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Record.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+package com.sun.org.apache.bcel.internal.classfile;\n+\n+import java.io.DataInput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n+\n+\/**\n+ * Record component info from a record. Instances from this class maps\n+ * every component from a given record.\n+ *\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se14\/preview\/specs\/records-jvms.html#jvms-4.7.30\">\n+ *      The Java Virtual Machine Specification, Java SE 14 Edition, Records (preview)<\/a>\n+ * @since 6.9.0\n+ *\/\n+public class RecordComponentInfo implements Node {\n+\n+    private final int index;\n+    private final int descriptorIndex;\n+    private final Attribute[] attributes;\n+    private final ConstantPool constantPool;\n+\n+    \/**\n+     * Constructs a new instance from an input stream.\n+     *\n+     * @param input        Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    public RecordComponentInfo(final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this.index = input.readUnsignedShort();\n+        this.descriptorIndex = input.readUnsignedShort();\n+        final int attributesCount = input.readUnsignedShort();\n+        this.attributes = new Attribute[attributesCount];\n+        for (int j = 0; j < attributesCount; j++) {\n+            attributes[j] = Attribute.readAttribute(input, constantPool);\n+        }\n+        this.constantPool = constantPool;\n+    }\n+\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitRecordComponent(this);\n+    }\n+\n+    \/**\n+     * Dumps contents into a file stream in binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    public void dump(final DataOutputStream file) throws IOException {\n+        file.writeShort(index);\n+        file.writeShort(descriptorIndex);\n+        file.writeShort(attributes.length);\n+        for (final Attribute attribute : attributes) {\n+            attribute.dump(file);\n+        }\n+    }\n+\n+    \/**\n+     * Gets all attributes.\n+     *\n+     * @return all attributes.\n+     *\/\n+    public Attribute[] getAttributes() {\n+        return attributes;\n+    }\n+\n+    \/**\n+     * Gets the constant pool.\n+     *\n+     * @return Constant pool.\n+     *\/\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n+    }\n+\n+    \/**\n+     * Gets the description index.\n+     *\n+     * @return index in constant pool of this record component descriptor.\n+     *\/\n+    public int getDescriptorIndex() {\n+        return descriptorIndex;\n+    }\n+\n+    \/**\n+     * Gets the name index.\n+     *\n+     * @return index in constant pool of this record component name.\n+     *\/\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    \/**\n+     * Converts this instance to a String suitable for debugging.\n+     *\n+     * @return a String suitable for debugging.\n+     *\/\n+    @Override\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder();\n+        buf.append(\"RecordComponentInfo(\");\n+        buf.append(constantPool.getConstantString(index, Const.CONSTANT_Utf8));\n+        buf.append(\",\");\n+        buf.append(constantPool.getConstantString(descriptorIndex, Const.CONSTANT_Utf8));\n+        buf.append(\",\");\n+        buf.append(attributes.length);\n+        buf.append(\"):\\n\");\n+        for (final Attribute attribute : attributes) {\n+            buf.append(\"  \").append(attribute.toString()).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+    }\n+\n+}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RecordComponentInfo.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * represents an annotation that is represented in the class file but is not provided to the JVM.\n+ * An annotation that is represented in the class file but is not provided to the JVM.\n@@ -38,0 +38,2 @@\n+     * Constructs a new instance.\n+     *\n@@ -49,1 +51,3 @@\n-     * @return deep copy of this attribute\n+     * Creates a deep copy of this attribute.\n+     *\n+     * @return deep copy of this attribute.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleAnnotations.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+     * Constructs a new instance.\n+     *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleParameterAnnotations.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * represents an annotation that is represented in the class file and is provided to the JVM.\n+ * An annotation that is represented in the class file and is provided to the JVM.\n@@ -38,0 +38,2 @@\n+     * Constructs a new instance.\n+     *\n@@ -49,1 +51,3 @@\n-     * @return deep copy of this attribute\n+     * Creates a deep copy of this attribute.\n+     *\n+     * @return deep copy of this attribute.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleAnnotations.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+     * Constructs a new instance.\n+     *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleParameterAnnotations.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-        \/\/ System.out.println(\"return from ident:\" + (char)ch);\n+        \/\/ System.out.println(\"return from ident:\" + (char) ch);\n@@ -131,1 +131,1 @@\n-                \/\/ System.out.println(\"so far:\" + buf2 + \":next:\" +(char)ch);\n+                \/\/ System.out.println(\"so far:\" + buf2 + \":next:\" +(char) ch);\n@@ -144,1 +144,1 @@\n-            \/\/ System.out.println(\"within ident:\"+ (char)ch);\n+            \/\/ System.out.println(\"within ident:\"+ (char) ch);\n@@ -147,1 +147,1 @@\n-        \/\/ System.out.println(\"regular return ident:\"+ (char)ch + \":\" + buf2);\n+        \/\/ System.out.println(\"regular return ident:\"+ (char) ch + \":\" + buf2);\n@@ -163,1 +163,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Signature.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            throw new ClassFormatException(\"SimpleElementValue doesnt know how to write out type \" + type);\n+            throw new ClassFormatException(\"SimpleElementValue doesn't know how to write out type \" + type);\n@@ -70,1 +70,1 @@\n-            throw new IllegalStateException(\"Dont call getValueBoolean() on a non BOOLEAN ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueBoolean() on a non BOOLEAN ElementValue\");\n@@ -78,1 +78,1 @@\n-            throw new IllegalStateException(\"Dont call getValueByte() on a non BYTE ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueByte() on a non BYTE ElementValue\");\n@@ -85,1 +85,1 @@\n-            throw new IllegalStateException(\"Dont call getValueChar() on a non CHAR ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueChar() on a non CHAR ElementValue\");\n@@ -92,1 +92,1 @@\n-            throw new IllegalStateException(\"Dont call getValueDouble() on a non DOUBLE ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueDouble() on a non DOUBLE ElementValue\");\n@@ -100,1 +100,1 @@\n-            throw new IllegalStateException(\"Dont call getValueFloat() on a non FLOAT ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueFloat() on a non FLOAT ElementValue\");\n@@ -108,1 +108,1 @@\n-            throw new IllegalStateException(\"Dont call getValueInt() on a non INT ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueInt() on a non INT ElementValue\");\n@@ -115,1 +115,1 @@\n-            throw new IllegalStateException(\"Dont call getValueLong() on a non LONG ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueLong() on a non LONG ElementValue\");\n@@ -123,1 +123,1 @@\n-            throw new IllegalStateException(\"Dont call getValueShort() on a non SHORT ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueShort() on a non SHORT ElementValue\");\n@@ -131,1 +131,1 @@\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueString() on a non STRING ElementValue\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SimpleElementValue.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SourceFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n- * <a href=\"http:\/\/java.sun.com\/j2me\/\"> Java 2 Micro Edition<\/a> (J2ME). This attribute is used by the\n- * <a href=\"http:\/\/java.sun.com\/products\/cldc\/\">KVM<\/a> and contained within the Code attribute of a method. See CLDC\n+ * <a href=\"https:\/\/java.sun.com\/j2me\/\"> Java 2 Micro Edition<\/a> (J2ME). This attribute is used by the\n+ * <a href=\"https:\/\/java.sun.com\/products\/cldc\/\">KVM<\/a> and contained within the Code attribute of a method. See CLDC\n@@ -49,1 +49,1 @@\n- * @LastModified: Oct 2020\n+ * @LastModified: Sept 2025\n@@ -56,1 +56,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMap.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n@@ -78,3 +78,1 @@\n-        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n-            byteCodeOffset = dataInput.readUnsignedShort();\n-        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX || frameType == Const.SAME_FRAME_EXTENDED) {\n@@ -170,1 +168,1 @@\n-            throw new Error(\"Clone Not Supported\");\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", ex);\n@@ -193,3 +191,1 @@\n-        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n-            file.writeShort(byteCodeOffset);\n-        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX || frameType == Const.SAME_FRAME_EXTENDED) {\n@@ -235,1 +231,0 @@\n-     *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapEntry.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public final class StackMapType implements Cloneable {\n+public final class StackMapType implements Node, Cloneable {\n@@ -39,1 +39,1 @@\n-    public static final StackMapType[] EMPTY_ARRAY = {}; \/\/ must be public because BCELifier code generator writes calls to it\n+    public static final StackMapType[] EMPTY_ARRAY = {}; \/\/ BCELifier code generator writes calls to constructor translating null to EMPTY_ARRAY\n@@ -56,1 +56,1 @@\n-     * Construct object from file stream.\n+     * Constructs object from file stream.\n@@ -69,0 +69,12 @@\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     * @since 6.8.0\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitStackMapType(this);\n+    }\n+\n@@ -101,0 +113,9 @@\n+    \/**\n+     * Gets the class name of this StackMapType from the constant pool at index position.\n+     * @return the fully qualified name of the class for this StackMapType.\n+     * @since 6.8.0\n+     *\/\n+    public String getClassName() {\n+        return constantPool.constantToString(index, Const.CONSTANT_Class);\n+    }\n+\n@@ -132,1 +153,1 @@\n-            return \", class=\" + constantPool.constantToString(index, Const.CONSTANT_Class);\n+            return \", class=\" + getClassName();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapType.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-     * Construct object from input stream.\n+     * Constructs object from input stream.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Synthetic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -54,1 +54,1 @@\n-    private static class JavaReader extends FilterReader {\n+    private static final class JavaReader extends FilterReader {\n@@ -91,1 +91,1 @@\n-     * Encode bytes into valid java identifier characters. Used by\n+     * Encode bytes into valid Java identifier characters. Used by\n@@ -94,1 +94,1 @@\n-    private static class JavaWriter extends FilterWriter {\n+    private static final class JavaWriter extends FilterWriter {\n@@ -440,1 +440,3 @@\n-            \/\/$FALL-THROUGH$\n+            index = bytes.readUnsignedShort();\n+            buf.append(\"\\t<\").append(constantPool.constantToString(index, Const.CONSTANT_Class)).append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n@@ -867,1 +869,1 @@\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                throw new InvalidMethodSignatureException(signature);\n@@ -875,1 +877,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -906,1 +908,1 @@\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                throw new InvalidMethodSignatureException(signature);\n@@ -910,1 +912,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -962,1 +964,1 @@\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                throw new InvalidMethodSignatureException(signature);\n@@ -988,1 +990,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -1175,1 +1177,1 @@\n-            type = type + typeSignatureToString(signature.substring(index), chopit);\n+            type += typeSignatureToString(signature.substring(index), chopit);\n@@ -1240,1 +1242,1 @@\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                throw new InvalidMethodSignatureException(signature);\n@@ -1245,1 +1247,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -1289,1 +1291,1 @@\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                throw new InvalidMethodSignatureException(signature);\n@@ -1292,1 +1294,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -1472,2 +1474,2 @@\n-                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                    consumedChars = unwrap(CONSUMER_CHARS) + consumedChars;\n+                    wrap(CONSUMER_CHARS, consumedChars);\n@@ -1493,2 +1495,2 @@\n-                        consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                        wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                        consumedChars = unwrap(CONSUMER_CHARS) + consumedChars;\n+                        wrap(CONSUMER_CHARS, consumedChars);\n@@ -1511,2 +1513,2 @@\n-                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                    consumedChars = unwrap(CONSUMER_CHARS) + consumedChars;\n+                    wrap(CONSUMER_CHARS, consumedChars);\n@@ -1518,1 +1520,1 @@\n-                wrap(Utility.CONSUMER_CHARS, consumedChars + 1); \/\/ remove final \";\"\n+                wrap(CONSUMER_CHARS, consumedChars + 1); \/\/ remove final \";\"\n@@ -1539,3 +1541,3 @@\n-                \/\/ Utility.consumed_chars += consumed_chars; is replaced by:\n-                final int temp = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                wrap(Utility.CONSUMER_CHARS, temp);\n+                \/\/ consumed_chars += consumed_chars; is replaced by:\n+                final int temp = unwrap(CONSUMER_CHARS) + consumedChars;\n+                wrap(CONSUMER_CHARS, temp);\n@@ -1555,1 +1557,1 @@\n-        return tl.get();\n+        return tl.get().intValue();\n@@ -1559,1 +1561,1 @@\n-        tl.set(value);\n+        tl.set(Integer.valueOf(value));\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Utility.java","additions":31,"deletions":29,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+\n@@ -225,0 +226,20 @@\n+    \/**\n+     * Visits a {@link Record} object.\n+     *\n+     * @param obj Record to visit\n+     * @since 6.9.0\n+     *\/\n+    default void visitRecord(final Record obj) {\n+        \/\/ empty\n+    }\n+\n+    \/**\n+     * Visits a {@link RecordComponentInfo} object.\n+     *\n+     * @param record component to visit\n+     * @since 6.9.0\n+     *\/\n+    default void visitRecordComponent(final RecordComponentInfo record) {\n+     \/\/ noop\n+    }\n+\n@@ -233,0 +254,10 @@\n+    \/**\n+     * Visits a {@link StackMapType} object.\n+     *\n+     * @param obj object to visit\n+     * @since 6.8.0\n+     *\/\n+    default void visitStackMapType(final StackMapType obj) {\n+      \/\/ empty\n+    }\n+\n@@ -236,0 +267,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Visitor.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+\n+\/**\n+ * Classes that describe the structure of a Java class file and a class file parser.\n+ *\/\n+package com.sun.org.apache.bcel.internal.classfile;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/package-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -36,1 +36,1 @@\n-     * Get length of array\n+     * Gets length of array\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ARRAYLENGTH.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+ *\n+ * @LastModified: Sept 2025\n@@ -32,1 +34,1 @@\n-public class ATHROW extends Instruction implements UnconditionalBranch, ExceptionThrower {\n+public class ATHROW extends Instruction implements UnconditionalBranch, ExceptionThrower, StackConsumer {\n@@ -51,0 +53,1 @@\n+        v.visitStackConsumer(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ATHROW.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +41,1 @@\n+import jdk.xml.internal.Utils;\n@@ -43,1 +45,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Sept 2025\n@@ -56,1 +58,1 @@\n-        if (annotationEntryGens.length == 0) {\n+        if (annotationEntryGens == null && annotationEntryGens.length == 0) {\n@@ -258,5 +260,1 @@\n-        final List<ElementValuePairGen> out = new ArrayList<>();\n-        for (final ElementValuePair nvp : in) {\n-            out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));\n-        }\n-        return out;\n+        return Utils.streamOfIfNonNull(in).map(nvp -> new ElementValuePairGen(nvp, cpool, copyPoolEntries)).collect(Collectors.toList());\n@@ -289,1 +287,1 @@\n-        return getTypeSignature();\/\/ BCELBUG: Should I use this instead?\n+        return getTypeSignature(); \/\/ BCELBUG: Should I use this instead?\n@@ -294,1 +292,1 @@\n-        \/\/ ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);\n+        \/\/ ConstantClass c = (ConstantClass) cpool.getConstant(typeIndex);\n@@ -300,1 +298,3 @@\n-     * Returns list of ElementNameValuePair objects\n+     * Returns list of ElementNameValuePair objects.\n+     *\n+     * @return list of ElementNameValuePair objects.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AnnotationEntryGen.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +27,1 @@\n+import java.util.stream.Collectors;\n@@ -31,0 +31,1 @@\n+import jdk.xml.internal.Utils;\n@@ -34,0 +35,1 @@\n+ * @LastModified: Sept 2025\n@@ -49,1 +51,1 @@\n-            evalues.add(ElementValueGen.copy(element, cpool, copyPoolEntries));\n+            evalues.add(copy(element, cpool, copyPoolEntries));\n@@ -58,1 +60,1 @@\n-    public ArrayElementValueGen(final int type, final ElementValue[] datums, final ConstantPoolGen cpool) {\n+    public ArrayElementValueGen(final int type, final ElementValue[] elementValues, final ConstantPoolGen cpool) {\n@@ -63,4 +65,1 @@\n-        this.evalues = new ArrayList<>();\n-        for (final ElementValue datum : datums) {\n-            evalues.add(ElementValueGen.copy(datum, cpool, true));\n-        }\n+        this.evalues = Utils.streamOfIfNonNull(elementValues).map(e -> copy(e, cpool, true)).collect(Collectors.toList());\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayElementValueGen.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +26,2 @@\n+ *\n+ * @LastModified: Sept 2025\n@@ -46,1 +47,1 @@\n-     * @param className complete name of class (java.lang.String, e.g.)\n+     * @param className complete name of class ({@link String}, for example)\n@@ -59,0 +60,1 @@\n+    @SuppressWarnings(\"deprecation\") \/\/signature\n@@ -82,1 +84,1 @@\n-        super.setSignature(buf.toString());\n+        this.signature = buf.toString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayType.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-     * Set new contents. Old instruction is disposed and may not be used anymore.\n+     * Sets new contents. Old instruction is disposed and may not be used anymore.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BranchHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Sept 2025\n@@ -107,1 +107,1 @@\n-     * Set the index to constant pool.\n+     * Sets the index to constant pool.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CPInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        super(ElementValueGen.CLASS, cpool);\n+        super(CLASS, cpool);\n@@ -56,1 +56,1 @@\n-        super(ElementValueGen.CLASS, cpool);\n+        super(CLASS, cpool);\n@@ -70,1 +70,1 @@\n-        \/\/ ConstantClass c = (ConstantClass)getConstantPool().getConstant(idx);\n+        \/\/ ConstantClass c = (ConstantClass) getConstantPool().getConstant(idx);\n@@ -72,1 +72,1 @@\n-        \/\/ (ConstantUtf8)getConstantPool().getConstant(c.getNameIndex());\n+        \/\/ (ConstantUtf8) getConstantPool().getConstant(c.getNameIndex());\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassElementValueGen.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * Template class for building up a java class. May be initialized with an existing java class (file).\n+ * Template class for building up a java class. May be initialized with an existing Java class (file).\n@@ -46,1 +46,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -50,1 +50,1 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    private static BCELComparator<ClassGen> bcelComparator = new BCELComparator<ClassGen>() {\n@@ -53,4 +53,2 @@\n-        public boolean equals(final Object o1, final Object o2) {\n-            final ClassGen THIS = (ClassGen) o1;\n-            final ClassGen THAT = (ClassGen) o2;\n-            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n+        public boolean equals(final ClassGen a, final ClassGen b) {\n+            return a == b || a != null && b != null && Objects.equals(a.getClassName(), b.getClassName());\n@@ -60,3 +58,2 @@\n-        public int hashCode(final Object o) {\n-            final ClassGen THIS = (ClassGen) o;\n-            return THIS.getClassName().hashCode();\n+        public int hashCode(final ClassGen o) {\n+            return o != null ? Objects.hashCode(o.getClassName()) : 0;\n@@ -69,1 +66,1 @@\n-    public static BCELComparator getComparator() {\n+    public static BCELComparator<ClassGen> getComparator() {\n@@ -76,1 +73,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n+    public static void setComparator(final BCELComparator<ClassGen> comparator) {\n@@ -104,1 +101,1 @@\n-     * Initialize with existing class.\n+     * Constructs a new instance from an existing class.\n@@ -121,4 +118,9 @@\n-        Collections.addAll(interfaceList, clazz.getInterfaceNames());\n-        for (final Attribute attribute : attributes) {\n-            if (!(attribute instanceof Annotations)) {\n-                addAttribute(attribute);\n+        final String[] interfaceNames = clazz.getInterfaceNames();\n+        if (interfaceNames != null) {\n+            Collections.addAll(interfaceList, interfaceNames);\n+        }\n+        if (attributes != null) {\n+            for (final Attribute attribute : attributes) {\n+                if (!(attribute instanceof Annotations)) {\n+                    addAttribute(attribute);\n+                }\n@@ -128,2 +130,8 @@\n-        Collections.addAll(methodList, clazz.getMethods());\n-        Collections.addAll(fieldList, clazz.getFields());\n+        final Method[] methods = clazz.getMethods();\n+        if (methods != null) {\n+            Collections.addAll(methodList, methods);\n+        }\n+        final Field[] fields = clazz.getFields();\n+        if (fields != null) {\n+            Collections.addAll(fieldList, fields);\n+        }\n@@ -245,1 +253,1 @@\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", e); \/\/ never happens\n@@ -285,1 +293,1 @@\n-        return bcelComparator.equals(this, obj);\n+        return obj instanceof ClassGen && bcelComparator.equals(this, (ClassGen) obj);\n@@ -382,1 +390,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n+     * Return value as defined by given BCELComparator strategy. By default return the hash code of the class name.\n@@ -481,1 +489,1 @@\n-     * Set major version number of class file, default value is 45 (JDK 1.1)\n+     * Sets major version number of class file, default value is 45 (JDK 1.1)\n@@ -495,1 +503,3 @@\n-        Collections.addAll(methodList, methods);\n+        if (methods != null) {\n+            Collections.addAll(methodList, methods);\n+        }\n@@ -499,1 +509,1 @@\n-     * Set minor version number of class file, default value is 3 (JDK 1.1)\n+     * Sets minor version number of class file, default value is 3 (JDK 1.1)\n@@ -518,1 +528,1 @@\n-     * Look for attributes representing annotations and unpack them.\n+     * Unpacks attributes representing annotations.\n@@ -520,1 +530,1 @@\n-    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {\n+    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attributes) {\n@@ -522,7 +532,9 @@\n-        for (final Attribute attr : attrs) {\n-            if (attr instanceof RuntimeVisibleAnnotations) {\n-                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n-                rva.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n-            } else if (attr instanceof RuntimeInvisibleAnnotations) {\n-                final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n-                ria.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n+        if (attributes != null) {\n+            for (final Attribute attr : attributes) {\n+                if (attr instanceof RuntimeVisibleAnnotations) {\n+                    final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n+                    rva.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n+                } else if (attr instanceof RuntimeInvisibleAnnotations) {\n+                    final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n+                    ria.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n+                }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassGen.java","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", e); \/\/ never happens\n@@ -84,1 +84,1 @@\n-     * Get CodeException object.<BR>\n+     * Gets CodeException object.<BR>\n@@ -123,1 +123,1 @@\n-     * Set end of handler\n+     * Sets end of handler\n@@ -133,1 +133,1 @@\n-     * Set handler code\n+     * Sets handler code\n@@ -143,1 +143,1 @@\n-     * Set start of handler\n+     * Sets start of handler\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CodeExceptionGen.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        \/\/ (!nvp.getNameString().equals(((ConstantUtf8)constantPoolGen.getConstant(nvp.getNameIndex())).getBytes()))\n+        \/\/ (!nvp.getNameString().equals(((ConstantUtf8) constantPoolGen.getConstant(nvp.getNameIndex())).getBytes()))\n@@ -89,1 +89,1 @@\n-        \/\/ ConstantString cu8 = (ConstantString)constantPoolGen.getConstant(nameIdx);\n+        \/\/ ConstantString cu8 = (ConstantString) constantPoolGen.getConstant(nameIdx);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ElementValuePairGen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,4 +43,2 @@\n-            typeIdx = cpool.addUtf8(value.getEnumTypeString());\/\/ was\n-                                                               \/\/ addClass(value.getEnumTypeString());\n-            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was\n-                                                                  \/\/ addString(value.getEnumValueString());\n+            typeIdx = cpool.addUtf8(value.getEnumTypeString()); \/\/ was addClass(value.getEnumTypeString());\n+            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was addString(value.getEnumValueString());\n@@ -58,1 +56,1 @@\n-        super(ElementValueGen.ENUM_CONSTANT, cpool);\n+        super(ENUM_CONSTANT, cpool);\n@@ -67,3 +65,3 @@\n-        super(ElementValueGen.ENUM_CONSTANT, cpool);\n-        typeIdx = cpool.addUtf8(t.getSignature());\/\/ was addClass(t);\n-        valueIdx = cpool.addUtf8(value);\/\/ was addString(value);\n+        super(ENUM_CONSTANT, cpool);\n+        typeIdx = cpool.addUtf8(t.getSignature()); \/\/ was addClass(t);\n+        valueIdx = cpool.addUtf8(value); \/\/ was addString(value);\n@@ -93,1 +91,1 @@\n-        \/\/ (ConstantClass)getConstantPool().getConstant(typeIdx);\n+        \/\/ (ConstantClass) getConstantPool().getConstant(typeIdx);\n@@ -95,1 +93,1 @@\n-        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getNameIndex())).getBytes();\n+        \/\/ ((ConstantUtf8) getConstantPool().getConstant(cu8.getNameIndex())).getBytes();\n@@ -103,1 +101,1 @@\n-        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n+        \/\/ (ConstantString) getConstantPool().getConstant(valueIdx);\n@@ -105,1 +103,1 @@\n-        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n+        \/\/ ((ConstantUtf8) getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n@@ -121,1 +119,1 @@\n-        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n+        \/\/ (ConstantString) getConstantPool().getConstant(valueIdx);\n@@ -123,1 +121,1 @@\n-        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n+        \/\/ ((ConstantUtf8) getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/EnumElementValueGen.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * the truth as such; because all instructions may throw an java.lang.VirtualMachineError. These exceptions are omitted.\n+ * the truth as such; because all instructions may throw a {@link VirtualMachineError}. These exceptions are omitted.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ExceptionThrower.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -47,1 +47,1 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    private static BCELComparator<FieldGen> bcelComparator = new BCELComparator<FieldGen>() {\n@@ -50,4 +50,2 @@\n-        public boolean equals(final Object o1, final Object o2) {\n-            final FieldGen THIS = (FieldGen) o1;\n-            final FieldGen THAT = (FieldGen) o2;\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+        public boolean equals(final FieldGen a, final FieldGen b) {\n+            return a == b || a != null && b != null && Objects.equals(a.getName(), b.getName()) && Objects.equals(a.getSignature(), b.getSignature());\n@@ -57,3 +55,2 @@\n-        public int hashCode(final Object o) {\n-            final FieldGen THIS = (FieldGen) o;\n-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n+        public int hashCode(final FieldGen o) {\n+            return o != null ? Objects.hash(o.getSignature(), o.getName()) : 0;\n@@ -64,1 +61,1 @@\n-     * @return Comparison strategy object\n+     * @return Comparison strategy object.\n@@ -66,1 +63,1 @@\n-    public static BCELComparator getComparator() {\n+    public static BCELComparator<FieldGen> getComparator() {\n@@ -71,1 +68,1 @@\n-     * @param comparator Comparison strategy object\n+     * @param comparator Comparison strategy object.\n@@ -73,1 +70,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n+    public static void setComparator(final BCELComparator<FieldGen> comparator) {\n@@ -84,2 +81,2 @@\n-     * @param field Field object\n-     * @param cp constant pool (must contain the same entries as the field's constant pool)\n+     * @param field Field object.\n+     * @param cp constant pool (must contain the same entries as the field's constant pool).\n@@ -190,1 +187,1 @@\n-        return bcelComparator.equals(this, obj);\n+        return obj instanceof FieldGen && bcelComparator.equals(this, (FieldGen) obj);\n@@ -194,1 +191,1 @@\n-     * Get field object after having set up all necessary values.\n+     * Gets field object after having set up all necessary values.\n@@ -210,4 +207,1 @@\n-        if (value != null) {\n-            return value.toString();\n-        }\n-        return null;\n+        return Objects.toString(value, null);\n@@ -222,1 +216,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n+     * Return value as defined by given BCELComparator strategy. By default return the hash code of the field's name XOR\n@@ -298,1 +292,1 @@\n-     * Set (optional) initial value of field, otherwise it will be set to null\/0\/false by the JVM automatically.\n+     * Sets (optional) initial value of field, otherwise it will be set to null\/0\/false by the JVM automatically.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGen.java","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -70,2 +70,4 @@\n-    protected void addAll(final Attribute[] attrs) {\n-        Collections.addAll(attributeList, attrs);\n+    protected void addAll(final Attribute[] attributes) {\n+        if (attributes != null) {\n+            Collections.addAll(attributeList, attributes);\n+        }\n@@ -96,1 +98,1 @@\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", e); \/\/ never happens\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGenOrMethodGen.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-     *\n@@ -92,0 +91,3 @@\n+        if (rt instanceof ArrayType) {\n+            return Type.OBJECT;\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldOrMethod.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ICONST.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -107,1 +107,1 @@\n-     * Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object, as that is the only type we can\n+     * Since InvokeDynamic doesn't refer to a reference type, just return {@link Object}, as that is the only type we can\n@@ -111,1 +111,1 @@\n-     * @return an ObjectType for java.lang.Object\n+     * @return an ObjectType for {@link Object}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEDYNAMIC.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -464,1 +464,1 @@\n-        if (InstructionConst.getInstruction(this.getOpcode()) != null) {\n+        if (InstructionConst.getInstruction(getOpcode()) != null) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Instruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-     * Get object via its opcode, for immutable instructions like branch instructions entries are set to null.\n+     * Gets object via its opcode, for immutable instructions like branch instructions entries are set to null.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionConst.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -37,1 +37,1 @@\n-    private static class MethodObject {\n+    private static final class MethodObject {\n@@ -56,2 +56,4 @@\n-    \/\/ N.N. These must agree with the order of Constants.T_CHAR through T_LONG\n-    private static final String[] shortNames = {\"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"};\n+    \/**\n+     * These must agree with the order of Constants.T_CHAR through T_LONG.\n+     *\/\n+    private static final String[] SHORT_NAMES = {\"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"};\n@@ -59,1 +61,1 @@\n-    private static final MethodObject[] appendMethodObjects = {\n+    private static final MethodObject[] APPEND_METHOD_OBJECTS = {\n@@ -487,1 +489,1 @@\n-            return createInvoke(appendMethodObjects[0], Const.INVOKEVIRTUAL);\n+            return createInvoke(APPEND_METHOD_OBJECTS[0], Const.INVOKEVIRTUAL);\n@@ -498,1 +500,1 @@\n-            return createInvoke(appendMethodObjects[t], Const.INVOKEVIRTUAL);\n+            return createInvoke(APPEND_METHOD_OBJECTS[t], Const.INVOKEVIRTUAL);\n@@ -501,1 +503,1 @@\n-            return createInvoke(appendMethodObjects[1], Const.INVOKEVIRTUAL);\n+            return createInvoke(APPEND_METHOD_OBJECTS[1], Const.INVOKEVIRTUAL);\n@@ -518,1 +520,1 @@\n-            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + shortNames[src - Const.T_CHAR] + \"2\" + shortNames[dest - Const.T_CHAR];\n+            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + SHORT_NAMES[src - Const.T_CHAR] + \"2\" + SHORT_NAMES[dest - Const.T_CHAR];\n@@ -645,2 +647,4 @@\n-        for (final Type argType : argTypes) {\n-            nargs += argType.getSize();\n+        if (argTypes != null) {\n+            for (final Type argType : argTypes) {\n+                nargs += argType.getSize();\n+            }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionFactory.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -121,1 +121,1 @@\n-        \/\/ if(!targeters.contains(t))\n+        \/\/ if (!targeters.contains(t))\n@@ -138,1 +138,1 @@\n-     * Get attribute of an instruction handle.\n+     * Gets attribute of an instruction handle.\n@@ -143,4 +143,1 @@\n-        if (attributes != null) {\n-            return attributes.get(key);\n-        }\n-        return null;\n+        return attributes != null ? attributes.get(key) : null;\n@@ -250,1 +247,1 @@\n-     * Set the position, i.e., the byte code offset of the contained instruction.\n+     * Sets the position, i.e., the byte code offset of the contained instruction.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionHandle.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.xml.internal.Utils;\n@@ -49,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -63,17 +64,19 @@\n-        int l = 0;\n-        int r = count - 1;\n-        \/*\n-         * Do a binary search since the pos array is orderd.\n-         *\/\n-        do {\n-            final int i = l + r >>> 1;\n-            final int j = pos[i];\n-            if (j == target) {\n-                return ihs[i];\n-            }\n-            if (target < j) {\n-                r = i - 1;\n-            } else {\n-                l = i + 1;\n-            }\n-        } while (l <= r);\n+        if (ihs != null && pos != null) {\n+            int l = 0;\n+            int r = count - 1;\n+            \/*\n+             * Do a binary search since the pos array is orderd.\n+             *\/\n+            do {\n+                final int i = l + r >>> 1;\n+                final int j = pos[i];\n+                if (j == target) {\n+                    return ihs[i];\n+                }\n+                if (target < j) {\n+                    r = i - 1;\n+                } else {\n+                    l = i + 1;\n+                }\n+            } while (l <= r);\n+        }\n@@ -516,1 +519,1 @@\n-     * Get instruction handle for instruction at byte code position pos. This only works properly, if the list is freshly\n+     * Gets instruction handle for instruction at byte code position pos. This only works properly, if the list is freshly\n@@ -608,1 +611,1 @@\n-     * Get positions (offsets) of all instructions in the list. This relies on that the list has been freshly created from\n+     * Gets positions (offsets) of all instructions in the list. This relies on that the list has been freshly created from\n@@ -962,1 +965,1 @@\n-        for (final CodeExceptionGen exception : exceptions) {\n+        Utils.streamOfIfNonNull(exceptions).forEach(exception -> {\n@@ -972,1 +975,1 @@\n-        }\n+        });\n@@ -984,4 +987,2 @@\n-        for (final LocalVariableGen element : lg) {\n-            final InstructionHandle start = element.getStart();\n-            final InstructionHandle end = element.getEnd();\n-            if (start == oldTarget) {\n+        Utils.streamOfIfNonNull(lg).forEach(element -> {\n+            if (element.getStart() == oldTarget) {\n@@ -990,1 +991,1 @@\n-            if (end == oldTarget) {\n+            if (element.getEnd() == oldTarget) {\n@@ -993,1 +994,1 @@\n-        }\n+        });\n@@ -1123,1 +1124,1 @@\n-             * Get an estimate about how many additional bytes may be added, because BranchInstructions may have variable length\n+             * Gets an estimate about how many additional bytes may be added, because BranchInstructions may have variable length\n@@ -1135,0 +1136,3 @@\n+            default:\n+                \/\/ TODO should this be an error?\n+                break;\n@@ -1139,1 +1143,1 @@\n-         * Pass 2: Expand the variable-length (Branch)Instructions depending on the target offset (short or int) and ensure that\n+         * Pass 2: Expand the variable-length (Branch) Instructions depending on the target offset (short or int) and ensure that\n@@ -1155,2 +1159,1 @@\n-        bytePositions = new int[count]; \/\/ Trim to proper size\n-        System.arraycopy(pos, 0, bytePositions, 0, count);\n+        bytePositions = Arrays.copyOfRange(pos, 0, count); \/\/ Trim to proper size\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionList.java","additions":36,"deletions":33,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * Denote that a class targets InstructionHandles within an InstructionList. Namely the following implementers:\n+ * Denotes that a class targets InstructionHandles within an InstructionList.\n@@ -36,1 +36,4 @@\n-     * Checks whether this targeter targets the specified instruction handle.\n+     * Tests whether this targeter targets the specified instruction handle.\n+     *\n+     * @param instructionHandle the instruction handle to test.\n+     * @return whether this targeter targets the specified instruction handle.\n@@ -38,1 +41,1 @@\n-    boolean containsTarget(InstructionHandle ih);\n+    boolean containsTarget(InstructionHandle instructionHandle);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionTargeter.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LCMP.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,2 @@\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Dynamic:\n+            return Type.OBJECT;\n@@ -116,1 +118,4 @@\n-            return Type.getType(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes());\n+            return Type.getType(Type.internalTypeNameToSignature(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes()));\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Dynamic:\n+            \/\/ Really not sure what to return here, maybe a BootstrapMethod instance but how do we get it?\n+            return c;\n@@ -132,1 +137,1 @@\n-     * Set the index to constant pool and adjust size.\n+     * Sets the index to constant pool and adjust size.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", e); \/\/ never happens\n@@ -74,1 +74,1 @@\n-     * Get LineNumber attribute.\n+     * Gets LineNumber attribute.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LineNumberGen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+            throw new UnsupportedOperationException(\"Clone Not Supported\", e); \/\/ never happens\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableGen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -165,1 +165,1 @@\n-     * Set the local variable index. also updates opcode and length TODO Why?\n+     * Sets the local variable index. also updates opcode and length TODO Why?\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.stream.Collectors;\n@@ -49,0 +50,1 @@\n+import jdk.xml.internal.Utils;\n@@ -60,1 +62,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -105,1 +107,1 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    private static BCELComparator<FieldGenOrMethodGen> bcelComparator = new BCELComparator<FieldGenOrMethodGen>() {\n@@ -108,4 +110,2 @@\n-        public boolean equals(final Object o1, final Object o2) {\n-            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o1;\n-            final FieldGenOrMethodGen THAT = (FieldGenOrMethodGen) o2;\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+        public boolean equals(final FieldGenOrMethodGen a, final FieldGenOrMethodGen b) {\n+            return a == b || a != null && b != null && Objects.equals(a.getName(), b.getName()) && Objects.equals(a.getSignature(), b.getSignature());\n@@ -115,3 +115,2 @@\n-        public int hashCode(final Object o) {\n-            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o;\n-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n+        public int hashCode(final FieldGenOrMethodGen o) {\n+            return o != null ? Objects.hash(o.getSignature(), o.getName()) : 0;\n@@ -130,1 +129,1 @@\n-     * @return Comparison strategy object\n+     * @return Comparison strategy object.\n@@ -132,1 +131,1 @@\n-    public static BCELComparator getComparator() {\n+    public static BCELComparator<FieldGenOrMethodGen> getComparator() {\n@@ -209,1 +208,1 @@\n-     * @param comparator Comparison strategy object\n+     * @param comparator Comparison strategy object.\n@@ -211,1 +210,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n+    public static void setComparator(final BCELComparator<FieldGenOrMethodGen> comparator) {\n@@ -639,1 +638,1 @@\n-        return bcelComparator.equals(this, obj);\n+        return obj instanceof FieldGenOrMethodGen && bcelComparator.equals(this, (FieldGenOrMethodGen) obj);\n@@ -793,1 +792,1 @@\n-     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively, before calling this method\n+     * Gets method object. Never forget to call setMaxStack() or setMaxStack(max), respectively, before calling this method\n@@ -891,1 +890,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n+     * Return value as defined by given BCELComparator strategy. By default return the hash code of the method's name XOR\n@@ -902,5 +901,1 @@\n-        final List<AnnotationEntryGen> result = new ArrayList<>();\n-        for (final AnnotationEntry element : mutableArray) {\n-            result.add(new AnnotationEntryGen(element, getConstantPool(), false));\n-        }\n-        return result;\n+        return Utils.streamOfIfNonNull(mutableArray).map(ae -> new AnnotationEntryGen(ae, getConstantPool(), false)).collect(Collectors.toList());\n@@ -1030,4 +1025,2 @@\n-    public void removeRuntimeAttributes(final Attribute[] attrs) {\n-        for (final Attribute attr : attrs) {\n-            removeAttribute(attr);\n-        }\n+    public void removeRuntimeAttributes(final Attribute[] attributes) {\n+        Utils.streamOfIfNonNull(attributes).forEach(this::removeAttribute);\n@@ -1041,1 +1034,1 @@\n-        this.argNames = argNames;\n+        this.argNames = Utils.createEmptyArrayIfNull(argNames, String[].class);\n@@ -1049,1 +1042,1 @@\n-        this.argTypes = argTypes;\n+        this.argTypes = argTypes != null ? argTypes : Type.NO_ARGS;\n@@ -1087,1 +1080,1 @@\n-     * Set maximum number of local variables.\n+     * Sets maximum number of local variables.\n@@ -1105,1 +1098,1 @@\n-     * Set maximum stack size for this method.\n+     * Sets maximum stack size for this method.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MethodGen.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * Denotes reference such as java.lang.String.\n+ * Denotes reference such as {@link String}.\n@@ -50,1 +50,1 @@\n-     * @param className fully qualified class name, e.g. java.lang.String\n+     * @param className fully qualified class name, e.g. {@link String}\n@@ -154,1 +154,1 @@\n-        if (this.referencesInterfaceExact() || superclass.referencesInterfaceExact()) {\n+        if (referencesInterfaceExact() || superclass.referencesInterfaceExact()) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ObjectType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-     * Set index of local variable containg the return address\n+     * Sets index of local variable containg the return address\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/RET.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,4 +45,4 @@\n-     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n-     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n-     * \"this\" or t is an ArrayType, then Type.OBJECT is returned. If \"this\" or t is a ReferenceType referencing an\n-     * interface, then Type.OBJECT is returned. If not all of the two classes' superclasses cannot be found, \"null\" is\n+     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is NULL, then t\n+     * is returned. If t is NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n+     * \"this\" or t is an ArrayType, then {@link #OBJECT} is returned. If \"this\" or t is a ReferenceType referencing an\n+     * interface, then {@link #OBJECT} is returned. If not all of the two classes' superclasses cannot be found, \"null\" is\n@@ -56,1 +56,1 @@\n-        if (this.equals(Type.NULL)) {\n+        if (equals(NULL)) {\n@@ -59,1 +59,1 @@\n-        if (t.equals(Type.NULL) || this.equals(t)) {\n+        if (t.equals(NULL) || equals(t)) {\n@@ -62,3 +62,3 @@\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n-             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n-             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by {@link #NULL} so we can also\n+             * say all the objects referenced by {@link #NULL} were derived from {@link Object}. However, the Java Language's\n+             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of {@link Object} :)\n@@ -68,2 +68,2 @@\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+            return OBJECT;\n+            \/\/ TODO: Is there a proof of {@link #OBJECT} being the direct ancestor of every ArrayType?\n@@ -76,3 +76,3 @@\n-     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n-     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n-     * \"this\" or t is an ArrayType, then Type.OBJECT is returned; unless their dimensions match. Then an ArrayType of the\n+     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is NULL, then t\n+     * is returned. If t is NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n+     * \"this\" or t is an ArrayType, then {@link #OBJECT} is returned; unless their dimensions match. Then an ArrayType of the\n@@ -80,1 +80,1 @@\n-     * \"this\" and t. If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned. If not all of\n+     * \"this\" and t. If \"this\" or t is a ReferenceType referencing an interface, then {@link #OBJECT} is returned. If not all of\n@@ -87,1 +87,1 @@\n-        if (this.equals(Type.NULL)) {\n+        if (equals(NULL)) {\n@@ -90,1 +90,1 @@\n-        if (t.equals(Type.NULL) || this.equals(t)) {\n+        if (t.equals(NULL) || equals(t)) {\n@@ -93,3 +93,3 @@\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n-             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n-             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by {@link #NULL} so we can also\n+             * say all the objects referenced by {@link #NULL} were derived from {@link Object}. However, the Java Language's\n+             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of {@link Object} :)\n@@ -109,2 +109,2 @@\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+            return OBJECT;\n+            \/\/ TODO: Is there a proof of {@link #OBJECT} being the direct ancestor of every ArrayType?\n@@ -118,1 +118,1 @@\n-            return Type.OBJECT;\n+            return OBJECT;\n@@ -145,1 +145,1 @@\n-        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n+        \/\/ Huh? Did you ask for OBJECT's superclass??\n@@ -161,1 +161,1 @@\n-        if (this.equals(Type.NULL)) {\n+        if (equals(NULL)) {\n@@ -172,1 +172,1 @@\n-                && (this.equals(T) || Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n+                && (equals(T) || Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n@@ -190,1 +190,1 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(OBJECT)) {\n@@ -197,1 +197,1 @@\n-                && (this.equals(T) || Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n+                && (equals(T) || Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n@@ -208,1 +208,1 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(OBJECT)) {\n@@ -249,1 +249,1 @@\n-     * Type.NULL is not defined (see the CHECKCAST definition in the JVM specification). However, because e.g. CHECKCAST\n+     * {@link #NULL} is not defined (see the CHECKCAST definition in the JVM specification). However, because e.g. CHECKCAST\n@@ -256,1 +256,1 @@\n-        if (this.equals(Type.NULL)) {\n+        if (equals(NULL)) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReferenceType.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        int[] matchClone = match.clone();\n+        final int[] matchClone = match.clone();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SWITCH.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -90,1 +90,1 @@\n-        \/\/ don't set default target before instuction is built\n+        \/\/ don't set default target before instruction is built\n@@ -291,1 +291,1 @@\n-     * Set branch target for 'i'th case\n+     * Sets branch target for 'i'th case\n@@ -317,1 +317,5 @@\n-                    s = targets[i].getInstruction().toString();\n+                    if (targets[i].getInstruction() == this) {\n+                        s = \"<points to itself>\";\n+                    } else {\n+                        s = targets[i].getInstruction().toString();\n+                    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Select.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-            throw new IllegalStateException(\"SimpleElementValueGen doesnt know how to write out type \" + super.getElementValueType());\n+            throw new IllegalStateException(\"SimpleElementValueGen doesn't know how to write out type \" + super.getElementValueType());\n@@ -187,1 +187,1 @@\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueString() on a non STRING ElementValue\");\n@@ -195,1 +195,1 @@\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+            throw new IllegalStateException(\"Don't call getValueString() on a non STRING ElementValue\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SimpleElementValueGen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,3 @@\n- * Thrown by InstructionList.remove() when one or multiple disposed instructions are still being referenced by an\n- * InstructionTargeter object. I.e. the InstructionTargeter has to be notified that (one of) the InstructionHandle it is\n- * referencing is being removed from the InstructionList and thus not valid anymore.\n+ * Thrown by {@link InstructionList} when one or multiple disposed instructions are still being referenced by an {@link InstructionTargeter} object. I.e. the\n+ * {@link InstructionTargeter} has to be notified that (one of) the {@link InstructionHandle} it is referencing is being removed from the\n+ * {@link InstructionList} and thus not valid anymore.\n@@ -29,2 +29,2 @@\n- * Making this an exception instead of a return value forces the user to handle these case explicitly in a try { ... }\n- * catch. The following code illustrates how this may be done:\n+ * Making this an exception instead of a return value forces the user to handle these case explicitly in a try { ... } catch. The following code illustrates how\n+ * this may be done:\n@@ -33,1 +33,1 @@\n- * <PRE>\n+ * <pre>\n@@ -37,1 +37,1 @@\n- *     } catch(TargetLostException e) {\n+ *     } catch (TargetLostException e) {\n@@ -44,1 +44,1 @@\n- * <\/PRE>\n+ * <\/pre>\n@@ -49,1 +49,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -57,3 +57,3 @@\n-    TargetLostException(final InstructionHandle[] t, final String mesg) {\n-        super(mesg);\n-        targets = t;\n+    TargetLostException(final InstructionHandle[] targets, final String message) {\n+        super(message);\n+        this.targets = targets;\n@@ -63,0 +63,2 @@\n+     * Gets the list of instructions still being targeted.\n+     *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TargetLostException.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.InvalidMethodSignatureException;\n@@ -30,0 +31,1 @@\n+import jdk.xml.internal.Utils;\n@@ -32,1 +34,1 @@\n- * Abstract super class for all possible java types, namely basic types such as int, object types like String and array\n+ * Abstract super class for all possible Java types, namely basic types such as int, object types like String and array\n@@ -34,1 +36,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -91,1 +93,1 @@\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                throw new InvalidMethodSignatureException(signature);\n@@ -95,1 +97,1 @@\n-                \/\/ corrected concurrent private static field acess\n+                \/\/ corrected concurrent private static field access\n@@ -99,1 +101,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -113,1 +115,1 @@\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+                throw new InvalidMethodSignatureException(signature);\n@@ -121,1 +123,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -157,1 +159,1 @@\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+            throw new InvalidMethodSignatureException(signature, e);\n@@ -163,1 +165,1 @@\n-        return Type.size(getTypeSize(signature.substring(index)));\n+        return size(getTypeSize(signature.substring(index)));\n@@ -178,1 +180,1 @@\n-     * Convert runtime java.lang.Class to BCEL Type object.\n+     * Convert runtime {@link Class} to BCEL Type object.\n@@ -186,1 +188,1 @@\n-         * That's an amzingly easy case, because getName() returns the signature. That's what we would have liked anyway.\n+         * That's an amazingly easy case, because getName() returns the signature. That's what we would have liked anyway.\n@@ -233,1 +235,1 @@\n-            \/\/ corrected concurrent private static field acess\n+            \/\/ corrected concurrent private static field access\n@@ -249,1 +251,1 @@\n-        \/\/ corrected concurrent private static field acess\n+        \/\/ corrected concurrent private static field access\n@@ -257,1 +259,1 @@\n-     * Convert runtime java.lang.Class[] to BCEL Type objects.\n+     * Convert runtime {@code java.lang.Class[]} to BCEL Type objects.\n@@ -289,0 +291,18 @@\n+    static String internalTypeNameToSignature(final String internalTypeName) {\n+        if (Utils.isEmpty(internalTypeName) || Arrays.asList(Const.SHORT_TYPE_NAMES).contains(internalTypeName)) {\n+            return internalTypeName;\n+        }\n+        switch (internalTypeName.charAt(0)) {\n+            case '[':\n+                return internalTypeName;\n+            case 'L':\n+            case 'T':\n+                if (internalTypeName.charAt(internalTypeName.length() - 1) == ';') {\n+                    return internalTypeName;\n+                }\n+                return 'L' + internalTypeName + ';';\n+            default:\n+                return 'L' + internalTypeName + ';';\n+        }\n+    }\n+\n@@ -364,1 +384,1 @@\n-     * @return hashcode of Type\n+     * @return hash code of Type\n@@ -372,2 +392,2 @@\n-     * boolean, short and char variable are considered as int in the stack or local variable area. Returns {@link Type#INT}\n-     * for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise returns the given type.\n+     * boolean, short and char variable are considered as int in the stack or local variable area. Returns {@link #INT}\n+     * for {@link #BOOLEAN}, {@link #SHORT} or {@link #CHAR}, otherwise returns the given type.\n@@ -378,2 +398,2 @@\n-        if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {\n-            return Type.INT;\n+        if (this == BOOLEAN || this == BYTE || this == SHORT || this == CHAR) {\n+            return INT;\n@@ -384,8 +404,0 @@\n-    \/*\n-     * Currently only used by the ArrayType constructor. The signature has a complicated dependency on other parameter so\n-     * it's tricky to do it in a call to the super ctor.\n-     *\/\n-    void setSignature(final String signature) {\n-        this.signature = signature;\n-    }\n-\n@@ -397,1 +409,1 @@\n-        return this.equals(Type.NULL) || type >= Const.T_UNKNOWN ? signature : Utility.signatureToString(signature, false);\n+        return equals(NULL) || type >= Const.T_UNKNOWN ? signature : Utility.signatureToString(signature, false);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Type.java","additions":41,"deletions":29,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * Get the type associated with an instruction, int for ILOAD, or the type of the field of a PUTFIELD instruction, e.g..\n+ * Gets the type associated with an instruction, int for ILOAD, or the type of the field of a PUTFIELD instruction, e.g..\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TypedInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+\n+\/**\n+ * Generic part of the <a href=\"https:\/\/commons.apache.org\/bcel\/\">Apache Byte Code Engineering Library (BCEL)<\/a>, classes to dynamically modify class objects\n+ * and byte code instructions.\n+ *\/\n+package com.sun.org.apache.bcel.internal.generic;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/package-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+\n+\/**\n+ * Basic classes for the <a href=\"https:\/\/commons.apache.org\/bcel\/\">Apache Byte Code Engineering Library (BCEL)<\/a> and constants defined by the\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\"> JVM specification<\/a>.\n+ *\/\n+package com.sun.org.apache.bcel.internal;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/package-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * Used for BCEL comparison strategy\n+ * Used for BCEL comparison strategy.\n@@ -27,0 +27,1 @@\n+ * @param <T> What type we are comparing.\n@@ -29,1 +30,1 @@\n-public interface BCELComparator {\n+public interface BCELComparator<T> {\n@@ -32,1 +33,1 @@\n-     * Compare two objects and return what THIS.equals(THAT) should return\n+     * Compares two objects and return what a.equals(b) should return.\n@@ -34,3 +35,3 @@\n-     * @param THIS\n-     * @param THAT\n-     * @return true if and only if THIS equals THAT\n+     * @param a an object.\n+     * @param b an object to be compared with {@code a} for equality.\n+     * @return {@code true} if the arguments are equal to each other and {@code false} otherwise.\n@@ -38,1 +39,1 @@\n-    boolean equals(Object THIS, Object THAT);\n+    boolean equals(T a, T b);\n@@ -41,1 +42,1 @@\n-     * Return hashcode for THIS.hashCode()\n+     * Gets the hash code for o.hashCode()\n@@ -43,2 +44,2 @@\n-     * @param THIS\n-     * @return hashcode for THIS.hashCode()\n+     * @param o\n+     * @return hash code for o.hashCode()\n@@ -46,1 +47,1 @@\n-    int hashCode(Object THIS);\n+    int hashCode(T o);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELComparator.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -68,1 +68,1 @@\n-class BCELFactory extends EmptyVisitor {\n+final class BCELFactory extends EmptyVisitor {\n@@ -91,1 +91,1 @@\n-            embed = \"(char)0x\" + Integer.toHexString(((Character) value).charValue());\n+            embed = \"(char) 0x\" + Integer.toHexString(((Character) value).charValue());\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Code;\n@@ -38,0 +39,3 @@\n+import com.sun.org.apache.bcel.internal.classfile.StackMap;\n+import com.sun.org.apache.bcel.internal.classfile.StackMapEntry;\n+import com.sun.org.apache.bcel.internal.classfile.StackMapType;\n@@ -49,1 +53,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -77,1 +81,1 @@\n-    public static void _main(final String[] argv) throws Exception {\n+    public static void main(final String[] argv) throws Exception {\n@@ -314,0 +318,7 @@\n+        final Code code = method.getCode();\n+        if (code != null) {\n+            final StackMap stackMap = code.getStackMap();\n+            if (stackMap != null) {\n+                stackMap.accept(this);\n+            }\n+        }\n@@ -322,0 +333,74 @@\n+\n+    @Override\n+    public void visitStackMap(final StackMap stackMap) {\n+        super.visitStackMap(stackMap);\n+        printWriter.print(\"    method.addCodeAttribute(\");\n+        printWriter.print(\"new StackMap(_cp.addUtf8(\\\"\");\n+        printWriter.print(stackMap.getName());\n+        printWriter.print(\"\\\"), \");\n+        printWriter.print(stackMap.getLength());\n+        printWriter.print(\", \");\n+        printWriter.print(\"new StackMapEntry[] {\");\n+        final StackMapEntry[] table = stackMap.getStackMap();\n+        for (int i = 0; i < table.length; i++) {\n+            table[i].accept(this);\n+            if (i < table.length - 1) {\n+                printWriter.print(\", \");\n+            } else {\n+                printWriter.print(\" }\");\n+            }\n+        }\n+        printWriter.print(\", _cp.getConstantPool())\");\n+        printWriter.println(\");\");\n+    }\n+\n+    @Override\n+    public void visitStackMapEntry(final StackMapEntry stackMapEntry) {\n+        super.visitStackMapEntry(stackMapEntry);\n+        printWriter.print(\"new StackMapEntry(\");\n+        printWriter.print(stackMapEntry.getFrameType());\n+        printWriter.print(\", \");\n+        printWriter.print(stackMapEntry.getByteCodeOffset());\n+        printWriter.print(\", \");\n+        visitStackMapTypeArray(stackMapEntry.getTypesOfLocals());\n+        printWriter.print(\", \");\n+        visitStackMapTypeArray(stackMapEntry.getTypesOfStackItems());\n+        printWriter.print(\", _cp.getConstantPool())\");\n+    }\n+\n+    \/**\n+     * Visits a {@link StackMapType} object.\n+     * @param stackMapType object to visit\n+     * @since 6.7.1\n+     *\/\n+    @Override\n+    public void visitStackMapType(final StackMapType stackMapType) {\n+        super.visitStackMapType(stackMapType);\n+        printWriter.print(\"new StackMapType((byte)\");\n+        printWriter.print(stackMapType.getType());\n+        printWriter.print(\", \");\n+        if (stackMapType.hasIndex()) {\n+            printWriter.print(\"_cp.addClass(\\\"\");\n+            printWriter.print(stackMapType.getClassName());\n+            printWriter.print(\"\\\")\");\n+        } else {\n+            printWriter.print(\"-1\");\n+        }\n+        printWriter.print(\", _cp.getConstantPool())\");\n+    }\n+\n+    private void visitStackMapTypeArray(final StackMapType[] types) {\n+        if (types == null || types.length == 0) {\n+            printWriter.print(\"null\"); \/\/ null translates to StackMapType.EMPTY_ARRAY\n+        } else {\n+            printWriter.print(\"new StackMapType[] {\");\n+            for (int i = 0; i < types.length; i++) {\n+                types[i].accept(this);\n+                if (i < types.length - 1) {\n+                    printWriter.print(\", \");\n+                } else {\n+                    printWriter.print(\" }\");\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELifier.java","additions":88,"deletions":3,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n@@ -76,1 +76,1 @@\n-    public static void _main(final String[] argv) throws IOException {\n+    public static void main(final String[] argv) throws IOException {\n@@ -92,1 +92,1 @@\n-                        dir = dir + sep;\n+                        dir += sep;\n@@ -118,1 +118,1 @@\n-                    parser = new ClassParser(zipFile, fileName[i]); \/\/ Create parser object from zip file\n+                    parser = new ClassParser(zipFile, fileName[i]); \/\/ Create parser object from ZIP file\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Class2HTML.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Sept 2025\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-                     * Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every line is very\n+                     * Sets an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every line is very\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/CodeHTML.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Sept 2025\n@@ -73,1 +73,0 @@\n-     *\n@@ -377,1 +376,1 @@\n-\/\/        StringBuffer buf = new StringBuffer();\n+\/\/        StringBuilder buf = new StringBuilder();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/InstructionFinder.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @see org.apache.bcel.Repository\n- * @LastModified: Feb 2023\n+ * @see com.sun.org.apache.bcel.internal.Repository\n+ * @LastModified: Sept 2025\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Repository.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+\n+\/**\n+ * Utility classes for the <a href=\"https:\/\/commons.apache.org\/bcel\/\">Apache Byte Code Engineering Library (BCEL)<\/a>, namely:\n+ * <ul>\n+ * <li>Collection classes for JavaClass objects<\/li>\n+ * <li>A converter for class files to HTML<\/li>\n+ * <li>A tool to find instructions patterns via regular expressions<\/li>\n+ * <li>A class to find classes as defined in the CLASSPATH<\/li>\n+ * <li>A class loader that allows to create classes at run time<\/li>\n+ * <\/ul>\n+ *\/\n+package com.sun.org.apache.bcel.internal.util;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/package-info.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.Array;\n@@ -29,0 +30,1 @@\n+import java.util.Objects;\n@@ -30,0 +32,1 @@\n+import java.util.stream.Stream;\n@@ -79,0 +82,55 @@\n+\n+    \/**\n+     * Returns the original array, or an empty array if it is {@code null}.\n+     * @param array the specified array\n+     * @return the original array, or an empty array if it is {@code null}\n+     *\/\n+    public static byte[] createEmptyArrayIfNull(byte[] array) {\n+        return (array != null) ? array : new byte[0];\n+    }\n+\n+    \/**\n+     * Returns the original array, or an empty array if it is {@code null}.\n+     * @param array the specified array\n+     * @return the original array, or an empty array if it is {@code null}\n+     *\/\n+    public static int[] createEmptyArrayIfNull(int[] array) {\n+        return (array != null) ? array : new int[0];\n+    }\n+\n+    \/**\n+     * Returns the original array, or an empty array if it is {@code null}.\n+     * @param <T> the class type\n+     * @param array the specified array\n+     * @param type the type of the array\n+     * @return the original array, or an empty array if it is {@code null}\n+     *\/\n+    public static <T> T[] createEmptyArrayIfNull(final T[] array, final Class<T[]> type) {\n+        Objects.requireNonNull(type, \"The type argument should not be null.\");\n+\n+        return (array != null) ? array : type.cast(Array.newInstance(type.getComponentType(), 0));\n+    }\n+\n+    \/**\n+     * Returns the new stream created by {@code Stream.of(values)} or an empty\n+     * sequential stream created by {@code Stream.empty()} if values is null.\n+     *\n+     * @param <T> the type of stream elements\n+     * @param values the elements of the new stream\n+     * @return the new stream created by {@code Stream.of(values)} or an empty\n+     * sequential stream created by {@code Stream.empty()} if values is null.\n+     *\/\n+    @SafeVarargs\n+    @SuppressWarnings(\"varargs\") \/\/ Creating a stream from an array is safe\n+    public static <T> Stream<T> streamOfIfNonNull(final T... values) {\n+        return values == null ? Stream.empty() : Stream.of(values);\n+    }\n+\n+    \/**\n+     * Checks if a CharSequence is empty (\"\") or null.\n+     * @param cs the CharSequence to check, may be null\n+     * @return {@code true} if the CharSequence is empty or null\n+     *\/\n+    public static boolean isEmpty(final CharSequence cs) {\n+        return cs == null || cs.length() == 0;\n+    }\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/Utils.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Apache Commons Byte Code Engineering Library (BCEL) Version 6.7.0\n+## Apache Commons Byte Code Engineering Library (BCEL) Version 6.10.0\n","filename":"src\/java.xml\/share\/legal\/bcel.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,24 +150,3 @@\n-\n-        \/\/ Already initialized?\n-        if (values != null)\n-            return;\n-\n-        \/\/ Initialize enabled categories based on \"-Xlint\" flags\n-        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_ALL)) {\n-            \/\/ If -Xlint or -Xlint:all is given, enable all categories by default\n-            values = EnumSet.allOf(LintCategory.class);\n-        } else if (options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_NONE)) {\n-            \/\/ if -Xlint:none is given, disable all categories by default\n-            values = LintCategory.newEmptySet();\n-        } else {\n-            \/\/ otherwise, enable on-by-default categories\n-            values = getDefaults();\n-        }\n-\n-        \/\/ Look for specific overrides\n-        for (LintCategory lc : LintCategory.values()) {\n-            if (options.isLintExplicitlyEnabled(lc)) {\n-                values.add(lc);\n-            } else if (options.isLintExplicitlyDisabled(lc)) {\n-                values.remove(lc);\n-            }\n+        if (values == null) {\n+            values = options.getLintCategoriesOf(Option.XLINT, this::getDefaults);\n+            suppressedValues = LintCategory.newEmptySet();\n@@ -175,2 +154,0 @@\n-\n-        suppressedValues = LintCategory.newEmptySet();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n@@ -32,0 +30,1 @@\n+import java.util.LinkedList;\n@@ -34,1 +33,0 @@\n-import java.util.Objects;\n@@ -37,1 +35,0 @@\n-import java.util.stream.Stream;\n@@ -39,1 +36,0 @@\n-import javax.tools.DiagnosticListener;\n@@ -129,3 +125,4 @@\n-        return Optional.of(sourceFile)\n-          .map(fileInfoMap::get)\n-          .flatMap(fileInfo -> fileInfo.lintAt(pos));\n+        FileInfo fileInfo = fileInfoMap.get(sourceFile);\n+        if (fileInfo != null)\n+            return fileInfo.lintAt(pos);\n+        return Optional.empty();\n@@ -183,1 +180,1 @@\n-        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n+        final List<Span> unmappedDecls = new LinkedList<>();    \/\/ unmapped top-level declarations awaiting attribution\n@@ -188,4 +185,4 @@\n-            tree.defs.stream()\n-              .filter(this::isTopLevelDecl)\n-              .map(decl -> new Span(decl, tree.endPositions))\n-              .forEach(unmappedDecls::add);\n+            for (JCTree decl : tree.defs) {\n+                if (isTopLevelDecl(decl))\n+                    unmappedDecls.add(new Span(decl, tree.endPositions));\n+            }\n@@ -208,2 +205,5 @@\n-            boolean mapped = unmappedDecls.stream().noneMatch(span -> span.contains(pos));\n-            return mapped ? Optional.of(rootRange.bestMatch(pos).lint) : Optional.empty();\n+            for (Span span : unmappedDecls) {\n+                if (span.contains(pos))\n+                    return Optional.empty();\n+            }\n+            return Optional.of(rootRange.bestMatch(pos).lint);\n@@ -255,1 +255,1 @@\n-            this(Span.MAXIMAL, rootLint, new ArrayList<>());\n+            this(Span.MAXIMAL, rootLint, new LinkedList<>());\n@@ -260,1 +260,1 @@\n-            this(new Span(tree, endPositions), lint, new ArrayList<>());\n+            this(new Span(tree, endPositions), lint, new LinkedList<>());\n@@ -265,5 +265,11 @@\n-            return children.stream()\n-              .map(child -> child.bestMatch(pos))\n-              .filter(Objects::nonNull)\n-              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n-              .orElseGet(() -> span.contains(pos) ? this : null);\n+            LintRange bestMatch = null;\n+            for (LintRange child : children) {\n+                if (!child.span.contains(pos))          \/\/ don't recurse unless necessary\n+                    continue;\n+                LintRange childBestMatch = child.bestMatch(pos);\n+                if (childBestMatch != null && (bestMatch == null || bestMatch.span.contains(childBestMatch.span)))\n+                    bestMatch = childBestMatch;\n+            }\n+            if (bestMatch == null)\n+                bestMatch = span.contains(pos) ? this : null;\n+            return bestMatch;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.EnumSet;\n@@ -58,0 +59,1 @@\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -443,1 +445,2 @@\n-        werror        = options.isSet(WERROR);\n+        werrorAny     = options.isSet(WERROR) || options.isSet(WERROR_CUSTOM, Option.LINT_CUSTOM_ALL);\n+        werrorLint    = options.getLintCategoriesOf(WERROR, LintCategory::newEmptySet);\n@@ -516,1 +519,1 @@\n-    \/** Switch: treat warnings as errors\n+    \/** Switch: treat any kind of warning (lint or non-lint) as an error.\n@@ -518,1 +521,5 @@\n-    protected boolean werror;\n+    protected boolean werrorAny;\n+\n+    \/** Switch: treat lint warnings in the specified {@link LintCategory}s as errors.\n+     *\/\n+    protected EnumSet<LintCategory> werrorLint;\n@@ -584,1 +591,2 @@\n-        if (werror && log.nerrors == 0 && log.nwarnings > 0) {\n+        if (log.nerrors == 0 && log.nwarnings > 0 &&\n+                (werrorAny || werrorLint.clone().removeAll(log.lintWarnings))) {\n@@ -590,0 +598,7 @@\n+    \/**\n+     * Should warnings in the given lint category be treated as errors due to a {@code -Werror} flag?\n+     *\/\n+    public boolean isWerror(LintCategory lc) {\n+        return werrorAny || werrorLint.contains(lc);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -566,0 +566,2 @@\n+    WERROR_CUSTOM(\"-Werror:\", \"opt.arg.Werror\", \"opt.Werror.custom\", STANDARD, BASIC, ANYOF, getXLintChoices()),\n+\n@@ -1135,0 +1137,16 @@\n+    \/**\n+     * Like {@link #getCustom} but also requires that the custom option supports lint categories.\n+     *\n+     * <p>\n+     * In practice, that means {@code option} must be {@link Option#LINT} or {@link Option#WERROR}.\n+     *\n+     * @param option regular option\n+     * @return corresponding lint custom option\n+     * @throws IllegalArgumentException if no such option exists\n+     *\/\n+    public Option getLintCustom() {\n+        if (this == XLINT || this == WERROR)\n+            return getCustom();\n+        throw new IllegalArgumentException();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-        werror = options.isSet(Option.WERROR);\n+        werror = compiler.isWerror(PROCESSING);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,7 @@\n-    Terminate compilation if warnings occur\n+    Terminate compilation if any warnings occur\n+javac.opt.arg.Werror=\\\n+    <key>(,<key>)*\n+javac.opt.Werror.custom=\\\n+    Specify lint categories for which warnings should terminate compilation,\\n\\\n+    separated by comma. Precede a key by ''-'' to exclude the specified category.\\n\\\n+    Use --help-lint to see the supported keys.\n@@ -340,1 +346,1 @@\n-    Print the supported keys for -Xlint\n+    Print the supported keys for -Xlint and -Werror\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -145,0 +145,10 @@\n+\n+                    \/\/ Optimization: We don't need to go through the trouble of calculating the Lint instance at \"pos\" if\n+                    \/\/ (a) \"category\" is disabled at the root level, and (b) the diagnostic doesn't have the DEFAULT_ENABLED\n+                    \/\/ flag: @SuppressWarnings can only disable lint categories, so \"category\" is disabled in the entire file.\n+                    if (!rootLint().isEnabled(category) &&\n+                      !diag.isFlagSet(DEFAULT_ENABLED) &&\n+                      !diag.getCode().equals(RequiresTransitiveAutomatic.key()))    \/\/ accommodate the \"requires\" hack below\n+                        return;\n+\n+                    \/\/ Wait for the Lint instance at \"pos\" to be calculated, then proceed\n@@ -174,1 +184,1 @@\n-                    !options.isLintDisabled(category);                  \/\/ ...suppression happens via -Xlint:-category\n+                    !options.isDisabled(Option.XLINT, category);        \/\/ ...suppression happens via -Xlint:-category\n@@ -556,1 +566,1 @@\n-    \/** The number of warnings encountered so far.\n+    \/** The total number of warnings encountered so far.\n@@ -560,0 +570,4 @@\n+    \/** Tracks whether any warnings have been encountered in each {@link LintCategory}.\n+     *\/\n+    public final EnumSet<LintCategory> lintWarnings = LintCategory.newEmptySet();\n+\n@@ -888,0 +902,1 @@\n+        lintWarnings.clear();\n@@ -943,1 +958,0 @@\n-                    nwarnings++;\n@@ -951,1 +965,0 @@\n-                        nwarnings++;\n@@ -962,1 +975,0 @@\n-                        nerrors++;\n@@ -976,1 +988,1 @@\n-     * Write out a diagnostic.\n+     * Write out a diagnostic and bump the warning and error counters as needed.\n@@ -979,0 +991,16 @@\n+\n+        \/\/ Increment counter(s)\n+        switch (diag.getType()) {\n+        case WARNING:\n+            nwarnings++;\n+            Optional.of(diag)\n+              .map(JCDiagnostic::getLintCategory)\n+              .ifPresent(lintWarnings::add);\n+            break;\n+        case ERROR:\n+            nerrors++;\n+            break;\n+        default:\n+            break;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -176,1 +176,4 @@\n-     * option flag of the form {@code -Xlint}, {@code -Xlint:all}, or {@code -Xlint:key}.\n+     * option flag of the form {@code -Flag}, {@code -Flag:all}, or {@code -Flag:key}.\n+     *\n+     * <p>\n+     * The given {@code option} must have a custom lint variant (available via {@link Option#getLintCustom}).\n@@ -181,0 +184,1 @@\n+     * @param option the plain (non-custom) version of the option (e.g., {@link Option#XLINT})\n@@ -182,1 +186,2 @@\n-     * @return true if {@code lc} has been enabled\n+     * @return true if {@code lc} is enabled via {@code option}'s lint custom variant (e.g., {@link Option#XLINT_CUSTOM})\n+     * @throws IllegalArgumentException if there is no lint custom variant of {@code option}\n@@ -184,4 +189,3 @@\n-    public boolean isLintEnabled(LintCategory lc) {\n-        return isLintExplicitlyEnabled(lc) ||\n-            isSet(Option.XLINT_CUSTOM) ||\n-            isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_ALL);\n+    public boolean isEnabled(Option option, LintCategory lc) {\n+        Option custom = option.getLintCustom();\n+        return isExplicitlyEnabled(option, lc) || isSet(custom) || isSet(custom, Option.LINT_CUSTOM_ALL);\n@@ -192,1 +196,4 @@\n-     * option flag of the form {@code -Xlint:none} or {@code -Xlint:-key}.\n+     * option flag of the form {@code -Flag:none} or {@code -Flag:-key}.\n+     *\n+     * <p>\n+     * The given {@code option} must have a custom lint variant (available via {@link Option#getLintCustom}).\n@@ -197,0 +204,1 @@\n+     * @param option the plain (non-custom) version of the option (e.g., {@link Option#XLINT})\n@@ -198,1 +206,2 @@\n-     * @return true if {@code lc} has been disabled\n+     * @return true if {@code lc} is disabled via {@code option}'s lint custom variant (e.g., {@link Option#XLINT_CUSTOM})\n+     * @throws IllegalArgumentException if there is no lint custom variant of {@code option}\n@@ -200,2 +209,2 @@\n-    public boolean isLintDisabled(LintCategory lc) {\n-        return isLintExplicitlyDisabled(lc) || isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_NONE);\n+    public boolean isDisabled(Option option, LintCategory lc) {\n+        return isExplicitlyDisabled(option, lc) || isSet(option.getLintCustom(), Option.LINT_CUSTOM_NONE);\n@@ -206,1 +215,4 @@\n-     * option flag of the form {@code -Xlint:key}.\n+     * option flag of the form {@code -Flag:key}.\n+     *\n+     * <p>\n+     * The given {@code option} must have a custom lint variant (available via {@link Option#getLintCustom}).\n@@ -209,1 +221,1 @@\n-     * Note: This does not check for option flags of the form {@code -Xlint} or {@code -Xlint:all}.\n+     * Note: This does not check for option flags of the form {@code -Flag} or {@code -Flag:all}.\n@@ -214,0 +226,1 @@\n+     * @param option the plain (non-custom) version of the option (e.g., {@link Option#XLINT})\n@@ -215,1 +228,2 @@\n-     * @return true if {@code lc} has been explicitly enabled\n+     * @return true if {@code lc} is explicitly enabled via {@code option}'s lint custom variant (e.g., {@link Option#XLINT_CUSTOM})\n+     * @throws IllegalArgumentException if there is no lint custom variant of {@code option}\n@@ -217,2 +231,3 @@\n-    public boolean isLintExplicitlyEnabled(LintCategory lc) {\n-        return lc.optionList.stream().anyMatch(alias -> isSet(Option.XLINT_CUSTOM, alias));\n+    public boolean isExplicitlyEnabled(Option option, LintCategory lc) {\n+        Option customOption = option.getLintCustom();\n+        return lc.optionList.stream().anyMatch(alias -> isSet(customOption, alias));\n@@ -223,1 +238,4 @@\n-     * option flag of the form {@code -Xlint:-key}.\n+     * option flag of the form {@code -Flag:-key}.\n+     *\n+     * <p>\n+     * The given {@code option} must have a custom lint variant (available via {@link Option#getLintCustom}).\n@@ -226,1 +244,1 @@\n-     * Note: This does not check for an option flag of the form {@code -Xlint:none}.\n+     * Note: This does not check for an option flag of the form {@code -Flag:none}.\n@@ -231,0 +249,1 @@\n+     * @param option the plain (non-custom) version of the option (e.g., {@link Option#XLINT})\n@@ -232,1 +251,33 @@\n-     * @return true if {@code lc} has been explicitly disabled\n+     * @return true if {@code lc} is explicitly disabled via {@code option}'s lint custom variant (e.g., {@link Option#XLINT_CUSTOM})\n+     * @throws IllegalArgumentException if there is no lint custom variant of {@code option}\n+     *\/\n+    public boolean isExplicitlyDisabled(Option option, LintCategory lc) {\n+        Option customOption = option.getLintCustom();\n+        return lc.optionList.stream().anyMatch(alias -> isSet(customOption, \"-\" + alias));\n+    }\n+\n+    \/**\n+     * Collect the set of {@link LintCategory}s specified by option flag(s) of the form\n+     * {@code -Flag} and\/or {@code -Flag:[-]key,[-]key,...}.\n+     *\n+     * <p>\n+     * The given {@code option} must have a custom lint variant (available via {@link Option#getLintCustom}).\n+     *\n+     * <p>\n+     * The set of categories is calculated as follows. First, an initial set is created:\n+     * <ul>\n+     *  <li>If {@code -Flag} or {@code -Flag:all} appears, the initial set contains all categories; otherwise,\n+     *  <li>If {@code -Flag:none} appears, the initial set is empty; otherwise,\n+     *  <li>The {@code defaults} parameter is invoked to construct an initial set.\n+     * <\/ul>\n+     * Next, for each lint category key {@code key}:\n+     * <ul>\n+     *  <li>If {@code -Flag:key} flag appears, the corresponding category is added to the set; otherwise\n+     *  <li>If {@code -Flag:-key} flag appears, the corresponding category is removed to the set\n+     * <\/ul>\n+     * Unrecognized {@code key}s are ignored.\n+     *\n+     * @param option the plain (non-custom) version of the option (e.g., {@link Option#XLINT})\n+     * @param defaults populates the default set, or null for an empty default set\n+     * @return the specified set of categories\n+     * @throws IllegalArgumentException if there is no lint custom variant of {@code option}\n@@ -234,2 +285,24 @@\n-    public boolean isLintExplicitlyDisabled(LintCategory lc) {\n-        return lc.optionList.stream().anyMatch(alias -> isSet(Option.XLINT_CUSTOM, \"-\" + alias));\n+    public EnumSet<LintCategory> getLintCategoriesOf(Option option, Supplier<? extends EnumSet<LintCategory>> defaults) {\n+\n+        \/\/ Create the initial set\n+        EnumSet<LintCategory> categories;\n+        Option customOption = option.getLintCustom();\n+        if (isSet(option) || isSet(customOption, Option.LINT_CUSTOM_ALL)) {\n+            categories = EnumSet.allOf(LintCategory.class);\n+        } else if (isSet(customOption, Option.LINT_CUSTOM_NONE)) {\n+            categories = EnumSet.noneOf(LintCategory.class);\n+        } else {\n+            categories = defaults.get();\n+        }\n+\n+        \/\/ Apply specific overrides\n+        for (LintCategory category : LintCategory.values()) {\n+            if (isExplicitlyEnabled(option, category)) {\n+                categories.add(category);\n+            } else if (isExplicitlyDisabled(option, category)) {\n+                categories.remove(category);\n+            }\n+        }\n+\n+        \/\/ Done\n+        return categories;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Options.java","additions":93,"deletions":20,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,1 +451,10 @@\n-:   Terminates compilation when warnings occur.\n+:   Terminates compilation when any warnings occur; this includes warnings in all lint\n+    categories, as well as non-lint warnings.\n+\n+<a id=\"option-Werror-custom\">`-Werror:`\\[`-`\\]*key*(`,`\\[`-`\\]*key*)\\*<\/a>\n+:   Specify lint categories for which warnings should terminate compilation. The keys\n+    `all` and `none` include or exclude all categories (respectively); other keys include\n+    the corresponding category, or exclude it if preceded by a hyphen (`-`). By default,\n+    no categories are included. In order to terminate compilation, the category must also\n+    be enabled (via [`-Xlint`](#option-Xlint-custom), if necessary).\n+    See [`-Xlint`](#option-Xlint-custom) below for the list of lint category keys.\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -203,0 +203,1 @@\n+                new CK_ATTRIBUTE(CKA_VALUE_LEN, secretLen),\n@@ -216,15 +217,3 @@\n-            \/\/ Some vendors, e.g. NSS, trim off the leading 0x00 byte(s) from\n-            \/\/ the generated secret. Thus, we need to check the secret length\n-            \/\/ and trim\/pad it so the returned value has the same length as\n-            \/\/ the modulus size\n-            if (secret.length == secretLen) {\n-                return secret;\n-            } else {\n-                if (secret.length > secretLen) {\n-                    \/\/ Shouldn't happen; but check just in case\n-                    throw new ProviderException(\"generated secret is out-of-range\");\n-                }\n-                byte[] newSecret = new byte[secretLen];\n-                System.arraycopy(secret, 0, newSecret, secretLen - secret.length,\n-                    secret.length);\n-                return newSecret;\n+            if (secret.length != secretLen) {\n+                \/\/ Shouldn't happen; but check just in case\n+                throw new ProviderException(\"generated secret is out-of-range\");\n@@ -232,0 +221,1 @@\n+            return secret;\n@@ -324,4 +314,14 @@\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n-            };\n+            CK_ATTRIBUTE[] attributes;\n+            if (\"TlsPremasterSecret\".equalsIgnoreCase(algorithm)) {\n+                attributes = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n+                };\n+            } else {\n+                \/\/ keep the leading zeroes\n+                attributes = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n+                        new CK_ATTRIBUTE(CKA_VALUE_LEN, secretLen),\n+                };\n+            }\n@@ -340,13 +340,0 @@\n-            if (\"RAW\".equals(key.getFormat())\n-                    && algorithm.equalsIgnoreCase(\"TlsPremasterSecret\")) {\n-                \/\/ Workaround for Solaris bug 6318543.\n-                \/\/ Strip leading zeroes ourselves if possible (key not sensitive).\n-                \/\/ This should be removed once the Solaris fix is available\n-                \/\/ as here we always retrieve the CKA_VALUE even for tokens\n-                \/\/ that do not have that bug.\n-                byte[] keyBytes = key.getEncoded();\n-                byte[] newBytes = KeyUtil.trimZeroes(keyBytes);\n-                if (keyBytes != newBytes) {\n-                    key = new SecretKeySpec(newBytes, algorithm);\n-                }\n-            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyAgreement.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -423,0 +423,6 @@\n+        \/\/ Account for the PH being at some vaddr offset from mapping in core file.\n+        uint64_t lib_memsz = lib_php->p_memsz;\n+        if (target_vaddr > existing_map->vaddr) {\n+            lib_memsz += target_vaddr - existing_map->vaddr;\n+        }\n+\n@@ -425,1 +431,1 @@\n-            (ROUNDUP(existing_map->memsz, page_size) != ROUNDUP(lib_php->p_memsz, page_size))) {\n+            (ROUNDUP(existing_map->memsz, page_size) != ROUNDUP(lib_memsz, page_size))) {\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_core.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  private static long          immutableDataReferencesCounterSize;\n@@ -51,1 +52,0 @@\n-  private static CIntegerField deoptMhHandlerOffsetField;\n@@ -82,19 +82,19 @@\n-    methodField                 = type.getAddressField(\"_method\");\n-    entryBCIField               = type.getCIntegerField(\"_entry_bci\");\n-    osrLinkField                = type.getAddressField(\"_osr_link\");\n-    immutableDataField          = type.getAddressField(\"_immutable_data\");\n-    immutableDataSizeField      = type.getCIntegerField(\"_immutable_data_size\");\n-    exceptionOffsetField        = type.getCIntegerField(\"_exception_offset\");\n-    deoptHandlerOffsetField     = type.getCIntegerField(\"_deopt_handler_offset\");\n-    deoptMhHandlerOffsetField   = type.getCIntegerField(\"_deopt_mh_handler_offset\");\n-    origPCOffsetField           = type.getCIntegerField(\"_orig_pc_offset\");\n-    stubOffsetField             = type.getCIntegerField(\"_stub_offset\");\n-    scopesPCsOffsetField        = type.getCIntegerField(\"_scopes_pcs_offset\");\n-    scopesDataOffsetField       = type.getCIntegerField(\"_scopes_data_offset\");\n-    handlerTableOffsetField     = new CIntField(type.getCIntegerField(\"_handler_table_offset\"), 0);\n-    nulChkTableOffsetField      = new CIntField(type.getCIntegerField(\"_nul_chk_table_offset\"), 0);\n-    entryOffsetField            = new CIntField(type.getCIntegerField(\"_entry_offset\"), 0);\n-    verifiedEntryOffsetField    = new CIntField(type.getCIntegerField(\"_verified_entry_offset\"), 0);\n-    osrEntryPointField          = type.getAddressField(\"_osr_entry_point\");\n-    compLevelField              = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n-    pcDescSize = db.lookupType(\"PcDesc\").getSize();\n+    methodField                        = type.getAddressField(\"_method\");\n+    entryBCIField                      = type.getCIntegerField(\"_entry_bci\");\n+    osrLinkField                       = type.getAddressField(\"_osr_link\");\n+    immutableDataField                 = type.getAddressField(\"_immutable_data\");\n+    immutableDataSizeField             = type.getCIntegerField(\"_immutable_data_size\");\n+    exceptionOffsetField               = type.getCIntegerField(\"_exception_offset\");\n+    deoptHandlerOffsetField            = type.getCIntegerField(\"_deopt_handler_offset\");\n+    origPCOffsetField                  = type.getCIntegerField(\"_orig_pc_offset\");\n+    stubOffsetField                    = type.getCIntegerField(\"_stub_offset\");\n+    scopesPCsOffsetField               = type.getCIntegerField(\"_scopes_pcs_offset\");\n+    scopesDataOffsetField              = type.getCIntegerField(\"_scopes_data_offset\");\n+    handlerTableOffsetField            = new CIntField(type.getCIntegerField(\"_handler_table_offset\"), 0);\n+    nulChkTableOffsetField             = new CIntField(type.getCIntegerField(\"_nul_chk_table_offset\"), 0);\n+    entryOffsetField                   = new CIntField(type.getCIntegerField(\"_entry_offset\"), 0);\n+    verifiedEntryOffsetField           = new CIntField(type.getCIntegerField(\"_verified_entry_offset\"), 0);\n+    osrEntryPointField                 = type.getAddressField(\"_osr_entry_point\");\n+    compLevelField                     = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n+    pcDescSize                         = db.lookupType(\"PcDesc\").getSize();\n+    immutableDataReferencesCounterSize = VM.getVM().getIntSize();\n@@ -128,1 +128,0 @@\n-  public Address deoptMhHandlerBegin()  { return headerBegin().addOffsetTo(getDeoptMhHandlerOffset()); }\n@@ -145,1 +144,1 @@\n-  public Address scopesPCsEnd()         { return immutableDataEnd();                                        }\n+  public Address scopesPCsEnd()         { return immutableDataEnd().addOffsetTo(-immutableDataReferencesCounterSize); }\n@@ -175,1 +174,2 @@\n-      nulChkTableSize();\n+      nulChkTableSize()  +\n+      (int) immutableDataReferencesCounterSize;\n@@ -253,11 +253,0 @@\n-  \/\/ MethodHandle\n-  public boolean isMethodHandleReturn(Address returnPc) {\n-    \/\/ Hard to read a bit fields from Java and it's only there for performance\n-    \/\/ so just go directly to the PCDesc\n-    \/\/ if (!hasMethodHandleInvokes())  return false;\n-    PCDesc pd = getPCDescAt(returnPc);\n-    if (pd == null)\n-      return false;\n-    return pd.isMethodHandleInvoke();\n-  }\n-\n@@ -266,1 +255,1 @@\n-  public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc) || isDeoptMhEntry(pc); }\n+  public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc); }\n@@ -268,1 +257,0 @@\n-  public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerBegin(); }\n@@ -497,1 +485,0 @@\n-  private int getDeoptMhHandlerOffset() { return (int) deoptMhHandlerOffsetField.getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-  private static int isMethodHandleInvokeMask;\n@@ -64,1 +63,0 @@\n-    isMethodHandleInvokeMask = db.lookupIntConstant(\"PcDesc::PCDESC_is_method_handle_invoke\");\n@@ -96,5 +94,0 @@\n-  public boolean isMethodHandleInvoke() {\n-    int flags = (int)pcFlagsField.getValue(addr);\n-    return (flags & isMethodHandleInvokeMask) != 0;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/PCDesc.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,11 +148,6 @@\n-\n-     if ((dwarf != null) && dwarf.isIn(nextPC)) {\n-       nextDwarf = dwarf;\n-     } else {\n-       Address libptr = dbg.findLibPtrByAddress(nextPC);\n-       if (libptr != null) {\n-         try {\n-           nextDwarf = new DwarfParser(libptr);\n-         } catch (DebuggerException e) {\n-           \/\/ Bail out to Java frame\n-         }\n+     Address libptr = dbg.findLibPtrByAddress(nextPC);\n+     if (libptr != null) {\n+       try {\n+         nextDwarf = new DwarfParser(libptr);\n+       } catch (DebuggerException e) {\n+         \/\/ Bail out to Java frame\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,18 @@\n+  protected void adjustForDeopt() {\n+    if (pc != null) {\n+      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n+      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n+      if (cb != null && cb.isJavaMethod()) {\n+        NMethod nm = (NMethod) cb;\n+        if (pc.equals(nm.deoptHandlerBegin())) {\n+          if (Assert.ASSERTS_ENABLED) {\n+            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n+          }\n+          \/\/ adjust pc if frame is deoptimized.\n+          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n+          deoptimized = true;\n+        }\n+      }\n+    }\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Frame.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,18 +109,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -132,1 +114,0 @@\n-    adjustUnextendedSP();\n@@ -156,2 +137,0 @@\n-    adjustUnextendedSP();\n-\n@@ -172,1 +151,0 @@\n-    adjustUnextendedSP();\n@@ -358,18 +336,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Sites calling method handle intrinsics and lambda forms are\n-    \/\/ treated as any other call site. Therefore, no special action is\n-    \/\/ needed when we are returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,18 +88,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -119,1 +101,0 @@\n-    adjustUnextendedSP();\n@@ -139,1 +120,0 @@\n-    adjustUnextendedSP();\n@@ -163,1 +143,0 @@\n-    adjustUnextendedSP();\n@@ -345,6 +324,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Nothing to do. senderForInterpreterFrame finds the correct unextendedSP.\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,18 +104,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -127,1 +109,0 @@\n-    adjustUnextendedSP();\n@@ -151,2 +132,0 @@\n-    adjustUnextendedSP();\n-\n@@ -167,1 +146,0 @@\n-    adjustUnextendedSP();\n@@ -350,18 +328,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Sites calling method handle intrinsics and lambda forms are\n-    \/\/ treated as any other call site. Therefore, no special action is\n-    \/\/ needed when we are returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,18 +105,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -137,1 +119,0 @@\n-    adjustUnextendedSP();\n@@ -141,1 +122,1 @@\n-}\n+  }\n@@ -355,18 +336,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ On x86, sites calling method handle intrinsics and lambda forms are treated\n-    \/\/ as any other call site. Therefore, no special action is needed when we are\n-    \/\/ returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+import static jdk.incubator.vector.Float16Consts.MAG_BIT_MASK;\n+import static jdk.incubator.vector.Float16Consts.EXP_BIAS;\n+import static jdk.incubator.vector.Float16Consts.SIGNIFICAND_WIDTH;\n@@ -97,1 +100,1 @@\n-\/\/ Currently Float16 is a value-based class and in future it is\n+\/\/ Currently Float16 is a value-based class and in the future it is\n@@ -104,1 +107,5 @@\n-    \/** @serial *\/\n+\n+    \/**\n+     * Primitive {@code short} field to hold the bits of the {@code Float16}.\n+     * @serial\n+     *\/\n@@ -106,0 +113,1 @@\n+\n@@ -109,1 +117,3 @@\n-    \/\/ IEEEremainder \/ remainder operator remainder\n+    \/\/ IEEEremainder and separate % operator remainder (which are\n+    \/\/ defined to use different rounding modes, see JLS sections 15.4\n+    \/\/ and 15.17.3).\n@@ -149,0 +159,3 @@\n+    \/**\n+     * A constant holding a zero (0.0) of type {@code Float16}.\n+     *\/\n@@ -151,0 +164,3 @@\n+    \/**\n+     * A constant holding a one (1.0) of type {@code Float16}.\n+     *\/\n@@ -318,1 +334,1 @@\n-        if (value <= -65_520L) {  \/\/ -(Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2)\n+        if (value <= -65_520L) {  \/\/ -(MAX_VALUE + ulp(MAX_VALUE) \/ 2)\n@@ -321,1 +337,1 @@\n-            if (value >= 65_520L) {  \/\/ Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2\n+            if (value >= 65_520L) {  \/\/ MAX_VALUE + ulp(MAX_VALUE) \/ 2\n@@ -399,1 +415,1 @@\n-        int PRECISION_DIFF = Double.PRECISION - PRECISION; \/\/ 42\n+        final int PRECISION_DIFF = Double.PRECISION - PRECISION; \/\/ 42\n@@ -429,1 +445,0 @@\n-        \/\/ Exponent bias adjust in the representation is equal to MAX_EXPONENT.\n@@ -431,1 +446,1 @@\n-                                   ( ((exp + MAX_EXPONENT) << (PRECISION - 1)) + signif_bits ) ));\n+                                   ( ((exp + EXP_BIAS) << (PRECISION - 1)) + signif_bits) ));\n@@ -470,1 +485,1 @@\n-            || Math.abs(trialResult) > (65504.0 + 32.0) || \/\/ Float.MAX_VALUE + ulp(MAX_VALUE),\n+            || Math.abs(trialResult) > (65504.0 + 32.0) || \/\/ MAX_VALUE + ulp(MAX_VALUE),\n@@ -777,1 +792,1 @@\n-        return (float16ToRawShortBits(f16) & (EXP_BIT_MASK | SIGNIF_BIT_MASK)) <=\n+        return (float16ToRawShortBits(f16) & MAG_BIT_MASK) <=\n@@ -901,1 +916,1 @@\n-        Float16 f16 = isNaN(value) ? Float16.NaN : value;\n+        Float16 f16 = isNaN(value) ? NaN : value;\n@@ -948,1 +963,1 @@\n-            return Float16.NaN.value;\n+            return NaN.value;\n@@ -1096,1 +1111,1 @@\n-     * For example, this property hold between the formats used for the\n+     * For example, this property holds between the formats used for the\n@@ -1480,1 +1495,1 @@\n-        return shortBitsToFloat16((short)(f16.value ^ (short)0x0000_8000));\n+        return shortBitsToFloat16((short)(f16.value ^ SIGN_BIT_MASK));\n@@ -1498,1 +1513,1 @@\n-        return shortBitsToFloat16((short)(f16.value & (short)0x0000_7FFF));\n+        return shortBitsToFloat16((short)(f16.value & MAG_BIT_MASK));\n@@ -1533,2 +1548,2 @@\n-        int bin16ExpBits     = 0x0000_7c00 & bits;     \/\/ Five exponent bits.\n-        return (bin16ExpBits >> (PRECISION - 1)) - 15;\n+        int bin16ExpBits = EXP_BIT_MASK & bits; \/\/ Five exponent bits.\n+        return (bin16ExpBits >> (PRECISION - 1)) - EXP_BIAS;\n@@ -1565,2 +1580,2 @@\n-        case MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n-        case MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        case MAX_EXPONENT + 1 -> abs(f16);  \/\/ NaN or infinity\n+        case MIN_EXPONENT - 1 -> MIN_VALUE; \/\/ zero or subnormal\n@@ -1568,1 +1583,1 @@\n-            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT;\n+            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT: \"Out of range exponent\";\n@@ -1689,2 +1704,1 @@\n-        final int MAX_SCALE = Float16.MAX_EXPONENT + -Float16.MIN_EXPONENT +\n-                Float16Consts.SIGNIFICAND_WIDTH + 1;\n+        final int MAX_SCALE = MAX_EXPONENT + -MIN_EXPONENT + SIGNIFICAND_WIDTH + 1;\n@@ -1727,3 +1741,2 @@\n-        return shortBitsToFloat16((short) ((float16ToRawShortBits(sign) & SIGN_BIT_MASK) |\n-                                           (float16ToRawShortBits(magnitude) &\n-                                            (EXP_BIT_MASK | SIGNIF_BIT_MASK) )));\n+        return shortBitsToFloat16((short)((float16ToRawShortBits(sign)      & SIGN_BIT_MASK) |\n+                                          (float16ToRawShortBits(magnitude) & MAG_BIT_MASK)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":38,"deletions":25,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -381,1 +381,2 @@\n-                        .append(\"loadScripts(document, 'script');\");\n+                        .append(\"loadScripts();\\n\")\n+                        .append(\"initTheme();\\n\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -14,6 +14,7 @@\n-var oddRowColor = \"odd-row-color\";\n-var evenRowColor = \"even-row-color\";\n-var sortAsc = \"sort-asc\";\n-var sortDesc = \"sort-desc\";\n-var tableTab = \"table-tab\";\n-var activeTableTab = \"active-table-tab\";\n+const oddRowColor = \"odd-row-color\";\n+const evenRowColor = \"even-row-color\";\n+const sortAsc = \"sort-asc\";\n+const sortDesc = \"sort-desc\";\n+const tableTab = \"table-tab\";\n+const activeTableTab = \"active-table-tab\";\n+const THEMES = Object.freeze([\"theme-light\", \"theme-dark\", \"theme-os\"]);\n@@ -33,8 +34,7 @@\n-function loadScripts(doc, tag) {\n-    createElem(doc, tag, 'script-files\/search.js');\n-\n-    createElem(doc, tag, 'module-search-index.js');\n-    createElem(doc, tag, 'package-search-index.js');\n-    createElem(doc, tag, 'type-search-index.js');\n-    createElem(doc, tag, 'member-search-index.js');\n-    createElem(doc, tag, 'tag-search-index.js');\n+function loadScripts() {\n+    createScript('script-files\/search.js');\n+    createScript('module-search-index.js');\n+    createScript('package-search-index.js');\n+    createScript('type-search-index.js');\n+    createScript('member-search-index.js');\n+    createScript('tag-search-index.js');\n@@ -43,3 +43,2 @@\n-function createElem(doc, tag, path) {\n-    var script = doc.createElement(tag);\n-    var scriptElement = doc.getElementsByTagName(tag)[0];\n+function createScript(path) {\n+    var script = document.createElement(\"script\");\n@@ -47,1 +46,2 @@\n-    scriptElement.parentNode.insertBefore(script, scriptElement);\n+    var firstScript = document.getElementsByTagName(\"script\")[0];\n+    firstScript.parentNode.insertBefore(script, firstScript);\n@@ -315,0 +315,8 @@\n+function getTheme() {\n+    return localStorage.getItem('theme') || THEMES[0];\n+}\n+\n+function initTheme() {\n+    document.body.classList.add(getTheme());\n+}\n+\n@@ -321,0 +329,1 @@\n+\n@@ -324,4 +333,4 @@\n-    }\n-    if (sessionStorage.getItem(\"sidebar\") === \"hidden\") {\n-        const sidebar = document.querySelector(\".main-grid nav.toc\");\n-        if (sidebar) sidebar.classList.add(\"hide-sidebar\");\n+        if (sessionStorage.getItem(\"sidebar\") === \"hidden\") {\n+            const sidebar = document.querySelector(\".main-grid nav.toc\");\n+            if (sidebar) sidebar.classList.add(\"hide-sidebar\");\n+        }\n@@ -330,0 +339,1 @@\n+\n@@ -378,0 +388,1 @@\n+    var currentTheme = getTheme();\n@@ -380,0 +391,3 @@\n+        if (input.id === currentTheme) {\n+            input.checked = true;\n+        }\n@@ -384,1 +398,0 @@\n-    const THEMES = [\"theme-light\", \"theme-dark\", \"theme-os\"];\n@@ -393,1 +406,0 @@\n-    setTheme(localStorage.getItem(\"theme\") || THEMES[0]);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    --even-row-color: #ffffff;\n+    --even-row-color: #fdfdfe;\n@@ -112,0 +112,2 @@\n+    --icon-filter: none;\n+    --caption-link-color: var(--subnav-link-color);\n@@ -117,1 +119,1 @@\n-    --body-background-color: #222528;\n+    --body-background-color: #1f2124;\n@@ -122,1 +124,1 @@\n-    --detail-block-color: #f4f4f4;\n+    --detail-block-color: #31363c;\n@@ -136,2 +138,2 @@\n-    --link-color-active: #ffb45b;\n-    --toc-background-color: #31363c;\n+    --link-color-active: #e8a351;\n+    --toc-background-color: #2f3439;\n@@ -140,1 +142,1 @@\n-    --snippet-background-color: #2d363c;\n+    --snippet-background-color: #2c353b;\n@@ -158,4 +160,2 @@\n-    div.main-grid img,\n-    .inherited-list h3 > button {\n-        filter: invert(100%) brightness(160%);\n-    }\n+    --icon-filter: invert(100%) brightness(160%);\n+    --caption-link-color: var(--link-color);\n@@ -171,1 +171,1 @@\n-        --body-background-color: #222528;\n+        --body-background-color: #1f2124;\n@@ -176,1 +176,1 @@\n-        --detail-block-color: #f4f4f4;\n+        --detail-block-color: #31363c;\n@@ -190,2 +190,2 @@\n-        --link-color-active: #ffb45b;\n-        --toc-background-color: #31363c;\n+        --link-color-active: #e8a351;\n+        --toc-background-color: #2f3439;\n@@ -194,1 +194,1 @@\n-        --snippet-background-color: #2d363c;\n+        --snippet-background-color: #2c353b;\n@@ -212,4 +212,2 @@\n-        div.main-grid img,\n-        .inherited-list h3 > button {\n-            filter: invert(100%) brightness(160%);\n-        }\n+        --icon-filter: invert(100%) brightness(160%);\n+        --caption-link-color: var(--link-color);\n@@ -219,2 +217,2 @@\n-        --body-text-color: #282828;\n-        --block-text-color: #282828;\n+        --body-text-color: #181818;\n+        --block-text-color: #181818;\n@@ -236,1 +234,1 @@\n-        --even-row-color: #ffffff;\n+        --even-row-color: #fdfdfe;\n@@ -262,4 +260,2 @@\n-        div.main-grid img,\n-        .inherited-list h3 > button {\n-            filter: none;\n-        }\n+        --icon-filter: none;\n+        --caption-link-color: var(--subnav-link-color);\n@@ -291,0 +287,3 @@\n+div.main-grid img {\n+    filter: var(--icon-filter);\n+}\n@@ -912,1 +911,1 @@\n-    color:var(--subnav-link-color);\n+    color:var(--caption-link-color);\n@@ -916,2 +915,2 @@\n-.inherited-list.expanded h3 a:hover,\n-.inherited-list.expanded h3 a:active {\n+.inherited-list h3 a:hover,\n+.inherited-list h3 a:active {\n@@ -1542,0 +1541,1 @@\n+    filter: var(--icon-filter);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -465,0 +465,1 @@\n+               --------------------------------------------\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    synchronized boolean isEnabled(String eventName) {\n+    boolean isEnabled(String eventName) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-   private Map<String, InternalSetting> availableSettings = new LinkedHashMap<>();\n+    private volatile Map<String, InternalSetting> availableSettings = new LinkedHashMap<>();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SettingsManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2015, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025 SAP SE. All rights reserved.\n@@ -31,0 +31,4 @@\n+#include <libperfstat.h>\n+#include <pthread.h>\n+#include <stdlib.h>\n+#include <time.h>\n@@ -33,0 +37,29 @@\n+static struct perfMetrics{\n+    unsigned long long timebase;\n+    perfstat_process_t stats;\n+    perfstat_cpu_total_t cpu_total;\n+} counters;\n+\n+static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n+\n+int perfInit() {\n+    static int initialized = 0;\n+    if (!initialized) {\n+\n+        perfstat_id_t id;\n+        counters.stats = (perfstat_process_t){0};\n+        counters.timebase = 0;\n+        int rc = perfstat_cpu_total(NULL, &counters.cpu_total, sizeof(perfstat_cpu_total_t), 1);\n+        if (rc < 0) {\n+            return -1;\n+        }\n+        rc = perfstat_process(&id, &counters.stats, sizeof(perfstat_process_t), 1);\n+        if (rc < 0) {\n+            return -1;\n+        }\n+        counters.timebase = counters.stats.last_timebase;\n+        initialized = 1;\n+    }\n+    return initialized ? 0 : -1;\n+}\n+\n@@ -37,1 +70,28 @@\n-    return -1.0;\n+    double load = -1.0;\n+    pthread_mutex_lock(&lock);\n+    if (perfInit() == 0) {\n+        int ret;\n+        perfstat_cpu_total_t cpu_total;\n+        ret = perfstat_cpu_total(NULL, &cpu_total, sizeof(perfstat_cpu_total_t), 1);\n+        if (ret < 0) {\n+            return -1.0;\n+        }\n+        long long user_diff = cpu_total.user - counters.cpu_total.user;\n+        long long sys_diff = cpu_total.sys - counters.cpu_total.sys;\n+        long long idle_diff = cpu_total.idle - counters.cpu_total.idle;\n+        long long wait_diff = cpu_total.wait - counters.cpu_total.wait;\n+        long long total = user_diff + sys_diff + idle_diff + wait_diff;\n+        if (total < (user_diff + sys_diff)) {\n+            total = user_diff + sys_diff;\n+        }\n+        if (total == 0) {\n+            load = 0.0;\n+        } else {\n+            load = (double)(user_diff + sys_diff) \/ total;\n+            load = MAX(load, 0.0);\n+            load = MIN(load, 1.0);\n+        }\n+        counters.cpu_total = cpu_total;\n+    }\n+    pthread_mutex_unlock(&lock);\n+    return load;\n@@ -44,1 +104,32 @@\n-    return -1.0;\n+    perfstat_process_t curr_stats;\n+    perfstat_id_t id;\n+    unsigned long long curr_timebase, timebase_diff;\n+    double user_diff, sys_diff, delta_time;\n+    double cpu_load = -1.0;\n+    pthread_mutex_lock(&lock);\n+    if (perfInit() == 0) {\n+        int ret;\n+        ret = perfstat_process(&id, &curr_stats, sizeof(perfstat_process_t), 1);\n+        if (ret < 0) {\n+            return -1.0;\n+        }\n+        curr_timebase = curr_stats.last_timebase;\n+        timebase_diff = curr_timebase - counters.timebase;\n+        if ((long long)timebase_diff < 0 || XINTFRAC == 0) {\n+            return -1.0;\n+        }\n+        delta_time = HTIC2NANOSEC(timebase_diff) \/ 1000000000.0;\n+        user_diff = (double)(curr_stats.ucpu_time - counters.stats.ucpu_time);\n+        sys_diff  = (double)(curr_stats.scpu_time - counters.stats.scpu_time);\n+        counters.stats = curr_stats;\n+        counters.timebase = curr_timebase;\n+        if (delta_time == 0) {\n+            cpu_load = 0.0;\n+        } else {\n+            cpu_load = (user_diff + sys_diff) \/ delta_time;\n+            cpu_load = MAX(cpu_load, 0.0);\n+            cpu_load = MIN(cpu_load, 1.0);\n+        }\n+    }\n+    pthread_mutex_unlock(&lock);\n+    return (jdouble)cpu_load;\n","filename":"src\/jdk.management\/aix\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":95,"deletions":4,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    void setArtificial() {\n+    public void setArtificial() {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n@@ -29,1 +28,0 @@\n-import java.util.Collection;\n@@ -37,1 +35,5 @@\n-    public Collection<InputBlock> schedule(InputGraph graph);\n+    \/\/ Compute a set of scheduled blocks for the given graph, creating new\n+    \/\/ blocks if these are not found in the graph.\n+    public void schedule(InputGraph graph);\n+    \/\/ Schedule locally the set of blocks in the given graph.\n+    public void scheduleLocally(InputGraph graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/Scheduler.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,0 +117,3 @@\n+            if (blk.isArtificial()) {\n+                diffblk.setArtificial();\n+            }\n@@ -124,0 +127,3 @@\n+            if (blk.isArtificial()) {\n+                diffblk.setArtificial();\n+            }\n@@ -252,0 +258,3 @@\n+        Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n+        s.scheduleLocally(graph);\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Difference\/src\/main\/java\/com\/sun\/hotspot\/igv\/difference\/Difference.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-            <version>15.3<\/version>\n+            <version>${nashorn.version}<\/version>\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-between 17 and 21 (the JDKs supported by the current NetBeans Platform).\n+between 17 and 25 (the JDKs supported by the current NetBeans Platform).\n","filename":"src\/utils\/IdealGraphVisualizer\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -299,0 +299,15 @@\n+    private boolean initialize(InputGraph graph) {\n+        nodes = new ArrayList<>();\n+        inputNodeToNode = new HashMap<>(graph.getNodes().size());\n+        this.graph = graph;\n+        if (!hasCategoryInformation()) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING,\n+                \"Cannot find node category information in the input graph. \" +\n+                \"The control-flow graph will not be approximated.\");\n+            return false;\n+        }\n+        buildUpGraph();\n+        markCFGNodes();\n+        return true;\n+    }\n+\n@@ -300,1 +315,1 @@\n-    public Collection<InputBlock> schedule(InputGraph graph) {\n+    public void schedule(InputGraph graph) {\n@@ -302,1 +317,1 @@\n-            return Collections.emptyList();\n+            return;\n@@ -314,1 +329,1 @@\n-            return graph.getBlocks();\n+            return;\n@@ -316,9 +331,2 @@\n-            nodes = new ArrayList<>();\n-            inputNodeToNode = new HashMap<>(graph.getNodes().size());\n-\n-            this.graph = graph;\n-            if (!hasCategoryInformation()) {\n-                ErrorManager.getDefault().log(ErrorManager.WARNING,\n-                    \"Cannot find node category information in the input graph. \" +\n-                    \"The control-flow graph will not be approximated.\");\n-                return null;\n+            if (!initialize(graph)) {\n+                return;\n@@ -326,2 +334,0 @@\n-            buildUpGraph();\n-            markCFGNodes();\n@@ -336,1 +342,16 @@\n-            return blocks;\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void scheduleLocally(InputGraph graph) {\n+        if (!initialize(graph)) {\n+            return;\n+        }\n+        \/\/ Import global schedule from the given graph.\n+        blocks = new Vector<>();\n+        for (InputBlock block : graph.getBlocks()) {\n+            blocks.add(block);\n+            for (InputNode in : block.getNodes()) {\n+                inputNodeToNode.get(in).block = block;\n+            }\n@@ -338,0 +359,1 @@\n+        scheduleLocal();\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,3 @@\n+                        <compilerArgs>\n+                            <arg>-proc:full<\/arg>\n+                        <\/compilerArgs>\n@@ -81,2 +84,2 @@\n-                                      <version>[17,22)<\/version>\n-                                      <message>IGV requires a JDK version between 17 and 21<\/message>\n+                                        <version>[17,26)<\/version>\n+                                        <message>IGV requires a JDK version between 17 and 25<\/message>\n@@ -112,1 +115,2 @@\n-        <netbeans.version>RELEASE200<\/netbeans.version>\n+        <netbeans.version>RELEASE270<\/netbeans.version>\n+        <nashorn.version>15.7<\/nashorn.version>\n","filename":"src\/utils\/IdealGraphVisualizer\/pom.xml","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,0 +85,11 @@\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#G1 8369147 generic-all\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#Parallel 8369147 generic-all\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#Serial 8369147 generic-all\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#ZGC 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#G1 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#Parallel 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#Serial 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#ZGC 8369147 generic-all\n+compiler\/whitebox\/StressNMethodRelocation.java 8369147,8369148,8369149 generic-all\n+serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150,8369151 generic-all\n+\n@@ -89,0 +100,8 @@\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#G1C1 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#G1C2 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#ParallelC1 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#ParallelC2 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#SerialC1 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#SerialC2 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#ZGCC1 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#ZGCC2 8370571 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+  compiler\/gallery \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,4 +79,1 @@\n-        long res = 0;\n-        for (int i = 0; i < 10000; i++) {\n-            res |= test1(field_L);\n-        }\n+        long res = test1(field_L);\n@@ -95,4 +92,1 @@\n-        int res = 0;\n-        for (int i = 0; i < 10000; i++) {\n-            res |= test2(field_I);\n-        }\n+        int res = test2(field_I);\n@@ -116,1 +110,1 @@\n-        for (int i = 1; i < 10000; i++) {\n+        for (int i = 1; i < 100; i++) {\n@@ -136,1 +130,1 @@\n-        for (long i = 1; i < 10000; i++) {\n+        for (long i = 1; i < 100; i++) {\n@@ -154,1 +148,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -172,1 +166,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -191,1 +185,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -209,1 +203,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -227,1 +221,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -246,1 +240,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -249,1 +243,1 @@\n-        Asserts.assertGTE(10000, res);\n+        Asserts.assertGTE(100, res);\n@@ -263,1 +257,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -280,1 +274,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -297,1 +291,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -314,1 +308,1 @@\n-        for (int i = -10000; i < 10000; i++) {\n+        for (int i = -100; i < 100; i++) {\n@@ -330,4 +324,1 @@\n-        int res = 0;\n-        for (int i = 0; i < 10000; i++) {\n-            res |= test15(0, 0);\n-        }\n+        int res = test15(0, 0);\n@@ -411,1 +402,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 100; i++) {\n@@ -495,1 +486,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 100; i++) {\n@@ -579,1 +570,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 100; i++) {\n@@ -663,1 +654,1 @@\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 100; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":20,"deletions":29,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+    volatile Object global;\n@@ -128,1 +129,3 @@\n-    public void consume(Object o) {}\n+    public void consume(Object o) {\n+        global = o;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConstructorBarriers.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n@@ -40,1 +40,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n@@ -53,1 +53,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n@@ -78,1 +78,1 @@\n-        \/\/  we end up running almost all code in the interpreter\n+        \/\/ we end up running almost all code in the interpreter\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/UnexpectedDeoptimizationTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,554 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gallery;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Color;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBufferInt;\n+import java.io.IOException;\n+import java.util.Random;\n+import javax.swing.JPanel;\n+import java.awt.Font;\n+\n+import java.net.URL;\n+import java.net.URISyntaxException;\n+import java.io.File;\n+import java.util.Arrays;\n+\n+\/**\n+ * I presented this demo at the JVMLS 2025 conference, when giving\n+ * a talk about Auto-Vectorization in HotSpot, see:\n+ *   https:\/\/inside.java\/2025\/08\/16\/jvmls-hotspot-auto-vectorization\/\n+ *\n+ * This is a stand-alone test that you can run directly with:\n+ *   java NormalMapping.java\n+ *\n+ * If you want to disable the auto-vectorizer, you can run:\n+ *   java -XX:-UseSuperWord NormalMapping.java\n+ *\n+ * On x86, you can also play with the UseAVX flag:\n+ *   java -XX:UseAVX=1 NormalMapping.java\n+ *\n+ * There is a JTREG test that automatically runs this demo,\n+ * see {@link TestNormalMapping}.\n+ *\n+ * My motivation for JVMLS 2025 was to present something that vectorizes\n+ * in an \"embarassingly parallel\" way. It should be something that C2's\n+ * SuperWord Auto Vectorizer could already do for many JDK releases,\n+ * and also has some visual appeal. I decided to use normal mapping, see:\n+ *   https:\/\/en.wikipedia.org\/wiki\/Normal_mapping\n+ *\n+ * At the conference, I only had the version that loads a normal map\n+ * from an image. I now also added some \"generated\" cases, which are\n+ * created from 2d height functions, and then converted to normal\n+ * maps. This allows us to show more \"surfaces\" without having to\n+ * store the images for all those cases.\n+ *\n+ * If you are interested in understanding the components, then look at these:\n+ * - computeLight: the normal mapping \"shader \/ kernel\".\n+ * - generateNormals \/ computeNormals: computing normals from height functions.\n+ * - nextNormals: add you own normal map png or height function.\n+ * - main: setup and endless-loop that triggers normals to be swapped periodically.\n+ * - MyDrawingPanel: drawing all the parts to the screen.\n+ *\/\n+public class NormalMapping {\n+    public static Random RANDOM = new Random();\n+\n+    \/\/ Increasing this number will make the demo slower.\n+    public static final int NUMBER_OF_LIGHTS = 5;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Welcome to the Normal Mapping Demo!\");\n+        State state = new State(NUMBER_OF_LIGHTS);\n+\n+        \/\/ Set up a panel we can draw on, and put it in a window.\n+        System.out.println(\"Setting up Window...\");\n+        MyDrawingPanel panel = new MyDrawingPanel(state);\n+        JFrame frame = new JFrame(\"Normal Mapping Demo (Auto-Vectorization)\");\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setSize(2000, 1000);\n+        frame.add(panel);\n+        frame.setVisible(true);\n+        System.out.println(\"Running Demo...\");\n+\n+        try {\n+            \/\/ Tight loop where we redraw the panel as fast as possible.\n+            int count = 0;\n+            while (true) {\n+                Thread.sleep(1);\n+                state.update();\n+                panel.repaint();\n+                if (count++ > 500) {\n+                    count = 0;\n+                    state.nextNormals();\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            System.out.println(\"Interrputed, terminating demo.\");\n+        } finally {\n+            System.out.println(\"Shut down demo.\");\n+            frame.setVisible(false);\n+            frame.dispose();\n+        }\n+    }\n+\n+    public static File getLocalFile(String name) {\n+        \/\/ If we are in JTREG IR testing mode, we have to get the path via system property,\n+        \/\/ if it is run in stand-alone that property is not available, and we can load\n+        \/\/ via getResource.\n+        System.out.println(\"Loading file: \" + name);\n+        String testSrc = System.getProperty(\"test.src\", null);\n+        System.out.println(\"System Property test.src: \" + testSrc);\n+        if (testSrc == null) {\n+            URL path = NormalMapping.class.getResource(name);\n+            System.out.println(\"  Loading via getResource: \" + path);\n+            try {\n+                return new File(path.toURI());\n+            } catch (URISyntaxException e) {\n+                throw new RuntimeException(\"Could not load: \", e);\n+            }\n+        } else {\n+            return new File(testSrc + \"\/\" + name);\n+        }\n+    }\n+\n+    public static BufferedImage loadImage(File file) {\n+        try {\n+            return ImageIO.read(file);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Could not load: \", e);\n+        }\n+    }\n+\n+    \/**\n+     * This class represents the lights that are located on the normal map,\n+     * moved around randomly, and shine their color of light on the scene.\n+     *\/\n+    public static class Light {\n+        public float x = 0.5f;\n+        public float y = 0.5f;\n+        private float dx;\n+        private float dy;\n+\n+        private float h;\n+        public float r;\n+        public float g;\n+        public float b;\n+\n+        Light() {\n+            this.h = RANDOM.nextFloat();\n+        }\n+\n+        \/\/ Random movement of the Light\n+        public void update() {\n+            \/\/ Random acceleration with dampening.\n+            dx *= 0.99;\n+            dy *= 0.99;\n+            dx += RANDOM.nextFloat() * 0.001 - 0.0005;\n+            dy += RANDOM.nextFloat() * 0.001 - 0.0005;\n+            x += dx;\n+            y += dy;\n+\n+            \/\/ Boounce off the walls.\n+            if (x < 0) { dx = +Math.abs(dx); }\n+            if (x > 1) { dx = -Math.abs(dx); }\n+            if (y < 0) { dy = +Math.abs(dy); }\n+            if (y > 1) { dy = -Math.abs(dy); }\n+\n+            \/\/ Rotate the hue -> gets us nice rainbow colors.\n+            h += 0.001 + RANDOM.nextFloat() * 0.0002;\n+            Color c = Color.getHSBColor(h, 1f, 1f);\n+            r = (1f \/ 256f) * c.getRed();\n+            g = (1f \/ 256f) * c.getGreen();\n+            b = (1f \/ 256f) * c.getBlue();\n+        }\n+    }\n+\n+    \/**\n+     * This class manages the state of the demo, including the lights,\n+     * arrays passed in and out of the normal map computation, as well\n+     * as the image buffers and FPS tracking.\n+     *\/\n+    public static class State {\n+        private static final int sizeX = 1000;\n+        private static final int sizeY = 1000;\n+\n+        public Light[] lights;\n+\n+        public float[] coordsX;\n+        public float[] coordsY;\n+\n+        private int nextNormalsId = 0;\n+        public BufferedImage normals;\n+        public float[] normalsX;\n+        public float[] normalsY;\n+        public float[] normalsZ;\n+\n+        public BufferedImage output;\n+        public BufferedImage output_2;\n+        public int[] outputRGB;\n+        public int[] outputRGB_2;\n+\n+        public long lastTime;\n+        public float fps;\n+\n+        float luminosityCorrection = 1f;\n+\n+        public State(int numberOfLights) {\n+            lights = new Light[numberOfLights];\n+            for (int i = 0; i < lights.length; i++) {\n+                lights[i] = new Light();\n+            }\n+\n+            \/\/ Coordinates\n+            this.coordsX = new float[sizeX * sizeY];\n+            this.coordsY = new float[sizeX * sizeY];\n+            for (int y = 0; y < sizeY; y++) {\n+                for (int x = 0; x < sizeX; x++) {\n+                    this.coordsX[y * sizeX + x] = x * (1f \/ sizeX);\n+                    this.coordsY[y * sizeX + x] = y * (1f \/ sizeY);\n+                }\n+            }\n+\n+            nextNormals();\n+\n+            \/\/ Double buffered output images, where we render to.\n+            \/\/ Without double buffering, we would get some flickering effects,\n+            \/\/ because we would be concurrently updating the buffer and drawing it.\n+            this.output   = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);\n+            this.output_2 = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);\n+            this.outputRGB   = ((DataBufferInt) output.getRaster().getDataBuffer()).getData();\n+            this.outputRGB_2 = ((DataBufferInt) output_2.getRaster().getDataBuffer()).getData();\n+\n+            \/\/ Set up the FPS tracker\n+            lastTime = System.nanoTime();\n+        }\n+\n+        public void nextNormals() {\n+            switch (nextNormalsId) {\n+                case 0 -> setNormals(loadNormals(\"normal_map.png\"));\n+                case 1 -> setNormals(generateNormals(\"heart\"));\n+                case 2 -> setNormals(generateNormals(\"hex\"));\n+                case 3 -> setNormals(generateNormals(\"cone\"));\n+                case 4 -> setNormals(generateNormals(\"ripple\"));\n+                case 5 -> setNormals(generateNormals(\"hill\"));\n+                case 6 -> setNormals(generateNormals(\"ripple2\"));\n+                case 7 -> setNormals(generateNormals(\"cones\"));\n+                case 8 -> setNormals(generateNormals(\"spheres\"));\n+                case 9 -> setNormals(generateNormals(\"donut\"));\n+                default -> throw new RuntimeException();\n+            }\n+            nextNormalsId = (nextNormalsId + 1) % 10;\n+        }\n+\n+        public BufferedImage loadNormals(String name) {\n+            \/\/ Extract normal values from RGB image\n+            \/\/ The loaded image may not have the desired INT_RGB format, so first convert it\n+            BufferedImage normalsLoaded = loadImage(getLocalFile(name));\n+            BufferedImage buf = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);\n+            buf.getGraphics().drawImage(normalsLoaded, 0, 0, null);\n+            return buf;\n+        }\n+\n+        public void setNormals(BufferedImage buf) {\n+            this.normals = buf;\n+\n+            int[] normalsRGB = ((DataBufferInt) this.normals.getRaster().getDataBuffer()).getData();\n+            this.normalsX = new float[sizeX * sizeY];\n+            this.normalsY = new float[sizeX * sizeY];\n+            this.normalsZ = new float[sizeX * sizeY];\n+            for (int y = 0; y < sizeY; y++) {\n+                for (int x = 0; x < sizeX; x++) {\n+                    this.coordsY[y * sizeX + x] = y * (1f \/ sizeY);\n+                    int normal = normalsRGB[y * sizeX + x];\n+                    \/\/ RGB values in range [0 ... 255]\n+                    int nr = (normal >> 16) & 0xff;\n+                    int ng = (normal >>  8) & 0xff;\n+                    int nb = (normal >>  0) & 0xff;\n+\n+                    \/\/ Map range [0..255] -> [-1 .. 1]\n+                    float nx = ((float)nr) * (1f \/ 128f) - 1f;\n+                    float ny = ((float)ng) * (1f \/ 128f) - 1f;\n+                    float nz = ((float)nb) * (1f \/ 128f) - 1f;\n+\n+                    this.normalsX[y * sizeX + x] = -nx;\n+                    this.normalsY[y * sizeX + x] = ny;\n+                    this.normalsZ[y * sizeX + x] = nz;\n+                }\n+            }\n+        }\n+\n+        interface HeightFunction {\n+            \/\/ x and y should be in [0..1]\n+            double call(double x, double y);\n+        }\n+\n+        public BufferedImage generateNormals(String name) {\n+            System.out.println(\"  generate normals for: \" + name);\n+            return computeNormals((double x, double y) -> {\n+                \/\/ Scale out, so we see a little more\n+                x = 10 * (x - 0.5);\n+                y = 10 * (y - 0.5);\n+\n+                \/\/ A selection of \"height functions\":\n+                return switch (name) {\n+                    case \"cone\" -> 0.1 * Math.max(0, 2 - Math.sqrt(x * x + y * y));\n+                    case \"heart\" -> {\n+                        double heart = Math.abs(Math.pow(x * x + y * y - 1, 3) - x * x * Math.pow(-y, 3));\n+                        double decay = Math.exp(-(x * x + y * y));\n+                        yield 0.1 * heart * decay;\n+                    }\n+                    case \"hill\" ->    0.5 * Math.exp(-(x * x + y * y));\n+                    case \"ripple\" ->  0.01 * Math.sin(x * x + y * y);\n+                    case \"ripple2\" -> 0.3 * Math.sin(x) * Math.sin(y);\n+                    case \"donut\" -> {\n+                        double d = Math.sqrt(x * x + y * y) - 2;\n+                        double i = 1 - d*d;\n+                        yield (i >= 0) ? 0.1 * Math.sqrt(i) : 0;\n+                    }\n+                    case \"hex\" -> {\n+                        double f = 3.0;\n+                        double a = Math.cos(f * x);\n+                        double b = Math.cos(f * (-0.5 * x + Math.sqrt(3) \/ 2.0 * y));\n+                        double c = Math.cos(f * (-0.5 * x - Math.sqrt(3) \/ 2.0 * y));\n+                        yield 0.03 * (a + b + c);\n+                    }\n+                    case \"cones\" -> {\n+                        double scale = 2.0;\n+                        double r = 0.8;\n+                        double cx = scale * (Math.floor(x \/ scale) + 0.5);\n+                        double cy = scale * (Math.floor(y \/ scale) + 0.5);\n+                        double dx = x - cx;\n+                        double dy = y - cy;\n+                        double d = Math.sqrt(dx * dx + dy * dy);\n+                        yield 0.1 * Math.max(0, 0.8 - d);\n+                    }\n+                    case \"spheres\" -> {\n+                        double scale = 2.0;\n+                        double r = 0.8;\n+                        double cx = scale * (Math.floor(x \/ scale) + 0.5);\n+                        double cy = scale * (Math.floor(y \/ scale) + 0.5);\n+                        double dx = x - cx;\n+                        double dy = y - cy;\n+                        double d2 = dx * dx + dy * dy;\n+                        if (d2 <= r * r) {\n+                            yield 0.03 * Math.sqrt(r * r - d2);\n+                        }\n+                        yield 0.0;\n+                    }\n+                    default -> throw new RuntimeException(\"not supported: \" + name);\n+                };\n+            });\n+        }\n+\n+        public static BufferedImage computeNormals(HeightFunction fun) {\n+            BufferedImage out = new BufferedImage(1000, 1000, BufferedImage.TYPE_INT_RGB);\n+            int[] arr = ((DataBufferInt) out.getRaster().getDataBuffer()).getData();\n+            int sx = out.getWidth();\n+            int sy = out.getHeight();\n+\n+            double delta = 0.00001;\n+            double dxx = 1.0 \/ sx;\n+            double dyy = 1.0 \/ sy;\n+            for (int yy = 0; yy < sy; yy++) {\n+                int nStart = sy * yy;\n+                for (int xx = 0; xx < sx; xx++) {\n+                    double x = xx * dxx;\n+                    double y = yy * dyy;\n+\n+                    \/\/ Compute the partial derivatives in x and y direction;\n+                    double fdx = fun.call(x + delta, y) - fun.call(x - delta, y);\n+                    double fdy = fun.call(x, y + delta) - fun.call(x, y - delta);\n+                    \/\/ We can compute the normal from the cross product of:\n+                    \/\/\n+                    \/\/  df\/dx  x  df\/dy = [2*delta, 0, fdx]  x  [0, 2*delta, fdy]\n+                    \/\/                  = [0*fdy - fdx*2*delta, fdx*0 - 2*delta*fdy, 2*delta*2*delta - 0*0]\n+                    double nx = -fdx * 2 * delta;\n+                    double ny = -2 * delta * fdy;\n+                    double nz = 2 * delta * 2 * delta;\n+\n+                    \/\/ normalize\n+                    float dist = (float)Math.sqrt(nx * nx + ny * ny + nz * nz);\n+                    nx \/= dist;\n+                    ny \/= dist;\n+                    nz \/= dist;\n+\n+                    \/\/ Now transform [-1..1] -> [0..255]\n+                    int r = (int)(nx * 127f + 127f) & 0xff;\n+                    int g = (int)(ny * 127f + 127f) & 0xff;\n+                    int b = (int)(nz * 127f + 127f) & 0xff;\n+                    int c = (r << 16) + (g << 8) + b;\n+                    arr[nStart + xx] = c;\n+                }\n+            }\n+            return out;\n+        }\n+\n+        public void update() {\n+            long nowTime = System.nanoTime();\n+            float newFPS = 1e9f \/ (nowTime - lastTime);\n+            fps = 0.99f * fps + 0.01f * newFPS;\n+            lastTime = nowTime;\n+\n+            for (Light light : lights) {\n+                light.update();\n+            }\n+\n+            \/\/ Reset the buffer\n+            int[] outputArray = ((DataBufferInt) output.getRaster().getDataBuffer()).getData();\n+            Arrays.fill(outputArray, 0);\n+\n+            \/\/ Add in the contribution of each light\n+            for (Light l : lights) {\n+                computeLight(l);\n+            }\n+            computeLuminosityCorrection();\n+\n+            \/\/ Swap the buffers for double buffering.\n+            var outputTmp = output;\n+            output = output_2;\n+            output_2 = outputTmp;\n+\n+            var outputRGBTmp = outputRGB;\n+            outputRGB = outputRGB_2;\n+            outputRGB_2 = outputRGBTmp;\n+        }\n+\n+        public void computeLight(Light l) {\n+            for (int i = 0; i < outputRGB.length; i++) {\n+                float x = coordsX[i];\n+                float y = coordsY[i];\n+                float nx = normalsX[i];\n+                float ny = normalsY[i];\n+                float nz = normalsZ[i];\n+\n+                \/\/ Compute distance vector between the light and the pixel\n+                float dx = x - l.x;\n+                float dy = y - l.y;\n+                float dz = 0.2f; \/\/ how much the lights float above the scene\n+\n+                \/\/ Compute the distance (dot product of d with itself)\n+                float d2 = dx * dx + dy * dy + dz * dz;\n+                float d = (float)Math.sqrt(d2);\n+                float d3 = d * d2;\n+\n+                \/\/ Compute dot-product between distance and normal vector\n+                float dotProduct = nx * dx + ny * dy + nz * dz;\n+\n+                \/\/ If the dot-product is negative:\n+                \/\/   Light on wrong side -> 0\n+                \/\/ If the dot-product is positive:\n+                \/\/   There should be light normalize by distance (d), and divide by the\n+                \/\/   squared distance (d2) to have physically accurately decaying light.\n+                \/\/   Correct the luminosity so the RGB values are going to be close\n+                \/\/   to 255, but not over.\n+                float luminosity = Math.max(0, dotProduct \/ d3) * luminosityCorrection;\n+\n+                \/\/ Now we compute the color values that hopefully end up in the range\n+                \/\/ [0..255]. If the hack\/trick with luminosityCorrection fails, we may\n+                \/\/ occasionally go out of the range and generate an overflow in the masking.\n+                \/\/ This can lead to some funky visual artifacts around the lights, but it\n+                \/\/ is quite rare.\n+                \/\/\n+                \/\/ Feel free to play with the targetExposure below, and see if you can\n+                \/\/ observe the artefacts.\n+                int r = (int)(luminosity * l.r) & 0xff;\n+                int g = (int)(luminosity * l.g) & 0xff;\n+                int b = (int)(luminosity * l.b) & 0xff;\n+                int c = (r << 16) + (g << 8) + b;\n+                outputRGB[i] += c;\n+            }\n+        }\n+\n+        \/\/ This is a bit of a horrible hack, but it mostly works.\n+        \/\/ Essentially, it tries to solve the \"exposure\" problem:\n+        \/\/ It is hard to know how much light a pixel will receive at most, and\n+        \/\/ we have to convert this value to a byte [0..255] at some point.\n+        \/\/ If we chose the \"exposure\" too low, we get a very dark picture\n+        \/\/ that is not very exciting to look at. If we over-expose, then we\n+        \/\/ may overflow\/clip the range [0..255], leading to unpleasant visual\n+        \/\/ artifacts.\n+        public void computeLuminosityCorrection() {\n+            \/\/ Find maximum R, G, and B value.\n+            float maxR = 0;\n+            float maxG = 0;\n+            float maxB = 0;\n+            for (int i = 0; i < outputRGB.length; i++) {\n+                int c = outputRGB[i];\n+                int cr = (c >> 16) & 0xff;\n+                int cg = (c >>  8) & 0xff;\n+                int cb = (c >>  0) & 0xff;\n+\n+                maxR = Math.max(maxR, cr);\n+                maxG = Math.max(maxG, cg);\n+                maxB = Math.max(maxB, cb);\n+            }\n+\n+            float maxC = Math.max(Math.max(maxR, maxG), maxB);\n+\n+            \/\/ Correct the maximum value to be 230, so we are safely in range 0..255\n+            \/\/ Setting it instead to 255 will make the image brighter, but most likely\n+            \/\/ it will give you some funky artefacts.\n+            \/\/ Setting it to 100 will make the image darker.\n+            float targetExposure = 230f;\n+            luminosityCorrection *= targetExposure \/ maxC;\n+        }\n+    }\n+\n+    public static class MyDrawingPanel extends JPanel {\n+        private final State state;\n+\n+        public MyDrawingPanel(State state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        protected void paintComponent(Graphics g) {\n+            super.paintComponent(g);\n+            Graphics2D g2d = (Graphics2D) g;\n+\n+            \/\/ Draw color output\n+            g2d.drawImage(state.output_2, 0, 0, null);\n+\n+            \/\/ Draw position of lights\n+            for (Light l : state.lights) {\n+                g2d.setColor(new Color(l.r, l.g, l.b));\n+                g2d.fillRect((int)(1000f * l.x) - 3, (int)(1000f * l.y) - 3, 6, 6);\n+            }\n+\n+            g2d.setColor(new Color(0, 0, 0));\n+            g2d.fillRect(0, 0, 150, 35);\n+            g2d.setColor(new Color(255, 255, 255));\n+            g2d.setFont(new Font(\"Consolas\", Font.PLAIN, 30));\n+            g2d.drawString(\"FPS: \" + (int)Math.floor(state.fps), 0, 30);\n+\n+            g2d.drawImage(state.normals, 1000, 0, null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gallery\/NormalMapping.java","additions":554,"deletions":0,"binary":false,"changes":554,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=ir\n+ * @bug 8367657\n+ * @summary Visual example of auto vectorization: normal mapping.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.gallery.TestNormalMapping ir\n+ *\/\n+\n+\/*\n+ * @test id=visual\n+ * @key headful\n+ * @library \/test\/lib \/\n+ * @run main compiler.gallery.TestNormalMapping visual\n+ *\/\n+\n+package compiler.gallery;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * This test is the JTREG version for automatic verification of the stand-alone\n+ * {@link NormalMapping}. If you just want to run the demo and play with it,\n+ * go look at the documentation in {@link NormalMapping}.\n+ * Here, we launch both a visual version that just runs for a few seconds, to see\n+ * that there are no crashes, but we don't do any specific verification.\n+ * We also have an IR test, that ensures that we get vectorization.\n+ *\/\n+public class TestNormalMapping {\n+    public static void main(String[] args) throws InterruptedException {\n+        String mode = args[0];\n+        System.out.println(\"Running JTREG test in mode: \" + mode);\n+\n+        switch (mode) {\n+            case \"ir\" -> runIR();\n+            case \"visual\" -> runVisual();\n+            default -> throw new RuntimeException(\"Unknown mode: \" + mode);\n+        }\n+    }\n+\n+    private static void runIR() {\n+        System.out.println(\"Testing with IR rules...\");\n+        String src = System.getProperty(\"test.src\", null);\n+        if (src == null) { throw new RuntimeException(\"Could not find test.src property.\"); }\n+        TestFramework.runWithFlags(\"-Dtest.src=\" + src,\n+                                   \"-XX:CompileCommand=inline,compiler.gallery.NormalMapping$State::update\",\n+                                   \"-XX:CompileCommand=inline,compiler.gallery.NormalMapping$State::computeLight\");\n+    }\n+\n+    private static void runVisual() throws InterruptedException {\n+        System.out.println(\"Testing with 2d Graphics (visual)...\");\n+\n+        \/\/ We will not do anything special here, just launch the application,\n+        \/\/ tell it to run for 10 second, interrupt it and let it shut down.\n+        Thread thread = new Thread() {\n+            public void run() {\n+                NormalMapping.main(null);\n+            }\n+        };\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(10000)); \/\/ let demo run for 10 seconds\n+        thread.interrupt();\n+        Thread.sleep(Utils.adjustTimeout(1000)); \/\/ allow demo 1 second for shutdown\n+    }\n+\n+    \/\/ ---------------------- For the IR testing part only --------------------------------\n+    NormalMapping.State state = new NormalMapping.State(5);\n+\n+    @Test\n+    @Warmup(1000)\n+    @IR(counts = {IRNode.REPLICATE_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.REPLICATE_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_F,   IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.SUB_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.MUL_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.ADD_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.SQRT_VF,         IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.MAX_VF,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_F2I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.AND_VI,          IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.LSHIFT_VI,       IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private void testIR() {\n+        \/\/ This call should inline givne the CompileCommand above.\n+        state.update();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gallery\/TestNormalMapping.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"filename":"test\/hotspot\/jtreg\/compiler\/gallery\/normal_map.png","binary":true,"status":"added"},{"patch":"@@ -101,3 +101,3 @@\n-    AUTO_VECTORIZATION2_AFTER_REORDER(                   \"AutoVectorization 2, after Apply Memop Reordering\"),\n-    AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT(              \"AutoVectorization 3, after Adjusting Pre-loop Limit\"),\n-    AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS(\"AutoVectorization 4, after Adding Speculative Runtime Checks\"),\n+    AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT(              \"AutoVectorization 2, after Adjusting Pre-loop Limit\"),\n+    AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS(\"AutoVectorization 3, after Adding Speculative Runtime Checks\"),\n+    AUTO_VECTORIZATION5_AFTER_APPLY(                     \"AutoVectorization 4, after Apply\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-- `-DExcluceRandom=true`: The framework randomly excludes some methods from compilation. IR verification is disabled completely with this flag.\n+- `-DExcludeRandom=true`: The framework randomly excludes some methods from compilation. IR verification is disabled completely with this flag.\n@@ -191,1 +191,0 @@\n-- `-DExcludeRandom=true`: Randomly exclude some methods from compilation.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8364757\n+ * @summary Moving Store nodes from the main CountedLoop to the OuterStripMinedLoop causes\n+ *          subsequent Store nodes to be eventually removed because of missing Phi nodes,\n+ *          leading to wrong results.\n+ *\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation\n+ *      -Xcomp -XX:-UseLoopPredicate\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:-UseAutoVectorizationPredicate\n+ *      -XX:CompileCommand=compileonly,compiler.loopstripmining.MissingStoreAfterOuterStripMinedLoop::test*\n+ *      compiler.loopstripmining.MissingStoreAfterOuterStripMinedLoop\n+ * @run main compiler.loopstripmining.MissingStoreAfterOuterStripMinedLoop\n+ *\n+ *\/\n+\n+package compiler.loopstripmining;\n+\n+public class MissingStoreAfterOuterStripMinedLoop {\n+    public static int x = 0;\n+    public static int y = 0;\n+\n+    static class A {\n+        int field;\n+    }\n+\n+    \/\/ The store node in the loop body is moved to the OuterStripLoop.\n+    \/\/ When making the post loop the new store node\n+    \/\/ should have the moved store node as memory input, and not the\n+    \/\/ initial x = 0 store.\n+    \/\/\n+    \/\/ store (x = 0)\n+    \/\/  |\n+    \/\/ store (x += 1, exit of CountedLoop main)\n+    \/\/  | <-- additional rewiring due to absence of phi node\n+    \/\/ store (x += 1, exit of CountedLoop post)\n+    \/\/  |\n+    \/\/ store (x = 0)\n+    static public void test1() {\n+        x = 0;\n+        for (int i = 0; i < 20000; i++) {\n+            x += i;\n+        }\n+        x = 0;\n+    }\n+\n+    \/\/ Two independent stores\n+    \/\/ They should be wired independently in the post loop, no aliasing\n+    static public void test2() {\n+        x = 0;\n+        y = 0;\n+        for (int i = 0; i < 20000; i++) {\n+            x += i;\n+            y += i;\n+        }\n+        x = 0;\n+        y = 0;\n+    }\n+\n+    \/\/ Chain of stores with potential aliasing.\n+    \/\/ The entire chain is moved to the OuterStripLoop, between the\n+    \/\/ inner loop exit and the safepoint.\n+    \/\/ The chain should be preserved when cloning the main loop body\n+    \/\/ to create the post loop. Only the first store of the post loop\n+    \/\/ should be rewired to have the last store of the main loop\n+    \/\/ as memory input.\n+    \/\/\n+    \/\/ ...\n+    \/\/  |\n+    \/\/ store (a1.field = v, exit of CountedLoop main)\n+    \/\/  |\n+    \/\/ store (a2.field = v, exit of CountedLoop main)\n+    \/\/  |\n+    \/\/ store (a3.field = v, exit of CountedLoop main)\n+    \/\/  | <-- only additional rewiring needed\n+    \/\/ store (a1.field = v, exit of CountedLoop post)\n+    \/\/  |\n+    \/\/ store (a2.field = v, exit of CountedLoop post)\n+    \/\/  |\n+    \/\/ store (a3.field = v, exit of CountedLoop post)\n+    static public void test3(A a1, A a2, A a3) {\n+        a1.field = 0;\n+        a2.field = 0;\n+        a3.field = 0;\n+        int v = 0;\n+        for (int i = 0; i < 20000; i++) {\n+            v++;\n+            a1.field = v;\n+            a2.field = v;\n+            a3.field = v;\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        A a1 = new A();\n+        A a2 = new A();\n+        A a3 = new A();\n+\n+        test1();\n+        if (x != 0) {\n+            throw new RuntimeException(\"unexpected value: \" + x);\n+        }\n+\n+        test2();\n+        if (x != 0 || y != 0) {\n+            throw new RuntimeException(\"unexpected value: \" + x + \" \" + y);\n+        }\n+\n+        test3(a1, a2, a3);\n+        if (a1.field != 20000 || a2.field != 20000 || a3.field != 20000) {\n+            throw new RuntimeException(\"unexpected value: \" + a1.field + \" \" + a2.field + \" \" + a3.field);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/MissingStoreAfterOuterStripMinedLoop.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8362394\n+ * @summary Test that repeated stacked string concatenations do not\n+ *          consume too many compilation resources.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:-OptoScheduling compiler.stringopts.TestStackedConcatsMany\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp -XX:-OptoScheduling\n+ *                   -XX:CompileOnly=compiler.stringopts.TestStackedConcatsMany::f\n+ *                   compiler.stringopts.TestStackedConcatsMany\n+ *\/\n+\n+\/\/ The test uses -XX:-OptoScheduling to avoid the assert \"too many D-U pinch points\" on aarch64 (JDK-8328078).\n+\n+package compiler.stringopts;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestStackedConcatsMany {\n+\n+    public static void main (String... args) {\n+        new StringBuilder(); \/\/ Trigger loading of the StringBuilder class.\n+        String s = f();\n+        String z = \"xy\";\n+        for (int i = 0; i < 24; i++) {\n+            z = z + z;\n+        }\n+        Asserts.assertEQ(s, z);\n+    }\n+\n+    static String f() {\n+        String s = \"xy\";\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s).toString();\n+\n+        return s;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/stringopts\/TestStackedConcatsMany.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -224,2 +224,15 @@\n-        if (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n-            throw new RuntimeException(method + \" must not be in queue\");\n+        checkNotCompiled(method, isOsr);\n+    }\n+\n+    \/**\n+     * Checks, that the specified executable is not (OSR-)compiled.\n+     *\n+     * @param executable The method or constructor to check.\n+     * @param isOsr Check for OSR compilation if true\n+     * @throws RuntimeException if {@linkplain #method} is in compiler queue or\n+     *                          is compiled, or if {@linkplain #method} has zero\n+     *                          compilation level.\n+     *\/\n+    protected static final void checkNotCompiled(Executable executable, boolean isOsr) {\n+        if (WHITE_BOX.isMethodQueuedForCompilation(executable)) {\n+            throw new RuntimeException(executable + \" must not be in queue\");\n@@ -227,2 +240,2 @@\n-        if (WHITE_BOX.isMethodCompiled(method, isOsr)) {\n-            throw new RuntimeException(method + \" must not be \" +\n+        if (WHITE_BOX.isMethodCompiled(executable, isOsr)) {\n+            throw new RuntimeException(executable + \" must not be \" +\n@@ -231,2 +244,2 @@\n-        if (WHITE_BOX.getMethodCompilationLevel(method, isOsr) != 0) {\n-            throw new RuntimeException(method + (isOsr ? \" osr_\" : \" \") +\n+        if (WHITE_BOX.getMethodCompilationLevel(executable, isOsr) != 0) {\n+            throw new RuntimeException(executable + (isOsr ? \" osr_\" : \" \") +\n@@ -245,0 +258,13 @@\n+        checkCompiled(method, testCase.isOsr());\n+    }\n+\n+    \/**\n+     * Checks, that the specified executable is compiled.\n+     *\n+     * @param executable The method or constructor to check.\n+     * @param isOsr Check for OSR compilation if true\n+     * @throws RuntimeException if {@linkplain #method} isn't in compiler queue\n+     *                          and isn't compiled, or if {@linkplain #method}\n+     *                          has nonzero compilation level\n+     *\/\n+    protected static final void checkCompiled(Executable executable, boolean isOsr) {\n@@ -246,2 +272,2 @@\n-        waitBackgroundCompilation();\n-        if (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n+        waitBackgroundCompilation(executable);\n+        if (WHITE_BOX.isMethodQueuedForCompilation(executable)) {\n@@ -249,1 +275,1 @@\n-                    method, System.currentTimeMillis() - start);\n+                    executable, System.currentTimeMillis() - start);\n@@ -252,3 +278,3 @@\n-        if (!WHITE_BOX.isMethodCompiled(method, testCase.isOsr())) {\n-            throw new RuntimeException(method + \" must be \"\n-                    + (testCase.isOsr() ? \"osr_\" : \"\") + \"compiled\");\n+        if (!WHITE_BOX.isMethodCompiled(executable, isOsr)) {\n+            throw new RuntimeException(executable + \" must be \"\n+                    + (isOsr ? \"osr_\" : \"\") + \"compiled\");\n@@ -256,1 +282,1 @@\n-        if (WHITE_BOX.getMethodCompilationLevel(method, testCase.isOsr())\n+        if (WHITE_BOX.getMethodCompilationLevel(executable, isOsr)\n@@ -258,2 +284,2 @@\n-            throw new RuntimeException(method\n-                    + (testCase.isOsr() ? \" osr_\" : \" \")\n+            throw new RuntimeException(executable\n+                    + (isOsr ? \" osr_\" : \" \")\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/CompilerWhiteBoxTest.java","additions":41,"deletions":15,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Serial\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseSerialGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Parallel\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseParallelGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.G1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseG1GC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseShenandoahGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Z\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseZGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+public class DeoptimizeRelocatedNMethod {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    public static double FUNCTION_RESULT = 0;\n+\n+    public static void main(String [] args) throws Exception {\n+        \/\/ Get method that will be relocated\n+        Method method = DeoptimizeRelocatedNMethod.class.getMethod(\"function\");\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        \/\/ Verify not initially compiled\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call function enough to compile\n+        callFunction();\n+\n+        \/\/ Verify now compiled\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get newly created nmethod\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        \/\/ Relocate nmethod and mark old for cleanup\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodProfiled.id);\n+\n+        \/\/ Trigger GC to clean up old nmethod\n+        WHITE_BOX.fullGC();\n+\n+        \/\/ Verify function still compiled after old was cleaned up\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get new nmethod and verify it's actually new\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+\n+        \/\/ Call to verify everything still works\n+        function();\n+\n+        \/\/ Deoptimized method\n+        WHITE_BOX.deoptimizeMethod(method);\n+\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call to verify everything still works\n+        function();\n+    }\n+\n+    \/\/ Call function multiple times to trigger compilation\n+    private static void callFunction() {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            function();\n+        }\n+    }\n+\n+    public static void function() {\n+        FUNCTION_RESULT = Math.random();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeRelocatedNMethod.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Serial\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseSerialGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Parallel\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseParallelGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.G1\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Z\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseZGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+public class RelocateNMethod extends CompilerWhiteBoxTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        CompilerWhiteBoxTest.main(RelocateNMethod::new, new String[] {\"CONSTRUCTOR_TEST\", \"METHOD_TEST\", \"STATIC_TEST\"});\n+    }\n+\n+    private RelocateNMethod(TestCase testCase) {\n+        super(testCase);\n+        \/\/ to prevent inlining of #method\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+    }\n+\n+    @Override\n+    protected void test() throws Exception {\n+        checkNotCompiled();\n+\n+        compile();\n+\n+        checkCompiled();\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodProfiled.id);\n+\n+        WHITE_BOX.fullGC();\n+\n+        checkCompiled();\n+\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethod.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=SerialC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Serial\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseSerialGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=SerialC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Serial\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseSerialGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ParallelC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Parallel\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseParallelGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ParallelC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Parallel\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseParallelGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=G1C1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.G1\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=G1C2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.G1\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ShenandoahC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Shenandoah\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ShenandoahC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Shenandoah\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ZGCC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Z\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseZGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ZGCC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Z\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseZGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+public class RelocateNMethodMultiplePaths {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    private static final int PATH_ONE_RESULT = 1;\n+    private static final int PATH_TWO_RESULT = 2;\n+\n+    public static void main(String [] args) throws Exception {\n+        \/\/ Get method that will be relocated\n+        Method method = RelocateNMethodMultiplePaths.class.getMethod(\"function\", boolean.class);\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        \/\/ Verify not initially compiled\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call function enough to compile\n+        callFunction(true);\n+\n+        \/\/ Verify now compiled\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get newly created nmethod\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        \/\/ Relocate nmethod and mark old for cleanup\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodNonProfiled.id);\n+\n+        \/\/ Trigger GC to clean up old nmethod\n+        WHITE_BOX.fullGC();\n+\n+        \/\/ Verify function still compiled after old was cleaned up\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get new nmethod and verify it's actually new\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+\n+        \/\/ Verify function still produces correct result\n+        if (function(true) != PATH_ONE_RESULT) {\n+            throw new RuntimeException(\"Relocated function produced incorrect result in path one\");\n+        }\n+\n+        \/\/ Call function again with different path and verify result\n+        if (function(false) != PATH_TWO_RESULT) {\n+            throw new RuntimeException(\"Relocated function produced incorrect result in path two\");\n+        }\n+\n+        \/\/ Verify function can be correctly deoptimized\n+        WHITE_BOX.deoptimizeMethod(method);\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+    }\n+\n+    \/\/ Call function multiple times to trigger compilation\n+    private static void callFunction(boolean pathOne) {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            function(pathOne);\n+        }\n+    }\n+\n+    public static int function(boolean pathOne) {\n+        if (pathOne) {\n+            return PATH_ONE_RESULT;\n+        } else {\n+            return PATH_TWO_RESULT;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethodMultiplePaths.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test StressNMethodRelocation\n+ * @summary Call and relocate methods concurrently\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+SegmentedCodeCache -XX:+UnlockExperimentalVMOptions\n+ *                   -XX:+NMethodRelocation compiler.whitebox.StressNMethodRelocation\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.CodeBlob;\n+import jdk.test.whitebox.code.NMethod;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.Random;\n+\n+public class StressNMethodRelocation {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final int C2_LEVEL = 4;\n+    private static final int ACTIVE_METHODS = 1024;\n+\n+    private static TestMethod[] methods;\n+    private static byte[] num1;\n+    private static byte[] num2;\n+\n+    private static long DURATION = 60_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Initialize defaults\n+        initNums();\n+\n+        \/\/ Generate compiled code\n+        methods = new TestMethod[ACTIVE_METHODS];\n+        generateCode(methods);\n+\n+        \/\/ Create thread that runs compiled methods\n+        RunMethods runMethods = new RunMethods();\n+        Thread runMethodsThread = new Thread(runMethods);\n+\n+        \/\/ Create thread that relocates compiled methods\n+        RelocateNMethods relocate = new RelocateNMethods();\n+        Thread relocateThread = new Thread(relocate);\n+\n+        \/\/ Start theads\n+        runMethodsThread.start();\n+        relocateThread.start();\n+\n+        \/\/ Wait for threads to finish\n+        runMethodsThread.join();\n+        relocateThread.join();\n+    }\n+\n+    private static byte[] genNum(Random random, int digitCount) {\n+        byte[] num = new byte[digitCount];\n+        int d;\n+        do {\n+            d = random.nextInt(10);\n+        } while (d == 0);\n+\n+        num[0] = (byte)d;\n+        for (int i = 1; i < digitCount; ++i) {\n+            num[i] = (byte)random.nextInt(10);\n+        }\n+        return num;\n+    }\n+\n+    private static void initNums() {\n+        final long seed = 8374592837465123L;\n+        Random random = new Random(seed);\n+\n+        final int digitCount = 40;\n+        num1 = genNum(random, digitCount);\n+        num2 = genNum(random, digitCount);\n+    }\n+\n+    private static void generateCode(TestMethod[] m) throws Exception {\n+        byte[] result = new byte[num1.length + 1];\n+\n+        for (int i = 0; i < ACTIVE_METHODS; ++i) {\n+            m[i] = new TestMethod();\n+            m[i].profile(num1, num2, result);\n+            m[i].compileWithC2();\n+        }\n+    }\n+\n+    private static final class TestMethod {\n+        private static final String CLASS_NAME = \"A\";\n+        private static final String METHOD_TO_COMPILE = \"sum\";\n+        private static final String JAVA_CODE = \"\"\"\n+        public class A {\n+\n+            public static void sum(byte[] n1, byte[] n2, byte[] out) {\n+                final int digitCount = n1.length;\n+                int carry = 0;\n+                for (int i = digitCount - 1; i >= 0; --i) {\n+                    int sum = n1[i] + n2[i] + carry;\n+                    out[i] = (byte)(sum % 10);\n+                    carry = sum \/ 10;\n+                }\n+                if (carry != 0) {\n+                    for (int i = digitCount; i > 0; --i) {\n+                        out[i] = out[i - 1];\n+                    }\n+                    out[0] = (byte)carry;\n+                }\n+            }\n+        }\"\"\";\n+\n+        private static final byte[] BYTE_CODE;\n+\n+        static {\n+            BYTE_CODE = InMemoryJavaCompiler.compile(CLASS_NAME, JAVA_CODE);\n+        }\n+\n+        private final Method method;\n+\n+        private static ClassLoader createClassLoaderFor() {\n+            return new ClassLoader() {\n+                @Override\n+                public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                    if (!name.equals(CLASS_NAME)) {\n+                        return super.loadClass(name);\n+                    }\n+\n+                    return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+                }\n+            };\n+        }\n+\n+        public TestMethod() throws Exception {\n+            var cl = createClassLoaderFor().loadClass(CLASS_NAME);\n+            method = cl.getMethod(METHOD_TO_COMPILE, byte[].class, byte[].class, byte[].class);\n+            WHITE_BOX.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+            WHITE_BOX.markMethodProfiled(method);\n+        }\n+\n+        public void invoke(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+        }\n+\n+        public void compileWithC2() throws Exception {\n+            WHITE_BOX.enqueueMethodForCompilation(method, C2_LEVEL);\n+            while (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WHITE_BOX.getMethodCompilationLevel(method) != C2_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled by C2.\");\n+            }\n+        }\n+    }\n+\n+    private static final class RelocateNMethods implements Runnable {\n+        public RelocateNMethods() {}\n+\n+        \/\/ Move nmethod back and forth between NonProfiled and Profiled code heaps\n+        public void run() {\n+            long startTime = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - startTime < DURATION) {\n+                \/\/ Relocate NonProfiled to Profiled\n+                CodeBlob[] nonProfiledBlobs = CodeBlob.getCodeBlobs(BlobType.MethodNonProfiled);\n+                for (CodeBlob blob : nonProfiledBlobs) {\n+                    if (blob.isNMethod) {\n+                        WHITE_BOX.relocateNMethodFromAddr(blob.address, BlobType.MethodProfiled.id);\n+                    }\n+                }\n+\n+                \/\/ Relocate Profiled to NonProfiled\n+                CodeBlob[] profiledBlobs = CodeBlob.getCodeBlobs(BlobType.MethodProfiled);\n+                for (CodeBlob blob : nonProfiledBlobs) {\n+                    if (blob.isNMethod) {\n+                        WHITE_BOX.relocateNMethodFromAddr(blob.address, BlobType.MethodNonProfiled.id);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final class RunMethods implements Runnable {\n+        public RunMethods() {}\n+\n+        public void run() {\n+            try {\n+                long startTime = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - startTime < DURATION) {\n+                    callMethods();\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e.getMessage());\n+            }\n+        }\n+\n+        private void callMethods() throws Exception {\n+            for (var m : methods) {\n+                byte[] result = new byte[num1.length + 1];\n+                m.invoke(num1, num2, result);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/StressNMethodRelocation.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires !vm.opt.final.UseLargePages\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestShrinkAuxiliaryDataRunner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test TestReclaimStringsLeaksMemory\n+ * @test id=Serial\n@@ -29,2 +29,2 @@\n- * @summary Ensure that during a Full GC interned string memory is reclaimed completely.\n- * @requires vm.gc == \"null\"\n+ * @summary Ensure that during a Full GC interned string memory is reclaimed completely with SerialGC.\n+ * @requires vm.gc.Serial\n@@ -34,1 +34,0 @@\n- * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory\n@@ -36,0 +35,10 @@\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8180048\n+ * @summary Ensure that during a Full GC interned string memory is reclaimed completely with ParallelGC.\n+ * @requires vm.gc.Parallel\n+ * @requires !vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n@@ -37,0 +46,10 @@\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8180048\n+ * @summary Ensure that during a Full GC interned string memory is reclaimed completely with G1GC.\n+ * @requires vm.gc.G1\n+ * @requires !vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n@@ -40,0 +59,22 @@\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8180048\n+ * @summary Ensure that during a Full GC interned string memory is reclaimed completely with ShenandoahGC.\n+ * @requires vm.gc.Shenandoah\n+ * @requires !vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseShenandoahGC\n+ *\/\n+\n+\/*\n+ * @test id=Z\n+ * @bug 8180048\n+ * @summary Ensure that during a Full GC interned string memory is reclaimed completely with ZGC.\n+ * @requires vm.gc.Z\n+ * @requires !vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseZGC\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestReclaimStringsLeaksMemory.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n@@ -35,0 +35,1 @@\n+ *          test-classes\/CustomLoadee5.java test-classes\/CustomLoadee5Child.java\n@@ -52,1 +53,5 @@\n-        String appJar1 = JarBuilder.build(\"UnloadUnregisteredLoader_app1\", \"UnloadUnregisteredLoader\");\n+        String appJar1 = JarBuilder.build(\"UnloadUnregisteredLoader_app1\",\n+                                          \"UnloadUnregisteredLoader\",\n+                                          \"UnloadUnregisteredLoader$CustomLoader\",\n+                                          \"CustomLoadee5\",\n+                                          \"Util\");\n@@ -57,1 +62,4 @@\n-        String customJarPath = JarBuilder.build(\"UnloadUnregisteredLoader_custom\", \"CustomLoadee\");\n+        String customJarPath = JarBuilder.build(\"UnloadUnregisteredLoader_custom\",\n+                                                \"CustomLoadee\",\n+                                                \"CustomLoadee5\",\n+                                                \"CustomLoadee5Child\");\n@@ -69,0 +77,2 @@\n+            \"CustomLoadee5 id: 3 super: 1 source: \" + customJarPath,\n+            \"CustomLoadee5Child id: 4 super: 3 source: \" + customJarPath,\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/UnloadUnregisteredLoaderTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-class CustomLoadee5 {\n+public class CustomLoadee5 {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.InputStream;\n@@ -49,1 +50,1 @@\n-  public static void doit(URL urls[], String className, boolean isFirstTime) throws Exception {\n+    public static void doit(URL urls[], String className, boolean isFirstTime) throws Exception {\n@@ -51,1 +52,3 @@\n-        URLClassLoader custLoader = new URLClassLoader(urls, appLoader);\n+        CustomLoader custLoader = new CustomLoader(urls, appLoader);\n+\n+        \/\/ Part 1 -- load CustomLoadee. It should be loaded from archive when isFirstTime==true\n@@ -71,0 +74,38 @@\n+\n+        \/\/ Part 2\n+        \/\/\n+        \/\/ CustomLoadee5 is never loaded from the archive, because the classfile bytes don't match\n+        \/\/ CustomLoadee5Child is never loaded from the archive, its super is not loaded from the archive\n+        try (InputStream in = appLoader.getResourceAsStream(\"CustomLoadee5.class\")) {\n+            byte[] b = in.readAllBytes();\n+            Util.replace(b, \"this is\", \"DAS IST\"); \/\/ Modify the bytecodes\n+            Class<?> c = custLoader.myDefineClass(b, 0, b.length);\n+            System.out.println(c.newInstance());\n+            if (!\"DAS IST CustomLoadee5\".equals(c.newInstance().toString())) {\n+                throw new RuntimeException(\"Bytecode modification not successful\");\n+            }\n+            if (wb.isSharedClass(c)) {\n+                throw new RuntimeException(c + \"should not be loaded from CDS\");\n+            }\n+        }\n+\n+        \/\/ When isFirstTime==true, the VM will try to load the archived copy of CustomLoadee5Child,\n+        \/\/ but it will fail (because CustomLoadee5 was not loaded from the archive) and will recover\n+        \/\/ by decoding the class from its classfile data.\n+        \/\/ This failure should not leave the JVM in an inconsistent state.\n+        Class<?> child = custLoader.loadClass(\"CustomLoadee5Child\");\n+        if (wb.isSharedClass(child)) {\n+            throw new RuntimeException(child + \"should not be loaded from CDS\");\n+        }\n+    }\n+\n+    static class CustomLoader extends URLClassLoader {\n+        public CustomLoader(URL[] urls, ClassLoader parent) {\n+            super(urls, parent);\n+        }\n+\n+        public Class<?> myDefineClass(byte[] b, int off, int len)\n+            throws ClassFormatError\n+        {\n+            return super.defineClass(b, off, len);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/UnloadUnregisteredLoader.java","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 8316694\n+ * @summary Verify that nmethod relocation posts the correct JVMTI events\n+ * @requires vm.jvmti\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/native NMethodRelocationTest\n+ *\/\n+\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+\n+import java.lang.reflect.Executable;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+\n+public class NMethodRelocationTest {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-agentlib:NMethodRelocationTest\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"-Xbootclasspath\/a:.\",\n+                \"-XX:+UseSerialGC\",\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+WhiteBoxAPI\",\n+                \"-XX:+SegmentedCodeCache\",\n+                \"-XX:-TieredCompilation\",\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:+NMethodRelocation\",\n+                \"DoWork\");\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        String output = oa.getOutput();\n+        if (oa.getExitValue() != 0) {\n+            System.err.println(oa.getOutput());\n+            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n+        }\n+        Asserts.assertTrue(oa.getExitValue() == 0);\n+\n+        Pattern pattern = Pattern.compile(\"(?m)^Relocated nmethod from (0x[0-9a-f]{16}) to (0x[0-9a-f]{16})$\");\n+        Matcher matcher = pattern.matcher(output);\n+\n+        if (matcher.find()) {\n+            String fromAddr = matcher.group(1);\n+            String toAddr = matcher.group(2);\n+\n+            \/\/ Confirm events sent for both original and relocated nmethod\n+            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + fromAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + toAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + fromAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + toAddr);\n+        } else {\n+            System.err.println(oa.getOutput());\n+            throw new RuntimeException(\"Unable to find relocation information\");\n+        }\n+    }\n+}\n+\n+class DoWork {\n+\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/** Load native library if required. *\/\n+    static {\n+        try {\n+            System.loadLibrary(\"NMethodRelocationTest\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load NMethodRelocationTest library\");\n+            System.err.println(\"java.library.path: \"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    \/**\n+     * Returns value of VM option.\n+     *\n+     * @param name option's name\n+     * @return value of option or {@code null}, if option doesn't exist\n+     * @throws NullPointerException if name is null\n+     *\/\n+    protected static String getVMOption(String name) {\n+        Objects.requireNonNull(name);\n+        return Objects.toString(WHITE_BOX.getVMFlag(name), null);\n+    }\n+\n+    \/**\n+     * Returns value of VM option or default value.\n+     *\n+     * @param name         option's name\n+     * @param defaultValue default value\n+     * @return value of option or {@code defaultValue}, if option doesn't exist\n+     * @throws NullPointerException if name is null\n+     * @see #getVMOption(String)\n+     *\/\n+    protected static String getVMOption(String name, String defaultValue) {\n+        String result = getVMOption(name);\n+        return result == null ? defaultValue : result;\n+    }\n+\n+    public static void main(String argv[]) throws Exception {\n+        run();\n+    }\n+\n+    public static void run() throws Exception {\n+        Executable method = DoWork.class.getDeclaredMethod(\"compiledMethod\");\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        WHITE_BOX.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        while (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n+            Thread.onSpinWait();\n+        }\n+\n+        NMethod originalNMethod = NMethod.get(method, false);\n+        if (originalNMethod == null) {\n+            throw new AssertionError(\"Could not find original nmethod\");\n+        }\n+\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodNonProfiled.id);\n+\n+        NMethod relocatedNMethod = NMethod.get(method, false);\n+        if (relocatedNMethod == null) {\n+            throw new AssertionError(\"Could not find relocated nmethod\");\n+        }\n+\n+        if (originalNMethod.address == relocatedNMethod.address) {\n+            throw new AssertionError(\"Relocated nmethod same as original\");\n+        }\n+\n+        WHITE_BOX.deoptimizeAll();\n+\n+        WHITE_BOX.fullGC();\n+        WHITE_BOX.fullGC();\n+\n+        WHITE_BOX.lockCompilation();\n+\n+        System.out.printf(\"Relocated nmethod from 0x%016x to 0x%016x%n\", originalNMethod.code_begin, relocatedNMethod.code_begin);\n+        System.out.flush();\n+    }\n+\n+    public static long compiledMethod() {\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <inttypes.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+\/**\n+ * Callback for COMPILED_METHOD_LOAD event.\n+ *\/\n+JNIEXPORT void JNICALL\n+callbackCompiledMethodLoad(jvmtiEnv* jvmti, jmethodID method,\n+                            jint code_size, const void* code_addr,\n+                            jint map_length, const jvmtiAddrLocationMap* map,\n+                            const void* compile_info) {\n+    char* name = nullptr;\n+    char* sig = nullptr;\n+\n+    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n+        printf(\"    [Could not retrieve method name]\\n\");\n+        fflush(stdout);\n+        return;\n+    }\n+\n+    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n+        name, (uintptr_t)code_addr);\n+    fflush(stdout);\n+}\n+\n+\/**\n+ * Callback for COMPILED_METHOD_UNLOAD event.\n+ *\/\n+JNIEXPORT void JNICALL\n+callbackCompiledMethodUnload(jvmtiEnv* jvmti, jmethodID method,\n+                             const void* code_addr) {\n+    char* name = nullptr;\n+    char* sig = nullptr;\n+\n+    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n+        printf(\"    [Could not retrieve method name]\\n\");\n+        fflush(stdout);\n+        return;\n+    }\n+    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n+        name, (uintptr_t)code_addr);\n+    fflush(stdout);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti = nullptr;\n+    jvmtiError error;\n+\n+    if (jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_0) != JNI_OK) {\n+        printf(\"Unable to access JVMTI!\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    \/\/ Add required capabilities\n+    jvmtiCapabilities caps;\n+    memset(&caps, 0, sizeof(caps));\n+    caps.can_generate_compiled_method_load_events = 1;\n+    error = jvmti->AddCapabilities(&caps);\n+    if (error != JVMTI_ERROR_NONE) {\n+        printf(\"ERROR: Unable to add capabilities, error=%d\\n\", error);\n+        return JNI_ERR;\n+    }\n+\n+    \/\/ Set event callbacks\n+    jvmtiEventCallbacks eventCallbacks;\n+    memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+    eventCallbacks.CompiledMethodLoad = callbackCompiledMethodLoad;\n+    eventCallbacks.CompiledMethodUnload = callbackCompiledMethodUnload;\n+    error = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+    if (error != JVMTI_ERROR_NONE) {\n+        printf(\"ERROR: Unable to set event callbacks, error=%d\\n\", error);\n+        return JNI_ERR;\n+    }\n+\n+    \/\/ Enable events\n+    error = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr);\n+    if (error != JVMTI_ERROR_NONE) {\n+        printf(\"ERROR: Unable to enable COMPILED_METHOD_LOAD event, error=%d\\n\", error);\n+        return JNI_ERR;\n+    }\n+\n+    error = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, nullptr);\n+    if (error != JVMTI_ERROR_NONE) {\n+        printf(\"ERROR: Unable to enable COMPILED_METHOD_UNLOAD event, error=%d\\n\", error);\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/libNMethodRelocationTest.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires vm.gc != \"Serial\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListLow\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires vm.gc != \"Serial\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/LinearListLow\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -313,0 +313,4 @@\n+        } finally {\n+            \/\/ Finished testing; release memory to avoid OOM.\n+            runnables.clear();\n+            threads.clear();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/runner\/ThreadsRunner.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-                NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, nullptr));\n+                NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thread));\n@@ -119,1 +119,1 @@\n-    NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr));\n+    NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, thread));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/stepBreakPopReturn\/stepBreakPopReturn.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n@@ -65,0 +66,6 @@\n+    private static final MethodType MT_calledFromNative = MethodType.methodType(\n+            Object.class,\n+            Object.class, Object.class, int.class, long.class, double.class, float.class);\n+\n+    private static MethodHandle mh;\n+\n@@ -67,0 +74,8 @@\n+        try {\n+            mh = MethodHandles.lookup().findStatic(\n+                Test.class,\n+                \"calledFromNative\",\n+                MT_calledFromNative);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"TEST FAILED - Unable to lookup \\\"calledFromNative\\\"\");\n+        }\n@@ -71,4 +86,0 @@\n-    private static final MethodType MT_calledFromNative = MethodType.methodType(\n-            Object.class,\n-            Object.class, Object.class, int.class, long.class, double.class, float.class);\n-\n@@ -81,4 +92,0 @@\n-        MethodHandle mh = MethodHandles.lookup().findStatic(\n-                Test.class,\n-                \"calledFromNative\",\n-                MT_calledFromNative);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/jni\/nativeAndMH\/Test.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -52,0 +54,3 @@\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import jdk.test.lib.net.URIBuilder;\n@@ -59,1 +64,0 @@\n-import jdk.test.lib.net.SimpleHttpServer;\n@@ -65,1 +69,0 @@\n- * @build jdk.test.lib.net.SimpleHttpServer\n@@ -84,2 +87,1 @@\n-    static final String TESTCONTEXT = REMOTE_FILE_LOCATION;  \/\/mapped to local file path\n-    private SimpleHttpServer httpserver;\n+    private HttpServer httpserver;\n@@ -87,0 +89,1 @@\n+    private ExecutorService executor;\n@@ -95,1 +98,4 @@\n-        httpserver = new SimpleHttpServer(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), TESTCONTEXT, DOCROOT);\n+        httpserver = SimpleFileServer.createFileServer(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0),\n+                Path.of(DOCROOT), SimpleFileServer.OutputLevel.INFO);\n+        executor = Executors.newCachedThreadPool();\n+        httpserver.setExecutor(executor);\n@@ -97,1 +103,5 @@\n-        remoteFilePath = httpserver.getAddress() + REMOTE_FILE_LOCATION;\n+        remoteFilePath = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .host(httpserver.getAddress().getAddress())\n+                .port(httpserver.getAddress().getPort())\n+                .build().toString() + REMOTE_FILE_LOCATION;\n@@ -103,1 +113,2 @@\n-            httpserver.stop();\n+            httpserver.stop(0);\n+            executor.shutdown();\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/CatalogFileInputTest.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -191,1 +191,0 @@\n-java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8298823 macosx-all\n@@ -252,0 +251,1 @@\n+sun\/java2d\/OpenGL\/OpaqueDest.java#id1 8367574 macosx-all\n@@ -556,2 +556,0 @@\n-com\/sun\/management\/OperatingSystemMXBean\/GetProcessCpuLoad.java 8030957 aix-all\n-com\/sun\/management\/OperatingSystemMXBean\/GetSystemCpuLoad.java  8030957 aix-all\n@@ -571,1 +569,0 @@\n-javax\/management\/MBeanServer\/OldMBeanServerTest.java            8030957 aix-all\n@@ -620,1 +617,0 @@\n-java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java       8365398 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8153029 8360463\n+ * @bug 8153029 8360463 8368984\n@@ -75,2 +75,1 @@\n-        checkTransformation(\"ChaCha20-Poly1305\", null);\n-        checkTransformation(\"ChaCha20-Poly1305\/None\/NoPadding\", null);\n+        checkTransformation(\"ChaCha20\/None\/\/\", NSAE);\n@@ -79,0 +78,3 @@\n+        checkTransformation(\"ChaCha20-Poly1305\", null);\n+        checkTransformation(\"ChaCha20-Poly1305\/None\/NoPadding\", null);\n+        checkTransformation(\"ChaCha20-Poly1305\/None\/\/\", NSAE);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/unittest\/ChaCha20CipherUnitTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8014618\n+ * @bug 8014618 8368694\n@@ -91,0 +91,20 @@\n+        \/\/ generate generic shared secret\n+        aliceKeyAgree.init(alicePrivKey);\n+        aliceKeyAgree.doPhase(bobPubKey, true);\n+        byte[] genericSecret =\n+            aliceKeyAgree.generateSecret(\"Generic\").getEncoded();\n+        System.out.println(\"generic secret:\\n\" + HEX_FORMATTER.formatHex(genericSecret));\n+\n+        \/\/ verify that leading zero is present\n+        if (genericSecret.length != 256) {\n+            throw new Exception(\"Unexpected generic secret length\");\n+        }\n+        if (genericSecret[0] != 0) {\n+            throw new Exception(\"First byte is not zero as expected\");\n+        }\n+        for (int i = 0; i < genericSecret.length; i++) {\n+            if (genericSecret[i] != sharedSecret[i]) {\n+                throw new Exception(\"Shared secrets differ\");\n+            }\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/TestLeadingZeroes.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run driver SimulResumerTest\n+ * @run driver\/timeout=180 SimulResumerTest\n","filename":"test\/jdk\/com\/sun\/jdi\/SimulResumerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.concurrent.*;\n-import java.util.logging.*;\n-import java.io.*;\n-import java.net.*;\n-\n-import com.sun.net.httpserver.*;\n-\n-\/**\n- * Implements a basic static content HTTP server\n- * which understands text\/html, text\/plain content types\n- *\n- * Must be given an abs pathname to the document root.\n- * Directory listings together with text + html files\n- * can be served.\n- *\n- * File Server created on files sub-path\n- *\n- * Echo server created on echo sub-path\n- *\/\n-public class SimpleFileServer {\n-\n-    public static void main (String[] args) throws Exception {\n-        if (args.length != 3) {\n-            System.out.println (\"usage: java FileServerHandler rootDir port logfilename\");\n-            System.exit(1);\n-        }\n-        Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n-        ConsoleHandler ch = new ConsoleHandler();\n-        logger.setLevel(Level.ALL);\n-        ch.setLevel(Level.ALL);\n-        logger.addHandler(ch);\n-\n-        String rootDir = args[0];\n-        int port = Integer.parseInt (args[1]);\n-        String logfile = args[2];\n-        HttpServer server = HttpServer.create (new InetSocketAddress (port), 0);\n-        HttpHandler h = new FileServerHandler (rootDir);\n-        HttpHandler h1 = new EchoHandler ();\n-\n-        HttpContext c = server.createContext (\"\/files\", h);\n-        c.getFilters().add (new LogFilter (new File (logfile)));\n-        HttpContext c1 = server.createContext (\"\/echo\", h1);\n-        c.getFilters().add (new LogFilter (new File (logfile)));\n-        c1.getFilters().add (new LogFilter (new File (logfile)));\n-        server.setExecutor (Executors.newCachedThreadPool());\n-        server.start ();\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/SimpleFileServer.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    private static final int PIXEL_OFFSET = 4;\n@@ -77,2 +78,2 @@\n-        for (int x = 0; x < bi.getWidth(); x++) {\n-            for (int y = 0; y < bi.getHeight(); y++) {\n+        for (int x = PIXEL_OFFSET; x < bi.getWidth() - PIXEL_OFFSET; x++) {\n+            for (int y = PIXEL_OFFSET; y < bi.getHeight() - PIXEL_OFFSET; y++) {\n","filename":"test\/jdk\/java\/awt\/Frame\/DisposeTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,5 +29,2 @@\n- *     Mouse Entered\/Exited events are wrongly generated during dragging the window\n- *     from one component to another\n- * @library ..\/..\/regtesthelpers\n- * @build Util\n- * @author alexandr.scherbatiy area=awt.event\n+ *     Mouse Entered\/Exited events are wrongly generated during dragging the\n+ *     window from one component to another\n@@ -53,4 +50,0 @@\n-import java.util.concurrent.Callable;\n-\n-import test.java.awt.regtesthelpers.Util;\n-\n@@ -58,1 +51,0 @@\n-\n@@ -60,1 +52,0 @@\n-    private static volatile int dragWindowMouseReleasedCount = 0;\n@@ -63,0 +54,4 @@\n+\n+    private static volatile Point pointToClick;\n+    private static volatile Point pointToDrag;\n+\n@@ -66,0 +61,1 @@\n+    private static JFrame frame;\n@@ -68,0 +64,3 @@\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n@@ -69,4 +68,1 @@\n-        Robot robot = new Robot();\n-        robot.setAutoDelay(100);\n-\n-        SwingUtilities.invokeAndWait(new Runnable() {\n+            SwingUtilities.invokeAndWait(DragWindowTest::createAndShowGUI);\n@@ -74,5 +70,2 @@\n-            @Override\n-            public void run() {\n-                createAndShowGUI();\n-            }\n-        });\n+            robot.delay(250);\n+            robot.waitForIdle();\n@@ -80,2 +73,4 @@\n-        robot.delay(250);\n-        robot.waitForIdle();\n+            SwingUtilities.invokeAndWait(() -> {\n+                pointToClick = getCenterPoint(label);\n+                pointToDrag = getCenterPoint(button);\n+            });\n@@ -83,1 +78,4 @@\n-        Point pointToClick = Util.invokeOnEDT(new Callable<Point>() {\n+            robot.mouseMove(pointToClick.x, pointToClick.y);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(250);\n@@ -85,3 +83,2 @@\n-            @Override\n-            public Point call() throws Exception {\n-                return getCenterPoint(label);\n+            if (dragWindowMouseEnteredCount != 1) {\n+                throw new RuntimeException(\"No MouseEntered event on Drag Window!\");\n@@ -89,1 +86,0 @@\n-        });\n@@ -91,0 +87,5 @@\n+            \/\/ Reset entered count to check if mouse entered starting from here\n+            buttonMouseEnteredCount = 0;\n+            robot.mouseMove(pointToDrag.x, pointToDrag.y);\n+            robot.waitForIdle();\n+            robot.delay(250);\n@@ -92,14 +93,2 @@\n-        robot.mouseMove(pointToClick.x, pointToClick.y);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle();\n-\n-        if (dragWindowMouseEnteredCount != 1) {\n-            throw new RuntimeException(\"No MouseEntered event on Drag Window!\");\n-        }\n-\n-        Point pointToDrag = Util.invokeOnEDT(new Callable<Point>() {\n-\n-            @Override\n-            public Point call() throws Exception {\n-                button.addMouseListener(new ButtonMouseListener());\n-                return getCenterPoint(button);\n+            if (buttonMouseEnteredCount != 0) {\n+                throw new RuntimeException(\"Extra MouseEntered event on button!\");\n@@ -107,8 +96,0 @@\n-        });\n-\n-        robot.mouseMove(pointToDrag.x, pointToDrag.y);\n-        robot.waitForIdle();\n-\n-        if (buttonMouseEnteredCount != 0) {\n-            throw new RuntimeException(\"Extra MouseEntered event on button!\");\n-        }\n@@ -116,2 +97,3 @@\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle();\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(250);\n@@ -119,2 +101,9 @@\n-        if (labelMouseReleasedCount != 1) {\n-            throw new RuntimeException(\"No MouseReleased event on label!\");\n+            if (labelMouseReleasedCount != 1) {\n+                throw new RuntimeException(\"No MouseReleased event on label!\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -122,1 +111,0 @@\n-\n@@ -132,2 +120,1 @@\n-\n-        JFrame frame = new JFrame(\"Main Frame\");\n+        frame = new JFrame(\"DragWindowTest\");\n@@ -145,0 +132,1 @@\n+        button.addMouseListener(new ButtonMouseListener());\n@@ -152,1 +140,0 @@\n-\n@@ -160,1 +147,0 @@\n-\n@@ -179,2 +165,0 @@\n-\n-        Point origin;\n@@ -213,1 +197,0 @@\n-\n@@ -218,5 +201,0 @@\n-\n-        @Override\n-        public void mouseReleased(MouseEvent e) {\n-            dragWindowMouseReleasedCount++;\n-        }\n@@ -226,1 +204,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java","additions":45,"deletions":68,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.OptionalDataException;\n+\n+\/**\n+ * @test\n+ * @bug 8367384\n+ * @summary Verify ICC_Profile serialization per spec, all name\/data cases\n+ *\/\n+public final class SerializationSpecTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Serialization form for ICC_Profile includes version, profile name,\n+        \/\/ and profile data. If the name is invalid or does not match a standard\n+        \/\/ profile, the data is used. An exception is thrown only if both the\n+        \/\/ name and the data are invalid, or if one of them is missing or is of\n+        \/\/ the wrong type.\n+\n+        \/\/ Naming conventions used in test file names:\n+        \/\/ null     : null reference\n+        \/\/ valid    : valid standard profile name or valid profile data (byte[])\n+        \/\/ invalid  : unrecognized name or data with incorrect ICC header\n+        \/\/ wrongType: incorrect type, e.g., int[] instead of String or byte[]\n+\n+        \/\/ No name or data\n+        test(\"empty\", OptionalDataException.class);\n+\n+        \/\/ Cases where only the profile name is present (no profile data)\n+        test(\"null\", OptionalDataException.class);\n+        test(\"valid\", OptionalDataException.class);\n+        test(\"invalid\", OptionalDataException.class);\n+        test(\"wrongType\", InvalidObjectException.class);\n+\n+        \/\/ The test files are named as <name>_<data>.ser\n+        test(\"null_null\", InvalidObjectException.class);\n+        test(\"null_valid\", null); \/\/ valid data is enough if name is null\n+        test(\"null_invalid\", InvalidObjectException.class);\n+        test(\"null_wrongType\", InvalidObjectException.class);\n+\n+        test(\"invalid_null\", InvalidObjectException.class);\n+        test(\"invalid_valid\", null); \/\/ valid data is enough if name is invalid\n+        test(\"invalid_invalid\", InvalidObjectException.class);\n+        test(\"invalid_wrongType\", InvalidObjectException.class);\n+\n+        test(\"wrongType_null\", InvalidObjectException.class);\n+        test(\"wrongType_valid\", InvalidObjectException.class);\n+        test(\"wrongType_invalid\", InvalidObjectException.class);\n+        test(\"wrongType_wrongType\", InvalidObjectException.class);\n+\n+        test(\"valid_null\", null); \/\/ the valid name is enough\n+        test(\"valid_valid\", null); \/\/ the valid name is enough\n+        test(\"valid_invalid\", null); \/\/ the valid name is enough\n+        test(\"valid_wrongType\", InvalidObjectException.class);\n+    }\n+\n+    private static void test(String test, Class<?> expected) {\n+        String fileName = test + \".ser\";\n+        File file = new File(System.getProperty(\"test.src\", \".\"), fileName);\n+        Class<?> actual = null;\n+        try (var fis = new FileInputStream(file);\n+             var ois = new ObjectInputStream(fis))\n+        {\n+            ois.readObject();\n+        } catch (Exception e) {\n+            actual = e.getClass();\n+        }\n+        if (actual != expected) {\n+            System.err.println(\"Test: \" + test);\n+            System.err.println(\"Expected: \" + expected);\n+            System.err.println(\"Actual: \" + actual);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/SerializationSpecTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/empty.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/invalid.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/invalid_invalid.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/invalid_null.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/invalid_valid.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/invalid_wrongType.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/null.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/null_invalid.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/null_null.ser","binary":true,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/null_valid.ser","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/BuiltInProfileCheck\/custom.icc","status":"copied"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/null_wrongType.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/valid.ser","binary":true,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/valid_invalid.ser","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/BuiltInProfileCheck\/builtIn.icc","status":"copied"},{"patch":"","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/valid_null.ser","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/BuiltInProfileCheck\/builtIn.icc","status":"copied"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/valid_valid.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/valid_wrongType.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/wrongType.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/wrongType_invalid.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/wrongType_null.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/wrongType_valid.ser","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/SerializationSpecTest\/wrongType_wrongType.ser","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+\/**\n+ * @test\n+ * @bug 8367384\n+ * @summary Checks ICC_Profile serialization for standard profiles\n+ *\/\n+public final class StandardProfilesRoundTrip {\n+\n+    private static final ICC_Profile[] PROFILES = {\n+            ICC_Profile.getInstance(ColorSpace.CS_sRGB),\n+            ICC_Profile.getInstance(ColorSpace.CS_LINEAR_RGB),\n+            ICC_Profile.getInstance(ColorSpace.CS_CIEXYZ),\n+            ICC_Profile.getInstance(ColorSpace.CS_PYCC),\n+            ICC_Profile.getInstance(ColorSpace.CS_GRAY)\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Test profiles one by one\n+        for (ICC_Profile profile : PROFILES) {\n+            test(profile);\n+        }\n+        \/\/ Test all profiles at once\n+        test(PROFILES);\n+    }\n+\n+    private static void test(ICC_Profile... profiles) throws Exception {\n+        byte[] data;\n+        try (var bos = new ByteArrayOutputStream();\n+             var oos = new ObjectOutputStream(bos))\n+        {\n+            for (ICC_Profile p : profiles) {\n+                oos.writeObject(p);\n+            }\n+            data = bos.toByteArray();\n+        }\n+        try (var ois = new ObjectInputStream(new ByteArrayInputStream(data))) {\n+            for (ICC_Profile p : profiles) {\n+                if (p != ois.readObject()) {\n+                    throw new RuntimeException(\"Wrong deserialized object\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/Serialization\/StandardProfilesRoundTrip.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -164,2 +164,2 @@\n-        System.out.println(\"CASE 15: Testing Deserialization of ICC_Profile ...\");\n-        testDeserialization();\n+        System.out.println(\"CASE 15: Testing loading of ICC_Profile from file ...\");\n+        testLoading();\n@@ -264,3 +264,3 @@\n-    private static void testDeserialization() throws IOException {\n-        \/\/invalidSRGB.icc is serialized on older version of JDK\n-        \/\/Upon deserialization, the invalid profile is expected to throw IAE\n+    private static void testLoading() throws IOException {\n+        \/\/ invalidSRGB.icc is a profile file that was produced by an older JDK\n+        \/\/ When attempting to load it, the current JDK is expected to throw IAE\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/ValidateICCHeaderData\/ValidateICCHeaderData.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-            testEnum(E1.B, 1, 3, \"B\", \"C\", \"A\", E2.class);\n+            testEnum(E1.B, 0, -1, E2.class);\n@@ -164,1 +164,1 @@\n-            testEnum(E1.B, 1, 3, \"B\", \"C\", \"A\", String.class);\n+            testEnum(E1.B, 0, -1, String.class);\n@@ -169,0 +169,30 @@\n+        try {\n+            testEnum(E1.B, 0, -1, 10);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 0, -1, new Object());\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 0, -1, new Object[] { null });\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 0, -1, \"\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 0, -1, (Object[]) null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n@@ -175,0 +205,7 @@\n+        testEnum(E1.B, 0, 2, \"A\", \"OLD_REMOVED_CONSTANT\", \"B\", E1.class);\n+        testEnum(E1.B, 1, 2, \"A\", \"OLD_REMOVED_CONSTANT\", \"B\", E1.class);\n+\n+        \/\/null invocation name:\n+        MethodType switchType = MethodType.methodType(int.class, E1.class, int.class);\n+        MethodHandle indy = ((CallSite) BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), null, switchType)).dynamicInvoker();\n+        assertEquals((int) indy.invoke(E1.A, 0), 0);\n@@ -200,0 +237,3 @@\n+        testEnum(E.class, E.C, 0, 2, \"A\", \"B\");\n+        testEnum(E.class, E.C, 1, 2, \"A\", \"B\");\n+        testEnum(E.class, E.C, 2, 2, \"A\", \"B\");\n@@ -282,0 +322,3 @@\n+        \/\/null invocationName is OK:\n+        BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), null, switchType,\n+                               new Object[] {Object.class});\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-                .connectTimeout(Duration.ofSeconds(10))\n","filename":"test\/jdk\/java\/net\/httpclient\/BasicHTTP2Test.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -219,1 +219,0 @@\n-                .connectTimeout(Duration.ofSeconds(10))\n","filename":"test\/jdk\/java\/net\/httpclient\/BasicHTTP3Test.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.time.Duration;\n@@ -50,0 +49,1 @@\n+import jdk.test.lib.Utils;\n@@ -77,0 +77,1 @@\n+ *        jdk.test.lib.Utils\n@@ -78,1 +79,1 @@\n- * @run testng\/othervm\/timeout=60 -Djdk.internal.httpclient.debug=true\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n@@ -219,1 +220,0 @@\n-                .connectTimeout(Duration.ofSeconds(10))\n@@ -351,1 +351,1 @@\n-            AssertionError error = TRACKER.check(tracker, 1000);\n+            AssertionError error = TRACKER.check(tracker, Utils.adjustTimeout(1000));\n@@ -397,1 +397,1 @@\n-        AssertionError error = TRACKER.check(tracker, 1000);\n+        AssertionError error = TRACKER.check(tracker, Utils.adjustTimeout(1000));\n@@ -426,1 +426,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(Utils.adjustTimeout(1000));\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/GetHTTP3Test.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-                .connectTimeout(Duration.ofSeconds(10))\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3DataLimitsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,2 +106,0 @@\n-                \/\/ the server drops 1 packet out of two!\n-                .connectTimeout(Duration.ofSeconds(Utils.adjustTimeout(10)))\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3HeaderSizeLimitTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,2 +158,0 @@\n-                \/\/ the server drops 1 packet out of two!\n-                .connectTimeout(Duration.ofSeconds(Utils.adjustTimeout(10)))\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3InsertionsLimitTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n- * @run junit H3ServerPushTest\n+ * @run junit\/othervm\/timeout=240 H3ServerPushTest\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3ServerPushTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.time.Duration;\n@@ -56,0 +55,1 @@\n+import jdk.test.lib.Utils;\n@@ -82,0 +82,1 @@\n+ *        jdk.test.lib.Utils\n@@ -224,1 +225,0 @@\n-                .connectTimeout(Duration.ofSeconds(10))\n@@ -378,1 +378,1 @@\n-            AssertionError error = TRACKER.check(tracker, 1000);\n+            AssertionError error = TRACKER.check(tracker, Utils.adjustTimeout(1000));\n@@ -440,1 +440,1 @@\n-        AssertionError error = TRACKER.check(tracker, 1000);\n+        AssertionError error = TRACKER.check(tracker, Utils.adjustTimeout(1000));\n@@ -469,1 +469,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(Utils.adjustTimeout(1000));\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/PostHTTP3Test.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,1 @@\n+        viaCircularProvider(\"circular\", CIRCULAR);\n@@ -102,0 +103,6 @@\n+    static final Consumer<Result> CIRCULAR = r -> {\n+        if (r.exitValue == 0 ||\n+            !r.output.contains(\"Circular loading of URL stream handler providers detected\")) {\n+            throw new RuntimeException(\"exitValue: \" + r.exitValue + \", output:[\" + r.output + \"]\");\n+        }\n+    };\n@@ -128,0 +135,9 @@\n+    static void viaCircularProvider(String protocol, Consumer<Result> resultChecker,\n+                                    String... sysProps)\n+        throws Exception\n+    {\n+        viaProviderWithTemplate(protocol, resultChecker,\n+                                TEST_SRC.resolve(\"circular.provider.template\"),\n+                                sysProps);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/spi\/URLStreamHandlerProvider\/Basic.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package $package;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.net.spi.URLStreamHandlerProvider;\n+\n+public final class Provider extends URLStreamHandlerProvider {\n+\n+    private static final String PROTOCOL = \"$protocol\";\n+\n+    @Override\n+    public URLStreamHandler createURLStreamHandler(String protocol) {\n+        try {\n+            \/\/ Trigger circular lookup\n+            URI.create(\"bogus:\/\/path\/to\/nothing\").toURL();\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+        throw new AssertionError(\"Should not have reached here!\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/spi\/URLStreamHandlerProvider\/circular.provider.template","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-                () -> Charset.forName(name));\n+                () -> Charset.isSupported(name));\n@@ -63,1 +63,1 @@\n-                () -> Charset.forName(\"\"));\n+                () -> Charset.isSupported(\"\"));\n","filename":"test\/jdk\/java\/nio\/charset\/Charset\/IllegalCharsetName.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -65,1 +66,3 @@\n-    public void ping () throws RemoteException { }\n+    public void ping () throws RemoteException {\n+        remoteCallsComplete.countDown();\n+    }\n@@ -77,0 +80,3 @@\n+    private static final int NO_OF_CLIENTS = ITERATIONS;\n+    private static final int GOOD_LUCK_FACTOR = 2;\n+    private static CountDownLatch remoteCallsComplete = new CountDownLatch(NO_OF_CLIENTS);\n@@ -116,0 +122,7 @@\n+            try {\n+                remoteCallsComplete.await();\n+                System.out.println(\"remoteCallsComplete . . . \");\n+            } catch (InterruptedException intEx) {\n+                System.out.println(\"remoteCallsComplete.await interrupted . . . \");\n+            }\n+            Thread.sleep(NO_OF_CLIENTS * LEASE_VALUE * GOOD_LUCK_FACTOR);\n@@ -117,1 +130,0 @@\n-            Thread.sleep(3000);\n@@ -128,2 +140,2 @@\n-        \/* numLeft should be 4 - if 11 there is a problem. *\/\n-        if (numLeft > 4) {\n+        \/* numLeft should not be greater than 2 - if 11 there is a problem. *\/\n+        if (numLeft > 2) {\n@@ -207,2 +219,3 @@\n-\n-            numLeaseInfosLeft = leaseTable.size();\n+            synchronized (leaseTable) {\n+                numLeaseInfosLeft = leaseTable.size();\n+            }\n","filename":"test\/jdk\/java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8159337\n+ * @bug 8159337 8368981\n@@ -31,1 +31,0 @@\n-import org.junit.jupiter.api.AfterAll;\n@@ -57,1 +56,1 @@\n-    public void wellFormedTags(String tag, String foldedTag) {\n+    void wellFormedTagsTest(String tag, String foldedTag) {\n@@ -61,0 +60,11 @@\n+    @ParameterizedTest\n+    @MethodSource(\"legacyTags\")\n+    void legacyTagsTest(String tag) {\n+        var lowerTag = tag.toLowerCase(Locale.ROOT);\n+        var upperTag = tag.toUpperCase(Locale.ROOT);\n+        assertEquals(tag, Locale.caseFoldLanguageTag(lowerTag),\n+                String.format(\"Folded %s\", lowerTag));\n+        assertEquals(tag, Locale.caseFoldLanguageTag(upperTag),\n+                String.format(\"Folded %s\", upperTag));\n+    }\n+\n@@ -63,1 +73,1 @@\n-    public void illFormedTags(String tag) {\n+    void illFormedTagsTest(String tag) {\n@@ -69,1 +79,1 @@\n-    public void throwNPE() {\n+    void throwNPETest() {\n@@ -74,1 +84,33 @@\n-    private static Stream<Arguments> wellFormedTags() {\n+    \/\/ Well-formed legacy tags in expected case\n+    static Stream<String> legacyTags() {\n+        return Stream.of(\n+                \"art-lojban\",\n+                \"cel-gaulish\",\n+                \"en-GB-oed\",\n+                \"i-ami\",\n+                \"i-bnn\",\n+                \"i-default\",\n+                \"i-enochian\",\n+                \"i-hak\",\n+                \"i-klingon\",\n+                \"i-lux\",\n+                \"i-mingo\",\n+                \"i-navajo\",\n+                \"i-pwn\",\n+                \"i-tao\",\n+                \"i-tay\",\n+                \"i-tsu\",\n+                \"no-bok\",\n+                \"no-nyn\",\n+                \"sgn-BE-FR\",\n+                \"sgn-BE-NL\",\n+                \"sgn-CH-DE\",\n+                \"zh-guoyu\",\n+                \"zh-hakka\",\n+                \"zh-min\",\n+                \"zh-min-nan\",\n+                \"zh-xiang\"\n+        );\n+    }\n+\n+    static Stream<Arguments> wellFormedTags() {\n@@ -127,10 +169,0 @@\n-                \/\/ Legacy tests\n-                \/\/ irregular\n-                Arguments.of(\"I-AMI\", \"i-ami\"),\n-                Arguments.of(\"EN-gb-OED\", \"en-GB-oed\"),\n-                Arguments.of(\"SGN-be-fr\", \"sgn-BE-FR\"),\n-                \/\/ regular\n-                Arguments.of(\"NO-BOK\", \"no-bok\"),\n-                Arguments.of(\"CEL-GAULISH\", \"cel-gaulish\"),\n-                Arguments.of(\"ZH-MIN-NAN\", \"zh-min-nan\"),\n-\n@@ -153,1 +185,1 @@\n-    private static Stream<Arguments> illFormedTags() {\n+    static Stream<Arguments> illFormedTags() {\n","filename":"test\/jdk\/java\/util\/Locale\/CaseFoldLanguageTagTest.java","additions":50,"deletions":18,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- *          jdk.httpserver\n@@ -33,1 +32,0 @@\n- *        jdk.test.lib.net.SimpleHttpServer\n@@ -54,0 +52,3 @@\n+import java.nio.file.Path;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -55,1 +56,2 @@\n-import jdk.test.lib.net.SimpleHttpServer;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n@@ -62,1 +64,2 @@\n-    private SimpleHttpServer server;\n+    private HttpServer server;\n+    private ExecutorService executor;\n@@ -67,2 +70,4 @@\n-        server = new SimpleHttpServer(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), TESTCONTEXT,\n-                System.getProperty(\"user.dir\", \".\"));\n+        server = SimpleFileServer.createFileServer(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0),\n+                Path.of(System.getProperty(\"user.dir\", \".\")), SimpleFileServer.OutputLevel.INFO);\n+        executor = Executors.newCachedThreadPool();\n+        server.setExecutor(executor);\n@@ -76,1 +81,1 @@\n-                URIBuilder.newBuilder().scheme(\"http\").port(server.getPort()).loopback()\n+                URIBuilder.newBuilder().scheme(\"http\").port(server.getAddress().getPort()).loopback()\n@@ -87,2 +92,4 @@\n-        if (server != null)\n-            server.stop();\n+        if (server != null) {\n+            server.stop(0);\n+            executor.shutdown();\n+        }\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/mrjar\/MultiReleaseJarHttpProperties.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8359388\n+ * @bug 8359388 8368984\n@@ -70,0 +70,3 @@\n+            \/\/ 4 or more components transformations\n+            \"PBEWithHmacSHA512\/\/\/PKCS5Padding\",\n+            \"AES\/GCM\/NoPadding\/\/\/\",\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestEmptyModePadding.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898428\n+ * @bug 4898428 8368984\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,1 @@\n+import jdk.test.lib.Utils;\n@@ -51,2 +53,2 @@\n-        Provider p = Security.getProvider(\n-                System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+        String pName = System.getProperty(\"test.provider.name\", \"SunJCE\");\n+        Provider p = Security.getProvider(pName);\n@@ -71,19 +73,10 @@\n-        try {\n-            c = Cipher.getInstance(algo + \"\/XYZ\/PKCS5Padding\");\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(algo + \"\/XYZ\/PKCS5Padding\",\n-                    System.getProperty(\"test.provider.name\", \"SunJCE\"));\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(algo + \"\/XYZ\/PKCS5Padding\", p);\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n+        \/\/ invalid transformations or transformations containing unsupported\n+        \/\/ modes which should lead to NSAE\n+        String[] nsaeTransformations = {\n+            (algo + \"\/XYZ\/PKCS5Padding\"),\n+            (algo + \"\/CBC\/XYZWithSHA512\/224Padding\/\"),\n+            (algo + \"\/CBC\/XYZWithSHA512\/256Padding\/\"),\n+            (pbeAlgo + \"\/CBC\/XYZWithSHA512\/224Padding\/\"),\n+            (pbeAlgo + \"\/CBC\/XYZWithSHA512\/256Padding\/\"),\n+            \"foo\",\n+        };\n@@ -91,18 +84,8 @@\n-        try {\n-            c = Cipher.getInstance(algo + \"\/CBC\/XYZPadding\");\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(algo + \"\/CBC\/XYZPadding\",\n-                    System.getProperty(\"test.provider.name\", \"SunJCE\"));\n-            throw new AssertionError();\n-        } catch (NoSuchPaddingException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(algo + \"\/CBC\/XYZPadding\", p);\n-            throw new AssertionError();\n-        } catch (NoSuchPaddingException e) {\n-            System.out.println(e);\n+        for (String t : nsaeTransformations) {\n+            System.out.println(\"Testing NSAE on \" + t);\n+            Utils.runAndCheckException(() -> Cipher.getInstance(t),\n+                    NoSuchAlgorithmException.class);\n+            Utils.runAndCheckException(() -> Cipher.getInstance(t, pName),\n+                    NoSuchAlgorithmException.class);\n+            Utils.runAndCheckException(() -> Cipher.getInstance(t, p),\n+                    NoSuchAlgorithmException.class);\n@@ -111,19 +94,9 @@\n-        try {\n-            c = Cipher.getInstance(\"foo\");\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(\"foo\",\n-                    System.getProperty(\"test.provider.name\", \"SunJCE\"));\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(\"foo\", p);\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n+        \/\/ transformations containing unsupported paddings for SunJCE provider\n+        \/\/ which should lead to NSPE\n+        String[] nspeTransformations = {\n+            (algo + \"\/CBC\/XYZPadding\"),\n+            (algo + \"\/CBC\/XYZWithSHA512\/224Padding\"),\n+            (algo + \"\/CBC\/XYZWithSHA512\/256Padding\"),\n+            (pbeAlgo + \"\/CBC\/XYZWithSHA512\/224Padding\"),\n+            (pbeAlgo + \"\/CBC\/XYZWithSHA512\/256Padding\"),\n+        };\n@@ -131,19 +104,6 @@\n-        try {\n-            c = Cipher.getInstance(\"foo\",\n-                    System.getProperty(\"test.provider.name\", \"SUN\"));\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(\"foo\", Security.getProvider(\n-                    System.getProperty(\"test.provider.name\", \"SUN\")));\n-            throw new AssertionError();\n-        } catch (NoSuchAlgorithmException e) {\n-            System.out.println(e);\n-        }\n-        try {\n-            c = Cipher.getInstance(\"foo\", \"bar\");\n-            throw new AssertionError();\n-        } catch (NoSuchProviderException e) {\n-            System.out.println(e);\n+        for (String t : nspeTransformations) {\n+            System.out.println(\"Testing NSPE on \" + t);\n+            Utils.runAndCheckException(() -> Cipher.getInstance(t, pName),\n+                    NoSuchPaddingException.class);\n+            Utils.runAndCheckException(() -> Cipher.getInstance(t, p),\n+                    NoSuchPaddingException.class);\n@@ -152,0 +112,10 @@\n+        \/\/ additional misc tests\n+        Utils.runAndCheckException(() -> Cipher.getInstance(\"foo\",\n+                System.getProperty(\"test.provider.name\", \"SUN\")),\n+                NoSuchAlgorithmException.class);\n+        Utils.runAndCheckException(() -> Cipher.getInstance(\"foo\",\n+                Security.getProvider(System.getProperty(\"test.provider.name\",\n+                \"SUN\"))), NoSuchAlgorithmException.class);\n+        Utils.runAndCheckException(() -> Cipher.getInstance(\"foo\", \"bar\"),\n+                NoSuchProviderException.class);\n+\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestGetInstance.java","additions":49,"deletions":79,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @key headful\n@@ -31,3 +30,4 @@\n-import java.awt.Toolkit;\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n@@ -35,2 +35,4 @@\n-import java.net.MalformedURLException;\n-import javax.swing.JDialog;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import javax.imageio.ImageIO;\n@@ -38,11 +40,7 @@\n-import javax.swing.JFrame;\n-import javax.swing.JScrollPane;\n-import javax.swing.SwingUtilities;\n-import javax.swing.event.HyperlinkEvent;\n-import javax.swing.event.HyperlinkListener;\n-import javax.swing.text.html.HTMLFrameHyperlinkEvent;\n-import javax.swing.text.html.HTMLDocument;\n-import java.awt.Color;\n-import java.awt.Insets;\n-import java.awt.Point;\n-import java.awt.Robot;\n+import javax.swing.text.StyleConstants;\n+import javax.swing.text.View;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+import static java.lang.Integer.toHexString;\n+\n+public final class TestBrowserBGColor {\n@@ -50,1 +48,6 @@\n-public class TestBrowserBGColor extends JFrame implements HyperlinkListener {\n+    private static final String HTML_DOC =\n+            \"<!DOCTYPE html>\"\n+            + \"<html><head>\"\n+            + \"<style> body { background: #FFF; } <\/style>\"\n+            + \"<title>Title<\/title><\/head>\"\n+            + \"<body> <\/body> <\/html>\";\n@@ -52,2 +55,1 @@\n-    private static TestBrowserBGColor b;\n-    private static JEditorPane browser;\n+    private static final int SIZE = 300;\n@@ -56,17 +58,3 @@\n-        Robot r = new Robot();\n-        SwingUtilities.invokeAndWait(() -> {\n-            try {\n-                b = new TestBrowserBGColor();\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-            b.setSize(Toolkit.getDefaultToolkit().getScreenSize());\n-            b.setVisible(true);\n-            b.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n-            b.addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent e) {\n-                    b.dispose();\n-                    b = null;\n-                }\n-            });\n-        });\n+        JEditorPane browser = new JEditorPane(\"text\/html\", HTML_DOC);\n+        browser.setEditable(false);\n+        browser.setSize(SIZE, SIZE);\n@@ -74,2 +62,4 @@\n-        r.waitForIdle();\n-        r.delay(500);\n+        BufferedImage image = new BufferedImage(SIZE, SIZE, TYPE_INT_RGB);\n+        Graphics g = image.getGraphics();\n+        browser.paint(g);\n+        g.dispose();\n@@ -77,10 +67,11 @@\n-        SwingUtilities.invokeAndWait(() -> {\n-            Insets insets = browser.getInsets();\n-            Point loc = browser.getLocationOnScreen();\n-            Color c = r.getPixelColor( loc.x + insets.left+100,\n-                                  loc.y + insets.top + 100);\n-            b.dispose();\n-            if (!c.equals(Color.WHITE)) {\n-                throw new RuntimeException(\"webpage background color wrong\");\n-            }\n-        });\n+        Color bgColor = StyleConstants.getBackground(\n+                getBodyView(browser.getUI()\n+                                   .getRootView(browser))\n+                .getAttributes());\n+        if (!bgColor.equals(Color.WHITE)) {\n+            saveImage(image);\n+            throw new RuntimeException(\"Wrong background color: \"\n+                                       + toHexString(bgColor.getRGB())\n+                                       + \" vs \"\n+                                       + toHexString(Color.WHITE.getRGB()));\n+        }\n@@ -89,0 +80,5 @@\n+    private static View getBodyView(final View view) {\n+        if (\"body\".equals(view.getElement()\n+                              .getName())) {\n+            return view;\n+        }\n@@ -90,8 +86,6 @@\n-    String htmlDoc = \" <!DOCTYPE html> <html><style> body { background: #FFF; } <\/style> <head> <title>Title<\/title> <\/head> <body> <\/body> <\/html>\";\n-\n-    public TestBrowserBGColor() throws IOException, MalformedURLException {\n-        browser = new JEditorPane(\"text\/html\", htmlDoc);\n-        browser.setEditable(false);\n-        browser.addHyperlinkListener(this);\n-        JScrollPane scroll = new JScrollPane(browser);\n-        getContentPane().add(scroll);\n+        return IntStream.range(0, view.getViewCount())\n+                        .mapToObj(view::getView)\n+                        .map(TestBrowserBGColor::getBodyView)\n+                        .filter(Objects::nonNull)\n+                        .findFirst()\n+                        .orElse(null);\n@@ -100,14 +94,5 @@\n-    public void hyperlinkUpdate(final HyperlinkEvent e) {\n-        if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n-            JEditorPane pane = (JEditorPane) e.getSource();\n-            if (e instanceof HTMLFrameHyperlinkEvent) {\n-                HTMLFrameHyperlinkEvent evt = (HTMLFrameHyperlinkEvent) e;\n-                HTMLDocument doc = (HTMLDocument) pane.getDocument();\n-                doc.processHTMLFrameHyperlinkEvent(evt);\n-            } else {\n-                try {\n-                    pane.setPage(e.getURL());\n-                } catch (Throwable t) {\n-                    t.printStackTrace();\n-                }\n-            }\n+    private static void saveImage(BufferedImage image) {\n+        try {\n+            ImageIO.write(image, \"png\",\n+                          new File(\"html-rendering.png\"));\n+        } catch (IOException ignored) {\n","filename":"test\/jdk\/javax\/swing\/JEditorPane\/TestBrowserBGColor.java","additions":57,"deletions":72,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-        JLabel label = new JLabel(\"<html><body>Can You Read This?<\/body><\/html>\");\n+        JLabel label = new JLabel(\"<html><body>\\u2588 \\u2588 \\u2588 \\u2588<\/body><\/html>\");\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicHTML\/bug4248210.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n- * @test 1.4 08\/08\/05\n+ * @test\n@@ -29,1 +29,0 @@\n- * @author Romain Guy\n@@ -33,3 +32,0 @@\n-import java.awt.*;\n-import java.awt.image.*;\n-import java.awt.event.*;\n@@ -37,2 +33,19 @@\n-import javax.swing.*;\n-import javax.swing.plaf.synth.*;\n+import java.io.File;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.plaf.synth.SynthLookAndFeel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import java.util.concurrent.CountDownLatch;\n@@ -43,1 +56,0 @@\n-    private static Point p;\n@@ -47,2 +59,2 @@\n-    private final static int OFFSET_X = -20;\n-    private final static int OFFSET_Y = -20;\n+    private final static int OFFSET_X = 20;\n+    private final static int OFFSET_Y = 20;\n@@ -51,0 +63,1 @@\n+        Robot robot = new Robot();\n@@ -52,1 +65,0 @@\n-            Robot robot = new Robot();\n@@ -58,0 +70,1 @@\n+            CountDownLatch latch = new CountDownLatch(1);\n@@ -65,0 +78,7 @@\n+                    button.addMouseListener(new MouseAdapter() {\n+                        @Override\n+                        public void mousePressed(MouseEvent e) {\n+                            System.out.println(\"Mouse pressed\");\n+                            latch.countDown();\n+                        }\n+                    });\n@@ -75,1 +95,1 @@\n-            p = Util.getCenterPoint(button);\n+            Point p = Util.getCenterPoint(button);\n@@ -81,1 +101,2 @@\n-            robot.waitForIdle();\n+            latch.await();\n+            robot.delay(1000);\n@@ -92,1 +113,1 @@\n-                javax.imageio.ImageIO.write(img, \"png\", new java.io.File(\"image.png\"));\n+                ImageIO.write(img, \"png\", new File(\"image.png\"));\n","filename":"test\/jdk\/javax\/swing\/plaf\/synth\/SynthButtonUI\/6276188\/bug6276188.java","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.test.lib.Platform;\n@@ -43,9 +44,19 @@\n-        Recording recording = new Recording();\n-        recording.enable(EVENT_NAME);\n-        recording.start();\n-        recording.stop();\n-        List<RecordedEvent> events = Events.fromRecording(recording);\n-        Events.hasEvents(events);\n-        for (RecordedEvent event : events) {\n-            System.out.println(\"Event: \" + event);\n-            Events.assertField(event, \"switchRate\").atLeast(0.0f);\n+        while (true) {\n+            try (Recording recording = new Recording()) {\n+                recording.enable(EVENT_NAME);\n+                recording.start();\n+                recording.stop();\n+                List<RecordedEvent> events = Events.fromRecording(recording);\n+                if (!events.isEmpty()) {\n+                    for (RecordedEvent event : events) {\n+                        System.out.println(\"Event: \" + event);\n+                        Events.assertField(event, \"switchRate\").atLeast(0.0f);\n+                    }\n+                    return;\n+                }\n+                \/\/ Thread context switch rate is unreliable on Windows because\n+                \/\/ the way processes are identified with performance counters.\n+                if (!Platform.isWindows()) {\n+                    Events.hasEvents(events);\n+                }\n+            }\n","filename":"test\/jdk\/jdk\/jfr\/event\/os\/TestThreadContextSwitches.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.time.Instant;\n@@ -44,0 +45,7 @@\n+ *\n+ * The test starts CPU time sampling with a short interval (1ms), disabling\n+ * out-of-stack sample processing for the duration of the test.\n+ * It now runs in native for one second, to cause queue overflows,\n+ * then it comes back into Java to trigger the queue walking.\n+ * Repeats the cycle 5 times and verifies that the loss decreases from the first\n+ * to the last iteration.\n@@ -45,1 +53,1 @@\n- * @requires vm.hasJFR & os.family == \"linux\" & vm.debug\n+ * @requires vm.hasJFR & os.family == \"linux\" & vm.debug & vm.flagless\n@@ -57,4 +65,0 @@\n-    private static final String BURST_THREAD_NAME = \"Burst-Thread-1\";\n-\n-    static volatile boolean alive = true;\n-\n@@ -66,0 +70,2 @@\n+        private final List<Long> sampleEventsInTimeBox = new ArrayList<>();\n+        private final List<Long> timeBoxEnds = new ArrayList<>();\n@@ -77,1 +83,1 @@\n-        public List<LossEvent> getEventsPerInterval(long widthMillis, long stopTimeMillis) {\n+        public synchronized List<LossEvent> getEventsPerTimeBox() {\n@@ -79,2 +85,2 @@\n-            for (long start = 0; start < stopTimeMillis; start += widthMillis) {\n-                long actualStart = Math.min(start, stopTimeMillis - widthMillis);\n+            AtomicLong previousEnd = new AtomicLong(0);\n+            for (Long timeBoxEnd : timeBoxEnds) {\n@@ -82,1 +88,1 @@\n-                                          .filter(e -> e.relativeTimeMillis >= actualStart && e.relativeTimeMillis < actualStart + widthMillis)\n+                                          .filter(e -> e.relativeTimeMillis >= previousEnd.get() && e.relativeTimeMillis <= timeBoxEnd)\n@@ -85,1 +91,2 @@\n-                ret.add(new LossEvent(actualStart, lostSamples));\n+                ret.add(new LossEvent(previousEnd.get(), lostSamples));\n+                previousEnd.set(timeBoxEnd);\n@@ -90,0 +97,17 @@\n+        public synchronized void addTimeBoxEnd(long timeBoxEnd, long sampleEvents) {\n+            timeBoxEnds.add(timeBoxEnd);\n+            sampleEventsInTimeBox.add(sampleEvents);\n+        }\n+\n+        public synchronized void print() {\n+            System.out.println(\"Loss event information:\");\n+            for (int i = 0; i < timeBoxEnds.size(); i++) {\n+                System.out.println(\"  Time box end: \" + timeBoxEnds.get(i) + \", sample events: \" + sampleEventsInTimeBox.get(i));\n+            }\n+            for (LossEvent e : events) {\n+                System.out.println(\"  Lost samples event: \" + e.lostSamples + \" at \" + e.relativeTimeMillis);\n+            }\n+            for (LossEvent e : getEventsPerTimeBox()) {\n+                System.out.println(\"  Lost samples in time box ending at \" + e.relativeTimeMillis + \": \" + e.lostSamples);\n+            }\n+        }\n@@ -95,2 +119,2 @@\n-            AtomicLong firstSampleTimeMillis = new AtomicLong(0);\n-            AtomicLong lastSampleTimeMillis = new AtomicLong(0);\n+            long burstThreadId = Thread.currentThread().threadId();\n+            final long startTimeMillis = Instant.now().toEpochMilli();\n@@ -98,0 +122,1 @@\n+            AtomicLong sampleEventCountInTimeBox = new AtomicLong(0);\n@@ -99,8 +124,0 @@\n-            rs.onEvent(EventNames.CPUTimeSample, e -> {\n-                if (firstSampleTimeMillis.get() == 0 && e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    firstSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    lastSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-            });\n@@ -109,1 +126,1 @@\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId) {\n@@ -111,2 +128,2 @@\n-                    long relativeTime = firstSampleTimeMillis.get() > 0 ? (eventTime - firstSampleTimeMillis.get()) : eventTime;\n-                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime);\n+                    long relativeTime = eventTime - startTimeMillis;\n+                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime + \" start time \" + startTimeMillis);\n@@ -116,1 +133,5 @@\n-            WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n+            rs.onEvent(EventNames.CPUTimeSample, e -> {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId) {\n+                    sampleEventCountInTimeBox.incrementAndGet();\n+                }\n+            });\n@@ -118,5 +139,5 @@\n-            \/\/ this thread runs all along\n-            Thread burstThread = new Thread(() -> WHITE_BOX.busyWait(11000));\n-            burstThread.setName(BURST_THREAD_NAME);\n-            burstThread.start();\n-            \/\/ now we toggle out-of-stack-walking off, wait 1 second and then turn it on for 500ms a few times\n+            \/\/ we disable the out-of-stack walking so that the queue fills up and overflows\n+            \/\/ while we are in native code\n+            disableOutOfStackWalking();\n+\n+\n@@ -124,13 +145,8 @@\n-                boolean supported = WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n-                if (!supported) {\n-                    System.out.println(\"Out-of-stack-walking not supported, skipping test\");\n-                    Asserts.assertFalse(true);\n-                    return;\n-                }\n-                Thread.sleep(700);\n-                long iterations = WHITE_BOX.cpuSamplerOutOfStackWalkingIterations();\n-                WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n-                Thread.sleep(300);\n-                while (WHITE_BOX.cpuSamplerOutOfStackWalkingIterations() == iterations) {\n-                    Thread.sleep(50); \/\/ just to make sure the stack walking really ran\n-                }\n+                \/\/ run in native for one second\n+                WHITE_BOX.busyWaitCPUTime(1000);\n+                \/\/ going out-of-native at the end of the previous call should have triggered\n+                \/\/ the safepoint handler, thereby also triggering the stack walking and creation\n+                \/\/ of the loss event\n+                WHITE_BOX.forceSafepoint(); \/\/ just to be sure\n+                lossEvents.addTimeBoxEnd(Instant.now().toEpochMilli() - startTimeMillis, sampleEventCountInTimeBox.get());\n+                sampleEventCountInTimeBox.set(0);\n@@ -138,0 +154,2 @@\n+\n+            rs.stop();\n@@ -139,1 +157,4 @@\n-            checkThatLossDecreased(lossEvents, lastSampleTimeMillis.get() - firstSampleTimeMillis.get());\n+\n+            enableOutOfStackWalking();\n+\n+            checkThatLossDecreased(lossEvents);\n@@ -143,10 +164,14 @@\n-    static void checkThatLossDecreased(LossEventCollection lossEvents, long lastSampleTimeMillis) {\n-        List<LossEvent> intervalLosses = lossEvents.getEventsPerInterval(1000, lastSampleTimeMillis);\n-        for (LossEvent interval : intervalLosses) {\n-            System.out.println(\"Lost samples in interval \" + interval.relativeTimeMillis + \": \" + interval.lostSamples);\n-        }\n-        \/\/ check that there are at least 3 intervals\n-        Asserts.assertTrue(intervalLosses.size() > 2);\n-        \/\/ check that the second to last interval has far fewer lost samples than the first\n-        Asserts.assertTrue(intervalLosses.get(intervalLosses.size() - 2).lostSamples <\n-                           intervalLosses.get(0).lostSamples \/ 2);\n+    static void disableOutOfStackWalking() {\n+        Asserts.assertTrue(WHITE_BOX.cpuSamplerSetOutOfStackWalking(false), \"Out-of-stack-walking not supported\");\n+    }\n+\n+    static void enableOutOfStackWalking() {\n+        WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n+    }\n+\n+    static void checkThatLossDecreased(LossEventCollection lossEvents) {\n+        lossEvents.print();\n+        List<LossEvent> timeBoxedLosses = lossEvents.getEventsPerTimeBox();\n+        \/\/ check that the last time box has far fewer lost samples than the first\n+        Asserts.assertTrue(timeBoxedLosses.get(timeBoxedLosses.size() - 1).lostSamples <=\n+                           timeBoxedLosses.get(0).lostSamples \/ 2);\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java","additions":78,"deletions":53,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.time.Instant;\n@@ -267,1 +268,2 @@\n-    private static void span(int depth) {\n+    private static void span(int depth) throws InterruptedException {\n+        awaitUniqueTimestamp();\n@@ -280,0 +282,7 @@\n+    private static void awaitUniqueTimestamp() throws InterruptedException {\n+        Instant timestamp = Instant.now();\n+        while (timestamp.equals(Instant.now())) {\n+            Thread.sleep(1);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestPrintContextual.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6248561 6264014\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that bitmask image copies work properly with the\n+ * OGL pipeline when a SrcOver composite with extra alpha is involved.\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawBitmaskImage\n+ * @run main\/othervm DrawBitmaskImage\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6248561 6264014\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that bitmask image copies work properly with the\n+ * OGL pipeline when a SrcOver composite with extra alpha is involved.\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawBitmaskImage\n+ * @run main\/othervm DrawBitmaskImage\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Transparency;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class DrawBitmaskImage extends Panel {\n+\n+    static final int TESTW = 200, TESTH = 200;\n+    private static volatile DrawBitmaskImage test;\n+    private static volatile Frame frame;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+        g2d.setComposite(AlphaComposite.SrcOver.derive(0.50f));\n+\n+        BufferedImage img = getGraphicsConfiguration().createCompatibleImage(50, 50,\n+                                                        Transparency.BITMASK);\n+        Graphics2D gimg = img.createGraphics();\n+        gimg.setComposite(AlphaComposite.Src);\n+        gimg.setColor(new Color(0, 0, 0, 0));\n+        gimg.fillRect(0, 0, 50, 50);\n+        gimg.setColor(Color.red);\n+        gimg.fillRect(10, 10, 30, 30);\n+        gimg.dispose();\n+\n+\n+        g2d.drawImage(img, 10, 10, null);\n+\n+        \/\/ draw a second time to ensure that the cached copy is used\n+        g2d.drawImage(img, 80, 10, null);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+         return new Dimension(TESTW, TESTH);\n+    }\n+\n+    static void createUI() {\n+        test = new DrawBitmaskImage();\n+        frame = new Frame(\"OpenGL DrawBitmaskImage Test\");\n+        Panel p = new Panel();\n+        p.add(test);\n+        frame.add(p);\n+        frame.setSize(TESTW+100, TESTH+100);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(DrawBitmaskImage::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, TESTW, TESTH);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test background color\n+        int pixel = capture.getRGB(5, 10);\n+        if (pixel != 0xff000000) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"background (actual=\" +\n+                                       Integer.toHexString(pixel) + \")\");\n+        }\n+\n+        \/\/ Test pixels (allow for small error in the actual red value)\n+        pixel = capture.getRGB(25, 25);\n+        System.out.println(\"pixel1 is \" + Integer.toHexString(pixel));\n+\n+        if ((pixel < 0xff7e0000) || (pixel > 0xff900000)) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"first pixel (actual=\" +\n+                                       Integer.toHexString(pixel) + \")\");\n+        }\n+\n+        pixel = capture.getRGB(95, 25);\n+        System.out.println(\"pixel2 is \" + Integer.toHexString(pixel));\n+        if ((pixel < 0xff7e0000) || (pixel > 0xff900000)) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"second pixel (actual=\" +\n+                                       Integer.toHexString(pixel) + \")\");\n+        }\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/DrawBitmaskImage.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,514 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6514990\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that calling\n+ * Graphics2D.drawImage(BufferedImage, BufferedImageOp, x, y) to an\n+ * OpenGL-accelerated destination produces the same results when performed\n+ * in software via BufferedImageOp.filter().\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawBufImgOp -ignore\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6514990\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that calling\n+ * Graphics2D.drawImage(BufferedImage, BufferedImageOp, x, y) to an\n+ * OpenGL-accelerated destination produces the same results when performed\n+ * in software via BufferedImageOp.filter().\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawBufImgOp -ignore\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ByteLookupTable;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ConvolveOp;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.Kernel;\n+import java.awt.image.LookupOp;\n+import java.awt.image.RescaleOp;\n+import java.awt.image.ShortLookupTable;\n+import java.awt.image.VolatileImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+\/**\n+ * REMIND: This testcase was originally intended to automatically compare\n+ * the results of the software BufferedImageOp implementations against\n+ * the OGL-accelerated codepaths.  However, there are just too many open\n+ * bugs in the mediaLib-based codepaths (see below), which means that\n+ * creating the reference image may cause crashes or exceptions,\n+ * and even if we work around those cases using the \"-ignore\" flag,\n+ * the visual results of the reference image are often buggy as well\n+ * (so the comparison will fail even though the OGL results are correct).\n+ * Therefore, for now we will run the testcase with the \"-ignore\" flag\n+ * but without the \"-compare\" flag, so at least it will be checking for\n+ * any exceptions\/crashes in the OGL code.  When we fix all of the\n+ * outstanding bugs with the software codepaths, we can remove the\n+ * \"-ignore\" flag and maybe even restore the \"-compare\" flag.  In the\n+ * meantime, it also functions well as a manual testcase (with either\n+ * the \"-show\" or \"-dump\" options).\n+ *\/\n+public class DrawBufImgOp extends Canvas {\n+\n+    private static final int TESTW = 600;\n+    private static final int TESTH = 500;\n+\n+    private static volatile DrawBufImgOp test;\n+    private static volatile Frame frame;\n+\n+    \/*\n+     * If true, skips tests that are known to trigger bugs (which in\n+     * turn may cause crashes, exceptions, or other artifacts).\n+     *\/\n+    private static boolean ignore;\n+\n+    \/\/ Test both pow2 and non-pow2 sized images\n+    private static final int[] srcSizes = { 32, 17 };\n+    private static final int[] srcTypes = {\n+        BufferedImage.TYPE_INT_RGB,\n+        BufferedImage.TYPE_INT_ARGB,\n+        BufferedImage.TYPE_INT_ARGB_PRE,\n+        BufferedImage.TYPE_INT_BGR,\n+        BufferedImage.TYPE_3BYTE_BGR,\n+        BufferedImage.TYPE_4BYTE_ABGR,\n+        BufferedImage.TYPE_USHORT_565_RGB,\n+        BufferedImage.TYPE_BYTE_GRAY,\n+        BufferedImage.TYPE_USHORT_GRAY,\n+    };\n+\n+    private static final RescaleOp\n+        rescale1band, rescale3band, rescale4band;\n+    private static final LookupOp\n+        lookup1bandbyte, lookup3bandbyte, lookup4bandbyte;\n+    private static final LookupOp\n+        lookup1bandshort, lookup3bandshort, lookup4bandshort;\n+    private static final ConvolveOp\n+        convolve3x3zero, convolve5x5zero, convolve7x7zero;\n+    private static final ConvolveOp\n+        convolve3x3noop, convolve5x5noop, convolve7x7noop;\n+\n+    static {\n+        rescale1band = new RescaleOp(0.5f, 10.0f, null);\n+        rescale3band = new RescaleOp(\n+            new float[] {  0.6f,  0.4f, 0.6f },\n+            new float[] { 10.0f, -3.0f, 5.0f },\n+            null);\n+        rescale4band = new RescaleOp(\n+            new float[] {  0.6f, 0.4f, 0.6f, 0.9f },\n+            new float[] { -1.0f, 5.0f, 3.0f, 1.0f },\n+            null);\n+\n+        \/\/ REMIND: we should probably test non-zero offsets, but that\n+        \/\/ would require massaging the source image data to avoid going\n+        \/\/ outside the lookup table array bounds\n+        int offset = 0;\n+        {\n+            byte invert[] = new byte[256];\n+            byte halved[] = new byte[256];\n+            for (int j = 0; j < 256 ; j++) {\n+                invert[j] = (byte) (255-j);\n+                halved[j] = (byte) (j \/ 2);\n+            }\n+            ByteLookupTable lut1 = new ByteLookupTable(offset, invert);\n+            lookup1bandbyte = new LookupOp(lut1, null);\n+            ByteLookupTable lut3 =\n+                new ByteLookupTable(offset,\n+                                    new byte[][] {invert, halved, invert});\n+            lookup3bandbyte = new LookupOp(lut3, null);\n+            ByteLookupTable lut4 =\n+                new ByteLookupTable(offset,\n+                               new byte[][] {invert, halved, invert, halved});\n+            lookup4bandbyte = new LookupOp(lut4, null);\n+        }\n+\n+        {\n+            short invert[] = new short[256];\n+            short halved[] = new short[256];\n+            for (int j = 0; j < 256 ; j++) {\n+                invert[j] = (short) ((255-j) * 255);\n+                halved[j] = (short) ((j \/ 2) * 255);\n+            }\n+            ShortLookupTable lut1 = new ShortLookupTable(offset, invert);\n+            lookup1bandshort = new LookupOp(lut1, null);\n+            ShortLookupTable lut3 =\n+                new ShortLookupTable(offset,\n+                                     new short[][] {invert, halved, invert});\n+            lookup3bandshort = new LookupOp(lut3, null);\n+            ShortLookupTable lut4 =\n+                new ShortLookupTable(offset,\n+                              new short[][] {invert, halved, invert, halved});\n+            lookup4bandshort = new LookupOp(lut4, null);\n+        }\n+\n+        \/\/ 3x3 blur\n+        float[] data3 = {\n+            0.1f, 0.1f, 0.1f,\n+            0.1f, 0.2f, 0.1f,\n+            0.1f, 0.1f, 0.1f,\n+        };\n+        Kernel k3 = new Kernel(3, 3, data3);\n+\n+        \/\/ 5x5 edge\n+        float[] data5 = {\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, 24.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,\n+        };\n+        Kernel k5 = new Kernel(5, 5, data5);\n+\n+        \/\/ 7x7 blur\n+        float[] data7 = {\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,\n+        };\n+        Kernel k7 = new Kernel(7, 7, data7);\n+\n+        convolve3x3zero = new ConvolveOp(k3, ConvolveOp.EDGE_ZERO_FILL, null);\n+        convolve5x5zero = new ConvolveOp(k5, ConvolveOp.EDGE_ZERO_FILL, null);\n+        convolve7x7zero = new ConvolveOp(k7, ConvolveOp.EDGE_ZERO_FILL, null);\n+\n+        convolve3x3noop = new ConvolveOp(k3, ConvolveOp.EDGE_NO_OP, null);\n+        convolve5x5noop = new ConvolveOp(k5, ConvolveOp.EDGE_NO_OP, null);\n+        convolve7x7noop = new ConvolveOp(k7, ConvolveOp.EDGE_NO_OP, null);\n+    }\n+\n+    public void paint(Graphics g) {\n+\n+        VolatileImage vimg = createVolatileImage(TESTW, TESTH);\n+        vimg.validate(getGraphicsConfiguration());\n+\n+        Graphics2D g2d = vimg.createGraphics();\n+        renderTest(g2d);\n+        g2d.dispose();\n+\n+        g.drawImage(vimg, 0, 0, null);\n+    }\n+\n+    \/*\n+     * foreach source image size (once with pow2, once with non-pow2)\n+     *\n+     *   foreach BufferedImage type\n+     *\n+     *     RescaleOp (1 band)\n+     *     RescaleOp (3 bands, if src has 3 bands)\n+     *     RescaleOp (4 bands, if src has 4 bands)\n+     *\n+     *     foreach LookupTable type (once with ByteLUT, once with ShortLUT)\n+     *       LookupOp (1 band)\n+     *       LookupOp (3 bands, if src has 3 bands)\n+     *       LookupOp (4 bands, if src has 4 bands)\n+     *\n+     *     foreach edge condition (once with ZERO_FILL, once with EDGE_NO_OP)\n+     *       ConvolveOp (3x3)\n+     *       ConvolveOp (5x5)\n+     *       ConvolveOp (7x7)\n+     *\/\n+    private void renderTest(Graphics2D g2d) {\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, TESTW, TESTH);\n+\n+        int yorig = 2;\n+        int xinc = 34;\n+        int yinc = srcSizes[0] + srcSizes[1] + 2 + 2;\n+\n+        for (int srcType : srcTypes) {\n+            int y = yorig;\n+\n+            for (int srcSize : srcSizes) {\n+                int x = 2;\n+                System.out.printf(\"type=%d size=%d\\n\", srcType, srcSize);\n+\n+                BufferedImage srcImg = makeSourceImage(srcSize, srcType);\n+                ColorModel srcCM = srcImg.getColorModel();\n+\n+                \/\/ RescaleOp\n+                g2d.drawImage(srcImg, rescale1band, x, y);\n+                x += xinc;\n+                \/\/ REMIND: 3-band RescaleOp.filter() throws IAE for images\n+                \/\/         that contain an alpha channel (bug to be filed)\n+                if (srcCM.getNumColorComponents() == 3 &&\n+                    !(ignore && srcCM.hasAlpha()))\n+                {\n+                    g2d.drawImage(srcImg, rescale3band, x, y);\n+                }\n+                x += xinc;\n+                if (srcCM.getNumComponents() == 4) {\n+                    g2d.drawImage(srcImg, rescale4band, x, y);\n+                }\n+                x += xinc;\n+\n+                \/\/ LookupOp\n+                \/\/ REMIND: Our LUTs are only 256 elements long, so won't\n+                \/\/         currently work with USHORT_GRAY data\n+                if (srcType != BufferedImage.TYPE_USHORT_GRAY) {\n+                    g2d.drawImage(srcImg, lookup1bandbyte, x, y);\n+                    x += xinc;\n+                    if (srcCM.getNumColorComponents() == 3) {\n+                        g2d.drawImage(srcImg, lookup3bandbyte, x, y);\n+                    }\n+                    x += xinc;\n+                    if (srcCM.getNumComponents() == 4) {\n+                        g2d.drawImage(srcImg, lookup4bandbyte, x, y);\n+                    }\n+                    x += xinc;\n+\n+                    \/\/ REMIND: LookupOp.createCompatibleDestImage() throws\n+                    \/\/         IAE for 3BYTE_BGR\/4BYTE_ABGR (bug to be filed)\n+                    if (!(ignore &&\n+                          (srcType == BufferedImage.TYPE_3BYTE_BGR ||\n+                           srcType == BufferedImage.TYPE_4BYTE_ABGR)))\n+                    {\n+                        g2d.drawImage(srcImg, lookup1bandshort, x, y);\n+                        x += xinc;\n+                        \/\/ REMIND: 3-band LookupOp.filter() throws IAE for\n+                        \/\/         images that contain an alpha channel\n+                        \/\/         (bug to be filed)\n+                        if (srcCM.getNumColorComponents() == 3 &&\n+                            !(ignore && srcCM.hasAlpha()))\n+                        {\n+                            g2d.drawImage(srcImg, lookup3bandshort, x, y);\n+                        }\n+                        x += xinc;\n+                        if (srcCM.getNumComponents() == 4) {\n+                            g2d.drawImage(srcImg, lookup4bandshort, x, y);\n+                        }\n+                        x += xinc;\n+                    } else {\n+                        x += 3*xinc;\n+                    }\n+                } else {\n+                    x += 6*xinc;\n+                }\n+\n+                \/\/ ConvolveOp\n+                \/\/ REMIND: ConvolveOp.filter() throws ImagingOpException\n+                \/\/         for 3BYTE_BGR (see 4957775)\n+                if (srcType != BufferedImage.TYPE_3BYTE_BGR) {\n+                    g2d.drawImage(srcImg, convolve3x3zero, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve5x5zero, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve7x7zero, x, y);\n+                    x += xinc;\n+\n+                    g2d.drawImage(srcImg, convolve3x3noop, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve5x5noop, x, y);\n+                    x += xinc;\n+                    g2d.drawImage(srcImg, convolve7x7noop, x, y);\n+                    x += xinc;\n+                } else {\n+                    x += 6*xinc;\n+                }\n+\n+                y += srcSize + 2;\n+            }\n+\n+            yorig += yinc;\n+        }\n+    }\n+\n+    private BufferedImage makeSourceImage(int size, int type) {\n+        int s2 = size\/2;\n+        BufferedImage img = new BufferedImage(size, size, type);\n+        Graphics2D g2d = img.createGraphics();\n+        g2d.setComposite(AlphaComposite.Src);\n+        g2d.setColor(Color.orange);\n+        g2d.fillRect(0, 0, size, size);\n+        g2d.setColor(Color.red);\n+        g2d.fillRect(0, 0, s2, s2);\n+        g2d.setColor(Color.green);\n+        g2d.fillRect(s2, 0, s2, s2);\n+        g2d.setColor(Color.blue);\n+        g2d.fillRect(0, s2, s2, s2);\n+        g2d.setColor(new Color(255, 255, 0, 128));\n+        g2d.fillRect(s2, s2, s2, s2);\n+        g2d.setColor(Color.pink);\n+        g2d.fillOval(s2-3, s2-3, 6, 6);\n+        g2d.dispose();\n+        return img;\n+    }\n+\n+    public BufferedImage makeReferenceImage() {\n+        BufferedImage img = new BufferedImage(TESTW, TESTH,\n+                                              BufferedImage.TYPE_INT_RGB);\n+        Graphics2D g2d = img.createGraphics();\n+        renderTest(g2d);\n+        g2d.dispose();\n+        return img;\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(TESTW, TESTH);\n+    }\n+\n+    private static void compareImages(BufferedImage refImg,\n+                                      BufferedImage testImg,\n+                                      int tolerance)\n+    {\n+        int x1 = 0;\n+        int y1 = 0;\n+        int x2 = refImg.getWidth();\n+        int y2 = refImg.getHeight();\n+\n+        for (int y = y1; y < y2; y++) {\n+            for (int x = x1; x < x2; x++) {\n+                Color expected = new Color(refImg.getRGB(x, y));\n+                Color actual   = new Color(testImg.getRGB(x, y));\n+                if (!isSameColor(expected, actual, tolerance)) {\n+                    saveImage(\"referenceimage\", refImg);\n+                    saveImage(\"testimage\", testImg);\n+                    throw new RuntimeException(\"Test failed at x=\"+x+\" y=\"+y+\n+                                               \" (expected=\"+expected+\n+                                               \" actual=\"+actual+\n+                                               \")\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isSameColor(Color c1, Color c2, int e) {\n+        int r1 = c1.getRed();\n+        int g1 = c1.getGreen();\n+        int b1 = c1.getBlue();\n+        int r2 = c2.getRed();\n+        int g2 = c2.getGreen();\n+        int b2 = c2.getBlue();\n+        int rmin = Math.max(r2-e, 0);\n+        int gmin = Math.max(g2-e, 0);\n+        int bmin = Math.max(b2-e, 0);\n+        int rmax = Math.min(r2+e, 255);\n+        int gmax = Math.min(g2+e, 255);\n+        int bmax = Math.min(b2+e, 255);\n+        if (r1 >= rmin && r1 <= rmax &&\n+            g1 >= gmin && g1 <= gmax &&\n+            b1 >= bmin && b1 <= bmax)\n+        {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+\n+    static void createUI() {\n+        test = new DrawBufImgOp();\n+        Panel panel = new Panel();\n+        panel.add(test);\n+        frame = new Frame(\"OpenGL DrawBufImgOp Test\");\n+        frame.add(panel);\n+        frame.setSize(TESTW+100, TESTH+100);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean show = false;\n+        boolean dump = false;\n+        boolean compare = false;\n+\n+        for (String arg : args) {\n+            if (arg.equals(\"-show\")) {\n+                show = true;\n+            } else if (arg.equals(\"-dump\")) {\n+                dump = true;\n+            } else if (arg.equals(\"-compare\")) {\n+                compare = true;\n+            } else if (arg.equals(\"-ignore\")) {\n+                ignore = true;\n+            }\n+        }\n+\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(DrawBufImgOp::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, TESTW, TESTH);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Compare the images (allow for +\/- 1 bit differences in color comps)\n+        if (dump || compare) {\n+            BufferedImage ref = test.makeReferenceImage();\n+            if (dump) {\n+                saveImage(\"DrawBufImgOp_ref\", ref);\n+                saveImage(\"DrawBufImgOp_cap\", capture);\n+            }\n+            if (compare) {\n+                test.compareImages(ref, capture, 1);\n+            }\n+        }\n+    }\n+\n+    static void saveImage(String name, BufferedImage img) {\n+        try {\n+            File file = new File(name + \".png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/DrawBufImgOp.java","additions":514,"deletions":0,"binary":false,"changes":514,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4993274\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that managed image copies and transforms work properly\n+ * with the OGL pipeline when a background color is specified.\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawImageBg\n+ * @run main\/othervm DrawImageBg\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4993274\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that managed image copies and transforms work properly\n+ * with the OGL pipeline when a background color is specified.\n+ * @run main\/othervm -Dsun.java2d.opengl=True DrawImageBg\n+ * @run main\/othervm DrawImageBg\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Transparency;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class DrawImageBg extends Panel {\n+\n+    static volatile Frame frame;\n+    static volatile DrawImageBg test;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        BufferedImage img = getGraphicsConfiguration().createCompatibleImage(50, 50,\n+                                                   Transparency.BITMASK);\n+        Graphics2D gimg = img.createGraphics();\n+        gimg.setComposite(AlphaComposite.Src);\n+        gimg.setColor(new Color(0, 0, 0, 0));\n+        gimg.fillRect(0, 0, 50, 50);\n+        gimg.setColor(Color.red);\n+        gimg.fillRect(10, 10, 30, 30);\n+        gimg.dispose();\n+\n+        g2d.drawImage(img, 10, 10, Color.blue, null);\n+\n+        \/\/ draw a second time to ensure that the cached copy is used\n+        g2d.drawImage(img, 80, 10, Color.blue, null);\n+    }\n+\n+    static void createUI() {\n+        frame = new Frame(\"OpenGL DrawImageBg Test\");\n+        test = new DrawImageBg();\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        BufferedImage capture = null;\n+        Robot robot = new Robot();\n+        try {\n+            EventQueue.invokeAndWait(DrawImageBg::createUI);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            \/\/ Grab the screen region\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x+80, pt1.y, 80, 80);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        if (capture == null) {\n+            throw new RuntimeException(\"Screen capture is null\");\n+        }\n+\n+        \/\/ Test inner and outer pixels\n+        int pixel1 = capture.getRGB(5, 10);\n+        if (pixel1 != 0xff0000ff) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"outer\", pixel1));\n+        }\n+        int pixel2 = capture.getRGB(25, 25);\n+        if (pixel2 != 0xffff0000) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"inner\", pixel2));\n+        }\n+    }\n+\n+    static String getMsg(String r, int p1) {\n+         return \"Failed: Incorrect color for \" + r + \" pixel: got \" + Integer.toHexString(p1);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/DrawImageBg.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6219284 6358147 6274813 6578452\n+ * @key headful\n+ * @summary Verifies that OGLRenderer.drawPoly(),\n+ * OGLTextRenderer.drawGlyphList(), and OGLMaskFill work properly when the\n+ * operation parameters exceed the capacity of the render queue.  With the\n+ * single-threaded OpenGL pipeline, there are some operations that require\n+ * a separate buffer to be spawned if the parameters cannot fit entirely on\n+ * the standard buffer.  This test exercises this special case.\n+ * @run main\/othervm  -Dsun.java2d.opengl=True -Dsun.java2d.opengl.lcdshader=true LargeOps\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class LargeOps extends Canvas {\n+\n+    private static final int NUM_POINTS = 8000;\n+    private int[] xPoints, yPoints;\n+    private String str;\n+\n+    public LargeOps() {\n+        xPoints = new int[NUM_POINTS];\n+        yPoints = new int[NUM_POINTS];\n+        for (int i = 0; i < NUM_POINTS; i++) {\n+            xPoints[i] = (i % 2 == 0) ? 10 : 400;\n+            yPoints[i] = (i % 2 == 1) ? i+3 : i;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < NUM_POINTS; i+=11) {\n+            sb.append(\"ThisIsATest\");\n+        }\n+        str = sb.toString();\n+    }\n+\n+    public void paint(Graphics g) {\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        \/\/ draw large polyline\n+        g2d.setColor(Color.green);\n+        g2d.drawPolyline(xPoints, yPoints, NUM_POINTS);\n+\n+        \/\/ draw long string\n+        g2d.setColor(Color.blue);\n+        g2d.drawString(str, 10, 100);\n+\n+        \/\/ draw long string with larger pt size\n+        Font font = g2d.getFont();\n+        g2d.setFont(font.deriveFont(40.0f));\n+        g2d.drawString(str, 10, 150);\n+\n+        \/\/ do the same with LCD hints enabled\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                             RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);\n+        g2d.setFont(font);\n+        g2d.drawString(str, 10, 200);\n+        g2d.setFont(font.deriveFont(43.0f));\n+        g2d.drawString(str, 10, 250);\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                             RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HBGR);\n+        g2d.setFont(font);\n+        g2d.drawString(str, 10, 300);\n+        g2d.setFont(font.deriveFont(37.0f));\n+        g2d.drawString(str, 10, 350);\n+    }\n+\n+    static volatile Frame frame;\n+    static volatile LargeOps test;\n+\n+    static void createUI() {\n+        frame = new Frame(\"OpenGL LargeOps Test\");\n+        frame.addWindowListener(new WindowAdapter() {\n+                public void windowClosing(WindowEvent e) {\n+                    frame.dispose();\n+                }\n+            });\n+        test = new LargeOps();\n+        frame.add(test);\n+        frame.setSize(600, 600);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+             Robot robot = new Robot();\n+             EventQueue.invokeAndWait(LargeOps::createUI);\n+             robot.waitForIdle();\n+             robot.delay(6000);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/LargeOps.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6277977 6319663\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that blending operations do not inadvertantly leave\n+ * non-opaque alpha values in the framebuffer.  Note that this test is\n+ * intended to run on GraphicsConfigs that support a stored alpha channel\n+ * (to verify the bug at hand), but it is also a useful for testing the\n+ * compositing results on any configuration.\n+ * @run main\/othervm  -Dsun.java2d.opengl=True OpaqueDest\n+ * @run main\/othervm  OpaqueDest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6277977 6319663\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that blending operations do not inadvertantly leave\n+ * non-opaque alpha values in the framebuffer.  Note that this test is\n+ * intended to run on GraphicsConfigs that support a stored alpha channel\n+ * (to verify the bug at hand), but it is also a useful for testing the\n+ * compositing results on any configuration.\n+ * @run main\/othervm -Dsun.java2d.opengl=True OpaqueDest\n+ * @run main\/othervm  OpaqueDest\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class OpaqueDest extends Canvas {\n+\n+    private static volatile Frame frame;\n+    private static volatile OpaqueDest test;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        g2d.setColor(Color.red);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        \/\/ This will clear the rectangle to black\n+        g2d.setComposite(AlphaComposite.Clear);\n+        g2d.fillRect(10, 10, 80, 80);\n+\n+        \/\/ If everything is working properly, then this will fill the\n+        \/\/ rectangle with red again.  Before this bug was fixed, the previous\n+        \/\/ Clear operation would leave zero values in the destination's\n+        \/\/ alpha channel (if present), and therefore a SrcIn operation\n+        \/\/ would result in all-black.\n+        g2d.setComposite(AlphaComposite.SrcIn);\n+        g2d.fillRect(10, 10, 80, 80);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(100, 100);\n+    }\n+\n+    static void createUI() {\n+        test = new OpaqueDest();\n+        frame = new Frame(\"OpenGL OpaqueDest Test\");\n+        Panel p = new Panel();\n+        p.add(test);\n+        frame.add(p);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(OpaqueDest::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 100, 100);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+\n+        \/\/ Test all pixels (every one should be red)\n+        for (int y = 0; y < 100; y++) {\n+            for (int x = 0; x < 100; x++) {\n+                int actual = capture.getRGB(x, y);\n+                    int expected = 0xffff0000;\n+                if (!similar(actual, expected)) {\n+                    saveImage(capture);\n+                    throw new RuntimeException(\"Test failed at x=\"+x+\" y=\"+y+\n+                                               \" (expected=\"+\n+                                               Integer.toHexString(expected) +\n+                                               \" actual=\"+\n+                                               Integer.toHexString(actual) +\n+                                               \")\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static boolean similar(int p1, int p2) {\n+        int a1 = (p1 >> 24) & 0xff;\n+        int r1 = (p1 >> 16) & 0xff;\n+        int g1 = (p1 >> 8) & 0xff;\n+        int b1 = p1 & 0xff;\n+        int a2 = (p2 >> 24) & 0xff;\n+        int r2 = (p2 >> 16) & 0xff;\n+        int g2 = (p2 >> 8) & 0xff;\n+        int b2 = p2 & 0xff;\n+\n+        int allowedDiff = 0x01; \/\/ tiny rounding error allowed.\n+        return\n+            (Math.abs(a1 - a2) <= allowedDiff) &&\n+            (Math.abs(r1 - r2) <= allowedDiff) &&\n+            (Math.abs(g1 - g2) <= allowedDiff) &&\n+            (Math.abs(b1 - b2) <= allowedDiff);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/OpaqueDest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5104584 8237244\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that scaling an image works properly when the\n+ * source parameters are outside the source bounds.\n+ * @run main\/othervm -Dsun.java2d.opengl=True ScaleParamsOOB\n+ * @run main\/othervm ScaleParamsOOB\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5104584 8237244\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that scaling an image works properly when the\n+ * source parameters are outside the source bounds.\n+ * @run main\/othervm -Dsun.java2d.opengl=True ScaleParamsOOB\n+ * @run main\/othervm ScaleParamsOOB\n+ *\/\n+\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class ScaleParamsOOB extends Panel {\n+\n+    private static final int TOLERANCE = 12;\n+\n+    private static volatile ScaleParamsOOB test;\n+    private static volatile Frame frame;\n+\n+    private BufferedImage img;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        BufferedImage img = getGraphicsConfiguration().createCompatibleImage(40, 40);\n+        Graphics2D gimg = img.createGraphics();\n+        gimg.setColor(Color.red);\n+        gimg.fillRect(0, 0, 40, 40);\n+        gimg.dispose();\n+\n+        \/\/ first time will be a sw->surface blit\n+        g2d.drawImage(img,\n+                      10, 10, 90, 90,\n+                      -60, -60, 100, 100,\n+                      null);\n+\n+        \/\/ second time will be a texture->surface blit\n+        g2d.drawImage(img,\n+                      110, 10, 190, 90,\n+                      -60, -60, 100, 100,\n+                      null);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(300, 200);\n+    }\n+\n+    private static void testRegion(BufferedImage bi,\n+                                   Rectangle wholeRegion,\n+                                   Rectangle affectedRegion)\n+    {\n+        int x1 = wholeRegion.x;\n+        int y1 = wholeRegion.y;\n+        int x2 = x1 + wholeRegion.width;\n+        int y2 = y1 + wholeRegion.height;\n+\n+        for (int y = y1; y < y2; y++) {\n+            for (int x = x1; x < x2; x++) {\n+                int actual = bi.getRGB(x, y);\n+                int expected = 0;\n+                if (affectedRegion.contains(x, y)) {\n+                    expected = Color.red.getRGB();\n+                } else {\n+                    expected = Color.black.getRGB();\n+                }\n+                int alpha = (actual >> 24) & 0xFF;\n+                int red = (actual >> 16) & 0xFF;\n+                int green = (actual >> 8) & 0xFF;\n+                int blue = (actual) & 0xFF;\n+\n+                int standardAlpha = (expected >> 24) & 0xFF;\n+                int standardRed = (expected >> 16) & 0xFF;\n+                int standardGreen = (expected >> 8) & 0xFF;\n+                int standardBlue = (expected) & 0xFF;\n+\n+                if ((Math.abs(alpha - standardAlpha) > TOLERANCE) ||\n+                    (Math.abs(red - standardRed) > TOLERANCE) ||\n+                    (Math.abs(green - standardGreen) > TOLERANCE) ||\n+                    (Math.abs(blue - standardBlue) > TOLERANCE)) {\n+                    saveImage(bi);\n+                    throw new RuntimeException(\"Test failed at x=\"+x+\" y=\"+y+\n+                                               \" (expected=\"+\n+                                               Integer.toHexString(expected) +\n+                                               \" actual=\"+\n+                                               Integer.toHexString(actual) +\n+                                               \")\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void createAndShowGUI() {\n+        test = new ScaleParamsOOB();\n+        frame = new Frame(\"OpenGL ScaleParamsOOB Test\");\n+        frame.setAlwaysOnTop(true);\n+        frame.add(test);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(() -> createAndShowGUI());\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        \/\/ Grab the screen region\n+        BufferedImage capture = null;\n+        try {\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 200, 200);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test background color\n+        int pixel = capture.getRGB(5, 5);\n+        if (pixel != 0xff000000) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"background: \" + Integer.toHexString(pixel));\n+        }\n+\n+        \/\/ Test pixels\n+        testRegion(capture,\n+                   new Rectangle(5, 5, 90, 90),\n+                   new Rectangle(40, 40, 20, 20));\n+        testRegion(capture,\n+                   new Rectangle(105, 5, 90, 90),\n+                   new Rectangle(140, 40, 20, 20));\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/ScaleParamsOOB.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5002133\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that the OpenGL pipeline does not affect the color\n+ * buffer when setting up a complex (shape) clip region.  The test fails if\n+ * the circular clip region is filled with a green color (the green region\n+ * should not be visible at all).\n+ * @run main\/othervm -Dsun.java2d.opengl=True ShapeClip\n+ * @run main\/othervm ShapeClip\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5002133\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that the OpenGL pipeline does not affect the color\n+ * buffer when setting up a complex (shape) clip region.  The test fails if\n+ * the circular clip region is filled with a green color (the green region\n+ * should not be visible at all).\n+ * @run main\/othervm -Dsun.java2d.opengl=True ShapeClip\n+ * @run main\/othervm ShapeClip\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class ShapeClip extends Panel {\n+\n+    private static volatile Frame frame;\n+    private static volatile ShapeClip test;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        int width = getWidth();\n+        int height = getHeight();\n+\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, width, height);\n+\n+        g2d.setColor(Color.green);\n+        g2d.fillRect(0, 0, 1, 1);\n+        g2d.setClip(new Ellipse2D.Double(10, 10, 100, 100));\n+        g2d.setColor(Color.blue);\n+        g2d.fillRect(30, 30, 20, 20);\n+    }\n+\n+    static void createUI() {\n+        test = new ShapeClip();\n+        frame = new Frame(\"OpenGL ShapeClip Test\");\n+        frame.add(test);\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(ShapeClip::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        \/\/ Grab the screen region\n+        BufferedImage capture = null;\n+        try {\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 80, 80);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test blue rectangle\n+        int pixel1 = capture.getRGB(40, 40);\n+        if (pixel1 != 0xff0000ff) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"rectangle \" + Integer.toHexString(pixel1));\n+        }\n+\n+        \/\/ Test clip region (should be same color as background)\n+        int pixel2 = capture.getRGB(60, 40);\n+        if (pixel2 != 0xff000000) {\n+            saveImage(capture);\n+            throw new RuntimeException(\"Failed: Incorrect color for \" +\n+                                       \"clip region \" + Integer.toHexString(pixel2));\n+        }\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/ShapeClip.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4942939 4970674\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that OGLMaskFill, OGLMaskBlit, and OGLTextRenderer\n+ * operations work properly for non-SrcOver composites.\n+ * @run main\/othervm -Dsun.java2d.opengl=True SrcMaskOps\n+ * @run main\/othervm SrcMaskOps\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4942939 4970674\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that OGLMaskFill, OGLMaskBlit, and OGLTextRenderer\n+ * operations work properly for non-SrcOver composites.\n+ * @run main\/othervm -Dsun.java2d.opengl=True SrcMaskOps\n+ * @run main\/othervm SrcMaskOps\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class SrcMaskOps extends Panel {\n+\n+    static volatile Frame frame;\n+    static volatile SrcMaskOps test;\n+\n+    static final int SRX = 50;\n+    static final int SRY = 50;\n+    static final int GPX = 90;\n+    static final int GPY = 50;\n+    static final int DTX = 120;\n+    static final int DTY = 70;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_ON);\n+        g2d.setComposite(AlphaComposite.Src);\n+\n+        g2d.setColor(Color.blue);\n+        g2d.drawRect(SRX, SRY, 20, 20);\n+\n+        g2d.setPaint(new GradientPaint(0.0f, 0.0f, Color.red,\n+                                       100.0f, 100.f, Color.red, true));\n+        g2d.drawRect(GPX, GPY, 20, 20);\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_OFF);\n+\n+        g2d.setColor(Color.red);\n+        Font font = new Font(Font.DIALOG, Font.PLAIN, 20);\n+        g2d.setFont(font);\n+        g2d.drawString(\"HELLO\", DTX, DTY);\n+    }\n+\n+    static void createUI() {\n+        frame = new Frame(\"OpenGL SrcMaskOps Test\");\n+        test = new SrcMaskOps();\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Robot robot = new Robot();\n+        BufferedImage capture = null;\n+        try {\n+            EventQueue.invokeAndWait(SrcMaskOps::createUI);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            \/\/ Grab the screen region\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 300, 300);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test solid rectangle\n+        int pixel1, pixel2;\n+        pixel1 = capture.getRGB(SRX, SRY);\n+        pixel2 = capture.getRGB(SRX+2, SRY+2);\n+        if (!similar(pixel1, 0xff0000ff) || !similar(pixel2, 0xffffffff)) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"solid rectangle\", pixel1, pixel2));\n+        }\n+\n+        \/\/ Test GradientPaint rectangle\n+        pixel1 = capture.getRGB(GPX, GPY);\n+        pixel2 = capture.getRGB(GPX+2, GPY+2);\n+        if (!similar(pixel1, 0xffff0000) || !similar(pixel2, 0xffffffff)) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"GradientPaint rectangle\", pixel1, pixel2));\n+        }\n+\n+        \/\/ Test solid text\n+        pixel1 = capture.getRGB(DTX+2, DTY-5);\n+        pixel2 = capture.getRGB(DTX+5, DTY-5);\n+        if (!similar(pixel1, 0xffff0000) || !similar(pixel2, 0xffffffff)) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"solid text\", pixel1, pixel2));\n+        }\n+\n+    }\n+\n+    static boolean similar(int p1, int p2) {\n+        int a1 = (p1 >> 24) & 0xff;\n+        int r1 = (p1 >> 16) & 0xff;\n+        int g1 = (p1 >> 8) & 0xff;\n+        int b1 = p1 & 0xff;\n+        int a2 = (p2 >> 24) & 0xff;\n+        int r2 = (p2 >> 16) & 0xff;\n+        int g2 = (p2 >> 8) & 0xff;\n+        int b2 = p2 & 0xff;\n+\n+        int allowedDiff = 0x10;\n+        return\n+            (Math.abs(a1 - a2) <= allowedDiff) &&\n+            (Math.abs(r1 - r2) <= allowedDiff) &&\n+            (Math.abs(g1 - g2) <= allowedDiff) &&\n+            (Math.abs(b1 - b2) <= allowedDiff);\n+    }\n+\n+    static String getMsg(String r, int p1, int p2) {\n+         return \"Failed: Incorrect color[s] for \" + r + \" got \" +\n+                Integer.toHexString(p1) + \" and \" + Integer.toHexString(p2);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/SrcMaskOps.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6244071\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that copying a subregion from a VolatileImage works\n+ * properly with the OGL pipeline.\n+ * @run main\/othervm  VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=true VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=false VolatileSubRegion\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6244071\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that copying a subregion from a VolatileImage works\n+ * properly with the OGL pipeline.\n+ * @run main\/othervm VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=true VolatileSubRegion\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=false VolatileSubRegion\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.VolatileImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class VolatileSubRegion extends Panel {\n+\n+    private VolatileImage img;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        if (img == null) {\n+            img = createVolatileImage(200, 200);\n+            Graphics2D goff = img.createGraphics();\n+            goff.setColor(Color.green);\n+            goff.fillRect(50, 0, 100, 50);\n+            goff.setColor(Color.blue);\n+            goff.fillRect(0, 0, 200, 200);\n+            goff.setColor(Color.red);\n+            goff.fillRect(50, 50, 100, 100);\n+            goff.setColor(Color.yellow);\n+            goff.fillRect(50, 150, 100, 50);\n+            goff.dispose();\n+        }\n+\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        g2d.drawImage(img,\n+                      50, 50, 200, 200,\n+                      50, 50, 200, 200,\n+                      null);\n+\n+    }\n+\n+\n+    private static volatile VolatileSubRegion test;\n+    private static volatile Frame frame;\n+\n+    static void createUI() {\n+        test = new VolatileSubRegion();\n+        frame = new Frame(\"OpenGL VolatileSubRegion Test\");\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(VolatileSubRegion::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        BufferedImage capture = null;\n+        try {\n+            GraphicsConfiguration gc = frame.getGraphicsConfiguration();\n+            if (gc.getColorModel() instanceof IndexColorModel) {\n+                System.out.println(\"IndexColorModel detected: \" +\n+                                   \"test considered PASSED\");\n+                return;\n+            }\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 200, 200);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+            if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+\n+        \/\/ Test pixels\n+        int pixel1 = capture.getRGB(49, 50);\n+        if (pixel1 != 0xffffffff) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"background pixel\", pixel1));\n+        }\n+        int pixel2 = capture.getRGB(50, 50);\n+        if (pixel2 != 0xffff0000) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"red region\", pixel2));\n+        }\n+        int pixel3 = capture.getRGB(50, 150);\n+        if (pixel3 != 0xffffff00) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"yellow region\", pixel3));\n+        }\n+    }\n+\n+    static String getMsg(String r, int p1) {\n+         return \"Failed: Incorrect color for \" + r + \" : got \" + Integer.toHexString(p1);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/VolatileSubRegion.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4970836\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @summary Verifies that transformed VolatileImage copies work properly with\n+ * the OGL pipeline.\n+ * @run main\/othervm XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=true XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=false XformVolatile\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4970836\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @summary Verifies that transformed VolatileImage copies work properly with\n+ * the OGL pipeline.\n+ * @run main\/othervm XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=true XformVolatile\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.opengl.fbobject=false XformVolatile\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+\n+public class XformVolatile extends Panel {\n+\n+    private static volatile Frame frame;\n+    private static volatile XformVolatile test;\n+    private volatile VolatileImage img;\n+\n+    public void paint(Graphics g) {\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        if (img == null) {\n+            img = createVolatileImage(200, 200);\n+            Graphics2D goff = img.createGraphics();\n+            goff.setColor(Color.blue);\n+            goff.fillRect(0, 0, 200, 200);\n+            goff.setColor(Color.red);\n+            goff.fillPolygon(new int[] {10, 100, 190},\n+                             new int[] {190, 10, 190}, 3);\n+            goff.dispose();\n+        }\n+\n+        g2d.setColor(Color.black);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        g2d.rotate(Math.toRadians(3.0));\n+        g2d.drawImage(img, 0, 0, null);\n+    }\n+\n+    static void createUI() {\n+        test = new XformVolatile();\n+        frame = new Frame(\"OpenGL XformVolatile Test\");\n+        frame.add(test);\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Robot robot = new Robot();\n+\n+        EventQueue.invokeAndWait(XformVolatile::createUI);\n+\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+\n+        \/\/ Grab the screen region\n+        BufferedImage capture = null;\n+        try {\n+            Point pt1 = test.getLocationOnScreen();\n+            Rectangle rect = new Rectangle(pt1.x, pt1.y, 200, 200);\n+            capture = robot.createScreenCapture(rect);\n+        } finally {\n+             if (frame != null) {\n+                 EventQueue.invokeAndWait(frame::dispose);\n+             }\n+        }\n+\n+        \/\/ Test inner and outer pixels\n+        int pixel1 = capture.getRGB(5, 175);\n+        if (pixel1 != 0xff0000ff) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"inner\", pixel1));\n+        }\n+        int pixel2 = capture.getRGB(5, 188);\n+        if (pixel2 != 0xffff0000) {\n+            saveImage(capture);\n+            throw new RuntimeException(getMsg(\"inner\", pixel2));\n+        }\n+    }\n+\n+    static String getMsg(String r, int p1) {\n+         return \"Failed: Incorrect color for \" + r + \" pixel: got \" + Integer.toHexString(p1);\n+    }\n+\n+    static void saveImage(BufferedImage img) {\n+        try {\n+            File file = new File(\"capture.png\");\n+            ImageIO.write(img, \"png\", file);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/OpenGL\/XformVolatile.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- *          jdk.httpserver\n@@ -33,1 +32,0 @@\n- *        jdk.test.lib.net.SimpleHttpServer\n@@ -54,0 +52,1 @@\n+import java.nio.file.Path;\n@@ -56,0 +55,2 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -58,1 +59,2 @@\n-import jdk.test.lib.net.SimpleHttpServer;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n@@ -71,2 +73,2 @@\n-    static final String TESTCONTEXT = \"\/multi-release.jar\";\n-    SimpleHttpServer server;\n+    HttpServer server;\n+    ExecutorService executor;\n@@ -81,1 +83,4 @@\n-        server = new SimpleHttpServer(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), TESTCONTEXT, System.getProperty(\"user.dir\", \".\"));\n+        server = SimpleFileServer.createFileServer(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0),\n+                Path.of(System.getProperty(\"user.dir\", \".\")), SimpleFileServer.OutputLevel.INFO);\n+        executor = Executors.newCachedThreadPool();\n+        server.setExecutor(executor);\n@@ -89,1 +94,3 @@\n-            server.stop();\n+            server.stop(0);\n+            executor.shutdown();\n+\n@@ -179,2 +186,2 @@\n-                {\"http\", toHttpJarURL(server.getPort(), \"\/multi-release.jar\", \"!\/\")},\n-                {\"http\", URIBuilder.newBuilder().scheme(\"http\").port(server.getPort())\n+                {\"http\", toHttpJarURL(server.getAddress().getPort(), \"\/multi-release.jar\", \"!\/\")},\n+                {\"http\", URIBuilder.newBuilder().scheme(\"http\").port(server.getAddress().getPort())\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/jar\/MultiReleaseJarURLConnection.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-   @bug 4691554 6221056 6380723 6404504 6419565 6529796 8301119\n+   @bug 4691554 6221056 6380723 6404504 6419565 6529796 8301119 8368845\n","filename":"test\/jdk\/sun\/nio\/cs\/mapping\/CoderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n- * @bug 4199484 4199599 4199601 4199602 4159519 4201529 4199604 4201532 4947038 6217210\n+ * @bug 4199484 4199599 4199601 4199602 4159519 4201529 4199604 4201532 4947038\n+ *      6217210 8368845\n","filename":"test\/jdk\/sun\/nio\/cs\/mapping\/ConverterTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-0E42600F    2212\n+0E42600F    FF0D\n","filename":"test\/jdk\/sun\/nio\/cs\/mapping\/Cp930.b2c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-   @bug 4179153 4652234 6529796\n+   @bug 4179153 4652234 6529796 8368845\n","filename":"test\/jdk\/sun\/nio\/cs\/mapping\/TestConv.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8014618\n+ * @bug 8014618 8368694\n@@ -90,0 +90,20 @@\n+        \/\/ generate generic shared secret\n+        aliceKeyAgree.init(alicePrivKey);\n+        aliceKeyAgree.doPhase(bobPubKey, true);\n+        byte[] genericSecret =\n+                aliceKeyAgree.generateSecret(\"Generic\").getEncoded();\n+        System.out.println(\"generic secret:\\n\" + HEX.formatHex(genericSecret));\n+\n+        \/\/ verify that leading zero is present\n+        if (genericSecret.length != 128) {\n+            throw new Exception(\"Unexpected generic secret length\");\n+        }\n+        if (genericSecret[0] != 0) {\n+            throw new Exception(\"First byte is not zero as expected\");\n+        }\n+        for (int i = 0; i < genericSecret.length; i++) {\n+            if (genericSecret[i] != sharedSecret[i]) {\n+                throw new Exception(\"Shared secrets differ\");\n+            }\n+        }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestLeadingZeroesP11.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8029661 8325164 8368073 8368514\n+ * @bug 8029661 8325164 8368073 8368514 8368520\n@@ -91,0 +91,3 @@\n+        \/\/ reduce the limit to trigger a key update later\n+        Security.setProperty(\"jdk.tls.keyLimits\",\n+                \"AES\/GCM\/NoPadding KeyUpdate 10000\");\n@@ -308,0 +311,1 @@\n+                \/\/ big enough to trigger a key update\n@@ -309,1 +313,1 @@\n-                        \"Hi Server, I'm Client\".getBytes());\n+                        \"a\".repeat(16000).getBytes());\n@@ -311,1 +315,1 @@\n-                        \"Hello Client, I'm Server\".getBytes());\n+                        \"b\".repeat(16000).getBytes());\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/FipsModeTLS.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,1 +66,9 @@\n-import javax.swing.*;\n+import javax.swing.JDialog;\n+import javax.swing.SwingUtilities;\n+import javax.swing.JTextArea;\n+import javax.swing.JButton;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JFrame;\n+import java.awt.FlowLayout;\n+import java.awt.BorderLayout;\n@@ -71,0 +79,2 @@\n+import static javax.swing.BorderFactory.createEmptyBorder;\n+\n@@ -237,1 +247,1 @@\n-                            + \"must not be specified.\"},\n+                            + \"must not be specified.\"}\n@@ -242,0 +252,1 @@\n+    private volatile String failureReason = \"\";\n@@ -333,0 +344,1 @@\n+                System.out.println(\"REASON: \" + failureReason);\n@@ -351,0 +363,1 @@\n+        failureReason = requestFailDescription();\n@@ -358,0 +371,29 @@\n+\n+    \/**\n+     * Opens a prompt to enter a failure reason to be filled by the tester\n+     *\/\n+     public static String requestFailDescription() {\n+\n+        final JDialog dialogWindow = new JDialog(new JFrame(), \"Failure Description\", true);\n+        final JTextArea reasonTextArea = new JTextArea(5, 20);\n+\n+        final JButton okButton = new JButton(\"OK\");\n+        okButton.addActionListener(_ -> dialogWindow.setVisible(false));\n+\n+        final JPanel okayBtnPanel = new JPanel(\n+                new FlowLayout(FlowLayout.CENTER, 4, 0));\n+        okayBtnPanel.setBorder(createEmptyBorder(4, 0, 0, 0));\n+        okayBtnPanel.add(okButton);\n+\n+        final JPanel mainPanel = new JPanel(new BorderLayout());\n+        mainPanel.add(new JScrollPane(reasonTextArea), BorderLayout.CENTER);\n+        mainPanel.add(okayBtnPanel, BorderLayout.SOUTH);\n+\n+        dialogWindow.add(mainPanel);\n+        dialogWindow.pack();\n+        dialogWindow.setVisible(true);\n+\n+        dialogWindow.dispose();\n+\n+        return reasonTextArea.getText();\n+    }\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/i18n.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8331051\n+ * @bug 8331051 8367610\n@@ -29,1 +29,1 @@\n- * @run main SinceChecker java.base --ignoreSince Valhalla --exclude java.lang.classfile\n+ * @run main\/timeout=480 SinceChecker java.base --ignoreSince Valhalla --exclude java.lang.classfile\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.base\/JavaBaseCheckSince.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -430,1 +430,2 @@\n-                    loadScripts(document, 'script');\"\"\",\n+                    loadScripts();\n+                    initTheme();\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8266666 8275788 8276964 8299080\n+ * @bug 8266666 8275788 8276964 8299080 8276966\n@@ -2169,0 +2169,1 @@\n+                        --------------------------------------------\n@@ -2210,2 +2211,10 @@\n-                    \"\"\"\n-                    A.java:4: error: contents mismatch\"\"\");\n+                \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\",\n+                \"\"\"\n+                      ----------------- inline -------------------\n+                      Hello, Snippet! ...more\n+                    \\s\\s\n+                      ----------------- external -----------------\n+                      Hello, Snippet!\n+                    \\s\\s\n+                      --------------------------------------------\"\"\");\n@@ -2222,0 +2231,1 @@\n+                        --------------------------------------------\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+WerrorLint.java:20:19: compiler.warn.strictfp\n+- compiler.err.warnings.and.werror\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/WerrorLint.e1.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+WerrorLint.java:20:19: compiler.warn.strictfp\n+WerrorLint.java:21:30: compiler.warn.empty.if\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/WerrorLint.e2.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8349847\n+ *\n+ * @compile                             -XDrawDiagnostics -Xlint:none                         WerrorLint.java\n+ * @compile                             -XDrawDiagnostics -Xlint:none     -Werror             WerrorLint.java\n+ * @compile                             -XDrawDiagnostics -Xlint:none     -Werror:empty       WerrorLint.java\n+ * @compile                             -XDrawDiagnostics -Xlint:none     -Werror:strictfp    WerrorLint.java\n+ * @compile\/ref=WerrorLint.w2.out       -XDrawDiagnostics -Xlint:all                          WerrorLint.java\n+ * @compile\/fail\/ref=WerrorLint.e2.out  -XDrawDiagnostics -Xlint:all      -Werror             WerrorLint.java\n+ * @compile\/fail\/ref=WerrorLint.e2.out  -XDrawDiagnostics -Xlint:all      -Werror:empty       WerrorLint.java\n+ * @compile\/fail\/ref=WerrorLint.e2.out  -XDrawDiagnostics -Xlint:all      -Werror:strictfp    WerrorLint.java\n+ * @compile\/ref=WerrorLint.w1.out       -XDrawDiagnostics                                     WerrorLint.java\n+ * @compile\/fail\/ref=WerrorLint.e1.out  -XDrawDiagnostics                 -Werror             WerrorLint.java\n+ * @compile\/ref=WerrorLint.w1.out       -XDrawDiagnostics                 -Werror:empty       WerrorLint.java\n+ * @compile\/fail\/ref=WerrorLint.e1.out  -XDrawDiagnostics                 -Werror:strictfp    WerrorLint.java\n+ *\/\n+\n+class WerrorLint {\n+    strictfp void m() {             \/\/ [strictfp] - this category is enabled by default\n+        if (hashCode() == 1) ;      \/\/ [empty]    - this category is disabled by default\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/WerrorLint.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+WerrorLint.java:20:19: compiler.warn.strictfp\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/warnings\/WerrorLint.w1.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+WerrorLint.java:20:19: compiler.warn.strictfp\n+WerrorLint.java:21:30: compiler.warn.empty.if\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/WerrorLint.w2.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.test.lib.net;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.net.InetSocketAddress;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.nio.file.FileSystemNotFoundException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-\/**\n- * A simple HTTP Server.\n- **\/\n-public class SimpleHttpServer {\n-    private final HttpServer httpServer;\n-    private ExecutorService executor;\n-    private String address;\n-    private final String context;\n-    private final String docRoot;\n-    private final InetSocketAddress inetSocketAddress;\n-\n-    public SimpleHttpServer(final InetSocketAddress inetSocketAddress, final String context, final String docRoot)\n-            throws IOException {\n-        this.inetSocketAddress = inetSocketAddress;\n-        this.context = context;\n-        this.docRoot = docRoot;\n-        httpServer = HttpServer.create();\n-    }\n-\n-    public void start() throws IOException, URISyntaxException {\n-        MyHttpHandler handler = new MyHttpHandler(docRoot);\n-        httpServer.bind(inetSocketAddress, 0);\n-        httpServer.createContext(context, handler);\n-        executor = Executors.newCachedThreadPool();\n-        httpServer.setExecutor(executor);\n-        httpServer.start();\n-        address = \"http:\" + URIBuilder.newBuilder().host(httpServer.getAddress().getAddress()).\n-                port(httpServer.getAddress().getPort()).build().toString();\n-    }\n-\n-    public void stop() {\n-        httpServer.stop(0);\n-        executor.shutdown();\n-    }\n-\n-    public String getAddress() {\n-        return address;\n-    }\n-\n-    public int getPort() {\n-        return httpServer.getAddress().getPort();\n-    }\n-\n-    class MyHttpHandler implements HttpHandler {\n-        private final URI rootUri;\n-\n-        MyHttpHandler(final String docroot) {\n-            rootUri = Path.of(docroot).toUri().normalize();\n-        }\n-\n-        public void handle(final HttpExchange t) throws IOException {\n-            try (InputStream is = t.getRequestBody()) {\n-                is.readAllBytes();\n-                Headers rMap = t.getResponseHeaders();\n-                try (OutputStream os = t.getResponseBody()) {\n-                    URI uri = t.getRequestURI();\n-                    String path = uri.getRawPath();\n-                    assert path.isEmpty() || path.startsWith(\"\/\");\n-                    Path fPath;\n-                    try {\n-                        uri = URI.create(\"file:\/\/\" + rootUri.getRawPath() + path).normalize();\n-                        fPath = Path.of(uri);\n-                    } catch (IllegalArgumentException | FileSystemNotFoundException ex) {\n-                        ex.printStackTrace();\n-                        notfound(t, path);\n-                        return;\n-                    }\n-                    byte[] bytes = Files.readAllBytes(fPath);\n-                    String method = t.getRequestMethod();\n-                    if (method.equals(\"HEAD\")) {\n-                        rMap.set(\"Content-Length\", Long.toString(bytes.length));\n-                        t.sendResponseHeaders(200, -1);\n-                        t.close();\n-                    } else if (!method.equals(\"GET\")) {\n-                        t.sendResponseHeaders(405, -1);\n-                        t.close();\n-                        return;\n-                    }\n-                    if (path.endsWith(\".html\") || path.endsWith(\".htm\")) {\n-                        rMap.set(\"Content-Type\", \"text\/html\");\n-                    } else {\n-                        rMap.set(\"Content-Type\", \"text\/plain\");\n-                    }\n-                    t.sendResponseHeaders(200, bytes.length);\n-                    os.write(bytes);\n-                }\n-            }\n-        }\n-        void moved(final HttpExchange t) throws IOException {\n-            Headers req = t.getRequestHeaders();\n-            Headers map = t.getResponseHeaders();\n-            URI uri = t.getRequestURI();\n-            String host = req.getFirst(\"Host\");\n-            String location = \"http:\/\/\" + host + uri.getPath() + \"\/\";\n-            map.set(\"Content-Type\", \"text\/html\");\n-            map.set(\"Location\", location);\n-            t.sendResponseHeaders(301, -1);\n-            t.close();\n-        }\n-        void notfound(final HttpExchange t, final String p) throws IOException {\n-            t.getResponseHeaders().set(\"Content-Type\", \"text\/html\");\n-            t.sendResponseHeaders(404, 0);\n-            try (OutputStream os = t.getResponseBody()) {\n-                String s = \"<h2>File not found<\/h2>\";\n-                s = s + p + \"<p>\";\n-                os.write(s.getBytes());\n-            }\n-            t.close();\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/net\/SimpleHttpServer.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -507,0 +507,6 @@\n+  private native void     relocateNMethodFromMethod0(Executable method, int type);\n+  public         void     relocateNMethodFromMethod(Executable method, int type) {\n+    Objects.requireNonNull(method);\n+    relocateNMethodFromMethod0(method, type);\n+  }\n+  public native void    relocateNMethodFromAddr(long address, int type);\n@@ -862,1 +868,2 @@\n-  public native void busyWait(int cpuTimeMs);\n+  public native void busyWaitCPUTime(int cpuTimeMs);\n+\n@@ -867,2 +874,0 @@\n-  public native long cpuSamplerOutOfStackWalkingIterations();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    assert obj.length == 4;\n+    assert obj.length == 6;\n@@ -56,0 +56,2 @@\n+    code_begin = (Long) obj[4];\n+    isNMethod = (Boolean) obj[5];\n@@ -61,0 +63,2 @@\n+  public final long code_begin;\n+  public final boolean isNMethod;\n@@ -68,0 +72,1 @@\n+        + \", code_begin=\" + code_begin\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/CodeBlob.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}