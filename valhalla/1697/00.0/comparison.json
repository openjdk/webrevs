{"files":[{"patch":"@@ -447,0 +447,3 @@\n+  UTIL_ADD_JVM_ARG_IF_OK([-Xlog:all=off:stdout],boot_jdk_jvmargs,[$JAVA])\n+  UTIL_ADD_JVM_ARG_IF_OK([-Xlog:all=warning:stderr],boot_jdk_jvmargs,[$JAVA])\n+\n","filename":"make\/autoconf\/boot-jdk.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2562,4 +2562,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -234,2 +234,1 @@\n-      if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-          nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -460,42 +459,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On aarch64, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":44,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,2 +144,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -161,8 +159,0 @@\n- private:\n-\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n- public:\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -122,2 +122,0 @@\n-  adjust_unextended_sp();\n-\n@@ -229,1 +227,0 @@\n-  adjust_unextended_sp();\n@@ -479,1 +476,1 @@\n-    assert(sender_pc == nm->deopt_mh_handler_begin() || sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5896,32 +5896,0 @@\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  Address dst(rthread, JavaThread::held_monitor_count_offset());\n-#ifdef ASSERT\n-  ldr(tmp, dst);\n-  increment(tmp);\n-  str(tmp, dst);\n-  Label ok;\n-  tbz(tmp, 63, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#else\n-  increment(dst);\n-#endif\n-}\n-\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  Address dst(rthread, JavaThread::held_monitor_count_offset());\n-#ifdef ASSERT\n-  ldr(tmp, dst);\n-  decrement(tmp);\n-  str(tmp, dst);\n-  Label ok;\n-  tbz(tmp, 63, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#else\n-  decrement(dst);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1026,3 +1026,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1266,2 +1266,0 @@\n-  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n@@ -1270,1 +1268,0 @@\n-  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -1286,44 +1283,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n-    __ cbzw(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ ldr(rscratch1, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-    __ cbz(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ Save return value potentially containing the exception oop in callee-saved R19.\n-    __ mov(r19, r0);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    \/\/ Restore potential return value.\n-    __ mov(r0, r19);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n-    __ cbzw(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -225,2 +225,1 @@\n-        if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-            nm->method()->is_method_handle_intrinsic()) {\n+        if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -449,41 +448,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it) original_pc: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" name: %s\", p2i(original_pc), p2i(unextended_sp), nm->name());\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On x86, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,2 +141,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -153,7 +151,0 @@\n- private:\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n- public:\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -117,2 +117,0 @@\n-  adjust_unextended_sp();\n-\n@@ -215,1 +213,0 @@\n-  adjust_unextended_sp();\n@@ -459,1 +456,1 @@\n-    assert(sender_pc == nm->deopt_mh_handler_begin() || sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2552,8 +2552,0 @@\n-void MacroAssembler::inc_held_monitor_count() {\n-  incrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-void MacroAssembler::dec_held_monitor_count() {\n-  decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n@@ -6587,1 +6579,1 @@\n-  cmpptr(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n+  cmpptr(count, 8 << shift); \/\/ Short arrays (< 32 bytes) fill by element\n@@ -6650,1 +6642,0 @@\n-        Label L_fill_64_bytes_loop;\n@@ -6655,1 +6646,25 @@\n-        align(16);\n+        \/\/ align data for 64-byte chunks\n+        Label L_fill_64_bytes_loop, L_align_64_bytes_loop;\n+        if (EnableX86ECoreOpts) {\n+            \/\/ align 'big' arrays to cache lines to minimize split_stores\n+            cmpptr(count, 96 << shift);\n+            jcc(Assembler::below, L_fill_64_bytes_loop);\n+\n+            \/\/ Find the bytes needed for alignment\n+            movptr(rtmp, to);\n+            andptr(rtmp, 0x1c);\n+            jcc(Assembler::zero, L_fill_64_bytes_loop);\n+            negptr(rtmp);           \/\/ number of bytes to fill 32-rtmp. it filled by 2 mov by 32\n+            addptr(rtmp, 32);\n+            shrptr(rtmp, 2 - shift);\/\/ get number of elements from bytes\n+            subptr(count, rtmp);    \/\/ adjust count by number of elements\n+\n+            align(16);\n+            BIND(L_align_64_bytes_loop);\n+            movdl(Address(to, 0), xtmp);\n+            addptr(to, 4);\n+            subptr(rtmp, 1 << shift);\n+            jcc(Assembler::greater, L_align_64_bytes_loop);\n+        }\n+\n+        align(16);\n@@ -6664,0 +6679,1 @@\n+        align(16);\n@@ -6708,0 +6724,1 @@\n+      align(16);\n@@ -6716,3 +6733,3 @@\n-  \/\/ fill trailing 4 bytes\n-  BIND(L_fill_4_bytes);\n-  testl(count, 1<<shift);\n+\n+  Label L_fill_4_bytes_loop;\n+  testl(count, 1 << shift);\n@@ -6720,0 +6737,3 @@\n+\n+  align(16);\n+  BIND(L_fill_4_bytes_loop);\n@@ -6721,0 +6741,6 @@\n+  addptr(to, 4);\n+\n+  BIND(L_fill_4_bytes);\n+  subptr(count, 1 << shift);\n+  jccb(Assembler::greaterEqual, L_fill_4_bytes_loop);\n+\n@@ -6723,1 +6749,0 @@\n-    addptr(to, 4);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -514,3 +514,0 @@\n-  void inc_held_monitor_count();\n-  void dec_held_monitor_count();\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1628,2 +1628,0 @@\n-  __ movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  __ movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n@@ -1632,1 +1630,0 @@\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n@@ -1656,43 +1653,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ cmpptr(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ rax may hold an exception oop, save it before the call\n-    __ push(rax);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    __ pop(rax);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1709,5 +1709,0 @@\n-\/\/ Register for saving SP into on method handle invokes. Not used on x86_64.\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-    return NO_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-                 DeoptMH,        \/\/ Offset where MethodHandle deopt handler lives\n@@ -87,1 +86,0 @@\n-    _values[DeoptMH       ] = -1;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,8 +313,0 @@\n-  \/\/ Emit the MethodHandle deopt handler code (if required).\n-  if (has_method_handle_invokes()) {\n-    \/\/ We can use the same code as for the normal deopt handler, we\n-    \/\/ just need a different entry point address.\n-    code_offsets->set_value(CodeOffsets::DeoptMH, assembler->emit_deopt_handler());\n-    CHECK_BAILOUT();\n-  }\n-\n@@ -577,1 +569,0 @@\n-, _has_method_handle_invokes(false)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  bool               _has_method_handle_invokes;  \/\/ True if this method has MethodHandle invokes.\n@@ -185,4 +184,0 @@\n-  \/\/ JSR 292\n-  bool     has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,3 +158,0 @@\n-  \/\/ JSR 292\n-  static LIR_Opr method_handle_invoke_SP_save_opr();\n-\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,0 @@\n-  , _is_method_handle_invoke(false)\n@@ -208,1 +207,0 @@\n-  , _is_method_handle_invoke(info->_is_method_handle_invoke)\n@@ -223,1 +221,1 @@\n-  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, _is_method_handle_invoke, maybe_return_as_fields);\n+  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, maybe_return_as_fields);\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool is_method_handle_invoke = false, bool maybe_return_as_fields = false) {\n+  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool maybe_return_as_fields = false) {\n@@ -259,1 +259,1 @@\n-                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop, return_scalarized,\n+                             reexecute, rethrow_exception, return_oop, return_scalarized,\n@@ -273,1 +273,0 @@\n-  bool              _is_method_handle_invoke;    \/\/ true if the associated call site is a MethodHandle call site.\n@@ -299,3 +298,0 @@\n-  bool     is_method_handle_invoke() const { return _is_method_handle_invoke;     }\n-  void set_is_method_handle_invoke(bool x) {        _is_method_handle_invoke = x; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -747,5 +747,0 @@\n-      if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &&\n-          opJavaCall->is_method_handle_invoke()) {\n-        opJavaCall->_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();\n-        do_temp(opJavaCall->_method_handle_invoke_SP_save_opr);\n-      }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1198,1 +1198,0 @@\n-  LIR_Opr   _method_handle_invoke_SP_save_opr;  \/\/ Used in LIR_OpVisitState::visit to store the reference to FrameMap::method_handle_invoke_SP_save_opr.\n@@ -1208,1 +1207,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n@@ -1217,1 +1215,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -483,6 +483,0 @@\n-  \/\/ JSR 292\n-  \/\/ Record if this method has MethodHandle invokes.\n-  if (op->is_method_handle_invoke()) {\n-    compilation()->set_has_method_handle_invokes(true);\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3180,12 +3180,0 @@\n-  \/\/ JSR 292\n-  \/\/ Preserve the SP over MethodHandle call sites, if needed.\n-  bool is_method_handle_invoke = (\/\/ %%% FIXME: Are both of these relevant?\n-                                  target->is_method_handle_intrinsic() ||\n-                                  target->is_compiled_lambda_form());\n-  if (is_method_handle_invoke) {\n-    info->set_is_method_handle_invoke(true);\n-    if(FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-        __ move(FrameMap::stack_pointer(), FrameMap::method_handle_invoke_SP_save_opr());\n-    }\n-  }\n-\n@@ -3225,7 +3213,0 @@\n-  \/\/ JSR 292\n-  \/\/ Restore the SP after MethodHandle call sites, if needed.\n-  if (is_method_handle_invoke\n-      && FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-    __ move(FrameMap::method_handle_invoke_SP_save_opr(), FrameMap::stack_pointer());\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -676,3 +676,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -757,2 +754,0 @@\n-      \/\/ Set flag if return address is a method handle call site.\n-      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -795,2 +790,0 @@\n-  \/\/ Set flag if return address is a method handle call site.\n-  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4910,0 +4910,2 @@\n+        signature++;\n+        length--;\n@@ -4911,2 +4913,2 @@\n-        const char* const p = skip_over_field_name(signature + 1, true, --length);\n-\n+        const char* const p = skip_over_field_name(signature, true, length);\n+        assert(p == nullptr || p > signature, \"must parse one character at least\");\n@@ -4914,1 +4916,3 @@\n-        if (p && (p - signature) > 1 && p[0] == JVM_SIGNATURE_ENDCLASS) {\n+        if (p != nullptr                             && \/\/ Parse of field name succeeded.\n+            p - signature < static_cast<int>(length) && \/\/ There is at least one character left to parse.\n+            p[0] == JVM_SIGNATURE_ENDCLASS) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -331,1 +331,0 @@\n-  friend class VMStructs;\n@@ -679,1 +678,0 @@\n-  friend class VMStructs;\n@@ -703,1 +701,0 @@\n-  friend class VMStructs;\n@@ -740,1 +737,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-bool CompiledICLocker::is_safe(nmethod* method) {\n-  return CompiledICProtectionBehaviour::current()->is_safe(method);\n+bool CompiledICLocker::is_safe(nmethod* nm) {\n+  return CompiledICProtectionBehaviour::current()->is_safe(nm);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static bool is_safe(nmethod* method);\n+  static bool is_safe(nmethod* nm);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-                                              bool        is_method_handle_invoke,\n@@ -305,1 +304,0 @@\n-  last_pd->set_is_method_handle_invoke(is_method_handle_invoke);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,0 @@\n-                      bool        is_method_handle_invoke = false,\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -468,8 +468,0 @@\n-bool nmethod::is_method_handle_return(address return_pc) {\n-  if (!has_method_handle_invokes())  return false;\n-  PcDesc* pd = pc_desc_at(return_pc);\n-  if (pd == nullptr)\n-    return false;\n-  return pd->is_method_handle_invoke();\n-}\n-\n@@ -776,1 +768,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"clearing of IC's only allowed at safepoint\");\n+  assert(SafepointSynchronize::is_at_safepoint() || (NMethodState_lock->owned_by_self() && is_not_installed()), \"clearing of IC's only allowed at safepoint or when not installed\");\n@@ -1168,1 +1160,2 @@\n-    + align_up(debug_info->data_size()           , oopSize);\n+    + align_up(debug_info->data_size()           , oopSize)\n+    + align_up(ImmutableDataReferencesCounterSize, oopSize);\n@@ -1245,1 +1238,0 @@\n-  _has_method_handle_invokes  = 0;\n@@ -1328,1 +1320,0 @@\n-    _deopt_mh_handler_offset = 0;\n@@ -1399,0 +1390,252 @@\n+\n+nmethod::nmethod(const nmethod &nm) : CodeBlob(nm._name, nm._kind, nm._size, nm._header_size)\n+{\n+\n+  if (nm._oop_maps != nullptr) {\n+    _oop_maps                   = nm._oop_maps->clone();\n+  } else {\n+    _oop_maps                   = nullptr;\n+  }\n+\n+  _size                         = nm._size;\n+  _relocation_size              = nm._relocation_size;\n+  _content_offset               = nm._content_offset;\n+  _code_offset                  = nm._code_offset;\n+  _data_offset                  = nm._data_offset;\n+  _frame_size                   = nm._frame_size;\n+\n+  S390_ONLY( _ctable_offset     = nm._ctable_offset; )\n+\n+  _header_size                  = nm._header_size;\n+  _frame_complete_offset        = nm._frame_complete_offset;\n+\n+  _kind                         = nm._kind;\n+\n+  _caller_must_gc_arguments     = nm._caller_must_gc_arguments;\n+\n+#ifndef PRODUCT\n+  _asm_remarks.share(nm._asm_remarks);\n+  _dbg_strings.share(nm._dbg_strings);\n+#endif\n+\n+  \/\/ Allocate memory and copy mutable data to C heap\n+  _mutable_data_size            = nm._mutable_data_size;\n+  if (_mutable_data_size > 0) {\n+    _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+    if (_mutable_data == nullptr) {\n+      vm_exit_out_of_memory(_mutable_data_size, OOM_MALLOC_ERROR, \"nmethod: no space for mutable data\");\n+    }\n+    memcpy(mutable_data_begin(), nm.mutable_data_begin(), nm.mutable_data_size());\n+  } else {\n+    _mutable_data               = nullptr;\n+  }\n+\n+  _deoptimization_generation    = 0;\n+  _gc_epoch                     = CodeCache::gc_epoch();\n+  _method                       = nm._method;\n+  _osr_link                     = nullptr;\n+\n+  \/\/ Increment number of references to immutable data to share it between nmethods\n+  _immutable_data_size          = nm._immutable_data_size;\n+  if (_immutable_data_size > 0) {\n+    _immutable_data             = nm._immutable_data;\n+    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n+  } else {\n+    _immutable_data             = blob_end();\n+  }\n+\n+  _exception_cache              = nullptr;\n+  _gc_data                      = nullptr;\n+  _oops_do_mark_nmethods        = nullptr;\n+  _oops_do_mark_link            = nullptr;\n+  _compiled_ic_data             = nullptr;\n+\n+  if (nm._osr_entry_point != nullptr) {\n+    _osr_entry_point            = (nm._osr_entry_point - (address) &nm) + (address) this;\n+  } else {\n+    _osr_entry_point            = nullptr;\n+  }\n+\n+  _entry_offset                 = nm._entry_offset;\n+  _verified_entry_offset        = nm._verified_entry_offset;\n+  _entry_bci                    = nm._entry_bci;\n+\n+  _skipped_instructions_size    = nm._skipped_instructions_size;\n+  _stub_offset                  = nm._stub_offset;\n+  _exception_offset             = nm._exception_offset;\n+  _deopt_handler_offset         = nm._deopt_handler_offset;\n+  _unwind_handler_offset        = nm._unwind_handler_offset;\n+  _num_stack_arg_slots          = nm._num_stack_arg_slots;\n+  _oops_size                    = nm._oops_size;\n+#if INCLUDE_JVMCI\n+  _metadata_size                = nm._metadata_size;\n+#endif\n+  _nul_chk_table_offset         = nm._nul_chk_table_offset;\n+  _handler_table_offset         = nm._handler_table_offset;\n+  _scopes_pcs_offset            = nm._scopes_pcs_offset;\n+  _scopes_data_offset           = nm._scopes_data_offset;\n+#if INCLUDE_JVMCI\n+  _speculations_offset          = nm._speculations_offset;\n+#endif\n+\n+  _orig_pc_offset               = nm._orig_pc_offset;\n+  _compile_id                   = nm._compile_id;\n+  _comp_level                   = nm._comp_level;\n+  _compiler_type                = nm._compiler_type;\n+  _is_unloading_state           = nm._is_unloading_state;\n+  _state                        = not_installed;\n+\n+  _has_unsafe_access            = nm._has_unsafe_access;\n+  _has_wide_vectors             = nm._has_wide_vectors;\n+  _has_monitors                 = nm._has_monitors;\n+  _has_scoped_access            = nm._has_scoped_access;\n+  _has_flushed_dependencies     = nm._has_flushed_dependencies;\n+  _is_unlinked                  = nm._is_unlinked;\n+  _load_reported                = nm._load_reported;\n+\n+  _deoptimization_status        = nm._deoptimization_status;\n+\n+  if (nm._pc_desc_container != nullptr) {\n+    _pc_desc_container          = new PcDescContainer(scopes_pcs_begin());\n+  } else {\n+    _pc_desc_container          = nullptr;\n+  }\n+\n+  \/\/ Copy nmethod contents excluding header\n+  \/\/ - Constant part          (doubles, longs and floats used in nmethod)\n+  \/\/ - Code part:\n+  \/\/   - Code body\n+  \/\/   - Exception handler\n+  \/\/   - Stub code\n+  \/\/   - OOP table\n+  memcpy(consts_begin(), nm.consts_begin(), nm.data_end() - nm.consts_begin());\n+\n+  post_init();\n+}\n+\n+nmethod* nmethod::relocate(CodeBlobType code_blob_type) {\n+  assert(NMethodRelocation, \"must enable use of function\");\n+\n+  \/\/ Locks required to be held by caller to ensure the nmethod\n+  \/\/ is not modified or purged from code cache during relocation\n+  assert_lock_strong(CodeCache_lock);\n+  assert_lock_strong(Compile_lock);\n+  assert(CompiledICLocker::is_safe(this), \"mt unsafe call\");\n+\n+  if (!is_relocatable()) {\n+    return nullptr;\n+  }\n+\n+  run_nmethod_entry_barrier();\n+  nmethod* nm_copy = new (size(), code_blob_type) nmethod(*this);\n+\n+  if (nm_copy == nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Fix relocation\n+  RelocIterator iter(nm_copy);\n+  CodeBuffer src(this);\n+  CodeBuffer dst(nm_copy);\n+  while (iter.next()) {\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+    \/\/ Direct calls may no longer be in range and the use of a trampoline may now be required.\n+    \/\/ Instead, allow trampoline relocations to update their owners and perform the necessary checks.\n+    if (iter.reloc()->is_call()) {\n+      address trampoline = trampoline_stub_Relocation::get_trampoline_for(iter.reloc()->addr(), nm_copy);\n+      if (trampoline != nullptr) {\n+        continue;\n+      }\n+    }\n+#endif\n+\n+    iter.reloc()->fix_relocation_after_move(&src, &dst);\n+  }\n+\n+  \/\/ To make dependency checking during class loading fast, record\n+  \/\/ the nmethod dependencies in the classes it is dependent on.\n+  \/\/ This allows the dependency checking code to simply walk the\n+  \/\/ class hierarchy above the loaded class, checking only nmethods\n+  \/\/ which are dependent on those classes.  The slow way is to\n+  \/\/ check every nmethod for dependencies which makes it linear in\n+  \/\/ the number of methods compiled.  For applications with a lot\n+  \/\/ classes the slow way is too slow.\n+  for (Dependencies::DepStream deps(nm_copy); deps.next(); ) {\n+    if (deps.type() == Dependencies::call_site_target_value) {\n+      \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n+      oop call_site = deps.argument_oop(0);\n+      MethodHandles::add_dependent_nmethod(call_site, nm_copy);\n+    } else {\n+      InstanceKlass* ik = deps.context_type();\n+      if (ik == nullptr) {\n+        continue;  \/\/ ignore things like evol_method\n+      }\n+      \/\/ record this nmethod as dependent on this klass\n+      ik->add_dependent_nmethod(nm_copy);\n+    }\n+  }\n+\n+  MutexLocker ml_NMethodState_lock(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ Verify the nm we copied from is still valid\n+  if (!is_marked_for_deoptimization() && is_in_use()) {\n+    assert(method() != nullptr && method()->code() == this, \"should be if is in use\");\n+\n+    nm_copy->clear_inline_caches();\n+\n+    \/\/ Attempt to start using the copy\n+    if (nm_copy->make_in_use()) {\n+      ICache::invalidate_range(nm_copy->code_begin(), nm_copy->code_size());\n+\n+      methodHandle mh(Thread::current(), nm_copy->method());\n+      nm_copy->method()->set_code(mh, nm_copy);\n+\n+      make_not_used();\n+\n+      nm_copy->post_compiled_method_load_event();\n+\n+      nm_copy->log_relocated_nmethod(this);\n+\n+      return nm_copy;\n+    }\n+  }\n+\n+  nm_copy->make_not_used();\n+\n+  return nullptr;\n+}\n+\n+bool nmethod::is_relocatable() {\n+  if (!is_java_method()) {\n+    return false;\n+  }\n+\n+  if (!is_in_use()) {\n+    return false;\n+  }\n+\n+  if (is_osr_method()) {\n+    return false;\n+  }\n+\n+  if (is_marked_for_deoptimization()) {\n+    return false;\n+  }\n+\n+#if INCLUDE_JVMCI\n+  if (jvmci_nmethod_data() != nullptr && jvmci_nmethod_data()->has_mirror()) {\n+    return false;\n+  }\n+#endif\n+\n+  if (is_unloading()) {\n+    return false;\n+  }\n+\n+  if (has_evol_metadata()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -1403,0 +1646,4 @@\n+void* nmethod::operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw () {\n+  return CodeCache::allocate(nmethod_size, code_blob_type);\n+}\n+\n@@ -1476,5 +1723,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = code_offset() + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -1490,5 +1732,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = _stub_offset + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -1536,1 +1773,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset  + align_up(speculations_len, oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -1538,1 +1775,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -1571,0 +1808,1 @@\n+    set_immutable_data_references_counter(1);\n@@ -1637,0 +1875,34 @@\n+\n+void nmethod::log_relocated_nmethod(nmethod* original) const {\n+  if (LogCompilation && xtty != nullptr) {\n+    ttyLocker ttyl;\n+    xtty->begin_elem(\"relocated nmethod\");\n+    log_identity(xtty);\n+    xtty->print(\" entry='\" INTPTR_FORMAT \"' size='%d'\", p2i(code_begin()), size());\n+\n+    const char* original_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(original));\n+    xtty->print(\" original_address='\" INTPTR_FORMAT \"'\", p2i(original));\n+    xtty->print(\" original_code_heap='%s'\", original_code_heap_name);\n+\n+    const char* new_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(this));\n+    xtty->print(\" new_address='\" INTPTR_FORMAT \"'\", p2i(this));\n+    xtty->print(\" new_code_heap='%s'\", new_code_heap_name);\n+\n+    LOG_OFFSET(xtty, relocation);\n+    LOG_OFFSET(xtty, consts);\n+    LOG_OFFSET(xtty, insts);\n+    LOG_OFFSET(xtty, stub);\n+    LOG_OFFSET(xtty, scopes_data);\n+    LOG_OFFSET(xtty, scopes_pcs);\n+    LOG_OFFSET(xtty, dependencies);\n+    LOG_OFFSET(xtty, handler_table);\n+    LOG_OFFSET(xtty, nul_chk_table);\n+    LOG_OFFSET(xtty, oops);\n+    LOG_OFFSET(xtty, metadata);\n+\n+    xtty->method(method());\n+    xtty->stamp();\n+    xtty->end_elem();\n+  }\n+}\n+\n@@ -2169,1 +2441,9 @@\n-    os::free(_immutable_data);\n+    int reference_count = get_immutable_data_references_counter();\n+    assert(reference_count > 0, \"immutable data has no references\");\n+\n+    set_immutable_data_references_counter(reference_count - 1);\n+    \/\/ Free memory if this is the last nmethod referencing immutable data\n+    if (reference_count == 0) {\n+      os::free(_immutable_data);\n+    }\n+\n@@ -2172,0 +2452,1 @@\n+\n@@ -2715,9 +2996,0 @@\n-  \/\/ Search for MethodHandle invokes and tag the nmethod.\n-  for (int i = 0; i < count; i++) {\n-    if (pcs[i].is_method_handle_invoke()) {\n-      set_has_method_handle_invokes(true);\n-      break;\n-    }\n-  }\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_offset != -1), \"must have deopt mh handler\");\n-\n@@ -3736,1 +4008,0 @@\n-  if (has_method_handle_invokes() && (pos == deopt_mh_handler_begin())) label = \"[Deopt MH Handler Code]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":306,"deletions":35,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-  friend class VMStructs;\n@@ -159,0 +158,1 @@\n+\/\/  - Nmethod reference counter\n@@ -172,0 +172,2 @@\n+  #define ImmutableDataReferencesCounterSize ((int)sizeof(int))\n+\n@@ -235,3 +237,0 @@\n-  \/\/ All deoptee's at a MethodHandle call site will resume execution\n-  \/\/ at this location described by this offset.\n-  int _deopt_mh_handler_offset;\n@@ -276,1 +275,0 @@\n-          _has_method_handle_invokes:1,\/\/ Has this method MethodHandle invokes?\n@@ -343,0 +341,2 @@\n+  nmethod(const nmethod &nm);\n+\n@@ -345,0 +345,1 @@\n+  void* operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw();\n@@ -577,0 +578,6 @@\n+  \/\/ Relocate the nmethod to the code heap identified by code_blob_type.\n+  \/\/ Returns nullptr if the code heap does not have enough space, the\n+  \/\/ nmethod is unrelocatable, or the nmethod is invalidated during relocation,\n+  \/\/ otherwise the relocated nmethod. The original nmethod will be marked not entrant.\n+  nmethod* relocate(CodeBlobType code_blob_type);\n+\n@@ -593,0 +600,2 @@\n+  bool is_relocatable();\n+\n@@ -615,1 +624,0 @@\n-  address deopt_mh_handler_begin() const { return           header_begin() + _deopt_mh_handler_offset ; }\n@@ -646,1 +654,1 @@\n-  address speculations_end      () const { return            immutable_data_end(); }\n+  address speculations_end      () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -648,1 +656,1 @@\n-  address scopes_data_end       () const { return            immutable_data_end(); }\n+  address scopes_data_end       () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -651,0 +659,2 @@\n+  address immutable_data_references_counter_begin () const { return immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+\n@@ -757,3 +767,0 @@\n-  bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }\n-  void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }\n-\n@@ -840,2 +847,0 @@\n-  \/\/ MethodHandle\n-  bool is_method_handle_return(address return_pc);\n@@ -845,1 +850,0 @@\n-  inline bool is_deopt_mh_entry(address pc);\n@@ -979,0 +983,3 @@\n+  inline int  get_immutable_data_references_counter()           { return *((int*)immutable_data_references_counter_begin());  }\n+  inline void set_immutable_data_references_counter(int count)  { *((int*)immutable_data_references_counter_begin()) = count; }\n+\n@@ -1047,0 +1054,1 @@\n+  void log_relocated_nmethod(nmethod* original) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,6 +43,5 @@\n-    PCDESC_is_method_handle_invoke   = 1 << 1,\n-    PCDESC_return_oop                = 1 << 2,\n-    PCDESC_rethrow_exception         = 1 << 3,\n-    PCDESC_has_ea_local_in_scope     = 1 << 4,\n-    PCDESC_arg_escape                = 1 << 5,\n-    PCDESC_return_scalarized         = 1 << 6\n+    PCDESC_return_oop                = 1 << 1,\n+    PCDESC_rethrow_exception         = 1 << 2,\n+    PCDESC_has_ea_local_in_scope     = 1 << 3,\n+    PCDESC_arg_escape                = 1 << 4,\n+    PCDESC_return_scalarized         = 1 << 5\n@@ -89,3 +88,0 @@\n-  bool     is_method_handle_invoke()       const { return (_flags & PCDESC_is_method_handle_invoke) != 0;     }\n-  void set_is_method_handle_invoke(bool z)       { set_flag(PCDESC_is_method_handle_invoke, z); }\n-\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -866,0 +866,6 @@\n+ImmutableOopMapSet* ImmutableOopMapSet::clone() const {\n+  address buffer = NEW_C_HEAP_ARRAY(unsigned char, _size, mtCode);\n+  memcpy(buffer, (address)this, _size);\n+  return (ImmutableOopMapSet*)buffer;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -64,1 +65,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -1089,1 +1089,2 @@\n-  StrongRootsScope _strong_roots_scope; \/\/ needed for Threads::possibly_parallel_threads_do\n+  NMethodMarkingScope _nmethod_marking_scope;\n+  ThreadsClaimTokenScope _threads_claim_token_scope;\n@@ -1097,1 +1098,2 @@\n-      _strong_roots_scope(active_workers),\n+      _nmethod_marking_scope(),\n+      _threads_claim_token_scope(),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,4 +53,0 @@\n-inline void PSPromotionManager::push_depth(ScannerTask task) {\n-  claimed_stack_depth()->push(task);\n-}\n-\n@@ -65,1 +61,1 @@\n-    push_depth(ScannerTask(p));\n+    claimed_stack_depth()->push(ScannerTask(p));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1144,1 +1144,1 @@\n-void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n+void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool return_oop, JVMCI_TRAPS) {\n@@ -1188,1 +1188,1 @@\n-      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n+      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, return_oop,\n@@ -1246,7 +1246,1 @@\n-      vmIntrinsics::ID iid = method->intrinsic_id();\n-      bool is_mh_invoke = false;\n-      if (direct_call) {\n-        is_mh_invoke = !method->is_static() && (iid == vmIntrinsics::_compiledLambdaForm ||\n-                (MethodHandles::is_signature_polymorphic(iid) && MethodHandles::is_signature_polymorphic_intrinsic(iid)));\n-      }\n-      record_scope(next_pc_offset, stream, flags, true, is_mh_invoke, return_oop, JVMCI_CHECK);\n+      record_scope(next_pc_offset, stream, flags, true, return_oop, JVMCI_CHECK);\n@@ -1345,3 +1339,0 @@\n-    case DEOPT_MH_HANDLER_ENTRY:\n-      _offsets.set_value(CodeOffsets::DeoptMH, pc_offset);\n-      break;\n@@ -1375,0 +1366,1 @@\n+    case DEOPT_MH_HANDLER_ENTRY:\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -245,1 +245,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n@@ -259,1 +258,0 @@\n-  nonstatic_field(JavaThread,                  _held_monitor_count,                           intx)                                  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -861,4 +861,3 @@\n-\n-    \/\/ Add to class loader list first before creating the mirror\n-    \/\/ (same order as class file parsing)\n-    loader_data->add_class(this);\n+  \/\/ Add to class loader list first before creating the mirror\n+  \/\/ (same order as class file parsing)\n+  loader_data->add_class(this);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -184,4 +184,0 @@\n-    if (method()->is_method_handle_intrinsic() ||\n-        method()->is_compiled_lambda_form()) {\n-      call->set_method_handle_invoke(true);\n-    }\n@@ -501,0 +497,4 @@\n+  virtual ciMethod* callee_method() {\n+    return _callee;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  virtual ciMethod* callee_method() { ShouldNotReachHere(); }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1406,14 +1406,15 @@\n-      \/\/ Recover symbolic info for method resolution.\n-      ciMethod* caller = jvms()->method();\n-      ciBytecodeStream iter(caller);\n-      iter.force_bci(jvms()->bci());\n-\n-      bool             not_used1;\n-      ciSignature*     not_used2;\n-      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-      ciKlass*         holder       = iter.get_declared_method_holder();\n-      if (orig_callee->is_method_handle_intrinsic()) {\n-        assert(_override_symbolic_info, \"required\");\n-        orig_callee = method();\n-        holder = method()->holder();\n-      }\n+      if (cg->callee_method() == nullptr) {\n+        \/\/ Recover symbolic info for method resolution.\n+        ciMethod* caller = jvms()->method();\n+        ciBytecodeStream iter(caller);\n+        iter.force_bci(jvms()->bci());\n+\n+        bool             not_used1;\n+        ciSignature*     not_used2;\n+        ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+        ciKlass*         holder       = iter.get_declared_method_holder();\n+        if (orig_callee->is_method_handle_intrinsic()) {\n+          assert(_override_symbolic_info, \"required\");\n+          orig_callee = method();\n+          holder = method()->holder();\n+        }\n@@ -1421,1 +1422,1 @@\n-      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+        ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1423,2 +1424,2 @@\n-      Node* receiver_node = in(TypeFunc::Parms);\n-      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+        Node* receiver_node = in(TypeFunc::Parms);\n+        const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1426,5 +1427,9 @@\n-      int  not_used3;\n-      bool call_does_dispatch;\n-      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                         call_does_dispatch, not_used3);  \/\/ out-parameters\n-      if (!call_does_dispatch) {\n+        int  not_used3;\n+        bool call_does_dispatch;\n+        ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                           call_does_dispatch, not_used3);  \/\/ out-parameters\n+        if (!call_does_dispatch) {\n+          cg->set_callee_method(callee);\n+        }\n+      }\n+      if (cg->callee_method() != nullptr) {\n@@ -1432,1 +1437,0 @@\n-        cg->set_callee_method(callee);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -800,1 +800,0 @@\n-  bool    _method_handle_invoke;\n@@ -808,1 +807,0 @@\n-      _method_handle_invoke(false),\n@@ -820,2 +818,0 @@\n-  void  set_method_handle_invoke(bool f)   { _method_handle_invoke = f; }\n-  bool  is_method_handle_invoke() const    { return _method_handle_invoke; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -672,1 +672,0 @@\n-      _has_method_handle_invokes(false),\n@@ -958,1 +957,0 @@\n-      _has_method_handle_invokes(false),\n@@ -2610,0 +2608,6 @@\n+      if (should_stress_inlining()) {\n+        \/\/ randomly add repeated inline attempt if stress-inlining\n+        cg->call_node()->set_generator(cg);\n+        C->igvn_worklist()->push(cg->call_node());\n+        continue;\n+      }\n@@ -5962,0 +5966,155 @@\n+\n+#ifndef PRODUCT\n+\/\/ Collects all the control inputs from nodes on the worklist and from their data dependencies\n+static void find_candidate_control_inputs(Unique_Node_List& worklist, Unique_Node_List& candidates) {\n+  \/\/ Follow non-control edges until we reach CFG nodes\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    const Node* n = worklist.at(i);\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in == nullptr || in->is_Root()) {\n+        continue;\n+      }\n+      if (in->is_CFG()) {\n+        if (in->is_Call()) {\n+          \/\/ The return value of a call is only available if the call did not result in an exception\n+          Node* control_proj_use = in->as_Call()->proj_out(TypeFunc::Control)->unique_out();\n+          if (control_proj_use->is_Catch()) {\n+            Node* fall_through = control_proj_use->as_Catch()->proj_out(CatchProjNode::fall_through_index);\n+            candidates.push(fall_through);\n+            continue;\n+          }\n+        }\n+\n+        if (in->is_Multi()) {\n+          \/\/ We got here by following data inputs so we should only have one control use\n+          \/\/ (no IfNode, etc)\n+          assert(!n->is_MultiBranch(), \"unexpected node type: %s\", n->Name());\n+          candidates.push(in->as_Multi()->proj_out(TypeFunc::Control));\n+        } else {\n+          candidates.push(in);\n+        }\n+      } else {\n+        worklist.push(in);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Returns the candidate node that is a descendant to all the other candidates\n+static Node* pick_control(Unique_Node_List& candidates) {\n+  Unique_Node_List worklist;\n+  worklist.copy(candidates);\n+\n+  \/\/ Traverse backwards through the CFG\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    const Node* n = worklist.at(i);\n+    if (n->is_Root()) {\n+      continue;\n+    }\n+    for (uint j = 0; j < n->req(); j++) {\n+      \/\/ Skip backedge of loops to avoid cycles\n+      if (n->is_Loop() && j == LoopNode::LoopBackControl) {\n+        continue;\n+      }\n+\n+      Node* pred = n->in(j);\n+      if (pred != nullptr && pred != n && pred->is_CFG()) {\n+        worklist.push(pred);\n+        \/\/ if pred is an ancestor of n, then pred is an ancestor to at least one candidate\n+        candidates.remove(pred);\n+      }\n+    }\n+  }\n+\n+  assert(candidates.size() == 1, \"unexpected control flow\");\n+  return candidates.at(0);\n+}\n+\n+\/\/ Initialize a parameter input for a debug print call, using a placeholder for jlong and jdouble\n+static void debug_print_init_parm(Node* call, Node* parm, Node* half, int* pos) {\n+  call->init_req((*pos)++, parm);\n+  const BasicType bt = parm->bottom_type()->basic_type();\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    call->init_req((*pos)++, half);\n+  }\n+}\n+\n+Node* Compile::make_debug_print_call(const char* str, address call_addr, PhaseGVN* gvn,\n+                              Node* parm0, Node* parm1,\n+                              Node* parm2, Node* parm3,\n+                              Node* parm4, Node* parm5,\n+                              Node* parm6) const {\n+  Node* str_node = gvn->transform(new ConPNode(TypeRawPtr::make(((address) str))));\n+  const TypeFunc* type = OptoRuntime::debug_print_Type(parm0, parm1, parm2, parm3, parm4, parm5, parm6);\n+  Node* call = new CallLeafNode(type, call_addr, \"debug_print\", TypeRawPtr::BOTTOM);\n+\n+  \/\/ find the most suitable control input\n+  Unique_Node_List worklist, candidates;\n+  if (parm0 != nullptr) { worklist.push(parm0);\n+  if (parm1 != nullptr) { worklist.push(parm1);\n+  if (parm2 != nullptr) { worklist.push(parm2);\n+  if (parm3 != nullptr) { worklist.push(parm3);\n+  if (parm4 != nullptr) { worklist.push(parm4);\n+  if (parm5 != nullptr) { worklist.push(parm5);\n+  if (parm6 != nullptr) { worklist.push(parm6);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+  find_candidate_control_inputs(worklist, candidates);\n+  Node* control = nullptr;\n+  if (candidates.size() == 0) {\n+    control = C->start()->proj_out(TypeFunc::Control);\n+  } else {\n+    control = pick_control(candidates);\n+  }\n+\n+  \/\/ find all the previous users of the control we picked\n+  GrowableArray<Node*> users_of_control;\n+  for (DUIterator_Fast kmax, i = control->fast_outs(kmax); i < kmax; i++) {\n+    Node* use = control->fast_out(i);\n+    if (use->is_CFG() && use != control) {\n+      users_of_control.push(use);\n+    }\n+  }\n+\n+  \/\/ we do not actually care about IO and memory as it uses neither\n+  call->init_req(TypeFunc::Control,   control);\n+  call->init_req(TypeFunc::I_O,       top());\n+  call->init_req(TypeFunc::Memory,    top());\n+  call->init_req(TypeFunc::FramePtr,  C->start()->proj_out(TypeFunc::FramePtr));\n+  call->init_req(TypeFunc::ReturnAdr, top());\n+\n+  int pos = TypeFunc::Parms;\n+  call->init_req(pos++, str_node);\n+  if (parm0 != nullptr) { debug_print_init_parm(call, parm0, top(), &pos);\n+  if (parm1 != nullptr) { debug_print_init_parm(call, parm1, top(), &pos);\n+  if (parm2 != nullptr) { debug_print_init_parm(call, parm2, top(), &pos);\n+  if (parm3 != nullptr) { debug_print_init_parm(call, parm3, top(), &pos);\n+  if (parm4 != nullptr) { debug_print_init_parm(call, parm4, top(), &pos);\n+  if (parm5 != nullptr) { debug_print_init_parm(call, parm5, top(), &pos);\n+  if (parm6 != nullptr) { debug_print_init_parm(call, parm6, top(), &pos);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n+\n+  call = gvn->transform(call);\n+  Node* call_control_proj = gvn->transform(new ProjNode(call, TypeFunc::Control));\n+\n+  \/\/ rewire previous users to have the new call as control instead\n+  PhaseIterGVN* igvn = gvn->is_IterGVN();\n+  for (int i = 0; i < users_of_control.length(); i++) {\n+    Node* use = users_of_control.at(i);\n+    for (uint j = 0; j < use->req(); j++) {\n+      if (use->in(j) == control) {\n+        if (igvn != nullptr) {\n+          igvn->replace_input_of(use, j, call_control_proj);\n+        } else {\n+          gvn->hash_delete(use);\n+          use->set_req(j, call_control_proj);\n+          gvn->hash_insert(use);\n+        }\n+      }\n+    }\n+  }\n+\n+  return call;\n+}\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":161,"deletions":2,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -361,2 +361,0 @@\n-  \/\/ JSR 292\n-  bool                  _has_method_handle_invokes; \/\/ True if this method has MethodHandle invokes.\n@@ -690,4 +688,0 @@\n-  \/\/ JSR 292\n-  bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n@@ -1142,1 +1136,2 @@\n-  bool should_delay_inlining() { return AlwaysIncrementalInline || (StressIncrementalInlining && (random() % 2) == 0); }\n+  bool should_stress_inlining() { return StressIncrementalInlining && (random() % 2) == 0; }\n+  bool should_delay_inlining() { return AlwaysIncrementalInline || should_stress_inlining(); }\n@@ -1365,0 +1360,22 @@\n+\n+#ifndef PRODUCT\n+private:\n+  \/\/ getting rid of the template makes things easier\n+  Node* make_debug_print_call(const char* str, address call_addr, PhaseGVN* gvn,\n+                              Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                              Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                              Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                              Node* parm6 = nullptr) const;\n+\n+public:\n+  \/\/ Creates a CallLeafNode for a runtime call that prints a static string and the values of the\n+  \/\/ nodes passed as arguments.\n+  \/\/ This function also takes care of doing the necessary wiring, including finding a suitable control\n+  \/\/ based on the nodes that need to be printed. Note that passing nodes that have incompatible controls\n+  \/\/ is undefined behavior.\n+  template <typename... TT, typename... NN>\n+  Node* make_debug_print(const char* str, PhaseGVN* gvn, NN... in) {\n+    address call_addr = CAST_FROM_FN_PTR(address, SharedRuntime::debug_print<TT...>);\n+    return make_debug_print_call(str, call_addr, gvn, in...);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-        break;\n+        \/\/ If MemBarStoreStore has a precedent edge add it to the worklist (like MemBarRelease)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -976,11 +976,0 @@\n-\n-  \/\/ If the call is a MethodHandle invoke, we need to exclude the\n-  \/\/ register which is used to save the SP value over MH invokes from\n-  \/\/ the mask.  Otherwise this register could be used for\n-  \/\/ deoptimization information.\n-  if (op == Op_CallStaticJava) {\n-    MachCallStaticJavaNode* mcallstaticjava = (MachCallStaticJavaNode*) mcall;\n-    if (mcallstaticjava->_method_handle_invoke)\n-      proj->_rout.OR(Matcher::method_handle_invoke_SP_save_mask());\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1387,0 +1387,3 @@\n+  \/\/ Find the last store in the body of an OuterStripMinedLoop when following memory uses\n+  Node *find_last_store_in_outer_loop(Node* store, const IdealLoopTree* outer_loop);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -803,2 +803,0 @@\n-  if (_method_handle_invoke)\n-    st->print(\"MethodHandle \");\n@@ -825,4 +823,1 @@\n-  \/\/ If this call is a MethodHandle invoke we have to use a different\n-  \/\/ debugmask which does not include the register we use to save the\n-  \/\/ SP over MH invokes.\n-  RegMask** debugmask = _method_handle_invoke ? m->idealreg2mhdebugmask : m->idealreg2debugmask;\n+  RegMask** debugmask = m->idealreg2debugmask;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1000,1 +1000,0 @@\n-  bool      _method_handle_invoke;   \/\/ Tells if the call has to preserve SP\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-RegMask Matcher::mh_caller_save_regmask;\n-RegMask Matcher::mh_caller_save_regmask_exclude_soe;\n@@ -117,15 +115,0 @@\n-  idealreg2mhdebugmask[Op_RegI] = nullptr;\n-  idealreg2mhdebugmask[Op_RegN] = nullptr;\n-  idealreg2mhdebugmask[Op_RegL] = nullptr;\n-  idealreg2mhdebugmask[Op_RegF] = nullptr;\n-  idealreg2mhdebugmask[Op_RegD] = nullptr;\n-  idealreg2mhdebugmask[Op_RegP] = nullptr;\n-  idealreg2mhdebugmask[Op_VecA] = nullptr;\n-  idealreg2mhdebugmask[Op_VecS] = nullptr;\n-  idealreg2mhdebugmask[Op_VecD] = nullptr;\n-  idealreg2mhdebugmask[Op_VecX] = nullptr;\n-  idealreg2mhdebugmask[Op_VecY] = nullptr;\n-  idealreg2mhdebugmask[Op_VecZ] = nullptr;\n-  idealreg2mhdebugmask[Op_RegFlags] = nullptr;\n-  idealreg2mhdebugmask[Op_RegVectMask] = nullptr;\n-\n@@ -501,1 +484,1 @@\n-#define NOF_STACK_MASKS (3*13)\n+#define NOF_STACK_MASKS (2*13)\n@@ -516,45 +499,6 @@\n-  idealreg2spillmask  [Op_RegN] = &rms[0];\n-  idealreg2spillmask  [Op_RegI] = &rms[1];\n-  idealreg2spillmask  [Op_RegL] = &rms[2];\n-  idealreg2spillmask  [Op_RegF] = &rms[3];\n-  idealreg2spillmask  [Op_RegD] = &rms[4];\n-  idealreg2spillmask  [Op_RegP] = &rms[5];\n-\n-  idealreg2debugmask  [Op_RegN] = &rms[6];\n-  idealreg2debugmask  [Op_RegI] = &rms[7];\n-  idealreg2debugmask  [Op_RegL] = &rms[8];\n-  idealreg2debugmask  [Op_RegF] = &rms[9];\n-  idealreg2debugmask  [Op_RegD] = &rms[10];\n-  idealreg2debugmask  [Op_RegP] = &rms[11];\n-\n-  idealreg2mhdebugmask[Op_RegN] = &rms[12];\n-  idealreg2mhdebugmask[Op_RegI] = &rms[13];\n-  idealreg2mhdebugmask[Op_RegL] = &rms[14];\n-  idealreg2mhdebugmask[Op_RegF] = &rms[15];\n-  idealreg2mhdebugmask[Op_RegD] = &rms[16];\n-  idealreg2mhdebugmask[Op_RegP] = &rms[17];\n-\n-  idealreg2spillmask  [Op_VecA] = &rms[18];\n-  idealreg2spillmask  [Op_VecS] = &rms[19];\n-  idealreg2spillmask  [Op_VecD] = &rms[20];\n-  idealreg2spillmask  [Op_VecX] = &rms[21];\n-  idealreg2spillmask  [Op_VecY] = &rms[22];\n-  idealreg2spillmask  [Op_VecZ] = &rms[23];\n-\n-  idealreg2debugmask  [Op_VecA] = &rms[24];\n-  idealreg2debugmask  [Op_VecS] = &rms[25];\n-  idealreg2debugmask  [Op_VecD] = &rms[26];\n-  idealreg2debugmask  [Op_VecX] = &rms[27];\n-  idealreg2debugmask  [Op_VecY] = &rms[28];\n-  idealreg2debugmask  [Op_VecZ] = &rms[29];\n-\n-  idealreg2mhdebugmask[Op_VecA] = &rms[30];\n-  idealreg2mhdebugmask[Op_VecS] = &rms[31];\n-  idealreg2mhdebugmask[Op_VecD] = &rms[32];\n-  idealreg2mhdebugmask[Op_VecX] = &rms[33];\n-  idealreg2mhdebugmask[Op_VecY] = &rms[34];\n-  idealreg2mhdebugmask[Op_VecZ] = &rms[35];\n-\n-  idealreg2spillmask  [Op_RegVectMask] = &rms[36];\n-  idealreg2debugmask  [Op_RegVectMask] = &rms[37];\n-  idealreg2mhdebugmask[Op_RegVectMask] = &rms[38];\n+  int index = 0;\n+  for (int i = Op_RegN; i <= Op_RegVectMask; ++i) {\n+    idealreg2spillmask[i] = &rms[index++];\n+    idealreg2debugmask[i] = &rms[index++];\n+  }\n+  assert(index == NOF_STACK_MASKS, \"wrong size\");\n@@ -747,15 +691,0 @@\n-  *idealreg2mhdebugmask[Op_RegN] = *idealreg2spillmask[Op_RegN];\n-  *idealreg2mhdebugmask[Op_RegI] = *idealreg2spillmask[Op_RegI];\n-  *idealreg2mhdebugmask[Op_RegL] = *idealreg2spillmask[Op_RegL];\n-  *idealreg2mhdebugmask[Op_RegF] = *idealreg2spillmask[Op_RegF];\n-  *idealreg2mhdebugmask[Op_RegD] = *idealreg2spillmask[Op_RegD];\n-  *idealreg2mhdebugmask[Op_RegP] = *idealreg2spillmask[Op_RegP];\n-  *idealreg2mhdebugmask[Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n-\n-  *idealreg2mhdebugmask[Op_VecA] = *idealreg2spillmask[Op_VecA];\n-  *idealreg2mhdebugmask[Op_VecS] = *idealreg2spillmask[Op_VecS];\n-  *idealreg2mhdebugmask[Op_VecD] = *idealreg2spillmask[Op_VecD];\n-  *idealreg2mhdebugmask[Op_VecX] = *idealreg2spillmask[Op_VecX];\n-  *idealreg2mhdebugmask[Op_VecY] = *idealreg2spillmask[Op_VecY];\n-  *idealreg2mhdebugmask[Op_VecZ] = *idealreg2spillmask[Op_VecZ];\n-\n@@ -766,1 +695,0 @@\n-  RegMask* mh_caller_save_mask = exclude_soe ? &mh_caller_save_regmask_exclude_soe : &mh_caller_save_regmask;\n@@ -782,15 +710,0 @@\n-\n-  idealreg2mhdebugmask[Op_RegN]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegI]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegL]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegF]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegP]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegVectMask]->SUBTRACT(*mh_caller_save_mask);\n-\n-  idealreg2mhdebugmask[Op_VecA]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecS]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecX]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecY]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecZ]->SUBTRACT(*mh_caller_save_mask);\n@@ -1020,1 +933,0 @@\n-      mh_caller_save_regmask.Insert(i);\n@@ -1027,1 +939,0 @@\n-      mh_caller_save_regmask_exclude_soe.Insert(i);\n@@ -1031,6 +942,0 @@\n-  \/\/ Also exclude the register we use to save the SP for MethodHandle\n-  \/\/ invokes to from the corresponding MH debug masks\n-  const RegMask sp_save_mask = method_handle_invoke_SP_save_mask();\n-  mh_caller_save_regmask.OR(sp_save_mask);\n-  mh_caller_save_regmask_exclude_soe.OR(sp_save_mask);\n-\n@@ -1312,1 +1217,0 @@\n-  bool             is_method_handle_invoke = false;  \/\/ for special kill effects\n@@ -1338,2 +1242,0 @@\n-      is_method_handle_invoke = call_java->is_method_handle_invoke();\n-      mcall_java->_method_handle_invoke = is_method_handle_invoke;\n@@ -1342,3 +1244,0 @@\n-      if (is_method_handle_invoke) {\n-        C->set_has_method_handle_invokes(true);\n-      }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":108,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-  friend class VMStructs;\n-\n@@ -182,1 +180,0 @@\n-  RegMask *idealreg2mhdebugmask[_last_machine_leaf];\n@@ -190,2 +187,0 @@\n-  static RegMask mh_caller_save_regmask;\n-  static RegMask mh_caller_save_regmask_exclude_soe;\n@@ -431,2 +426,0 @@\n-  static const RegMask method_handle_invoke_SP_save_mask();\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4456,4 +4456,1 @@\n-  if (outcnt() != 2) {\n-    assert(Opcode() == Op_Initialize, \"Only seen when there are no use of init memory\");\n-    assert(outcnt() == 1, \"Only control then\");\n-  }\n+  assert(outcnt() > 0 && outcnt() <= 2, \"Only one or two out edges allowed\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1069,1 +1069,0 @@\n-  bool is_method_handle_invoke = false;\n@@ -1082,5 +1081,0 @@\n-    \/\/ Is the call a MethodHandle call?\n-      if (mcall->as_MachCallJava()->_method_handle_invoke) {\n-        assert(C->has_method_handle_invokes(), \"must have been set during call generation\");\n-        is_method_handle_invoke = true;\n-      }\n@@ -1287,1 +1281,0 @@\n-      is_method_handle_invoke,\n@@ -1466,3 +1459,0 @@\n-  if (C->has_method_handle_invokes())\n-    total_req += deopt_handler_req;  \/\/ deopt MH handler\n-\n@@ -1903,7 +1893,0 @@\n-\n-    \/\/ Emit the MethodHandle deopt handler code (if required).\n-    if (C->has_method_handle_invokes() && !C->failing()) {\n-      \/\/ We can use the same code as for the normal deopt handler, we\n-      \/\/ just need a different entry point address.\n-      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(masm));\n-    }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,4 +92,3 @@\n-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, after Apply Memop Reordering\") \\\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, after Adjusting Pre-loop Limit\") \\\n-  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, after Adding Speculative Runtime Checks\") \\\n-  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, after Apply\") \\\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 2, after Adjusting Pre-loop Limit\") \\\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 3, after Adding Speculative Runtime Checks\") \\\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 4, after Apply\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1836,0 +1836,56 @@\n+#ifndef PRODUCT\n+static void debug_print_convert_type(const Type** fields, int* argp, Node *parm) {\n+  const BasicType bt = parm->bottom_type()->basic_type();\n+  fields[(*argp)++] = Type::get_const_basic_type(bt);\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    fields[(*argp)++] = Type::HALF;\n+  }\n+}\n+\n+static void update_arg_cnt(const Node* parm, int* arg_cnt) {\n+  (*arg_cnt)++;\n+  const BasicType bt = parm->bottom_type()->basic_type();\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    (*arg_cnt)++;\n+  }\n+}\n+\n+const TypeFunc* OptoRuntime::debug_print_Type(Node* parm0, Node* parm1,\n+                                        Node* parm2, Node* parm3,\n+                                        Node* parm4, Node* parm5,\n+                                        Node* parm6) {\n+  int argcnt = 1;\n+  if (parm0 != nullptr) { update_arg_cnt(parm0, &argcnt);\n+  if (parm1 != nullptr) { update_arg_cnt(parm1, &argcnt);\n+  if (parm2 != nullptr) { update_arg_cnt(parm2, &argcnt);\n+  if (parm3 != nullptr) { update_arg_cnt(parm3, &argcnt);\n+  if (parm4 != nullptr) { update_arg_cnt(parm4, &argcnt);\n+  if (parm5 != nullptr) { update_arg_cnt(parm5, &argcnt);\n+  if (parm6 != nullptr) { update_arg_cnt(parm6, &argcnt);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+\n+  \/\/ create input type (domain)\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ static string pointer\n+\n+  if (parm0 != nullptr) { debug_print_convert_type(fields, &argp, parm0);\n+  if (parm1 != nullptr) { debug_print_convert_type(fields, &argp, parm1);\n+  if (parm2 != nullptr) { debug_print_convert_type(fields, &argp, parm2);\n+  if (parm3 != nullptr) { debug_print_convert_type(fields, &argp, parm3);\n+  if (parm4 != nullptr) { debug_print_convert_type(fields, &argp, parm4);\n+  if (parm5 != nullptr) { debug_print_convert_type(fields, &argp, parm5);\n+  if (parm6 != nullptr) { debug_print_convert_type(fields, &argp, parm6);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -1969,3 +2025,0 @@\n-\n-    \/\/ Check if the exception PC is a MethodHandle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":56,"deletions":3,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -752,0 +752,10 @@\n+#ifndef PRODUCT\n+  \/\/ Signature for runtime calls in debug printing nodes, which depends on which nodes are actually passed\n+  \/\/ Note: we do not allow more than 7 node arguments as GraphKit::make_runtime_call only allows 8, and we need\n+  \/\/ one for the static string\n+  static const TypeFunc* debug_print_Type(Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                                          Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                                          Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                                          Node* parm6 = nullptr);\n+#endif \/\/ PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,0 +56,5 @@\n+  static constexpr uint STACKED_CONCAT_UPPER_BOUND = 256; \/\/ argument limit for a merged concat.\n+                                                          \/\/ The value 256 was derived by measuring\n+                                                          \/\/ compilation time on variable length sequences\n+                                                          \/\/ of stackable concatenations and chosen to keep\n+                                                          \/\/ a safe margin to any critical point.\n@@ -298,0 +303,2 @@\n+\n+  uint arguments_appended = 0;\n@@ -306,0 +313,1 @@\n+      arguments_appended += other->num_arguments();\n@@ -308,0 +316,12 @@\n+      arguments_appended++;\n+    }\n+    \/\/ Check if this concatenation would result in an excessive number of arguments\n+    \/\/ -- leading to high memory use, compilation time, and later, a large number of IR nodes\n+    \/\/ -- and bail out in that case.\n+    if (arguments_appended > STACKED_CONCAT_UPPER_BOUND) {\n+#ifndef PRODUCT\n+      if (PrintOptimizeStringConcat) {\n+        tty->print_cr(\"Merge candidate of length %d exceeds argument limit\", arguments_appended);\n+      }\n+#endif\n+      return nullptr;\n@@ -683,1 +703,1 @@\n-            if (merged->validate_control_flow() && merged->validate_mem_flow()) {\n+            if (merged != nullptr && merged->validate_control_flow() && merged->validate_mem_flow()) {\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -1555,1 +1556,3 @@\n-      address((jlong) blob) { }\n+      address((jlong) blob),\n+      code_begin((jlong) blob->code_begin()),\n+      is_nmethod((jboolean) blob->is_nmethod()) { }\n@@ -1561,0 +1564,2 @@\n+  const jlong       code_begin;\n+  const jboolean    is_nmethod;\n@@ -1567,1 +1572,1 @@\n-  jobjectArray result = env->NewObjectArray(4, clazz, nullptr);\n+  jobjectArray result = env->NewObjectArray(6, clazz, nullptr);\n@@ -1585,0 +1590,8 @@\n+  obj = longBox(thread, env, cb->code_begin);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 4, obj);\n+\n+  obj = booleanBox(thread, env, cb->is_nmethod);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 5, obj);\n+\n@@ -1634,0 +1647,38 @@\n+WB_ENTRY(void, WB_RelocateNMethodFromMethod(JNIEnv* env, jobject o, jobject method, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION(env);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  nmethod* code = mh->code();\n+  if (code != nullptr) {\n+    MutexLocker ml_Compile_lock(Compile_lock);\n+    CompiledICLocker ic_locker(code);\n+    MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    code->relocate(static_cast<CodeBlobType>(blob_type));\n+  }\n+WB_END\n+\n+WB_ENTRY(void, WB_RelocateNMethodFromAddr(JNIEnv* env, jobject o, jlong addr, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  CHECK_JNI_EXCEPTION(env);\n+  void* address = (void*) addr;\n+\n+  if (address == nullptr) {\n+    return;\n+  }\n+\n+  MutexLocker ml_Compile_lock(Compile_lock);\n+  MutexLocker ml_CompiledIC_lock(CompiledIC_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ Verify that nmethod address is still valid\n+  CodeBlob* blob = CodeCache::find_blob(address);\n+  if (blob != nullptr && blob->is_nmethod()) {\n+    nmethod* code = blob->as_nmethod();\n+    if (code->is_in_use()) {\n+      CompiledICLocker ic_locker(code);\n+      code->relocate(static_cast<CodeBlobType>(blob_type));\n+    }\n+  }\n+WB_END\n+\n@@ -2769,1 +2820,1 @@\n-WB_ENTRY(void, WB_BusyWait(JNIEnv* env, jobject wb, jint time))\n+WB_ENTRY(void, WB_BusyWaitCPUTime(JNIEnv* env, jobject wb, jint time))\n@@ -2780,2 +2831,1 @@\n-    JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE);\n-    return JNI_TRUE;\n+    return JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE) ? JNI_TRUE : JNI_FALSE;\n@@ -2787,8 +2837,0 @@\n-WB_ENTRY(jlong, WB_CPUSamplerOutOfStackWalkingIterations(JNIEnv* env, jobject wb))\n-  #if defined(ASSERT) && INCLUDE_JFR && defined(LINUX)\n-    return (jlong)JfrCPUTimeThreadSampling::out_of_stack_walking_iterations();\n-  #else\n-    return 0;\n-  #endif\n-WB_END\n-\n@@ -3026,0 +3068,3 @@\n+  {CC\"relocateNMethodFromMethod0\", CC\"(Ljava\/lang\/reflect\/Executable;I)V\",\n+                                                      (void*)&WB_RelocateNMethodFromMethod },\n+  {CC\"relocateNMethodFromAddr\", CC\"(JI)V\",            (void*)&WB_RelocateNMethodFromAddr },\n@@ -3154,1 +3199,1 @@\n-  {CC\"busyWait\", CC\"(I)V\",                            (void*)&WB_BusyWait},\n+  {CC\"busyWaitCPUTime\", CC\"(I)V\",                     (void*)&WB_BusyWaitCPUTime},\n@@ -3156,1 +3201,0 @@\n-  {CC\"cpuSamplerOutOfStackWalkingIterations\", CC\"()J\",(void*)&WB_CPUSamplerOutOfStackWalkingIterations},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":59,"deletions":15,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -1522,0 +1523,4 @@\n+static size_t clamp_by_size_t_max(uint64_t value) {\n+  return (size_t)MIN2(value, (uint64_t)std::numeric_limits<size_t>::max());\n+}\n+\n@@ -1523,16 +1528,13 @@\n-  julong phys_mem;\n-\n-  \/\/ If the user specified one of these options, they\n-  \/\/ want specific memory sizing so do not limit memory\n-  \/\/ based on compressed oops addressability.\n-  \/\/ Also, memory limits will be calculated based on\n-  \/\/ available os physical memory, not our MaxRAM limit,\n-  \/\/ unless MaxRAM is also specified.\n-  bool override_coop_limit = (!FLAG_IS_DEFAULT(MaxRAMPercentage) ||\n-                           !FLAG_IS_DEFAULT(MinRAMPercentage) ||\n-                           !FLAG_IS_DEFAULT(InitialRAMPercentage) ||\n-                           !FLAG_IS_DEFAULT(MaxRAM));\n-  if (override_coop_limit) {\n-    if (FLAG_IS_DEFAULT(MaxRAM)) {\n-      phys_mem = static_cast<julong>(os::physical_memory());\n-      FLAG_SET_ERGO(MaxRAM, (uint64_t)phys_mem);\n+  uint64_t physical_memory;\n+\n+  \/\/ Check if the user has configured any limit on the amount of RAM we may use.\n+  bool has_ram_limit = !FLAG_IS_DEFAULT(MaxRAMPercentage) ||\n+                       !FLAG_IS_DEFAULT(MinRAMPercentage) ||\n+                       !FLAG_IS_DEFAULT(InitialRAMPercentage) ||\n+                       !FLAG_IS_DEFAULT(MaxRAM);\n+\n+  if (has_ram_limit) {\n+    if (!FLAG_IS_DEFAULT(MaxRAM)) {\n+      \/\/ The user has configured MaxRAM, use that instead of physical memory\n+      \/\/ reported by the OS.\n+      physical_memory = MaxRAM;\n@@ -1540,1 +1542,4 @@\n-      phys_mem = (julong)MaxRAM;\n+      \/\/ The user has configured a limit, make sure MaxRAM reflects the physical\n+      \/\/ memory limit that heap sizing takes into account.\n+      physical_memory = os::physical_memory();\n+      FLAG_SET_ERGO(MaxRAM, physical_memory);\n@@ -1543,2 +1548,4 @@\n-    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(static_cast<julong>(os::physical_memory()), (julong)MaxRAM)\n-                                       : (julong)MaxRAM;\n+    \/\/ If the user did not specify any limit, choose the lowest of the available\n+    \/\/ physical memory and MaxRAM. MaxRAM is typically set to 128GB on 64-bit\n+    \/\/ architecture.\n+    physical_memory = MIN2(os::physical_memory(), MaxRAM);\n@@ -1547,3 +1554,3 @@\n-  \/\/ If the maximum heap size has not been set with -Xmx,\n-  \/\/ then set it as fraction of the size of physical memory,\n-  \/\/ respecting the maximum and minimum sizes of the heap.\n+  \/\/ If the maximum heap size has not been set with -Xmx, then set it as\n+  \/\/ fraction of the size of physical memory, respecting the maximum and\n+  \/\/ minimum sizes of the heap.\n@@ -1551,2 +1558,6 @@\n-    julong reasonable_max = (julong)(((double)phys_mem * MaxRAMPercentage) \/ 100);\n-    const julong reasonable_min = (julong)(((double)phys_mem * MinRAMPercentage) \/ 100);\n+    uint64_t min_memory = (uint64_t)(((double)physical_memory * MinRAMPercentage) \/ 100);\n+    uint64_t max_memory = (uint64_t)(((double)physical_memory * MaxRAMPercentage) \/ 100);\n+\n+    const size_t reasonable_min = clamp_by_size_t_max(min_memory);\n+    size_t reasonable_max = clamp_by_size_t_max(max_memory);\n+\n@@ -1559,1 +1570,1 @@\n-      reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);\n+      reasonable_max = MAX2(reasonable_max, MaxHeapSize);\n@@ -1564,1 +1575,1 @@\n-      reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);\n+      reasonable_max = MIN2(reasonable_max, ErgoHeapSizeLimit);\n@@ -1574,1 +1585,1 @@\n-      reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);\n+      reasonable_max = MAX2(reasonable_max, InitialHeapSize);\n@@ -1576,1 +1587,1 @@\n-      reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);\n+      reasonable_max = MAX2(reasonable_max, MinHeapSize);\n@@ -1585,2 +1596,2 @@\n-          log_debug(gc, heap, coops)(\"HeapBaseMinAddress must be at least %zu\"\n-                                     \" (%zuG) which is greater than value given %zu\",\n+          log_debug(gc, heap, coops)(\"HeapBaseMinAddress must be at least %zu \"\n+                                     \"(%zuG) which is greater than value given %zu\",\n@@ -1594,0 +1605,1 @@\n+\n@@ -1595,2 +1607,2 @@\n-      \/\/ Limit the heap size to the maximum possible when using compressed oops\n-      julong max_coop_heap = (julong)max_heap_for_compressed_oops();\n+      size_t heap_end = HeapBaseMinAddress + MaxHeapSize;\n+      size_t max_coop_heap = max_heap_for_compressed_oops();\n@@ -1598,3 +1610,4 @@\n-      if (HeapBaseMinAddress + MaxHeapSize < max_coop_heap) {\n-        \/\/ Heap should be above HeapBaseMinAddress to get zero based compressed oops\n-        \/\/ but it should be not less than default MaxHeapSize.\n+      \/\/ Limit the heap size to the maximum possible when using compressed oops\n+      if (heap_end < max_coop_heap) {\n+        \/\/ Heap should be above HeapBaseMinAddress to get zero based compressed\n+        \/\/ oops but it should be not less than default MaxHeapSize.\n@@ -1604,4 +1617,3 @@\n-      \/\/ If user specified flags prioritizing os physical\n-      \/\/ memory limits, then disable compressed oops if\n-      \/\/ limits exceed max_coop_heap and UseCompressedOops\n-      \/\/ was not specified.\n+      \/\/ If the user has configured any limit on the amount of RAM we may use,\n+      \/\/ then disable compressed oops if the calculated max exceeds max_coop_heap\n+      \/\/ and UseCompressedOops was not specified.\n@@ -1609,5 +1621,5 @@\n-        if (FLAG_IS_ERGO(UseCompressedOops) && override_coop_limit) {\n-          aot_log_info(aot)(\"UseCompressedOops disabled due to\"\n-            \" max heap %zu > compressed oop heap %zu. \"\n-            \"Please check the setting of MaxRAMPercentage %5.2f.\"\n-            ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);\n+        if (FLAG_IS_ERGO(UseCompressedOops) && has_ram_limit) {\n+          aot_log_info(aot)(\"UseCompressedOops disabled due to \"\n+                            \"max heap %zu > compressed oop heap %zu. \"\n+                            \"Please check the setting of MaxRAMPercentage %5.2f.\",\n+                            reasonable_max, max_coop_heap, MaxRAMPercentage);\n@@ -1616,1 +1628,1 @@\n-          reasonable_max = MIN2(reasonable_max, max_coop_heap);\n+          reasonable_max = max_coop_heap;\n@@ -1622,2 +1634,2 @@\n-    log_trace(gc, heap)(\"  Maximum heap size %zu\", (size_t) reasonable_max);\n-    FLAG_SET_ERGO(MaxHeapSize, (size_t)reasonable_max);\n+    log_trace(gc, heap)(\"  Maximum heap size %zu\", reasonable_max);\n+    FLAG_SET_ERGO(MaxHeapSize, reasonable_max);\n@@ -1629,4 +1641,2 @@\n-    julong reasonable_minimum = (julong)(OldSize + NewSize);\n-\n-    reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);\n-\n+    size_t reasonable_minimum = clamp_by_size_t_max((uint64_t)OldSize + (uint64_t)NewSize);\n+    reasonable_minimum = MIN2(reasonable_minimum, MaxHeapSize);\n@@ -1636,1 +1646,2 @@\n-      julong reasonable_initial = (julong)(((double)phys_mem * InitialRAMPercentage) \/ 100);\n+      uint64_t initial_memory = (uint64_t)(((double)physical_memory * InitialRAMPercentage) \/ 100);\n+      size_t reasonable_initial = clamp_by_size_t_max(initial_memory);\n@@ -1639,2 +1650,2 @@\n-      reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)MinHeapSize);\n-      reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);\n+      reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, MinHeapSize);\n+      reasonable_initial = MIN2(reasonable_initial, MaxHeapSize);\n@@ -1645,0 +1656,1 @@\n+\n@@ -1648,1 +1660,1 @@\n-      FLAG_SET_ERGO(MinHeapSize, MIN2((size_t)reasonable_minimum, InitialHeapSize));\n+      FLAG_SET_ERGO(MinHeapSize, MIN2(reasonable_minimum, InitialHeapSize));\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":67,"deletions":55,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1762,5 +1762,2 @@\n-  assert((current->held_monitor_count() == 0 && current->jni_monitor_count() == 0),\n-         \"Held monitor count should not be used for lightweight locking: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n-\n-  if (entry->is_pinned() || current->held_monitor_count() > 0) {\n-    log_develop_debug(continuations)(\"PINNED due to critical section\/hold monitor\");\n+  if (entry->is_pinned()) {\n+    log_develop_debug(continuations)(\"PINNED due to critical section\");\n@@ -1768,1 +1765,1 @@\n-    freeze_result res = entry->is_pinned() ? freeze_pinned_cs : freeze_pinned_monitor;\n+    const freeze_result res = freeze_pinned_cs;\n@@ -1825,2 +1822,0 @@\n-  } else if (thread->held_monitor_count() > 0) {\n-    return freeze_pinned_monitor;\n@@ -1862,1 +1857,0 @@\n-      intx monitor_count = entry->parent_held_monitor_count();\n@@ -1869,2 +1863,0 @@\n-      } else if (monitor_count > 0) {\n-        return freeze_pinned_monitor;\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -639,6 +639,1 @@\n-\n-  \/\/ If the deopt call site is a MethodHandle invoke call site we have\n-  \/\/ to adjust the unpack_sp.\n-  nmethod* deoptee_nm = deoptee.cb()->as_nmethod_or_null();\n-  if (deoptee_nm != nullptr && deoptee_nm->is_method_handle_return(deoptee.pc()))\n-    unpack_sp = deoptee.unextended_sp();\n+  assert(unpack_sp == deoptee.unextended_sp(), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,4 +213,1 @@\n-    if (nm->is_method_handle_return(pc()))\n-      return nm->deopt_mh_handler_begin() - pc_return_offset;\n-    else\n-      return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_begin() - pc_return_offset;\n@@ -365,3 +362,1 @@\n-  address deopt = nm->is_method_handle_return(pc()) ?\n-                        nm->deopt_mh_handler_begin() :\n-                        nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1595,0 +1595,3 @@\n+  product(bool, NMethodRelocation, false, EXPERIMENTAL,                     \\\n+          \"Enables use of experimental function nmethod::relocate()\")       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -480,1 +480,0 @@\n-  _is_method_handle_return(0),\n@@ -493,2 +492,0 @@\n-  _held_monitor_count(0),\n-  _jni_monitor_count(0),\n@@ -932,21 +929,0 @@\n-    \/\/ Check for monitor counts being out of sync.\n-    assert(held_monitor_count() == jni_monitor_count(),\n-           \"held monitor count should be equal to jni: %zd != %zd\",\n-           held_monitor_count(), jni_monitor_count());\n-    \/\/ All in-use monitors, including JNI-locked ones, should have been released above.\n-    assert(held_monitor_count() == 0, \"Failed to unlock %zd object monitors\",\n-           held_monitor_count());\n-  } else {\n-    \/\/ Check for monitor counts being out of sync.\n-    assert(held_monitor_count() == jni_monitor_count(),\n-           \"held monitor count should be equal to jni: %zd != %zd\",\n-           held_monitor_count(), jni_monitor_count());\n-    \/\/ It is possible that a terminating thread failed to unlock monitors it locked\n-    \/\/ via JNI so we don't assert the count is zero.\n-  }\n-\n-  if (CheckJNICalls && jni_monitor_count() > 0) {\n-    \/\/ We would like a fatal here, but due to we never checked this before there\n-    \/\/ is a lot of tests which breaks, even with an error log.\n-    log_debug(jni)(\"JavaThread %s (tid: %zu) with Objects still locked by JNI MonitorEnter.\",\n-                   exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n@@ -1993,20 +1969,0 @@\n-\/\/ Slow-path increment of the held monitor counts. JNI locking is always\n-\/\/ this slow-path.\n-void JavaThread::inc_held_monitor_count(intx i, bool jni) {\n-#ifdef SUPPORT_MONITOR_COUNT\n-  \/\/ Nothing to do. Just do some sanity check.\n-  assert(_held_monitor_count == 0, \"counter should not be used\");\n-  assert(_jni_monitor_count == 0, \"counter should not be used\");\n-#endif \/\/ SUPPORT_MONITOR_COUNT\n-}\n-\n-\/\/ Slow-path decrement of the held monitor counts. JNI unlocking is always\n-\/\/ this slow-path.\n-void JavaThread::dec_held_monitor_count(intx i, bool jni) {\n-#ifdef SUPPORT_MONITOR_COUNT\n-  \/\/ Nothing to do. Just do some sanity check.\n-  assert(_held_monitor_count == 0, \"counter should not be used\");\n-  assert(_jni_monitor_count == 0, \"counter should not be used\");\n-#endif \/\/ SUPPORT_MONITOR_COUNT\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -454,1 +454,0 @@\n-  volatile int     _is_method_handle_return;     \/\/ true (== 1) if the current exception PC is a MethodHandle call site.\n@@ -481,3 +480,0 @@\n-  \/\/ It's signed for error detection.\n-  intx _held_monitor_count;  \/\/ used by continuations for fast lock detection\n-  intx _jni_monitor_count;\n@@ -667,7 +663,0 @@\n-  void inc_held_monitor_count(intx i = 1, bool jni = false);\n-  void dec_held_monitor_count(intx i = 1, bool jni = false);\n-\n-  intx held_monitor_count() { return _held_monitor_count; }\n-  intx jni_monitor_count()  { return _jni_monitor_count;  }\n-  void clear_jni_monitor_count() { _jni_monitor_count = 0; }\n-\n@@ -824,1 +813,0 @@\n-  void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }\n@@ -874,1 +862,0 @@\n-  static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }\n@@ -908,2 +895,0 @@\n-  static ByteSize held_monitor_count_offset() { return byte_offset_of(JavaThread, _held_monitor_count); }\n-  static ByteSize jni_monitor_count_offset()  { return byte_offset_of(JavaThread, _jni_monitor_count); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -273,0 +273,40 @@\n+\n+#ifdef COMPILER2\n+\/\/ Runtime methods for printf-style debug nodes (same printing format as fieldDescriptor::print_on_for)\n+void SharedRuntime::debug_print_value(jboolean x) {\n+  tty->print_cr(\"boolean %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jbyte x) {\n+  tty->print_cr(\"byte %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jshort x) {\n+  tty->print_cr(\"short %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jchar x) {\n+  tty->print_cr(\"char %c %d\", isprint(x) ? x : ' ', x);\n+}\n+\n+void SharedRuntime::debug_print_value(jint x) {\n+  tty->print_cr(\"int %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jlong x) {\n+  tty->print_cr(\"long \" JLONG_FORMAT, x);\n+}\n+\n+void SharedRuntime::debug_print_value(jfloat x) {\n+  tty->print_cr(\"float %f\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jdouble x) {\n+  tty->print_cr(\"double %lf\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(oopDesc* x) {\n+  x->print();\n+}\n+#endif \/\/ COMPILER2\n+\n@@ -534,3 +574,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -551,2 +588,0 @@\n-    \/\/ Set flag if return address is a method handle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n@@ -2083,1 +2118,0 @@\n-      current->dec_held_monitor_count();\n@@ -2105,14 +2139,0 @@\n-\/\/ This is only called when CheckJNICalls is true, and only\n-\/\/ for virtual thread termination.\n-JRT_LEAF(void,  SharedRuntime::log_jni_monitor_still_held())\n-  assert(CheckJNICalls, \"Only call this when checking JNI usage\");\n-  if (log_is_enabled(Debug, jni)) {\n-    JavaThread* current = JavaThread::current();\n-    int64_t vthread_id = java_lang_Thread::thread_id(current->vthread());\n-    int64_t carrier_id = java_lang_Thread::thread_id(current->threadObj());\n-    log_debug(jni)(\"VirtualThread (tid: \" INT64_FORMAT \", carrier id: \" INT64_FORMAT\n-                   \") exiting with Objects still locked by JNI MonitorEnter.\",\n-                   vthread_id, carrier_id);\n-  }\n-JRT_END\n-\n@@ -2607,0 +2627,1 @@\n+volatile uint AdapterHandlerLibrary::_id_counter = 0;\n@@ -2699,1 +2720,3 @@\n-  return AdapterHandlerEntry::allocate(fingerprint);\n+  uint id = (uint)AtomicAccess::add((int*)&_id_counter, 1);\n+  assert(id > 0, \"we can never overflow because AOT cache cannot contain more than 2^32 methods\");\n+  return AdapterHandlerEntry::allocate(id, fingerprint);\n@@ -3183,2 +3206,2 @@\n-  const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n-  const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+  const char* name = AdapterHandlerLibrary::name(handler);\n+  const uint32_t id = AdapterHandlerLibrary::id(handler);\n@@ -3291,2 +3314,2 @@\n-    const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n-    const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+    const char* name = AdapterHandlerLibrary::name(handler);\n+    const uint32_t id = AdapterHandlerLibrary::id(handler);\n@@ -3437,0 +3460,1 @@\n+  uint max_id = 0;\n@@ -3438,1 +3462,7 @@\n-  _aot_adapter_handler_table.iterate([](AdapterHandlerEntry* entry) {\n+  \/* It is possible that some adapters generated in assembly phase are not stored in the cache.\n+   * That implies adapter ids of the adapters in the cache may not be contiguous.\n+   * If the size of the _aot_adapter_handler_table is used to initialize _id_counter, then it may\n+   * result in collision of adapter ids between AOT stored handlers and runtime generated handlers.\n+   * To avoid such situation, initialize the _id_counter with the largest adapter id among the AOT stored handlers.\n+   *\/\n+  _aot_adapter_handler_table.iterate([&](AdapterHandlerEntry* entry) {\n@@ -3441,0 +3471,1 @@\n+    max_id = MAX2(max_id, entry->id());\n@@ -3442,0 +3473,3 @@\n+  \/\/ Set adapter id to the maximum id found in the AOTCache\n+  assert(_id_counter == 0, \"Did not expect new AdapterHandlerEntry to be created at this stage\");\n+  _id_counter = max_id;\n@@ -3832,2 +3866,2 @@\n-const char* AdapterHandlerLibrary::name(AdapterFingerPrint* fingerprint) {\n-  return fingerprint->as_basic_args_string();\n+const char* AdapterHandlerLibrary::name(AdapterHandlerEntry* handler) {\n+  return handler->fingerprint()->as_basic_args_string();\n@@ -3836,3 +3870,2 @@\n-uint32_t AdapterHandlerLibrary::id(AdapterFingerPrint* fingerprint) {\n-  unsigned int hash = fingerprint->compute_hash();\n-  return hash;\n+uint32_t AdapterHandlerLibrary::id(AdapterHandlerEntry* handler) {\n+  return handler->id();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":64,"deletions":31,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -412,3 +413,0 @@\n-  \/\/ Issue UL warning for unlocked JNI monitor on virtual thread termination\n-  static void log_jni_monitor_still_held();\n-\n@@ -665,0 +663,33 @@\n+#ifdef COMPILER2\n+  \/\/ Runtime methods for printf-style debug nodes\n+  static void debug_print_value(jboolean x);\n+  static void debug_print_value(jbyte x);\n+  static void debug_print_value(jshort x);\n+  static void debug_print_value(jchar x);\n+  static void debug_print_value(jint x);\n+  static void debug_print_value(jlong x);\n+  static void debug_print_value(jfloat x);\n+  static void debug_print_value(jdouble x);\n+  static void debug_print_value(oopDesc* x);\n+\n+  template <typename T, typename... Rest>\n+  static void debug_print_rec(T arg, Rest... args) {\n+    debug_print_value(arg);\n+    debug_print_rec(args...);\n+  }\n+\n+  static void debug_print_rec() {}\n+\n+  \/\/ template is required here as we need to know the exact signature at compile-time\n+  template <typename... TT>\n+  static void debug_print(const char *str, TT... args) {\n+    \/\/ these three lines are the manual expansion of JRT_LEAF ... JRT_END, does not work well with templates\n+    DEBUG_ONLY(NoHandleMark __hm;)\n+    os::verify_stack_alignment();\n+    DEBUG_ONLY(NoSafepointVerifier __nsv;)\n+\n+    tty->print_cr(\"%s\", str);\n+    debug_print_rec(args...);\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -713,0 +744,1 @@\n+  uint _id;\n@@ -727,1 +759,1 @@\n-  AdapterHandlerEntry(AdapterFingerPrint* fingerprint) :\n+  AdapterHandlerEntry(int id, AdapterFingerPrint* fingerprint) :\n@@ -730,0 +762,1 @@\n+    _id(id),\n@@ -751,2 +784,2 @@\n-  static AdapterHandlerEntry* allocate(AdapterFingerPrint* fingerprint) {\n-    return new(0) AdapterHandlerEntry(fingerprint);\n+  static AdapterHandlerEntry* allocate(uint id, AdapterFingerPrint* fingerprint) {\n+    return new(0) AdapterHandlerEntry(id, fingerprint);\n@@ -834,0 +867,1 @@\n+  uint id() const { return _id; }\n@@ -862,0 +896,1 @@\n+  static volatile uint _id_counter; \/\/ counter for generating unique adapter ids, range = [1,UINT_MAX]\n@@ -901,2 +936,2 @@\n-  static const char* name(AdapterFingerPrint* fingerprint);\n-  static uint32_t id(AdapterFingerPrint* fingerprint);\n+  static const char* name(AdapterHandlerEntry* handler);\n+  static uint32_t id(AdapterHandlerEntry* handler);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":43,"deletions":8,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -484,1 +484,0 @@\n-      current->inc_held_monitor_count(1, true);\n@@ -503,1 +502,0 @@\n-    current->dec_held_monitor_count(1, true);\n@@ -1306,2 +1304,1 @@\n-    intx rec = mid->complete_exit(_thread);\n-    _thread->dec_held_monitor_count(rec + 1);\n+    mid->complete_exit(_thread);\n@@ -1333,3 +1330,0 @@\n-  assert(current->held_monitor_count() == 0, \"Should not be possible\");\n-  \/\/ All monitors (including entered via JNI) have been unlocked above, so we need to clear jni count.\n-  current->clear_jni_monitor_count();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -450,0 +450,3 @@\n+  \/\/ Deferred \"static\" initialization\n+  NonJavaThread::init();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,3 +63,0 @@\n-#include \"oops\/instanceClassLoaderKlass.hpp\"\n-#include \"oops\/instanceMirrorKlass.hpp\"\n-#include \"oops\/instanceStackChunkKlass.hpp\"\n@@ -89,1 +86,0 @@\n-#include \"runtime\/java.hpp\"\n@@ -545,1 +541,0 @@\n-  nonstatic_field(nmethod,                     _deopt_mh_handler_offset,                      int)                                   \\\n@@ -617,1 +612,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n@@ -1723,1 +1717,0 @@\n-  declare_constant(PcDesc::PCDESC_is_method_handle_invoke)                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -323,2 +323,0 @@\n-  friend class VMStructs;\n-\n@@ -726,0 +724,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-     * @param invocationName unused\n+     * @param invocationName unused, {@code null} is permitted\n@@ -175,1 +175,1 @@\n-     * @throws NullPointerException     if any argument is {@code null}\n+     * @throws NullPointerException     if any argument is {@code null}, unless noted otherwise\n@@ -178,1 +178,1 @@\n-     *                                  second parameter of type {@code int} and with {@code int} as its return type,\n+     *                                  second parameter of type {@code int} and with {@code int} as its return type\n@@ -181,1 +181,1 @@\n-     *                                  {@code Class} or {@code EnumDesc}.\n+     *                                  {@code Class} or {@code EnumDesc}\n@@ -183,1 +183,1 @@\n-     *                                  when {@code target} is a {@code Boolean.class}.\n+     *                                  when {@code target} is a {@code Boolean.class}\n@@ -258,2 +258,3 @@\n-     * If no element in the {@code labels} array matches the target, then\n-     * the method of the call site return the length of the {@code labels} array.\n+     * If for a given {@code target} there is no element in the {@code labels}\n+     * fulfilling one of the above conditions, then the method of the call\n+     * site returns the length of the {@code labels} array.\n@@ -263,1 +264,4 @@\n-     * both  or an {@link IndexOutOfBoundsException} is thrown.\n+     * or an {@link IndexOutOfBoundsException} is thrown.\n+     *\n+     * @apiNote It is permissible for the {@code labels} array to contain {@code String}\n+     * values that do not represent any enum constants at runtime.\n@@ -268,1 +272,1 @@\n-     * @param invocationName unused\n+     * @param invocationName unused, {@code null} is permitted\n@@ -275,6 +279,9 @@\n-     * @throws NullPointerException if any argument is {@code null}\n-     * @throws IllegalArgumentException if any element in the labels array is null, if the\n-     * invocation type is not a method type whose first parameter type is an enum type,\n-     * second parameter of type {@code int} and whose return type is {@code int},\n-     * or if {@code labels} contains an element that is not of type {@code String} or\n-     * {@code Class} of the target enum type.\n+     * @throws NullPointerException     if any argument is {@code null}, unless noted otherwise\n+     * @throws IllegalArgumentException if any element in the labels array is null\n+     * @throws IllegalArgumentException if any element in the labels array is an empty {@code String}\n+     * @throws IllegalArgumentException if the invocation type is not a method type\n+     *                                  whose first parameter type is an enum type,\n+     *                                  second parameter of type {@code int} and\n+     *                                  whose return type is {@code int}\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code String} or\n+     *                                  {@code Class} equal to the target enum type\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -150,24 +150,3 @@\n-\n-        \/\/ Already initialized?\n-        if (values != null)\n-            return;\n-\n-        \/\/ Initialize enabled categories based on \"-Xlint\" flags\n-        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_ALL)) {\n-            \/\/ If -Xlint or -Xlint:all is given, enable all categories by default\n-            values = EnumSet.allOf(LintCategory.class);\n-        } else if (options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_NONE)) {\n-            \/\/ if -Xlint:none is given, disable all categories by default\n-            values = LintCategory.newEmptySet();\n-        } else {\n-            \/\/ otherwise, enable on-by-default categories\n-            values = getDefaults();\n-        }\n-\n-        \/\/ Look for specific overrides\n-        for (LintCategory lc : LintCategory.values()) {\n-            if (options.isLintExplicitlyEnabled(lc)) {\n-                values.add(lc);\n-            } else if (options.isLintExplicitlyDisabled(lc)) {\n-                values.remove(lc);\n-            }\n+        if (values == null) {\n+            values = options.getLintCategoriesOf(Option.XLINT, this::getDefaults);\n+            suppressedValues = LintCategory.newEmptySet();\n@@ -175,2 +154,0 @@\n-\n-        suppressedValues = LintCategory.newEmptySet();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.EnumSet;\n@@ -58,0 +59,1 @@\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -443,1 +445,2 @@\n-        werror        = options.isSet(WERROR);\n+        werrorAny     = options.isSet(WERROR) || options.isSet(WERROR_CUSTOM, Option.LINT_CUSTOM_ALL);\n+        werrorLint    = options.getLintCategoriesOf(WERROR, LintCategory::newEmptySet);\n@@ -516,1 +519,1 @@\n-    \/** Switch: treat warnings as errors\n+    \/** Switch: treat any kind of warning (lint or non-lint) as an error.\n@@ -518,1 +521,5 @@\n-    protected boolean werror;\n+    protected boolean werrorAny;\n+\n+    \/** Switch: treat lint warnings in the specified {@link LintCategory}s as errors.\n+     *\/\n+    protected EnumSet<LintCategory> werrorLint;\n@@ -584,1 +591,2 @@\n-        if (werror && log.nerrors == 0 && log.nwarnings > 0) {\n+        if (log.nerrors == 0 && log.nwarnings > 0 &&\n+                (werrorAny || werrorLint.clone().removeAll(log.lintWarnings))) {\n@@ -590,0 +598,7 @@\n+    \/**\n+     * Should warnings in the given lint category be treated as errors due to a {@code -Werror} flag?\n+     *\/\n+    public boolean isWerror(LintCategory lc) {\n+        return werrorAny || werrorLint.contains(lc);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-        werror = options.isSet(Option.WERROR);\n+        werror = compiler.isWerror(PROCESSING);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,7 @@\n-    Terminate compilation if warnings occur\n+    Terminate compilation if any warnings occur\n+javac.opt.arg.Werror=\\\n+    <key>(,<key>)*\n+javac.opt.Werror.custom=\\\n+    Specify lint categories for which warnings should terminate compilation,\\n\\\n+    separated by comma. Precede a key by ''-'' to exclude the specified category.\\n\\\n+    Use --help-lint to see the supported keys.\n@@ -340,1 +346,1 @@\n-    Print the supported keys for -Xlint\n+    Print the supported keys for -Xlint and -Werror\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,1 +451,10 @@\n-:   Terminates compilation when warnings occur.\n+:   Terminates compilation when any warnings occur; this includes warnings in all lint\n+    categories, as well as non-lint warnings.\n+\n+<a id=\"option-Werror-custom\">`-Werror:`\\[`-`\\]*key*(`,`\\[`-`\\]*key*)\\*<\/a>\n+:   Specify lint categories for which warnings should terminate compilation. The keys\n+    `all` and `none` include or exclude all categories (respectively); other keys include\n+    the corresponding category, or exclude it if preceded by a hyphen (`-`). By default,\n+    no categories are included. In order to terminate compilation, the category must also\n+    be enabled (via [`-Xlint`](#option-Xlint-custom), if necessary).\n+    See [`-Xlint`](#option-Xlint-custom) below for the list of lint category keys.\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -85,0 +85,11 @@\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#G1 8369147 generic-all\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#Parallel 8369147 generic-all\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#Serial 8369147 generic-all\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#ZGC 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#G1 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#Parallel 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#Serial 8369147 generic-all\n+compiler\/whitebox\/RelocateNMethod.java#ZGC 8369147 generic-all\n+compiler\/whitebox\/StressNMethodRelocation.java 8369147,8369148,8369149 generic-all\n+serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150,8369151 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+  compiler\/gallery \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -191,1 +191,0 @@\n-java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8298823 macosx-all\n@@ -252,0 +251,1 @@\n+sun\/java2d\/OpenGL\/OpaqueDest.java#id1 8367574 macosx-all\n@@ -556,2 +556,0 @@\n-com\/sun\/management\/OperatingSystemMXBean\/GetProcessCpuLoad.java 8030957 aix-all\n-com\/sun\/management\/OperatingSystemMXBean\/GetSystemCpuLoad.java  8030957 aix-all\n@@ -571,1 +569,0 @@\n-javax\/management\/MBeanServer\/OldMBeanServerTest.java            8030957 aix-all\n@@ -620,1 +617,0 @@\n-java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java       8365398 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8331051\n+ * @bug 8331051 8367610\n@@ -29,1 +29,1 @@\n- * @run main SinceChecker java.base --ignoreSince Valhalla --exclude java.lang.classfile\n+ * @run main\/timeout=480 SinceChecker java.base --ignoreSince Valhalla --exclude java.lang.classfile\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.base\/JavaBaseCheckSince.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -507,0 +507,6 @@\n+  private native void     relocateNMethodFromMethod0(Executable method, int type);\n+  public         void     relocateNMethodFromMethod(Executable method, int type) {\n+    Objects.requireNonNull(method);\n+    relocateNMethodFromMethod0(method, type);\n+  }\n+  public native void    relocateNMethodFromAddr(long address, int type);\n@@ -862,1 +868,2 @@\n-  public native void busyWait(int cpuTimeMs);\n+  public native void busyWaitCPUTime(int cpuTimeMs);\n+\n@@ -867,2 +874,0 @@\n-  public native long cpuSamplerOutOfStackWalkingIterations();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}