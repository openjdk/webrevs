{"files":[{"patch":"@@ -128,1 +128,2 @@\n-if [ -d \"$TOPLEVEL_DIR\/.git\" ] ; then\n+# Git worktrees use a '.git' file rather than directory, so test both.\n+if [ -d \"$TOPLEVEL_DIR\/.git\" -o -f \"$TOPLEVEL_DIR\/.git\" ] ; then\n","filename":"bin\/idea.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1454,4 +1454,4 @@\n-<pre><code>bash configure --with-devkit=&lt;devkit-path&gt; --openjdk-target=ppc64-linux-gnu &amp;&amp; make<\/code><\/pre>\n-<p>will configure and build the JDK for Linux\/ppc64 assuming that\n-<code>&lt;devkit-path&gt;<\/code> points to a Linux\/x86_64 to Linux\/ppc64\n-devkit.<\/p>\n+<pre><code>bash configure --with-devkit=&lt;devkit-path&gt; --openjdk-target=ppc64le-linux-gnu &amp;&amp; make<\/code><\/pre>\n+<p>will configure and build the JDK for Linux\/ppc64le assuming that\n+<code>&lt;devkit-path&gt;<\/code> points to a Linux\/x86_64 to\n+Linux\/ppc64le devkit.<\/p>\n@@ -1484,1 +1484,1 @@\n-<td>ppc64-linux-gnu<\/td>\n+<td>ppc64le-linux-gnu<\/td>\n@@ -1487,1 +1487,1 @@\n-<td>ppc64le-linux-gnu<\/td>\n+<td>riscv64-linux-gnu<\/td>\n","filename":"doc\/building.html","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1261,1 +1261,1 @@\n-bash configure --with-devkit=<devkit-path> --openjdk-target=ppc64-linux-gnu && make\n+bash configure --with-devkit=<devkit-path> --openjdk-target=ppc64le-linux-gnu && make\n@@ -1264,2 +1264,2 @@\n-will configure and build the JDK for Linux\/ppc64 assuming that `<devkit-path>`\n-points to a Linux\/x86_64 to Linux\/ppc64 devkit.\n+will configure and build the JDK for Linux\/ppc64le assuming that `<devkit-path>`\n+points to a Linux\/x86_64 to Linux\/ppc64le devkit.\n@@ -1284,1 +1284,0 @@\n-| ppc64-linux-gnu          |\n@@ -1286,0 +1285,1 @@\n+| riscv64-linux-gnu        |\n","filename":"doc\/building.md","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -14,3 +14,1 @@\n-    \/* The extra [class] is a hack that increases specificity enough to\n-       override a similar rule in reveal.js *\/\n-    ul.task-list[class]{list-style: none;}\n+    ul.task-list{list-style: none;}\n@@ -18,1 +16,0 @@\n-      font-size: inherit;\n","filename":"doc\/starting-next-release.html","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-<\/ul><\/li>\n@@ -77,3 +76,2 @@\n-id=\"toc-testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/a>\n-<ul>\n+id=\"toc-testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/a><\/li>\n@@ -438,0 +436,3 @@\n+<h4 id=\"aot_jdk\">AOT_JDK<\/h4>\n+<p>See <a href=\"#testing-ahead-of-time-optimizations\">Testing\n+Ahead-of-time optimizations<\/a>.<\/p>\n@@ -460,0 +461,6 @@\n+<h4 id=\"jvmti_stress_agent\">JVMTI_STRESS_AGENT<\/h4>\n+<p>Executes JTReg tests with JVM TI stress agent. The stress agent is\n+the part of test library and located in\n+<code>test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp<\/code>. The\n+value of this argument is set as JVM TI agent options. This mode uses\n+ProblemList-jvmti-stress-agent.txt as an additional exclude list.<\/p>\n@@ -559,0 +566,6 @@\n+<h4 id=\"test_jdk\">TEST_JDK<\/h4>\n+<p>The path to the JDK that will be used to run the benchmarks.<\/p>\n+<p>Defaults to <code>build\/&lt;CONF-NAME&gt;\/jdk<\/code>.<\/p>\n+<h4 id=\"benchmarks_jar\">BENCHMARKS_JAR<\/h4>\n+<p>The path to the JAR containing the benchmarks.<\/p>\n+<p>Defaults to <code>test\/micro\/benchmarks.jar<\/code>.<\/p>\n@@ -604,2 +617,2 @@\n-<h2 id=\"testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/h2>\n+<h3 id=\"testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/h3>\n","filename":"doc\/testing.html","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -370,0 +370,4 @@\n+#### AOT_JDK\n+\n+See [Testing Ahead-of-time optimizations](#testing-ahead-of-time-optimizations).\n+\n@@ -400,0 +404,7 @@\n+#### JVMTI_STRESS_AGENT\n+\n+Executes JTReg tests with JVM TI stress agent. The stress agent is the part of\n+test library and located in `test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp`.\n+The value of this argument is set as JVM TI agent options.\n+This mode uses ProblemList-jvmti-stress-agent.txt as an additional exclude list.\n+\n@@ -548,0 +559,12 @@\n+#### TEST_JDK\n+\n+The path to the JDK that will be used to run the benchmarks.\n+\n+Defaults to `build\/<CONF-NAME>\/jdk`.\n+\n+#### BENCHMARKS_JAR\n+\n+The path to the JAR containing the benchmarks.\n+\n+Defaults to `test\/micro\/benchmarks.jar`.\n+\n@@ -615,1 +638,1 @@\n--------------------------------------------------------------------------------\n+\n","filename":"doc\/testing.md","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -207,2 +207,3 @@\n-        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY MAX_MEM RUN_PROBLEM_LISTS \\\n-        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n+        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY JVMTI_STRESS_AGENT \\\n+        MAX_MEM RUN_PROBLEM_LISTS RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT \\\n+        AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n@@ -879,0 +880,9 @@\n+  ifneq ($$(JTREG_JVMTI_STRESS_AGENT), )\n+    AGENT := $$(LIBRARY_PREFIX)JvmtiStressAgent$$(SHARED_LIBRARY_SUFFIX)=$$(JTREG_JVMTI_STRESS_AGENT)\n+    $1_JTREG_BASIC_OPTIONS += -javaoption:'-agentpath:$(TEST_IMAGE_DIR)\/hotspot\/jtreg\/native\/$$(AGENT)'\n+    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \\\n+\t    $$(addprefix $$($1_TEST_ROOT)\/, ProblemList-jvmti-stress-agent.txt) \\\n+        ))\n+  endif\n+\n+\n@@ -1246,1 +1256,1 @@\n-      $(TR) -cs '[a-z][A-Z][0-9]\\n' '[_*1000]')) \\\n+      $(TR) -cs '[a-z][A-Z][0-9]\\n' '_')) \\\n@@ -1326,1 +1336,1 @@\n-\t      $(TR) -cs '[a-z][A-Z][0-9]\\n' '[_*1000]')) \\\n+\t      $(TR) -cs '[a-z][A-Z][0-9]\\n' '_')) \\\n@@ -1328,1 +1338,1 @@\n-\t  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c '\\n' '[_*1000]')) \\\n+\t  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c '\\n' '_')) \\\n","filename":"make\/RunTests.gmk","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -179,0 +179,16 @@\n+\n+# These settings are needed to run testing with jvmti agent\n+ifeq ($(OPENJDK_BUILD_OS), linux)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .so\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), windows)\n+  LIBRARY_PREFIX :=\n+  SHARED_LIBRARY_SUFFIX := .dll\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), macosx)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .dylib\n+endif\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -943,1 +943,1 @@\n-  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_CPU\" = \"xlinux\"; then\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n@@ -957,0 +957,11 @@\n+            # Switching the initialization mode with gcc from 'pattern' to 'zero'\n+            # avoids the use of unsupported `__builtin_clear_padding` for variable\n+            # length aggregates\n+            if test \"x$DEBUG_LEVEL\" != xrelease && test \"x$TOOLCHAIN_TYPE\" = xgcc ; then\n+              INIT_ZERO_FLAG=\"-ftrivial-auto-var-init=zero\"\n+              FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [$INIT_ZERO_FLAG],\n+                IF_TRUE: [\n+                  $2SVE_CFLAGS=\"${$2SVE_CFLAGS} $INIT_ZERO_FLAG\"\n+                ]\n+              )\n+            fi\n","filename":"make\/autoconf\/flags-cflags.m4","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-# make TARGETS=\"arm-linux-gnueabihf ppc64-linux-gnu\" BASE_OS=Fedora BASE_OS_VERSION=17\n+# make TARGETS=\"arm-linux-gnueabihf ppc64le-linux-gnu\" BASE_OS=Fedora BASE_OS_VERSION=17\n@@ -53,1 +53,1 @@\n-#    make TARGETS=\"arm-linux-gnueabihf,ppc64-linux-gnu\" BASE_OS=Fedora\n+#    make TARGETS=\"arm-linux-gnueabihf ppc64le-linux-gnu\" BASE_OS=Fedora\n","filename":"make\/devkit\/Makefile","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  ifeq ($(filter aarch64 armhfp ppc64le riscv64 s390x x86_64, $(ARCH)), )\n+    $(error Only \"aarch64 armhfp ppc64le riscv64 s390x x86_64\" architectures are supported for Fedora, but \"$(ARCH)\" was requested)\n+  endif\n@@ -73,0 +76,3 @@\n+    ifeq ($(filter 38 39 40 41, $(BASE_OS_VERSION)), )\n+      $(error Only Fedora 38-41 are supported for \"$(ARCH)\", but Fedora $(BASE_OS_VERSION) was requested)\n+    endif\n@@ -75,2 +81,2 @@\n-    LATEST_ARCHIVED_OS_VERSION := 35\n-    ifeq ($(filter x86_64 armhfp, $(ARCH)), )\n+    LATEST_ARCHIVED_OS_VERSION := 36\n+    ifeq ($(filter aarch64 armhfp x86_64, $(ARCH)), )\n@@ -81,0 +87,5 @@\n+    ifeq ($(ARCH), armhfp)\n+      ifneq ($(BASE_OS_VERSION), 36)\n+        $(error Fedora 36 is the last release supporting \"armhfp\", but $(BASE_OS) was requested)\n+      endif\n+    endif\n@@ -467,1 +478,1 @@\n-ifneq ($(filter riscv64 ppc64 ppc64le s390x, $(ARCH)), )\n+ifneq ($(filter riscv64 ppc64le s390x, $(ARCH)), )\n","filename":"make\/devkit\/Tools.gmk","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+\t\t\t\"oracle.oracle-java\",\n@@ -20,0 +21,4 @@\n+\n+\t\t\/\/ Java extension\n+\t\t\"jdk.project.jdkhome\": \"{{OUTPUTDIR}}\/jdk\",\n+\t\t\"jdk.java.onSave.organizeImports\": false, \/\/ prevents unnecessary changes\n","filename":"make\/ide\/vscode\/hotspot\/template-workspace.jsonc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3348,1 +3348,3 @@\n-  __ membar(__ AnyAny);\n+  if(!UseLSE) {\n+    __ membar(__ AnyAny);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,3 +110,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -202,0 +205,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6768,4 +6768,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,5 +231,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(*stub->entry());\n-    } else {\n-      __ unlock_object(R5, R6, R4, *stub->entry());\n-    }\n+    __ unlock_object(R5, R6, R4, *stub->entry());\n@@ -2621,19 +2617,6 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      \/\/ Add debug info for NullPointerException only if one is possible.\n-      if (op->info() != nullptr) {\n-        if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n-          explicit_null_check(obj, op->info());\n-        } else {\n-          add_debug_info_for_null_check_here(op->info());\n-        }\n-      }\n-      __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow locking\n-      \/\/ note: The slow locking code could be inlined here, however if we use\n-      \/\/       slow locking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow locking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      if (op->info() != nullptr) {\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    \/\/ Add debug info for NullPointerException only if one is possible.\n+    if (op->info() != nullptr) {\n+      if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n+        explicit_null_check(obj, op->info());\n+      } else {\n@@ -2641,1 +2624,0 @@\n-        __ null_check(obj);\n@@ -2643,1 +2625,0 @@\n-      __ b(*op->stub()->entry());\n@@ -2645,0 +2626,1 @@\n+    __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n@@ -2647,12 +2629,2 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow unlocking\n-      \/\/ note: The slow unlocking code could be inlined here, however if we use\n-      \/\/       slow unlocking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow unlocking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      __ b(*op->stub()->entry());\n-    }\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":38,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -85,34 +85,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(Rscratch, Roop);\n-      lbz(Rscratch, in_bytes(Klass::misc_flags_offset()), Rscratch);\n-      testbitdi(CR0, R0, Rscratch, exact_log2(KlassFlags::_misc_is_value_based_class));\n-      bne(CR0, slow_int);\n-    }\n-\n-    \/\/ ... and mark it unlocked.\n-    ori(Rmark, Rmark, markWord::unlocked_value);\n-\n-    \/\/ Save unlocked object header into the displaced header location on the stack.\n-    std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-\n-    \/\/ Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"cas must take a zero displacement\");\n-    cmpxchgd(\/*flag=*\/CR0,\n-             \/*current_value=*\/Rscratch,\n-             \/*compare_value=*\/Rmark,\n-             \/*exchange_value=*\/Rbox,\n-             \/*where=*\/Roop\/*+0==mark_offset_in_bytes*\/,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-    \/\/ If compare\/exchange succeeded we found an unlocked object and we now have locked it\n-    \/\/ hence we are done.\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n@@ -124,10 +91,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    bind(cas_failed);\n-    \/\/ We did not find an unlocked object so see if this is a recursive case.\n-    sub(Rscratch, Rscratch, R1_SP);\n-    load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-    and_(R0\/*==0?*\/, Rscratch, R0);\n-    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-    bne(CR0, slow_int);\n-  }\n-\n@@ -135,3 +92,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(Rmark \/*tmp*\/);\n-  }\n@@ -149,7 +103,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if it is a fast recursive unlock.\n-    ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-    cmpdi(CR0, Rmark, 0);\n-    beq(CR0, done);\n-  }\n-\n@@ -160,17 +107,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(Roop, Rmark, slow_int);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ Check if it is still a light weight lock, this is is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object.\n-    cmpxchgd(\/*flag=*\/CR0,\n-             \/*current_value=*\/R0,\n-             \/*compare_value=*\/Rbox,\n-             \/*exchange_value=*\/Rmark,\n-             \/*where=*\/Roop,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &slow_int);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_unlock(Roop, Rmark, slow_int);\n@@ -183,3 +114,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(Rmark \/*tmp*\/);\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":74,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -337,0 +337,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -949,39 +949,2 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-  } else {\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-    \/\/   \/\/ We stored the monitor address into the object's mark word.\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-    \/\/ }\n-\n-    const Register header           = R7_ARG5;\n-    const Register object_mark_addr = R8_ARG6;\n-    const Register current_header   = R9_ARG7;\n-    const Register tmp              = R10_ARG8;\n-\n-    Label count_locking, done, slow_case, cas_failed;\n-\n-    assert_different_registers(header, object_mark_addr, current_header, tmp);\n-\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(monitor, object, header, tmp, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, object);\n-        lbz(tmp, in_bytes(Klass::misc_flags_offset()), tmp);\n-        testbitdi(CR0, R0, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-        bne(CR0, slow_case);\n-      }\n+  const Register header           = R7_ARG5;\n+  const Register tmp              = R8_ARG6;\n@@ -989,56 +952,1 @@\n-      \/\/ Load markWord from object into header.\n-      ld(header, oopDesc::mark_offset_in_bytes(), object);\n-\n-      \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-      ori(header, header, markWord::unlocked_value);\n-\n-      \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-      const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-      const int mark_offset = lock_offset +\n-                              BasicLock::displaced_header_offset_in_bytes();\n-\n-      \/\/ Initialize the box (Must happen before we update the object mark!).\n-      std(header, mark_offset, monitor);\n-\n-      \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-      \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, displaced).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/header, \/*exchange_value=*\/monitor,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-               MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-               noreg,\n-               &cas_failed,\n-               \/*check without membar and ldarx first*\/true);\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object and we have now locked it.\n-      b(count_locking);\n-      bind(cas_failed);\n-\n-      \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-      \/\/   \/\/ Simple recursive case.\n-      \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if owner is self by comparing the value in the markWord of object\n-      \/\/ (current_header) with the stack pointer.\n-      sub(current_header, current_header, R1_SP);\n-\n-      assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-      load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n-\n-      and_(R0\/*==0?*\/, current_header, tmp);\n-      \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-      \/\/ header indicating it is a recursive lock.\n-      bne(CR0, slow_case);\n-      std(R0\/*==0!*\/, mark_offset, monitor);\n-      b(count_locking);\n-    }\n+  Label done, slow_case;\n@@ -1046,18 +954,9 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-\n-    \/\/ None of the above fast optimizations worked so we have to get into the\n-    \/\/ slow case of monitor enter.\n-    bind(slow_case);\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    \/\/ }\n-\n-    if (LockingMode == LM_LEGACY) {\n-      b(done);\n-      align(32, 12);\n-      bind(count_locking);\n-      inc_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  assert_different_registers(header, tmp);\n+\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n+  b(done);\n+\n+  bind(slow_case);\n+  call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+\n+  bind(done);\n@@ -1074,3 +973,3 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-  } else {\n+  const Register object           = R7_ARG5;\n+  const Register header           = R8_ARG6;\n+  const Register current_header   = R10_ARG8;\n@@ -1078,36 +977,2 @@\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n-    \/\/ }\n-\n-    const Register object           = R7_ARG5;\n-    const Register header           = R8_ARG6;\n-    const Register object_mark_addr = R9_ARG7;\n-    const Register current_header   = R10_ARG8;\n-\n-    Label free_slot;\n-    Label slow_case;\n-\n-    assert_different_registers(object, header, object_mark_addr, current_header);\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Test first if we are in the fast recursive case.\n-      ld(header, in_bytes(BasicObjectLock::lock_offset()) +\n-                 BasicLock::displaced_header_offset_in_bytes(), monitor);\n-\n-      \/\/ If the displaced header is zero, we have a recursive unlock.\n-      cmpdi(CR0, header, 0);\n-      beq(CR0, free_slot); \/\/ recursive unlock\n-    }\n-\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n+  Label free_slot;\n+  Label slow_case;\n@@ -1115,1 +980,1 @@\n-    \/\/ If we still have a lightweight lock, unlock the object and be done.\n+  assert_different_registers(object, header, current_header);\n@@ -1117,2 +982,2 @@\n-    \/\/ The object address from the monitor is in object.\n-    ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  \/\/ The object address from the monitor is in object.\n+  ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n@@ -1120,19 +985,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(object, header, slow_case);\n-    } else {\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ We have the displaced header in displaced_header. If the lock is still\n-      \/\/ lightweight, it will contain the monitor address and we'll store the\n-      \/\/ displaced header back into the object's mark word.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, monitor).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel,\n-               MacroAssembler::cmpxchgx_hint_release_lock(),\n-               noreg,\n-               &slow_case);\n-    }\n-    b(free_slot);\n+  lightweight_unlock(object, header, slow_case);\n@@ -1140,3 +987,1 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n+  b(free_slot);\n@@ -1144,5 +989,2 @@\n-    \/\/ The lock has been converted into a heavy lock and hence\n-    \/\/ we need to get into the slow case.\n-    bind(slow_case);\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    \/\/ }\n+  bind(slow_case);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n@@ -1150,2 +992,2 @@\n-    Label done;\n-    b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n+  Label done;\n+  b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n@@ -1153,10 +995,6 @@\n-    \/\/ Exchange worked, do monitor->set_obj(nullptr);\n-    align(32, 12);\n-    bind(free_slot);\n-    li(R0, 0);\n-    std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n-    if (LockingMode == LM_LEGACY) {\n-      dec_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  \/\/ Do monitor->set_obj(nullptr);\n+  align(32, 12);\n+  bind(free_slot);\n+  li(R0, 0);\n+  std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  bind(done);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":32,"deletions":194,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2674,232 +2674,0 @@\n-void MacroAssembler::compiler_fast_lock_object(ConditionRegister flag, Register oop, Register box,\n-                                               Register temp, Register displaced_header, Register current_header) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n-  assert_different_registers(oop, box, temp, displaced_header, current_header);\n-  Label object_has_monitor;\n-  Label cas_failed;\n-  Label success, failure;\n-\n-  \/\/ Load markWord from object into displaced_header.\n-  ld(displaced_header, oopDesc::mark_offset_in_bytes(), oop);\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(temp, oop);\n-    lbz(temp, in_bytes(Klass::misc_flags_offset()), temp);\n-    testbitdi(flag, R0, temp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-    bne(flag, failure);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  andi_(temp, displaced_header, markWord::monitor_value);\n-  bne(CR0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-    ori(displaced_header, displaced_header, markWord::unlocked_value);\n-\n-    \/\/ Load Compare Value application register.\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    std(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-    cmpxchgd(\/*flag=*\/flag,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/displaced_header,\n-             \/*exchange_value=*\/box,\n-             \/*where=*\/oop,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object and we have now locked it.\n-    b(success);\n-\n-    bind(cas_failed);\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    sub(current_header, current_header, R1_SP);\n-    load_const_optimized(temp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n-\n-    and_(R0\/*==0?*\/, current_header, temp);\n-    \/\/ If condition is true we are cont and hence we can store 0 as the\n-    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    if (flag != CR0) {\n-      mcrf(flag, CR0);\n-    }\n-    beq(CR0, success);\n-    b(failure);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  addi(temp, displaced_header, in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value);\n-  Register thread_id = displaced_header;\n-  ld(thread_id, in_bytes(JavaThread::monitor_owner_id_offset()), R16_thread);\n-  cmpxchgd(\/*flag=*\/flag,\n-           \/*current_value=*\/current_header,\n-           \/*compare_value=*\/(intptr_t)0,\n-           \/*exchange_value=*\/thread_id,\n-           \/*where=*\/temp,\n-           MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock());\n-\n-  \/\/ Store a non-null value into the box.\n-  std(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  beq(flag, success);\n-\n-  \/\/ Check for recursive locking.\n-  cmpd(flag, current_header, thread_id);\n-  bne(flag, failure);\n-\n-  \/\/ Current thread already owns the lock. Just increment recursions.\n-  Register recursions = displaced_header;\n-  ld(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n-  addi(recursions, recursions, 1);\n-  std(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n-\n-  \/\/ flag == EQ indicates success, increment held monitor count if LM_LEGACY is enabled\n-  \/\/ flag == NE indicates failure\n-  bind(success);\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(temp);\n-  }\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == EQ.\n-  Label flag_correct;\n-  beq(flag, flag_correct);\n-  stop(\"compiler_fast_lock_object: Flag != EQ\");\n-#endif\n-  bind(failure);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag == NE.\n-  bne(flag, flag_correct);\n-  stop(\"compiler_fast_lock_object: Flag != NE\");\n-  bind(flag_correct);\n-#endif\n-}\n-\n-void MacroAssembler::compiler_fast_unlock_object(ConditionRegister flag, Register oop, Register box,\n-                                                 Register temp, Register displaced_header, Register current_header) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, temp, displaced_header, current_header);\n-  Label success, failure, object_has_monitor, not_recursive;\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ld(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    cmpdi(flag, displaced_header, 0);\n-    beq(flag, success);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  ld(current_header, oopDesc::mark_offset_in_bytes(), oop);\n-  andi_(R0, current_header, markWord::monitor_value);\n-  bne(CR0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object.\n-    \/\/ Cmpxchg sets flag to cmpd(current_header, box).\n-    cmpxchgd(\/*flag=*\/flag,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/box,\n-             \/*exchange_value=*\/displaced_header,\n-             \/*where=*\/oop,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &failure);\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    b(success);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-  addi(current_header, current_header, -(int)markWord::monitor_value); \/\/ monitor\n-\n-  ld(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n-  addic_(displaced_header, displaced_header, -1);\n-  blt(CR0, not_recursive); \/\/ Not recursive if negative after decrement.\n-\n-  \/\/ Recursive unlock\n-  std(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n-  if (flag == CR0) { \/\/ Otherwise, flag is already EQ, here.\n-    crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Set CR0 EQ\n-  }\n-  b(success);\n-\n-  bind(not_recursive);\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  release();\n-  li(temp, 0);\n-  std(temp, in_bytes(ObjectMonitor::owner_offset()), current_header);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  ld(temp, in_bytes(ObjectMonitor::entry_list_offset()), current_header);\n-  cmpdi(flag, temp, 0);\n-  beq(flag, success);  \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  ld(temp, in_bytes(ObjectMonitor::succ_offset()), current_header);\n-  cmpdi(flag, temp, 0);\n-  \/\/ Invert equal bit\n-  crnand(flag, Assembler::equal, flag, Assembler::equal);\n-  beq(flag, success);  \/\/ If there is a successor we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try\n-  \/\/ to reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  std(current_header, in_bytes(JavaThread::unlocked_inflated_monitor_offset()), R16_thread);\n-  b(failure); \/\/ flag == NE\n-\n-  \/\/ flag == EQ indicates success, decrement held monitor count if LM_LEGACY is enabled\n-  \/\/ flag == NE indicates failure\n-  bind(success);\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(temp);\n-  }\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == EQ.\n-  Label flag_correct;\n-  beq(flag, flag_correct);\n-  stop(\"compiler_fast_unlock_object: Flag != EQ\");\n-#endif\n-  bind(failure);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag == NE.\n-  bne(flag, flag_correct);\n-  stop(\"compiler_fast_unlock_object: Flag != NE\");\n-  bind(flag_correct);\n-#endif\n-}\n-\n@@ -4772,32 +4540,0 @@\n-\/\/ Note: Must preserve CR0 EQ (invariant).\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  assert(LockingMode == LM_LEGACY, \"\");\n-  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-#ifdef ASSERT\n-  Label ok;\n-  cmpdi(CR0, tmp, 0);\n-  bge_predict_taken(CR0, ok);\n-  stop(\"held monitor count is negativ at increment\");\n-  bind(ok);\n-  crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Restore CR0 EQ\n-#endif\n-  addi(tmp, tmp, 1);\n-  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-}\n-\n-\/\/ Note: Must preserve CR0 EQ (invariant).\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  assert(LockingMode == LM_LEGACY, \"\");\n-  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-#ifdef ASSERT\n-  Label ok;\n-  cmpdi(CR0, tmp, 0);\n-  bgt_predict_taken(CR0, ok);\n-  stop(\"held monitor count is <= 0 at decrement\");\n-  bind(ok);\n-  crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Restore CR0 EQ\n-#endif\n-  addi(tmp, tmp, -1);\n-  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-}\n-\n@@ -4845,1 +4581,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -4902,1 +4637,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":0,"deletions":266,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -700,2 +700,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n@@ -718,6 +716,0 @@\n-  void compiler_fast_lock_object(ConditionRegister flag, Register oop, Register box,\n-                                 Register tmp1, Register tmp2, Register tmp3);\n-\n-  void compiler_fast_unlock_object(ConditionRegister flag, Register oop, Register box,\n-                                   Register tmp1, Register tmp2, Register tmp3);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -11576,32 +11576,0 @@\n-instruct cmpFastLock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set crx (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-\n-  format %{ \"FASTLOCK  $oop, $box, $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n-    \/\/ If locking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_locking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-instruct cmpFastUnlock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set crx (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-\n-  format %{ \"FASTUNLOCK  $oop, $box, $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n-    \/\/ If unlocking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_unlocking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n@@ -11609,1 +11577,1 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT && !UseObjectMonitorTable);\n+  predicate(!UseObjectMonitorTable);\n@@ -11625,1 +11593,1 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT && UseObjectMonitorTable);\n+  predicate(UseObjectMonitorTable);\n@@ -11641,1 +11609,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2449,8 +2449,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n-      Register r_temp_3_or_noreg = UseObjectMonitorTable ? r_temp_3 : noreg;\n-      __ compiler_fast_lock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n-    } else {\n-      \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n-      __ compiler_fast_lock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    }\n+    \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n+    Register r_temp_3_or_noreg = UseObjectMonitorTable ? r_temp_3 : noreg;\n+    __ compiler_fast_lock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n@@ -2623,1 +2618,1 @@\n-    if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    if (method->is_object_wait0()) {\n@@ -2675,5 +2670,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      __ compiler_fast_unlock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    } else {\n-      __ compiler_fast_unlock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    }\n+    __ compiler_fast_unlock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n@@ -2720,1 +2711,1 @@\n-  bool maybe_preempted = LockingMode != LM_LEGACY && method->is_object_wait0();\n+  bool maybe_preempted = method->is_object_wait0();\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1365,1 +1365,1 @@\n-  bool support_vthread_preemption = Continuations::enabled() && LockingMode != LM_LEGACY;\n+  bool support_vthread_preemption = Continuations::enabled();\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2596,4 +2596,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -197,0 +197,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+        break;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -232,5 +232,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ branch_optimized(Assembler::bcondAlways, *stub->entry());\n-    } else {\n-      __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n-    }\n+    __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n@@ -2717,7 +2713,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ branch_optimized(Assembler::bcondAlways, *op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -72,54 +70,1 @@\n-  assert(LockingMode != LM_MONITOR, \"LM_MONITOR is already handled, by emit_lock()\");\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, Roop);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      branch_optimized(Assembler::bcondAllOne, slow_case);\n-    }\n-\n-    NearLabel done;\n-\n-    \/\/ Load object header.\n-    z_lg(Rmark, Address(Roop, hdr_offset));\n-\n-    \/\/ and mark it as unlocked.\n-    z_oill(Rmark, markWord::unlocked_value);\n-    \/\/ Save unlocked object header into the displaced header location on the stack.\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header. If it is not the same, get the\n-    \/\/ object header instead.\n-    z_csg(Rmark, Rbox, hdr_offset, Roop);\n-    \/\/ If the object header was the same, we're done.\n-    branch_optimized(Assembler::bcondEqual, done);\n-    \/\/ If the object header was not the same, it is now in the Rmark register.\n-    \/\/ => Test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (Rmark & markWord::lock_mask_in_place) == 0\n-    \/\/ 2) rsp <= Rmark\n-    \/\/ 3) Rmark <= rsp + page_size\n-    \/\/\n-    \/\/ These 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (Rmark - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    z_sgr(Rmark, Z_SP);\n-\n-    load_const_optimized(Z_R0_scratch, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Rmark, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n-    \/\/ For recursive locking, the result is zero. => Save it in the displaced header\n-    \/\/ location (null in the displaced Rmark location indicates recursive locking).\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Otherwise we don't care about the result and handle locking via runtime call.\n-    branch_optimized(Assembler::bcondNotZero, slow_case);\n-    \/\/ done\n-    bind(done);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n@@ -129,2 +74,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -133,9 +76,0 @@\n-  NearLabel done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Load displaced header.\n-    z_ltg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ If the loaded Rmark is null we had recursive locking, and we are done.\n-    z_bre(done);\n-  }\n-\n@@ -146,15 +80,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ Test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object. If the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead.\n-    z_csg(Rbox, Rmark, hdr_offset, Roop);\n-    \/\/ If the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call.\n-    branch_optimized(Assembler::bcondNotEqual, slow_case);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n-  \/\/ done\n-  bind(done);\n+  lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1011,22 +1011,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    return;\n-  }\n-\n-  \/\/ template code: (for LM_LEGACY)\n-  \/\/\n-  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-  \/\/   \/\/ We stored the monitor address into the object's mark word.\n-  \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-  \/\/   \/\/ Simple recursive case.\n-  \/\/   monitor->lock()->set_displaced_header(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1034,2 +1012,0 @@\n-  const Register object_mark_addr = Z_ARG4;\n-  const Register current_header   = Z_ARG5;\n@@ -1040,61 +1016,1 @@\n-  \/\/ markWord header = obj->mark().set_unlocked();\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(monitor, object, header, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, object);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      z_btrue(slow_case);\n-    }\n-\n-    \/\/ Load markWord from object into header.\n-    z_lg(header, hdr_offset, object);\n-\n-    \/\/ Set header to be (markWord of object | UNLOCK_VALUE).\n-    \/\/ This will not change anything if it was unlocked before.\n-    z_oill(header, markWord::unlocked_value);\n-\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n-    \/\/ Initialize the box (Must happen before we update the object mark!).\n-    z_stg(header, mark_offset, monitor);\n-\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-    \/\/ not necessary, use offset in instruction directly.\n-    \/\/ add2reg(object_mark_addr, hdr_offset, object);\n-\n-    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-    z_csg(header, monitor, hdr_offset, object);\n-    assert(current_header == header,\n-           \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-\n-    z_bre(done);\n-\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    z_sgr(current_header, Z_SP);\n-\n-    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-\n-    \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n-    \/\/ (Z_R1 is temp and not used after here).\n-    load_const_optimized(Z_R0, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n-\n-    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-    \/\/ header indicating it is a recursive lock and be done.\n-    z_brne(slow_case);\n-    z_release();  \/\/ Member unnecessary on zarch AND because the above csg does a sync before and after.\n-    z_stg(Z_R0\/*==0!*\/, mark_offset, monitor);\n-  }\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n@@ -1102,3 +1018,0 @@\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n@@ -1106,2 +1019,0 @@\n-  \/\/ None of the above fast optimizations worked so we have to get into the\n-  \/\/ slow case of monitor enter.\n@@ -1112,2 +1023,0 @@\n-  \/\/ }\n-\n@@ -1125,22 +1034,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    return;\n-  }\n-\n-\/\/ else {\n-  \/\/ template code: (for LM_LEGACY):\n-  \/\/\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1162,8 +1049,0 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-  const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n@@ -1171,5 +1050,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if we are in the fast recursive case.\n-    MacroAssembler::load_and_test_long(header, Address(monitor, mark_offset));\n-    z_bre(done); \/\/ header == 0 -> goto done\n-  }\n@@ -1177,26 +1051,2 @@\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ If we still have a lightweight lock, unlock the object and be done.\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_unlock(object, header, current_header, slow_case);\n-\n-    z_bru(done);\n-  } else {\n-    \/\/ The markword is expected to be at offset 0.\n-    \/\/ This is not required on s390, at least not here.\n-    assert(hdr_offset == 0, \"unlock_object: review code below\");\n-\n-    \/\/ We have the displaced header in header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    z_lgr(current_header, monitor);\n-    z_csg(current_header, header, hdr_offset, object);\n-    z_bre(done);\n-  }\n-\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n+  lightweight_unlock(object, header, current_header, slow_case);\n+  z_bru(done);\n@@ -1209,3 +1059,0 @@\n-\n-  \/\/ }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":3,"deletions":156,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -3769,205 +3769,0 @@\n-\/\/ \"The box\" is the space on the stack where we copy the object mark.\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp1;\n-  Register temp            = temp2;\n-\n-  NearLabel done, object_has_monitor;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  BLOCK_COMMENT(\"compiler_fast_lock_object {\");\n-\n-  \/\/ Load markWord from oop into mark.\n-  z_lg(displacedHeader, hdr_offset, oop);\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(temp, oop);\n-    z_tm(Address(temp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-    z_brne(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-  z_tmll(displacedHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    \/\/ From loading the markWord, we know that oop != nullptr\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set mark to markWord | markWord::unlocked_value.\n-    z_oill(displacedHeader, markWord::unlocked_value);\n-\n-    \/\/ Load Compare Value application register.\n-\n-    \/\/ Initialize the box (must happen before we update the object mark).\n-    z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n-    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n-    z_csg(displacedHeader, box, hdr_offset, oop);\n-    assert(currentHeader == displacedHeader, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-    z_bre(done);\n-\n-    \/\/ We did not see an unlocked object\n-    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n-    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n-    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n-    z_sgr(currentHeader, Z_SP);\n-    load_const_optimized(temp, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-\n-    z_ngr(currentHeader, temp);\n-\n-    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n-    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n-\n-    z_stg(currentHeader\/*==0 or not 0*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    z_bru(done);\n-  }\n-\n-  bind(object_has_monitor);\n-\n-  Register zero = temp;\n-  Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  \/\/ If csg succeeds then CR=EQ, otherwise, register zero is filled\n-  \/\/ with the current owner.\n-  z_lghi(zero, 0);\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_csg(zero, Z_R0_scratch, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n-\n-  \/\/ Store a non-null value into the box.\n-  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-  z_bre(done); \/\/ acquired the lock for the first time.\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n-  \/\/ Check if we are already the owner (recursive lock)\n-  z_cgr(Z_R0_scratch, zero); \/\/ owner is stored in zero by \"z_csg\" above\n-  z_brne(done); \/\/ not a recursive lock\n-\n-  \/\/ Current thread already owns the lock. Just increment recursion count.\n-  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_lock_object\");\n-  \/\/ If locking was successful, CR should indicate 'EQ'.\n-  \/\/ The compiler or the native wrapper generates a branch to the runtime call\n-  \/\/ _complete_monitor_locking_Java.\n-}\n-\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp2;\n-  Register temp            = temp1;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  Label done, object_has_monitor, not_recursive;\n-\n-  BLOCK_COMMENT(\"compiler_fast_unlock_object {\");\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    \/\/ if the displaced header is zero, we have a recursive unlock.\n-    load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    z_bre(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  z_lg(currentHeader, hdr_offset, oop);\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-\n-  z_tmll(currentHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a lightweight lock, this is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object\n-    \/\/ copy box to currentHeader such that csg does not kill it.\n-    z_lgr(currentHeader, box);\n-    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n-    z_bru(done); \/\/ csg sets CR as desired.\n-  }\n-\n-  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n-  \/\/ This is handled like owner thread mismatches: We take the slow path.\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_cg(Z_R0_scratch, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  z_brne(done);\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n-\n-  \/\/ Recursive inflated unlock\n-  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n-  z_bru(done);\n-\n-  bind(not_recursive);\n-\n-  NearLabel set_eq_unlocked;\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  z_release();\n-  z_lghi(temp, 0);\n-  z_stg(temp, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  z_fence();\n-\n-  \/\/ Check if the entry_list is empty.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(entry_list)));\n-  z_bre(done); \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)));\n-  z_brne(set_eq_unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  z_xilf(currentHeader, markWord::monitor_value);\n-  z_stg(currentHeader, Address(Z_thread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  z_ltgr(oop, oop); \/\/ Set flag = NE\n-  z_bru(done);\n-\n-  bind(set_eq_unlocked);\n-  z_cr(temp, temp); \/\/ Set flag = EQ\n-\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_unlock_object\");\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-}\n-\n@@ -6352,1 +6147,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -6418,1 +6212,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":0,"deletions":207,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -793,2 +793,0 @@\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -10164,22 +10164,0 @@\n-instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(VARIABLE_SIZE); \/\/ Uses load_const_optimized.\n-  format %{ \"FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n@@ -10187,1 +10165,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -10203,1 +10180,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1767,7 +1767,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+    __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n@@ -1968,7 +1963,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+    __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+\/\/   z17:  2025-04\n@@ -72,5 +73,5 @@\n-static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\",         \"G10\" };\n-static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\",       \"3931\" };\n-static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\",        \"z16\" };\n-static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"2024-12-31\", \"tbd\" };\n-static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"2023-12-31\", \"2024-12-31\", \"tbd\",        \"tbd\",        \"tbd\" };\n+static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\",         \"G10\",         \"G11\" };\n+static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\",       \"3931\",        \"9175\" };\n+static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\",        \"z16\",         \"z17\" };\n+static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"2024-12-31\", \"tbd\",         \"tbd\" };\n+static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"2023-12-31\", \"2024-12-31\", \"tbd\",        \"tbd\",        \"tbd\",         \"tbd\" };\n@@ -88,1 +89,3 @@\n-                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh\"\n+                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh\",\n+                                   \"system-z, g11-z17, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, venh2,\"\n+                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh, concurrent_function\"\n@@ -342,0 +345,5 @@\n+  if (is_z17()) {\n+    model_ix = 11;\n+    ambiguity++;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-\/\/ --- FeatureBitString Bits 128..192 (DW[2]) ---\n+\/\/ --- FeatureBitString Bits 128..191 (DW[2]) ---\n@@ -121,1 +121,1 @@\n-\/\/ --- FeatureBitString Bits 193..200 (DW[3]) ---\n+\/\/ --- FeatureBitString Bits 192..255 (DW[3]) ---\n@@ -124,0 +124,1 @@\n+#define  ConcurrentFunFacilityMask      0x0040000000000000UL  \/\/ z17, Concurrent-functions facility, Bit: 201\n@@ -192,1 +193,2 @@\n-  static bool is_z16()  { return has_BEAR_Enh_Facility(); }\n+  static bool is_z16()  { return has_BEAR_Enh_Facility()      && !has_Concurrent_Fun_Facility(); }\n+  static bool is_z17()  { return has_Concurrent_Fun_Facility();}\n@@ -500,0 +502,1 @@\n+  static bool has_Concurrent_Fun_Facility()   { return  (_features[3] & ConcurrentFunFacilityMask)     == ConcurrentFunFacilityMask; }\n@@ -576,0 +579,1 @@\n+  static void set_has_Concurrent_Fun_Facility()   { _features[3] |= ConcurrentFunFacilityMask;}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,3 +107,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -193,0 +196,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6766,26 +6766,40 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n-   \/\/byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = StringUTF16.getChar(sa, sp++);\n-   \/\/    if (c > '\\u00FF')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n-   \/\/\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n-   \/\/    byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = sa[sp++];\n-   \/\/    if (c >= '\\u0080')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n+\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/     int i = 0;\n+\/\/     for (; i < len; i++) {\n+\/\/         char c = sa[sp++];\n+\/\/         if (c > '\\u00FF')\n+\/\/             break;\n+\/\/         da[dp++] = (byte) c;\n+\/\/     }\n+\/\/     return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeISOArray0(\n+\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = StringUTF16.getChar(sa, sp++);\n+\/\/     if (c > '\\u00FF')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = sa[sp++];\n+\/\/     if (c >= '\\u0080')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":40,"deletions":26,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  \/\/ VM expects i2c entry to be always filled. The rest can be unset.\n+  \/\/ foil any attempt to call the i2c, c2i or unverified c2i entries\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  do_arch_blob(initial, 32)                                             \\\n+  do_arch_blob(initial, 0)                                              \\\n@@ -61,1 +61,1 @@\n-  do_arch_blob(final, 32)                                               \\\n+  do_arch_blob(final, 0)                                                \\\n","filename":"src\/hotspot\/cpu\/zero\/stubDeclarations_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -667,2 +667,11 @@\n-    if (is_dumping_preimage_static_archive() || is_dumping_final_static_archive()) {\n-      \/\/ Don't tweak execution mode\n+    if (is_dumping_preimage_static_archive()) {\n+      \/\/ Don't tweak execution mode during AOT training run\n+    } else if (is_dumping_final_static_archive()) {\n+      if (Arguments::mode() == Arguments::_comp) {\n+        \/\/ AOT assembly phase submits the non-blocking compilation requests\n+        \/\/ for methods collected during training run, then waits for all compilations\n+        \/\/ to complete. With -Xcomp, we block for each compilation request, which is\n+        \/\/ counter-productive. Switching back to mixed mode improves testing time\n+        \/\/ with AOT and -Xcomp.\n+        Arguments::set_mode_flags(Arguments::_mixed);\n+      }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1917,2 +1917,3 @@\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n+         JavaThread::current()->thread_state() == _thread_in_vm ||\n+         JavaThread::current() == java_lang_Thread::thread(java_thread),\n+         \"unsafe call to java_lang_Thread::get_thread_status()?\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n@@ -431,1 +431,1 @@\n-   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n+   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n@@ -437,1 +437,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-void CompilationPolicy::print_counters(const char* prefix, Method* m) {\n+void CompilationPolicy::print_counters_on(outputStream* st, const char* prefix, Method* m) {\n@@ -419,6 +419,5 @@\n-  tty->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n-      invocation_count, backedge_count, prefix,\n-      mdo_invocations, mdo_invocations_start,\n-      mdo_backedges, mdo_backedges_start);\n-  tty->print(\" %smax levels=%d,%d\", prefix,\n-      m->highest_comp_level(), m->highest_osr_comp_level());\n+  st->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n+    invocation_count, backedge_count, prefix,\n+    mdo_invocations, mdo_invocations_start,\n+    mdo_backedges, mdo_backedges_start);\n+  st->print(\" %smax levels=%d,%d\", prefix, m->highest_comp_level(), m->highest_osr_comp_level());\n@@ -427,1 +426,1 @@\n-void CompilationPolicy::print_training_data(const char* prefix, Method* method) {\n+void CompilationPolicy::print_training_data_on(outputStream* st,  const char* prefix, Method* method) {\n@@ -429,1 +428,1 @@\n-  tty->print(\" %smtd: \", prefix);\n+  st->print(\" %smtd: \", prefix);\n@@ -432,1 +431,1 @@\n-    tty->print(\"null\");\n+    st->print(\"null\");\n@@ -435,1 +434,1 @@\n-    tty->print(\"mdo=\");\n+    st->print(\"mdo=\");\n@@ -437,1 +436,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -443,1 +442,1 @@\n-      tty->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n+      st->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n@@ -446,1 +445,1 @@\n-    tty->print(\", deps=\");\n+    st->print(\", deps=\");\n@@ -448,1 +447,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -450,1 +449,1 @@\n-      tty->print(\"%d\", ctd->init_deps_left());\n+      st->print(\"%d\", ctd->init_deps_left());\n@@ -456,1 +455,1 @@\n-void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+void CompilationPolicy::print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level) {\n@@ -459,2 +458,1 @@\n-  ttyLocker tty_lock;\n-  tty->print(\"%lf: [\", os::elapsedTime());\n+  st->print(\"%lf: [\", os::elapsedTime());\n@@ -464,1 +462,1 @@\n-    tty->print(\"call\");\n+    st->print(\"call\");\n@@ -467,1 +465,1 @@\n-    tty->print(\"loop\");\n+    st->print(\"loop\");\n@@ -470,1 +468,1 @@\n-    tty->print(\"compile\");\n+    st->print(\"compile\");\n@@ -473,1 +471,1 @@\n-    tty->print(\"force-compile\");\n+    st->print(\"force-compile\");\n@@ -476,1 +474,1 @@\n-    tty->print(\"remove-from-queue\");\n+    st->print(\"remove-from-queue\");\n@@ -479,1 +477,1 @@\n-    tty->print(\"update-in-queue\");\n+    st->print(\"update-in-queue\");\n@@ -482,1 +480,1 @@\n-    tty->print(\"reprofile\");\n+    st->print(\"reprofile\");\n@@ -485,1 +483,1 @@\n-    tty->print(\"make-not-entrant\");\n+    st->print(\"make-not-entrant\");\n@@ -488,1 +486,1 @@\n-    tty->print(\"unknown\");\n+    st->print(\"unknown\");\n@@ -491,1 +489,1 @@\n-  tty->print(\" level=%d \", level);\n+  st->print(\" level=%d \", level);\n@@ -495,1 +493,1 @@\n-  tty->print(\"[%s\", method_name);\n+  st->print(\"[%s\", method_name);\n@@ -498,1 +496,1 @@\n-    tty->print(\" [%s]] \", inlinee_name);\n+    st->print(\" [%s]] \", inlinee_name);\n@@ -500,3 +498,3 @@\n-  else tty->print(\"] \");\n-  tty->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n-                                      CompileBroker::queue_size(CompLevel_full_optimization));\n+  else st->print(\"] \");\n+  st->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n+                                     CompileBroker::queue_size(CompLevel_full_optimization));\n@@ -504,3 +502,3 @@\n-  tty->print(\" rate=\");\n-  if (m->prev_time() == 0) tty->print(\"n\/a\");\n-  else tty->print(\"%f\", m->rate());\n+  st->print(\" rate=\");\n+  if (m->prev_time() == 0) st->print(\"n\/a\");\n+  else st->print(\"%f\", m->rate());\n@@ -508,2 +506,2 @@\n-  tty->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n-                               threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n+  st->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n+                              threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n@@ -512,1 +510,1 @@\n-    print_counters(\"\", m);\n+    print_counters_on(st, \"\", m);\n@@ -514,1 +512,1 @@\n-      print_counters(\"inlinee \", im);\n+      print_counters_on(st, \"inlinee \", im);\n@@ -516,1 +514,1 @@\n-    tty->print(\" compilable=\");\n+    st->print(\" compilable=\");\n@@ -519,1 +517,1 @@\n-      tty->print(\"c1\");\n+      st->print(\"c1\");\n@@ -523,2 +521,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c1-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c1-osr\");\n@@ -528,2 +526,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2\");\n@@ -533,2 +531,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2-osr\");\n@@ -536,1 +534,1 @@\n-    tty->print(\" status=\");\n+    st->print(\" status=\");\n@@ -538,3 +536,4 @@\n-      tty->print(\"in-queue\");\n-    } else tty->print(\"idle\");\n-    print_training_data(\"\", m);\n+      st->print(\"in-queue\");\n+    } else st->print(\"idle\");\n+\n+    print_training_data_on(st, \"\", m);\n@@ -542,1 +541,1 @@\n-      print_training_data(\"inlinee \", im);\n+      print_training_data_on(st, \"inlinee \", im);\n@@ -545,1 +544,9 @@\n-  tty->print_cr(\"]\");\n+  st->print_cr(\"]\");\n+\n+}\n+\n+void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+  stringStream s;\n+  print_event_on(&s, type, m, im, bci, level);\n+  ResourceMark rm;\n+  tty->print(\"%s\", s.as_string());\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":62,"deletions":55,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -290,2 +290,2 @@\n-  static void print_counters(const char* prefix, Method* m);\n-  static void print_training_data(const char* prefix, Method* method);\n+  static void print_counters_on(outputStream* st, const char* prefix, Method* m);\n+  static void print_training_data_on(outputStream* st, const char* prefix, Method* method);\n@@ -321,0 +321,1 @@\n+  static void print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1490,0 +1490,2 @@\n+  start_new_collection_set();\n+\n@@ -2796,2 +2798,0 @@\n-\n-  young_regions_cset_group()->clear();\n@@ -3162,1 +3162,1 @@\n-  collection_set()->prepare_groups_for_scan();\n+  collection_set()->prepare_for_scan();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,9 @@\n+uint G1CollectionSet::groups_cur_length() const {\n+  assert(_inc_build_state == CSetBuildType::Inactive, \"must be\");\n+  return _groups.length();\n+}\n+\n+uint G1CollectionSet::groups_increment_length() const {\n+  return groups_cur_length() - _groups_inc_part_start;\n+}\n+\n@@ -53,6 +62,4 @@\n-  _collection_set_regions(nullptr),\n-  _collection_set_cur_length(0),\n-  _collection_set_max_length(0),\n-  _collection_set_groups(),\n-  _selected_groups_cur_length(0),\n-  _selected_groups_inc_part_start(0),\n+  _regions(nullptr),\n+  _regions_max_length(0),\n+  _regions_cur_length(0),\n+  _groups(),\n@@ -63,2 +70,3 @@\n-  _inc_build_state(Inactive),\n-  _inc_part_start(0) {\n+  _inc_build_state(CSetBuildType::Inactive),\n+  _regions_inc_part_start(0),\n+  _groups_inc_part_start(0) {\n@@ -68,1 +76,1 @@\n-  FREE_C_HEAP_ARRAY(uint, _collection_set_regions);\n+  FREE_C_HEAP_ARRAY(uint, _regions);\n@@ -79,2 +87,2 @@\n-  assert((size_t)young_region_length() == _collection_set_cur_length,\n-         \"Young region length %u should match collection set length %u\", young_region_length(), _collection_set_cur_length);\n+  assert((size_t)young_region_length() == _regions_cur_length,\n+         \"Young region length %u should match collection set length %u\", young_region_length(), _regions_cur_length);\n@@ -88,3 +96,3 @@\n-  guarantee(_collection_set_regions == nullptr, \"Must only initialize once.\");\n-  _collection_set_max_length = max_region_length;\n-  _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);\n+  guarantee(_regions == nullptr, \"Must only initialize once.\");\n+  _regions_max_length = max_region_length;\n+  _regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);\n@@ -100,2 +108,2 @@\n-void G1CollectionSet::prepare_groups_for_scan () {\n-  collection_set_groups()->prepare_for_scan();\n+void G1CollectionSet::prepare_for_scan () {\n+  groups()->prepare_for_scan();\n@@ -107,1 +115,1 @@\n-  assert(_inc_build_state == Active,\n+  assert(_inc_build_state == CSetBuildType::Active,\n@@ -116,2 +124,2 @@\n-  assert(_collection_set_cur_length < _collection_set_max_length, \"Collection set now larger than maximum size.\");\n-  _collection_set_regions[_collection_set_cur_length++] = hr->hrm_index();\n+  assert(_regions_cur_length < _regions_max_length, \"Collection set now larger than maximum size.\");\n+  _regions[_regions_cur_length++] = hr->hrm_index();\n@@ -124,2 +132,3 @@\n-  assert(_collection_set_cur_length == 0, \"Collection set must be empty before starting a new collection set.\");\n-  assert(_inc_build_state == Inactive, \"Precondition\");\n+  assert(_regions_cur_length == 0, \"Collection set must be empty before starting a new collection set.\");\n+  assert(groups_cur_length() == 0, \"Collection set groups must be empty before starting a new collection set.\");\n+  assert(_optional_groups.length() == 0, \"Collection set optional gorups must be empty before starting a new collection set.\");\n@@ -127,1 +136,1 @@\n-  update_incremental_marker();\n+  continue_incremental_building();\n@@ -130,3 +139,11 @@\n-void G1CollectionSet::finalize_incremental_building() {\n-  assert(_inc_build_state == Active, \"Precondition\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n+void G1CollectionSet::continue_incremental_building() {\n+  assert(_inc_build_state == CSetBuildType::Inactive, \"Precondition\");\n+\n+  _regions_inc_part_start = _regions_cur_length;\n+  _groups_inc_part_start = groups_cur_length();\n+\n+  _inc_build_state = CSetBuildType::Active;\n+}\n+\n+void G1CollectionSet::stop_incremental_building() {\n+  _inc_build_state = CSetBuildType::Inactive;\n@@ -137,2 +154,2 @@\n-  _collection_set_cur_length = 0;\n-  _collection_set_groups.clear();\n+  _regions_cur_length = 0;\n+  _groups.clear();\n@@ -142,1 +159,1 @@\n-  size_t len = _collection_set_cur_length;\n+  size_t len = _regions_cur_length;\n@@ -146,1 +163,1 @@\n-    G1HeapRegion* r = _g1h->region_at(_collection_set_regions[i]);\n+    G1HeapRegion* r = _g1h->region_at(_regions[i]);\n@@ -173,1 +190,1 @@\n-  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id);\n+  iterate_part_from(cl, hr_claimer, _regions_inc_part_start, regions_cur_length(), worker_id);\n@@ -183,1 +200,1 @@\n-                                  &_collection_set_regions[offset],\n+                                  &_regions[offset],\n@@ -190,1 +207,1 @@\n-  assert(_inc_build_state == Active, \"Precondition\");\n+  assert(_inc_build_state == CSetBuildType::Active, \"Precondition\");\n@@ -196,3 +213,3 @@\n-  assert(_collection_set_cur_length < (UINT_MAX - 1),\n-         \"Collection set is too large with %u entries\", _collection_set_cur_length);\n-  hr->set_young_index_in_cset(_collection_set_cur_length + 1);\n+  assert(_regions_cur_length < (UINT_MAX - 1),\n+         \"Collection set is too large with %u entries\", _regions_cur_length);\n+  hr->set_young_index_in_cset(_regions_cur_length + 1);\n@@ -200,2 +217,2 @@\n-  assert(_collection_set_cur_length < _collection_set_max_length, \"Collection set larger than maximum allowed.\");\n-  _collection_set_regions[_collection_set_cur_length] = hr->hrm_index();\n+  assert(_regions_cur_length < _regions_max_length, \"Collection set larger than maximum allowed.\");\n+  _regions[_regions_cur_length] = hr->hrm_index();\n@@ -205,1 +222,1 @@\n-  _collection_set_cur_length++;\n+  _regions_cur_length++;\n@@ -287,1 +304,2 @@\n-  Ticks start_time = Ticks::now();\n+  assert(_inc_build_state == CSetBuildType::Active, \"Precondition\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n@@ -289,1 +307,1 @@\n-  finalize_incremental_building();\n+  Ticks start_time = Ticks::now();\n@@ -346,3 +364,0 @@\n-  _selected_groups_cur_length = 0;\n-  _selected_groups_inc_part_start = 0;\n-\n@@ -366,3 +381,0 @@\n-  _selected_groups_cur_length = collection_set_groups()->length();\n-  stop_incremental_building();\n-\n@@ -371,2 +383,0 @@\n-\n-  QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx);\n@@ -619,1 +629,2 @@\n-  log_debug(gc, ergo, cset) (\"Completed with groups, selected %u\", num_regions_selected);\n+  log_debug(gc, ergo, cset)(\"Completed with groups, selected %u region in %u groups\",\n+                            num_regions_selected, num_groups_selected);\n@@ -628,1 +639,1 @@\n-uint G1CollectionSet::select_optional_collection_set_regions(double time_remaining_ms) {\n+uint G1CollectionSet::select_optional_groups(double time_remaining_ms) {\n@@ -663,1 +674,1 @@\n-  _collection_set_groups.append(gr);\n+  _groups.append(gr);\n@@ -673,0 +684,3 @@\n+  assert(_regions_inc_part_start == 0, \"must be\");\n+  assert(_groups_inc_part_start == 0, \"must be\");\n+\n@@ -675,0 +689,3 @@\n+\n+  stop_incremental_building();\n+  QuickSort::sort(_regions, _regions_cur_length, compare_region_idx);\n@@ -678,1 +695,1 @@\n-  update_incremental_marker();\n+  continue_incremental_building();\n@@ -680,1 +697,1 @@\n-  uint num_regions_selected = select_optional_collection_set_regions(remaining_pause_time);\n+  uint num_regions_selected = select_optional_groups(remaining_pause_time);\n@@ -682,1 +699,0 @@\n-  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -744,1 +760,1 @@\n-  G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);\n+  G1VerifyYoungCSetIndicesClosure cl(_regions_cur_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":71,"deletions":55,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-\/\/ The set of regions that are evacuated during an evacuation pause.\n+\/\/ The set of regions and candidate groups that were evacuated during an\n+\/\/ evacuation pause.\n@@ -46,2 +47,2 @@\n-\/\/ At the end of a collection, before freeing the collection set, this set\n-\/\/ contains all regions that were evacuated during this collection:\n+\/\/ At the end of a collection, before freeing it, this set contains all regions\n+\/\/ and collection set groups that were evacuated during this collection:\n@@ -53,4 +54,3 @@\n-\/\/ This set is built incrementally at mutator time as regions are retired, and\n-\/\/ if this had been a mixed gc, some additional (during gc) incrementally added\n-\/\/ old regions from the collection set candidates built during the concurrent\n-\/\/ cycle.\n+\/\/ This set is initially built at mutator time as regions are retired. If the\n+\/\/ collection is a mixed gc, it contains some additional (during the pause)\n+\/\/ incrementally added old regions from the collection set candidates.\n@@ -132,0 +132,1 @@\n+\/\/ Candidate groups are kept in sync with the contents of the collection set regions.\n@@ -140,2 +141,3 @@\n-  \/\/ All entries in _collection_set_regions below _collection_set_cur_length are\n-  \/\/ assumed to be part of the collection set.\n+  \/\/\n+  \/\/ All regions in _regions below _regions_cur_length are assumed to be part of the\n+  \/\/ collection set.\n@@ -143,5 +145,8 @@\n-  \/\/ concurrent readers. This means we are good with using storestore and loadload\n-  \/\/ barriers on the writer and reader respectively only.\n-  uint* _collection_set_regions;\n-  volatile uint _collection_set_cur_length;\n-  uint _collection_set_max_length;\n+  \/\/ concurrent readers. This means synchronization using storestore and loadload\n+  \/\/ barriers on the writer and reader respectively only are sufficient.\n+  \/\/\n+  \/\/ This corresponds to the regions referenced by the candidate groups further below.\n+  uint* _regions;\n+  uint _regions_max_length;\n+\n+  volatile uint _regions_cur_length;\n@@ -150,1 +155,1 @@\n-  G1CSetCandidateGroupList _collection_set_groups;\n+  G1CSetCandidateGroupList _groups;\n@@ -152,4 +157,1 @@\n-  \/\/ Groups are added to the collection set in increments when performing optional evacuations.\n-  \/\/ We use the value below to track these increments.\n-  uint _selected_groups_cur_length;\n-  uint _selected_groups_inc_part_start;\n+  uint groups_cur_length() const;\n@@ -162,1 +164,2 @@\n-  \/\/ will be collected only if there is enough time. We call these optional (old) regions.\n+  \/\/ will be collected only if there is enough time. We call these optional (old)\n+  \/\/ groups. Regions are reachable via this list as well.\n@@ -165,1 +168,1 @@\n-  enum CSetBuildType {\n+  enum class CSetBuildType {\n@@ -171,1 +174,4 @@\n-  size_t _inc_part_start;\n+  \/\/ Index into the _regions indicating the start of the current collection set increment.\n+  size_t _regions_inc_part_start;\n+  \/\/ Index into the _groups indicating the start of the current collection set increment.\n+  uint _groups_inc_part_start;\n@@ -178,1 +184,0 @@\n-  \/\/ Update the incremental collection set information when adding a region.\n@@ -181,1 +186,1 @@\n-  \/\/ Add the given old region to the head of the current collection set.\n+  \/\/ Add the given old region to the current collection set.\n@@ -194,4 +199,4 @@\n-  \/\/ Select regions for evacuation from the optional candidates given the remaining time\n-  \/\/ and return the number  of actually selected regions.\n-  uint select_optional_collection_set_regions(double time_remaining_ms);\n-  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected);\n+  \/\/ Select groups for evacuation from the optional candidates given the remaining time\n+  \/\/ and return the number of actually selected regions.\n+  uint select_optional_groups(double time_remaining_ms);\n+  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_groups_selected);\n@@ -201,1 +206,1 @@\n-  \/\/ will take.\n+  \/\/ will take. Returns the time remaining from the given target pause time.\n@@ -203,3 +208,0 @@\n-  \/\/ Perform any final calculations on the incremental collection set fields before we\n-  \/\/ can use them.\n-  void finalize_incremental_building();\n@@ -226,0 +228,1 @@\n+  \/\/ Drop all collection set candidates (only the candidates).\n@@ -231,2 +234,2 @@\n-  G1CSetCandidateGroupList* collection_set_groups() { return &_collection_set_groups; }\n-  const G1CSetCandidateGroupList* collection_set_groups() const { return &_collection_set_groups; }\n+  G1CSetCandidateGroupList* groups() { return &_groups; }\n+  const G1CSetCandidateGroupList* groups() const { return &_groups; }\n@@ -234,1 +237,1 @@\n-  void prepare_groups_for_scan();\n+  void prepare_for_scan();\n@@ -239,2 +242,3 @@\n-  uint region_length() const       { return young_region_length() +\n-                                            initial_old_region_length(); }\n+  \/\/ Total length of the initial collection set in regions.\n+  uint initial_region_length() const { return young_region_length() +\n+                                              initial_old_region_length(); }\n@@ -244,1 +248,1 @@\n-  uint eden_region_length() const     { return _eden_region_length; }\n+  uint eden_region_length() const { return _eden_region_length; }\n@@ -246,1 +250,1 @@\n-  uint initial_old_region_length() const      { return _initial_old_region_length; }\n+  uint initial_old_region_length() const { return _initial_old_region_length; }\n@@ -261,6 +265,2 @@\n-  \/\/ Start a new collection set increment.\n-  void update_incremental_marker() {\n-    _inc_build_state = Active;\n-    _inc_part_start = _collection_set_cur_length;\n-    _selected_groups_inc_part_start = _selected_groups_cur_length;\n-  }\n+  \/\/ Start a new collection set increment, continuing the incremental building.\n+  void continue_incremental_building();\n@@ -268,1 +268,1 @@\n-  void stop_incremental_building() { _inc_build_state = Inactive; }\n+  void stop_incremental_building();\n@@ -275,1 +275,1 @@\n-  size_t increment_length() const { return _collection_set_cur_length - _inc_part_start; }\n+  size_t regions_cur_length() const { return _regions_cur_length - _regions_inc_part_start; }\n@@ -277,1 +277,1 @@\n-  size_t cur_length() const { return _collection_set_cur_length; }\n+  size_t cur_length() const { return _regions_cur_length; }\n@@ -279,1 +279,1 @@\n-  uint collection_groups_increment_length() const { return _selected_groups_cur_length - _selected_groups_inc_part_start; }\n+  uint groups_increment_length() const;\n@@ -282,1 +282,1 @@\n-  \/\/ the given G1HeapRegionClosure on all of them.\n+  \/\/ the given G1HeapRegionClosure on all of the regions.\n@@ -290,1 +290,1 @@\n-  \/\/ Finalize the initial collection set consisting of all young regions potentially a\n+  \/\/ Finalize the initial collection set consisting of all young regions and potentially a\n@@ -294,0 +294,1 @@\n+  \/\/ Returns whether there still were some optional regions.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":52,"deletions":51,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-  uint length = collection_groups_increment_length();\n-  uint offset =  _selected_groups_inc_part_start;\n+  uint length = groups_increment_length();\n+  uint offset =  _groups_inc_part_start;\n@@ -44,1 +44,1 @@\n-    G1HeapRegionRemSet::iterate_for_merge(collection_set_groups()->at(offset + cur_pos)->card_set(), cl);\n+    G1HeapRegionRemSet::iterate_for_merge(groups()->at(offset + cur_pos)->card_set(), cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,6 +47,1 @@\n-  add(c);\n-}\n-\n-void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n-  G1HeapRegion* hr = hr_info._r;\n-  _candidates.append(hr_info);\n+  _candidates.append(c);\n@@ -66,1 +61,1 @@\n-size_t G1CSetCandidateGroup::liveness() const {\n+double G1CSetCandidateGroup::liveness_percent() const {\n@@ -68,2 +63,1 @@\n-\n-  return (size_t) ceil(((capacity - _reclaimable_bytes) * 100.0) \/ capacity);\n+  return ((capacity - _reclaimable_bytes) * 100.0) \/ capacity;\n@@ -137,25 +131,0 @@\n-int G1CollectionSetCandidateInfo::compare_region_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n-  \/\/ Make sure that null entries are moved to the end.\n-  if (ci1->_r == nullptr) {\n-    if (ci2->_r == nullptr) {\n-      return 0;\n-    } else {\n-      return 1;\n-    }\n-  } else if (ci2->_r == nullptr) {\n-    return -1;\n-  }\n-\n-  G1Policy* p = G1CollectedHeap::heap()->policy();\n-  double gc_efficiency1 = p->predict_gc_efficiency(ci1->_r);\n-  double gc_efficiency2 = p->predict_gc_efficiency(ci2->_r);\n-\n-  if (gc_efficiency1 > gc_efficiency2) {\n-    return -1;\n-  } else if (gc_efficiency1 < gc_efficiency2) {\n-    return 1;\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -283,3 +252,3 @@\n-void G1CollectionSetCandidates::set_candidates_from_marking(G1CollectionSetCandidateInfo* candidate_infos,\n-                                                            uint num_infos) {\n-  if (num_infos == 0) {\n+void G1CollectionSetCandidates::set_candidates_from_marking(G1HeapRegion** candidates,\n+                                                            uint num_candidates) {\n+  if (num_candidates == 0) {\n@@ -298,1 +267,1 @@\n-  uint group_limit = p->calc_min_old_cset_length(num_infos);\n+  uint group_limit = p->calc_min_old_cset_length(num_candidates);\n@@ -307,2 +276,2 @@\n-  for (uint i = 0; i < num_infos; i++) {\n-    G1HeapRegion* r = candidate_infos[i]._r;\n+  for (uint i = 0; i < num_candidates; i++) {\n+    G1HeapRegion* r = candidates[i];\n@@ -322,1 +291,1 @@\n-    current->add(candidate_infos[i]);\n+    current->add(r);\n@@ -328,1 +297,1 @@\n-  assert(_from_marking_groups.num_regions() == num_infos, \"Must be!\");\n+  assert(_from_marking_groups.num_regions() == num_candidates, \"Must be!\");\n@@ -330,2 +299,2 @@\n-  log_debug(gc, ergo, cset) (\"Finished creating %u collection groups from %u regions\", _from_marking_groups.length(), num_infos);\n-  _last_marking_candidates_length = num_infos;\n+  log_debug(gc, ergo, cset) (\"Finished creating %u collection groups from %u regions\", _from_marking_groups.length(), num_candidates);\n+  _last_marking_candidates_length = num_candidates;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":13,"deletions":44,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-\n-  static int compare_region_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n@@ -94,1 +92,0 @@\n-  void add(G1CollectionSetCandidateInfo& hr_info);\n@@ -105,1 +102,1 @@\n-  size_t liveness() const;\n+  double liveness_percent() const;\n@@ -238,1 +235,1 @@\n-  \/\/ Merge collection set candidates from marking into the current marking list\n+  \/\/ Merge collection set candidates from marking into the current marking candidates\n@@ -240,2 +237,2 @@\n-  void set_candidates_from_marking(G1CollectionSetCandidateInfo* candidate_infos,\n-                                   uint num_infos);\n+  void set_candidates_from_marking(G1HeapRegion** candidates,\n+                                   uint num_candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,2 +34,3 @@\n-\/\/ whether they should be a collection set candidate, calculate their efficiency,\n-\/\/ sort and put them into the candidates.\n+\/\/ whether they should be a collection set candidate. Calculate their efficiency,\n+\/\/ sort, and put them into the collection set candidates.\n+\/\/\n@@ -40,3 +41,0 @@\n-\n-  using CandidateInfo = G1CollectionSetCandidateInfo;\n-\n@@ -50,1 +48,0 @@\n-\n@@ -54,1 +51,1 @@\n-    CandidateInfo* _data;\n+    G1HeapRegion** _data;\n@@ -58,0 +55,27 @@\n+    static int compare_region_gc_efficiency(G1HeapRegion** rr1, G1HeapRegion** rr2) {\n+      G1HeapRegion* r1 = *rr1;\n+      G1HeapRegion* r2 = *rr2;\n+      \/\/ Make sure that null entries are moved to the end.\n+      if (r1 == nullptr) {\n+        if (r2 == nullptr) {\n+          return 0;\n+        } else {\n+          return 1;\n+        }\n+      } else if (r2 == nullptr) {\n+        return -1;\n+      }\n+\n+      G1Policy* p = G1CollectedHeap::heap()->policy();\n+      double gc_efficiency1 = p->predict_gc_efficiency(r1);\n+      double gc_efficiency2 = p->predict_gc_efficiency(r2);\n+\n+      if (gc_efficiency1 > gc_efficiency2) {\n+        return -1;\n+      } else if (gc_efficiency1 < gc_efficiency2) {\n+        return 1;\n+      } else {\n+        return 0;\n+      }\n+    }\n+\n@@ -71,1 +95,1 @@\n-      _data(NEW_C_HEAP_ARRAY(CandidateInfo, _max_size, mtGC)),\n+      _data(NEW_C_HEAP_ARRAY(G1HeapRegion*, _max_size, mtGC)),\n@@ -74,1 +98,1 @@\n-        _data[i] = CandidateInfo();\n+        _data[i] = nullptr;\n@@ -79,1 +103,1 @@\n-      FREE_C_HEAP_ARRAY(CandidateInfo, _data);\n+      FREE_C_HEAP_ARRAY(G1HeapRegion*, _data);\n@@ -95,2 +119,2 @@\n-      assert(_data[idx]._r == nullptr, \"Value must not have been set.\");\n-      _data[idx] = CandidateInfo(hr);\n+      assert(_data[idx] == nullptr, \"Value must not have been set.\");\n+      _data[idx] = hr;\n@@ -104,1 +128,1 @@\n-        assert(_data[i]._r == nullptr, \"must be\");\n+        assert(_data[i] == nullptr, \"must be\");\n@@ -106,1 +130,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionSetCandidateInfo::compare_region_gc_efficiency);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)compare_region_gc_efficiency);\n@@ -108,1 +132,1 @@\n-        assert(_data[i]._r == nullptr, \"must be\");\n+        assert(_data[i] == nullptr, \"must be\");\n@@ -112,1 +136,1 @@\n-    CandidateInfo* array() const { return _data; }\n+    G1HeapRegion** array() const { return _data; }\n@@ -196,1 +220,1 @@\n-  void prune(CandidateInfo* data) {\n+  void prune(G1HeapRegion** data) {\n@@ -214,1 +238,1 @@\n-      G1HeapRegion* r = data[num_candidates - num_pruned - 1]._r;\n+      G1HeapRegion* r = data[num_candidates - num_pruned - 1];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":42,"deletions":18,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-public:\n@@ -46,0 +45,1 @@\n+public:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1965,1 +1965,2 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n+  assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),\n+         \"should be at a safepoint or initializing\");\n@@ -2984,0 +2985,1 @@\n+#define G1PPRL_GID_LIVENESS_FORMAT    \"  %9.2f\"\n@@ -3117,1 +3119,1 @@\n-                          G1PPRL_BYTE_FORMAT\n+                          G1PPRL_GID_LIVENESS_FORMAT\n@@ -3123,1 +3125,1 @@\n-                          group->liveness(),\n+                          group->liveness_percent(),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -249,0 +249,5 @@\n+  \/\/ We clear remembered sets for young regions this late in the full GC because\n+  \/\/ G1HeapVerifier expects the remembered sets for all young regions to be complete\n+  \/\/ throughout most of the collection process (e.g. G1FullCollector::verify_after_marking).\n+  _heap->young_regions_cset_group()->clear();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-  _young_index_in_cset(-1),\n+  _young_index_in_cset(InvalidCSetIndex),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-  uint  young_index_in_cset() const { return _young_index_in_cset; }\n+  uint young_index_in_cset() const { return _young_index_in_cset; }\n@@ -502,1 +502,1 @@\n-    assert(index != UINT_MAX, \"just checking\");\n+    assert(index != InvalidCSetIndex, \"just checking\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,4 +100,0 @@\n-\n-  \/\/ We immediately start allocating regions placing them in the collection set.\n-  \/\/ Initialize the collection set info.\n-  _collection_set->start_incremental_building();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1429,1 +1429,1 @@\n-  size_t const increment_length = g1h->collection_set()->increment_length();\n+  size_t const increment_length = g1h->collection_set()->regions_cur_length();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,4 +271,1 @@\n-  void do_cset_groups() {\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    G1CSetCandidateGroup* young_only_cset_group = g1h->young_regions_cset_group();\n-\n+  void accumulate_stats_for_group(G1CSetCandidateGroup* group, G1PerRegionTypeRemSetCounters* gen_counter) {\n@@ -276,12 +273,14 @@\n-    \/\/ during region iteration.\n-    if (young_only_cset_group->length() > 1) {\n-      G1CardSet* young_only_card_set = young_only_cset_group->card_set();\n-      size_t rs_mem_sz = young_only_card_set->mem_size();\n-      size_t rs_unused_mem_sz = young_only_card_set->unused_mem_size();\n-      size_t occupied_cards = young_only_card_set->occupied();\n-\n-      _max_group_cardset_mem_sz = rs_mem_sz;\n-      _max_cardset_mem_sz_group = young_only_cset_group;\n-\n-      \/\/ Only update cardset details\n-      _young.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+    \/\/ during region iteration. Skip these.\n+    if (group->length() > 1) {\n+      G1CardSet* card_set = group->card_set();\n+\n+      size_t rs_mem_sz = card_set->mem_size();\n+      size_t rs_unused_mem_sz = card_set->unused_mem_size();\n+      size_t occupied_cards = card_set->occupied();\n+\n+      if (rs_mem_sz > _max_group_cardset_mem_sz) {\n+        _max_group_cardset_mem_sz = rs_mem_sz;\n+        _max_cardset_mem_sz_group = group;\n+      }\n+\n+      gen_counter->add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n@@ -290,0 +289,1 @@\n+  }\n@@ -291,0 +291,2 @@\n+  void do_cset_groups() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -292,12 +294,1 @@\n-    G1PerRegionTypeRemSetCounters* current = &_old;\n-    for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n-      if (group->length() > 1) {\n-        G1CardSet* group_card_set = group->card_set();\n-        size_t rs_mem_sz = group_card_set->mem_size();\n-        size_t rs_unused_mem_sz = group_card_set->unused_mem_size();\n-        size_t occupied_cards = group_card_set->occupied();\n-\n-        if (rs_mem_sz > _max_group_cardset_mem_sz) {\n-          _max_group_cardset_mem_sz = rs_mem_sz;\n-          _max_cardset_mem_sz_group = group;\n-        }\n+    accumulate_stats_for_group(g1h->young_regions_cset_group(), &_young);\n@@ -305,4 +296,8 @@\n-        \/\/ Only update cardset details\n-        _old.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n-        _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n-      }\n+    G1CollectionSetCandidates* candidates = g1h->policy()->candidates();\n+    for (G1CSetCandidateGroup* group : candidates->from_marking_groups()) {\n+      accumulate_stats_for_group(group, &_old);\n+    }\n+    \/\/ Skip gathering statistics for retained regions. Just verify that they have\n+    \/\/ the expected amount of regions.\n+    for (G1CSetCandidateGroup* group : candidates->retained_groups()) {\n+      assert(group->length() == 1, \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":27,"deletions":32,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  evacuation_info->set_collection_set_regions(collection_set()->region_length() +\n+  evacuation_info->set_collection_set_regions(collection_set()->initial_region_length() +\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -890,1 +890,1 @@\n-  double worker_cost() const override { return G1CollectedHeap::heap()->collection_set()->region_length(); }\n+  double worker_cost() const override { return G1CollectedHeap::heap()->collection_set()->initial_region_length(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,9 +284,0 @@\n-\/\/ Return true if any of the following is true:\n-\/\/ . the allocation won't fit into the current young gen heap\n-\/\/ . heap memory is tight\n-bool SerialHeap::should_try_older_generation_allocation(size_t word_size) const {\n-  size_t young_capacity = _young_gen->capacity_before_gc();\n-  return    (word_size > heap_word_size(young_capacity))\n-         || _is_heap_almost_full;\n-}\n-\n@@ -311,6 +302,3 @@\n-  \/\/ Loop until the allocation is satisfied, or unsatisfied after GC.\n-  for (uint try_count = 1; \/* return or throw *\/; try_count += 1) {\n-    \/\/ First allocation attempt is lock-free.\n-    DefNewGeneration *young = _young_gen;\n-    if (young->should_allocate(size, is_tlab)) {\n-      result = young->par_allocate(size);\n+  for (uint try_count = 1; \/* break *\/; try_count++) {\n+    if (_young_gen->should_allocate(size, is_tlab)) {\n+      result = _young_gen->par_allocate(size);\n@@ -318,2 +306,11 @@\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n+        break;\n+      }\n+    }\n+    \/\/ Try old-gen allocation for non-TLAB.\n+    if (!is_tlab) {\n+      \/\/ If it's too large for young-gen or heap is too full.\n+      if (size > heap_word_size(_young_gen->capacity_before_gc()) || _is_heap_almost_full) {\n+        result = _old_gen->par_allocate(size);\n+        if (result != nullptr) {\n+          break;\n+        }\n@@ -325,12 +322,0 @@\n-      log_trace(gc, alloc)(\"SerialHeap::mem_allocate_work: attempting locked slow path allocation\");\n-      \/\/ Note that only large objects get a shot at being\n-      \/\/ allocated in later generations.\n-      bool first_only = !should_try_older_generation_allocation(size);\n-\n-      result = attempt_allocation(size, is_tlab, first_only);\n-      if (result != nullptr) {\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n-      }\n-\n-      \/\/ Read the gc count while the heap lock is held.\n@@ -344,4 +329,1 @@\n-\n-      assert(result == nullptr || is_in_reserved(result),\n-             \"result not in heap\");\n-      return result;\n+      break;\n@@ -357,0 +339,3 @@\n+\n+  assert(result == nullptr || is_in_reserved(result), \"postcondition\");\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -232,4 +232,0 @@\n-  \/\/ Return true if an allocation should be attempted in the older generation\n-  \/\/ if it fails in the younger generation.  Return false, otherwise.\n-  bool should_try_older_generation_allocation(size_t word_size) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  \/\/ Multi-threaded version.\n+  inline HeapWord* par_allocate(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,8 @@\n+HeapWord* TenuredGeneration::par_allocate(size_t word_size) {\n+  HeapWord* res = _the_space->par_allocate(word_size);\n+  if (res != nullptr) {\n+    _bts->update_for_block(res, res + word_size);\n+  }\n+  return res;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -826,1 +826,0 @@\n-template<bool GENERATIONAL>\n@@ -836,3 +835,0 @@\n-    if (GENERATIONAL) {\n-      ShenandoahThreadLocalData::enable_plab_promotions(thread);\n-    }\n@@ -842,1 +838,0 @@\n-template<bool GENERATIONAL>\n@@ -854,5 +849,0 @@\n-    if (GENERATIONAL) {\n-      Thread* worker_thread = Thread::current();\n-      ShenandoahThreadLocalData::enable_plab_promotions(worker_thread);\n-    }\n-\n@@ -862,1 +852,1 @@\n-    ShenandoahConcurrentEvacThreadClosure<GENERATIONAL> thr_cl(&oops_cl);\n+    ShenandoahConcurrentEvacThreadClosure thr_cl(&oops_cl);\n@@ -868,1 +858,1 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  const ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -871,7 +861,2 @@\n-  if (heap->mode()->is_generational()) {\n-    ShenandoahConcurrentEvacUpdateThreadTask<true> task(heap->workers()->active_workers());\n-    heap->workers()->run_task(&task);\n-  } else {\n-    ShenandoahConcurrentEvacUpdateThreadTask<false> task(heap->workers()->active_workers());\n-    heap->workers()->run_task(&task);\n-  }\n+  ShenandoahConcurrentEvacUpdateThreadTask task(heap->workers()->active_workers());\n+  heap->workers()->run_task(&task);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1219,0 +1219,5 @@\n+\n+      \/\/ Re-enable promotions for the next evacuation phase.\n+      ShenandoahThreadLocalData::enable_plab_promotions(thread);\n+\n+      \/\/ Reset the fill size for next evacuation phase.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  _paced_time(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  double _paced_time;\n-\n@@ -240,12 +238,0 @@\n-  static void add_paced_time(Thread* thread, double v) {\n-    data(thread)->_paced_time += v;\n-  }\n-\n-  static double paced_time(Thread* thread) {\n-    return data(thread)->_paced_time;\n-  }\n-\n-  static void reset_paced_time(Thread* thread) {\n-    data(thread)->_paced_time = 0;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -40,1 +39,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -42,0 +40,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeStream.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"interpreter\/bytecodes.hpp\"\n@@ -34,1 +34,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/signature.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -35,1 +34,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -37,0 +35,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -55,0 +54,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"bytecodeInterpreter_zero.inline.hpp\"\n@@ -45,2 +46,0 @@\n-# include \"bytecodeInterpreter_zero.inline.hpp\"\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\/\/ # include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/jfr.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"jfr\/jfr.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -32,2 +32,0 @@\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -35,0 +33,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -40,1 +39,0 @@\n-#include \"oops\/instanceKlass.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -45,1 +44,1 @@\n-#include \"runtime\/handles.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"runtime\/handles.inline.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n+#include \"jfr\/instrumentation\/jfrJvmtiAgent.hpp\"\n@@ -27,0 +29,3 @@\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/jni\/jfrJniMethodRegistration.hpp\"\n+#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -29,2 +34,0 @@\n-#include \"jfr\/recorder\/jfrEventSetting.hpp\"\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -33,0 +36,2 @@\n+#include \"jfr\/recorder\/jfrEventSetting.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -34,1 +39,0 @@\n-#include \"jfr\/recorder\/repository\/jfrRepository.hpp\"\n@@ -38,0 +42,1 @@\n+#include \"jfr\/recorder\/repository\/jfrRepository.hpp\"\n@@ -45,5 +50,0 @@\n-#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n-#include \"jfr\/jni\/jfrJniMethodRegistration.hpp\"\n-#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n-#include \"jfr\/instrumentation\/jfrJvmtiAgent.hpp\"\n-#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n@@ -57,0 +56,1 @@\n+#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n@@ -70,1 +70,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -72,0 +71,1 @@\n+#include \"osContainer_linux.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/leakprofiler\/chains\/edgeStore.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"jfr\/leakprofiler\/chains\/edgeStore.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -35,3 +34,0 @@\n-#include \"jfr\/leakprofiler\/chains\/rootSetClosure.hpp\"\n-#include \"jfr\/leakprofiler\/chains\/edgeStore.hpp\"\n-#include \"jfr\/leakprofiler\/chains\/objectSampleMarker.hpp\"\n@@ -39,0 +35,1 @@\n+#include \"jfr\/leakprofiler\/chains\/rootSetClosure.hpp\"\n@@ -41,0 +38,1 @@\n+#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -51,8 +51,0 @@\n-const unsigned int initial_size = 431;\n-\n-static JfrCHeapTraceIdSet* c_heap_allocate_set(int size = initial_size) {\n-  return new JfrCHeapTraceIdSet(size);\n-}\n-\n-static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n-\n@@ -69,8 +61,2 @@\n-static bool has_thread_exited(traceid tid) {\n-  assert(tid != 0, \"invariant\");\n-  if (unloaded_thread_id_set == nullptr) {\n-    return false;\n-  }\n-  ThreadIdExclusiveAccess lock;\n-  return unloaded_thread_id_set->contains(tid);\n-}\n+static const unsigned initial_set_size = 512;\n+static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n@@ -81,1 +67,1 @@\n-    unloaded_thread_id_set = c_heap_allocate_set();\n+    unloaded_thread_id_set = new (mtTracing) JfrCHeapTraceIdSet(initial_set_size);\n@@ -196,6 +182,0 @@\n-static JfrResourceAreaTraceIdSet* id_set = nullptr;\n-\n-static void prepare_for_resolution() {\n-  id_set = new JfrResourceAreaTraceIdSet(initial_size);\n-}\n-\n@@ -216,0 +196,2 @@\n+static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+\n@@ -223,1 +205,1 @@\n-    prepare_for_resolution();\n+    resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n@@ -225,0 +207,1 @@\n+\n@@ -317,2 +300,2 @@\n-  assert(id_set != nullptr, \"invariant\");\n-  return !id_set->add(method_id);\n+  assert(resolution_set != nullptr, \"invariant\");\n+  return !resolution_set->add(method_id);\n@@ -359,1 +342,1 @@\n-  if (sample->is_virtual_thread() || has_thread_exited(sample->thread_id())) {\n+  if (sample->is_virtual_thread() || sample->thread_exited()) {\n@@ -375,1 +358,1 @@\n-  int _count;\n+  unsigned _count;\n@@ -381,1 +364,1 @@\n-  int count() const { return _count; }\n+  unsigned count() const { return _count; }\n@@ -397,2 +380,1 @@\n-  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n-\n+  writer.write_count(_stacktrace_id_set->size());\n@@ -402,1 +384,0 @@\n-  writer.write_count(lpstw.count(), count_offset);\n@@ -425,0 +406,10 @@\n+static void check_if_thread_exited(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  if (sample->thread_exited() || unloaded_thread_id_set == nullptr) {\n+    return;\n+  }\n+  if (unloaded_thread_id_set->contains(sample->thread_id())) {\n+    sample->set_thread_exited();\n+  }\n+}\n+\n@@ -434,0 +425,1 @@\n+    check_if_thread_exited(sample);\n@@ -440,0 +432,7 @@\n+static void delete_unloaded_thread_id_set() {\n+  if (unloaded_thread_id_set != nullptr) {\n+    delete unloaded_thread_id_set;\n+    unloaded_thread_id_set = nullptr;\n+  }\n+}\n+\n@@ -445,0 +444,1 @@\n+  ThreadIdExclusiveAccess lock;\n@@ -446,0 +446,1 @@\n+  delete_unloaded_thread_id_set();\n@@ -448,3 +449,6 @@\n-static inline unsigned int set_size() {\n-  const unsigned int queue_size = static_cast<unsigned int>(JfrOptionSet::old_object_queue_size());\n-  return queue_size > initial_size ? queue_size : initial_size;\n+static inline unsigned stacktrace_id_set_size() {\n+  unsigned queue_size = static_cast<unsigned>(JfrOptionSet::old_object_queue_size());\n+  if (!is_power_of_2(queue_size)) {\n+    queue_size = next_power_of_2(queue_size);\n+  }\n+  return queue_size > initial_set_size ? queue_size : initial_set_size;\n@@ -459,1 +463,3 @@\n-    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(set_size());\n+    const unsigned stacktrace_set_size = stacktrace_id_set_size();\n+    assert(is_power_of_2(stacktrace_set_size), \"invariant\");\n+    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(stacktrace_set_size);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allStatic.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"memory\/allStatic.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfrfiles\/jfrTypes.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"jfrfiles\/jfrTypes.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp\"\n@@ -34,1 +34,0 @@\n-#include \"prims\/jvmtiDeferredUpdates.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jfr\/leakprofiler\/checkpoint\/eventEmitter.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n@@ -28,2 +30,0 @@\n-#include \"jfr\/leakprofiler\/checkpoint\/eventEmitter.hpp\"\n-#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/leakProfiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  mutable bool _thread_exited;\n@@ -85,1 +86,2 @@\n-                   _virtual_thread(false) {}\n+                   _virtual_thread(false),\n+                   _thread_exited(false) {}\n@@ -228,0 +230,9 @@\n+  bool thread_exited() const {\n+    return _thread_exited;\n+  }\n+\n+  void set_thread_exited() const {\n+    assert(!_thread_exited, \"invariant\");\n+    _thread_exited = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n@@ -37,1 +37,0 @@\n-#include \"jfr\/utilities\/jfrSignal.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"jfr\/utilities\/jfrSignal.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/metadata\/jfrSerializer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"logging\/log.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"logging\/log.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrNetworkUtilization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+#include \"jfr\/periodic\/jfrNativeMemoryEvent.hpp\"\n+#include \"jfr\/periodic\/jfrNetworkUtilization.hpp\"\n@@ -44,2 +46,0 @@\n-#include \"jfr\/periodic\/jfrNativeMemoryEvent.hpp\"\n-#include \"jfr\/periodic\/jfrNetworkUtilization.hpp\"\n@@ -64,1 +64,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -66,0 +65,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"logging\/log.hpp\"\n@@ -30,1 +29,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrThreadCPULoadEvent.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"jfr\/utilities\/jfrTime.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n@@ -44,2 +44,0 @@\n-#include \"utilities\/ticks.hpp\"\n-\n@@ -47,0 +45,1 @@\n+#include \"utilities\/ticks.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -29,1 +28,0 @@\n-#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n@@ -31,0 +29,2 @@\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n@@ -67,1 +67,1 @@\n-void JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n+size_t JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n@@ -71,1 +71,1 @@\n-    return;\n+    return 0;\n@@ -90,0 +90,1 @@\n+  return 1;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  static void write(JfrChunkWriter& writer);\n+  static size_t write(JfrChunkWriter& writer);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadState.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadState.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1051,2 +1051,0 @@\n-  KlassUsedPredicate _klass_used_predicate;\n-  MethodUsedPredicate _method_used_predicate;\n@@ -1058,2 +1056,0 @@\n-    _klass_used_predicate(current_epoch()),\n-    _method_used_predicate(current_epoch()),\n@@ -1063,1 +1059,1 @@\n-    if (_method_used_predicate(klass)) {\n+    if (klass->is_instance_klass()) {\n@@ -1078,1 +1074,1 @@\n-    return _klass_used_predicate(klass) ? _klass_cb(klass) : true;\n+    return _klass_cb(klass);\n@@ -1283,1 +1279,1 @@\n-    _artifacts = new JfrArtifactSet(class_unload);\n+    _artifacts = new JfrArtifactSet(class_unload, previous_epoch());\n@@ -1285,1 +1281,1 @@\n-    _artifacts->initialize(class_unload);\n+    _artifacts->initialize(class_unload, previous_epoch());\n@@ -1287,0 +1283,1 @@\n+  assert(current_epoch() || _leakp_writer != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,6 +32,10 @@\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(nullptr),\n-                                                    _klass_list(nullptr),\n-                                                    _total_count(0),\n-                                                    _class_unload(class_unload) {\n-  initialize(class_unload);\n-  assert(_klass_list != nullptr, \"invariant\");\n+JfrArtifactSet::JfrArtifactSet(bool class_unload, bool previous_epoch) : _symbol_table(nullptr),\n+                                                                         _klass_set(nullptr),\n+                                                                         _klass_loader_set(nullptr),\n+                                                                         _klass_loader_leakp_set(nullptr),\n+                                                                         _total_count(0),\n+                                                                         _class_unload(class_unload) {\n+  initialize(class_unload, previous_epoch);\n+  assert(!previous_epoch || _klass_loader_leakp_set != nullptr, \"invariant\");\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  assert(_klass_set != nullptr, \"invariant\");\n@@ -40,2 +44,3 @@\n-static const size_t initial_klass_list_size = 4096;\n-const int initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_set_size = 4096;\n+static unsigned initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_loader_leakp_set_size = 64;\n@@ -43,1 +48,1 @@\n-void JfrArtifactSet::initialize(bool class_unload) {\n+void JfrArtifactSet::initialize(bool class_unload, bool previous_epoch) {\n@@ -53,3 +58,5 @@\n-  _klass_loader_leakp_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);\n+  if (previous_epoch) {\n+    _klass_loader_leakp_set = new JfrKlassSet(initial_klass_loader_leakp_set_size);\n+  }\n+  _klass_loader_set = new JfrKlassSet(initial_klass_loader_set_size);\n+  _klass_set = new JfrKlassSet(initial_klass_set_size);\n@@ -96,5 +103,1 @@\n-  return _klass_list->is_nonempty();\n-}\n-\n-int JfrArtifactSet::entries() const {\n-  return _klass_list->length();\n+  return _klass_set->is_nonempty();\n@@ -102,2 +105,1 @@\n-\n-static inline bool not_in_set(GrowableArray<const Klass*>* set, const Klass* k) {\n+static inline bool not_in_set(JfrArtifactSet::JfrKlassSet* set, const Klass* k) {\n@@ -106,1 +108,1 @@\n-  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(set, k);\n+  return set->add(k);\n@@ -119,2 +121,2 @@\n-  assert(_klass_list != nullptr, \"invariant\");\n-  _klass_list->append(k);\n+  assert(_klass_set != nullptr, \"invariant\");\n+  _klass_set->add(k);\n@@ -124,0 +126,4 @@\n+  assert(_klass_set != nullptr, \"invariant\");\n+  initial_klass_set_size = MAX2(initial_klass_set_size, _klass_set->table_size());\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  initial_klass_loader_set_size = MAX2(initial_klass_loader_set_size, _klass_loader_set->table_size());\n@@ -130,0 +136,2 @@\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  initial_klass_loader_leakp_set_size = MAX2(initial_klass_loader_leakp_set_size, _klass_loader_leakp_set->table_size());\n@@ -131,1 +139,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -34,3 +35,0 @@\n-template <typename T>\n-class GrowableArray;\n-\n@@ -138,21 +136,0 @@\n-class KlassUsedPredicate {\n-  bool _current_epoch;\n- public:\n-  KlassUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n-class MethodUsedPredicate {\n-  bool _current_epoch;\n-public:\n-  MethodUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    if (!klass->is_instance_klass()) {\n-      return false;\n-    }\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n@@ -206,0 +183,26 @@\n+ public:\n+  class JfrArtifactSetConfig : public AllStatic {\n+   public:\n+    typedef const Klass* KEY_TYPE;\n+\n+    constexpr static AnyObj::allocation_type alloc_type() {\n+      return AnyObj::RESOURCE_AREA;\n+    }\n+\n+    constexpr static MemTag memory_tag() {\n+      return mtInternal;\n+    }\n+\n+    \/\/ Knuth multiplicative hashing.\n+    static uint32_t hash(const KEY_TYPE& k) {\n+      const uint32_t v = static_cast<uint32_t>(JfrTraceId::load_raw(k));\n+      return v * UINT32_C(2654435761);\n+    }\n+\n+    static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n+      return lhs == rhs;\n+    }\n+  };\n+\n+  typedef JfrSet<JfrArtifactSetConfig> JfrKlassSet;\n+\n@@ -208,3 +211,3 @@\n-  GrowableArray<const Klass*>* _klass_list;\n-  GrowableArray<const Klass*>* _klass_loader_set;\n-  GrowableArray<const Klass*>* _klass_loader_leakp_set;\n+  JfrKlassSet* _klass_set;\n+  JfrKlassSet* _klass_loader_set;\n+  JfrKlassSet* _klass_loader_leakp_set;\n@@ -215,1 +218,1 @@\n-  JfrArtifactSet(bool class_unload);\n+  JfrArtifactSet(bool class_unload, bool previous_epoch);\n@@ -219,1 +222,1 @@\n-  void initialize(bool class_unload);\n+  void initialize(bool class_unload, bool previous_epoch);\n@@ -234,1 +237,0 @@\n-  int entries() const;\n@@ -257,1 +259,1 @@\n-    if (iterate(functor, _klass_list)) {\n+    if (iterate(functor, _klass_set)) {\n@@ -264,6 +266,4 @@\n-  bool iterate(Functor& functor, GrowableArray<const Klass*>* list) const {\n-    assert(list != nullptr, \"invariant\");\n-    for (int i = 0; i < list->length(); ++i) {\n-      if (!functor(list->at(i))) {\n-        return false;\n-      }\n+  bool iterate(Functor& functor, JfrKlassSet* set) const {\n+    assert(set != nullptr, \"invariant\");\n+    if (set->is_nonempty()) {\n+      set->iterate(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -31,0 +30,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrEventSetting.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n@@ -52,1 +52,0 @@\n-#include \"runtime\/handles.inline.hpp\"\n@@ -54,0 +53,1 @@\n+#include \"runtime\/handles.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfrfiles\/jfrEventClasses.hpp\"\n@@ -27,1 +26,0 @@\n-#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -29,0 +27,1 @@\n+#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -30,1 +29,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -33,0 +31,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -46,1 +45,0 @@\n-#include \"jfr\/writers\/jfrJavaEventWriter.hpp\"\n@@ -48,0 +46,2 @@\n+#include \"jfr\/writers\/jfrJavaEventWriter.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n@@ -370,0 +370,1 @@\n+  size_t _elements;\n@@ -371,1 +372,1 @@\n-  MetadataEvent(JfrChunkWriter& cw) : _cw(cw) {}\n+  MetadataEvent(JfrChunkWriter& cw) : _cw(cw), _elements(0) {}\n@@ -373,1 +374,1 @@\n-    JfrMetadataEvent::write(_cw);\n+    _elements = JfrMetadataEvent::write(_cw);\n@@ -376,1 +377,1 @@\n-  size_t elements() const { return 1; }\n+  size_t elements() const { return _elements; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"utilities\/preserveException.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/preserveException.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThreadLoop.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -30,0 +29,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorageUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPoolWriter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationElementIterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -29,2 +28,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n-#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n@@ -33,0 +30,2 @@\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -52,1 +52,0 @@\n-\/\/ for strstr\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrFlush.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static const int initial_size = 1009;\n+static const int initial_size = 1024;\n@@ -36,1 +36,1 @@\n-  return new JfrCHeapTraceIdSet(size);\n+  return new (mtTracing) JfrCHeapTraceIdSet(size);\n@@ -71,7 +71,0 @@\n-static bool is_nonempty_set(u1 epoch) {\n-  if (epoch == 0) {\n-    return _unload_set_epoch_0 != nullptr && _unload_set_epoch_0->is_nonempty();\n-  }\n-  return _unload_set_epoch_1 != nullptr && _unload_set_epoch_1->is_nonempty();\n-}\n-\n@@ -80,3 +73,1 @@\n-  if (is_nonempty_set(JfrTraceIdEpoch::previous())) {\n-    get_unload_set_previous_epoch()->clear();\n-  }\n+  get_unload_set_previous_epoch()->clear();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -45,1 +45,0 @@\n- \/\/ for strstr\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrResolution.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -31,0 +29,2 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrStackTraceMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"jni.h\"\n-#include \"memory\/iterator.hpp\"\n@@ -33,0 +31,2 @@\n+#include \"jni.h\"\n+#include \"memory\/iterator.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -30,0 +29,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -30,0 +29,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilterManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -32,0 +31,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrEpochQueue.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/utilities\/jfrAllocation.hpp\"\n@@ -30,1 +29,1 @@\n-#include \"utilities\/resizableHashTable.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -32,2 +31,2 @@\n-template <typename AllocPolicy = JfrCHeapObj, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n-class ConfigTraceID : public AllStatic {\n+template <typename K, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n+class JfrSetConfig : public AllStatic {\n@@ -35,2 +34,1 @@\n-  typedef AllocPolicy STORAGE;\n-  typedef traceid TYPE;\n+  typedef K KEY_TYPE;\n@@ -47,3 +45,3 @@\n-  static uint32_t hash(const TYPE& id) {\n-    const uint32_t v = static_cast<uint32_t>(id);\n-    return v * UINT32_C(2654435761);\n+  static uint32_t hash(const KEY_TYPE& key) {\n+    const uint32_t k = static_cast<uint32_t>(key);\n+    return k * UINT32_C(2654435761);\n@@ -52,1 +50,1 @@\n-  static bool cmp(const TYPE& lhs, const TYPE& rhs) {\n+  static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n@@ -57,2 +55,0 @@\n-constexpr static unsigned int MAX_TABLE_SIZE = 0x3fffffff;\n-\n@@ -60,7 +56,16 @@\n-class JfrSet : public CONFIG::STORAGE {\n- public:\n-  typedef typename CONFIG::TYPE TYPE;\n-  typedef ResizeableHashTable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n-\n-  constexpr static bool is_cheap() {\n-    return CONFIG::alloc_type() == AnyObj::C_HEAP;\n+class JfrSetStorage : public AnyObj {\n+  typedef typename CONFIG::KEY_TYPE K;\n+ protected:\n+  K* _table;\n+  unsigned _table_size;\n+  unsigned _elements;\n+\n+  static K* alloc_table(unsigned table_size) {\n+    K* table;\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(K, table_size, CONFIG::memory_tag());\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(K, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(K));\n+    return table;\n@@ -69,2 +74,4 @@\n-  JfrSet(unsigned int initial_size, unsigned int max_size = MAX_TABLE_SIZE) :\n-    _map(is_cheap() ? new (CONFIG::memory_tag()) HashMap(initial_size, max_size) : new HashMap(initial_size, max_size)) {}\n+  JfrSetStorage(unsigned table_size) :\n+    _table(alloc_table(table_size)),\n+    _table_size(table_size),\n+    _elements(0) {}\n@@ -72,3 +79,3 @@\n-  ~JfrSet() {\n-    if (is_cheap()) {\n-      delete _map;\n+  ~JfrSetStorage() {\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, _table);\n@@ -78,4 +85,10 @@\n-  bool add(const TYPE& k) {\n-    bool inserted;\n-    _map->put_if_absent(k, &inserted);\n-    return inserted;\n+ public:\n+  template <typename Functor>\n+  void iterate(Functor& functor) {\n+    assert(is_nonempty(), \"invariant\");\n+    for (unsigned i = 0; i < _table_size; ++i) {\n+      K k = _table[i];\n+      if (k != 0) {\n+        functor(k);\n+      }\n+    }\n@@ -84,2 +97,2 @@\n-  bool remove(const TYPE& k) {\n-    return _map->remove(k);\n+  unsigned table_size() const {\n+    return _table_size;\n@@ -88,2 +101,2 @@\n-  bool contains(const TYPE& k) const {\n-    return _map->contains(k);\n+  unsigned size() const {\n+    return _elements;\n@@ -92,2 +105,2 @@\n-  bool is_empty() const {\n-    return _map->number_of_entries() == 0;\n+  bool is_nonempty() const {\n+    return _elements > 0;\n@@ -96,2 +109,2 @@\n-  bool is_nonempty() const {\n-    return !is_empty();\n+  void clear() {\n+    memset(_table, 0, _table_size * sizeof(K));\n@@ -99,0 +112,1 @@\n+};\n@@ -100,2 +114,11 @@\n-  int size() const {\n-    return _map->number_of_entries();\n+template <typename CONFIG>\n+class JfrSet : public JfrSetStorage<CONFIG> {\n+  typedef typename CONFIG::KEY_TYPE K;\n+  static_assert(sizeof(K) > 1, \"invalid size of CONFIG::KEY_TYPE\");\n+ private:\n+  static const constexpr unsigned max_initial_size = 1 << 30;\n+  unsigned _table_mask;\n+  unsigned _resize_threshold; \/\/ 0.5 load factor\n+\n+  uint32_t slot_idx(const uint32_t hash) const {\n+    return hash & _table_mask;\n@@ -104,3 +127,23 @@\n-  void clear() {\n-    if (is_nonempty()) {\n-      _map->unlink(this);\n+  void resize() {\n+    assert(this->_elements == _resize_threshold, \"invariant\");\n+    K* const old_table = this->_table;\n+    assert(old_table != nullptr, \"invariant\");\n+    const unsigned old_table_size = this->table_size();\n+    guarantee(old_table_size <= max_initial_size, \"overflow\");\n+    this->_table_size = old_table_size << 1;\n+    this->_table = JfrSetStorage<CONFIG>::alloc_table(this->_table_size);\n+    _table_mask = this->_table_size - 1;\n+    _resize_threshold = old_table_size;\n+    for (unsigned i = 0; i < old_table_size; ++i) {\n+      const K k = old_table[i];\n+      if (k != 0) {\n+        uint32_t idx = slot_idx(CONFIG::hash(k));\n+        do {\n+          K v = this->_table[idx];\n+          if (v == 0) {\n+            this->_table[idx] = k;\n+            break;\n+          }\n+          idx = slot_idx(idx + 1);\n+        } while (true);\n+      }\n@@ -108,1 +151,5 @@\n-    assert(is_empty(), \"invariant\");\n+    if (CONFIG::alloc_type() == AnyObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, old_table);\n+    }\n+    assert(_table_mask + 1 == this->_table_size, \"invariant\");\n+    assert(_resize_threshold << 1 == this->_table_size, \"invariant\");\n@@ -111,3 +158,18 @@\n-  \/\/ Callback for node deletion, used by clear().\n-  bool do_entry(const TYPE& k, const TYPE& v) {\n-    return true;\n+  K* find_slot(K const& k) const {\n+    uint32_t idx = slot_idx(CONFIG::hash(k));\n+    assert(idx < this->table_size(), \"invariant\");\n+    K* result = nullptr;\n+    while (true) {\n+      K v = this->_table[idx];\n+      if (v == 0) {\n+        result = &this->_table[idx];\n+        break;\n+      }\n+      if (CONFIG::cmp(v, k)) {\n+        result = reinterpret_cast<K*>(p2i(&this->_table[idx]) | 1);\n+        break;\n+      }\n+      idx = slot_idx(idx + 1);\n+    }\n+    assert(result != nullptr, \"invariant\");\n+    return result;\n@@ -116,2 +178,29 @@\n- private:\n-  HashMap* _map;\n+ public:\n+  JfrSet(unsigned size) :\n+    JfrSetStorage<CONFIG>(size),\n+    _table_mask(size - 1),\n+    _resize_threshold(size >> 1) {\n+    assert(size >= 2, \"invariant\");\n+    assert(size % 2 == 0, \"invariant\");\n+    assert(size <= max_initial_size, \"avoid overflow in resize\");\n+  }\n+\n+  bool contains(K const& k) const {\n+    K* const slot = find_slot(k);\n+    return p2i(slot) & 1;\n+  }\n+\n+  bool add(K const& k) {\n+    K* const slot = find_slot(k);\n+    if (p2i(slot) & 1) {\n+      \/\/ Already exists.\n+      return false;\n+    }\n+    assert(*slot == 0, \"invariant\");\n+    *slot = k;\n+    if (++this->_elements == _resize_threshold) {\n+      resize();\n+    }\n+    assert(this->_elements < _resize_threshold, \"invariant\");\n+    return true;\n+  }\n@@ -120,2 +209,2 @@\n-typedef JfrSet<ConfigTraceID<> > JfrCHeapTraceIdSet;\n-typedef JfrSet<ConfigTraceID<ResourceObj, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid> > JfrCHeapTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":138,"deletions":49,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTimeConverter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/orderAccess.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/orderAccess.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTryLock.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n@@ -30,0 +29,2 @@\n+\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrStreamWriterHost.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  assert(Universe::objectArrayKlass() != nullptr, \"Too early?\");\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -189,1 +189,5 @@\n-  static ObjArrayKlass* objectArrayKlass()       { return _objectArrayKlass; }\n+  static ObjArrayKlass* objectArrayKlass() {\n+    ObjArrayKlass* k = _objectArrayKlass;\n+    assert(k != nullptr, \"Object array klass should be initialized; too early?\");\n+    return k;\n+  }\n@@ -191,1 +195,5 @@\n-  static Klass* fillerArrayKlass()               { return _fillerArrayKlass; }\n+  static Klass* fillerArrayKlass() {\n+    Klass* k = _fillerArrayKlass;\n+    assert(k != nullptr, \"Filler array class should be initialized; too early?\");\n+    return k;\n+  }\n@@ -196,2 +204,3 @@\n-    assert(_typeArrayKlasses[t] != nullptr, \"domain check\");\n-    return _typeArrayKlasses[t];\n+    TypeArrayKlass* k = _typeArrayKlasses[t];\n+    assert(k != nullptr, \"Type array class should be initialized; too early?\");\n+    return k;\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  bool match_mode_flag(MallocLimitMode* out) {\n+  bool match_mode(MallocLimitMode* out) {\n@@ -80,1 +80,1 @@\n-  \/\/ Check if string at position matches a category name.\n+  \/\/ Check if string at position matches a MemTag name.\n@@ -82,1 +82,1 @@\n-  bool match_category(MemTag* out) {\n+  bool match_mem_tag(MemTag* out) {\n@@ -133,1 +133,1 @@\n-void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode flag) {\n+void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode mode) {\n@@ -135,1 +135,1 @@\n-  _cat[i].sz = s; _cat[i].mode = flag;\n+  _mtag[i].sz = s; _mtag[i].mode = mode;\n@@ -147,1 +147,0 @@\n-  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n@@ -153,1 +152,1 @@\n-      if (_cat[i].sz > 0) {\n+      if (_mtag[i].sz > 0) {\n@@ -156,1 +155,1 @@\n-                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n+                     PROPERFMTARGS(_mtag[i].sz), mode_to_name(_mtag[i].mode));\n@@ -167,1 +166,1 @@\n-  \/\/ MallocLimit=<size>[:flag]\n+  \/\/ MallocLimit=<size>[:mode]\n@@ -169,2 +168,2 @@\n-  \/\/ Category-specific form:\n-  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+  \/\/ MemTag-specific form:\n+  \/\/ MallocLimit=<mem-tag>:<size>[:mode][,<mem-tag>:<size>[:mode]...]\n@@ -180,1 +179,1 @@\n-    \/\/ Match optional mode flag (e.g. 1g:oom)\n+    \/\/ Match optional mode  (e.g. 1g:oom)\n@@ -183,1 +182,1 @@\n-      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n+      BAIL_UNLESS(sst.match_mode(&_glob.mode), \"Expected mode\");\n@@ -186,1 +185,1 @@\n-  \/\/ Category-specific form?\n+  \/\/ MemTag-specific form?\n@@ -191,2 +190,2 @@\n-      \/\/ Match category, followed by :\n-      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n+      \/\/ Match MemTag, followed by :\n+      BAIL_UNLESS(sst.match_mem_tag(&mem_tag), \"Expected category name\");\n@@ -195,1 +194,1 @@\n-      malloclimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n+      malloclimit* const modified_limit = &_mtag[NMTUtil::tag_to_index(mem_tag)];\n@@ -200,1 +199,1 @@\n-      \/\/ Match optional flag\n+      \/\/ Match optional mode\n@@ -202,1 +201,1 @@\n-        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n+        BAIL_UNLESS(sst.match_mode(&modified_limit->mode), \"Expected mode\");\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  malloclimit _cat[mt_number_of_tags]; \/\/ per-category limit\n+  malloclimit _mtag[mt_number_of_tags]; \/\/ per-memtag limit\n@@ -60,1 +60,1 @@\n-  const malloclimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n+  const malloclimit* mem_tag_limit(MemTag mem_tag) const { return &_mtag[(int)mem_tag]; }\n@@ -72,1 +72,1 @@\n-  static const malloclimit* category_limit(MemTag mem_tag) { return _limits.category_limit(mem_tag); }\n+  static const malloclimit* mem_tag_limit(MemTag mem_tag) { return _limits.mem_tag_limit(mem_tag); }\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -210,0 +210,6 @@\n+  if (ZapCHeap) {\n+    \/\/ To do this zapping, we need to know the block size.\n+    \/\/ This is why we have to do it here, and not in os::free.\n+    memset(memblock, freeBlockPad, header->size());\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-      \/\/ Category Limit?\n-      l = MallocLimitHandler::category_limit(mem_tag);\n+      \/\/ MemTag Limit?\n+      l = MallocLimitHandler::mem_tag_limit(mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  if (_resolved_indy_entries == nullptr) {\n+    return 0;\n+  }\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -669,0 +669,3 @@\n+  develop(bool, VerifyIntrinsicChecks, false,                               \\\n+          \"Verify in intrinsic that Java level checks work as expected\")    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2541,7 +2541,9 @@\n-          assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n-          ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-          uint i = 0;\n-          for (; i < call->row_limit(); i++) {\n-            ciKlass* receiver = call->receiver(i);\n-            if (receiver != nullptr) {\n-              break;\n+          if (TypeProfileCasts) {\n+            assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n+            ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n+            uint i = 0;\n+            for (; i < call->row_limit(); i++) {\n+              ciKlass* receiver = call->receiver(i);\n+              if (receiver != nullptr) {\n+                break;\n+              }\n@@ -2549,0 +2551,1 @@\n+            ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2550,1 +2553,0 @@\n-          ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -963,1 +963,5 @@\n-void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n+void LibraryCallKit::generate_string_range_check(Node* array,\n+                                                 Node* offset,\n+                                                 Node* count,\n+                                                 bool char_count,\n+                                                 bool halt_on_oob) {\n@@ -981,4 +985,11 @@\n-    PreserveJVMState pjvms(this);\n-    set_control(_gvn.transform(bailout));\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_maybe_recompile);\n+    if (halt_on_oob) {\n+      bailout = _gvn.transform(bailout)->as_Region();\n+      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n+      Node* halt = _gvn.transform(new HaltNode(bailout, frame, \"unexpected guard failure in intrinsic\"));\n+      C->root()->add_req(halt);\n+    } else {\n+      PreserveJVMState pjvms(this);\n+      set_control(_gvn.transform(bailout));\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_maybe_recompile);\n+    }\n@@ -1142,0 +1153,1 @@\n+\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1153,6 +1165,6 @@\n-  ba = must_be_not_null(ba, true);\n-\n-  \/\/ Range checks\n-  generate_string_range_check(ba, offset, len, false);\n-  if (stopped()) {\n-    return true;\n+  if (VerifyIntrinsicChecks) {\n+    ba = must_be_not_null(ba, true);\n+    generate_string_range_check(ba, offset, len, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n@@ -1160,0 +1172,1 @@\n+\n@@ -3671,1 +3684,1 @@\n-  lease_result_value->init_req(_true_path, null()); \/\/ if the lease was returned, return 0.\n+  lease_result_value->init_req(_true_path, _gvn.longcon(0)); \/\/ if the lease was returned, return 0L.\n@@ -6804,0 +6817,3 @@\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6814,2 +6830,8 @@\n-  src = must_be_not_null(src, true);\n-  dst = must_be_not_null(dst, true);\n+  \/\/ Cast source & target arrays to not-null\n+  if (VerifyIntrinsicChecks) {\n+    src = must_be_not_null(src, true);\n+    dst = must_be_not_null(dst, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n@@ -6832,0 +6854,9 @@\n+  \/\/ Check source & target bounds\n+  if (VerifyIntrinsicChecks) {\n+    generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n+    generate_string_range_check(dst, dst_offset, length, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -175,1 +175,2 @@\n-                                    Node* length, bool char_count);\n+                                    Node* length, bool char_count,\n+                                    bool halt_on_oob = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1639,0 +1639,58 @@\n+private:\n+  \/\/ Class to keep track of wins in split_thru_phi.\n+  class SplitThruPhiWins {\n+  private:\n+    \/\/ Region containing the phi we are splitting through.\n+    const Node* _region;\n+\n+    \/\/ Sum of all wins regardless of where they happen. This applies to Loops phis as well as non-loop phis.\n+    int _total_wins;\n+\n+    \/\/ For Loops, wins have different impact depending on if they happen on loop entry or on the backedge.\n+    \/\/ Number of wins on a loop entry edge if the split is through a loop head,\n+    \/\/ otherwise 0. Entry edge wins only pay dividends once on loop entry.\n+    int _loop_entry_wins;\n+    \/\/ Number of wins on a loop back-edge, which pay dividends on every iteration.\n+    int _loop_back_wins;\n+\n+  public:\n+    SplitThruPhiWins(const Node* region) :\n+      _region(region),\n+      _total_wins(0),\n+      _loop_entry_wins(0),\n+      _loop_back_wins(0) {};\n+\n+    void reset() {_total_wins = 0; _loop_entry_wins = 0; _loop_back_wins = 0;}\n+    void add_win(int ctrl_index) {\n+      if (_region->is_Loop() && ctrl_index == LoopNode::EntryControl) {\n+        _loop_entry_wins++;\n+      } else if (_region->is_Loop() && ctrl_index == LoopNode::LoopBackControl) {\n+        _loop_back_wins++;\n+      }\n+      _total_wins++;\n+    }\n+    \/\/ Is this split profitable with respect to the policy?\n+    bool profitable(int policy) const {\n+      assert(_region->is_Loop() || (_loop_entry_wins == 0 && _loop_back_wins == 0), \"wins on loop edges without a loop\");\n+      assert(!_region->is_Loop() || _total_wins == _loop_entry_wins + _loop_back_wins, \"missed some win\");\n+      \/\/ In general this means that the split has to have more wins than specified\n+      \/\/ in the policy. However, for loops we need to take into account where the\n+      \/\/ wins happen. We need to be careful when splitting, because splitting nodes\n+      \/\/ related to the iv through the phi can sufficiently rearrange the loop\n+      \/\/ structure to prevent RCE and thus vectorization. Thus, we only deem splitting\n+      \/\/ profitable if the win of a split is not on the entry edge, as such wins\n+      \/\/ only pay off once and have a high chance of messing up the loop structure.\n+      return (_loop_entry_wins == 0 && _total_wins > policy) ||\n+      \/\/ If there are wins on the entry edge but the backadge also has sufficient wins,\n+      \/\/ there is sufficient profitability to spilt regardless of the risk of messing\n+      \/\/ up the loop structure.\n+             _loop_back_wins > policy ||\n+      \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n+      \/\/ split. This is needed when we split a node and then must also split a\n+      \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n+             policy < 0;\n+    }\n+  };\n+\n+public:\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -76,1 +77,1 @@\n-  int wins = 0;\n+  SplitThruPhiWins wins(region);\n@@ -129,1 +130,1 @@\n-      wins++;\n+      wins.add_win(i);\n@@ -144,1 +145,1 @@\n-        wins++;\n+        wins.add_win(i);\n@@ -152,1 +153,1 @@\n-          wins++;\n+          wins.add_win(i);\n@@ -175,1 +176,1 @@\n-      wins = 0;\n+      wins.reset();\n@@ -180,1 +181,1 @@\n-  if (wins <= policy) {\n+  if (!wins.profitable(policy)) {\n@@ -237,0 +238,7 @@\n+#ifndef PRODUCT\n+  if (TraceLoopOpts) {\n+    tty->print(\"Split %d %s through %d Phi in %d %s\",\n+               n->_idx, n->Name(), phi->_idx, region->_idx, region->Name());\n+  }\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-  if ((sopc != 0) && !arch_supports_vector(sopc, num_elem, elem_bt, mask_use_type)) {\n+  if (!arch_supports_vector(sopc, num_elem, elem_bt, mask_use_type)) {\n@@ -394,1 +394,1 @@\n-  bool use_predicate = is_masked_op && sopc != 0 && arch_supports_vector(sopc, num_elem, elem_bt, VecMaskUsePred);\n+  bool use_predicate = is_masked_op && arch_supports_vector(sopc, num_elem, elem_bt, VecMaskUsePred);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  inline void patch_pd_unused(intptr_t* sp);\n@@ -786,3 +787,18 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n-  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n+\n+  int adjust = frame::metadata_words_at_bottom;\n+#if INCLUDE_ASAN && defined(AARCH64)\n+  \/\/ Reading at offset frame::metadata_words_at_bottom from _cont_stack_top\n+  \/\/ will accesss memory at the callee frame, which on preemption cases will\n+  \/\/ be the VM native method being called. The Arm 64-bit ABI doesn't specify\n+  \/\/ a location where the frame record (returnpc+fp) has to be stored within\n+  \/\/ a stack frame, and GCC currently chooses to save it at the top of the\n+  \/\/ frame (lowest address). ASan treats this memory access in the callee as\n+  \/\/ an overflow access to one of the locals stored in that frame. For these\n+  \/\/ preemption cases we don't need to read these words anyways so we avoid it.\n+  if (_preempt) {\n+    adjust = 0;\n+  }\n+#endif\n+  intptr_t* from = _cont_stack_top - adjust;\n+  intptr_t* to   = chunk_top - adjust;\n+  copy_to_chunk(from, to, cont_size() + adjust);\n@@ -819,0 +835,5 @@\n+    \/\/ For stub\/native frames the fp is not used while frozen, and will be constructed\n+    \/\/ again when thawing the frame (see ThawBase::handle_preempted_continuation). We\n+    \/\/ patch it with a special bad address to help with debugging, particularly when\n+    \/\/ inspecting frames and identifying invalid accesses.\n+    patch_pd_unused(chunk_top);\n@@ -2537,1 +2558,1 @@\n-    \/\/ we copied the original fp at the time of freeze which now will have to be fixed.\n+    \/\/ we copied the fp patched during freeze, which will now have to be fixed.\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -611,1 +611,2 @@\n-    guarantee(expressions != nullptr && expressions->length() > 0, \"must have exception to throw\");\n+    guarantee(expressions != nullptr && expressions->length() == 1, \"should have only exception on stack\");\n+    guarantee(exec_mode != Unpack_exception, \"rethrow_exception set with Unpack_exception\");\n@@ -787,0 +788,1 @@\n+    assert(array->element(0)->rethrow_exception(), \"must be\");\n@@ -894,0 +896,1 @@\n+#ifdef ASSERT\n@@ -918,0 +921,1 @@\n+#endif\n@@ -982,1 +986,0 @@\n-    bool is_top_frame = true;\n@@ -984,3 +987,3 @@\n-    int callee_max_locals = 0;\n-    for (int i = 0; i < cur_array->frames(); i++) {\n-      vframeArrayElement* el = cur_array->element(i);\n+    for (int frame_idx = 0; frame_idx < cur_array->frames(); frame_idx++) {\n+      bool is_top_frame = (frame_idx == 0);\n+      vframeArrayElement* el = cur_array->element(frame_idx);\n@@ -989,0 +992,2 @@\n+      methodHandle mh(thread, iframe->interpreter_frame_method());\n+      bool reexecute = el->should_reexecute();\n@@ -990,2 +995,0 @@\n-      \/\/ Get the oop map for this bci\n-      InterpreterOopMap mask;\n@@ -993,2 +996,0 @@\n-      bool try_next_mask = false;\n-      int next_mask_expression_stack_size = -1;\n@@ -996,3 +997,0 @@\n-      methodHandle mh(thread, iframe->interpreter_frame_method());\n-      OopMapCache::compute_one_oop_map(mh, iframe->interpreter_frame_bci(), &mask);\n-      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -1000,1 +998,1 @@\n-      \/\/ Get to the next bytecode if possible\n+      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -1002,0 +1000,32 @@\n+      Bytecodes::Code cur_code = str.next();\n+\n+      if (!reexecute && !Bytecodes::is_invoke(cur_code)) {\n+        \/\/ We can only compute OopMaps for the before state, so we need to roll forward\n+        \/\/ to the next bytecode.\n+        assert(is_top_frame, \"must be\");\n+        assert(falls_through(cur_code), \"must be\");\n+        assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+        assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+        \/\/ Need to subtract off the size of the result type of\n+        \/\/ the bytecode because this is not described in the\n+        \/\/ debug info but returned to the interpreter in the TOS\n+        \/\/ caching register\n+        BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n+        if (bytecode_result_type != T_ILLEGAL) {\n+          top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n+        }\n+        assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n+\n+        cur_code = str.next();\n+        \/\/ Reflect the fact that we have rolled forward and now need\n+        \/\/ top_frame_expression_stack_adjustment\n+        reexecute = true;\n+      }\n+\n+      assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+      assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+      \/\/ Get the oop map for this bci\n+      InterpreterOopMap mask;\n+      OopMapCache::compute_one_oop_map(mh, str.bci(), &mask);\n@@ -1005,2 +1035,0 @@\n-      Bytecodes::Code cur_code = str.next();\n-      Bytecodes::Code next_code = Bytecodes::_shouldnotreachhere;\n@@ -1008,1 +1036,1 @@\n-        Bytecode_invoke invoke(mh, iframe->interpreter_frame_bci());\n+        Bytecode_invoke invoke(mh, str.bci());\n@@ -1010,1 +1038,1 @@\n-        if (i != 0 && invoke.has_member_arg()) {\n+        if (!is_top_frame && invoke.has_member_arg()) {\n@@ -1014,30 +1042,0 @@\n-      if (str.bci() < max_bci) {\n-        next_code = str.next();\n-        if (next_code >= 0) {\n-          \/\/ The interpreter oop map generator reports results before\n-          \/\/ the current bytecode has executed except in the case of\n-          \/\/ calls. It seems to be hard to tell whether the compiler\n-          \/\/ has emitted debug information matching the \"state before\"\n-          \/\/ a given bytecode or the state after, so we try both\n-          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n-            \/\/ Get expression stack size for the next bytecode\n-            InterpreterOopMap next_mask;\n-            OopMapCache::compute_one_oop_map(mh, str.bci(), &next_mask);\n-            next_mask_expression_stack_size = next_mask.expression_stack_size();\n-            if (Bytecodes::is_invoke(next_code)) {\n-              Bytecode_invoke invoke(mh, str.bci());\n-              next_mask_expression_stack_size += invoke.size_of_parameters();\n-            }\n-            \/\/ Need to subtract off the size of the result type of\n-            \/\/ the bytecode because this is not described in the\n-            \/\/ debug info but returned to the interpreter in the TOS\n-            \/\/ caching register\n-            BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n-            if (bytecode_result_type != T_ILLEGAL) {\n-              top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n-            }\n-            assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n-            try_next_mask = true;\n-          }\n-        }\n-      }\n@@ -1046,38 +1044,43 @@\n-      \/\/ This assertion may be dependent on the platform we're running on and may need modification (tested on x86 and sparc)\n-      if (!(\n-            \/* SPARC *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||\n-            \/* x86 *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||\n-            (try_next_mask &&\n-             (iframe->interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -\n-                                                                    top_frame_expression_stack_adjustment))) ||\n-            (is_top_frame && (exec_mode == Unpack_exception) && iframe->interpreter_frame_expression_stack_size() == 0) ||\n-            (is_top_frame && (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el->should_reexecute()) &&\n-             (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))\n-            )) {\n-        {\n-          \/\/ Print out some information that will help us debug the problem\n-          tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n-          tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n-          tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n-          if (try_next_mask) {\n-            tty->print_cr(\"  Next code %s\", Bytecodes::name(next_code));\n-          }\n-          tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n-                        iframe->interpreter_frame_expression_stack_size());\n-          tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n-          tty->print_cr(\"  try_next_mask = %d\", try_next_mask);\n-          tty->print_cr(\"  next_mask_expression_stack_size = %d\", next_mask_expression_stack_size);\n-          tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n-          tty->print_cr(\"  callee_max_locals = %d\", callee_max_locals);\n-          tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n-          tty->print_cr(\"  exec_mode = %d\", exec_mode);\n-          tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n-          tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n-          tty->print_cr(\"  Interpreted frames:\");\n-          for (int k = 0; k < cur_array->frames(); k++) {\n-            vframeArrayElement* el = cur_array->element(k);\n-            tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n-          }\n-          cur_array->print_on_2(tty);\n+      auto match = [&]() {\n+        int iframe_expr_ssize = iframe->interpreter_frame_expression_stack_size();\n+#if INCLUDE_JVMCI\n+        if (is_top_frame && el->rethrow_exception()) {\n+          return iframe_expr_ssize == 1;\n+        }\n+#endif\n+        \/\/ This should only be needed for C1\n+        if (is_top_frame && exec_mode == Unpack_exception && iframe_expr_ssize == 0) {\n+          return true;\n+        }\n+        if (reexecute) {\n+          int expr_ssize_before = iframe_expr_ssize + top_frame_expression_stack_adjustment;\n+          int oopmap_expr_invoke_ssize = mask.expression_stack_size() + cur_invoke_parameter_size;\n+          return expr_ssize_before == oopmap_expr_invoke_ssize;\n+        } else {\n+          int oopmap_expr_callee_ssize = mask.expression_stack_size() + callee_size_of_parameters;\n+          return iframe_expr_ssize == oopmap_expr_callee_ssize;\n+        }\n+      };\n+      if (!match()) {\n+        \/\/ Print out some information that will help us debug the problem\n+        tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n+        tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", frame_idx, cur_array->frames() - 1);\n+        tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n+        tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n+                      iframe->interpreter_frame_expression_stack_size());\n+        tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n+        tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n+        tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n+        tty->print_cr(\"  exec_mode = %d\", exec_mode);\n+        tty->print_cr(\"  original should_reexecute = %s\", el->should_reexecute() ? \"true\" : \"false\");\n+        tty->print_cr(\"  reexecute = %s%s\", reexecute ? \"true\" : \"false\",\n+                      (reexecute != el->should_reexecute()) ? \" (changed)\" : \"\");\n+#if INCLUDE_JVMCI\n+        tty->print_cr(\"  rethrow_exception = %s\", el->rethrow_exception() ? \"true\" : \"false\");\n+#endif\n+        tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n+        tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n+        tty->print_cr(\"  Interpreted frames:\");\n+        for (int k = 0; k < cur_array->frames(); k++) {\n+          vframeArrayElement* el = cur_array->element(k);\n+          tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n@@ -1085,0 +1088,1 @@\n+        cur_array->print_on_2(tty);\n@@ -1090,2 +1094,0 @@\n-      callee_max_locals = mh->max_locals();\n-      is_top_frame = false;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":89,"deletions":87,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -139,0 +139,10 @@\n+JVMFlag::Error LargePageSizeInBytesConstraintFunc(size_t value, bool verbose) {\n+  if (!is_power_of_2(value)) {\n+    JVMFlag::printError(verbose, \"LargePageSizeInBytes ( %zu ) must be \"\n+                        \"a power of 2\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  f(size_t, LargePageSizeInBytesConstraintFunc)       \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,1 +240,2 @@\n-          \"page size for the environment as the maximum)\")                  \\\n+          \"page size for the environment as the maximum) \"                  \\\n+          \"(must be a power of 2)\")                                         \\\n@@ -242,0 +243,1 @@\n+          constraint(LargePageSizeInBytesConstraintFunc, AtParse)           \\\n@@ -486,0 +488,3 @@\n+  develop(bool, ZapCHeap, trueInDebug,                                      \\\n+          \"Zap allocated\/freed C heap space\")                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    VMError::set_handshake_timed_out_thread(p2i(target));\n+    VMError::set_handshake_timed_out_thread(target);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -714,0 +714,1 @@\n+  assert(node->TState == ObjectWaiter::TS_RUN, \"\");\n@@ -729,0 +730,1 @@\n+      node->TState = ObjectWaiter::TS_RUN;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -669,2 +669,2 @@\n-  } else {\n-    DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n+  } else if (ZapCHeap) {\n+    ::memset(inner_ptr, uninitBlockPad, size);\n@@ -743,1 +743,1 @@\n-    if (old_size < size) {\n+    if (ZapCHeap && old_size < size) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-        VMError::set_safepoint_timed_out_thread(p2i(cur_thread));\n+        VMError::set_safepoint_timed_out_thread(cur_thread);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2688,5 +2688,7 @@\n-    assert(no_arg_blob != nullptr &&\n-           obj_arg_blob != nullptr &&\n-           int_arg_blob != nullptr &&\n-           obj_int_arg_blob != nullptr &&\n-           obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n+    \/\/ we should always get an entry back but we don't have any\n+    \/\/ associated blob on Zero\n+    assert(_no_arg_handler != nullptr &&\n+           _obj_arg_handler != nullptr &&\n+           _int_arg_handler != nullptr &&\n+           _obj_int_arg_handler != nullptr &&\n+           _obj_obj_arg_handler != nullptr, \"Initial adapter handlers must be properly created\");\n@@ -2696,0 +2698,2 @@\n+#ifndef ZERO\n+  \/\/ no blobs to register when we are on Zero\n@@ -2701,0 +2705,1 @@\n+#endif \/\/ ZERO\n@@ -3120,0 +3125,2 @@\n+  \/\/ we can only check for the same code if there is any\n+#ifndef ZERO\n@@ -3126,0 +3133,1 @@\n+# endif \/\/ ZERO\n@@ -3228,1 +3236,2 @@\n-  int insts_size = adapter_blob->code_size();\n+  int insts_size;\n+  \/\/ on Zero the blob may be null\n@@ -3230,0 +3239,4 @@\n+  if (adapter_blob == nullptr) {\n+    return;\n+  }\n+  insts_size = adapter_blob->code_size();\n@@ -3279,0 +3292,5 @@\n+#ifdef ZERO\n+  \/\/ On zero there is no code to save and no need to create a blob and\n+  \/\/ or relocate the handler.\n+  adapter_blob = nullptr;\n+#else\n@@ -3302,0 +3320,2 @@\n+#endif \/\/ ZERO\n+\n@@ -3308,0 +3328,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -176,8 +176,0 @@\n-  if (code_size == 0) {\n-    LogTarget(Info, stubs) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print_cr(\"%s\\t not generated\", buffer_name);\n-    }\n-    return nullptr;\n-  }\n@@ -204,0 +196,9 @@\n+  if (code_size == 0) {\n+    assert(buffer.insts_size() == 0, \"should not write into buffer when bob size declared as 0\");\n+    LogTarget(Info, stubs) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"%s\\t not generated\", buffer_name);\n+    }\n+    return nullptr;\n+  }\n@@ -206,1 +207,1 @@\n-  assert(code_size == 0 || buffer.insts_remaining() > 200,\n+  assert(buffer.insts_remaining() > 200,\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/scopeDesc.hpp\"\n@@ -64,1 +65,4 @@\n-  _reexecute = vf->should_reexecute();\n+  _reexecute = vf->should_reexecute(); \/\/ initial value, updated in unpack_on_stack\n+#if INCLUDE_JVMCI\n+  _rethrow = vf->scope()->rethrow_exception();\n+#endif\n@@ -174,1 +178,28 @@\n-int unpack_counter = 0;\n+static int unpack_counter = 0;\n+\n+bool vframeArrayElement::should_reexecute(bool is_top_frame, int exec_mode) const {\n+  if (is_top_frame) {\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      return true;\n+    case Deoptimization::Unpack_exception:\n+      assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+    default:\n+      break;\n+    }\n+  }\n+  if (raw_bci() == SynchronizationEntryBCI) {\n+    return true;\n+  }\n+  bool reexec = should_reexecute();\n+  assert(is_top_frame || reexec == false, \"unexepected should_reexecute()\");\n+#ifdef ASSERT\n+  if (!reexec) {\n+    address bcp = method()->bcp_from(bci());\n+    Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+    assert(!Interpreter::bytecode_should_reexecute(code), \"should_reexecute mismatch\");\n+  }\n+#endif\n+  return reexec;\n+}\n@@ -192,3 +223,10 @@\n-  bool use_next_mdp = false; \/\/ true if we should use the mdp associated with the next bci\n-                             \/\/ rather than the one associated with bcp\n-  if (raw_bci() == SynchronizationEntryBCI) {\n+  bool reexecute = should_reexecute(is_top_frame, exec_mode);\n+  if (is_top_frame && exec_mode == Deoptimization::Unpack_exception) {\n+    assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+    bcp = method()->bcp_from(bci());\n+    \/\/ exception is pending\n+    pc = Interpreter::rethrow_exception_entry();\n+    \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n+    \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n+    \/\/ in interpreterRuntime.cpp.\n+  } else if (raw_bci() == SynchronizationEntryBCI) {\n@@ -198,1 +236,2 @@\n-  } else if (should_reexecute()) { \/\/reexecute this bytecode\n+    assert(reexecute, \"must be\");\n+  } else if (reexecute) { \/\/reexecute this bytecode\n@@ -201,1 +240,10 @@\n-    pc  = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      \/\/ Do not special-case _athrow or _return_register_finalizer\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      break;\n+    default:\n+      \/\/ Yes, special-case _athrow and _return_register_finalizer\n+      pc = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    }\n@@ -204,0 +252,1 @@\n+    assert(!reexecute, \"must be\");\n@@ -205,1 +254,0 @@\n-    use_next_mdp = true;\n@@ -242,1 +290,10 @@\n-        use_next_mdp = false;\n+#ifdef ASSERT\n+        Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+        assert(Bytecodes::is_invoke(code), \"must be\");\n+        assert(!reexecute, \"must be\");\n+#endif\n+        \/\/ It would be nice if the VerifyStack logic in unpack_frames() was refactored so\n+        \/\/ we could check the stack before and after changing the reexecute mode, but\n+        \/\/ it should pass either way because an invoke uses the same stack state for both modes,\n+        \/\/ which is: args popped but result not yet pushed.\n+        reexecute = true;\n@@ -248,6 +305,5 @@\n-    } else if (!realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr &&\n-               state->is_earlyret_pending()) {\n-      \/\/ Force early return from top frame after deoptimization\n-      pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n-    } else {\n-      if (realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+    } else if (JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+      if (!realloc_failure_exception) {\n+        \/\/ Force early return from top frame after deoptimization\n+        pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n+      } else {\n@@ -258,21 +314,0 @@\n-      \/\/ Possibly override the previous pc computation of the top (youngest) frame\n-      switch (exec_mode) {\n-      case Deoptimization::Unpack_deopt:\n-        \/\/ use what we've got\n-        break;\n-      case Deoptimization::Unpack_exception:\n-        \/\/ exception is pending\n-        pc = SharedRuntime::raw_exception_handler_for_return_address(thread, pc);\n-        \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n-        \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n-        \/\/ in interpreterRuntime.cpp.\n-        break;\n-      case Deoptimization::Unpack_uncommon_trap:\n-      case Deoptimization::Unpack_reexecute:\n-        \/\/ redo last byte code\n-        pc  = Interpreter::deopt_entry(vtos, 0);\n-        use_next_mdp = false;\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n@@ -280,0 +315,1 @@\n+    _reexecute = reexecute;\n@@ -320,3 +356,0 @@\n-  if (ProfileInterpreter) {\n-    iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n-  }\n@@ -326,1 +359,1 @@\n-    if (mdo != nullptr) {\n+    if (mdo != nullptr && exec_mode != Deoptimization::Unpack_exception) {\n@@ -328,1 +361,1 @@\n-      if (use_next_mdp) ++bci;\n+      if (!reexecute) ++bci;\n@@ -331,0 +364,2 @@\n+    } else {\n+      iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":76,"deletions":41,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+#if INCLUDE_JVMCI\n+    bool _rethrow;                                               \/\/ from ScopeDesc::rethrow_exception()\n+#endif\n@@ -74,0 +77,1 @@\n+  bool should_reexecute(bool is_top_frame, int exec_mode) const;\n@@ -75,0 +79,3 @@\n+#if INCLUDE_JVMCI\n+  bool rethrow_exception(void) const  { return _rethrow; }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,6 +98,0 @@\n-\n-  void  clear()                 { _len = 0; }\n-  void  trunc_to(int length)    {\n-    assert(length <= _len,\"cannot increase length\");\n-    _len = length;\n-  }\n@@ -195,5 +189,0 @@\n-  E pop() {\n-    assert(_len > 0, \"empty list\");\n-    return _data[--_len];\n-  }\n-\n@@ -253,53 +242,0 @@\n-  \/\/ Order preserving remove operations.\n-\n-  void remove(const E& elem) {\n-    \/\/ Assuming that element does exist.\n-    bool removed = remove_if_existing(elem);\n-    if (removed) return;\n-    ShouldNotReachHere();\n-  }\n-\n-  bool remove_if_existing(const E& elem) {\n-    \/\/ Returns TRUE if elem is removed.\n-    for (int i = 0; i < _len; i++) {\n-      if (_data[i] == elem) {\n-        remove_at(i);\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  void remove_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    for (int j = index + 1; j < _len; j++) {\n-      _data[j-1] = _data[j];\n-    }\n-    _len--;\n-  }\n-\n-  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n-  void remove_till(int idx) {\n-    remove_range(0, idx);\n-  }\n-\n-  \/\/ Remove all elements in the range [start - end). The order is preserved.\n-  void remove_range(int start, int end) {\n-    assert(0 <= start, \"illegal start index %d\", start);\n-    assert(start < end && end <= _len, \"erase called with invalid range (%d, %d) for length %d\", start, end, _len);\n-\n-    for (int i = start, j = end; j < length(); i++, j++) {\n-      at_put(i, at(j));\n-    }\n-    trunc_to(length() - (end - start));\n-  }\n-\n-  \/\/ The order is changed.\n-  void delete_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    if (index < --_len) {\n-      \/\/ Replace removed element with last one.\n-      _data[index] = _data[_len];\n-    }\n-  }\n-\n@@ -433,0 +369,5 @@\n+  E pop() {\n+    assert(this->_len > 0, \"empty list\");\n+    return this->_data[--this->_len];\n+  }\n+\n@@ -526,0 +467,61 @@\n+  void trunc_to(int length) {\n+    assert(length <= this->_len,\"cannot increase length\");\n+    this->_len = length;\n+  }\n+\n+  \/\/ Order preserving remove operations.\n+\n+  void remove_at(int index) {\n+    assert(0 <= index && index < this->_len,\n+           \"illegal index %d for length %d\", index, this->_len);\n+    for (int j = index + 1; j < this->_len; j++) {\n+      this->_data[j-1] = this->_data[j];\n+    }\n+    this->_len--;\n+  }\n+\n+  void remove(const E& elem) {\n+    \/\/ Assuming that element does exist.\n+    bool removed = this->remove_if_existing(elem);\n+    if (removed) return;\n+    ShouldNotReachHere();\n+  }\n+\n+  bool remove_if_existing(const E& elem) {\n+    \/\/ Returns TRUE if elem is removed.\n+    for (int i = 0; i < this->_len; i++) {\n+      if (this->_data[i] == elem) {\n+        this->remove_at(i);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n+  void remove_till(int idx) {\n+    remove_range(0, idx);\n+  }\n+\n+  \/\/ Remove all elements in the range [start - end). The order is preserved.\n+  void remove_range(int start, int end) {\n+    assert(0 <= start, \"illegal start index %d\", start);\n+    assert(start < end && end <= this->_len,\n+           \"erase called with invalid range (%d, %d) for length %d\",\n+           start, end, this->_len);\n+\n+    for (int i = start, j = end; j < this->length(); i++, j++) {\n+      this->at_put(i, this->at(j));\n+    }\n+    this->_len -= (end - start);\n+  }\n+\n+  \/\/ Replaces the designated element with the last element and shrinks by 1.\n+  void delete_at(int index) {\n+    assert(0 <= index && index < this->_len, \"illegal index %d for length %d\", index, this->_len);\n+    if (index < --this->_len) {\n+      \/\/ Replace removed element with last one.\n+      this->_data[index] = this->_data[this->_len];\n+    }\n+  }\n+\n@@ -529,0 +531,1 @@\n+  void clear() { this->_len = 0; }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":67,"deletions":64,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-volatile intptr_t VMError::_handshake_timed_out_thread = p2i(nullptr);\n-volatile intptr_t VMError::_safepoint_timed_out_thread = p2i(nullptr);\n+Thread* volatile VMError::_handshake_timed_out_thread = nullptr;\n+Thread* volatile VMError::_safepoint_timed_out_thread = nullptr;\n@@ -824,4 +824,4 @@\n-        if (_handshake_timed_out_thread == p2i(_thread)) {\n-          st->print(\" (sent by handshake timeout handler\");\n-        } else if (_safepoint_timed_out_thread == p2i(_thread)) {\n-          st->print(\" (sent by safepoint timeout handler\");\n+        if (get_handshake_timed_out_thread() == _thread) {\n+          st->print(\" (sent by handshake timeout handler)\");\n+        } else if (get_safepoint_timed_out_thread() == _thread) {\n+          st->print(\" (sent by safepoint timeout handler)\");\n@@ -1341,2 +1341,4 @@\n-void VMError::set_handshake_timed_out_thread(intptr_t thread_addr) {\n-  _handshake_timed_out_thread = thread_addr;\n+void VMError::set_handshake_timed_out_thread(Thread* thread) {\n+  \/\/ Only preserve the first thread to time-out this way. The atomic operation ensures\n+  \/\/ visibility to the target thread.\n+  Atomic::replace_if_null(&_handshake_timed_out_thread, thread);\n@@ -1345,2 +1347,12 @@\n-void VMError::set_safepoint_timed_out_thread(intptr_t thread_addr) {\n-  _safepoint_timed_out_thread = thread_addr;\n+void VMError::set_safepoint_timed_out_thread(Thread* thread) {\n+  \/\/ Only preserve the first thread to time-out this way. The atomic operation ensures\n+  \/\/ visibility to the target thread.\n+  Atomic::replace_if_null(&_safepoint_timed_out_thread, thread);\n+}\n+\n+Thread* VMError::get_handshake_timed_out_thread() {\n+  return Atomic::load(&_handshake_timed_out_thread);\n+}\n+\n+Thread* VMError::get_safepoint_timed_out_thread() {\n+  return Atomic::load(&_safepoint_timed_out_thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -146,2 +146,2 @@\n-  static volatile intptr_t _handshake_timed_out_thread;\n-  static volatile intptr_t _safepoint_timed_out_thread;\n+  static Thread* volatile _handshake_timed_out_thread;\n+  static Thread* volatile _safepoint_timed_out_thread;\n@@ -226,2 +226,4 @@\n-  static void set_handshake_timed_out_thread(intptr_t thread_addr);\n-  static void set_safepoint_timed_out_thread(intptr_t thread_addr);\n+  static void set_handshake_timed_out_thread(Thread* thread);\n+  static void set_safepoint_timed_out_thread(Thread* thread);\n+  static Thread* get_handshake_timed_out_thread();\n+  static Thread* get_safepoint_timed_out_thread();\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-                str = JLA.uncheckedNewStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n+                str = JLA.uncheckedNewStringWithLatin1Bytes(bytearr);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -693,5 +693,2 @@\n-     *\n-     * @param  noShare\n-     *         {@code true} if the resulting string MUST NOT share the byte array,\n-     *         {@code false} if the byte array can be exclusively used to construct\n-     *         the string and is not modified or used for any other purpose.\n+     * The byte array can be exclusively used to construct\n+     * the string and is not modified or used for any other purpose.\n@@ -699,1 +696,1 @@\n-    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n+    private static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n@@ -710,1 +707,1 @@\n-                if (noShare || length != bytes.length) {\n+                if (length != bytes.length) {\n@@ -762,0 +759,28 @@\n+    \/**\n+     * {@return a new String created using the supplied latin1 bytes}\n+     * @param src a byte array with the bytes for a latin1 string\n+     *\/\n+    static String newStringWithLatin1Bytes(byte[] src) {\n+        int len = src.length;\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        if (COMPACT_STRINGS)\n+            return new String(src, LATIN1);\n+        return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+    }\n+\n+    \/**\n+     * {@return a new {@code String} created using the given byte array that is\n+     * encoded in specified charset}\n+     * <p>\n+     * <b>WARNING: The caller of this method is assumed to have relinquished\n+     * and transferred the ownership of the byte array<\/b>. It can thus be\n+     * exclusively used to construct the {@code String}.\n+     *\n+     * @param src byte array containing encoded characters\n+     * @param cs charset the byte array encoded in\n+     *\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n+     *\/\n@@ -781,1 +806,1 @@\n-            return newStringUTF8NoRepl(src, 0, src.length, false);\n+            return newStringUTF8NoRepl(src, 0, src.length);\n@@ -1022,1 +1047,1 @@\n-            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            int ret = StringCoding.encodeISOArray(val, sp, dst, dp, len);\n@@ -1287,1 +1312,2 @@\n-        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n+        int positives = StringCoding.countPositives(val, 0, val.length);\n+        if (positives == val.length) {\n@@ -1291,1 +1317,0 @@\n-        int dp = 0;\n@@ -1293,1 +1318,6 @@\n-        for (byte c : val) {\n+        if (positives > 0) {\n+            System.arraycopy(val, 0, dst, 0, positives);\n+        }\n+        int dp = positives;\n+        for (int i = dp; i < val.length; i++) {\n+            byte c = val[i];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -31,0 +32,2 @@\n+import java.util.function.BiFunction;\n+\n@@ -41,1 +44,1 @@\n-    public static int countNonZeroAscii(String s) {\n+    static int countNonZeroAscii(String s) {\n@@ -53,1 +56,1 @@\n-    public static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n+    private static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n@@ -66,1 +69,1 @@\n-    public static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n+    private static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n@@ -77,1 +80,1 @@\n-    public static boolean hasNegatives(byte[] ba, int off, int len) {\n+    static boolean hasNegatives(byte[] ba, int off, int len) {\n@@ -88,0 +91,7 @@\n+     *\n+     * @param ba a byte array\n+     * @param off the index of the first byte to start reading from\n+     * @param len the total number of bytes to read\n+     * @throws NullPointerException if {@code ba} is null\n+     * @throws ArrayIndexOutOfBoundsException if the provided sub-range is\n+     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -89,0 +99,8 @@\n+    static int countPositives(byte[] ba, int off, int len) {\n+        Preconditions.checkFromIndexSize(\n+                off, len,\n+                ba.length,      \/\/ Implicit null check on `ba`\n+                Preconditions.AIOOBE_FORMATTER);\n+        return countPositives0(ba, off, len);\n+    }\n+\n@@ -90,1 +108,1 @@\n-    public static int countPositives(byte[] ba, int off, int len) {\n+    private static int countPositives0(byte[] ba, int off, int len) {\n@@ -100,0 +118,28 @@\n+    \/**\n+     * Encodes as many ISO-8859-1 codepoints as possible from the source byte\n+     * array containing characters encoded in UTF-16, into the destination byte\n+     * array, assuming that the encoding is ISO-8859-1 compatible.\n+     *\n+     * @param sa the source byte array containing characters encoded in UTF-16\n+     * @param sp the index of the <em>character (not byte!)<\/em> from the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of <em>characters (not bytes!)<\/em> to be encoded\n+     * @return the total number of <em>characters (not bytes!)<\/em> successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeISOArray(byte[] sa, int sp,\n+                              byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        int sl;\n+        if ((sp | dp | len) < 0 ||\n+                \/\/ Halving the length of `sa` to obtain the number of characters:\n+                sp >= (sl = sa.length >>> 1) ||     \/\/ Implicit null check on `sa`\n+                dp >= da.length) {                  \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sl - sp, da.length - dp));\n+        return encodeISOArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -101,2 +147,2 @@\n-    public static int implEncodeISOArray(byte[] sa, int sp,\n-                                         byte[] da, int dp, int len) {\n+    private static int encodeISOArray0(byte[] sa, int sp,\n+                                       byte[] da, int dp, int len) {\n@@ -113,0 +159,26 @@\n+    \/**\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n+     *\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeAsciiArray(char[] sa, int sp,\n+                                byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        if ((sp | dp | len) < 0 ||\n+                sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                dp >= da.length) {      \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+        return encodeAsciiArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -114,3 +186,2 @@\n-    public static int implEncodeAsciiArray(char[] sa, int sp,\n-                                           byte[] da, int dp, int len)\n-    {\n+    static int encodeAsciiArray0(char[] sa, int sp,\n+                                 byte[] da, int dp, int len) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":82,"deletions":11,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -2146,0 +2145,5 @@\n+\n+            public String uncheckedNewStringWithLatin1Bytes(byte[] bytes) {\n+                return String.newStringWithLatin1Bytes(bytes);\n+            }\n+\n@@ -2159,4 +2163,0 @@\n-            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8NoRepl(bytes, off, len, true);\n-            }\n-\n@@ -2175,2 +2175,2 @@\n-            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n-                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n+                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -178,0 +178,5 @@\n+     * <p>\n+     * The location where a block of code merges back to its parent block, as\n+     * represented by the {@link #breakLabel()}, is expected to be reachable,\n+     * either from this block or the parent block.  The built code may be\n+     * malformed if there is no executable code at that location.\n@@ -328,0 +333,5 @@\n+     * <p>\n+     * The order of catch blocks is significant.  When an exception is thrown\n+     * by the try block, the first catch block whose exception type is {@linkplain\n+     * Class#isAssignableFrom(Class) the same class as or a superclass of} the\n+     * class of exception thrown is branched to (JVMS {@jvms 2.10}).\n@@ -346,0 +356,4 @@\n+         * @apiNote\n+         * If the type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -350,3 +364,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         an exception of the given type or {@code exceptionType}\n-         *         represents a primitive type\n+         * @throws IllegalArgumentException if {@code exceptionType} represents\n+         *         a primitive type\n@@ -370,0 +383,4 @@\n+         * @apiNote\n+         * If every type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -374,2 +391,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         one or more exceptions of the given types\n+         * @throws IllegalArgumentException if any exception type represents a\n+         *         primitive type\n@@ -390,0 +407,4 @@\n+         * @apiNote\n+         * Since this block intercepts all exceptions, all subsequent catch\n+         * blocks will never be executed.\n+         *\n@@ -392,2 +413,0 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         all exceptions\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -42,2 +42,4 @@\n- * table entries.  Delivered as a {@link CodeElement} when traversing the\n- * contents of a {@link CodeModel}.\n+ * table entries.  The order of exception table entries is significant: when an\n+ * exception is thrown in a method, execution branches to the first matching\n+ * exception handler if such a handler exists (JVMS {@jvms 2.10}). Delivered as\n+ * a {@link CodeElement} when traversing the contents of a {@link CodeModel}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ExceptionCatch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n-import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n- * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n- * adaptation on another {@link MethodHandle}.\n- *\/\n-final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n-        implements MethodHandleDesc {\n-\n-    private final MethodHandleDesc underlying;\n-    private final MethodTypeDesc type;\n-\n-    AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n-        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n-              ConstantDescs.MHD_METHODHANDLE_ASTYPE, underlying, type);\n-        this.underlying = requireNonNull(underlying);\n-        this.type = requireNonNull(type);\n-    }\n-\n-    @Override\n-    public MethodTypeDesc invocationType() {\n-        return type;\n-    }\n-\n-    @Override\n-    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n-        MethodType methodType = type.resolveConstantDesc(lookup);\n-        return handle.asType(methodType);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/AsTypeMethodHandleDesc.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -47,1 +47,0 @@\n-import static java.lang.constant.DirectMethodHandleDesc.*;\n@@ -341,3 +340,0 @@\n-    static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n-            = MethodHandleDesc.ofMethod(Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n-                                        MethodTypeDesc.of(CD_MethodHandle, CD_MethodType));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.constant.AsTypeMethodHandleDesc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -4152,5 +4150,1 @@\n-            try {\n-                return JLA.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-            } catch (CharacterCodingException cce) {\n-                throw new AssertionError(cce);\n-            }\n+            return JLA.uncheckedNewStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -43,0 +44,1 @@\n+import java.util.Objects;\n@@ -47,0 +49,1 @@\n+import java.util.function.Supplier;\n@@ -384,11 +387,1 @@\n-    private static class ThreadTrackHolder {\n-        static final ThreadTracker TRACKER = new ThreadTracker();\n-    }\n-\n-    private static Object tryBeginLookup() {\n-        return ThreadTrackHolder.TRACKER.tryBegin();\n-    }\n-\n-    private static void endLookup(Object key) {\n-        ThreadTrackHolder.TRACKER.end(key);\n-    }\n+    private static final ScopedValue<Boolean> IN_LOOKUP = ScopedValue.newInstance();\n@@ -409,2 +402,1 @@\n-        Object key = tryBeginLookup();\n-        if (key == null) {\n+        if (IN_LOOKUP.isBound()) {\n@@ -415,9 +407,17 @@\n-            for (Iterator<CharsetProvider> i = providers(); i.hasNext();) {\n-                CharsetProvider cp = i.next();\n-                Charset cs = cp.charsetForName(charsetName);\n-                if (cs != null)\n-                    return cs;\n-            }\n-            return null;\n-        } finally {\n-            endLookup(key);\n+            return ScopedValue.where(IN_LOOKUP, true).call(\n+                    new ScopedValue.CallableOp<Charset, Exception>() {\n+                        @Override\n+                        public Charset call() {\n+                            for (Iterator<CharsetProvider> i = providers(); i.hasNext(); ) {\n+                                CharsetProvider cp = i.next();\n+                                Charset cs = cp.charsetForName(charsetName);\n+                                if (cs != null)\n+                                    return cs;\n+                            }\n+                            return null;\n+                        }\n+                    }\n+            );\n+        } catch (Exception t) {\n+            \/\/ Should not happen\n+            throw new RuntimeException(t);\n@@ -425,0 +425,1 @@\n+\n@@ -428,7 +429,7 @@\n-    private static class ExtendedProviderHolder {\n-        static final CharsetProvider[] extendedProviders = extendedProviders();\n-        \/\/ returns ExtendedProvider, if installed\n-        private static CharsetProvider[] extendedProviders() {\n-            CharsetProvider[] cps = new CharsetProvider[1];\n-            int n = 0;\n-            ServiceLoader<CharsetProvider> sl =\n+    private static final Supplier<List<CharsetProvider>> EXTENDED_PROVIDERS = StableValue.supplier(\n+            new Supplier<>() { public List<CharsetProvider> get() { return extendedProviders0(); }});\n+\n+    private static List<CharsetProvider> extendedProviders0() {\n+        CharsetProvider[] cps = new CharsetProvider[1];\n+        int n = 0;\n+        final ServiceLoader<CharsetProvider> sl =\n@@ -436,5 +437,3 @@\n-            for (CharsetProvider cp : sl) {\n-                if (n + 1 > cps.length) {\n-                    cps = Arrays.copyOf(cps, cps.length << 1);\n-                }\n-                cps[n++] = cp;\n+        for (CharsetProvider cp : sl) {\n+            if (n + 1 > cps.length) {\n+                cps = Arrays.copyOf(cps, cps.length << 1);\n@@ -442,1 +441,1 @@\n-            return n == cps.length ? cps : Arrays.copyOf(cps, n);\n+            cps[n++] = cp;\n@@ -444,0 +443,1 @@\n+        return List.of(n == cps.length ? cps : Arrays.copyOf(cps, n));\n@@ -449,2 +449,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider cp : ecps) {\n+        for (CharsetProvider cp : EXTENDED_PROVIDERS.get()) {\n@@ -611,2 +610,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider ecp :ecps) {\n+        for (CharsetProvider ecp : EXTENDED_PROVIDERS.get()) {\n@@ -622,1 +620,10 @@\n-    private @Stable static Charset defaultCharset;\n+    private static final Supplier<Charset> defaultCharset = StableValue.supplier(\n+            new Supplier<>() { public Charset get() { return defaultCharset0(); }});\n+\n+    private static Charset defaultCharset0() {\n+        \/\/ do not look for providers other than the standard one\n+        final Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n+        return (cs == null)\n+                ? sun.nio.cs.UTF_8.INSTANCE\n+                : cs;\n+    }\n@@ -643,11 +650,1 @@\n-        if (defaultCharset == null) {\n-            synchronized (Charset.class) {\n-                \/\/ do not look for providers other than the standard one\n-                Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n-                if (cs != null)\n-                    defaultCharset = cs;\n-                else\n-                    defaultCharset = sun.nio.cs.UTF_8.INSTANCE;\n-            }\n-        }\n-        return defaultCharset;\n+        return defaultCharset.get();\n@@ -659,3 +656,7 @@\n-    private final String name;          \/\/ tickles a bug in oldjavac\n-    private final String[] aliases;     \/\/ tickles a bug in oldjavac\n-    private Set<String> aliasSet;\n+    @Stable\n+    private final String name;\n+    @Stable\n+    private final String[] aliases;\n+    @Stable\n+    private final Supplier<Set<String>> aliasSet = StableValue.supplier(\n+            new Supplier<>() { public Set<String> get() { return Set.of(aliases); }});\n@@ -713,6 +714,1 @@\n-        Set<String> set = this.aliasSet;\n-        if (set == null) {\n-            set = Set.of(aliases);\n-            this.aliasSet = set;\n-        }\n-        return set;\n+        return aliasSet.get();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset.java","additions":56,"deletions":60,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -655,8 +655,1 @@\n-        \/* Detecting whether a double is negative is easy with the exception of\n-         * the value -0.0.  This is a double which has a zero mantissa (and\n-         * exponent), but a negative sign bit.  It is semantically distinct from\n-         * a zero with a positive sign bit, and this distinction is important\n-         * to certain kinds of computations.  However, it's a little tricky to\n-         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0).  How then, you may\n-         * ask, does it behave distinctly from +0.0?  Well, 1\/(-0.0) ==\n-         * -Infinity.  Proper detection of -0.0 is needed to deal with the\n+        \/* Proper detection of -0.0 is needed to deal with the\n@@ -665,1 +658,1 @@\n-        boolean isNegative = ((number < 0.0) || (number == 0.0 && 1\/number < 0.0)) ^ (multiplier < 0);\n+        boolean isNegative = Double.doubleToRawLongBits(number) < 0 ^ multiplier < 0;\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,3 +62,6 @@\n- * <p>If the locale contains \"rg\" (region override)\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n- * the symbols are overridden for the designated region.\n+ * <p>The \"rg\" (region override), \"nu\" (numbering system), and \"cu\" (currency)\n+ * {@code Locale} <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode\n+ * extensions<\/a> are supported which may override values within the symbols.\n+ * For both \"nu\" and \"cu\", if they are specified in addition to \"rg\" by the\n+ * backing {@code Locale}, the respective values from the \"nu\" and \"cu\" extension\n+ * supersede the implicit ones from the \"rg\" extension.\n@@ -91,1 +94,1 @@\n-        initialize( Locale.getDefault(Locale.Category.FORMAT) );\n+        initialize(Locale.getDefault(Locale.Category.FORMAT));\n@@ -114,2 +117,2 @@\n-    public DecimalFormatSymbols( Locale locale ) {\n-        initialize( locale );\n+    public DecimalFormatSymbols(Locale locale) {\n+        initialize(locale);\n@@ -815,1 +818,1 @@\n-    private void initialize( Locale locale ) {\n+    private void initialize(Locale locale) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *\n+ * <p>\n@@ -59,1 +59,1 @@\n- *\n+ * <p>\n@@ -85,1 +85,1 @@\n-     *\n+     * <p>\n@@ -91,1 +91,1 @@\n-     *\n+     * <p>\n@@ -95,1 +95,1 @@\n-     *\n+     * <p>\n@@ -100,1 +100,1 @@\n-     *\n+     * <p>\n@@ -169,1 +169,1 @@\n-    public final double getDouble() {\n+    public double getDouble() {\n@@ -181,1 +181,1 @@\n-    public final long getLong() {\n+    public long getLong() {\n@@ -211,1 +211,1 @@\n-    public final BigDecimal getBigDecimal() {\n+    public BigDecimal getBigDecimal() {\n@@ -283,1 +283,1 @@\n-    final void set(boolean isNegative, double source, int maximumFractionDigits) {\n+    void set(boolean isNegative, double source, int maximumFractionDigits) {\n@@ -287,0 +287,16 @@\n+    \/*\n+     * This compatibility option will only be available for a *very* limited\n+     * number of releases.\n+     * It restores the original behavior to help migrating to the new one,\n+     * and is used by adding\n+     *      -Djdk.compat.DecimalFormat=true\n+     * to the launcher's command line.\n+     *\n+     * The new behavior differs from the old one only in very rare cases,\n+     * so migration should be painless.\n+     *\n+     * When this option is removed, the old behavior, including relevant\n+     * fields and methods, will be removed as well.\n+     *\/\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n@@ -298,3 +314,3 @@\n-    final void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n-\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter  = FloatingDecimal.getBinaryToASCIIConverter(source);\n+    void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n+        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n+                FloatingDecimal.getBinaryToASCIIConverter(source, COMPAT);\n@@ -418,1 +434,1 @@\n-    private final void round(int maximumDigits,\n+    private void round(int maximumDigits,\n@@ -585,1 +601,1 @@\n-    final void set(boolean isNegative, long source) {\n+    void set(boolean isNegative, long source) {\n@@ -598,1 +614,1 @@\n-    final void set(boolean isNegative, long source, int maximumDigits) {\n+    void set(boolean isNegative, long source, int maximumDigits) {\n@@ -648,1 +664,1 @@\n-    final void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n+    void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n@@ -665,1 +681,1 @@\n-    final void set(boolean isNegative, BigInteger source, int maximumDigits) {\n+    void set(boolean isNegative, BigInteger source, int maximumDigits) {\n@@ -775,1 +791,1 @@\n-    private final char[] getDataChars(int length) {\n+    private char[] getDataChars(int length) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -106,0 +106,3 @@\n+ * <li> \"cu\"\n+ * (<a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35.html#UnicodeCurrencyIdentifier\">\n+ * Currency Type<\/a>) - Overrides the Currency used\n@@ -108,2 +111,2 @@\n- * If both \"nu\" and \"rg\" are specified, the decimal digits from the \"nu\"\n- * extension supersedes the implicit one from the \"rg\" extension.\n+ * For both \"nu\" and \"cu\", if they are specified in addition to \"rg\", the respective\n+ * values from the \"nu\" and \"cu\" extension supersede the implicit ones from the \"rg\" extension.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -463,6 +461,1 @@\n-        try {\n-            \/\/ Return a new string using the bytes without making a copy\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -698,5 +691,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -734,5 +723,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -762,5 +747,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -798,5 +779,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -826,5 +803,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":6,"deletions":33,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -482,5 +480,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -703,1 +703,1 @@\n-         *     var joiner = Joiner.all(new CancelAfterTwoFailures<String>());\n+         *     var joiner = Joiner.allUntil(new CancelAfterTwoFailures<String>());\n@@ -708,1 +708,1 @@\n-         * except that it yields a stream of the completed subtasks.\n+         * except that it yields a list of the completed subtasks.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -255,1 +256,7 @@\n-            return JLA.newStringUTF8NoRepl(ba, off, length);\n+            try {\n+                \/\/ Copy subrange for exclusive use by the string being created\n+                byte[] bytes = Arrays.copyOfRange(ba, off, off + length);\n+                return JLA.uncheckedNewStringNoRepl(bytes, StandardCharsets.UTF_8);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -276,1 +283,1 @@\n-                return hash(JLA.newStringUTF8NoRepl(a, off, len));\n+                return hash(toString(a, off, len));\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.function.BiFunction;\n@@ -321,0 +322,12 @@\n+    \/**\n+     * Constructs a new {@code String} with the supplied Latin1 bytes.\n+     * <p>\n+     * <b>WARNING: The caller of this method shall relinquish and transfer the\n+     * ownership of the byte array to the callee<\/b>, since the latter will not\n+     * make a copy.\n+     *\n+     * @param bytes the byte array source\n+     * @return the newly created string\n+     *\/\n+    String uncheckedNewStringWithLatin1Bytes(byte[] bytes);\n+\n@@ -354,10 +367,0 @@\n-    \/**\n-     * Returns a new string by decoding from the given UTF-8 bytes array.\n-     *\n-     * @param off the index of the first byte to decode\n-     * @param len the number of bytes to decode\n-     * @return the newly created string\n-     * @throws IllegalArgumentException for malformed or unmappable bytes.\n-     *\/\n-    String newStringUTF8NoRepl(byte[] bytes, int off, int len);\n-\n@@ -426,5 +429,3 @@\n-     * Encodes as many ASCII codepoints as possible from the source array into\n-     * the destination byte array, assuming that the encoding is ASCII\n-     * compatible.\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n@@ -432,3 +433,9 @@\n-     * @return the number of bytes successfully encoded, or 0 if none\n-     *\/\n-    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -31,1 +32,1 @@\n-import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n@@ -42,1 +43,0 @@\n-    final Set<ConstantDesc> catchTypes;\n@@ -49,1 +49,0 @@\n-        this.catchTypes = new HashSet<>();\n@@ -62,3 +61,8 @@\n-        if (catchBlock == null) {\n-            if (tryBlock.reachable()) {\n-                b.branch(Opcode.GOTO, tryCatchEnd);\n+        \/\/ nullable list of CP entries - null means catching all (0)\n+        List<ClassEntry> entries = new ArrayList<>(Math.max(1, exceptionTypes.size()));\n+        if (exceptionTypes.isEmpty()) {\n+            entries.add(null);\n+        } else {\n+            for (var exceptionType : exceptionTypes) {\n+                var entry = b.constantPool().classEntry(exceptionType); \/\/ throws IAE\n+                entries.add(entry);\n@@ -67,0 +71,1 @@\n+        \/\/ End validation\n@@ -68,3 +73,3 @@\n-        for (var exceptionType : exceptionTypes) {\n-            if (!catchTypes.add(exceptionType)) {\n-                throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+        if (catchBlock == null) {\n+            if (tryBlock.reachable()) {\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n@@ -85,7 +90,3 @@\n-        if (exceptionTypes.isEmpty()) {\n-            catchBlock.exceptionCatchAll(tryStart, tryEnd, catchBlock.startLabel());\n-        }\n-        else {\n-            for (var exceptionType : exceptionTypes) {\n-                catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), exceptionType);\n-            }\n+        for (var entry : entries) {\n+            \/\/ This accepts null for catching all\n+            catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n+import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n+ * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n+ * adaptation on another {@link MethodHandle}.\n+ *\/\n+public final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n+        implements MethodHandleDesc {\n+\n+    private static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n+            = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n+                                        MethodTypeDesc.of(CD_MethodHandle, ConstantDescs.CD_MethodType));\n+\n+    private final MethodHandleDesc underlying;\n+    private final MethodTypeDesc type;\n+\n+    public AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n+        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n+              MHD_METHODHANDLE_ASTYPE, underlying, type);\n+        this.underlying = requireNonNull(underlying);\n+        this.type = requireNonNull(type);\n+    }\n+\n+    @Override\n+    public MethodTypeDesc invocationType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n+        MethodType methodType = type.resolveConstantDesc(lookup);\n+        return handle.asType(methodType);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/AsTypeMethodHandleDesc.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -249,1 +249,1 @@\n-                        return toChars(str, index, f, 0, fd) - start;\n+                        return toChars(str, index, f, 0, fd, true, false) - start;\n@@ -327,0 +327,3 @@\n+             *\n+             * Also,\n+             * d_v = v      iff     4 sp10 = vb\n@@ -333,1 +336,2 @@\n-                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n+                \/* Exactly one of u' or w' lies in Rv *\/\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd, sp10 << 2 == vb, wpin);\n@@ -342,0 +346,3 @@\n+         *\n+         * Also,\n+         * d_v = v      iff     4 s = vb\n@@ -348,1 +355,1 @@\n-            return toChars(str, index, uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd, s << 2 == vb, win);\n@@ -355,1 +362,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk, fd, s << 2 == vb, away);\n@@ -374,1 +382,2 @@\n-    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e,\n+                        FormattedFPDecimal fd, boolean exact, boolean away) {\n@@ -386,1 +395,1 @@\n-            fd.set(f, e, len);\n+            fd.set(f, e, len, exact, away);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+                \/* Exactly one of u' or w' lies in Rv *\/\n@@ -329,1 +330,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1745,1 +1745,2 @@\n-     * @param d The double precision value to convert.\n+     * @param d      The double precision value to convert.\n+     * @param compat    compatibility with releases < JDK 21\n@@ -1748,2 +1749,4 @@\n-    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n-        return getBinaryToASCIIConverter(d, true);\n+    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean compat) {\n+        return compat\n+                ? getCompatBinaryToASCIIConverter(d, true)\n+                : getBinaryToASCIIConverter(d);\n@@ -1752,7 +1755,26 @@\n-    \/**\n-     * Returns a <code>BinaryToASCIIConverter<\/code> for a <code>double<\/code>.\n-     * The returned object is a <code>ThreadLocal<\/code> variable of this class.\n-     *\n-     * @param d The double precision value to convert.\n-     * @param isCompatibleFormat\n-     * @return The converter.\n+    private static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n+        assert Double.isFinite(d);\n+\n+        FormattedFPDecimal dec = FormattedFPDecimal.split(d);\n+        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n+\n+        buf.nDigits = dec.getPrecision();\n+        buf.decExponent = dec.getExp() + buf.nDigits;\n+        buf.firstDigitIndex = 0;\n+        buf.exactDecimalConversion = dec.getExact();\n+        buf.decimalDigitsRoundedUp = dec.getAway();\n+\n+        long f = dec.getSignificand();\n+        char[] digits = buf.digits;\n+        for (int i = buf.nDigits - 1; i >= 0; --i) {\n+            long q = f \/ 10;\n+            digits[i] = (char) ((f - 10 * q) + '0');\n+            f = q;\n+        }\n+        return buf;\n+    }\n+\n+    \/*\n+     * The old implementation of getBinaryToASCIIConverter().\n+     * Should be removed in the future, along with its dependent methods and\n+     * fields (> 550 lines).\n@@ -1760,1 +1782,1 @@\n-    static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n+    private static BinaryToASCIIConverter getCompatBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -50,1 +50,7 @@\n-    private long f;\n+    \/* Whether the decimal exactly represents the double *\/\n+    private boolean exact;\n+    \/*\n+     * When not exact, whether the magnitude of the decimal is larger than\n+     * the magnitude of the double. Aka \"away from zero\".\n+     *\/\n+    private boolean away;\n@@ -53,0 +59,1 @@\n+    private long f;\n@@ -71,1 +78,1 @@\n-    private static FormattedFPDecimal split(double v) {\n+    static FormattedFPDecimal split(double v) {\n@@ -122,1 +129,1 @@\n-        fd.set(s, eNew, prec);\n+        fd.set(s, eNew, prec, fd.exact, fd.away);\n@@ -135,0 +142,8 @@\n+    public boolean getAway() {\n+        return away;\n+    }\n+\n+    public boolean getExact() {\n+        return exact;\n+    }\n+\n@@ -139,1 +154,1 @@\n-    public void set(long f, int e, int n) {\n+    public void set(long f, int e, int n, boolean exact, boolean away) {\n@@ -144,0 +159,2 @@\n+        this.exact = exact;\n+        this.away = away;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFPDecimal.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -427,0 +427,1 @@\n+            Objects.requireNonNull(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-        java.desktop, \/\/ for ScopedValue\n@@ -158,6 +157,1 @@\n-        jdk.incubator.vector, \/\/ participates in preview features\n-        jdk.jartool, \/\/ participates in preview features\n-        jdk.jdeps, \/\/ participates in preview features\n-        jdk.jfr, \/\/ participates in preview features\n-        jdk.jlink,   \/\/ participates in preview features\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.jdeps;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n@@ -554,1 +554,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n@@ -689,1 +689,1 @@\n-                int n = JLA.uncheckedEncodeASCII(src, sp, dst, dp, len);\n+                int n = JLA.encodeASCII(src, sp, dst, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.util.Preconditions;\n@@ -145,1 +144,13 @@\n-        \/\/ Method possible replaced with a compiler intrinsic.\n+        \/**\n+         * Encodes as many ISO-8859-1 codepoints as possible from the source\n+         * character array into the destination byte array, assuming that\n+         * the encoding is ISO-8859-1 compatible.\n+         *\n+         * @param sa the source character array\n+         * @param sp the index of the source array to start reading from\n+         * @param da the target byte array\n+         * @param dp the index of the target array to start writing to\n+         * @param len the maximum number of characters to be encoded\n+         * @return the total number of characters successfully encoded\n+         * @throws NullPointerException if any of the provided arrays is null\n+         *\/\n@@ -148,1 +159,5 @@\n-            if (len <= 0) {\n+            \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+            \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+            if ((sp | dp | len) < 0 ||\n+                    sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                    dp >= da.length) {      \/\/ Implicit null check on `da`\n@@ -151,2 +166,2 @@\n-            encodeISOArrayCheck(sa, sp, da, dp, len);\n-            return implEncodeISOArray(sa, sp, da, dp, len);\n+            int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+            return encodeISOArray0(sa, sp, da, dp, minLen);\n@@ -156,3 +171,1 @@\n-        private static int implEncodeISOArray(char[] sa, int sp,\n-                                              byte[] da, int dp, int len)\n-        {\n+        private static int encodeISOArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n@@ -169,11 +182,0 @@\n-        private static void encodeISOArrayCheck(char[] sa, int sp,\n-                                                byte[] da, int dp, int len) {\n-            Objects.requireNonNull(sa);\n-            Objects.requireNonNull(da);\n-            Preconditions.checkIndex(sp, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp, da.length, Preconditions.AIOOBE_FORMATTER);\n-\n-            Preconditions.checkIndex(sp + len - 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp + len - 1, da.length, Preconditions.AIOOBE_FORMATTER);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, len);\n+                int n = JLA.encodeASCII(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -346,8 +346,0 @@\n-#if defined(_ALLBSD_SOURCE)\n-    my_openat_func = (openat_func*) openat;\n-    my_fstatat_func = (fstatat_func*) fstatat;\n-#else\n-    \/\/ Make sure we link to the 64-bit version of the functions\n-    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"openat64\");\n-    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"fstatat64\");\n-#endif\n@@ -358,0 +350,2 @@\n+    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"open64at\");\n+    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"stat64at\");\n@@ -360,0 +354,2 @@\n+    my_openat_func = (openat_func*) openat;\n+    my_fstatat_func = (fstatat_func*) fstatat;\n@@ -362,0 +358,3 @@\n+    \/\/ Make sure we link to the 64-bit version of the functions\n+    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"openat64\");\n+    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"fstatat64\");\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-    private Cache cache = new Cache();\n-    CFont fFont;\n-    int numGlyphs = -1;\n+    private final Cache rawCache = new Cache(true);\n+    private final Cache modCache = new Cache(false);\n+    private final CFont fFont;\n+    private int numGlyphs = -1;\n@@ -104,1 +105,2 @@\n-        int glyph = cache.get(unicode, raw);\n+        Cache cache = raw ? rawCache : modCache;\n+        int glyph = cache.get(unicode);\n@@ -107,4 +109,8 @@\n-        final char[] unicodeArray = new char[] { unicode };\n-        final int[] glyphArray = new int[1];\n-        nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n-        glyph = glyphArray[0];\n+        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n+            glyph = INVISIBLE_GLYPH_ID;\n+        } else {\n+            final char[] unicodeArray = new char[]{unicode};\n+            final int[] glyphArray = new int[1];\n+            nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n+            glyph = glyphArray[0];\n+        }\n@@ -134,1 +140,2 @@\n-            cache.get(2, surrogates, glyphs, raw);\n+            Cache cache = raw ? rawCache : modCache;\n+            cache.get(2, surrogates, glyphs);\n@@ -143,1 +150,1 @@\n-        cache.get(count, unicodes, glyphs, false);\n+        modCache.get(count, unicodes, glyphs);\n@@ -167,0 +174,1 @@\n+        private final boolean raw;\n@@ -171,1 +179,2 @@\n-        Cache() {\n+        Cache(boolean raw) {\n+            this.raw = raw;\n@@ -176,5 +185,1 @@\n-        public synchronized int get(final int index, final boolean raw) {\n-            if (isIgnorableWhitespace(index) || (isDefaultIgnorable(index) && !raw)) {\n-                return INVISIBLE_GLYPH_ID;\n-            }\n-\n+        public synchronized int get(final int index) {\n@@ -251,1 +256,1 @@\n-        public synchronized void get(int count, char[] indices, int[] values, boolean raw)\n+        public synchronized void get(int count, char[] indices, int[] values)\n@@ -273,1 +278,1 @@\n-                final int value = get(code, raw);\n+                final int value = get(code);\n@@ -280,0 +285,3 @@\n+                } else if (isIgnorableWhitespace(code) || (isDefaultIgnorable(code) && !raw)) {\n+                    values[i] = INVISIBLE_GLYPH_ID;\n+                    put(code, INVISIBLE_GLYPH_ID);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -74,6 +74,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/common\/SubImageInputStream.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,7 +149,0 @@\n-\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n@@ -286,7 +279,0 @@\n-\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageWriter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.imageio.stream;\n-\n-import java.io.IOException;\n-import javax.imageio.stream.ImageInputStream;\n-\n-\/**\n- * Small class to assist in properly closing an ImageInputStream instance\n- * prior to garbage collection.  The ImageInputStreamImpl class defines a\n- * finalize() method, but in a number of its public subclasses\n- * (e.g. FileImageInputStream) we override the finalize() method to be\n- * empty for performance reasons, and instead rely on the Disposer mechanism\n- * for closing\/disposing resources.  This is fine when one of these classes\n- * is instantiated directly (e.g. new FileImageInputStream()) but in the\n- * unlikely case where a user defines their own subclass of one of those\n- * streams, we need some way to get back to the behavior of\n- * ImageInputStreamImpl, which will call close() as part of finalization.\n- *\n- * Typically an Image{Input,Output}Stream will construct an instance of\n- * StreamFinalizer in its constructor if it detects that it has been\n- * subclassed by the user.  The ImageInputStream instance will hold a\n- * reference to the StreamFinalizer, and the StreamFinalizer will hold a\n- * reference back to the ImageInputStream from which it was created.  When\n- * both are no longer reachable, the StreamFinalizer.finalize() method will\n- * be called, which will take care of closing down the ImageInputStream.\n- *\n- * Clearly this is a bit of a hack, but it will likely only be used in the\n- * rarest of circumstances: when a user has subclassed one of the public\n- * stream classes.  (It should be no worse than the old days when the public\n- * stream classes had non-empty finalize() methods.)\n- *\/\n-public class StreamFinalizer {\n-    private ImageInputStream stream;\n-\n-    public StreamFinalizer(ImageInputStream stream) {\n-        this.stream = stream;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        try {\n-            stream.close();\n-        } catch (IOException e) {\n-        } finally {\n-            stream = null;\n-            super.finalize();\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/stream\/StreamFinalizer.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -54,0 +54,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -58,1 +59,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -105,4 +105,3 @@\n-     * Stores some information about {@code ICC_Profile} without causing a\n-     * deferred profile to be loaded. Note that we can defer the loading of\n-     * standard profiles only. If this field is null, then {@link #cmmProfile}\n-     * should be used to access profile information.\n+     * Stores information about a built-in profile without triggering profile\n+     * loading. If this field is null, {@link #cmmProfile} should be used to\n+     * access profile data. If not null, the profile is considered immutable.\n@@ -110,9 +109,1 @@\n-    private transient volatile ProfileDeferralInfo deferralInfo;\n-\n-\n-    \/**\n-     * Set to {@code true} for {@code BuiltInProfile}, {@code false} otherwise.\n-     * This flag is used in {@link #setData(int, byte[])} to prevent modifying\n-     * built-in profiles.\n-     *\/\n-    private final transient boolean builtIn;\n+    private transient final BuiltinProfileInfo builtInInfo;\n@@ -127,1 +118,1 @@\n-         * ProfileDeferralInfo is used for built-in profile creation only,\n+         * BuiltinProfileInfo is used for built-in profile creation only,\n@@ -130,1 +121,1 @@\n-        ICC_Profile SRGB = new ICC_ProfileRGB(new ProfileDeferralInfo(\n+        ICC_Profile SRGB = new ICC_ProfileRGB(new BuiltinProfileInfo(\n@@ -133,1 +124,1 @@\n-        ICC_Profile LRGB = new ICC_ProfileRGB(new ProfileDeferralInfo(\n+        ICC_Profile LRGB = new ICC_ProfileRGB(new BuiltinProfileInfo(\n@@ -136,1 +127,1 @@\n-        ICC_Profile XYZ = new ICC_Profile(new ProfileDeferralInfo(\n+        ICC_Profile XYZ = new ICC_Profile(new BuiltinProfileInfo(\n@@ -139,1 +130,1 @@\n-        ICC_Profile PYCC = new ICC_Profile(new ProfileDeferralInfo(\n+        ICC_Profile PYCC = new ICC_Profile(new BuiltinProfileInfo(\n@@ -142,1 +133,1 @@\n-        ICC_Profile GRAY = new ICC_ProfileGray(new ProfileDeferralInfo(\n+        ICC_Profile GRAY = new ICC_ProfileGray(new BuiltinProfileInfo(\n@@ -774,1 +765,1 @@\n-        builtIn = false;\n+        builtInInfo = null;\n@@ -782,1 +773,1 @@\n-     * Note: {@code ProfileDeferralInfo} is used for built-in profile\n+     * Note: {@code BuiltinProfileInfo} is used for built-in profile\n@@ -785,3 +776,2 @@\n-    ICC_Profile(ProfileDeferralInfo pdi) {\n-        deferralInfo = pdi;\n-        builtIn = true;\n+    ICC_Profile(BuiltinProfileInfo bpi) {\n+        builtInInfo = bpi;\n@@ -937,1 +927,1 @@\n-            var is = getStandardProfileInputStream(deferralInfo.filename);\n+            var is = getStandardProfileInputStream(builtInInfo.filename);\n@@ -945,2 +935,0 @@\n-                    \/\/ from now we cannot use the deferred value, drop it\n-                    deferralInfo = null;\n@@ -978,3 +966,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.profileClass;\n+        if (builtInInfo != null) {\n+            return builtInInfo.profileClass;\n@@ -1015,3 +1002,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.colorSpaceType;\n+        if (builtInInfo != null) {\n+            return builtInInfo.colorSpaceType;\n@@ -1163,2 +1149,2 @@\n-        if (builtIn) {\n-            throw new IllegalArgumentException(\"Built-in profile cannot be modified\");\n+        if (builtInInfo != null) {\n+            throw new IllegalArgumentException(\"Can't modify built-in profile\");\n@@ -1208,3 +1194,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.numComponents;\n+        if (builtInInfo != null) {\n+            return builtInInfo.numComponents;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":24,"deletions":39,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -41,1 +42,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -90,1 +90,1 @@\n-     * {@code ProfileDeferralInfo} object.\n+     * {@code BuiltinProfileInfo} object.\n@@ -92,2 +92,2 @@\n-    ICC_ProfileGray(ProfileDeferralInfo pdi) {\n-        super(pdi);\n+    ICC_ProfileGray(BuiltinProfileInfo bpi) {\n+        super(bpi);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileGray.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -41,1 +42,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -125,3 +125,1 @@\n-     * {@code ProfileDeferralInfo} object.\n-     *\n-     * @param  pdi\n+     * {@code BuiltinProfileInfo} object.\n@@ -129,2 +127,2 @@\n-    ICC_ProfileRGB(ProfileDeferralInfo pdi) {\n-        super(pdi);\n+    ICC_ProfileRGB(BuiltinProfileInfo bpi) {\n+        super(bpi);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileRGB.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2504,2 +2504,1 @@\n-     * result of calling any other method (other than\n-     * {@code finalize}) subsequent to a call to this method\n+     * result of calling any other method subsequent to a call to this method\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/ImageReader.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2003,2 +2003,1 @@\n-     * result of calling any other method (other than\n-     * {@code finalize}) subsequent to a call to this method\n+     * result of calling any other method subsequent to a call to this method\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/ImageWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -61,1 +60,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -112,6 +111,1 @@\n-        if (getClass() == FileCacheImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -261,16 +255,1 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed\/deleted prior to garbage collection\n-    }\n-\n-    private static class StreamDisposerRecord implements DisposerRecord {\n+    static class StreamDisposerRecord implements DisposerRecord {\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileCacheImageInputStream.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import javax.imageio.stream.FileCacheImageInputStream.StreamDisposerRecord;\n@@ -34,0 +35,2 @@\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -49,0 +52,3 @@\n+    private final Object disposerReferent = new Object();\n+\n+    private final StreamDisposerRecord disposerRecord;\n@@ -94,0 +100,7 @@\n+        \/\/ If this instance becomes unreachable the disposer will clean up resources\n+        \/\/ used for caching. This can't flush any un-flushed cache.\n+        this.disposerRecord = new StreamDisposerRecord(cacheFile, cache);\n+        Disposer.addRecord(this.disposerReferent, this.disposerRecord);\n+        \/\/ If the VM is exiting and this instance is still reachable,\n+        \/\/ StreamCloser will call close() to flush the cache and clean up resources.\n+        \/\/ However closing the java.io.OutputStream is the application's responsibility.\n@@ -234,1 +247,1 @@\n-        cache.close();\n+        disposerRecord.dispose();\n@@ -236,1 +249,0 @@\n-        cacheFile.delete();\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileCacheImageOutputStream.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -48,1 +47,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -98,6 +97,1 @@\n-        if (getClass() == FileImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -157,15 +151,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed prior to garbage collection\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageInputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -47,1 +46,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -90,6 +89,1 @@\n-        if (getClass() == FileImageOutputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -165,15 +159,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed prior to garbage collection\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageOutputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -844,25 +844,0 @@\n-\n-    \/**\n-     * Finalizes this object prior to garbage collection.  The\n-     * {@code close} method is called to close any open input\n-     * source.  This method should not be called from application\n-     * code.\n-     *\n-     * @throws Throwable if an error occurs during superclass\n-     * finalization.\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        if (!isClosed) {\n-            try {\n-                close();\n-            } catch (IOException e) {\n-            }\n-        }\n-        super.finalize();\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageInputStreamImpl.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -53,1 +52,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -74,6 +73,1 @@\n-        if (getClass() == MemoryCacheImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -179,15 +173,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ MemoryCache is reset prior to garbage collection\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/MemoryCacheImageInputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -47,1 +47,25 @@\n- *\n+ * <p>\n+ * An {@code ImageInputStream} or {@code ImageOutputStream} may internally allocate\n+ * system resources, such as a temporary cache file.\n+ * Clients are encouraged to use a try-with-resources statement to ensure the\n+ * {@link ImageInputStream#close()} or {@link ImageOutputStream#close()}\n+ * method is called which can promptly free those native resources.\n+ * Otherwise there is the possibility they will leak and eventually cause the\n+ * application to fail as well the possibility that not all data is flushed\n+ * to the underlying output stream. A logical consequence of that is that\n+ * this should be done before closing the destination {@link java.io.OutputStream}.\n+ * A simple pattern would be\n+ * {@snippet lang='java':\n+ * try (FileOutputStream fos = new FileOutputStream(\"out.jpg\");\n+ *      ImageOutputStream ios = new FileCacheImageOutputStream(fos, null)) {\n+ *     ImageIO.write(img, \"jpg\", ios);\n+ * } catch (IOException e) {\n+ * } \/\/ implicit finally block closes the streams in the reverse order to opening\n+ * }\n+ * <p>\n+ * Sub-classers of these Image I\/O API stream types can, to a limited extent, protect\n+ * the application from the consequences of failures to close by adopting mechanisms\n+ * such as {@link java.lang.ref.Cleaner} to free internal resources when it\n+ * is no longer reachable. This is only necessary if there are any resources to release.\n+ * However applications cannot rely on this, either for resource management, or\n+ * for program correctness.\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/package-info.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\/* remember that the API requires a Font use a\n+\/* Remember that the API requires a Font use a\n@@ -39,1 +39,1 @@\n- * to 216*256*4 bytes of storage per composite font. If an app\n+ * to 2*216*256*4 bytes of storage per composite font. If an app\n@@ -41,1 +41,1 @@\n- * over 1Mb of cached data. May need to employ WeakReferences if\n+ * over 2Mb of cached data. May need to employ WeakReferences if\n@@ -57,4 +57,5 @@\n-    CompositeFont font;\n-    CharToGlyphMapper[] slotMappers;\n-    int[][] glyphMaps;\n-    private boolean hasExcludes;\n+    private final CompositeFont font;\n+    private final CharToGlyphMapper[] slotMappers;\n+    private final int[][] glyphMapsRaw;\n+    private final int[][] glyphMapsMod;\n+    private final boolean hasExcludes;\n@@ -64,1 +65,6 @@\n-        initMapper();\n+        glyphMapsRaw = new int[NBLOCKS][];\n+        glyphMapsMod = new int[NBLOCKS][];\n+        slotMappers = new CharToGlyphMapper[font.numSlots];\n+        \/* This requires that slot 0 is never empty. *\/\n+        missingGlyph = font.getSlotFont(0).getMissingGlyphCode();\n+        missingGlyph = compositeGlyphCode(0, missingGlyph);\n@@ -76,13 +82,1 @@\n-    private void initMapper() {\n-        if (missingGlyph == CharToGlyphMapper.UNINITIALIZED_GLYPH) {\n-            if (glyphMaps == null) {\n-                glyphMaps = new int[NBLOCKS][];\n-            }\n-            slotMappers = new CharToGlyphMapper[font.numSlots];\n-            \/* This requires that slot 0 is never empty. *\/\n-            missingGlyph = font.getSlotFont(0).getMissingGlyphCode();\n-            missingGlyph = compositeGlyphCode(0, missingGlyph);\n-        }\n-    }\n-\n-    private int getCachedGlyphCode(int unicode) {\n+    private int getCachedGlyphCode(int unicode, boolean raw) {\n@@ -93,0 +87,1 @@\n+        int[][] glyphMaps = raw ? glyphMapsRaw : glyphMapsMod;\n@@ -99,1 +94,1 @@\n-    private void setCachedGlyphCode(int unicode, int glyphCode) {\n+    private void setCachedGlyphCode(int unicode, int glyphCode, boolean raw) {\n@@ -104,0 +99,1 @@\n+        int[][] glyphMaps = raw ? glyphMapsRaw : glyphMapsMod;\n@@ -123,4 +119,1 @@\n-        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n-            return INVISIBLE_GLYPH_ID;\n-        }\n-        int glyphCode = getCachedGlyphCode(unicode);\n+        int glyphCode = getCachedGlyphCode(unicode, raw);\n@@ -130,0 +123,5 @@\n+        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n+            glyphCode = INVISIBLE_GLYPH_ID;\n+            setCachedGlyphCode(unicode, glyphCode, raw);\n+            return glyphCode;\n+        }\n@@ -136,1 +134,1 @@\n-                    setCachedGlyphCode(unicode, glyphCode);\n+                    setCachedGlyphCode(unicode, glyphCode, raw);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeGlyphMapper.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.cmm;\n+\n+\/**\n+ * Stores information about a built-in profile used by\n+ * ICC_Profile.getInstance(int cspace) to defer the loading of profile data and\n+ * CMM initialization. Since built-in profiles are immutable, this information\n+ * is always valid.\n+ *\/\n+public final class BuiltinProfileInfo {\n+\n+    \/**\n+     * Used by ICC_ColorSpace without triggering built-in profile loading.\n+     *\/\n+    public final int colorSpaceType, numComponents, profileClass;\n+\n+    \/**\n+     * The profile file name, such as \"CIEXYZ.pf\", \"sRGB.pf\", etc.\n+     *\/\n+    public final String filename;\n+\n+    public BuiltinProfileInfo(String fn, int type, int ncomp, int pclass) {\n+        filename = fn;\n+        colorSpaceType = type;\n+        numComponents = ncomp;\n+        profileClass = pclass;\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/BuiltinProfileInfo.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.cmm;\n-\n-\/**\n- * A class to pass information about a profile to be loaded from a file to the\n- * static getInstance(int cspace) method of ICC_Profile. Loading of the profile\n- * data and initialization of the CMM is to be deferred as long as possible.\n- *\/\n-public final class ProfileDeferralInfo {\n-\n-    \/**\n-     * Need to have this info for ICC_ColorSpace without causing a deferred\n-     * profile to be loaded.\n-     *\/\n-    public final int colorSpaceType, numComponents, profileClass;\n-\n-    \/**\n-     * The profile file name, such as \"CIEXYZ.pf\", \"sRGB.pf\", etc.\n-     *\/\n-    public final String filename;\n-\n-    public ProfileDeferralInfo(String fn, int type, int ncomp, int pclass) {\n-        filename = fn;\n-        colorSpaceType = type;\n-        numComponents = ncomp;\n-        profileClass = pclass;\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/ProfileDeferralInfo.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            profiles[i].getNumComponents(); \/\/ force header initialization\n+            profiles[i].getMajorVersion(); \/\/ force header initialization\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2151,6 +2151,2 @@\n-            (Error OPAQUE_FRAME      \"Attempted to return early from a frame \"\n-                                     \"corresponding to a native method, \"\n-                                     \"the thread is a suspended virtual thread and the target \"\n-                                     \"VM is unable to force its current frame to return, \"\n-                                     \"or the implementation is unable to provide this \"\n-                                     \"functionality on this frame.\")\n+            (Error OPAQUE_FRAME      \"Unable to force the current frame to return \"\n+                                     \"(e.g. the current frame is executing a native method).\")\n@@ -2628,0 +2624,2 @@\n+            (Error OPAQUE_FRAME      \"Unable to get the value of local variables in the frame \"\n+                                     \"(e.g. the frame is executing a native method).\")\n@@ -2665,3 +2663,3 @@\n-            (Error OPAQUE_FRAME      \"The thread is a suspended virtual thread and the target VM \"\n-                                     \"does not support setting the value of local \"\n-                                     \"variables in the frame.\")\n+            (Error INVALID_SLOT)\n+            (Error OPAQUE_FRAME      \"Unable to set the value of local variables in the frame \"\n+                                     \"(e.g. the frame is executing a native method).\")\n@@ -2716,4 +2714,3 @@\n-            (Error OPAQUE_FRAME      \"If one or more of the frames to pop is a native \"\n-                                     \"method or its caller is a native method, or the \"\n-                                     \"thread is a suspended virtual thread and the implementation \"\n-                                     \"was unable to pop the frames.\")\n+            (Error OPAQUE_FRAME      \"Unable to pop one or more of the frames \"\n+                                     \"(e.g. one or more of the frames to pop is a native \"\n+                                     \"method or its caller is a native method).\")\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,0 +415,1 @@\n+            compiler.log.reportOutstandingWarnings();\n@@ -486,1 +487,2 @@\n-            if (compiler != null)\n+            if (compiler != null) {\n+                compiler.log.reportOutstandingWarnings();\n@@ -488,0 +490,1 @@\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -271,0 +272,1 @@\n+                LintMapper.instance(this).clear();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,3 +363,8 @@\n-                    Type t = attr.attribType(dcReference.qualifierExpression, env);\n-                    if (t != null && !t.isErroneous()) {\n-                        return t;\n+                    JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+                    try {\n+                        Type t = attr.attribType(dcReference.qualifierExpression, env);\n+                        if (t != null && !t.isErroneous()) {\n+                            return t;\n+                        }\n+                    } finally {\n+                        log.useSource(prevSource);\n@@ -391,0 +396,1 @@\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n@@ -512,0 +518,1 @@\n+            log.useSource(prevSource);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.code;\n-\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.Tag;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n-\n-\/**\n- * Holds pending {@link Lint} warnings until the {@lint Lint} instance associated with the containing\n- * module, package, class, method, or variable declaration is known so that {@link @SupressWarnings}\n- * suppressions may be applied.\n- *\n- * <p>\n- * Warnings are regsistered at any time prior to attribution via {@link #report}. The warning will be\n- * associated with the declaration placed in context by the most recent invocation of {@link #push push()}\n- * not yet {@link #pop}'d. Warnings are actually emitted later, during attribution, via {@link #flush}.\n- *\n- * <p>\n- * There is also an \"immediate\" mode, where warnings are emitted synchronously; see {@link #pushImmediate}.\n- *\n- * <p>\n- * Deferred warnings are grouped by the innermost containing module, package, class, method, or variable\n- * declaration (represented by {@link JCTree} nodes), so that the corresponding {@link Lint} configuration\n- * can be applied when the warning is eventually generated.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-public class DeferredLintHandler {\n-\n-    protected static final Context.Key<DeferredLintHandler> deferredLintHandlerKey = new Context.Key<>();\n-\n-    public static DeferredLintHandler instance(Context context) {\n-        DeferredLintHandler instance = context.get(deferredLintHandlerKey);\n-        if (instance == null)\n-            instance = new DeferredLintHandler(context);\n-        return instance;\n-    }\n-\n-    \/**\n-     * Registered {@link LintLogger}s grouped by the innermost containing module, package, class,\n-     * method, or variable declaration.\n-     *\/\n-    private final HashMap<JCTree, ArrayList<LintLogger>> deferralMap = new HashMap<>();\n-\n-    \/**\n-     * The current \"reporter\" stack, reflecting calls to {@link #push} and {@link #pop}.\n-     *\n-     * <p>\n-     * The top of the stack determines how calls to {@link #report} are handled.\n-     *\/\n-    private final ArrayDeque<Consumer<LintLogger>> reporterStack = new ArrayDeque<>();\n-\n-    @SuppressWarnings(\"this-escape\")\n-    protected DeferredLintHandler(Context context) {\n-        context.put(deferredLintHandlerKey, this);\n-        Lint rootLint = Lint.instance(context);\n-        pushImmediate(rootLint);            \/\/ default to \"immediate\" mode\n-    }\n-\n-\/\/ LintLogger\n-\n-    \/**An interface for deferred lint reporting - loggers passed to\n-     * {@link #report(LintLogger) } will be called when\n-     * {@link #flush(DiagnosticPosition) } is invoked.\n-     *\/\n-    public interface LintLogger {\n-\n-        \/**\n-         * Generate a warning if appropriate.\n-         *\n-         * @param lint the applicable lint configuration\n-         *\/\n-        void report(Lint lint);\n-    }\n-\n-\/\/ Reporter Stack\n-\n-    \/**\n-     * Defer {@link #report}ed warnings until the given declaration is flushed.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @see #pop\n-     *\/\n-    public void push(JCTree decl) {\n-        Assert.check(decl.getTag() == Tag.MODULEDEF\n-                  || decl.getTag() == Tag.PACKAGEDEF\n-                  || decl.getTag() == Tag.CLASSDEF\n-                  || decl.getTag() == Tag.METHODDEF\n-                  || decl.getTag() == Tag.VARDEF);\n-        reporterStack.push(logger -> deferralMap\n-                                        .computeIfAbsent(decl, s -> new ArrayList<>())\n-                                        .add(logger));\n-    }\n-\n-    \/**\n-     * Enter \"immediate\" mode so that {@link #report}ed warnings are emitted synchonously.\n-     *\n-     * @param lint lint configuration to use for reported warnings\n-     *\/\n-    public void pushImmediate(Lint lint) {\n-        reporterStack.push(logger -> logger.report(lint));\n-    }\n-\n-    \/**\n-     * Revert to the previous configuration in effect prior to the most recent invocation\n-     * of {@link #push} or {@link #pushImmediate}.\n-     *\n-     * @see #pop\n-     *\/\n-    public void pop() {\n-        Assert.check(reporterStack.size() > 1);     \/\/ the bottom stack entry should never be popped\n-        reporterStack.pop();\n-    }\n-\n-    \/**\n-     * Report a warning.\n-     *\n-     * <p>\n-     * In immediate mode, the warning is emitted synchronously. Otherwise, the warning is emitted later\n-     * when the current declaration is flushed.\n-     *\/\n-    public void report(LintLogger logger) {\n-        Assert.check(!reporterStack.isEmpty());\n-        reporterStack.peek().accept(logger);\n-    }\n-\n-\/\/ Warning Flush\n-\n-    \/**\n-     * Emit deferred warnings encompassed by the given declaration.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @param lint lint configuration corresponding to {@code decl}\n-     *\/\n-    public void flush(JCTree decl, Lint lint) {\n-        Optional.of(decl)\n-          .map(deferralMap::remove)\n-          .stream()\n-          .flatMap(ArrayList::stream)\n-          .forEach(logger -> logger.report(lint));\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -388,3 +388,0 @@\n-         *\n-         * <p>\n-         * This category is not supported by {@code @SuppressWarnings} (yet - see JDK-8224228).\n@@ -392,1 +389,1 @@\n-        TEXT_BLOCKS(\"text-blocks\", false),\n+        TEXT_BLOCKS(\"text-blocks\"),\n@@ -490,21 +487,0 @@\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(LintWarning warning) {\n-        logIfEnabled(null, warning);\n-    }\n-\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param pos source position at which to report the warning\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(DiagnosticPosition pos, LintWarning warning) {\n-        if (isEnabled(warning.getLintCategory())) {\n-            log.warning(pos, warning);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.code;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.tree.EndPosTable;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+\n+\/**\n+ * Maps source code positions to the applicable {@link Lint} instance.\n+ *\n+ * <p>\n+ * Because {@code @SuppressWarnings} is a Java symbol, in general this mapping can't be\n+ * calculated until after attribution. As each top-level declaration (class, package, or module)\n+ * is attributed, this singleton is notified and the {@link Lint}s that apply to every source\n+ * position within that top-level declaration are calculated.\n+ *\n+ * <p>\n+ * The method {@link #lintAt} returns the {@link Lint} instance applicable to source position;\n+ * if it can't be determined yet, an empty {@link Optional} is returned.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class LintMapper {\n+\n+    \/\/ The key for the context singleton\n+    private static final Context.Key<LintMapper> CONTEXT_KEY = new Context.Key<>();\n+\n+    \/\/ Per-source file information. Note: during the parsing of a file, an entry exists but the FileInfo value is null\n+    private final Map<JavaFileObject, FileInfo> fileInfoMap = new HashMap<>();\n+\n+    \/\/ Compiler context\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily; see initializeIfNeeded()\n+    private Lint rootLint;\n+\n+    \/**\n+     * Obtain the {@link LintMapper} context singleton.\n+     *\/\n+    public static LintMapper instance(Context context) {\n+        LintMapper instance = context.get(CONTEXT_KEY);\n+        if (instance == null)\n+            instance = new LintMapper(context);\n+        return instance;\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected LintMapper(Context context) {\n+        context.put(CONTEXT_KEY, this);\n+        this.context = context;\n+    }\n+\n+    \/\/ Lazy initialization to avoid dependency loops\n+    private void initializeIfNeeded() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+    }\n+\n+\/\/ Lint Operations\n+\n+    \/**\n+     * Determine if the given file is known to this instance.\n+     *\n+     * @param sourceFile source file\n+     * @return true if file is recognized\n+     *\/\n+    public boolean isKnown(JavaFileObject sourceFile) {\n+        return fileInfoMap.containsKey(sourceFile);\n+    }\n+\n+    \/**\n+     * Obtain the {@link Lint} configuration that applies at the given position, if known.\n+     *\n+     * @param sourceFile source file\n+     * @param pos source position\n+     * @return the applicable {@link Lint}, if known, otherwise empty\n+     *\/\n+    public Optional<Lint> lintAt(JavaFileObject sourceFile, DiagnosticPosition pos) {\n+        initializeIfNeeded();\n+        return Optional.of(sourceFile)\n+          .map(fileInfoMap::get)\n+          .flatMap(fileInfo -> fileInfo.lintAt(pos));\n+    }\n+\n+    \/**\n+     * Calculate {@lint Lint} configurations for all positions within the given top-level declaration.\n+     *\n+     * @param sourceFile source file\n+     * @param tree top-level declaration (class, package, or module)\n+     *\/\n+    public void calculateLints(JavaFileObject sourceFile, JCTree tree, EndPosTable endPositions) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n+    }\n+\n+    \/**\n+     * Reset this instance.\n+     *\/\n+    public void clear() {\n+        fileInfoMap.clear();\n+    }\n+\n+\/\/ Parsing Notifications\n+\n+    \/**\n+     * Invoked when file parsing starts to create an entry for the new file (but with a null value).\n+     *\/\n+    public void startParsingFile(JavaFileObject sourceFile) {\n+        initializeIfNeeded();\n+        fileInfoMap.put(sourceFile, null);\n+    }\n+\n+    \/**\n+     * Invoked when file parsing completes to put in place a corresponding {@link FileInfo}.\n+     *\/\n+    public void finishParsingFile(JCCompilationUnit tree) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.put(tree.sourcefile, new FileInfo(rootLint, tree));\n+    }\n+\n+\/\/ FileInfo\n+\n+    \/**\n+     * Holds {@link Lint} information for a fully parsed source file.\n+     *\n+     * <p>\n+     * Initially (immediately after parsing), \"unmappedDecls\" contains a {@link Span} corresponding to each\n+     * top-level declaration in the source file. As each top-level declaration is attributed, the corresponding\n+     * {@link Span} is removed and the corresponding {@link LintRange} subtree is populated under \"rootRange\".\n+     *\/\n+    private static class FileInfo {\n+\n+        final LintRange rootRange;                              \/\/ the root LintRange (covering the entire source file)\n+        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n+\n+        \/\/ After parsing: Add top-level declarations to our \"unmappedDecls\" list\n+        FileInfo(Lint rootLint, JCCompilationUnit tree) {\n+            rootRange = new LintRange(rootLint);\n+            tree.defs.stream()\n+              .filter(this::isTopLevelDecl)\n+              .map(decl -> new Span(decl, tree.endPositions))\n+              .forEach(unmappedDecls::add);\n+        }\n+\n+        \/\/ After attribution: Discard the span from \"unmappedDecls\" and populate the declaration's subtree under \"rootRange\"\n+        void afterAttr(JCTree tree, EndPosTable endPositions) {\n+            for (Iterator<Span> i = unmappedDecls.iterator(); i.hasNext(); ) {\n+                if (i.next().contains(tree.pos())) {\n+                    rootRange.populateSubtree(tree, endPositions);\n+                    i.remove();\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"top-level declaration not found\");\n+        }\n+\n+        \/\/ Find the most specific Lint configuration applying to the given position, unless the position has not been mapped yet\n+        Optional<Lint> lintAt(DiagnosticPosition pos) {\n+            boolean mapped = unmappedDecls.stream().noneMatch(span -> span.contains(pos));\n+            return mapped ? Optional.of(rootRange.bestMatch(pos).lint) : Optional.empty();\n+        }\n+\n+        boolean isTopLevelDecl(JCTree tree) {\n+            return tree.getTag() == Tag.MODULEDEF\n+                || tree.getTag() == Tag.PACKAGEDEF\n+                || tree.getTag() == Tag.CLASSDEF;\n+        }\n+    }\n+\n+\/\/ Span\n+\n+    \/**\n+     * A lexical range.\n+     *\/\n+    private record Span(int startPos, int endPos) {\n+\n+        static final Span MAXIMAL = new Span(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+\n+        Span(JCTree tree, EndPosTable endPositions) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n+        }\n+\n+        boolean contains(DiagnosticPosition pos) {\n+            int offset = pos.getLintPosition();\n+            return offset == startPos || (offset > startPos && offset < endPos);\n+        }\n+\n+        boolean contains(Span that) {\n+            return this.startPos <= that.startPos && this.endPos >= that.endPos;\n+        }\n+    }\n+\n+\/\/ LintRange\n+\n+    \/**\n+     * A tree of nested lexical ranges and the {@link Lint} configurations that apply therein.\n+     *\/\n+    private record LintRange(\n+        Span span,                                      \/\/ declaration's lexical range\n+        Lint lint,                                      \/\/ the Lint configuration that applies at this declaration\n+        List<LintRange> children                        \/\/ the nested declarations one level below this node\n+    ) {\n+\n+        \/\/ Create a node representing the entire file, using the root lint configuration\n+        LintRange(Lint rootLint) {\n+            this(Span.MAXIMAL, rootLint, new ArrayList<>());\n+        }\n+\n+        \/\/ Create a node representing the given declaration and its corresponding Lint configuration\n+        LintRange(JCTree tree, EndPosTable endPositions, Lint lint) {\n+            this(new Span(tree, endPositions), lint, new ArrayList<>());\n+        }\n+\n+        \/\/ Find the most specific node in this tree (including me) that contains the given position, if any\n+        LintRange bestMatch(DiagnosticPosition pos) {\n+            return children.stream()\n+              .map(child -> child.bestMatch(pos))\n+              .filter(Objects::nonNull)\n+              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n+              .orElseGet(() -> span.contains(pos) ? this : null);\n+        }\n+\n+        \/\/ Populate a sparse subtree corresponding to the given nested declaration.\n+        \/\/ Only when the Lint configuration differs from the parent is a node added.\n+        void populateSubtree(JCTree tree, EndPosTable endPositions) {\n+            new TreeScanner() {\n+\n+                private LintRange currentNode = LintRange.this;\n+\n+                @Override\n+                public void visitModuleDef(JCModuleDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitModuleDef);\n+                }\n+                @Override\n+                public void visitPackageDef(JCPackageDecl tree) {\n+                    scanDecl(tree, tree.packge, super::visitPackageDef);\n+                }\n+                @Override\n+                public void visitClassDef(JCClassDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitClassDef);\n+                }\n+                @Override\n+                public void visitMethodDef(JCMethodDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitMethodDef);\n+                }\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitVarDef);\n+                }\n+\n+                private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursor) {\n+\n+                    \/\/ The \"symbol\" can be null if there were earlier errors; skip this declaration if so\n+                    if (symbol == null) {\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Update the Lint using the declaration; if there's no change, then we don't need a new node here\n+                    Lint newLint = currentNode.lint.augment(symbol);\n+                    if (newLint == currentNode.lint) {  \/\/ note: lint.augment() returns the same instance if there's no change\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Add a new node here and proceed\n+                    final LintRange previousNode = currentNode;\n+                    currentNode = new LintRange(tree, endPositions, newLint);\n+                    previousNode.children.add(currentNode);\n+                    try {\n+                        recursor.accept(tree);\n+                    } finally {\n+                        currentNode = previousNode;\n+                    }\n+                }\n+            }.scan(tree);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -70,3 +70,0 @@\n-    \/** flag: is the \"preview\" lint category enabled? *\/\n-    private final boolean verbose;\n-\n@@ -103,1 +100,0 @@\n-        verbose = Lint.instance(context).isEnabled(LintCategory.PREVIEW);\n@@ -187,3 +183,1 @@\n-        if (verbose) {\n-            log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n-        }\n+        log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -94,1 +93,0 @@\n-    private final Lint lint;\n@@ -114,1 +112,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -117,1 +114,0 @@\n-        lint = Lint.instance(context);\n@@ -240,1 +236,0 @@\n-     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n@@ -242,2 +237,1 @@\n-    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv,\n-            Symbol s, JCTree deferDecl)\n+    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv, Symbol s)\n@@ -261,2 +255,0 @@\n-            Assert.check(deferDecl != null);\n-            deferredLintHandler.push(deferDecl);\n@@ -273,1 +265,0 @@\n-                deferredLintHandler.pop();\n@@ -290,2 +281,1 @@\n-    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv,\n-            MethodSymbol m, JCTree deferDecl)\n+    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv, MethodSymbol m)\n@@ -295,1 +285,0 @@\n-            deferredLintHandler.push(deferDecl);\n@@ -299,1 +288,0 @@\n-                deferredLintHandler.pop();\n@@ -703,1 +691,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym);\n@@ -1055,2 +1043,1 @@\n-    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env,\n-            Symbol s, JCTree deferDecl, boolean isTypeParam)\n+    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env, Symbol s, boolean isTypeParam)\n@@ -1061,3 +1048,0 @@\n-        if (deferDecl != null) {\n-            deferredLintHandler.push(deferDecl);\n-        }\n@@ -1067,2 +1051,0 @@\n-            if (deferDecl != null)\n-                deferredLintHandler.pop();\n@@ -1076,1 +1058,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym)\n@@ -1079,1 +1061,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym)));\n@@ -1114,1 +1096,0 @@\n-        private JCTree deferDecl;\n@@ -1116,1 +1097,1 @@\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym) {\n@@ -1120,1 +1101,0 @@\n-            this.deferDecl = deferDecl;\n@@ -1125,1 +1105,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1131,1 +1111,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, true);\n@@ -1137,1 +1117,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1139,1 +1119,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, false);\n@@ -1158,12 +1138,5 @@\n-            JCTree prevDecl = deferDecl;\n-            deferDecl = tree;\n-            try {\n-                if (sym != null && sym.kind == VAR) {\n-                    \/\/ Don't visit a parameter once when the sym is the method\n-                    \/\/ and once when the sym is the parameter.\n-                    scan(tree.mods);\n-                    scan(tree.vartype);\n-                }\n-                scan(tree.init);\n-            } finally {\n-                deferDecl = prevDecl;\n+            if (sym != null && sym.kind == VAR) {\n+                \/\/ Don't visit a parameter once when the sym is the method\n+                \/\/ and once when the sym is the parameter.\n+                scan(tree.mods);\n+                scan(tree.vartype);\n@@ -1171,0 +1144,1 @@\n+            scan(tree.init);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -101,0 +102,1 @@\n+    final LintMapper lintMapper;\n@@ -119,1 +121,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -141,0 +142,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -160,1 +162,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -845,1 +846,0 @@\n-        deferredLintHandler.push(variable);\n@@ -861,1 +861,0 @@\n-            deferredLintHandler.pop();\n@@ -990,1 +989,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1231,1 +1229,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m);\n@@ -1324,1 +1322,1 @@\n-                localEnv.info.lint.logIfEnabled(tree, LintWarnings.WouldNotBeAllowedInPrologue(sym));\n+                log.warning(tree, LintWarnings.WouldNotBeAllowedInPrologue(sym));\n@@ -1578,1 +1576,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1637,1 +1634,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym);\n@@ -1738,1 +1735,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);\n+            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner);\n@@ -2251,1 +2248,1 @@\n-            env.info.lint.logIfEnabled(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+            log.warning(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2353,1 +2350,1 @@\n-                env.info.lint.logIfEnabled(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -4525,1 +4522,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n+        annotate.annotateLater(tree.var.mods.annotations, env, v);\n@@ -4527,1 +4524,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v);\n@@ -4766,1 +4763,1 @@\n-            env.info.lint.logIfEnabled(tree, LintWarnings.TryExplicitCloseCall);\n+            log.warning(tree, LintWarnings.TryExplicitCloseCall);\n@@ -4793,1 +4790,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4795,1 +4792,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -5597,0 +5594,3 @@\n+\n+        \/\/ Now that this tree is attributed, we can calculate the Lint configuration everywhere within it\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n@@ -5639,1 +5639,0 @@\n-            deferredLintHandler.flush(env.tree, lint);\n@@ -5823,1 +5822,0 @@\n-                deferredLintHandler.flush(env.tree, env.info.lint);\n@@ -5874,3 +5872,0 @@\n-        chk.checkModuleName(tree);\n-        chk.checkDeprecatedAnnotation(tree, msym);\n-\n@@ -5878,1 +5873,2 @@\n-            deferredLintHandler.flush(tree, lint);\n+            chk.checkModuleName(tree);\n+            chk.checkDeprecatedAnnotation(tree, msym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    Lint lint;\n+    private Lint lint;\n@@ -167,2 +167,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-\n@@ -185,4 +183,0 @@\n-    \/** A handler for deferred lint warnings.\n-     *\/\n-    private DeferredLintHandler deferredLintHandler;\n-\n@@ -238,18 +232,9 @@\n-        LintWarning warningKey = null;\n-        if (sym.isDeprecatedForRemoval()) {\n-            if (!lint.isSuppressed(LintCategory.REMOVAL)) {\n-                if (sym.kind == MDL) {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n-                } else {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n-                }\n-            }\n-        } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {\n-            if (sym.kind == MDL) {\n-                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n-            } else {\n-                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n-            }\n-        }\n-        if (warningKey != null)\n-            log.warning(pos, warningKey);\n+        Assert.check(!importSuppression);\n+        LintWarning warningKey = sym.isDeprecatedForRemoval() ?\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedForRemovalModule(sym) :\n+                LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location())) :\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedModule(sym) :\n+                LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+        log.warning(pos, warningKey);\n@@ -263,1 +248,1 @@\n-        if (!importSuppression && !lint.isSuppressed(LintCategory.PREVIEW))\n+        if (!importSuppression)\n@@ -267,8 +252,0 @@\n-    \/** Log a preview warning.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param msg        A Warning describing the problem.\n-     *\/\n-    public void warnRestrictedAPI(DiagnosticPosition pos, Symbol sym) {\n-        lint.logIfEnabled(pos, LintWarnings.RestrictedMethod(sym.enclClass(), sym));\n-    }\n-\n@@ -280,2 +257,1 @@\n-        if (!lint.isSuppressed(LintCategory.UNCHECKED))\n-            log.warning(pos, warnKey);\n+        log.warning(pos, warnKey);\n@@ -617,3 +593,1 @@\n-            deferredLintHandler.report(_l -> {\n-                lint.logIfEnabled(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n-            });\n+            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n@@ -974,1 +948,1 @@\n-            lint.logIfEnabled(tree, LintWarnings.VarargsRedundantTrustmeAnno(\n+            log.warning(tree.pos(), LintWarnings.VarargsRedundantTrustmeAnno(\n@@ -1245,1 +1219,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1297,1 +1271,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1372,10 +1346,0 @@\n-    private void warnOnExplicitStrictfp(JCTree tree) {\n-        deferredLintHandler.push(tree);\n-        try {\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(tree.pos(), LintWarnings.Strictfp));\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n-    }\n-\n-\n@@ -1594,1 +1558,1 @@\n-            lint.logIfEnabled(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n+            log.warning(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n@@ -1918,1 +1882,1 @@\n-            lint.logIfEnabled(TreeInfo.diagnosticPositionFor(m, tree),\n+            log.warning(TreeInfo.diagnosticPositionFor(m, tree),\n@@ -1932,6 +1896,1 @@\n-            Lint prevLint = setLint(lint.augment(m));\n-            try {\n-                checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n-            } finally {\n-                setLint(prevLint);\n-            }\n+            checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n@@ -3023,7 +2982,2 @@\n-        final Lint prevLint = setLint(warnOnAnyAccessToMembers ? lint.enable(LintCategory.SERIAL) : lint);\n-        try {\n-            if (warnOnAnyAccessToMembers || isLambda)\n-                checkAccessFromSerializableElementInner(tree, isLambda);\n-        } finally {\n-            setLint(prevLint);\n-        }\n+        if (warnOnAnyAccessToMembers || isLambda)\n+            checkAccessFromSerializableElementInner(tree, isLambda);\n@@ -3033,5 +2987,4 @@\n-        if (lint.isEnabled(LintCategory.SERIAL)) {\n-            Symbol sym = TreeInfo.symbol(tree);\n-            if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n-                return;\n-            }\n+        Symbol sym = TreeInfo.symbol(tree);\n+        if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n+            return;\n+        }\n@@ -3039,7 +2992,6 @@\n-            if (sym.kind == VAR) {\n-                if ((sym.flags() & PARAMETER) != 0 ||\n-                    sym.isDirectlyOrIndirectlyLocal() ||\n-                    sym.name == names._this ||\n-                    sym.name == names._super) {\n-                    return;\n-                }\n+        if (sym.kind == VAR) {\n+            if ((sym.flags() & PARAMETER) != 0 ||\n+                sym.isDirectlyOrIndirectlyLocal() ||\n+                sym.name == names._this ||\n+                sym.name == names._super) {\n+                return;\n@@ -3047,0 +2999,1 @@\n+        }\n@@ -3048,10 +3001,5 @@\n-            if (!types.isSubtype(sym.owner.type, syms.serializableType) &&\n-                isEffectivelyNonPublic(sym)) {\n-                if (isLambda) {\n-                    if (belongsToRestrictedPackage(sym)) {\n-                        log.warning(tree.pos(),\n-                                    LintWarnings.AccessToMemberFromSerializableLambda(sym));\n-                    }\n-                } else {\n-                    log.warning(tree.pos(),\n-                                LintWarnings.AccessToMemberFromSerializableElement(sym));\n+        if (!types.isSubtype(sym.owner.type, syms.serializableType) && isEffectivelyNonPublic(sym)) {\n+            DiagnosticFlag flag = warnOnAnyAccessToMembers ? DiagnosticFlag.DEFAULT_ENABLED : null;\n+            if (isLambda) {\n+                if (belongsToRestrictedPackage(sym)) {\n+                    log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableLambda(sym));\n@@ -3059,0 +3007,2 @@\n+            } else {\n+                log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableElement(sym));\n@@ -3845,2 +3795,1 @@\n-                log.warning(pos,\n-                            LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n+                log.warning(pos, LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n@@ -3860,1 +3809,1 @@\n-            deferredLintHandler.report(_l -> warnDeprecated(pos.get(), s));\n+            warnDeprecated(pos.get(), s);\n@@ -3866,3 +3815,1 @@\n-            deferredLintHandler.report(_l -> {\n-                log.warning(pos, Warnings.SunProprietary(s));\n-            });\n+            log.warning(pos, Warnings.SunProprietary(s));\n@@ -3925,1 +3872,1 @@\n-            deferredLintHandler.report(_l -> warnRestrictedAPI(pos, s));\n+            log.warning(pos, LintWarnings.RestrictedMethod(s.enclClass(), s));\n@@ -4197,1 +4144,1 @@\n-                deferredLintHandler.report(_ -> lint.logIfEnabled(pos, LintWarnings.DivZero));\n+                log.warning(pos, LintWarnings.DivZero);\n@@ -4210,2 +4157,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PossibleLossOfPrecision(found, req)));\n+            log.warning(pos, LintWarnings.PossibleLossOfPrecision(found, req));\n@@ -4220,1 +4166,1 @@\n-            lint.logIfEnabled(tree.thenpart.pos(), LintWarnings.EmptyIf);\n+            log.warning(tree.thenpart.pos(), LintWarnings.EmptyIf);\n@@ -4367,2 +4313,1 @@\n-            lint.logIfEnabled(pos,\n-                        LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n+            log.warning(pos, LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n@@ -4410,2 +4355,1 @@\n-                            deferredLintHandler.report(_ ->\n-                                lint.logIfEnabled(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle)));\n+                            log.warning(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle));\n@@ -4447,1 +4391,1 @@\n-                        Check.this.lint.logIfEnabled(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n+                        log.warning(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n@@ -4745,2 +4689,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.ModuleNotFound(msym)));\n+            log.warning(pos, LintWarnings.ModuleNotFound(msym));\n@@ -4753,2 +4696,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PackageEmptyOrNotFound(packge)));\n+            log.warning(pos, LintWarnings.PackageEmptyOrNotFound(packge));\n@@ -4760,7 +4702,5 @@\n-            deferredLintHandler.report(_ -> {\n-                if (rd.isTransitive() && lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {\n-                    log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n-                } else {\n-                    lint.logIfEnabled(pos, LintWarnings.RequiresAutomatic);\n-                }\n-            });\n+            if (rd.isTransitive()) {    \/\/ see comment in Log.applyLint() for special logic that applies\n+                log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n+            } else {\n+                log.warning(pos, LintWarnings.RequiresAutomatic);\n+            }\n@@ -5854,1 +5794,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5861,1 +5801,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5888,1 +5828,1 @@\n-                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                log.warning(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5965,1 +5905,1 @@\n-                        .forEach(ta -> lint.logIfEnabled(typeParamTrees.get(ta.position.parameter_index).pos(),\n+                        .forEach(ta -> log.warning(typeParamTrees.get(ta.position.parameter_index).pos(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":60,"deletions":120,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -218,1 +218,0 @@\n-    private       Lint lint;\n@@ -343,1 +342,0 @@\n-        lint = Lint.instance(context);\n@@ -592,1 +590,0 @@\n-            Lint lintPrev = lint;\n@@ -595,1 +592,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -626,1 +622,0 @@\n-                lint = lintPrev;\n@@ -632,3 +627,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -638,4 +630,3 @@\n-            try {\n-                alive = Liveness.ALIVE;\n-                scanStat(tree.body);\n-                tree.completesNormally = alive != Liveness.DEAD;\n+            alive = Liveness.ALIVE;\n+            scanStat(tree.body);\n+            tree.completesNormally = alive != Liveness.DEAD;\n@@ -643,2 +634,2 @@\n-                if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n-                    log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n+            if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n+                log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n@@ -646,4 +637,1 @@\n-                clearPendingExits(true);\n-            } finally {\n-                lint = lintPrev;\n-            }\n+            clearPendingExits(true);\n@@ -664,9 +652,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -754,2 +734,1 @@\n-                    lint.logIfEnabled(l.tail.head.pos(),\n-                                LintWarnings.PossibleFallThroughIntoCase);\n+                    log.warning(l.tail.head.pos(), LintWarnings.PossibleFallThroughIntoCase);\n@@ -1262,1 +1241,1 @@\n-                    lint.logIfEnabled(TreeInfo.diagEndPos(tree.finalizer),\n+                    log.warning(TreeInfo.diagEndPos(tree.finalizer),\n@@ -1483,1 +1462,0 @@\n-            Lint lintPrev = lint;\n@@ -1491,1 +1469,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -1540,1 +1517,0 @@\n-                lint = lintPrev;\n@@ -1549,3 +1525,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -1584,1 +1557,0 @@\n-                lint = lintPrev;\n@@ -1589,9 +1561,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -2429,7 +2393,4 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try {\n-                JCClassDecl classDefPrev = classDef;\n-                int firstadrPrev = firstadr;\n-                int nextadrPrev = nextadr;\n-                ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n+            JCClassDecl classDefPrev = classDef;\n+            int firstadrPrev = firstadr;\n+            int nextadrPrev = nextadr;\n+            ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n@@ -2437,15 +2398,14 @@\n-                pendingExits = new ListBuffer<>();\n-                if (tree.name != names.empty) {\n-                    firstadr = nextadr;\n-                }\n-                classDef = tree;\n-                try {\n-                    \/\/ define all the static fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) != 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+            pendingExits = new ListBuffer<>();\n+            if (tree.name != names.empty) {\n+                firstadr = nextadr;\n+            }\n+            classDef = tree;\n+            try {\n+                \/\/ define all the static fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) != 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2455,0 +2415,1 @@\n+                }\n@@ -2456,5 +2417,5 @@\n-                    \/\/ process all the static initializers\n-                    forEachInitializer(tree, true, def -> {\n-                        scan(def);\n-                        clearPendingExits(false);\n-                    });\n+                \/\/ process all the static initializers\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    clearPendingExits(false);\n+                });\n@@ -2462,7 +2423,6 @@\n-                    \/\/ verify all static final fields got initialized\n-                    for (int i = firstadr; i < nextadr; i++) {\n-                        JCVariableDecl vardecl = vardecls[i];\n-                        VarSymbol var = vardecl.sym;\n-                        if (var.owner == classDef.sym && var.isStatic()) {\n-                            checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n-                        }\n+                \/\/ verify all static final fields got initialized\n+                for (int i = firstadr; i < nextadr; i++) {\n+                    JCVariableDecl vardecl = vardecls[i];\n+                    VarSymbol var = vardecl.sym;\n+                    if (var.owner == classDef.sym && var.isStatic()) {\n+                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2470,0 +2430,1 @@\n+                }\n@@ -2471,9 +2432,8 @@\n-                    \/\/ define all the instance fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) == 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+                \/\/ define all the instance fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) == 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2483,0 +2443,1 @@\n+                }\n@@ -2484,5 +2445,4 @@\n-                    \/\/ process all the methods\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(METHODDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the methods\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(METHODDEF)) {\n+                        scan(l.head);\n@@ -2490,0 +2450,1 @@\n+                }\n@@ -2491,5 +2452,4 @@\n-                    \/\/ process all the nested classes\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(CLASSDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the nested classes\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(CLASSDEF)) {\n+                        scan(l.head);\n@@ -2497,5 +2457,0 @@\n-                } finally {\n-                    pendingExits = pendingExitsPrev;\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    classDef = classDefPrev;\n@@ -2504,1 +2459,4 @@\n-                lint = lintPrev;\n+                pendingExits = pendingExitsPrev;\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                classDef = classDefPrev;\n@@ -2519,2 +2477,9 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n+            final Bits initsPrev = new Bits(inits);\n+            final Bits uninitsPrev = new Bits(uninits);\n+            int nextadrPrev = nextadr;\n+            int firstadrPrev = firstadr;\n+            int returnadrPrev = returnadr;\n+\n+            Assert.check(pendingExits.isEmpty());\n+            boolean isConstructorPrev = isConstructor;\n+            boolean isCompactOrGeneratedRecordConstructorPrev = isCompactOrGeneratedRecordConstructor;\n@@ -2522,18 +2487,3 @@\n-                final Bits initsPrev = new Bits(inits);\n-                final Bits uninitsPrev = new Bits(uninits);\n-                int nextadrPrev = nextadr;\n-                int firstadrPrev = firstadr;\n-                int returnadrPrev = returnadr;\n-\n-                Assert.check(pendingExits.isEmpty());\n-                boolean isConstructorPrev = isConstructor;\n-                boolean isCompactOrGeneratedRecordConstructorPrev = isCompactOrGeneratedRecordConstructor;\n-                try {\n-                    isConstructor = TreeInfo.isConstructor(tree);\n-                    isCompactOrGeneratedRecordConstructor = isConstructor && ((tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n-                            (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD));\n-\n-                    \/\/ We only track field initialization inside constructors\n-                    if (!isConstructor) {\n-                        firstadr = nextadr;\n-                    }\n+                isConstructor = TreeInfo.isConstructor(tree);\n+                isCompactOrGeneratedRecordConstructor = isConstructor && ((tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+                         (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD));\n@@ -2541,15 +2491,19 @@\n-                    \/\/ Mark all method parameters as DA\n-                    for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n-                        JCVariableDecl def = l.head;\n-                        scan(def);\n-                        Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n-                        \/*  If we are executing the code from Gen, then there can be\n-                         *  synthetic or mandated variables, ignore them.\n-                         *\/\n-                        initParam(def);\n-                    }\n-                    if (isConstructor) {\n-                        Set<VarSymbol> unsetFields = findUninitStrictFields();\n-                        if (unsetFields != null && !unsetFields.isEmpty()) {\n-                            unsetFieldsInfo.addUnsetFieldsInfo(classDef.sym, tree.body, unsetFields);\n-                        }\n+                \/\/ We only track field initialization inside constructors\n+                if (!isConstructor) {\n+                    firstadr = nextadr;\n+                }\n+\n+                \/\/ Mark all method parameters as DA\n+                for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n+                    JCVariableDecl def = l.head;\n+                    scan(def);\n+                    Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n+                    \/*  If we are executing the code from Gen, then there can be\n+                     *  synthetic or mandated variables, ignore them.\n+                     *\/\n+                    initParam(def);\n+                }\n+                if (isConstructor) {\n+                    Set<VarSymbol> unsetFields = findUninitStrictFields();\n+                    if (unsetFields != null && !unsetFields.isEmpty()) {\n+                        unsetFieldsInfo.addUnsetFieldsInfo(classDef.sym, tree.body, unsetFields);\n@@ -2557,0 +2511,1 @@\n+                }\n@@ -2558,30 +2513,27 @@\n-                    \/\/ else we are in an instance initializer block;\n-                    \/\/ leave caught unchanged.\n-                    scan(tree.body);\n-\n-                    if (isConstructor) {\n-                        boolean isSynthesized = (tree.sym.flags() &\n-                                                 GENERATEDCONSTR) != 0;\n-                        for (int i = firstadr; i < nextadr; i++) {\n-                            JCVariableDecl vardecl = vardecls[i];\n-                            VarSymbol var = vardecl.sym;\n-                            if (var.owner == classDef.sym && !var.isStatic()) {\n-                                \/\/ choose the diagnostic position based on whether\n-                                \/\/ the ctor is default(synthesized) or not\n-                                if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n-                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n-                                            var, Errors.VarNotInitializedInDefaultConstructor(var));\n-                                } else if (isCompactOrGeneratedRecordConstructor) {\n-                                    boolean isInstanceRecordField = var.enclClass().isRecord() &&\n-                                            (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n-                                            var.owner.kind == TYP;\n-                                    if (isInstanceRecordField) {\n-                                        boolean notInitialized = !inits.isMember(var.adr);\n-                                        if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n-                                        \/*  this way we indicate Lower that it should generate an initialization for this field\n-                                         *  in the compact constructor\n-                                         *\/\n-                                            var.flags_field |= UNINITIALIZED_FIELD;\n-                                        } else {\n-                                            checkInit(TreeInfo.diagEndPos(tree.body), var);\n-                                        }\n+                \/\/ else we are in an instance initializer block;\n+                \/\/ leave caught unchanged.\n+                scan(tree.body);\n+\n+                if (isConstructor) {\n+                    boolean isSynthesized = (tree.sym.flags() &\n+                                             GENERATEDCONSTR) != 0;\n+                    for (int i = firstadr; i < nextadr; i++) {\n+                        JCVariableDecl vardecl = vardecls[i];\n+                        VarSymbol var = vardecl.sym;\n+                        if (var.owner == classDef.sym && !var.isStatic()) {\n+                            \/\/ choose the diagnostic position based on whether\n+                            \/\/ the ctor is default(synthesized) or not\n+                            if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n+                                checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n+                                        var, Errors.VarNotInitializedInDefaultConstructor(var));\n+                            } else if (isCompactOrGeneratedRecordConstructor) {\n+                                boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                        (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                        var.owner.kind == TYP;\n+                                if (isInstanceRecordField) {\n+                                    boolean notInitialized = !inits.isMember(var.adr);\n+                                    if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n+                                    \/*  this way we indicate Lower that it should generate an initialization for this field\n+                                     *  in the compact constructor\n+                                     *\/\n+                                        var.flags_field |= UNINITIALIZED_FIELD;\n@@ -2589,1 +2541,1 @@\n-                                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n+                                        checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2592,1 +2544,1 @@\n-                                    checkInit(TreeInfo.diagEndPos(tree.body), var);\n+                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2594,0 +2546,2 @@\n+                            } else {\n+                                checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2597,9 +2551,0 @@\n-                    clearPendingExits(true);\n-                } finally {\n-                    inits.assign(initsPrev);\n-                    uninits.assign(uninitsPrev);\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    returnadr = returnadrPrev;\n-                    isConstructor = isConstructorPrev;\n-                    isCompactOrGeneratedRecordConstructor = isCompactOrGeneratedRecordConstructorPrev;\n@@ -2607,0 +2552,1 @@\n+                clearPendingExits(true);\n@@ -2608,1 +2554,7 @@\n-                lint = lintPrev;\n+                inits.assign(initsPrev);\n+                uninits.assign(uninitsPrev);\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                returnadr = returnadrPrev;\n+                isConstructor = isConstructorPrev;\n+                isCompactOrGeneratedRecordConstructor = isCompactOrGeneratedRecordConstructorPrev;\n@@ -2647,12 +2599,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try{\n-                boolean track = trackable(tree.sym);\n-                if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n-                    newVar(tree);\n-                }\n-                if (tree.init != null) {\n-                    scanExpr(tree.init);\n-                    if (track) {\n-                        letInit(tree.pos(), tree.sym);\n-                    }\n+            boolean track = trackable(tree.sym);\n+            if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n+                newVar(tree);\n+            }\n+            if (tree.init != null) {\n+                scanExpr(tree.init);\n+                if (track) {\n+                    letInit(tree.pos(), tree.sym);\n@@ -2660,2 +2608,0 @@\n-            } finally {\n-                lint = lintPrev;\n@@ -2913,2 +2859,1 @@\n-            if (!resourceVarDecls.isEmpty() &&\n-                    lint.isEnabled(Lint.LintCategory.TRY)) {\n+            if (!resourceVarDecls.isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":143,"deletions":198,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -90,1 +89,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -197,10 +195,5 @@\n-        deferredLintHandler.push(tree);\n-        try {\n-            \/\/ Compute the method type\n-            m.type = signature(m, tree.typarams, tree.params,\n-                               tree.restype, tree.recvparam,\n-                               tree.thrown,\n-                               localEnv);\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n+        \/\/ Compute the method type\n+        m.type = signature(m, tree.typarams, tree.params,\n+                           tree.restype, tree.recvparam,\n+                           tree.thrown,\n+                           localEnv);\n@@ -230,1 +223,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m);\n@@ -233,1 +226,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m);\n@@ -237,1 +230,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m);\n@@ -266,1 +259,0 @@\n-        deferredLintHandler.push(tree);\n@@ -268,10 +260,6 @@\n-        try {\n-            if (TreeInfo.isEnumInit(tree)) {\n-                attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n-            } else if (!tree.isImplicitlyTyped()) {\n-                attr.attribType(tree.vartype, localEnv);\n-                if (TreeInfo.isReceiverParam(tree))\n-                    checkReceiver(tree, localEnv);\n-            }\n-        } finally {\n-            deferredLintHandler.pop();\n+        if (TreeInfo.isEnumInit(tree)) {\n+            attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n+        } else if (!tree.isImplicitlyTyped()) {\n+            attr.attribType(tree.vartype, localEnv);\n+            if (TreeInfo.isReceiverParam(tree))\n+                checkReceiver(tree, localEnv);\n@@ -320,1 +308,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v);\n@@ -322,1 +310,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -144,1 +143,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -172,2 +170,0 @@\n-    private final boolean lintOptions;\n-\n@@ -196,1 +192,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -208,2 +203,0 @@\n-        lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-\n@@ -749,1 +742,0 @@\n-                deferredLintHandler.push(moduleDecl);\n@@ -757,1 +749,0 @@\n-                    deferredLintHandler.pop();\n@@ -994,1 +985,0 @@\n-            deferredLintHandler.push(decl);\n@@ -1000,1 +990,0 @@\n-                deferredLintHandler.pop();\n@@ -1266,6 +1255,3 @@\n-            if (lintOptions) {\n-                for (ModuleSymbol msym : limitMods) {\n-                    if (!observable.contains(msym)) {\n-                        log.warning(\n-                                LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n-                    }\n+            for (ModuleSymbol msym : limitMods) {\n+                if (!observable.contains(msym)) {\n+                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n@@ -1724,4 +1710,1 @@\n-            if (lintOptions) {\n-                log.warning(\n-                        LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n-            }\n+            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n@@ -1763,3 +1746,1 @@\n-                if (lintOptions) {\n-                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n-                }\n+                log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n@@ -1783,3 +1764,1 @@\n-                        if (lintOptions) {\n-                            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n-                        }\n+                        log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -60,0 +61,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -70,0 +72,1 @@\n+import static com.sun.tools.javac.util.Position.NOPOS;\n@@ -159,1 +162,1 @@\n-    private       Lint lint;\n+    private final LintMapper lintMapper;\n@@ -171,4 +174,0 @@\n-    \/** Contains symbols of fields and constructors that have warnings suppressed.\n-     *\/\n-    private final Set<Symbol> suppressed = new HashSet<>();\n-\n@@ -234,1 +233,1 @@\n-        lint = Lint.instance(context);\n+        lintMapper = LintMapper.instance(context);\n@@ -265,2 +264,2 @@\n-        \/\/ Short circuit if warnings are totally disabled\n-        if (!lint.isEnabled(THIS_ESCAPE))\n+        \/\/ Short circuit if this calculation is unnecessary\n+        if (!lintMapper.lintAt(env.toplevel.sourcefile, env.tree.pos()).get().isEnabled(THIS_ESCAPE))\n@@ -281,1 +280,0 @@\n-        \/\/ Track which constructors and fields have warnings suppressed.\n@@ -285,1 +283,0 @@\n-            private Lint lint = ThisEscapeAnalyzer.this.lint;\n@@ -293,2 +290,0 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n@@ -309,18 +304,0 @@\n-                    lint = lintPrev;\n-                }\n-            }\n-\n-            @Override\n-            public void visitVarDef(JCVariableDecl tree) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of fields\n-                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n-\n-                    \/\/ Recurse\n-                    super.visitVarDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n@@ -332,7 +309,0 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of constructors\n-                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n@@ -340,5 +310,5 @@\n-                    \/\/ Gather some useful info\n-                    boolean constructor = TreeInfo.isConstructor(tree);\n-                    boolean extendableClass = currentClassIsExternallyExtendable();\n-                    boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n-                    boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+                \/\/ Gather some useful info\n+                boolean constructor = TreeInfo.isConstructor(tree);\n+                boolean extendableClass = currentClassIsExternallyExtendable();\n+                boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n+                boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n@@ -346,2 +316,2 @@\n-                    \/\/ Determine if this is a constructor we should analyze\n-                    boolean analyzable = extendableClass && constructor && nonPrivate;\n+                \/\/ Determine if this is a constructor we should analyze\n+                boolean analyzable = extendableClass && constructor && nonPrivate;\n@@ -349,2 +319,2 @@\n-                    \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n-                    boolean invokable = !extendableClass || constructor || finalish;\n+                \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n+                boolean invokable = !extendableClass || constructor || finalish;\n@@ -352,2 +322,2 @@\n-                    \/\/ Add this method or constructor to our map\n-                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n+                \/\/ Add this method or constructor to our map\n+                methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n@@ -355,5 +325,2 @@\n-                    \/\/ Recurse\n-                    super.visitMethodDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n+                \/\/ Recurse\n+                super.visitMethodDef(tree);\n@@ -404,1 +371,1 @@\n-                log.warning(frame.site.pos(), key);\n+                log.warning(frame.warningPos(), key);\n@@ -1749,0 +1716,8 @@\n+        DiagnosticPosition warningPos() {\n+            return site.pos().withLintPosition(NOPOS);      \/\/ disable normal Lint suppression\n+        }\n+\n+        Lint lint() {\n+            return lintMapper.lintAt(topLevelEnv.toplevel.sourcefile, site.pos()).get();\n+        }\n+\n@@ -1750,2 +1725,1 @@\n-            return suppressible &&\n-              suppressed.contains(initializer instanceof JCVariableDecl v ? v.sym : method.declaration.sym);\n+            return suppressible && !lint().isEnabled(THIS_ESCAPE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":30,"deletions":56,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -112,2 +111,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n-    private final Lint lint;\n@@ -139,2 +136,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-        lint = Lint.instance(context);\n@@ -278,1 +273,0 @@\n-                deferredLintHandler.push(tree);\n@@ -286,1 +280,0 @@\n-                    deferredLintHandler.pop();\n@@ -355,2 +348,0 @@\n-            deferredLintHandler.pushImmediate(lint);\n-            Lint prevLint = chk.setLint(lint);\n@@ -380,7 +371,2 @@\n-                    deferredLintHandler.push(decl);\n-                    try {\n-                        \/\/check @Deprecated:\n-                        markDeprecated(decl.sym, decl.mods.annotations, env);\n-                    } finally {\n-                        deferredLintHandler.pop();\n-                    }\n+                    \/\/check for @Deprecated annotations\n+                    markDeprecated(decl.sym, decl.mods.annotations, env);\n@@ -388,1 +374,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle);\n@@ -392,2 +378,0 @@\n-                chk.setLint(prevLint);\n-                deferredLintHandler.pop();\n@@ -426,1 +410,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge);\n@@ -918,1 +902,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym);\n@@ -920,1 +904,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym);\n@@ -935,1 +919,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym);\n@@ -939,1 +923,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        locations.update(log, lint, FSInfo.instance(context));\n+        locations.update(log, FSInfo.instance(context));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -86,0 +84,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -126,5 +125,0 @@\n-    \/**\n-     * The root {@link Lint} instance.\n-     *\/\n-    private Lint lint;\n-\n@@ -171,1 +165,1 @@\n-    void update(Log log, Lint lint, FSInfo fsInfo) {\n+    void update(Log log, FSInfo fsInfo) {\n@@ -173,1 +167,0 @@\n-        this.lint = lint;\n@@ -224,1 +217,1 @@\n-                    lint.logIfEnabled(LintWarnings.InvalidPath(s));\n+                    log.warning(LintWarnings.InvalidPath(s));\n@@ -319,1 +312,1 @@\n-                    lint.logIfEnabled(LintWarnings.DirPathElementNotFound(dir));\n+                    log.warning(LintWarnings.DirPathElementNotFound(dir));\n@@ -364,1 +357,1 @@\n-                    lint.logIfEnabled(LintWarnings.PathElementNotFound(file));\n+                    log.warning(LintWarnings.PathElementNotFound(file));\n@@ -386,1 +379,1 @@\n-                                lint.logIfEnabled(LintWarnings.UnexpectedArchiveFile(file));\n+                                log.warning(LintWarnings.UnexpectedArchiveFile(file));\n@@ -391,1 +384,1 @@\n-                                lint.logIfEnabled(LintWarnings.InvalidArchiveFile(file));\n+                                log.warning(LintWarnings.InvalidArchiveFile(file));\n@@ -1654,1 +1647,1 @@\n-                lint.logIfEnabled(Files.exists(prefix) ?\n+                log.warning(Files.exists(prefix) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -149,3 +148,0 @@\n-    \/** The root Lint config. *\/\n-    Lint lint;\n-\n@@ -315,2 +311,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -868,2 +862,1 @@\n-                        lint.logIfEnabled(\n-                                    LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n+                        log.warning(LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n@@ -1636,1 +1629,1 @@\n-            lint.logIfEnabled(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            log.warning(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n@@ -2102,1 +2095,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFound(container, name));\n+                    log.warning(LintWarnings.AnnotationMethodNotFound(container, name));\n@@ -2104,1 +2097,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFoundReason(container,\n+                    log.warning(LintWarnings.AnnotationMethodNotFoundReason(container,\n@@ -2981,1 +2974,1 @@\n-        lint.logIfEnabled(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        log.warning(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -506,6 +505,3 @@\n-                    boolean lintPaths = !options.isLintDisabled(LintCategory.PATH);\n-                    if (lintPaths) {\n-                        Path outDirParent = outDir.getParent();\n-                        if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n-                            log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n-                        }\n+                    Path outDirParent = outDir.getParent();\n+                    if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n+                        log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n@@ -579,2 +575,1 @@\n-        boolean lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-        if (lintOptions && source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n+        if (source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n@@ -583,1 +578,1 @@\n-                    if (baseFileManager.isDefaultBootClassPath())\n+                    if (baseFileManager.isDefaultBootClassPath()) {\n@@ -585,3 +580,3 @@\n-                } else {\n-                    if (baseFileManager.isDefaultSystemModulesPath())\n-                        log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n+                    }\n+                } else if (baseFileManager.isDefaultSystemModulesPath()) {\n+                    log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n@@ -596,1 +591,1 @@\n-        } else if (source == Source.MIN && lintOptions) {\n+        } else if (source == Source.MIN) {\n@@ -603,1 +598,1 @@\n-        } else if (target == Target.MIN && lintOptions) {\n+        } else if (target == Target.MIN) {\n@@ -637,1 +632,1 @@\n-        if (obsoleteOptionFound && lintOptions) {\n+        if (obsoleteOptionFound) {\n@@ -648,1 +643,1 @@\n-        if (lintOptions && options.isSet(Option.ADD_OPENS)) {\n+        if (options.isSet(Option.ADD_OPENS)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -261,0 +261,4 @@\n+    \/** The Lint mapper.\n+     *\/\n+    protected LintMapper lintMapper;\n+\n@@ -387,0 +391,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -578,0 +583,1 @@\n+        log.reportOutstandingWarnings();\n@@ -628,0 +634,1 @@\n+        lintMapper.startParsingFile(filename);\n@@ -647,0 +654,1 @@\n+        lintMapper.finishParsingFile(tree);\n@@ -1853,0 +1861,1 @@\n+        log.reportOutstandingWarnings();\n@@ -1926,0 +1935,1 @@\n+        lintMapper = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -86,1 +84,1 @@\n-    private final Log log;\n+    protected final Log log;\n@@ -138,7 +136,0 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n-    protected final Lint lint;\n-\n@@ -171,1 +162,0 @@\n-        this.lint = fac.lint;\n@@ -208,11 +198,0 @@\n-    \/**\n-     * Report a warning at the given position using the provided arguments.\n-     *\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n-    protected void lexWarning(int pos, JCDiagnostic.LintWarning key) {\n-        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n-        log.warning(dp, key);\n-    }\n-\n@@ -1063,11 +1042,6 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks = TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        log.warning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        log.warning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-    \/** Handler for deferred diagnostics. *\/\n-    protected final DeferredLintHandler deferredLintHandler;\n@@ -197,1 +195,0 @@\n-        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -225,1 +222,0 @@\n-        this.deferredLintHandler = parser.deferredLintHandler;\n@@ -606,2 +602,1 @@\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n+     *     dangling comments are reported to the log as warnings.\n@@ -668,6 +663,1 @@\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n+            list.forEach(c -> reportDanglingDocComment(tree, c));\n@@ -678,1 +668,1 @@\n-     * Reports an individual dangling comment using the {@link #deferredLintHandler}.\n+     * Reports an individual dangling comment as a warning to the log.\n@@ -684,1 +674,1 @@\n-    void reportDanglingDocComment(Comment c) {\n+    void reportDanglingDocComment(JCTree tree, Comment c) {\n@@ -686,8 +676,3 @@\n-        if (pos != null) {\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+        if (pos != null && !shebang(c, pos)) {\n+            pos = pos.withLintPosition(tree.getStartPosition());\n+            S.lintWarning(pos, LintWarnings.DanglingDocComment);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -106,0 +108,8 @@\n+\n+    \/**\n+     * Report a warning that is subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param key the warning to report\n+     *\/\n+    void lintWarning(DiagnosticPosition pos, LintWarning key);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -73,1 +72,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -91,1 +89,0 @@\n-        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ParserFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -153,0 +155,5 @@\n+    @Override\n+    public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+        tokenizer.log.warning(pos, key);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-    final Lint lint;\n@@ -77,1 +75,0 @@\n-        this.lint = Lint.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -170,4 +171,3 @@\n-        public void commit() {\n-            for (int i = 0 ; i < offset ; i++) {\n-                S.nextToken(); \/\/ advance underlying lexer until position matches\n-            }\n+        @Override\n+        public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+           \/\/ ignore\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-import static com.sun.tools.javac.code.Lint.LintCategory.PROCESSING;\n@@ -341,1 +339,0 @@\n-    Lint lint;\n@@ -424,2 +421,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -489,8 +484,6 @@\n-        if (lint.isEnabled(PROCESSING)) {\n-            int periodIndex = name.lastIndexOf(\".\");\n-            if (periodIndex != -1) {\n-                String base = name.substring(periodIndex);\n-                String extn = (isSourceFile ? \".java\" : \".class\");\n-                if (base.equals(extn))\n-                    log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n-            }\n+        int periodIndex = name.lastIndexOf(\".\");\n+        if (periodIndex != -1) {\n+            String base = name.substring(periodIndex);\n+            String extn = (isSourceFile ? \".java\" : \".class\");\n+            if (base.equals(extn))\n+                log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n@@ -710,1 +703,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcIllegalFileName(name));\n+            log.warning(LintWarnings.ProcIllegalFileName(name));\n@@ -738,1 +731,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeRecreate(typename));\n+            log.warning(LintWarnings.ProcTypeRecreate(typename));\n@@ -742,1 +735,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeAlreadyExists(typename));\n+            log.warning(LintWarnings.ProcTypeAlreadyExists(typename));\n@@ -771,1 +764,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcFileReopening(fileObject.getName()));\n+            log.warning(LintWarnings.ProcFileReopening(fileObject.getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-    private final Lint lint;\n@@ -209,1 +208,0 @@\n-        lint = Lint.instance(context);\n@@ -629,1 +627,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n+                       boolean allowModules, ProcessingEnvironment env) {\n@@ -650,2 +648,1 @@\n-                        add(importStringToPattern(allowModules, annotationPattern,\n-                                                  processor, log, lint));\n+                        add(importStringToPattern(allowModules, annotationPattern, processor, log));\n@@ -653,1 +650,1 @@\n-                        lint.logIfEnabled(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -666,1 +663,1 @@\n-                    lint.logIfEnabled(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -674,2 +671,1 @@\n-                            lint.logIfEnabled(LintWarnings.ProcDuplicateOptionName(optionName,\n-                                                                         p.getClass().getName()));\n+                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName, p.getClass().getName()));\n@@ -762,2 +758,1 @@\n-                                                           JavacProcessingEnvironment.this,\n-                                                           lint);\n+                                                           JavacProcessingEnvironment.this);\n@@ -891,1 +886,1 @@\n-        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n+        if (unmatchedAnnotations.size() > 0) {\n@@ -1652,1 +1647,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {\n@@ -1665,1 +1660,1 @@\n-                return warnAndNoMatches(s, p, log, lint);\n+                return warnAndNoMatches(s, p, log);\n@@ -1674,1 +1669,1 @@\n-            return warnAndNoMatches(s, p, log, lint);\n+            return warnAndNoMatches(s, p, log);\n@@ -1678,2 +1673,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n-        lint.logIfEnabled(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log) {\n+        log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1603,0 +1603,1 @@\n+# flags: default-enabled\n@@ -1927,1 +1928,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1933,1 +1934,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1939,1 +1940,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1950,1 +1951,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1962,1 +1963,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1968,1 +1969,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2205,0 +2206,1 @@\n+# flags: default-enabled\n@@ -2210,0 +2212,1 @@\n+# flags: default-enabled\n@@ -2235,0 +2238,1 @@\n+# flags: default-enabled\n@@ -2240,0 +2244,1 @@\n+# flags: default-enabled\n@@ -2252,0 +2257,1 @@\n+# flags: default-enabled\n@@ -2376,1 +2382,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2382,1 +2388,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2392,1 +2398,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2400,1 +2406,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2406,1 +2412,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2805,1 +2811,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3205,1 +3211,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3212,1 +3218,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3316,1 +3322,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3322,1 +3328,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3893,0 +3899,1 @@\n+# flags: default-enabled\n@@ -3909,0 +3916,1 @@\n+# flags: default-enabled\n@@ -4311,1 +4319,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -371,0 +371,30 @@\n+        \/** Get the position that determines which Lint configuration applies. *\/\n+        default int getLintPosition() {\n+            return getStartPosition();\n+        }\n+        \/** Create a new instance from this instance and the given lint position. *\/\n+        default DiagnosticPosition withLintPosition(int lintPos) {\n+            DiagnosticPosition orig = this;\n+            return new DiagnosticPosition() {\n+                @Override\n+                public JCTree getTree() {\n+                    return orig.getTree();\n+                }\n+                @Override\n+                public int getStartPosition() {\n+                    return orig.getStartPosition();\n+                }\n+                @Override\n+                public int getPreferredPosition() {\n+                    return orig.getPreferredPosition();\n+                }\n+                @Override\n+                public int getEndPosition(EndPosTable endPosTable) {\n+                    return orig.getEndPosition(endPosTable);\n+                }\n+                @Override\n+                public int getLintPosition() {\n+                    return lintPos;\n+                }\n+            };\n+        }\n@@ -408,0 +438,4 @@\n+        \/** Flag for lint diagnostics that should be emitted even when their category\n+         *  is not explicitly enabled, as long as it is not explicitly suppressed.\n+         *\/\n+        DEFAULT_ENABLED,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -39,0 +41,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -45,0 +48,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -47,0 +51,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -48,0 +53,3 @@\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.comp.AttrContext;\n+import com.sun.tools.javac.comp.Env;\n@@ -51,1 +59,4 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -55,0 +66,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -58,0 +70,4 @@\n+import static com.sun.tools.javac.code.Lint.LintCategory.*;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresAutomatic;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresTransitiveAutomatic;\n+import static com.sun.tools.javac.tree.JCTree.Tag.*;\n@@ -106,0 +122,5 @@\n+        \/**\n+         * Diagnostics waiting for an applicable {@link Lint} instance.\n+         *\/\n+        protected Map<JavaFileObject, List<JCDiagnostic>> lintWaitersMap = new LinkedHashMap<>();\n+\n@@ -116,1 +137,57 @@\n-         * Handle a diagnostic.\n+         * Step 1: Handle a diagnostic for which the applicable Lint instance (if any) may not be known yet.\n+         *\/\n+        public final void report(JCDiagnostic diag) {\n+            Lint lint = null;\n+            LintCategory category = diag.getLintCategory();\n+            if (category != null) {                                         \/\/ this is a lint warning; find the applicable Lint\n+                DiagnosticPosition pos = diag.getDiagnosticPosition();\n+                if (pos != null && category.annotationSuppression) {        \/\/ we should apply the Lint from the warning's position\n+                    if ((lint = lintFor(diag)) == null) {\n+                        addLintWaiter(currentSourceFile(), diag);           \/\/ ...but we don't know it yet, so defer\n+                        return;\n+                    }\n+                } else                                                      \/\/ we should apply the root Lint\n+                    lint = rootLint();\n+            }\n+            reportWithLint(diag, lint);\n+        }\n+\n+        \/**\n+         * Step 2: Handle a diagnostic for which the applicable Lint instance (if any) is known and provided.\n+         *\/\n+        public final void reportWithLint(JCDiagnostic diag, Lint lint) {\n+\n+            \/\/ Apply hackery for REQUIRES_TRANSITIVE_AUTOMATIC (see also Check.checkModuleRequires())\n+            if (diag.getCode().equals(RequiresTransitiveAutomatic.key()) && !lint.isEnabled(REQUIRES_TRANSITIVE_AUTOMATIC)) {\n+                reportWithLint(\n+                  diags.warning(null, diag.getDiagnosticSource(), diag.getDiagnosticPosition(), RequiresAutomatic), lint);\n+                return;\n+            }\n+\n+            \/\/ Apply the lint configuration (if any) and discard the warning if it gets filtered out\n+            if (lint != null) {\n+                LintCategory category = diag.getLintCategory();\n+                boolean emit = !diag.isFlagSet(DEFAULT_ENABLED) ?       \/\/ is the warning not enabled by default?\n+                  lint.isEnabled(category) :                            \/\/ then emit if the category is enabled\n+                  category.annotationSuppression ?                      \/\/ else emit if the category is not suppressed, where\n+                    !lint.isSuppressed(category) :                      \/\/ ...suppression happens via @SuppressWarnings\n+                    !options.isLintDisabled(category);                  \/\/ ...suppression happens via -Xlint:-category\n+                if (!emit)\n+                    return;\n+            }\n+\n+            \/\/ Proceed\n+            reportReady(diag);\n+        }\n+\n+        \/**\n+         * Step 3: Handle a diagnostic to which the applicable Lint instance (if any) has been applied.\n+         *\/\n+        protected abstract void reportReady(JCDiagnostic diag);\n+\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) {\n+            lintWaitersMap.computeIfAbsent(sourceFile, s -> new LinkedList<>()).add(diagnostic);\n+        }\n+\n+        \/**\n+         * Flush any lint waiters whose {@link Lint} configurations are now known.\n@@ -118,1 +195,28 @@\n-        public abstract void report(JCDiagnostic diag);\n+        public void flushLintWaiters() {\n+            lintWaitersMap.entrySet().removeIf(entry -> {\n+\n+                \/\/ Is the source file no longer recognized? If so, discard warnings (e.g., this can happen with JShell)\n+                JavaFileObject sourceFile = entry.getKey();\n+                if (!lintMapper.isKnown(sourceFile))\n+                    return true;\n+\n+                \/\/ Flush those diagnostics for which we now know the applicable Lint\n+                List<JCDiagnostic> diagnosticList = entry.getValue();\n+                JavaFileObject prevSourceFile = useSource(sourceFile);\n+                try {\n+                    diagnosticList.removeIf(diag -> {\n+                        Lint lint = lintFor(diag);\n+                        if (lint != null) {\n+                            reportWithLint(diag, lint);\n+                            return true;\n+                        }\n+                        return false;\n+                    });\n+                } finally {\n+                    useSource(prevSourceFile);\n+                }\n+\n+                \/\/ Discard list if empty\n+                return diagnosticList.isEmpty();\n+            });\n+        }\n@@ -127,1 +231,4 @@\n-        public void report(JCDiagnostic diag) { }\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) { }\n+\n+        @Override\n+        protected void reportReady(JCDiagnostic diag) { }\n@@ -160,1 +267,1 @@\n-        public void report(JCDiagnostic diag) {\n+        protected void reportReady(JCDiagnostic diag) {\n@@ -164,1 +271,10 @@\n-                prev.report(diag);\n+                prev.reportReady(diag);\n+            }\n+        }\n+\n+        @Override\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diag) {\n+            if (deferrable(diag)) {\n+                super.addLintWaiter(sourceFile, diag);\n+            } else {\n+                prev.addLintWaiter(sourceFile, diag);\n@@ -185,0 +301,7 @@\n+\n+            \/\/ Flush matching Lint waiters to the previous handler\n+            lintWaitersMap.forEach(\n+              (sourceFile, diagnostics) -> diagnostics.stream()\n+                .filter(accepter)\n+                .forEach(diagnostic -> prev.addLintWaiter(sourceFile, diagnostic)));\n+            lintWaitersMap = null; \/\/ prevent accidental ongoing use\n@@ -250,0 +373,10 @@\n+    \/**\n+     * The {@link Options} singleton.\n+     *\/\n+    private final Options options;\n+\n+    \/**\n+     * The lint positions table.\n+     *\/\n+    private final LintMapper lintMapper;\n+\n@@ -353,0 +486,2 @@\n+        this.options = Options.instance(context);\n+        this.lintMapper = LintMapper.instance(context);\n@@ -372,1 +507,0 @@\n-        final Options options = Options.instance(context);\n@@ -692,0 +826,15 @@\n+\/\/ Deferred Lint Calculation\n+\n+    \/**\n+     * Report unreported lint warnings for which the applicable {@link Lint} configuration is now known.\n+     *\/\n+    public void reportOutstandingWarnings() {\n+        diagnosticHandler.flushLintWaiters();\n+    }\n+\n+    \/\/ Get the Lint config for the given warning (if known)\n+    private Lint lintFor(JCDiagnostic diag) {\n+        Assert.check(diag.getLintCategory() != null);\n+        return lintMapper.lintAt(diag.getSource(), diag.getDiagnosticPosition()).orElse(null);\n+    }\n+\n@@ -759,1 +908,1 @@\n-        public void report(JCDiagnostic diagnostic) {\n+        protected void reportReady(JCDiagnostic diagnostic) {\n@@ -786,1 +935,1 @@\n-                    boolean verbose = rootLint().isEnabled(category);\n+                    boolean verbose = lintFor(diagnostic).isEnabled(category);\n@@ -792,1 +941,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.STRICT)) {\n+                if (diagnostic.isFlagSet(STRICT)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":159,"deletions":10,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -1464,2 +1464,1 @@\n-        case CKA_ECDSA_PARAMS:\n-            \/* CKA_EC_PARAMS is the same, these two are equivalent *\/\n+        case CKA_EC_PARAMS:\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-#define CK_ATTRIBUTES_TEMPLATE_LENGTH (CK_ULONG)61U\n+#define CK_ATTRIBUTES_TEMPLATE_LENGTH (CK_ULONG)60U\n@@ -61,0 +61,2 @@\n+\/\/ Group attributes based on their value types; put attributes whose values\n+\/\/ requiring address alignments, e.g. CK_ULONG, first\n@@ -62,7 +64,1 @@\n-        {CKA_CLASS, 0, 0},\n-        {CKA_TOKEN, 0, 0},\n-        {CKA_PRIVATE, 0, 0},\n-        {CKA_LABEL, 0, 0},\n-        {CKA_APPLICATION, 0, 0},\n-        {CKA_VALUE, 0, 0},\n-        {CKA_OBJECT_ID, 0, 0},\n+        \/\/ CK_ULONG\n@@ -70,6 +66,3 @@\n-        {CKA_ISSUER, 0, 0},\n-        {CKA_SERIAL_NUMBER, 0, 0},\n-        {CKA_AC_ISSUER, 0, 0},\n-        {CKA_OWNER, 0, 0},\n-        {CKA_ATTR_TYPES, 0, 0},\n-        {CKA_TRUSTED, 0, 0},\n+        {CKA_CLASS, 0, 0},\n+        {CKA_HW_FEATURE_TYPE, 0, 0},\n+        {CKA_KEY_GEN_MECHANISM, 0, 0},\n@@ -77,15 +70,0 @@\n-        {CKA_SUBJECT, 0, 0},\n-        {CKA_ID, 0, 0},\n-        {CKA_SENSITIVE, 0, 0},\n-        {CKA_ENCRYPT, 0, 0},\n-        {CKA_DECRYPT, 0, 0},\n-        {CKA_WRAP, 0, 0},\n-        {CKA_UNWRAP, 0, 0},\n-        {CKA_SIGN, 0, 0},\n-        {CKA_SIGN_RECOVER, 0, 0},\n-        {CKA_VERIFY, 0, 0},\n-        {CKA_VERIFY_RECOVER, 0, 0},\n-        {CKA_DERIVE, 0, 0},\n-        {CKA_START_DATE, 0, 0},\n-        {CKA_END_DATE, 0, 0},\n-        {CKA_MODULUS, 0, 0},\n@@ -93,10 +71,0 @@\n-        {CKA_PUBLIC_EXPONENT, 0, 0},\n-        {CKA_PRIVATE_EXPONENT, 0, 0},\n-        {CKA_PRIME_1, 0, 0},\n-        {CKA_PRIME_2, 0, 0},\n-        {CKA_EXPONENT_1, 0, 0},\n-        {CKA_EXPONENT_2, 0, 0},\n-        {CKA_COEFFICIENT, 0, 0},\n-        {CKA_PRIME, 0, 0},\n-        {CKA_SUBPRIME, 0, 0},\n-        {CKA_BASE, 0, 0},\n@@ -107,0 +75,5 @@\n+        \/\/ CK_BBOOL\n+        {CKA_ALWAYS_SENSITIVE, 0, 0},\n+        {CKA_DECRYPT, 0, 0},\n+        {CKA_DERIVE, 0, 0},\n+        {CKA_ENCRYPT, 0, 0},\n@@ -108,0 +81,1 @@\n+        {CKA_HAS_RESET, 0, 0},\n@@ -109,3 +83,0 @@\n-        {CKA_NEVER_EXTRACTABLE, 0, 0},\n-        {CKA_ALWAYS_SENSITIVE, 0, 0},\n-        {CKA_KEY_GEN_MECHANISM, 0, 0},\n@@ -113,1 +84,17 @@\n-        {CKA_ECDSA_PARAMS, 0, 0},\n+        {CKA_NEVER_EXTRACTABLE, 0, 0},\n+        {CKA_PRIVATE, 0, 0},\n+        {CKA_RESET_ON_INIT, 0, 0},\n+        {CKA_SENSITIVE, 0, 0},\n+        {CKA_SIGN, 0, 0},\n+        {CKA_SIGN_RECOVER, 0, 0},\n+        {CKA_TOKEN, 0, 0},\n+        {CKA_TRUSTED, 0, 0},\n+        {CKA_UNWRAP, 0, 0},\n+        {CKA_VERIFY, 0, 0},\n+        {CKA_VERIFY_RECOVER, 0, 0},\n+        {CKA_WRAP, 0, 0},\n+        \/\/ PTR: byte[]\n+        {CKA_AC_ISSUER, 0, 0},\n+        {CKA_ATTR_TYPES, 0, 0},\n+        {CKA_BASE, 0, 0},\n+        {CKA_COEFFICIENT, 0, 0},\n@@ -116,0 +103,23 @@\n+        {CKA_EXPONENT_1, 0, 0},\n+        {CKA_EXPONENT_2, 0, 0},\n+        {CKA_ID, 0, 0},\n+        {CKA_ISSUER, 0, 0},\n+        {CKA_MODULUS, 0, 0},\n+        {CKA_OBJECT_ID, 0, 0},\n+        {CKA_OWNER, 0, 0},\n+        {CKA_PRIME, 0, 0},\n+        {CKA_PRIME_1, 0, 0},\n+        {CKA_PRIME_2, 0, 0},\n+        {CKA_PRIVATE_EXPONENT, 0, 0},\n+        {CKA_PUBLIC_EXPONENT, 0, 0},\n+        {CKA_SERIAL_NUMBER, 0, 0},\n+        {CKA_SUBJECT, 0, 0},\n+        {CKA_SUBPRIME, 0, 0},\n+        {CKA_VALUE, 0, 0},\n+        \/\/ PTR: CK_UTF8CHAR[]\n+        {CKA_APPLICATION, 0, 0},\n+        {CKA_LABEL, 0, 0},\n+        \/\/ PTR: CK_DATE\n+        {CKA_START_DATE, 0, 0},\n+        {CKA_END_DATE, 0, 0},\n+        \/\/ deprecated\n@@ -118,3 +128,1 @@\n-        {CKA_HW_FEATURE_TYPE, 0, 0},\n-        {CKA_RESET_ON_INIT, 0, 0},\n-        {CKA_HAS_RESET, 0, 0},\n+        \/\/ misc\n@@ -122,0 +130,1 @@\n+        \/\/ keep this at the end to match the impl in getNativeKeyInfo(...)\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_keymgmt.c","additions":56,"deletions":47,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-        jframe.setLocationRelativeTo(null);\n@@ -100,0 +99,1 @@\n+        jframe.setLocationRelativeTo(null);\n","filename":"src\/jdk.editpad\/share\/classes\/jdk\/editpad\/EditPad.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -361,2 +361,12 @@\n-            List<? extends DocTree> ref2 = transform(tree.reference);\n-            return (equal(ref2, tree.getReference()))\n+            \/\/ Some extra work is required to accommodate various forms of @see tags, as a\n+            \/\/ leading reference affects the position of the label following it (JDK-8356411),\n+            var ref = tree.reference;\n+            var hasReference = !ref.isEmpty() && ref.getFirst().getKind() == DocTree.Kind.REFERENCE;\n+            List<DCTree> transformed = new ArrayList<>();\n+            if (hasReference) {\n+                transformed.add(ref.getFirst());\n+                transformed.addAll(transform(ref.subList(1, ref.size())));\n+            } else {\n+                transformed.addAll(transform(ref));\n+            }\n+            return (equal(ref, transformed))\n@@ -364,1 +374,1 @@\n-                    : m.at(tree.pos).newSeeTree(ref2);\n+                    : m.at(tree.pos).newSeeTree(transformed);\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/markdown\/MarkdownTransformer.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.LongFunction;\n@@ -33,1 +34,0 @@\n-import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -51,1 +51,2 @@\n-     * @param features bits specifying CPU features\n+     * @param bitMaskSupplier supplier to get the bit mask for the corresponding VM constant\n+     * @param featuresSupplier supplier to get the bits specifying CPU features\n@@ -60,1 +61,2 @@\n-                    long features,\n+                    LongFunction<Long> bitMaskSupplier,\n+                    LongFunction<Long> featuresSupplier,\n@@ -65,1 +67,1 @@\n-            long bitMask = e.getValue();\n+            long bitMask = bitMaskSupplier.apply(e.getValue());\n@@ -71,1 +73,1 @@\n-                    if ((features & bitMask) != 0) {\n+                    if ((featuresSupplier.apply(e.getValue()) & bitMask) != 0) {\n@@ -85,53 +87,0 @@\n-    \/**\n-     * Converts CPU features bit map into enum constants.\n-     *\n-     * @param <CPUFeatureType> CPU feature enum type\n-     * @param enumType the class of {@code CPUFeatureType}\n-     * @param constants VM constants. Each entry whose key starts with {@code \"VM_Version::CPU_\"}\n-     *            specifies a CPU feature and its value is a mask for a bit in {@code features}\n-     * @param featuresBitMapAddress pointer to {@code VM_Features::_features_bitmap} field of {@code VM_Version::_features}\n-     * @param featuresBitMapSize size of feature bit map in bytes\n-     * @param renaming maps from VM feature names to enum constant names where the two differ\n-     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an\n-     *             enum value\n-     * @return the set of converted values\n-     *\/\n-    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(\n-                    Class<CPUFeatureType> enumType,\n-                    Map<String, Long> constants,\n-                    long featuresBitMapAddress,\n-                    long featuresBitMapSize,\n-                    Map<String, String> renaming) {\n-        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);\n-        List<String> missing = new ArrayList<>();\n-\n-        for (Entry<String, Long> e : constants.entrySet()) {\n-            String key = e.getKey();\n-            long bitIndex = e.getValue();\n-            if (key.startsWith(\"VM_Version::CPU_\")) {\n-                String name = key.substring(\"VM_Version::CPU_\".length());\n-                try {\n-                    final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n-                    final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n-\n-                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));\n-\n-                    long featureIndex = bitIndex >>> featuresElementShiftCount;\n-                    long featureBitMask = 1L << (bitIndex & featuresElementMask);\n-                    assert featureIndex < featuresBitMapSize;\n-\n-                    long featuresElement = UNSAFE.getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n-\n-                    if ((featuresElement & featureBitMask) != 0) {\n-                        outFeatures.add(feature);\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    missing.add(name);\n-                }\n-            }\n-        }\n-        if (!missing.isEmpty()) {\n-            throw new JVMCIError(\"Missing CPU feature constants: %s\", missing);\n-        }\n-        return outFeatures;\n-    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIBackendFactory.java","additions":7,"deletions":58,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -189,1 +189,4 @@\n-                            result.getCompiler();\n+                            \/\/ EagerJVMCI only applies to JVMCI when used by the CompileBroker.\n+                            if (result.getCompilerToVM().isCompilerThread()) {\n+                                result.getCompiler();\n+                            }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> 1L << idx, _ -> config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import jdk.internal.misc.Unsafe;\n@@ -53,5 +55,9 @@\n-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class,\n-                                                                                  constants,\n-                                                                                  featuresBitMapAddress,\n-                                                                                  config.vmFeaturesFeaturesSize,\n-                                                                                  renaming);\n+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n+            return 1L << (idx & featuresElementMask);\n+        }, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            long featureIndex = idx >>> featuresElementShiftCount;\n+            return Unsafe.getUnsafe().getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n+        }, renaming);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, mask -> mask, _ -> config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -52,1 +50,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jartool\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -879,0 +879,5 @@\n+                    \/\/ If the file exists, remove it from all entries in entriesInSF\n+                    for (var signed : entriesInSF.values()) {\n+                        signed.remove(name);\n+                    }\n+\n@@ -893,3 +898,0 @@\n-                        for (var signed : entriesInSF.values()) {\n-                            signed.remove(name);\n-                        }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -423,1 +423,2 @@\n-                    file = createTemporaryFile(\"tmpJar\", \".jar\");\n+                    tmpFile = createTemporaryFile(\"tmpJar\", \".jar\");\n+                    file = tmpFile;\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -330,0 +330,2 @@\n+        copyResource(DocPaths.MOON_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.MOON_SVG), true);\n+        copyResource(DocPaths.SUN_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.SUN_SVG), true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,5 @@\n+    static final HtmlId THEME_BUTTON = HtmlId.of(\"theme-button\");\n+    static final HtmlId THEME_DARK = HtmlId.of(\"theme-dark\");\n+    static final HtmlId THEME_LIGHT = HtmlId.of(\"theme-light\");\n+    static final HtmlId THEME_OS = HtmlId.of(\"theme-os\");\n+    static final HtmlId THEME_PANEL = HtmlId.of(\"theme-panel\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+                addThemeSwitcher(target);\n@@ -151,0 +152,1 @@\n+                addThemeSwitcher(target);\n@@ -169,0 +171,1 @@\n+                addThemeSwitcher(target);\n@@ -187,0 +190,1 @@\n+                addThemeSwitcher(target);\n@@ -211,0 +215,1 @@\n+                addThemeSwitcher(target);\n@@ -229,0 +234,1 @@\n+                addThemeSwitcher(target);\n@@ -271,0 +277,1 @@\n+                addThemeSwitcher(target);\n@@ -288,0 +295,1 @@\n+                addThemeSwitcher(target);\n@@ -314,0 +322,1 @@\n+                addThemeSwitcher(target);\n@@ -320,4 +329,0 @@\n-    private void addContentToList(List<Content> listContents, Content source) {\n-        listContents.add(HtmlTree.LI(source));\n-    }\n-\n@@ -495,0 +500,11 @@\n+    private void addThemeSwitcher(Content target) {\n+        var selectTheme = contents.getContent(\"doclet.theme.select_theme\");\n+        target.add(HtmlTree.LI(HtmlTree.BUTTON(HtmlIds.THEME_BUTTON)\n+                .add(HtmlTree.IMG(pathToRoot.resolve(DocPaths.RESOURCE_FILES).resolve(DocPaths.SUN_SVG),\n+                        selectTheme.toString()).addStyle(HtmlIds.THEME_LIGHT.name()))\n+                .add(HtmlTree.IMG(pathToRoot.resolve(DocPaths.RESOURCE_FILES).resolve(DocPaths.MOON_SVG),\n+                        selectTheme.toString()).addStyle(HtmlIds.THEME_DARK.name()))\n+                .put(HtmlAttr.ARIA_LABEL, selectTheme.toString())\n+                .put(HtmlAttr.TITLE, selectTheme.toString())));\n+    }\n+\n@@ -548,0 +564,1 @@\n+\n@@ -560,0 +577,16 @@\n+        var selectTheme = contents.getContent(\"doclet.theme.select_theme\");\n+        subNavContent.add(HtmlTree.DIV(HtmlIds.THEME_PANEL)\n+                .add(HtmlTree.DIV(selectTheme))\n+                .add(HtmlTree.DIV(HtmlTree.LABEL(HtmlIds.THEME_LIGHT.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_LIGHT)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_LIGHT.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.light\"))))\n+                        .add(HtmlTree.LABEL(HtmlIds.THEME_DARK.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_DARK)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_DARK.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.dark\"))))\n+                        .add(HtmlTree.LABEL(HtmlIds.THEME_OS.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_OS)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_OS.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.system\"))))));\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -11,3 +11,3 @@\n-    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"baseline-shift:baseline;display:inline;overflow:visible;opacity:1;vector-effect:none;fill:#1a73a8;stop-color:#000;stop-opacity:1\"\/>\n-    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;fill-opacity:1;stroke:#1a73a8;stroke-width:8;stroke-dasharray:none;stroke-opacity:1\"\/>\n-<\/svg>\n\\ No newline at end of file\n+    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"fill:#1a73a8\"\/>\n+    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;stroke:#1a73a8;stroke-width:8\"\/>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/glass.svg","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,185 @@\n+body.theme-dark {\n+    .hljs-title.function_,\n+    .hljs-template-variable {\n+        color: #66bcce;\n+    }\n+    .hljs-code,\n+    .hljs-comment,\n+    .hljs-quote {\n+        color:#9d9d9d;\n+        font-style: italic;\n+    }\n+    .hljs-meta {\n+        color: #836F00;\n+    }\n+    .hljs-symbol,\n+    .hljs-template-tag,\n+    .hljs-keyword,\n+    .hljs-literal,\n+    .hljs-name,\n+    .hljs-built_in,\n+    .hljs-char.escape_ {\n+        color: #88aece;\n+    }\n+    .hljs-variable,\n+    .hljs-property,\n+    .hljs-attr,\n+    .hljs-section {\n+        color: #c59bc1;\n+    }\n+    .hljs-attribute {\n+        color:  #c59bc1;\n+    }\n+    .hljs-regexp,\n+    .hljs-number {\n+        color: #cfe374;\n+    }\n+    .hljs-link {\n+        color: #b5bd68;\n+    }\n+    .hljs-string {\n+        color: #b5bd68;\n+    }\n+    .hljs-doctag {\n+        text-decoration: underline;\n+    }\n+    .hljs-emphasis {\n+        font-style: italic;\n+    }\n+    .hljs-strong {\n+        font-weight: bold;\n+    }\n+    .hljs-subst,\n+    .hljs-title,\n+    .hljs-params,\n+    .hljs-bullet,\n+    .hljs-formula,\n+    .hljs-tag,\n+    .hljs-type {\n+        \/* ignored *\/\n+    }\n+}\n+\n+@media (prefers-color-scheme: dark) {\n+    .hljs-title.function_,\n+    .hljs-template-variable {\n+        color: #66bcce;\n+    }\n+    .hljs-code,\n+    .hljs-comment,\n+    .hljs-quote {\n+        color:#9d9d9d;\n+        font-style: italic;\n+    }\n+    .hljs-meta {\n+        color: #836F00;\n+    }\n+    .hljs-symbol,\n+    .hljs-template-tag,\n+    .hljs-keyword,\n+    .hljs-literal,\n+    .hljs-name,\n+    .hljs-built_in,\n+    .hljs-char.escape_ {\n+        color: #88aece;\n+    }\n+    .hljs-variable,\n+    .hljs-property,\n+    .hljs-attr,\n+    .hljs-section {\n+        color: #c59bc1;\n+    }\n+    .hljs-attribute {\n+        color:  #c59bc1;\n+    }\n+    .hljs-regexp,\n+    .hljs-number {\n+        color: #cfe374;\n+    }\n+    .hljs-link {\n+        color: #b5bd68;\n+    }\n+    .hljs-string {\n+        color: #b5bd68;\n+    }\n+    .hljs-doctag {\n+        text-decoration: underline;\n+    }\n+    .hljs-emphasis {\n+        font-style: italic;\n+    }\n+    .hljs-strong {\n+        font-weight: bold;\n+    }\n+    .hljs-subst,\n+    .hljs-title,\n+    .hljs-params,\n+    .hljs-bullet,\n+    .hljs-formula,\n+    .hljs-tag,\n+    .hljs-type {\n+        \/* ignored *\/\n+    }\n+\n+    body.theme-light {\n+        .hljs-title.function_,\n+        .hljs-template-variable {\n+            color: #00738F;\n+        }\n+        .hljs-code,\n+        .hljs-comment,\n+        .hljs-quote {\n+            color: #6e6e71;\n+            font-style: italic;\n+        }\n+        .hljs-meta {\n+            color: #836F00;\n+        }\n+        .hljs-symbol,\n+        .hljs-template-tag,\n+        .hljs-keyword,\n+        .hljs-literal,\n+        .hljs-name,\n+        .hljs-built_in,\n+        .hljs-char.escape_ {\n+            color: #0C40C2;\n+        }\n+        .hljs-variable,\n+        .hljs-property,\n+        .hljs-attr,\n+        .hljs-section {\n+            color: #841191;\n+        }\n+        .hljs-attribute {\n+            color: #164ad9;\n+        }\n+        .hljs-regexp,\n+        .hljs-number {\n+            color: #104BEB;\n+        }\n+        .hljs-link {\n+            color: #47688a;\n+        }\n+        .hljs-string {\n+            color: #008313;\n+        }\n+        .hljs-doctag {\n+            text-decoration: underline;\n+        }\n+        .hljs-emphasis {\n+            font-style: italic;\n+        }\n+        .hljs-strong {\n+            font-weight: bold;\n+        }\n+        .hljs-subst,\n+        .hljs-title,\n+        .hljs-params,\n+        .hljs-bullet,\n+        .hljs-formula,\n+        .hljs-tag,\n+        .hljs-type {\n+            \/* ignored *\/\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/highlight.css","additions":185,"deletions":0,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg version=\"1.1\" viewBox=\"0 0 100 100\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <g fill=\"none\" stroke=\"#fff\" stroke-linecap=\"round\">\n+        <path d=\"m34.834 21.49a29.94 29.94 0 0 1 33.103 12.994 29.94 29.94 0 0 1-2.6651 35.462 29.94 29.94 0 0 1-34.674 7.9004\" stroke-width=\"7.6\"\/>\n+        <path d=\"m35.411 22.187a42.812 42.812 0 0 1-4.6466 55.023\" stroke-width=\"7.6892\"\/>\n+    <\/g>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/moon.svg","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -331,1 +331,0 @@\n-    \/\/ Make sure current element is visible in breadcrumb navigation on small displays\n@@ -333,3 +332,0 @@\n-    if (subnav && subnav.lastElementChild) {\n-        subnav.lastElementChild.scrollIntoView({ behavior: \"instant\", inline: \"start\", block: \"nearest\" });\n-    }\n@@ -354,0 +350,43 @@\n+    const themeButton = document.querySelector(\"button#theme-button\");\n+    const themePanel = document.querySelector(\"div#theme-panel\");\n+    var themePanelVisible = false;\n+    themeButton.addEventListener(\"click\", e => {\n+        if (!themePanelVisible) {\n+            let {x, y} = themeButton.getBoundingClientRect();\n+            themePanel.style.display = \"block\";\n+            if (window.innerHeight - 85 < y) {\n+                themePanel.style.top = \"\";\n+                themePanel.style.bottom = \"4px\";\n+            } else {\n+                themePanel.style.top = y + (expanded ? 0 : 36) + \"px\";\n+                themePanel.style.bottom = \"\";\n+            }\n+            themePanel.style.left = x + (expanded ? 36 : 0) + \"px\";\n+            themeButton.setAttribute(\"aria-expanded\", \"true\");\n+            themePanelVisible = true;\n+            e.stopPropagation();\n+        }\n+    });\n+    function closeThemePanel(e) {\n+        if (themePanelVisible && (!e || !themePanel.contains(e.target))) {\n+            themePanel.style.removeProperty(\"display\");\n+            themeButton.setAttribute(\"aria-expanded\", \"false\");\n+            themePanelVisible = false;\n+        }\n+    }\n+    themePanel.querySelectorAll(\"input\").forEach(input => {\n+        input.removeAttribute(\"disabled\");\n+        input.addEventListener(\"change\", e => {\n+            setTheme(e.target.value);\n+        })\n+    });\n+    const THEMES = [\"theme-light\", \"theme-dark\", \"theme-os\"];\n+    function setTheme(theme) {\n+        THEMES.forEach(t => {\n+            if (t !== theme) document.body.classList.remove(t);\n+        });\n+        document.body.classList.add(theme);\n+        localStorage.setItem(\"theme\", theme);\n+        document.getElementById(theme).checked = true;\n+    }\n+    setTheme(localStorage.getItem(\"theme\") || THEMES[0]);\n@@ -365,0 +404,1 @@\n+            closeThemePanel();\n@@ -373,0 +413,1 @@\n+            closeThemePanel();\n@@ -392,0 +433,1 @@\n+        closeThemePanel();\n@@ -406,0 +448,1 @@\n+        closeThemePanel();\n@@ -460,0 +503,1 @@\n+    document.querySelector(\"body\").addEventListener(\"click\", closeThemePanel);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -426,1 +426,2 @@\n-            .append($(\"<div\/>\")\n+            .append($(\"<a\/>\")\n+                .attr(\"href\", item.indexItem ? pathtoroot + getURL(item.indexItem, item.category) : null)\n@@ -518,1 +519,1 @@\n-            }, 1000);\n+            }, 500);\n@@ -534,0 +535,5 @@\n+            for (var e = event.originalEvent; e != null; e = e.originalEvent) {\n+                if (e.type === \"click\") {\n+                    return;\n+                }\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/search.js.template","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -196,0 +196,4 @@\n+doclet.theme.select_theme=Select Theme\n+doclet.theme.light=Light\n+doclet.theme.dark=Dark\n+doclet.theme.system=System Setting\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,22 @@\n+    \/* Navigation bar and content area dimensions *\/\n+    --top-nav-height: 44px;\n+    --sub-nav-height: 36px;\n+    --nav-height: calc(var(--top-nav-height) + var(--sub-nav-height));\n+    --max-content-width: 1500px;\n+    --content-margin: 0 auto;\n+    \/* Inline SVG icons for dark theme *\/\n+    --right-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"100\" height=\"100\"> \\\n+    <path d=\"m35.763 5.058 38.675 36.885a12.596 12.596 90 0 1 0 18.23L35.763 97.058v-18.32l27.055-25.431a2.975 2.975 90.09 0 0 .007-4.33L35.763 23.38Z\" \\\n+    style=\"fill:%23fff;stroke-width:.285806\" transform=\"translate(-5.292 -1.058)\"\/> \\\n+    <\/svg>');\n+    --glass-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\"> \\\n+    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"fill:%23a1d3ff\"\/>\\\n+    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;stroke:%23a1d3ff;stroke-width:8\"\/><\/svg>');\n+    --x-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\">\\\n+    <path d=\"m8 8 84 84\" style=\"stroke:%23e0e0e0;stroke-width:15\"\/>\\\n+    <path d=\"M8 92 92 8\" style=\"stroke:%23e0e0e0;stroke-width:15\"\/><\/svg>');\n+}\n+body {\n@@ -37,1 +59,1 @@\n-    --detail-background-color: #ffffff;\n+    --detail-background-color: var(--body-background-color);\n@@ -79,1 +101,1 @@\n-    --search-input-placeholder-color: #909090;\n+    --search-input-placeholder-color: #757575;\n@@ -81,1 +103,2 @@\n-    --search-tag-highlight-color: #ffff66;\n+    --search-tag-background-color: #ffff66;\n+    --search-tag-text-color: var(--block-text-color);\n@@ -89,6 +112,152 @@\n-    \/* Navigation bar dimensions *\/\n-    --top-nav-height: 44px;\n-    --sub-nav-height: 36px;\n-    --nav-height: calc(var(--top-nav-height) + var(--sub-nav-height));\n-    --max-content-width: 1500px;\n-    --content-margin: 0 auto;\n+}\n+\n+body.theme-dark {\n+    --body-text-color: #e8e8e8;\n+    --block-text-color: #e8e8e8;\n+    --body-background-color: #222528;\n+    --section-background-color: var(--body-background-color);\n+    --detail-background-color: var(--body-background-color);\n+    --code-background-color: #303940;\n+    --mark-background-color: #313131;\n+    --detail-block-color: #f4f4f4;\n+    --navbar-background-color: #395A6F;\n+    --navbar-text-color: #ffffff;\n+    --subnav-background-color: #3d454d;\n+    --subnav-link-color: #d8dcdf;\n+    --member-heading-background-color: var(--subnav-background-color);\n+    --selected-background-color: #f8981d;\n+    --selected-text-color: #253441;\n+    --selected-link-color: #4a698a;\n+    --table-header-color: #38444d;\n+    --even-row-color: #222528;\n+    --odd-row-color: #2d3135;\n+    --title-color: #fff;\n+    --link-color: #94badb;\n+    --link-color-active: #ffb45b;\n+    --toc-background-color: #31363c;\n+    --toc-highlight-color: var(--subnav-background-color);\n+    --toc-hover-color: #3f4146;\n+    --snippet-background-color: #2d363c;\n+    --snippet-text-color: var(--block-text-color);\n+    --snippet-highlight-color: #f7c590;\n+    --pre-background-color: var(--snippet-background-color);\n+    --pre-text-color: var(--snippet-text-color);\n+    --border-color: #444444;\n+    --table-border-color: #717171;\n+    --tab-border-radius: 2px 2px 0 0;\n+    --search-input-background-color: #303030;\n+    --search-input-text-color: #d0d0d0;\n+    --search-input-placeholder-color: #979797;\n+    --search-tag-background-color: #c6c61e;\n+    --search-tag-text-color: #282828;\n+    --button-border-color: #909090;\n+    --button-active-filter: brightness(96%);\n+    --button-focus-filter: brightness(104%);\n+    --invalid-tag-background-color: #ffe6e6;\n+    --invalid-tag-text-color: #000000;\n+    div.main-grid img {\n+        filter: invert(100%) brightness(160%);\n+    }\n+}\n+\n+\/*\n+ * Dark theme\n+ *\/\n+@media (prefers-color-scheme: dark) {\n+    body {\n+        --body-text-color: #e8e8e8;\n+        --block-text-color: #e8e8e8;\n+        --body-background-color: #222528;\n+        --section-background-color: var(--body-background-color);\n+        --detail-background-color: var(--body-background-color);\n+        --code-background-color: #303940;\n+        --mark-background-color: #313131;\n+        --detail-block-color: #f4f4f4;\n+        --navbar-background-color: #395A6F;\n+        --navbar-text-color: #ffffff;\n+        --subnav-background-color: #3d454d;\n+        --subnav-link-color: #d8dcdf;\n+        --member-heading-background-color: var(--subnav-background-color);\n+        --selected-background-color: #f8981d;\n+        --selected-text-color: #253441;\n+        --selected-link-color: #4a698a;\n+        --table-header-color: #38444d;\n+        --even-row-color: #222528;\n+        --odd-row-color: #2d3135;\n+        --title-color: #fff;\n+        --link-color: #94badb;\n+        --link-color-active: #ffb45b;\n+        --toc-background-color: #31363c;\n+        --toc-highlight-color: var(--subnav-background-color);\n+        --toc-hover-color: #3f4146;\n+        --snippet-background-color: #2d363c;\n+        --snippet-text-color: var(--block-text-color);\n+        --snippet-highlight-color: #f7c590;\n+        --pre-background-color: var(--snippet-background-color);\n+        --pre-text-color: var(--snippet-text-color);\n+        --border-color: #444444;\n+        --table-border-color: #717171;\n+        --tab-border-radius: 2px 2px 0 0;\n+        --search-input-background-color: #303030;\n+        --search-input-text-color: #d0d0d0;\n+        --search-input-placeholder-color: #979797;\n+        --search-tag-background-color: #c6c61e;\n+        --search-tag-text-color: #282828;\n+        --button-border-color: #909090;\n+        --button-active-filter: brightness(96%);\n+        --button-focus-filter: brightness(104%);\n+        --invalid-tag-background-color: #ffe6e6;\n+        --invalid-tag-text-color: #000000;\n+        div.main-grid img {\n+            filter: invert(100%) brightness(160%);\n+        }\n+    }\n+\n+    body.theme-light {\n+        --body-text-color: #282828;\n+        --block-text-color: #282828;\n+        --body-background-color: #ffffff;\n+        --section-background-color: var(--body-background-color);\n+        --detail-background-color: var(--body-background-color);\n+        --code-background-color: #f5f5f5;\n+        --mark-background-color: #f7f7f7;\n+        --detail-block-color: #f4f4f4;\n+        --navbar-background-color: #4D7A97;\n+        --navbar-text-color: #ffffff;\n+        --subnav-background-color: #dee3e9;\n+        --subnav-link-color: #47688a;\n+        --member-heading-background-color: var(--subnav-background-color);\n+        --selected-background-color: #f8981d;\n+        --selected-text-color: #253441;\n+        --selected-link-color: #4a698a;\n+        --table-header-color: #ebeff4;\n+        --even-row-color: #ffffff;\n+        --odd-row-color: #f0f0f2;\n+        --title-color: #2c4557;\n+        --link-color: #437291;\n+        --link-color-active: #bb7a2a;\n+        --toc-background-color: #f8f8f8;\n+        --toc-highlight-color: var(--subnav-background-color);\n+        --toc-hover-color: #e9ecf0;\n+        --snippet-background-color: #f2f2f4;\n+        --snippet-text-color: var(--block-text-color);\n+        --snippet-highlight-color: #f7c590;\n+        --pre-background-color: var(--snippet-background-color);\n+        --pre-text-color: var(--snippet-text-color);\n+        --border-color: #e6e6e6;\n+        --table-border-color: #000000;\n+        --tab-border-radius: 2px 2px 0 0;\n+        --search-input-background-color: #ffffff;\n+        --search-input-text-color: #000000;\n+        --search-input-placeholder-color: #757575;\n+        --search-tag-background-color: #ffff66;\n+        --search-tag-text-color: var(--block-text-color);\n+        --button-border-color: #b0b8c8;\n+        --button-active-filter: brightness(96%);\n+        --button-focus-filter: brightness(104%);\n+        --invalid-tag-background-color: #ffe6e6;\n+        --invalid-tag-text-color: #000000;\n+        div.main-grid img {\n+            filter: none;\n+        }\n+    }\n@@ -189,1 +358,1 @@\n-    padding:0 20px;\n+    padding:0 20px 0 10px;\n@@ -218,0 +387,1 @@\n+    position: relative;\n@@ -239,0 +409,62 @@\n+button#theme-button {\n+    position: relative;\n+    top: -9.5px;\n+    width: 32px;\n+    height: 32px;\n+    padding: 6px;\n+    margin-left: -6px;\n+    background-color: transparent;\n+    border: 1px solid transparent;\n+    border-radius: 6px;\n+    cursor: pointer;\n+}\n+button#theme-button:hover,\n+button#theme-button:focus-visible {\n+    border: 1px solid var(--button-border-color);\n+}\n+button#theme-button img {\n+    display: none;\n+    width: 18px;\n+}\n+body.theme-light button#theme-button img.theme-light {\n+    display: inline;\n+}\n+body.theme-dark button#theme-button img.theme-dark {\n+    display: inline;\n+}\n+@media (prefers-color-scheme: dark) {\n+    body.theme-os button#theme-button img.theme-dark {\n+        display: inline;\n+    }\n+}\n+@media (prefers-color-scheme: light) {\n+    body.theme-os button#theme-button img.theme-light {\n+        display: inline;\n+    }\n+}\n+div#theme-panel {\n+    display: none;\n+    position: fixed;\n+    z-index: 8;\n+    background-color: var(--toc-background-color);\n+    color: var(--body-text-color);\n+    padding: 4px;\n+    white-space: nowrap;\n+    border: 1px solid var(--border-color);\n+    border-radius: 4px;\n+    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n+}\n+div#theme-panel div:first-child {\n+    font-weight: bold;\n+    font-size: 16px;\n+}\n+div#theme-panel div {\n+    padding: 8px;\n+}\n+div#theme-panel label {\n+    margin-right: 8px;\n+    cursor: pointer;\n+}\n+div#theme-panel input {\n+    margin-right: 4px;\n+}\n@@ -255,1 +487,0 @@\n-    overflow:hidden;\n@@ -257,1 +488,1 @@\n-    height: var(--sub-nav-height);\n+    min-height: var(--sub-nav-height);\n@@ -261,2 +492,1 @@\n-    line-height: 1.8;\n-    display: inline-flex;\n+    line-height: 1.7;\n@@ -264,3 +494,0 @@\n-    scroll-snap-type: x mandatory;\n-    scroll-padding-left: 13px;\n-    scrollbar-width: none;\n@@ -268,2 +495,2 @@\n-    white-space: nowrap;\n-    margin:0;\n+    margin: 4px 0;\n+    min-height: 28px;\n@@ -276,1 +503,3 @@\n-    scroll-snap-align: start;\n+    display: inline-block;\n+    padding: 2px 0;\n+    margin-right: -4px;\n@@ -284,0 +513,11 @@\n+body.theme-dark ol.sub-nav-list li:not(:first-child) {\n+    background-image: var(--right-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    ol.sub-nav-list li:not(:first-child) {\n+        background-image: var(--right-svg-dark);\n+    }\n+    body.theme-light ol.sub-nav-list li:not(:first-child) {\n+        background-image: url(\"right.svg\");\n+    }\n+}\n@@ -293,1 +533,2 @@\n-    margin: 0 15px;\n+    margin: 4.5px 15px auto 5px;\n+    padding: 1px 0;\n@@ -365,1 +606,1 @@\n-    filter: invert(100%) sepia(4%) saturate(98%) hue-rotate(212deg) brightness(160%) contrast(160%);\n+    filter: invert(100%) brightness(160%);\n@@ -997,1 +1238,1 @@\n-.ui-autocomplete > li > div {\n+.ui-autocomplete > li > a {\n@@ -1001,1 +1242,1 @@\n-.ui-autocomplete > li.result-item > div {\n+.ui-autocomplete > li.result-item > a {\n@@ -1012,0 +1253,1 @@\n+    color: var(--block-text-color);\n@@ -1018,1 +1260,1 @@\n-    color: #404040;\n+    color: var(--block-text-color);\n@@ -1025,0 +1267,1 @@\n+.ui-menu .ui-state-active .search-result-label,\n@@ -1026,1 +1269,1 @@\n-    color: #383838;\n+    color: var(--selected-text-color);\n@@ -1045,0 +1288,11 @@\n+body.theme-dark input[type=\"text\"] {\n+    background-image: var(--glass-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    input[type=\"text\"] {\n+        background-image: var(--glass-svg-dark);\n+    }\n+    body.theme-light input[type=\"text\"] {\n+        background-image: url('glass.svg');\n+    }\n+}\n@@ -1072,0 +1326,15 @@\n+body.theme-dark input#reset-search,\n+body.theme-dark input.reset-filter,\n+body.theme-dark input#page-search-reset {\n+    background-image: var(--x-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    input#reset-search, input.reset-filter, input#page-search-reset {\n+        background-image: var(--x-svg-dark);\n+    }\n+    body.theme-light input#reset-search,\n+    body.theme-light input.reset-filter,\n+    body.theme-light input#page-search-reset {\n+        background-image: url('x.svg');\n+    }\n+}\n@@ -1104,0 +1373,1 @@\n+    color: #282828;\n@@ -1112,1 +1382,2 @@\n-    background-color:var(--search-tag-highlight-color);\n+    background-color:var(--search-tag-background-color);\n+    color:var(--search-tag-text-color);\n@@ -1116,1 +1387,2 @@\n-    background-color: var(--search-tag-highlight-color);\n+    background-color: var(--search-tag-background-color);\n+    color:var(--search-tag-text-color);\n@@ -1163,0 +1435,1 @@\n+    color: var(--selected-text-color);\n@@ -1171,1 +1444,0 @@\n-    color: #404040;\n@@ -1505,11 +1777,0 @@\n-    nav.toc a:link, nav.toc a:visited {\n-        text-decoration:none;\n-        color:var(--link-color);\n-    }\n-    nav.toc a[href]:hover, nav.toc a[href]:focus {\n-        text-decoration:none;\n-        color:var(--link-color-active);\n-    }\n-    :root {\n-        scroll-behavior: auto;\n-    }\n@@ -1587,1 +1848,1 @@\n-    .ui-autocomplete > li > div,\n+    .ui-autocomplete > li > a,\n@@ -1589,1 +1850,1 @@\n-    .ui-autocomplete > li.result-item > div {\n+    .ui-autocomplete > li.result-item > a {\n@@ -1606,1 +1867,0 @@\n-        padding: 0 16px;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":303,"deletions":43,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg version=\"1.1\" viewBox=\"0 0 100 100\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <g fill=\"none\" stroke=\"#fff\" stroke-linecap=\"round\">\n+        <circle cx=\"49.932\" cy=\"50.193\" r=\"24.947\" stroke-width=\"7.6\"\/>\n+        <path d=\"m50.882 5.5255v10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m24.315 74.134-7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m75.461 73.989 7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m18.223 16.442c7.6524 7.6524 7.6524 7.6524 7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m83.27 19.68-7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m50.014 84.417v10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m95.53 49.53h-10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m15.446 49.162h-10.822\" stroke-width=\"7.533\"\/>\n+    <\/g>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/sun.svg","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -11,3 +11,3 @@\n-    <path d=\"m8 8 84 84\" style=\"fill:#c6c6c6;fill-opacity:1;stroke:#505050;stroke-width:15;stroke-dasharray:none;stroke-opacity:1\"\/>\n-    <path d=\"M8 92 92 8\" style=\"fill:#000;stroke:#505050;stroke-width:15;stroke-dasharray:none;stroke-opacity:1\"\/>\n-<\/svg>\n\\ No newline at end of file\n+    <path d=\"m8 8 84 84\" style=\"stroke:#505050;stroke-width:15\"\/>\n+    <path d=\"M8 92 92 8\" style=\"stroke:#505050;stroke-width:15\"\/>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/x.svg","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,0 +118,6 @@\n+    \/** The name of the moon icon for the dark theme. *\/\n+    public static final DocPath MOON_SVG = DocPath.create(\"moon.svg\");\n+\n+    \/** The name of the sun icon for the light theme. *\/\n+    public static final DocPath SUN_SVG = DocPath.create(\"sun.svg\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+        RADIO,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlAttr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -589,2 +589,1 @@\n-        return new HtmlTree(HtmlTag.FOOTER)\n-                .setRole(HtmlAttr.Role.CONTENTINFO);\n+        return new HtmlTree(HtmlTag.FOOTER);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlTree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -65,1 +63,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,2 +405,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM was unable to pop the frames.\n+     * @throws OpaqueFrameException if the target VM is unable to pop this frame\n+     * (e.g. a virtual thread is suspended, but not at an event).\n@@ -487,2 +487,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM is unable to force the method to return.\n+     * @throws OpaqueFrameException if the target VM is unable to force the method to return\n+     * (e.g. a virtual thread is suspended, but not at an event).\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,16 +398,13 @@\n-                if (thread.isVirtual()) {\n-                    \/\/ We first need to find out if the current frame is native, or if the\n-                    \/\/ previous frame is native, in which case we throw NativeMethodException\n-                    for (int i = 0; i < 2; i++) {\n-                        StackFrameImpl sf;\n-                        try {\n-                            sf = (StackFrameImpl)thread.frame(i);\n-                        } catch (IndexOutOfBoundsException e) {\n-                            \/\/ This should never happen, but we need to check for it.\n-                            break;\n-                        }\n-                        sf.validateStackFrame();\n-                        MethodImpl meth = (MethodImpl)sf.location().method();\n-                        if (meth.isNative()) {\n-                            throw new NativeMethodException();\n-                        }\n+                \/\/ We first need to find out if the current frame is native, or if the\n+                \/\/ previous frame is native, in which case we throw NativeMethodException\n+                for (int i = 0; i < 2; i++) {\n+                    StackFrame sf;\n+                    try {\n+                        sf = thread.frame(i);\n+                    } catch (IndexOutOfBoundsException e) {\n+                        \/\/ This should never happen, but we need to check for it.\n+                        break;\n+                    }\n+                    Method meth = sf.location().method();\n+                    if (meth.isNative()) {\n+                        throw new NativeMethodException();\n@@ -415,5 +412,0 @@\n-                    \/\/ No native frames involved. Must have been due to thread\n-                    \/\/ not being mounted.\n-                    throw new OpaqueFrameException();\n-                } else {\n-                    throw new NativeMethodException();\n@@ -421,0 +413,3 @@\n+                \/\/ No native frames involved. Must have been due to virtual thread\n+                \/\/ not being mounted or some other reason such as failure to deopt.\n+                throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/StackFrameImpl.java","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -600,3 +600,1 @@\n-                if (isVirtual() && !meth.isNative()) {\n-                    throw new OpaqueFrameException();\n-                } else {\n+                if (meth.isNative()) {\n@@ -604,0 +602,2 @@\n+                } else {\n+                    throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ThreadReferenceImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                descriptors.add(String.valueOf(object));\n+                values.add(String.valueOf(object));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/AnnotationElement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-     * Returns the settings that specifies how a recording is configured.\n+     * Returns the settings that specify how a recording is configured.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Configuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * @return {@code true} if by default the event should be enabled by default, {@code false} otherwise\n+     * @return {@code true} if by default the event should be enabled, {@code false} otherwise\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Enabled.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-            label = platformEventType.getLabel();;\n+            label = platformEventType.getLabel();\n@@ -229,1 +229,1 @@\n-     * Returns the list of human-readable names that makes up the categories for\n+     * Returns the list of human-readable names that make up the categories for\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-     * This method is also be invoked when a listener is added to an already\n+     * This method is also invoked when a listener is added to an already\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderListener.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * The following example shows how configure, start, stop and dump recording data to disk.\n+ * The following example shows how to configure, start, stop and dump recording data to disk.\n@@ -141,1 +141,1 @@\n-     * @param configuration configuration that contains the settings to be use, not\n+     * @param configuration configuration that contains the settings to be used, not\n@@ -342,1 +342,1 @@\n-     * with the {@link #setMaxAge(Duration)} method and the {@link #setMaxSize(long)}method.\n+     * with the {@link #setMaxAge(Duration)} method and the {@link #setMaxSize(long)} method.\n@@ -618,1 +618,1 @@\n-     * If multiple events with same name (for example, the same class is loaded\n+     * If multiple events with the same name (for example, the same class is loaded\n@@ -620,1 +620,1 @@\n-     * name is disabled. To disable a specific class, use the\n+     * name are disabled. To disable a specific class, use the\n@@ -656,1 +656,1 @@\n-     * @param eventClass the event to enable, not {@code null}\n+     * @param eventClass the event to disable, not {@code null}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Recording.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-     * Specifies that events arrives in chronological order, sorted by the time\n+     * Specifies that events arrive in chronological order, sorted by the time\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-     * @return an immutable list of added event types, not {@code null}\n+     * @return an immutable list of removed event types, not {@code null}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/MetadataEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-     * Returns the class this method belongs to, if it belong to a Java frame.\n+     * Returns the class this method belongs to, if it belongs to a Java frame.\n@@ -102,1 +102,1 @@\n-     * expressions).\n+     * expression).\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-        if (object == null || object.getClass().isAssignableFrom(clazz)) {\n+        if (object == null || object.getClass() == clazz) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * The following example shows how read and print all events in a recording file.\n+ * The following example shows how to read and print all events in a recording file.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,2 +235,2 @@\n-     * If neither maximum limit or the maximum age is set, the size of the\n-     * recording may grow indefinitely if events are on\n+     * If neither the maximum limit nor the maximum age is set, the size of the\n+     * recording may grow indefinitely if events are not consumed.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * parameters is passed to a method that throws other exceptions, such as\n+ * parameter is passed to a method that throws other exceptions, such as\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            eventType.setThrottler(new Throttler(eventType));\n+            eventType.setThrottler(new Throttler());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                list.add(o);\n+                list.add(o == NULL_OBJECT ? null : o);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LongMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.jfr.events.ActiveSettingEvent;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.jfr.FlightRecorderPermission;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PrivateAccess.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.file.Paths;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ChunkFilename.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.jfr.internal.MetadataRepository;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/FlushTask.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+        @SuppressWarnings({ \"unchecked\"})\n@@ -61,2 +61,2 @@\n-            if (keys instanceof Set set) {\n-                set.add(o);\n+            if (keys instanceof Set<?> set) {\n+                ((Set<Object>) set).add(o);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Histogram.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.BiConsumer;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryParser.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,3 +43,3 @@\n-         SELECT E.id, LAST_BATCH(E.value), LAST_BATCH(T.value),\n-                LAST_BATCH(S.value), LAST_BATCH(P.value),\n-                LAST_BATCH(C.value), LAST_BATCH(U.value)\n+         SELECT E.id, LAST(E.value), LAST(T.value),\n+                LAST(S.value), LAST(P.value),\n+                LAST(C.value), LAST(U.value)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,0 @@\n-import static jdk.jfr.internal.util.TimespanUnit.SECONDS;\n-import static jdk.jfr.internal.util.TimespanUnit.MILLISECONDS;\n-\n@@ -44,1 +41,0 @@\n-import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CPUThrottleSetting.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private volatile static boolean initialized;\n+    private static volatile boolean initialized;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/MethodSetting.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-    public Throttler(PlatformEventType t) {\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/Throttler.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    public static <T> Predicate<T> matchAny(List<Predicate<T>> filters) {\n+    public static <T> Predicate<T> matchAll(List<Predicate<T>> filters) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,1 +206,1 @@\n-                filter =  Filters.matchAny(filters);\n+                filter = Filters.matchAll(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Array;\n@@ -294,1 +295,1 @@\n-                printValue(frame, null, \"\");\n+                printJavaFrame(frame, \"\");\n@@ -326,1 +327,1 @@\n-    private void printArray(Object[] array) {\n+    private void printArray(Object[] array, ValueDescriptor field) {\n@@ -331,1 +332,1 @@\n-            printValue(array[i], null, i + 1 < array.length ? \", \" : \"\");\n+            printValue(array[i], field, i + 1 < array.length ? \", \" : \"\");\n@@ -339,37 +340,9 @@\n-        if (value == null) {\n-            println(\"N\/A\" + postFix);\n-            return;\n-        }\n-        if (value instanceof RecordedObject) {\n-            if (value instanceof RecordedThread rt) {\n-                printThread(rt, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClass rc) {\n-                printClass(rc, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClassLoader rcl) {\n-                printClassLoader(rcl, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedFrame frame) {\n-                if (frame.isJavaFrame()) {\n-                    printJavaFrame((RecordedFrame) value, postFix);\n-                    return;\n-                }\n-            }\n-            if (value instanceof RecordedMethod rm) {\n-                println(formatMethod(rm));\n-                return;\n-            }\n-            if (field.getTypeName().equals(TYPE_OLD_OBJECT)) {\n-                printOldObject((RecordedObject) value);\n-                return;\n-            }\n-             print((RecordedObject) value, postFix);\n-            return;\n-        }\n-        if (value.getClass().isArray()) {\n-            printArray((Object[]) value);\n-            return;\n+        switch (value) {\n+            case null -> println(\"N\/A\" + postFix);\n+            case RecordedObject object -> printRecordedObject(object, field, postFix);\n+            case Number number -> printNumber(number, field);\n+            case String text -> println(\"\\\"\" + text + \"\\\"\");\n+            case Duration duration -> printDuration(duration);\n+            case OffsetDateTime dateTime -> printOffsetDateTime(dateTime);\n+            case Object[] array -> printArray(array, field);\n+            default -> println(value);\n@@ -377,0 +350,1 @@\n+    }\n@@ -378,29 +352,9 @@\n-        if (value instanceof Double d) {\n-            if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Float f) {\n-            if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Long l) {\n-            if (l == Long.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Integer i) {\n-            if (i == Integer.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-\n-        if (field.getContentType() != null) {\n-            if (printFormatted(field, value)) {\n-                return;\n-            }\n+    private void printRecordedObject(RecordedObject struct, ValueDescriptor field, String postFix) {\n+        switch (struct) {\n+            case RecordedThread rt -> printThread(rt, postFix);\n+            case RecordedClass rc -> printClass(rc, postFix);\n+            case RecordedClassLoader rcl -> printClassLoader(rcl, postFix);\n+            case RecordedFrame rf when rf.isJavaFrame() -> printJavaFrame(rf, postFix);\n+            case RecordedMethod rm -> println(formatMethod(rm));\n+            case RecordedObject ro when field.getTypeName().equals(TYPE_OLD_OBJECT) -> printOldObject(ro);\n+            default -> print(struct, postFix);\n@@ -408,0 +362,1 @@\n+    }\n@@ -409,3 +364,7 @@\n-        String text = String.valueOf(value);\n-        if (value instanceof String) {\n-            text = \"\\\"\" + text + \"\\\"\";\n+    private void printNumber(Number number, ValueDescriptor field) {\n+        switch (number) {\n+            case Double d when Double.isNaN(d) || d == Double.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Float f when Float.isNaN(f) || f == Float.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Long l when l == Long.MIN_VALUE -> println(\"N\/A\");\n+            case Integer i when i == Integer.MIN_VALUE -> println(\"N\/A\");\n+            default -> printFormatted(field, number);\n@@ -413,1 +372,0 @@\n-        println(text);\n@@ -549,16 +507,4 @@\n-    private boolean printFormatted(ValueDescriptor field, Object value) {\n-        if (value instanceof Duration d) {\n-            if (d.getSeconds() == Long.MIN_VALUE && d.getNano() == 0)  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (d.equals(ChronoUnit.FOREVER.getDuration())) {\n-                println(\"Forever\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(String.format(\"%.9f s\", (double) d.toNanos() \/ 1_000_000_000));\n-            } else {\n-                println(ValueFormatter.formatDuration(d));\n-            }\n-            return true;\n+    private void printOffsetDateTime(OffsetDateTime dateTime) {\n+        if (dateTime.equals(OffsetDateTime.MIN)) {\n+            println(\"N\/A\");\n+            return;\n@@ -566,11 +512,11 @@\n-        if (value instanceof OffsetDateTime odt) {\n-            if (odt.equals(OffsetDateTime.MIN))  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(TIME_FORMAT_EXACT.format(odt));\n-            } else {\n-                println(TIME_FORMAT.format(odt));\n-            }\n-            return true;\n+        if (showExact) {\n+            println(TIME_FORMAT_EXACT.format(dateTime));\n+        } else {\n+            println(TIME_FORMAT.format(dateTime));\n+        }\n+    }\n+\n+    private void printDuration(Duration duration) {\n+        if (duration.getSeconds() == Long.MIN_VALUE && duration.getNano() == 0) {\n+            println(\"N\/A\");\n+            return;\n@@ -578,4 +524,16 @@\n-        Percentage percentage = field.getAnnotation(Percentage.class);\n-        if (percentage != null) {\n-            if (value instanceof Number n) {\n-                double p = 100 * n.doubleValue();\n+        if (duration.equals(ChronoUnit.FOREVER.getDuration())) {\n+            println(\"Forever\");\n+            return;\n+        }\n+        if (showExact) {\n+            println(String.format(\"%.9f s\", (double) duration.toNanos() \/ 1_000_000_000));\n+        } else {\n+            println(ValueFormatter.formatDuration(duration));\n+        }\n+    }\n+\n+    private void printFormatted(ValueDescriptor field, Number number) {\n+        if (field.getContentType() != null) {\n+            Percentage percentage = field.getAnnotation(Percentage.class);\n+            if (percentage != null) {\n+                double p = 100 * number.doubleValue();\n@@ -587,1 +545,1 @@\n-                return true;\n+                return;\n@@ -589,10 +547,10 @@\n-        }\n-        DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n-        if (dataAmount != null && value instanceof Number number) {\n-            boolean frequency = field.getAnnotation(Frequency.class) != null;\n-            String unit = dataAmount.value();\n-            boolean bits = unit.equals(DataAmount.BITS);\n-            boolean bytes = unit.equals(DataAmount.BYTES);\n-            if (bits || bytes) {\n-                formatMemory(number.longValue(), bytes, frequency);\n-                return true;\n+            DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n+            if (dataAmount != null) {\n+                boolean frequency = field.getAnnotation(Frequency.class) != null;\n+                String unit = dataAmount.value();\n+                boolean bits = unit.equals(DataAmount.BITS);\n+                boolean bytes = unit.equals(DataAmount.BYTES);\n+                if (bits || bytes) {\n+                    printMemory(number.longValue(), bytes, frequency);\n+                    return;\n+                }\n@@ -600,5 +558,3 @@\n-        }\n-        MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n-        if (memoryAddress != null) {\n-            if (value instanceof Number n) {\n-                long d = n.longValue();\n+            MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n+            if (memoryAddress != null) {\n+                long d = number.longValue();\n@@ -606,1 +562,1 @@\n-                return true;\n+                return;\n@@ -608,6 +564,4 @@\n-        }\n-        Frequency frequency = field.getAnnotation(Frequency.class);\n-        if (frequency != null) {\n-            if (value instanceof Number) {\n-                println(value + \" Hz\");\n-                return true;\n+            Frequency frequency = field.getAnnotation(Frequency.class);\n+            if (frequency != null) {\n+                println(number + \" Hz\");\n+                return;\n@@ -616,2 +570,1 @@\n-\n-        return false;\n+        println(number);\n@@ -620,1 +573,1 @@\n-    private void formatMemory(long value, boolean bytesUnit, boolean frequency) {\n+    private void printMemory(long value, boolean bytesUnit, boolean frequency) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":83,"deletions":130,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-            eventWriter.setEventFilter(Filters.matchAny(eventFilters));\n+            eventWriter.setEventFilter(Filters.matchAll(eventFilters));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-        return Filters.matchAny(filters);\n+        return Filters.matchAll(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Scrub.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,4 @@\n+    public final void println(Object object) {\n+        println(String.valueOf(object));\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/StructuredWriter.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.jfr.internal.Type;\n@@ -267,10 +266,9 @@\n-        try {\n-            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization started.\");\n-            Thread current = Thread.currentThread();\n-            JVM.exclude(current);\n-            long methodId = 16384126;\n-            long classId = methodId >> 16;\n-            ClassLoader cl = null;\n-            String className = \" java\/lang\/String\";\n-            Module m = String.class.getModule();\n-            var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\");\n+        Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization started.\");\n+        Thread current = Thread.currentThread();\n+        JVM.exclude(current);\n+        long methodId = 16384126;\n+        long classId = methodId >> 16;\n+        ClassLoader cl = null;\n+        String className = \"java\/lang\/String\";\n+        Module m = String.class.getModule();\n+        try (var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\")) {\n@@ -278,1 +276,0 @@\n-            is.close();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/PlatformTracer.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.jfr.internal.settings.CPUThrottleSetting;\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanRate.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * fields that matches the data types of the payload. Metadata about fields,\n+ * fields that match the data types of the payload. Metadata about fields,\n@@ -235,1 +235,1 @@\n- * parameters is passed to a method that throws other exceptions, such as\n+ * parameters are passed to a method that throws other exceptions, such as\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -34,1 +32,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jfr\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -41,1 +41,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -56,1 +54,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-        var srcPath = pkg.asPackageApplicationLayout().orElseThrow().resolveAt(env.appImageDir()).desktopIntegrationDirectory().resolve(fileName);\n+        var srcPath = env.asApplicationLayout().orElseThrow().desktopIntegrationDirectory().resolve(fileName);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -43,2 +44,20 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, libAppLauncher()));\n+        return (LinuxApplicationLayout)ApplicationLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout unresolve() {\n+        return (LinuxApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), libAppLauncher());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, libAppLauncher()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayout.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayoutMixin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,2 +354,1 @@\n-                AppImageLayout.toPathGroup(pkg.packageLayout().resolveAt(\n-                        env.appImageDir())).sizeInBytes() >> 10));\n+                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jpackage.internal.model.LinuxApplication;\n@@ -37,0 +38,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -55,1 +57,1 @@\n-        final var pkg = pkgBuilder.create();\n+        final var tmpPkg = pkgBuilder.create();\n@@ -57,1 +59,1 @@\n-        final var stdPkgType = pkg.asStandardPackageType();\n+        final var stdPkgType = tmpPkg.asStandardPackageType();\n@@ -59,1 +61,1 @@\n-            validatePackageName(pkg.packageName(), stdPkgType.orElseThrow());\n+            validatePackageName(tmpPkg.packageName(), stdPkgType.orElseThrow());\n@@ -62,3 +64,10 @@\n-        var reply = create(pkg, pkg.packageLayout());\n-        if (reply.isInstallDirInUsrTree()) {\n-            reply = create(pkg, usrTreePackageLayout(pkg.relativeInstallDir(), pkg.packageName()));\n+        final AppImageLayout relativeInstalledLayout;\n+        if (create(tmpPkg).isInstallDirInUsrTree()) {\n+            final var usrTreeLayout = usrTreePackageLayout(tmpPkg.relativeInstallDir(), tmpPkg.packageName());\n+            if (tmpPkg.isRuntimeInstaller()) {\n+                relativeInstalledLayout = RuntimeLayout.create(usrTreeLayout.runtimeDirectory());\n+            } else {\n+                relativeInstalledLayout = usrTreeLayout;\n+            }\n+        } else {\n+            relativeInstalledLayout = tmpPkg.appImageLayout().resolveAt(tmpPkg.relativeInstallDir()).resetRootDirectory();\n@@ -67,1 +76,6 @@\n-        return reply;\n+        final var app = ApplicationBuilder.overrideAppImageLayout(pkgBuilder.app(), relativeInstalledLayout);\n+\n+        return create(pkgBuilder\n+                .app(LinuxApplication.create(app))\n+                .installedPackageLayout(relativeInstalledLayout.resolveAt(Path.of(\"\/\")).resetRootDirectory())\n+                .create());\n@@ -70,1 +84,1 @@\n-    private LinuxPackage create(Package pkg, AppImageLayout pkgLayout) throws ConfigException {\n+    private LinuxPackage create(Package pkg) throws ConfigException {\n@@ -72,1 +86,0 @@\n-                pkgLayout,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-    @Override\n-    AppImageLayout packageLayout();\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackage.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-    \/**\n-     * Overrides {@link Package#packageLayout()}.\n-     *\/\n-    AppImageLayout packageLayout();\n-\n@@ -91,1 +86,1 @@\n-    record Stub(AppImageLayout packageLayout, String menuGroupName,\n+    record Stub(String menuGroupName,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackageMixin.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -47,0 +49,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -53,1 +56,1 @@\n-    static Consumer<Path> createSigner(MacApplication app, CodesignConfig signingCfg) {\n+    static Consumer<MacBundle> createSigner(MacApplication app, CodesignConfig signingCfg) {\n@@ -70,1 +73,1 @@\n-        SignFilter(Application app, Path appImage) {\n+        SignFilter(Application app, MacBundle appImage) {\n@@ -75,1 +78,1 @@\n-                return appLayout.resolveAt(appImage);\n+                return appLayout.resolveAt(appImage.root());\n@@ -101,1 +104,6 @@\n-    private void sign(MacApplication app, Path appImage) throws CodesignException, IOException {\n+    private void sign(MacApplication app, MacBundle appImage) throws CodesignException, IOException {\n+        if (!appImage.isValid()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        app = normalizeAppImageLayout(app);\n@@ -105,1 +113,1 @@\n-        try (var content = Files.walk(appImage)) {\n+        try (var content = Files.walk(appImage.root())) {\n@@ -121,1 +129,1 @@\n-            return appLayout.resolveAt(appImage);\n+            return appLayout.resolveAt(appImage.root());\n@@ -124,1 +132,1 @@\n-        final var frameworkPath = appImage.resolve(\"Contents\/Frameworks\");\n+        final var frameworkPath = appImage.contentsDir().resolve(\"Frameworks\");\n@@ -134,1 +142,1 @@\n-        codesigners.accept(appImage);\n+        codesigners.accept(appImage.root());\n@@ -238,0 +246,14 @@\n+    private static MacApplication normalizeAppImageLayout(MacApplication app) {\n+        switch (app.imageLayout()) {\n+            case MacApplicationLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, APPLICATION_LAYOUT);\n+            }\n+            case RuntimeLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, RUNTIME_BUNDLE_LAYOUT);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                 env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+                 env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -49,1 +49,1 @@\n-                 env = BuildEnv.withAppImageDir(BuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n+                 env = BuildEnv.withAppImageDir(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -98,2 +99,7 @@\n-        final var mixin = new MacApplicationMixin.Stub(validatedIcon(), validatedBundleName(),\n-                validatedBundleIdentifier(), validatedCategory(), appStore, createSigningConfig());\n+        final var mixin = new MacApplicationMixin.Stub(\n+                validatedIcon(),\n+                validatedBundleName(),\n+                validatedBundleIdentifier(),\n+                validatedCategory(),\n+                appStore,\n+                createSigningConfig());\n@@ -104,0 +110,11 @@\n+    static MacApplication overrideAppImageLayout(MacApplication app, AppImageLayout appImageLayout) {\n+        final var mixin = new MacApplicationMixin.Stub(\n+                app.icon(),\n+                app.bundleName(),\n+                app.bundleIdentifier(),\n+                app.category(),\n+                app.appStore(),\n+                app.signingConfig());\n+        return MacApplication.create(ApplicationBuilder.overrideAppImageLayout(app, appImageLayout), mixin);\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -38,1 +39,2 @@\n-                .create(MacApplicationLayout.class, layout, new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n+                .create(MacApplicationLayout.class, layout,\n+                        new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n@@ -43,2 +45,1 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, runtimeRootDirectory()));\n+        return (MacApplicationLayout)ApplicationLayout.super.resolveAt(root);\n@@ -46,0 +47,20 @@\n+\n+    @Override\n+    default MacApplicationLayout unresolve() {\n+        return (MacApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default MacApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), runtimeRootDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default MacApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, runtimeRootDirectory()));\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayout.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n@@ -33,1 +33,2 @@\n-     * Path to the root Java runtime directory in the application image.\n+     * Returns path to the root Java runtime directory in the application image.\n+     * <p>\n@@ -35,0 +36,2 @@\n+     *\n+     * @return the path to the root Java runtime directory in the application image\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayoutMixin.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import jdk.jpackage.internal.model.MacPackage;\n+\n+final class MacBuildEnvFromParams {\n+\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return BuildEnvFromParams.create(params, MacPackagingPipeline.APPLICATION_LAYOUT::resolveAt, MacPackage::guessRuntimeLayout);\n+    });\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBuildEnvFromParams.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -76,2 +77,14 @@\n-    static MacBundle fromAppImageLayout(AppImageLayout layout) {\n-        return new MacBundle(layout.rootDirectory());\n+    static Optional<MacBundle> fromAppImageLayout(AppImageLayout layout) {\n+        final var root = layout.rootDirectory();\n+        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n+        final var contentsDirname = Path.of(\"Contents\");\n+        var bundleRoot = root;\n+        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n+            var nameComponent = bundleSubdir.getName(i);\n+            if (contentsDirname.equals(nameComponent)) {\n+                return Optional.of(new MacBundle(bundleRoot));\n+            } else {\n+                bundleRoot = bundleRoot.resolve(nameComponent);\n+            }\n+        }\n+        return Optional.empty();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundle.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-        final var superPkgBuilder = pkgBuilder.pkgBuilder();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static jdk.jpackage.internal.model.MacPackage.RUNTIME_PACKAGE_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -48,1 +48,0 @@\n-import java.nio.file.Files;\n@@ -67,0 +66,1 @@\n+import jdk.jpackage.internal.model.MacPackage;\n@@ -78,7 +78,3 @@\n-        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params).map(predefinedRuntimeImage -> {\n-            if (Files.isDirectory(RUNTIME_PACKAGE_LAYOUT.resolveAt(predefinedRuntimeImage).runtimeDirectory())) {\n-                return RUNTIME_PACKAGE_LAYOUT;\n-            } else {\n-                return RuntimeLayout.DEFAULT;\n-            }\n-        });\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params)\n+                .map(MacPackage::guessRuntimeLayout)\n+                .map(RuntimeLayout::unresolve);\n@@ -91,1 +87,1 @@\n-        }), APPLICATION_LAYOUT, predefinedRuntimeLayout);\n+        }), APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.LayoutUtils.packagerLayout;\n+\n@@ -29,0 +31,1 @@\n+import jdk.jpackage.internal.model.MacApplication;\n@@ -48,1 +51,9 @@\n-        final var pkg = pkgBuilder.create();\n+\n+        final var app = (MacApplication)pkgBuilder.app();\n+\n+        var pkg = pkgBuilder.create();\n+\n+        pkgBuilder.app(MacApplicationBuilder.overrideAppImageLayout(app, packagerLayout(pkg)))\n+                .installedPackageLayout(pkg.installedPackageLayout());\n+\n+        pkg = pkgBuilder.create();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -52,0 +53,1 @@\n+import java.util.function.UnaryOperator;\n@@ -56,0 +58,1 @@\n+import jdk.jpackage.internal.PackagingPipeline.AppImageTaskAction;\n@@ -101,4 +104,0 @@\n-    static AppImageLayout packagingLayout(Package pkg) {\n-        return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName());\n-    }\n-\n@@ -107,9 +106,2 @@\n-                .appContextMapper(appContext -> {\n-                    return new TaskContextProxy(appContext, true, false);\n-                })\n-                .pkgContextMapper(appContext -> {\n-                    final var isRuntimeInstaller = pkg.map(Package::isRuntimeInstaller).orElse(false);\n-                    final var withPredefinedAppImage = pkg.flatMap(Package::predefinedAppImage).isPresent();\n-                    return new TaskContextProxy(appContext, false, isRuntimeInstaller || withPredefinedAppImage);\n-                })\n-                .appImageLayoutForPackaging(MacPackagingPipeline::packagingLayout)\n+                .contextMapper(pkg.map(MacPackagingPipeline::mapPackageTaskContext)\n+                        .orElseGet(MacPackagingPipeline::mapAppTaskContext))\n@@ -159,1 +151,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -165,1 +157,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -185,1 +177,0 @@\n-                builder.appImageLayoutForPackaging(Package::appImageLayout);\n@@ -239,2 +230,49 @@\n-    private static void copyAppImage(MacPackage pkg, AppImageDesc srcAppImage,\n-            AppImageDesc dstAppImage) throws IOException {\n+    static final class LayoutUtils {\n+        \/**\n+         * Returns unresolved app image layout for the specified package for use with\n+         * the signing function defined in {@link MacPackagingPipeline} class and\n+         * {@link MacPkgPackager} and {@link MacDmgPackager} packagers.\n+         * <p>\n+         * Paths of the result app image layout will start with the bundle name. E.g.:\n+         * for a package with relative installation directory set to\n+         * {@code \"Applications\/Acme\/MyApp.app\"} and the \"launchers\" directory of an\n+         * application layout set to {@code \"Contents\/MacOS\"}, the result application\n+         * layout object will be such that the value of its \"launchers\" directory will\n+         * be {@code \"MyApp.app\/Contents\/MacOS\"}. The root directory of the result app\n+         * image layout will be an empty path ({@link Path.of(\"\")}), i.e. the app image\n+         * layout will be unresolved.\n+         *\n+         * @param pkg the package\n+         * @return the unresolved app image layout for the specified package suitable\n+         *         for the use with macosx packaging pipeline and packagers\n+         *\/\n+        static AppImageLayout packagerLayout(Package pkg) {\n+            return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName()).resetRootDirectory();\n+        }\n+\n+        static <T extends AppImageLayout> AppImageBuildEnv<MacApplication, T> fromPackagerLayout(AppImageBuildEnv<MacApplication, T> cfg) {\n+\n+            var bundleDirectoryName = cfg.envLayout().runtimeDirectory().getName(0);\n+            var bundleLayout = cfg.envLayout().map(bundleDirectoryName::relativize).resetRootDirectory();\n+            var bundleRoot = cfg.env().appImageDir().resolve(bundleDirectoryName);\n+            var app = MacApplicationBuilder.overrideAppImageLayout(cfg.app(), bundleLayout);\n+            var env = BuildEnv.withAppImageLayout(cfg.env(), bundleLayout.resolveAt(bundleRoot));\n+\n+            return new AppImageBuildEnv<>(env, app);\n+        }\n+\n+        static <T extends AppImageLayout> AppImageTaskAction<MacApplication, T> withBundleLayout(AppImageTaskAction<MacApplication, T> action) {\n+            return new AppImageTaskAction<>() {\n+                @Override\n+                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException, PackagerException {\n+                    if (!env.envLayout().runtimeDirectory().getName(0).equals(Path.of(\"Contents\"))) {\n+                        env = LayoutUtils.fromPackagerLayout(env);\n+                    }\n+                    action.execute(env);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static void copyAppImage(MacPackage pkg, AppImageLayout srcAppImage,\n+            AppImageLayout dstAppImage) throws IOException {\n@@ -244,1 +282,6 @@\n-        var inputRootDirectory = srcAppImage.resolvedAppImagelayout().rootDirectory();\n+        final Optional<MacBundle> srcMacBundle;\n+        if (pkg.isRuntimeInstaller()) {\n+            srcMacBundle = MacBundle.fromAppImageLayout(srcAppImage);\n+        } else {\n+            srcMacBundle = Optional.empty();\n+        }\n@@ -246,1 +289,1 @@\n-        if (pkg.isRuntimeInstaller() && MacBundle.isDirectoryMacBundle(inputRootDirectory)) {\n+        srcMacBundle.ifPresentOrElse(inputBundle -> {\n@@ -249,7 +292,15 @@\n-            FileUtils.copyRecursive(\n-                    inputRootDirectory,\n-                    dstAppImage.resolvedAppImagelayout().rootDirectory(),\n-                    LinkOption.NOFOLLOW_LINKS);\n-        } else {\n-            PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n-        }\n+            try {\n+                FileUtils.copyRecursive(\n+                        inputBundle.root(),\n+                        MacBundle.fromAppImageLayout(dstAppImage).orElseThrow().root(),\n+                        LinkOption.NOFOLLOW_LINKS);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }, () -> {\n+            try {\n+                PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n@@ -275,4 +326,17 @@\n-    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n-        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env.env(), env.env().appImageDir().resolve(env.envLayout().rootDirectory())),\n-                env.pkg(), env.pkg().appImageLayout(), env.outputDir()));\n+    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> cfg) throws IOException {\n+        var appCfg = LayoutUtils.fromPackagerLayout(\n+                new AppImageBuildEnv<>(cfg.env(), (MacApplication)cfg.pkg().app()));\n+\n+        var pkg = cfg.pkg(); pkg = new Package.Stub(\n+                appCfg.app(),\n+                pkg.type(),\n+                pkg.packageName(),\n+                pkg.description(),\n+                pkg.version(),\n+                pkg.aboutURL(),\n+                pkg.licenseFile(),\n+                pkg.predefinedAppImage(),\n+                pkg.installedPackageLayout(),\n+                pkg.relativeInstallDir());\n+\n+        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(appCfg.env(), pkg, cfg.outputDir()));\n@@ -334,1 +398,1 @@\n-        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).infoPlistFile();\n+        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n@@ -387,2 +451,1 @@\n-            final var appImageDir = env.resolvedLayout().rootDirectory();\n-            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(appImageDir);\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow());\n@@ -470,1 +533,1 @@\n-            return new MacBundle(env.resolvedLayout().rootDirectory());\n+            return MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow();\n@@ -501,0 +564,15 @@\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapAppTaskContext() {\n+        return ctx -> {\n+            return new TaskContextProxy(ctx, true, false);\n+        };\n+    }\n+\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapPackageTaskContext(Package pkg) {\n+        return ctx -> {\n+            final var isRuntimeInstaller = pkg.isRuntimeInstaller();\n+            final var withPredefinedAppImage = pkg.predefinedAppImage().isPresent();\n+            return new TaskContextProxy(ctx, false, isRuntimeInstaller || withPredefinedAppImage);\n+        };\n+    }\n+\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":113,"deletions":35,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.file.Files;\n@@ -32,2 +33,0 @@\n-    MacApplication app();\n-\n@@ -35,7 +34,1 @@\n-    default AppImageLayout appImageLayout() {\n-        if (isRuntimeInstaller()) {\n-            return RUNTIME_PACKAGE_LAYOUT;\n-        } else {\n-            return Package.super.appImageLayout();\n-        }\n-    }\n+    MacApplication app();\n@@ -51,1 +44,15 @@\n-    public static final RuntimeLayout RUNTIME_PACKAGE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n+    \/**\n+     * Guesses layout of a runtime image at the given path.\n+     *\n+     * @param path the path to a runtime image\n+     * @return the runtime image layout resolved at the given path\n+     *\/\n+    public static RuntimeLayout guessRuntimeLayout(Path path) {\n+        if (Files.isDirectory(RUNTIME_BUNDLE_LAYOUT.resolveAt(path).runtimeDirectory())) {\n+            return RUNTIME_BUNDLE_LAYOUT.resolveAt(path);\n+        } else {\n+            return RuntimeLayout.DEFAULT.resolveAt(path);\n+        }\n+    }\n+\n+    public static final RuntimeLayout RUNTIME_BUNDLE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPackage.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-\n-record AppImageDesc(AppImageLayout appImageLayout, Path path) {\n-\n-    AppImageDesc {\n-        Objects.requireNonNull(appImageLayout);\n-        Objects.requireNonNull(path);\n-    }\n-\n-    AppImageLayout resolvedAppImagelayout() {\n-        return appImageLayout.resolveAt(path);\n-    }\n-\n-    Optional<ApplicationLayout> asResolvedApplicationLayout() {\n-        return asApplicationLayout().map(v -> v.resolveAt(path));\n-    }\n-\n-    Optional<ApplicationLayout> asApplicationLayout() {\n-        if (appImageLayout instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageDesc.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -156,3 +156,24 @@\n-        return new Launcher.Stub(launcher.name(), Optional.of(startupInfo),\n-                launcher.fileAssociations(), launcher.isService(), launcher.description(),\n-                launcher.icon(), launcher.defaultIconResourceName(), launcher.extraAppImageFileData());\n+        return new Launcher.Stub(\n+                launcher.name(),\n+                Optional.of(startupInfo),\n+                launcher.fileAssociations(),\n+                launcher.isService(),\n+                launcher.description(),\n+                launcher.icon(),\n+                launcher.defaultIconResourceName(),\n+                launcher.extraAppImageFileData());\n+    }\n+\n+    static Application overrideAppImageLayout(Application app, AppImageLayout appImageLayout) {\n+        return new Application.Stub(\n+                app.name(),\n+                app.description(),\n+                app.version(),\n+                app.vendor(),\n+                app.copyright(),\n+                app.srcDir(),\n+                app.contentDirs(),\n+                Objects.requireNonNull(appImageLayout),\n+                app.runtimeBuilder(),\n+                app.launchers(),\n+                app.extraAppImageFileData());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            env.app().runtimeBuilder().orElseThrow().createRuntime(env.resolvedLayout());\n+            env.app().runtimeBuilder().orElseThrow().create(env.resolvedLayout());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -31,0 +33,3 @@\n+\/**\n+ * Build environment.\n+ *\/\n@@ -33,0 +38,5 @@\n+    \/**\n+     * Returns root directory for intermediate build files.\n+     *\n+     * @return the root directory for intermediate build files\n+     *\/\n@@ -35,0 +45,5 @@\n+    \/**\n+     * Returns <code>true<\/code> if the build should be verbose output.\n+     *\n+     * @return <code>true<\/code> if the build should be verbose output\n+     *\/\n@@ -37,0 +52,7 @@\n+    \/**\n+     * Returns the path of the resource directory or an empty {@link Optional}\n+     * instance if none is configured with the build.\n+     *\n+     * @return the path of the resource directory or an empty {@link Optional}\n+     *         instance if non is configured with the build\n+     *\/\n@@ -40,1 +62,1 @@\n-     * Returns path to application image directory.\n+     * Returns the path of the app image directory of this build.\n@@ -42,2 +64,1 @@\n-     * The return value is supposed to be used as a parameter for\n-     * ApplicationLayout#resolveAt function.\n+     * @return the path of the app image directory of this build\n@@ -46,1 +67,1 @@\n-        return buildRoot().resolve(\"image\");\n+        return appImageLayout().rootDirectory();\n@@ -49,0 +70,20 @@\n+    \/**\n+     * Returns resolved app image layout of the app image directory. The return\n+     * layout is resolved at {@link #appImageDir()} path.\n+     *\n+     * @return the resolved app image layout of the app image directory\n+     *\/\n+    AppImageLayout appImageLayout();\n+\n+    default Optional<ApplicationLayout> asApplicationLayout() {\n+        if (appImageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Returns a path to a directory for intermediate configuration files.\n+     * @return the path to the directory for intermediate configuration files\n+     *\/\n@@ -53,0 +94,7 @@\n+    \/**\n+     * Creates an {@link OverridableResource} instance for the given resource name.\n+     *\n+     * @param defaultName the resource name\n+     * @return the {@link OverridableResource} instance wrapping a resource with the\n+     *         given name\n+     *\/\n@@ -59,2 +107,8 @@\n-    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose, Class<?> resourceLocator) {\n-        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.empty());\n+    static BuildEnv withAppImageLayout(BuildEnv env, AppImageLayout appImageLayout) {\n+        return ((Internal.DefaultBuildEnv)env).copyWithAppImageLayout(appImageLayout);\n+    }\n+\n+    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose,\n+            Class<?> resourceLocator, AppImageLayout appImageLayout) {\n+        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose,\n+                resourceLocator, appImageLayout);\n@@ -64,2 +118,3 @@\n-        private static record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n-                boolean verbose, Class<?> resourceLocator, Optional<Path> optAppImageDir) implements BuildEnv {\n+        private record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n+                boolean verbose, Class<?> resourceLocator,\n+                AppImageLayout appImageLayout) implements BuildEnv {\n@@ -71,1 +126,1 @@\n-                Objects.requireNonNull(optAppImageDir);\n+                Objects.requireNonNull(appImageLayout);\n@@ -74,2 +129,2 @@\n-            DefaultBuildEnv copyWithAppImageDir(Path appImageDir) {\n-                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.of(appImageDir));\n+            DefaultBuildEnv copyWithAppImageDir(Path v) {\n+                return copyWithAppImageLayout(appImageLayout.unresolve().resolveAt(v));\n@@ -78,3 +133,2 @@\n-            @Override\n-            public Path appImageDir() {\n-                return optAppImageDir.orElseGet(BuildEnv.super::appImageDir);\n+            DefaultBuildEnv copyWithAppImageLayout(AppImageLayout v) {\n+                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, v);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnv.java","additions":68,"deletions":14,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.model.Package;\n@@ -43,2 +45,0 @@\n-        Objects.requireNonNull(appImageDir);\n-\n@@ -60,2 +60,2 @@\n-        return BuildEnv.withAppImageDir(BuildEnv.create(root, Optional.ofNullable(resourceDir),\n-                verbose, ResourceLocator.class), appImageDir);\n+        return BuildEnv.create(root, Optional.ofNullable(resourceDir), verbose,\n+                ResourceLocator.class, resolvedAppImageLayout());\n@@ -79,0 +79,5 @@\n+    BuildEnvBuilder appImageLayout(AppImageLayout v) {\n+        appImageLayout = v;\n+        return this;\n+    }\n+\n@@ -81,0 +86,1 @@\n+        appImageLayout = app.imageLayout();\n@@ -84,1 +90,1 @@\n-    BuildEnvBuilder appImageDirForPackage() {\n+    BuildEnvBuilder appImageDirFor(Package pkg) {\n@@ -86,0 +92,1 @@\n+        appImageLayout = pkg.appImageLayout();\n@@ -89,0 +96,5 @@\n+    private AppImageLayout resolvedAppImageLayout() {\n+        Objects.requireNonNull(appImageLayout);\n+        return Optional.ofNullable(appImageDir).map(appImageLayout.unresolve()::resolveAt).orElse(appImageLayout);\n+    }\n+\n@@ -94,0 +106,1 @@\n+    private AppImageLayout appImageLayout;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvBuilder.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -34,0 +36,2 @@\n+import java.util.function.Function;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -35,0 +39,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -38,1 +43,3 @@\n-    static BuildEnv create(Map<String, ? super Object> params) throws ConfigException {\n+    static BuildEnv create(Map<String, ? super Object> params,\n+            Function<Path, ApplicationLayout> predefinedAppImageLayoutProvider,\n+            Function<Path, RuntimeLayout> predefinedRuntimeImageLayoutProvider) throws ConfigException {\n@@ -50,1 +57,2 @@\n-            PREDEFINED_RUNTIME_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = predefinedRuntimeImageLayoutProvider.apply(PREDEFINED_RUNTIME_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -52,1 +60,2 @@\n-            PREDEFINED_APP_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = predefinedAppImageLayoutProvider.apply(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -54,1 +63,1 @@\n-            builder.appImageDirForPackage();\n+            builder.appImageDirFor(pkg.orElseThrow());\n@@ -62,2 +71,3 @@\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(\n-            BuildEnv.class, BuildEnvFromParams::create);\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return create(params, PLATFORM_APPLICATION_LAYOUT::resolveAt, RuntimeLayout.DEFAULT::resolveAt);\n+    });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        return createApplicationBuilder(params, launcherMapper, appLayout, Optional.of(RuntimeLayout.DEFAULT));\n+        return createApplicationBuilder(params, launcherMapper, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n@@ -87,1 +87,2 @@\n-            ApplicationLayout appLayout, Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n+            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n+            Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n@@ -107,1 +108,1 @@\n-            appBuilder.appImageLayout(predefinedRuntimeLayout.orElseThrow());\n+            appBuilder.appImageLayout(runtimeLayout);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public void createRuntime(AppImageLayout appImageLayout) throws PackagerException {\n+    public void create(AppImageLayout appImageLayout) throws PackagerException {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -89,0 +90,1 @@\n+                validatedInstalledPackageLayout(relativeInstallDir),\n@@ -92,0 +94,9 @@\n+    PackageBuilder app(Application v) {\n+        app = v;\n+        return this;\n+    }\n+\n+    Application app() {\n+        return app;\n+    }\n+\n@@ -172,0 +183,9 @@\n+    PackageBuilder installedPackageLayout(AppImageLayout v) {\n+        installedPackageLayout = v;\n+        return this;\n+    }\n+\n+    Optional<AppImageLayout> installedPackageLayout() {\n+        return Optional.ofNullable(installedPackageLayout);\n+    }\n+\n@@ -176,0 +196,15 @@\n+    private AppImageLayout validatedInstalledPackageLayout(Path relativeInstallDir) {\n+        return installedPackageLayout().orElseGet(() -> {\n+            var theInstallDir = relativeInstallDir;\n+            if (type instanceof StandardPackageType stdType) {\n+                switch (stdType) {\n+                    case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n+                        theInstallDir = Path.of(\"\/\").resolve(theInstallDir);\n+                    }\n+                    default -> {}\n+                }\n+            }\n+            return app.imageLayout().resolveAt(theInstallDir).resetRootDirectory();\n+        });\n+    }\n+\n@@ -238,0 +273,1 @@\n+    private Application app;\n@@ -246,0 +282,1 @@\n+    private AppImageLayout installedPackageLayout;\n@@ -248,1 +285,0 @@\n-    private final Application app;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageBuilder.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -41,1 +42,0 @@\n-import java.util.function.Function;\n@@ -44,0 +44,1 @@\n+import java.util.stream.Stream;\n@@ -65,1 +66,1 @@\n-        execute(appContextMapper.apply(createTaskContext(env, app)));\n+        execute(contextMapper.apply(createTaskContext(env, app)));\n@@ -84,2 +85,1 @@\n-        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir,\n-                taskConfig, appImageLayoutForPackaging.apply(pkg)));\n+        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir, taskConfig));\n@@ -95,1 +95,1 @@\n-        execute(pkgContextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n+        execute(contextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n@@ -138,1 +138,6 @@\n-    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app, U envLayout) {\n+    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app) {\n+        @SuppressWarnings(\"unchecked\")\n+        U envLayout() {\n+            return (U)app.imageLayout();\n+        }\n+\n@@ -141,1 +146,1 @@\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+            return (U)env.appImageLayout();\n@@ -145,1 +150,1 @@\n-    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, U envLayout, Path outputDir) {\n+    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, Path outputDir) {\n@@ -147,2 +152,2 @@\n-        U resolvedLayout() {\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+        U envLayout() {\n+            return (U)pkg.appImageLayout();\n@@ -151,2 +156,3 @@\n-        AppImageBuildEnv<Application, U> appImageBuildEnv() {\n-            return new AppImageBuildEnv<>(env, pkg.app(), envLayout);\n+        @SuppressWarnings(\"unchecked\")\n+        U resolvedLayout() {\n+            return (U)env.appImageLayout();\n@@ -168,1 +174,1 @@\n-        void execute(T pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException, PackagerException;\n+        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException, PackagerException;\n@@ -198,0 +204,5 @@\n+            private TaskBuilder(TaskID id, TaskConfig config) {\n+                this(id);\n+                config.action().ifPresent(this::setAction);\n+            }\n+\n@@ -228,0 +239,4 @@\n+            boolean hasAction() {\n+                return action != null;\n+            }\n+\n@@ -286,0 +301,6 @@\n+        Stream<TaskBuilder> configuredTasks() {\n+            return taskConfig.entrySet().stream().map(e -> {\n+                return new TaskBuilder(e.getKey(), e.getValue());\n+            });\n+        }\n+\n@@ -293,17 +314,1 @@\n-            appContextMapper(v);\n-            pkgContextMapper(v);\n-            return this;\n-        }\n-\n-        Builder appContextMapper(UnaryOperator<TaskContext> v) {\n-            appContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder pkgContextMapper(UnaryOperator<TaskContext> v) {\n-            pkgContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder appImageLayoutForPackaging(Function<Package, AppImageLayout> v) {\n-            appImageLayoutForPackaging = v;\n+            contextMapper = v;\n@@ -321,6 +326,1 @@\n-            return createPackagingTaskContext(env, pkg, outputDir, taskConfig,\n-                    validatedAppImageLayoutForPackaging().apply(pkg));\n-        }\n-\n-        private Function<Package, AppImageLayout> validatedAppImageLayoutForPackaging() {\n-            return Optional.ofNullable(appImageLayoutForPackaging).orElse(Package::packageLayout);\n+            return createPackagingTaskContext(env, pkg, outputDir, taskConfig);\n@@ -331,3 +331,1 @@\n-                    Optional.ofNullable(appContextMapper).orElse(UnaryOperator.identity()),\n-                    Optional.ofNullable(pkgContextMapper).orElse(UnaryOperator.identity()),\n-                    validatedAppImageLayoutForPackaging());\n+                    Optional.ofNullable(contextMapper).orElse(UnaryOperator.identity()));\n@@ -339,3 +337,1 @@\n-        private UnaryOperator<TaskContext> appContextMapper;\n-        private UnaryOperator<TaskContext> pkgContextMapper;\n-        private Function<Package, AppImageLayout> appImageLayoutForPackaging;\n+        private UnaryOperator<TaskContext> contextMapper;\n@@ -407,1 +403,1 @@\n-    static void copyAppImage(Package pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException {\n+    static void copyAppImage(Package pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException {\n@@ -411,1 +407,1 @@\n-    static void copyAppImage(AppImageDesc srcAppImage, AppImageDesc dstAppImage,\n+    static void copyAppImage(AppImageLayout srcAppImage, AppImageLayout dstAppImage,\n@@ -413,2 +409,1 @@\n-        final var srcLayout = srcAppImage.resolvedAppImagelayout();\n-        final var srcLayoutPathGroup = AppImageLayout.toPathGroup(srcLayout);\n+        final var srcLayoutPathGroup = toPathGroup(srcAppImage);\n@@ -416,1 +411,1 @@\n-        if (removeAppImageFile && srcLayout instanceof ApplicationLayout appLayout) {\n+        if (removeAppImageFile && srcAppImage instanceof ApplicationLayout appLayout) {\n@@ -421,1 +416,1 @@\n-        srcLayoutPathGroup.copy(AppImageLayout.toPathGroup(dstAppImage.resolvedAppImagelayout()), LinkOption.NOFOLLOW_LINKS);\n+        srcLayoutPathGroup.copy(toPathGroup(dstAppImage), LinkOption.NOFOLLOW_LINKS);\n@@ -435,2 +430,1 @@\n-            UnaryOperator<TaskContext> appContextMapper, UnaryOperator<TaskContext> pkgContextMapper,\n-            Function<Package, AppImageLayout> appImageLayoutForPackaging) {\n+            UnaryOperator<TaskContext> contextMapper) {\n@@ -439,3 +433,1 @@\n-        this.appContextMapper = Objects.requireNonNull(appContextMapper);\n-        this.pkgContextMapper = Objects.requireNonNull(pkgContextMapper);\n-        this.appImageLayoutForPackaging = Objects.requireNonNull(appImageLayoutForPackaging);\n+        this.contextMapper = Objects.requireNonNull(contextMapper);\n@@ -445,1 +437,1 @@\n-        return new DefaultTaskContext(taskGraph, env, app, app.asApplicationLayout(), Optional.empty());\n+        return new DefaultTaskContext(taskGraph, env, app, Optional.empty());\n@@ -449,3 +441,2 @@\n-        final var pkgEnv = BuildEnv.withAppImageDir(packagingContext.env.env(), packagingContext.srcAppImage.path());\n-        return new DefaultTaskContext(taskGraph, pkgEnv, packagingContext.env.pkg.app(),\n-                packagingContext.srcAppImage.asApplicationLayout(), Optional.of(packagingContext));\n+        return new DefaultTaskContext(taskGraph, packagingContext.env(),\n+                packagingContext.pkg().app(), Optional.of(packagingContext));\n@@ -455,1 +446,1 @@\n-            Path outputDir, Map<TaskID, TaskConfig> taskConfig, AppImageLayout appImageLayoutForPackaging) {\n+            Path outputDir, Map<TaskID, TaskConfig> taskConfig) {\n@@ -460,1 +451,3 @@\n-        Objects.requireNonNull(appImageLayoutForPackaging);\n+        if (pkg.appImageLayout().isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -462,2 +455,2 @@\n-        final AppImageDesc srcAppImageDesc;\n-        final AppImageDesc dstAppImageDesc;\n+        final AppImageLayout srcLayout;\n+        final AppImageLayout dstLayout;\n@@ -466,3 +459,2 @@\n-            \/\/ appImageDir() should point to a directory where the application image will be created.\n-            srcAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.appImageDir());\n-            dstAppImageDesc = srcAppImageDesc;\n+            srcLayout = pkg.appImageLayout().resolveAt(env.appImageDir());\n+            dstLayout = srcLayout;\n@@ -470,2 +462,17 @@\n-            srcAppImageDesc = new AppImageDesc(pkg.app().imageLayout(),\n-                    pkg.predefinedAppImage().orElseThrow(UnsupportedOperationException::new));\n+            srcLayout = pkg.predefinedAppImage().map(predefinedAppImage -> {\n+                \/\/ Will create a package from the predefined app image.\n+                if (predefinedAppImage.equals(env.appImageDir())) {\n+                    return env.appImageLayout();\n+                } else {\n+                    return pkg.appImageLayout().resolveAt(predefinedAppImage);\n+                }\n+            }).orElseGet(() -> {\n+                \/\/ No predefined app image and no runtime builder.\n+                \/\/ This should be runtime packaging.\n+                if (pkg.isRuntimeInstaller()) {\n+                    return env.appImageLayout();\n+                } else {\n+                    \/\/ Can't create app image without runtime builder.\n+                    throw new UnsupportedOperationException();\n+                }\n+            });\n@@ -474,3 +481,3 @@\n-                \/\/ \"copy app image\" task action is undefined indicating\n-                \/\/ the package will use provided app image as-is.\n-                dstAppImageDesc = srcAppImageDesc;\n+                \/\/ \"copy app image\" task action is empty indicating\n+                \/\/ the package will use provided app image in place.\n+                dstLayout = srcLayout;\n@@ -478,1 +485,1 @@\n-                dstAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.buildRoot().resolve(\"image\"));\n+                dstLayout = pkg.appImageLayout().resolveAt(env.buildRoot().resolve(\"image\"));\n@@ -482,4 +489,1 @@\n-        final var pkgEnv = new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env, dstAppImageDesc.path()), pkg, dstAppImageDesc.appImageLayout(), outputDir);\n-\n-        return new PackagingTaskContext(pkgEnv, srcAppImageDesc);\n+        return new PackagingTaskContext(BuildEnv.withAppImageLayout(env, dstLayout), pkg, outputDir, srcLayout);\n@@ -503,0 +507,6 @@\n+        } catch (ExceptionBox ex) {\n+            throw new PackagerException(ex.getCause());\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (PackagerException ex) {\n+            throw ex;\n@@ -504,7 +514,1 @@\n-            if (ex instanceof PackagerException pex) {\n-                throw pex;\n-            } else if (ex instanceof ExceptionBox bex) {\n-                throw new PackagerException(bex.getCause());\n-            } else {\n-                throw new PackagerException(ex);\n-            }\n+            throw new PackagerException(ex);\n@@ -514,2 +518,2 @@\n-    private record PackagingTaskContext(PackageBuildEnv<Package, AppImageLayout> env,\n-            AppImageDesc srcAppImage) implements TaskContext, StartupParameters {\n+    private record PackagingTaskContext(BuildEnv env, Package pkg, Path outputDir,\n+            AppImageLayout srcAppImage) implements TaskContext, StartupParameters {\n@@ -519,0 +523,2 @@\n+            Objects.requireNonNull(pkg);\n+            Objects.requireNonNull(outputDir);\n@@ -524,1 +530,1 @@\n-            return env.env;\n+            return env;\n@@ -541,1 +547,1 @@\n-                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(env);\n+                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(pkgBuildEnv());\n@@ -543,2 +549,2 @@\n-                ((CopyAppImageTaskAction<Package>)taskAction).execute(env.pkg(),\n-                        srcAppImage, new AppImageDesc(env.envLayout(), env.env().appImageDir()));\n+                ((CopyAppImageTaskAction<Package>)taskAction).execute(pkg(),\n+                        srcAppImage, env.appImageLayout());\n@@ -551,1 +557,5 @@\n-            return env.appImageBuildEnv();\n+            return new AppImageBuildEnv<>(env, pkg.app());\n+        }\n+\n+        PackageBuildEnv<Package, AppImageLayout> pkgBuildEnv() {\n+            return new PackageBuildEnv<>(env, pkg, outputDir);\n@@ -556,1 +566,1 @@\n-            Optional<ApplicationLayout> appLayout, Optional<PackagingTaskContext> pkg) implements TaskContext {\n+            Optional<PackagingTaskContext> pkg) implements TaskContext {\n@@ -562,1 +572,0 @@\n-            Objects.requireNonNull(appLayout);\n@@ -574,2 +583,2 @@\n-            } else if (pkg.isEmpty() && isPackageTask) {\n-                \/\/ Building application image, skip packaging tasks.\n+            } else if (pkg.isEmpty() && (isPackageTask || isCopyAppImageTask)) {\n+                \/\/ Building application image, skip packaging and copying app image tasks.\n@@ -577,2 +586,2 @@\n-            } else if (app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n-                \/\/ Runtime builder is not present, skip building application image tasks.\n+            } else if (pkg.isPresent() && app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n+                \/\/ Building a package, runtime builder is not present, skip building application image tasks.\n@@ -599,1 +608,1 @@\n-                pkg.orElseThrow().execute(taskAction);\n+                pkg.orElseThrow(UnsupportedOperationException::new).execute(taskAction);\n@@ -615,1 +624,1 @@\n-            return new AppImageBuildEnv<>(env, app, (T)appLayout.orElseThrow());\n+            return new AppImageBuildEnv<>(env, app);\n@@ -625,5 +634,1 @@\n-                try {\n-                    context.execute(config.action.orElseThrow());\n-                } catch (ExceptionBox ex) {\n-                    throw ExceptionBox.rethrowUnchecked(ex);\n-                }\n+                context.execute(config.action.orElseThrow());\n@@ -637,3 +642,1 @@\n-    private final Function<Package, AppImageLayout> appImageLayoutForPackaging;\n-    private final UnaryOperator<TaskContext> appContextMapper;\n-    private final UnaryOperator<TaskContext> pkgContextMapper;\n+    private final UnaryOperator<TaskContext> contextMapper;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":107,"deletions":104,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -32,0 +35,1 @@\n+import java.util.Objects;\n@@ -33,0 +37,1 @@\n+import java.util.function.UnaryOperator;\n@@ -35,2 +40,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n@@ -44,3 +47,8 @@\n- *\n- * The layout is \"unresolved\" if the root directory is an empty string and\n- * \"resolved\" otherwise.\n+ * <p>\n+ * The layout is \"unresolved\" if the root directory is an empty path\n+ * ({@code Path.of(\"\")}) and \"resolved\" otherwise.\n+ * <p>\n+ * The return value of the {@link #runtimeDirectory()} method call is always a\n+ * path starting with the path returned by the {@link #rootDirectory()} method\n+ * call. Public methods without parameters and with the return type {@link Path}\n+ * in the derived interfaces must comply to this constrain.\n@@ -59,1 +67,1 @@\n-     * Root directory of this app image.\n+     * Root directory of this app image layout.\n@@ -62,1 +70,1 @@\n-     * @return the root directory of this app image\n+     * @return the root directory of this app image layout\n@@ -67,1 +75,21 @@\n-     * Creates a copy of this app image resolved at the given root directory.\n+     * Returns a copy of this app image layout with the root directory set to an empty\n+     * path ({@code Path.of(\"\")}) or this instance if its root directory is already\n+     * an empty path.\n+     *\n+     * @return an app image layout with the root directory set to an empty path\n+     *\/\n+    AppImageLayout resetRootDirectory();\n+\n+    \/**\n+     * Returns <code>true<\/code> if the root directory of this app image layout is\n+     * not an empty path, i.e, if it is not equal to <code>Path.of(\"\")<\/code>.\n+     *\n+     * @return <code>true<\/code> if the root directory of this app image layout is\n+     *         not an empty path\n+     *\/\n+    default boolean isResolved() {\n+        return !rootDirectory().equals(Path.of(\"\"));\n+    }\n+\n+    \/**\n+     * Creates a copy of this app image layout resolved at the given root directory.\n@@ -70,1 +98,29 @@\n-     * @return a copy of this app image resolved at the given root directory\n+     * @return a copy of this app image layout resolved at the given root directory\n+     *\/\n+    default AppImageLayout resolveAt(Path root) {\n+        return map(root::resolve);\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout resolved such that its root directory\n+     * is set to an empty path ({@code Path.of(\"\")}) or this instance if its root\n+     * directory is already an empty path.\n+     *\n+     * @return an app image layout resolved at {@code Path.of(\"\")} path\n+     *\/\n+    default AppImageLayout unresolve() {\n+        if (isResolved()) {\n+            final var root = rootDirectory();\n+            return map(root::relativize);\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout with the specified mapper applied to\n+     * every path.\n+     *\n+     * @param mapper the mapper to use with every path in this app image layout.\n+     * @return the copy of this app image layout with the specified mapper applied\n+     *         to every path\n@@ -72,1 +128,1 @@\n-    AppImageLayout resolveAt(Path root);\n+    AppImageLayout map(UnaryOperator<Path> mapper);\n@@ -76,1 +132,1 @@\n-    *\/\n+     *\/\n@@ -79,0 +135,17 @@\n+        public Stub {\n+            Objects.requireNonNull(rootDirectory);\n+        }\n+\n+        public Stub(Path runtimeDirectory) {\n+            this(Path.of(\"\"), runtimeDirectory);\n+        }\n+\n+        @Override\n+        public AppImageLayout resetRootDirectory() {\n+            if (isResolved()) {\n+                return new Stub(runtimeDirectory);\n+            } else {\n+                return this;\n+            }\n+        }\n+\n@@ -80,2 +153,2 @@\n-        public AppImageLayout resolveAt(Path base) {\n-            return new Stub(resolveNullablePath(base, rootDirectory), resolveNullablePath(base, runtimeDirectory));\n+        public AppImageLayout map(UnaryOperator<Path> mapper) {\n+            return new Stub(mapNullablePath(mapper, rootDirectory), mapNullablePath(mapper, runtimeDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImageLayout.java","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -31,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -45,1 +46,20 @@\n-        return buildFrom(this).resolveAt(root).create();\n+        return (ApplicationLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default ApplicationLayout unresolve() {\n+        return (ApplicationLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default ApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return buildFrom(this).rootDirectory(\"\").create();\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default ApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return buildFrom(this).mutate(mapper).create();\n@@ -116,8 +136,8 @@\n-        public Builder resolveAt(Path base) {\n-            rootDirectory(resolveNullablePath(base, rootDirectory));\n-            launchersDirectory(resolveNullablePath(base, launchersDirectory));\n-            appDirectory(resolveNullablePath(base, appDirectory));\n-            runtimeDirectory(resolveNullablePath(base, runtimeDirectory));\n-            appModsDirectory(resolveNullablePath(base, appModsDirectory));\n-            desktopIntegrationDirectory(resolveNullablePath(base, desktopIntegrationDirectory));\n-            contentDirectory(resolveNullablePath(base, contentDirectory));\n+        public Builder mutate(UnaryOperator<Path> mapper) {\n+            rootDirectory(mapNullablePath(mapper, rootDirectory));\n+            launchersDirectory(mapNullablePath(mapper, launchersDirectory));\n+            appDirectory(mapNullablePath(mapper, appDirectory));\n+            runtimeDirectory(mapNullablePath(mapper, runtimeDirectory));\n+            appModsDirectory(mapNullablePath(mapper, appModsDirectory));\n+            desktopIntegrationDirectory(mapNullablePath(mapper, desktopIntegrationDirectory));\n+            contentDirectory(mapNullablePath(mapper, contentDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLayout.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n- * The interface specifies the source app image layout with two transformations:\n- * package app image layout and installed app image layout.\n+ * The interface specifies the source app image and the installed app image layouts.\n@@ -39,7 +38,0 @@\n- * Package app image layout is the source app image layout resolved at the\n- * relative installation directory of the package. Additionally, to resolve the\n- * source layout, some packages may transform the source layout.\n- * <p>\n- * Use {@link #packageLayout()} or {@link #asPackageApplicationLayout()} to get\n- * the package app image layout.\n- * <p>\n@@ -58,1 +50,0 @@\n- * <th>Package app image layout<\/th>\n@@ -65,1 +56,0 @@\n- * <td>Duke\/bin\/foo.exe Duke\/app\/foo.jar<\/td>\n@@ -70,1 +60,0 @@\n- * <td>opt\/duke\/bin\/foo opt\/duke\/lib\/app\/foo.jar<\/td>\n@@ -76,1 +65,0 @@\n- * <td>Applications\/Duke.app\/Contents\/MacOS\/foo Applications\/Duke.app\/Contents\/app\/foo.jar<\/td>\n@@ -172,1 +160,0 @@\n-     * @see #packageLayout\n@@ -196,38 +183,0 @@\n-    \/**\n-     * Gets the layout of the installed app image of the application resolved at the\n-     * relative installation directory of this package.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package\n-     *\n-     * @see #relativeInstallDir\n-     * @see #appImageLayout\n-     * @see #installedPackageLayout\n-     *\/\n-    default AppImageLayout packageLayout() {\n-        return appImageLayout().resolveAt(relativeInstallDir());\n-    }\n-\n-    \/**\n-     * Returns the layout of the installed app image of the application resolved at\n-     * the relative installation directory of this package as\n-     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n-     * layout object is of incompatible type.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n-     * returns <code>true<\/code>.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package as\n-     *         {@link ApplicationLayout} type\n-     *\n-     * @see #packageLayout\n-     *\/\n-    default Optional<ApplicationLayout> asPackageApplicationLayout() {\n-        if (packageLayout() instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -240,1 +189,0 @@\n-     * @see #packageLayout\n@@ -242,16 +190,1 @@\n-    default AppImageLayout installedPackageLayout() {\n-        return asStandardPackageType().map(stdType -> {\n-            switch (stdType) {\n-                case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n-                    return packageLayout().resolveAt(Path.of(\"\/\"));\n-                }\n-                case WIN_EXE, WIN_MSI -> {\n-                    return packageLayout();\n-                }\n-                default -> {\n-                    \/\/ Should never get here\n-                    throw new IllegalStateException();\n-                }\n-            }\n-        }).orElseThrow(UnsupportedOperationException::new);\n-    }\n+    AppImageLayout installedPackageLayout();\n@@ -337,1 +270,1 @@\n-            Path relativeInstallDir) implements Package {\n+            AppImageLayout installedPackageLayout, Path relativeInstallDir) implements Package {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Package.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    void createRuntime(AppImageLayout appImageLayout) throws PackagerException;\n+    void create(AppImageLayout appImageLayout) throws PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -42,2 +43,21 @@\n-        return create(new AppImageLayout.Stub(resolveNullablePath(root, rootDirectory()),\n-                resolveNullablePath(root, runtimeDirectory())));\n+        return (RuntimeLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default RuntimeLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(runtimeDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default RuntimeLayout unresolve() {\n+        return (RuntimeLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default RuntimeLayout map(UnaryOperator<Path> mapper) {\n+        return create(new RuntimeLayout.Stub(mapNullablePath(mapper, rootDirectory()),\n+                mapNullablePath(mapper, runtimeDirectory())));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeLayout.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-public class ResourceLocator {\n-    public ResourceLocator() {\n+public final class ResourceLocator {\n+    private ResourceLocator() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/ResourceLocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,0 +473,17 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(entries);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        PathGroup other = (PathGroup) obj;\n+        return Objects.equals(entries, other.entries);\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathGroup.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -50,2 +52,7 @@\n-    public static Path resolveNullablePath(Path base, Path path) {\n-        return Optional.ofNullable(path).map(base::resolve).orElse(null);\n+    public static Path mapNullablePath(UnaryOperator<Path> mapper, Path path) {\n+        Objects.requireNonNull(mapper);\n+        if (path != null) {\n+            return mapper.apply(path);\n+        } else {\n+            return null;\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathUtils.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -50,1 +49,0 @@\n-                .appImageLayoutForPackaging(Package::appImageLayout)\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                pkg.installedPackageLayout(),\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinExePackage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/JShellConsole.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -68,1 +66,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jshell\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-     * {@code \"Garbage collection performed by the JVM\"\"}.\n+     * {@code \"Garbage collection performed by the JVM\"}.\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/EventTypeInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.file.Paths;\n@@ -50,1 +51,1 @@\n- * Specify which events should be enabled and what kind information each\n+ * Specify which events should be enabled and what kind of information each\n@@ -62,1 +63,1 @@\n- * The following table shows the options names to use with {@link #setRecordingOptions(long, Map)}\n+ * The following table shows the option names to use with {@link #setRecordingOptions(long, Map)}\n@@ -70,1 +71,1 @@\n- * <th scope=\"col\">Descripion<\/th>\n+ * <th scope=\"col\">Description<\/th>\n@@ -110,1 +111,1 @@\n- * <td>Specifies the size, measured in bytes, at which data is kept in disk\n+ * <td>Specifies the size, measured in bytes, at which data is kept in the disk\n@@ -134,2 +135,2 @@\n- * is relative to the working directory where the target JVM was started.}<\/td>\n- * <td>{@code \"c:\\recording\\recotding.jfr\"},<br>\n+ * is relative to the working directory where the target JVM was started.<\/td>\n+ * <td>{@code \"c:\\recording\\recording.jfr\"},<br>\n@@ -148,1 +149,1 @@\n- * <td>Sets how long the recording should be running<\/td>\n+ * <td>Specifies the duration of the recording.<\/td>\n@@ -290,1 +291,1 @@\n-     * <th scope=\"col\">Descripion<\/th>\n+     * <th scope=\"col\">Description<\/th>\n@@ -340,1 +341,1 @@\n-     * To be able to read from a running recording the value must be set<\/td>\n+     * To be able to read from a running recording the value must be set to<\/td>\n@@ -358,1 +359,1 @@\n-     * @throws IllegalArgumentException if a recording with the iD doesn't\n+     * @throws IllegalArgumentException if a recording with the ID doesn't\n@@ -428,1 +429,1 @@\n-     * @param recordingId the ID of the recordings to get settings for\n+     * @param recordingId the ID of the recording to get settings for\n@@ -525,1 +526,1 @@\n-     * Returns the list of the available recordings, not necessarily running.\n+     * Returns the list of available recordings, not necessarily running.\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBean.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-     * {@code \"The duration an event must exceed to be be recorded\"}).\n+     * {@code \"The duration an event must exceed to be recorded\"}).\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/SettingDescriptorInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -446,1 +446,1 @@\n-TEST(BasicShenandoahSimpleBitMapTest, minimum_test) {\n+TEST_F(ShenandoahSimpleBitMapTest, minimum_test) {\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+        int ri = reversed.length();\n@@ -131,1 +132,1 @@\n-          ASSERT_EQ(e, reversed.pop());\n+          ASSERT_EQ(e, reversed.at(--ri));\n@@ -133,0 +134,1 @@\n+        ASSERT_EQ(ri, 0);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zArray.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-      if (!compare_limits(a->category_limit(NMTUtil::index_to_tag(i)),\n-                          b->category_limit(NMTUtil::index_to_tag(i)))) {\n+      if (!compare_limits(a->mem_tag_limit(NMTUtil::index_to_tag(i)),\n+                          b->mem_tag_limit(NMTUtil::index_to_tag(i)))) {\n@@ -95,1 +95,1 @@\n-TEST(NMT, MallocLimitCategoryEnumNames) {\n+TEST(NMT, MallocLimitMemTagEnumNames) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,2 +91,2 @@\n-    int category = i % (mt_number_of_tags - 1);\n-    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)category);\n+    int mtag = i % (mt_number_of_tags - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)mtag);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+compiler\/macronodes\/TestTopInMacroElimination.java      8362832 generic-all\n+\n+gc\/stringdedup\/TestStringDeduplicationAgeThreshold.java 8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationInterned.java     8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationPrintOptions.java 8362562 generic-all\n+\n+\n+serviceability\/jvmti\/events\/SingleStep\/singlestep02\/singlestep02.java       8362350 generic-all\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t007\/TestDescription.java\t8362350 generic-all\n+\n+# Incompatbile tests\n+\n+# IR\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-A            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-U            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-U           0000000 generic-all\n+\n+# Requires solo jvmti capabilities\n+\n+compiler\/jvmci\/events\/JvmciShutdownEventTest.java                           0000000 generic-all\n+\n+# jdwp\n+runtime\/6294277\/SourceDebugExtension.java                                   0000000 generic-all\n+\n+# heap stats\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorArrayAllSampledTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorEventOnOffTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCParallelTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCSerialTest.java                         0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCTest.java                               0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorIllegalArgumentTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInitialAllocationTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterArrayTest.java                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterObjectTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorMultiArrayTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorNoCapabilityTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorRecursiveTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatArrayCorrectnessTest.java             0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatIntervalTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatObjectCorrectnessTest.java            0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatSimpleTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTest.java                                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadDisabledTest.java                   0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadOnOffTest.java                      0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadTest.java                           0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTwoAgentsTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id0                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id1                     0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-jvmti-stress-agent.txt","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8358781\n+ * @summary Regression test for -XX:-TypeProfileCasts crash\n+ * @requires vm.debug\n+ * @run main\/othervm -XX:-TypeProfileCasts -XX:CompileThresholdScaling=0.01\n+ *                   compiler.arguments.TestProfileCasts\n+ *\/\n+package compiler.arguments;\n+\n+public class TestProfileCasts {\n+    static class Foo {\n+    }\n+\n+    private static void test(Object o) {\n+        if (o instanceof Foo) {\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100; i++) {\n+            test(new Foo());\n+            test(null);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestProfileCasts.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361842\n+ * @summary Verify the effectiveness of the `VerifyIntrinsicChecks` VM flag\n+ *          through (bypassing `StringCoding::encodeAsciiArray`, and) feeding\n+ *          invalid input to an intrinsified `StringCoding::encodeAsciiArray0`\n+ *          (note the `0` suffix!).\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true & vm.flavor == \"server\" & !vm.graal.enabled\n+ * @run main\/othervm compiler.intrinsics.TestVerifyIntrinsicChecks verify\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+import java.lang.Helper;\n+import java.time.Instant;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public final class TestVerifyIntrinsicChecks {\n+\n+    public static void main(String[] args) throws Exception {\n+        switch (args[0]) {\n+            case \"verify\" -> {\n+                log(\"Starting JVM in a separate process to verify the crash\");\n+                OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                        \"-Xcomp\",\n+                        \"-XX:-TieredCompilation\",\n+                        \"-XX:CompileCommand=inline,java.lang.StringCoding::encodeAsciiArray0\",\n+                        \"-XX:+VerifyIntrinsicChecks\",\n+                        \"--patch-module\", \"java.base=%s\/java.base\".formatted(System.getProperty(\"test.patch.path\")),\n+                        \"compiler.intrinsics.TestVerifyIntrinsicChecks\",\n+                        \"crash\");\n+                outputAnalyzer.shouldContain(\"unexpected null in intrinsic\");\n+                outputAnalyzer.shouldNotHaveExitValue(0);\n+            }\n+            case \"crash\" -> {\n+                log(\"Triggering the crash\");\n+                warmUpIntrinsicMethod();\n+                violateIntrinsicMethodContract();\n+            }\n+            default -> throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    private static void warmUpIntrinsicMethod() {\n+        log(\"Warming up the intrinsic method\");\n+        char[] sa = createAsciiChars(8192);\n+        byte[] sp = new byte[4096];\n+        for (int i = 0; i < 1_000; i++) {\n+            Helper.StringCodingEncodeAsciiArray0(sa, i, sp, 0, sp.length - i);\n+        }\n+    }\n+\n+    private static char[] createAsciiChars(int length) {\n+        char[] buffer = new char[length];\n+        for (int i = 0; i < length; i++) {\n+            buffer[i] = (char) (i % '\\u0080');\n+        }\n+        return buffer;\n+    }\n+\n+    private static void violateIntrinsicMethodContract() {\n+        log(\"Violating the intrinsic method contract (sa=null)\");\n+        Helper.StringCodingEncodeAsciiArray0(null, 1, null, 1, 1);\n+    }\n+\n+    private synchronized static void log(String format, Object... args) {\n+        Object[] extendedArgs = new Object[2 + args.length];\n+        extendedArgs[0] = Instant.now();\n+        extendedArgs[1] = Thread.currentThread().getName();\n+        System.arraycopy(args, 0, extendedArgs, extendedArgs.length - args.length, args.length);\n+        String extendedFormat = \"%%s [%%s] %s%%n\".formatted(format);\n+        System.out.printf(extendedFormat, extendedArgs);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestVerifyIntrinsicChecks.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+\n@@ -49,2 +50,20 @@\n-\/**\n- * This test was derived from compiler.intrinsics.string.TestHasNegatives\n+\n+\/*\n+ * @test\n+ * @bug 8281146\n+ * @summary Verify `StringCoding::countPositives` intrinsic Java wrapper checks\n+ *          by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      compiler.intrinsics.string.TestCountPositives\n@@ -52,0 +71,1 @@\n+\n@@ -56,1 +76,0 @@\n-import java.util.stream.IntStream;\n@@ -60,0 +79,3 @@\n+\/**\n+ * This test was derived from {@link TestHasNegatives}.\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,20 @@\n+\/*\n+ * @test\n+ * @bug 6896617 8274242\n+ * @summary Verify `sun.nio.cs.ISO_8859_1.Encoder::encodeISOArray` intrinsic\n+ *          Java wrapper checks by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @run main\/othervm\/timeout=1200\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      --add-opens=java.base\/sun.nio.cs=ALL-UNNAMED -Xbatch -Xmx256m\n+ *      compiler.intrinsics.string.TestEncodeIntrinsics\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestEncodeIntrinsics.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+\n@@ -49,0 +50,21 @@\n+\/*\n+ * @test\n+ * @bug 8054307\n+ * @summary Verify `StringCoding::hasNegatives` intrinsic Java wrapper checks\n+ *          by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      compiler.intrinsics.string.TestHasNegatives\n+ *\/\n+\n@@ -53,1 +75,0 @@\n-import java.util.stream.IntStream;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestHasNegatives.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jtreg.SkippedException;\n@@ -352,0 +353,1 @@\n+        checkCompatibleFlags();\n@@ -790,0 +792,8 @@\n+    private void checkCompatibleFlags() {\n+        for (String flag : Utils.getTestJavaOpts()) {\n+            if (flag.contains(\"-agentpath\")) {\n+                throw new SkippedException(\"Can't run test with agent.\");\n+            }\n+        }\n+    }\n+\n@@ -796,0 +806,3 @@\n+            if (flag.contains(\"agentpath\")) {\n+                throw new SkippedException(\"Can't run test with -javaagent\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -384,1 +384,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -420,1 +420,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -456,1 +456,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n@@ -492,1 +492,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/InvariantCodeMotionReassociateAddSub.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -709,3 +709,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -723,3 +725,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -801,6 +805,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -810,1 +808,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -813,2 +811,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n@@ -826,6 +822,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -835,1 +825,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -838,2 +828,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Scenario;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment with unaligned access\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentByteSizeLongLoopLimit\n+ *\/\n+\n+\n+public class TestMemorySegmentByteSizeLongLoopLimit {\n+    public static int SIZE = 10_000;\n+\n+    public static int[] a = new int[SIZE];\n+    public static long[] b = new long[SIZE];\n+\n+    public static MemorySegment msA = MemorySegment.ofArray(a);\n+    public static MemorySegment msB = MemorySegment.ofArray(b);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\",        \"> 0\",\n+                  IRNode.STORE_VECTOR,                          \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void test() {\n+        for (long i = 0; i < msA.byteSize() \/ 8L; i++) {\n+            int v = msA.get(ValueLayout.JAVA_INT_UNALIGNED, i * 4L);\n+            msB.set(ValueLayout.JAVA_LONG_UNALIGNED, i * 8L, v + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentByteSizeLongLoopLimit.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment stored in field\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentField\n+ *\/\n+\n+public class TestMemorySegmentField {\n+    static int SIZE = 10_000;\n+    static MemorySegment MS = Arena.ofAuto().allocate(SIZE * 4);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    static int zeroInvarI = 0;\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void testFields() {\n+        int invar = zeroInvarI;\n+        for (long i = 0; i < MS.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = MS.get(ValueLayout.JAVA_BYTE, adr);\n+            MS.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentField.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -42,0 +42,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int StringCodingEncodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n+        return StringCoding.encodeAsciiArray0(sa, sp, da, dp, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.test.lib.Platform;\n@@ -63,0 +64,3 @@\n+        \/\/ On s390x, generated code is ~6x larger in fastdebug and ~1.4x in release builds vs. other archs,\n+        \/\/ hence we require slightly more minimum space.\n+        int minInitialSize = 2000 + (Platform.isS390x() ? 800 : 0);\n@@ -64,1 +68,1 @@\n-            int initialCodeCacheSizeInKb = 2000 + rand.nextInt(400);\n+            int initialCodeCacheSizeInKb = minInitialSize + rand.nextInt(400);\n","filename":"test\/hotspot\/jtreg\/compiler\/startup\/StartupOutput.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    \/\/ The ConvI2L can be split through the AddI, creating a mix of\n+    \/\/ The ConvI2L can be pushed through the AddI, creating a mix of\n@@ -135,2 +135,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -158,2 +157,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/UseCompressedOops.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                output.shouldContain(\"(sent by safepoint timeout handler\");\n+                output.shouldContain(\"(sent by safepoint timeout handler)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Safepoint\/TestAbortVMOnSafepointTimeout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,0 +260,10 @@\n+\n+        \/\/ Training run with -XX:+PrintTieredEvents (see JDK-8362530).\n+        printTestCase(\"Training run with -XX:+PrintTieredEvents\");\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:+PrintTieredEvents\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"train-with-tiered-events\");\n+        out.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotFlags\/AOTFlags.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+                    \"share\/interpreter\",\n+                    \"share\/jfr\",\n","filename":"test\/hotspot\/jtreg\/sources\/TestIncludesAreSorted.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java                         8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java              8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/ResumptionUpdateBoundValues.java            8362658 generic-all\n+sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java                       8362658 generic-all\n+\n+\n+# List of tests incompatible with jvmti stress agent or requiring more investigation\n+\n+com\/sun\/jdi\/EATests.java#id0                                                0000000 generic-all\n+com\/sun\/jdi\/ThreadMemoryLeakTest.java                                       0000000 generic-all\n+\n+# weak referenced are not cleared\n+java\/lang\/WeakPairMap\/Driver.java                                           0000000 generic-all\n+java\/lang\/ref\/ReachabilityFenceTest.java                                    0000000 generic-all\n","filename":"test\/jdk\/ProblemList-jvmti-stress-agent.txt","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,3 @@\n- * @bug 8256321\n- * @summary Verifies profile properties are the same before\/after activation\n+ * @bug 8256321 8359380\n+ * @summary Verifies built-in profile properties are the same before and after\n+ *          activation and in copies of built-in profiles\n@@ -49,6 +50,9 @@\n-        \/\/ check default values, before profile activation\n-        test(srgb, TYPE_RGB, 3, CLASS_DISPLAY);\n-        test(gray, TYPE_GRAY, 1, CLASS_DISPLAY);\n-        test(xyz, TYPE_XYZ, 3, CLASS_ABSTRACT);\n-        test(lrgb, TYPE_RGB, 3, CLASS_DISPLAY);\n-        test(pycc, TYPE_3CLR, 3, CLASS_COLORSPACECONVERSION);\n+        \/\/ checks default values before built-in profiles are activated\n+        test(srgb, gray, xyz, lrgb, pycc);\n+\n+        \/\/ activates built-in profiles and creates copies\n+        ICC_Profile srgbCopy = ICC_Profile.getInstance(srgb.getData());\n+        ICC_Profile grayCopy = ICC_Profile.getInstance(gray.getData());\n+        ICC_Profile xyzCopy = ICC_Profile.getInstance(xyz.getData());\n+        ICC_Profile lrgbCopy = ICC_Profile.getInstance(lrgb.getData());\n+        ICC_Profile pyccCopy = ICC_Profile.getInstance(pycc.getData());\n@@ -56,6 +60,6 @@\n-        \/\/ activate profiles\n-        srgb.getData();\n-        gray.getData();\n-        xyz.getData();\n-        lrgb.getData();\n-        pycc.getData();\n+        \/\/ checks default values after profile activation\n+        test(srgb, gray, xyz, lrgb, pycc);\n+\n+        \/\/ checks default values in copies of the built-in profiles\n+        test(srgbCopy, grayCopy, xyzCopy, lrgbCopy, pyccCopy);\n+    }\n@@ -63,1 +67,3 @@\n-        \/\/ check default values, after profile activation\n+    private static void test(ICC_Profile srgb, ICC_Profile gray,\n+                             ICC_Profile xyz, ICC_Profile lrgb,\n+                             ICC_Profile pycc) {\n","filename":"test\/jdk\/java\/awt\/color\/CheckDefaultProperties.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    private static final String EXCEPTION_MSG = \"Built-in profile cannot be modified\";\n+    private static final String EXCEPTION_MSG = \"Can't modify built-in profile\";\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/BuiltInProfileCheck\/BuiltInProfileCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ColorConvertOp;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/**\n+ * @test\n+ * @bug 8272860 8359380\n+ * @summary Verifies that ICC_Profile methods work correctly after a\n+ *          ColorConvertOp transformation\n+ * @library \/test\/lib\n+ *\/\n+public final class GetProfileDataAfterTransform {\n+\n+    private static final int[] CSS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY,\n+            ColorSpace.CS_LINEAR_RGB, ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    \/**\n+     * The main process records expected get*() values before conversion and\n+     * passes them to a subprocess, which verifies it after the transform.\n+     *\n+     * @param  args If empty, the main process runs all color space pairs and\n+     *         spawns subprocesses. If not empty, args[0] and args[1] are source\n+     *         and target color space constants, followed by expected profile\n+     *         values to validate in the subprocess.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            for (int csFrom : CSS) {\n+                for (int csTo : CSS) {\n+                    var from = (ICC_ColorSpace) ColorSpace.getInstance(csFrom);\n+                    var to = (ICC_ColorSpace) ColorSpace.getInstance(csTo);\n+\n+                    ICC_Profile profileFrom = from.getProfile();\n+                    ICC_Profile profileTo = to.getProfile();\n+\n+                    List<String> cmd = new ArrayList<>();\n+                    cmd.add(GetProfileDataAfterTransform.class.getSimpleName());\n+\n+                    cmd.add(String.valueOf(csFrom));\n+                    cmd.add(String.valueOf(csTo));\n+\n+                    for (ICC_Profile p : List.of(profileFrom, profileTo)) {\n+                        cmd.add(String.valueOf(p.getPCSType()));\n+                        cmd.add(String.valueOf(p.getProfileClass()));\n+                        cmd.add(String.valueOf(p.getMinorVersion()));\n+                        cmd.add(String.valueOf(p.getMajorVersion()));\n+                        cmd.add(String.valueOf(p.getColorSpaceType()));\n+                        cmd.add(String.valueOf(p.getNumComponents()));\n+                    }\n+\n+                    OutputAnalyzer output = ProcessTools.executeTestJava(cmd);\n+                    output.shouldHaveExitValue(0).stdoutShouldBeEmpty()\n+                          .stderrShouldBeEmpty();\n+                }\n+            }\n+        } else {\n+            int csFrom = Integer.parseInt(args[0]);\n+            int csTo = Integer.parseInt(args[1]);\n+            var from = (ICC_ColorSpace) ColorSpace.getInstance(csFrom);\n+            var to = (ICC_ColorSpace) ColorSpace.getInstance(csTo);\n+\n+            BufferedImageOp op = new ColorConvertOp(from, to, null);\n+            \/\/ Note from.getProfile() and to.getProfile() are not loaded yet!\n+            op.filter(new BufferedImage(10, 10, TYPE_INT_RGB),\n+                      new BufferedImage(10, 10, TYPE_INT_RGB));\n+\n+            test(from.getProfile(), args, 2);\n+            test(to.getProfile(), args, 8);\n+        }\n+    }\n+\n+    private static void test(ICC_Profile profile, String[] args, int offset) {\n+        \/\/ Uncomment when JDK-8272860 is fixed\n+        \/\/ if (profile.getData() == null) {\n+        \/\/    throw new RuntimeException(\"Profile data is null\");\n+        \/\/ }\n+        if (profile.getPCSType() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong PCStype\");\n+        }\n+        if (profile.getProfileClass() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong ProfileClass\");\n+        }\n+        if (profile.getMinorVersion() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong MinorVersion\");\n+        }\n+        if (profile.getMajorVersion() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong MajorVersion\");\n+        }\n+        if (profile.getColorSpaceType() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong ColorSpaceType\");\n+        }\n+        if (profile.getNumComponents() != Integer.parseInt(args[offset])) {\n+            throw new RuntimeException(\"Wrong NumComponents\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/GetProfileDataAfterTransform.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-#ifdef _AIX\n@@ -77,3 +76,0 @@\n-#else\n-        printf(\"%X %X\\n\", act.sa_flags, act.sa_mask);\n-#endif\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/exePrintSignalDisposition.c","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-        lst.add(\"myCookie2=bar; path=\/dir; expires=Tue, 19 Aug 2025 16:00:00 GMT\");\n-        lst.add(\"myCookie3=test; path=\/dir; expires=Tue Aug 19 2025 16:00:00 GMT-0100\");\n+        lst.add(\"myCookie2=bar; path=\/dir; expires=Fri, 19 Aug 4242 16:00:00 GMT\");\n+        lst.add(\"myCookie3=test; path=\/dir; expires=Fri Aug 19 4242 16:00:00 GMT-0100\");\n@@ -67,1 +67,2 @@\n-            fail(\"Should have 5 cookies. Got only \"+ cookies.size() + \", expires probably didn't parse correctly\");\n+            fail(\"unexpected cookies: \" + cookies + \", should have 5 cookies. Got only \"\n+                    + cookies.size() + \", expires probably didn't parse correctly\");\n","filename":"test\/jdk\/java\/net\/CookieHandler\/B6644726.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-public class ProxyServer extends Thread implements Closeable {\n+public final class ProxyServer implements Closeable {\n@@ -100,3 +100,1 @@\n-    public ProxyServer(Integer port,\n-                       Boolean debug,\n-                       Credentials credentials)\n+    private ProxyServer(Integer port, Boolean debug, Credentials credentials)\n@@ -111,8 +109,0 @@\n-        setName(\"ProxyListener\");\n-        setDaemon(true);\n-        connections = new CopyOnWriteArrayList<Connection>();\n-        start();\n-    }\n-\n-    public ProxyServer(String s) {\n-        credentials = null;\n@@ -120,0 +110,1 @@\n+        Thread.ofPlatform().name(\"ProxyListener\").daemon().start(this::run);\n@@ -151,1 +142,1 @@\n-    public void run() {\n+    private void run() {\n@@ -659,4 +650,5 @@\n-        ProxyServer ps = new ProxyServer(port, debug);\n-        System.out.println(\"Proxy server listening on port \" + ps.getPort());\n-        while (true) {\n-            Thread.sleep(5000);\n+        try (ProxyServer ps = new ProxyServer(port, debug)) {\n+            System.out.println(\"Proxy server listening on port \" + ps.getPort());\n+            while (true) {\n+                Thread.sleep(5000);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @requires (os.family == \"linux\" | os.family == \"mac\" | os.family == \"aix\")\n","filename":"test\/jdk\/java\/nio\/file\/DirectoryStream\/SecureDS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8362448\n+ * @summary Verify DecimalFormat::format on doubles.\n+ * @run junit DoubleFormattingTest\n+ * @run junit\/othervm -Djdk.compat.DecimalFormat=true DoubleFormattingTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.util.Formatter;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DoubleFormattingTest {\n+\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n+    static Stream<Arguments> testFormat() {\n+        return Stream.of(\n+                Arguments.of(4.8726570057E288, 0),\n+                Arguments.of(7.3879E20, 0),\n+                Arguments.of(1.9400994884341945E25, 0),\n+                Arguments.of(6.3E-322, 324)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testFormat(double v, int minFractionDigits) {\n+        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ROOT);\n+        df.setGroupingUsed(false);\n+        df.setMinimumFractionDigits(minFractionDigits);\n+        String actual = df.format(v);\n+        Formatter fmt = new Formatter(Locale.ROOT);\n+        fmt.format(\"%.\" + minFractionDigits + \"f\", v);\n+        String expected = fmt.toString();\n+        if (COMPAT) {\n+            assertNotEquals(expected, actual);\n+        } else {\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DoubleFormattingTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361638\n@@ -40,0 +41,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -53,5 +56,0 @@\n-import static java.lang.constant.ConstantDescs.CD_Double;\n-import static java.lang.constant.ConstantDescs.CD_Integer;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-\n@@ -64,0 +62,24 @@\n+    @Test\n+    void testExceptionalContracts() throws Throwable {\n+        generateTryCatchMethod(catchBuilder -> {\n+            Consumer<CodeBuilder.BlockCodeBuilder> handler = tb -> tb.pop().aconst_null().areturn();\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catching(CD_NPE, null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(null, handler));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(List.of(), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(Collections.singletonList(null), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingAll(null));\n+            catchBuilder.catchingMulti(List.of(CD_IOOBE, CD_NPE), tb -> {\n+                tb.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                tb.astore(1);\n+            });\n+            catchBuilder.catchingAll(tb -> tb.pop().loadConstant(\"all\").areturn());\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(CD_int, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(CD_NPE, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(null, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(CD_Exception, CD_IOOBE), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(CD_long, CD_Throwable), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingAll(handler));\n+        });\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/configuration\/TestGCHeapConfigurationEventWith32BitOops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/configuration\/TestGCHeapConfigurationEventWithZeroBasedOops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-        Asserts.assertGT((long) re.getValue(\"elements\"), 0L, \"No elements\");\n-        Asserts.assertGT((long) re.getValue(\"size\"), 0L, \"Empty size\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFlush.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+        launcher.addToolArg(\"--exact\");\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestPrintContextual.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        for (var i = 0; i < 10_000; i++) {\n+        for (var i = 0; i < 1000; i++) {\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -65,2 +67,1 @@\n-            System.out.println(\"No support of DH KeyPairGenerator, skipping\");\n-            return;\n+           throw new SkippedException(\"No support of DH KeyPairGenerator, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/SupportedDHKeys.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jtreg.SkippedException;\n@@ -47,2 +48,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestDH.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jtreg.SkippedException;\n@@ -79,2 +80,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestInterop.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import jtreg.SkippedException;\n+\n@@ -93,2 +95,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n@@ -96,0 +97,1 @@\n+\n@@ -97,2 +99,0 @@\n-            DHPublicKeySpec publicSpec;\n-            DHPrivateKeySpec privateSpec;\n@@ -109,1 +109,1 @@\n-            if (Arrays.equals(s2, n2) == false) {\n+            if (!Arrays.equals(s2, n2)) {\n@@ -117,1 +117,1 @@\n-            if (Arrays.equals(s3, n3) == false) {\n+            if (!Arrays.equals(s3, n3)) {\n@@ -126,21 +126,0 @@\n-\n-\/*\n-        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DH\", provider);\n-        kpg.initialize(512);\n-\/\/        KeyPair kp1 = kpg.generateKeyPair();\n-\/\/      System.out.println(kp1.getPublic());\n-\/\/      System.out.println(kp1.getPrivate());\n-        while (true) {\n-            KeyAgreement ka = KeyAgreement.getInstance(\"DH\", provider);\n-            ka.init(pr1);\n-            KeyPair kp2 = kpg.generateKeyPair();\n-            ka.doPhase(kp2.getPublic(), true);\n-            byte[] sec = ka.generateSecret();\n-            if (sec.length == 64) {\n-                System.out.println(kp2.getPrivate());\n-                System.out.println(kp2.getPublic());\n-                System.out.println(toString(sec));\n-                break;\n-            }\n-        }\n-\/**\/\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestShort.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -62,2 +64,1 @@\n-            System.out.println(\"No supported of DH KeyPairGenerator, skipping\");\n-            return;\n+            throw new SkippedException(\"DH (DiffieHellman) is not supported in KeyPairGenerator, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/UnsupportedDHKeys.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8309841\n+ * @bug 8309841 8365559\n@@ -43,0 +43,2 @@\n+    private static final String WEAK_UNSIGNED\n+            = \"The jar will be treated as unsigned, because it is signed with a weak algorithm that is now disabled\";\n@@ -45,0 +47,5 @@\n+        t8309841();\n+        t8365559();\n+    }\n+\n+    static void t8309841() throws Exception {\n@@ -92,0 +99,8 @@\n+    }\n+\n+    static void t8365559() throws Exception {\n+        JarUtils.createJarFile(\n+                Path.of(\"c.jar\"),\n+                Path.of(\".\"),\n+                Files.writeString(Path.of(\"c\"), \"c\"));\n+        SecurityTools.keytool(\"-genkeypair -storepass changeit -keystore ks -alias w -dname CN=w -keyalg ec\");\n@@ -93,0 +108,12 @@\n+        \/\/ Sign the JAR using an already disabled signature algorithm SHA1withECDSA.\n+        \/\/ The file can still be signed but verification will treat it as unsigned.\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks c.jar w -sigalg SHA1withECDSA\")\n+                        .shouldContain(\"the -sigalg option is considered a security risk and is disabled.\");\n+\n+        SecurityTools.jarsigner(\"-verify c.jar\")\n+                .shouldContain(WEAK_UNSIGNED)\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND);\n+        SecurityTools.jarsigner(\"-verify -verbose c.jar\")\n+                .shouldContain(WEAK_UNSIGNED)\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND)\n+                .shouldNotContain(\"Warning: nonexistent signed entries:\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RemovedFiles.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/helpers-test\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,5 +45,4 @@\n-    public static void testClassFilePath(String... args) {\n-        var appDesc = args[0];\n-        var expectedClassFilePath = Path.of(args[1]);\n-        TKit.assertEquals(expectedClassFilePath.toString(), JavaAppDesc.parse(\n-                appDesc).classFilePath().toString(), null);\n+    public static void testClassFilePath(String appDesc, String expectedClassFile) {\n+        var expectedClassFilePath = Path.of(expectedClassFile);\n+        TKit.assertEquals(expectedClassFilePath.toString(),\n+                JavaAppDesc.parse(appDesc).classFilePath().toString(), null);\n@@ -58,0 +57,6 @@\n+            createTestCase(\"bye.jar:!\", appDesc -> {\n+                return appDesc\n+                        .setBundleFileName(\"bye.jar\")\n+                        .setClassName(\"Hello\")\n+                        .setWithMainClass(true);\n+            }),\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JavaAppDescTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1177,4 +1177,9 @@\n-            TKit.assertStringListEquals(\n-                    addLauncherNames().stream().sorted().toList(),\n-                    aif.addLaunchers().keySet().stream().sorted().toList(),\n-                    \"Check additional launcher names\");\n+            \/\/ Don't compare the add launchers configured on the command line with the\n+            \/\/ add launchers listed in the `.jpackage.xml` file if the latter comes from\n+            \/\/ a predefined app image.\n+            if (!hasArgument(\"--app-image\")) {\n+                TKit.assertStringListEquals(\n+                        addLauncherNames().stream().sorted().toList(),\n+                        aif.addLaunchers().keySet().stream().sorted().toList(),\n+                        \"Check additional launcher names\");\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class LinuxApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static LinuxApplicationLayout createLayout() {\n+        return LinuxApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"libapplauncher.so\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test LinuxApplicationLayout\n+ * @requires (os.family == \"linux\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class MacApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static MacApplicationLayout createLayout() {\n+        return MacApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"Contents\/runtime\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test MacApplicationLayoutTest\n+ * @requires (os.family == \"mac\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class BuildEnvTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"image\"})\n+    public void testUnresolvedAppImageLayout(Path appImageDir) {\n+        final var rootDir = Path.of(\"\");\n+\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory());\n+\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @Test\n+    public void testResolvedAppImageLayout() {\n+        final var rootDir = Path.of(\"\/oof\");\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final var layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true, BuildEnvTest.class, layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\/foo\/bar\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"\/foo\/bar\"})\n+    public void test_withAppImageDir(Path appImageDir) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var layout = RuntimeLayout.DEFAULT;\n+        final var env = BuildEnv.withAppImageDir(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, layout), appImageDir);\n+\n+        assertNotSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(appImageDir, env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_withAppImageLayout(boolean resolved) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final AppImageLayout layout;\n+        if (resolved) {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        } else {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory();\n+        }\n+\n+        final var env = BuildEnv.withAppImageLayout(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, RuntimeLayout.DEFAULT), layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @Test\n+    public void test_asApplicationLayout() {\n+        final var rootDir = Path.of(\"r\");\n+\n+        assertTrue(BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT).asApplicationLayout().isEmpty());\n+\n+        var layout = ApplicationLayout.build().setAll(\"foo\").create();\n+        assertSame(layout, BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, layout).asApplicationLayout().orElseThrow());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/BuildEnvTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,872 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.CopyAppImageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.NoArgTaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.TaskContext;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class PackagingPipelineTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1, withRuntimeBuilder ? Optional.of(TestRuntimeBuilder.INSTANCE) : Optional.empty());\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(app).create();\n+\n+        \/\/ Build application image in `env.appImageDir()` directory.\n+        final var builder = buildPipeline();\n+        if (app.runtimeBuilder().isEmpty()) {\n+            builder.task(BuildApplicationTaskID.RUNTIME).noaction().add();\n+        }\n+\n+        builder.create().execute(env, app);\n+\n+        assertEquals(app.appImageDirName(), env.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, app);\n+        }));\n+\n+        List<TaskID> expectedActions = new ArrayList<>();\n+        if (app.runtimeBuilder().isPresent()) {\n+            expectedActions.add(BuildApplicationTaskID.RUNTIME);\n+        }\n+        expectedActions.addAll(List.of(BuildApplicationTaskID.LAUNCHERS, BuildApplicationTaskID.CONTENT));\n+\n+        assertEquals(expectedActions, executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage;\n+        if (withRuntimeBuilder) {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT)\n+                    .file(\"runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+        } else {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT);\n+        }\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCopyApplication(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var srcApp = createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE);\n+\n+        final var srcEnv = buildEnv(workDir.resolve(\"build\")).appImageDirFor(srcApp).create();\n+\n+        \/\/ Build application image in `srcEnv.appImageDir()` directory.\n+        buildPipeline().create().execute(srcEnv, srcApp);\n+\n+        final var dstApp = createApp(TEST_LAYOUT_2, TestRuntimeBuilder.INSTANCE);\n+\n+        final var dstEnv = buildEnv(workDir.resolve(\"build-2\"))\n+                .appImageLayout(dstApp.imageLayout().resolveAt(workDir.resolve(\"a\/b\/c\")))\n+                .create();\n+\n+        \/\/ Copy application image from `srcEnv.appImageDir()` into `dstEnv.appImageDir()`\n+        \/\/ with layout transformation.\n+        \/\/ This test exercises flexibility of the packaging pipeline.\n+        final var builder = buildPipeline()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).applicationAction(cfg -> {\n+                    assertSame(dstApp, cfg.app());\n+                    assertEquals(dstEnv.appImageDir(), cfg.env().appImageLayout().rootDirectory());\n+                    assertFalse(Files.exists(dstEnv.appImageDir()));\n+                    PackagingPipeline.copyAppImage(srcEnv.appImageLayout(), cfg.env().appImageLayout(), false);\n+                }).add();\n+\n+        \/\/ Disable the default \"build application image\" actions of the tasks which\n+        \/\/ are the dependencies of `PrimaryTaskID.BUILD_APPLICATION_IMAGE` task as\n+        \/\/ their output will be overwritten in the custom action of this task.\n+        builder.taskGraphSnapshot().getAllTailsOf(PrimaryTaskID.BUILD_APPLICATION_IMAGE).forEach(taskId -> {\n+            builder.task(taskId).noaction().add();\n+        });\n+\n+        builder.create().execute(dstEnv, dstApp);\n+\n+        AppImageLayout.toPathGroup(dstEnv.appImageLayout()).paths().forEach(path -> {\n+            assertTrue(Files.exists(path));\n+        });\n+\n+        assertEquals(Path.of(\"c\"), dstEnv.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dstEnv, dstApp);\n+        }));\n+\n+        assertEquals(List.of(PrimaryTaskID.BUILD_APPLICATION_IMAGE), executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(\"q\/launchers\/my-launcher\", TestLauncher.CONTENT)\n+                .file(\"qqq\/runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(dstEnv.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCreatePackage(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(pkg).create();\n+\n+        final var builder = buildPipeline();\n+\n+        \/\/ Will create an app image in `env.appImageDir()` directory with `pkg.appImageLayout()` layout.\n+        \/\/ Will convert the created app image into a package.\n+        builder.create().execute(env, pkg, outputDir);\n+\n+        final var expected = createTestPackageFileContents(env.appImageLayout());\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"testCreatePackage:\\n---\\n%s\\n---\", actual));\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, pkg, outputDir);\n+        }));\n+\n+        assertEquals(List.of(\n+                BuildApplicationTaskID.RUNTIME,\n+                BuildApplicationTaskID.LAUNCHERS,\n+                BuildApplicationTaskID.CONTENT,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE\n+        ), executedTaskActions);\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final AppImageLayout srcLayout;\n+        if (transformLayout) {\n+            \/\/ Create an application layout such that the runtime directory doesn't\n+            \/\/ have a common parent with other directories otherwise the runtime directory\n+            \/\/ will be skipped when copying the app image layout as path groups because\n+            \/\/ the destination app image layout is of type RuntimeLayout and have only\n+            \/\/ the runtime directory.\n+            srcLayout = ApplicationLayout.build()\n+                    .launchersDirectory(\"launchers\")\n+                    .appDirectory(\"lib\")\n+                    .runtimeDirectory(\"runtime\")\n+                    .appModsDirectory(\"lib\")\n+                    .contentDirectory(\"lib\")\n+                    .desktopIntegrationDirectory(\"lib\")\n+                    .create();\n+        } else {\n+            srcLayout = RuntimeLayout.DEFAULT;\n+        }\n+\n+        \/\/ Create a runtime image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(srcLayout)\n+                .appImageDir(workDir.resolve(\"rt\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+\n+        final var pipeline = buildPackage(createApp(\n+                RuntimeLayout.DEFAULT.resolveAt(TEST_INSTALL_DIR).resetRootDirectory())).create();\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        createAndVerifyPackage(buildPipeline(), pipeline, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreateRuntimeInstaller(%s)\", transformLayout), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    private enum ExternalAppImageMode {\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant equals to `Package.appImageLayout()`.\n+        COPY_FROM_BUILD_ENV,\n+\n+        \/\/ Copy predefined app image from some directory.\n+        \/\/ Layout of the predefined app image is `Package.appImageLayout()`.\n+        COPY,\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant is NOT equal to `Package.appImageLayout()`.\n+        TRANSFORM_FROM_BUILD_ENV,\n+        ;\n+\n+        static final Set<ExternalAppImageMode> FROM_BUILD_ENV = Set.of(\n+                COPY_FROM_BUILD_ENV, TRANSFORM_FROM_BUILD_ENV);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ExternalAppImageMode.class)\n+    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout;\n+        final ExpectedAppImage expectedAppImage;\n+        if (ExternalAppImageMode.TRANSFORM_FROM_BUILD_ENV == mode) {\n+            appLayout = TEST_LAYOUT_2_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"q\/launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"qqq\/runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        } else {\n+            appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        }\n+\n+        final BuildEnv env;\n+        final Path predefinedAppImage;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImage = env.appImageDir();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            final var externalAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(externalAppImageLayout);\n+            TestLauncher.INSTANCE.create(externalAppImageLayout);\n+            predefinedAppImage = externalAppImageLayout.rootDirectory();\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImage)\n+                .create();\n+\n+        createAndVerifyPackage(buildPipeline(), pkg, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names={\"COPY\", \"COPY_FROM_BUILD_ENV\"})\n+    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+\n+        final BuildEnv env;\n+        final ApplicationLayout predefinedAppImageLayout;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImageLayout = env.asApplicationLayout().orElseThrow();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            predefinedAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(predefinedAppImageLayout);\n+            TestLauncher.INSTANCE.create(predefinedAppImageLayout);\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImageLayout.rootDirectory())\n+                .create();\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+\n+        final var builder = buildPipeline().configuredTasks().filter(task -> {\n+            return CopyAppImageTaskID.COPY.equals(task.task());\n+        }).findFirst().orElseThrow().noaction().add();\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        builder.create().execute(startupParameters);\n+\n+        final var expected = createTestPackageFileContents(predefinedAppImageLayout);\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\",\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), actual));\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(predefinedAppImageLayout.unresolve().launchersDirectory().resolve(\"my-launcher\"), TestLauncher.CONTENT)\n+                .file(predefinedAppImageLayout.unresolve().runtimeDirectory().resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(pkg.predefinedAppImage().orElseThrow()));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+        assertEquals(List.of(\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE), actualExecutedTaskActions);\n+    }\n+\n+    @Test\n+    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var env = setupBuildEnvForExternalAppImage(workDir);\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR)).create();\n+        final var pipeline = buildPipeline().create();\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, pkg, workDir));\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_RuntimeException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new RuntimeException(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_PackagerException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new PackagerException(\"param.vendor.default\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_Exception() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new Exception(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, PackagerException.class, () -> {\n+            rethrowUnchecked(expectedException);\n+        });\n+        assertSame(expectedException, ex.getCause());\n+    }\n+\n+    @Test\n+    void testAppImageAction() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).appImageAction(ctx -> {\n+                    assertSame(app, ctx.app());\n+                    assertSame(env, ctx.env());\n+                    executed[0] = true;\n+                }).add().create().execute(env, app);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testAppImageActionWithPackage() throws PackagerException, IOException {\n+\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        final var builder = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.PACKAGE).add();\n+\n+        final var startupParameters = builder.createStartupParameters(env,  pkg,  Path.of(\"\"));\n+\n+        builder.task(PrimaryTaskID.PACKAGE).appImageAction(ctx -> {\n+            assertSame(pkg.app(), ctx.app());\n+            assertSame(startupParameters.packagingEnv(), ctx.env());\n+            executed[0] = true;\n+        }).add().create().execute(startupParameters);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testPackageActionWithApplication() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).packageAction(ctx -> {\n+                    throw new AssertionError();\n+                }).add().create();\n+\n+        \/\/ If the pipeline is building an application, it can not execute actions that take a package as an argument.\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, app));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testContextMapper(boolean allowAll) throws PackagerException, IOException {\n+\n+        var builder = PackagingPipeline.buildStandard().contextMapper(ctx -> {\n+            return new TaskContext() {\n+                @Override\n+                public boolean test(TaskID task) {\n+                    return allowAll;\n+                }\n+\n+                @Override\n+                public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+                    if (!allowAll) {\n+                        throw new AssertionError();\n+                    }\n+                    ctx.execute(taskAction);\n+                }\n+            };\n+        });\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dummyBuildEnv(), createApp(TEST_LAYOUT_1));\n+        }));\n+\n+        List<TaskID> expectedExecutedTaskActions;\n+\n+        if (allowAll) {\n+            expectedExecutedTaskActions = List.of(\n+                    BuildApplicationTaskID.RUNTIME,\n+                    BuildApplicationTaskID.LAUNCHERS,\n+                    BuildApplicationTaskID.CONTENT,\n+                    BuildApplicationTaskID.APP_IMAGE_FILE,\n+                    CopyAppImageTaskID.COPY,\n+                    PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT);\n+        } else {\n+            expectedExecutedTaskActions = List.of();\n+        }\n+\n+        assertEquals(expectedExecutedTaskActions, actualExecutedTaskActions);\n+    }\n+\n+    public static List<PackagingPipeline.TaskID> dryRun(PackagingPipeline.Builder builder,\n+            Consumer<PackagingPipeline.Builder> callback) {\n+\n+        List<PackagingPipeline.TaskID> executedTaskActions = new ArrayList<>();\n+        builder.configuredTasks().filter(PackagingPipeline.Builder.TaskBuilder::hasAction).forEach(taskBuilder -> {\n+            var taskId = taskBuilder.task();\n+            taskBuilder.action(() -> {\n+                executedTaskActions.add(taskId);\n+            }).add();\n+        });\n+\n+        callback.accept(builder);\n+\n+        return executedTaskActions;\n+    }\n+\n+    private static Exception testExceptionRethrow(Exception expectedException,\n+            Class<? extends Exception> expectedCatchExceptionType,\n+            NoArgTaskAction throwAction) throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).action(throwAction).add().create();\n+\n+        return assertThrowsExactly(expectedCatchExceptionType, () -> pipeline.execute(env,  app));\n+    }\n+\n+    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) throws ConfigException {\n+        \/\/ Create an app image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(TEST_LAYOUT_1.resolveAt(Path.of(\"a\/b\/c\")).resetRootDirectory())\n+                .appImageDir(workDir.resolve(\"app-image\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+        TestLauncher.INSTANCE.create((ApplicationLayout)env.appImageLayout());\n+\n+        return env;\n+    }\n+\n+    private static void createAndVerifyPackage(PackagingPipeline.Builder builder, Package pkg,\n+            BuildEnv env, Path outputDir, String logMsgHeader, ExpectedAppImage expectedAppImage,\n+            TaskID... expectedExecutedTaskActions) throws PackagerException, IOException {\n+        Objects.requireNonNull(logMsgHeader);\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        assertNotSameAppImageDirs(env, startupParameters.packagingEnv());\n+\n+        \/\/ Will create an app image in `startupParameters.packagingEnv().appImageDir()` directory\n+        \/\/ with `pkg.appImageLayout()` layout using an app image (runtime image) from `env.appImageDir()` as input.\n+        \/\/ Will convert the created app image into a package.\n+        \/\/ Will not overwrite the contents of `env.appImageDir()` directory.\n+        builder.create().execute(startupParameters);\n+\n+        final var packagingAppImageDir = startupParameters.packagingEnv().appImageDir();\n+\n+        final var expected = createTestPackageFileContents(pkg.appImageLayout().resolveAt(packagingAppImageDir));\n+\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\", logMsgHeader, actual));\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(packagingAppImageDir));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+\n+        assertEquals(List.of(expectedExecutedTaskActions), actualExecutedTaskActions);\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout) {\n+        return createApp(appImageLayout, Optional.empty());\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, RuntimeBuilder runtimeBuilder) {\n+        return createApp(appImageLayout, Optional.of(runtimeBuilder));\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, Optional<RuntimeBuilder> runtimeBuilder) {\n+        Objects.requireNonNull(appImageLayout);\n+        Objects.requireNonNull(runtimeBuilder);\n+        if (appImageLayout.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new Application.Stub(\n+                \"foo\",\n+                \"My app\",\n+                \"1.0\",\n+                \"Acme\",\n+                \"copyright\",\n+                Optional.empty(),\n+                List.of(),\n+                appImageLayout,\n+                runtimeBuilder,\n+                List.of(),\n+                Map.of());\n+    }\n+\n+\n+    private static final class PackageBuilder {\n+        PackageBuilder(Application app) {\n+            this.app = Objects.requireNonNull(app);\n+        }\n+\n+        Package create() {\n+            return new Package.Stub(\n+                    app,\n+                    new PackageType() {},\n+                    \"the-package\",\n+                    \"My package\",\n+                    \"1.0\",\n+                    Optional.empty(),\n+                    Optional.empty(),\n+                    Optional.ofNullable(predefinedAppImage),\n+                    null,\n+                    TEST_INSTALL_DIR);\n+        }\n+\n+        PackageBuilder predefinedAppImage(Path v) {\n+            predefinedAppImage = v;\n+            return this;\n+        }\n+\n+        private Path predefinedAppImage;\n+        private final Application app;\n+    }\n+\n+\n+    private static PackageBuilder buildPackage(Application app) {\n+        return new PackageBuilder(app);\n+    }\n+\n+    private static BuildEnvBuilder buildEnv(Path rootDir) {\n+        return new BuildEnvBuilder(rootDir);\n+    }\n+\n+    private static BuildEnv dummyBuildEnv() {\n+        return BuildEnv.create(Path.of(\"foo\"), Optional.empty(), false, PackagingPipeline.class, RuntimeLayout.DEFAULT);\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline() {\n+        return PackagingPipeline.buildStandard()\n+                \/\/ Disable building the app image file (.jpackage.xml) as we don't have launchers in the test app.\n+                .task(BuildApplicationTaskID.APP_IMAGE_FILE).noaction().add()\n+                .task(BuildApplicationTaskID.LAUNCHERS).applicationAction(cfg -> {\n+                    TestLauncher.INSTANCE.create(cfg.resolvedLayout());\n+                }).add()\n+                .task(PrimaryTaskID.PACKAGE).packageAction(cfg -> {\n+                    var str = createTestPackageFileContents(cfg.resolvedLayout());\n+                    var packageFile = cfg.outputDir().resolve(cfg.pkg().packageFileNameWithSuffix());\n+                    Files.createDirectories(packageFile.getParent());\n+                    Files.writeString(packageFile, str);\n+                }).add();\n+    }\n+\n+    private static String createTestPackageFileContents(AppImageLayout pkgLayout) throws IOException {\n+        return ExpectedAppImage.load(pkgLayout.rootDirectory()).toString();\n+    }\n+\n+    private static void assertNotSameAppImageDirs(BuildEnv a, BuildEnv b) {\n+        assertNotEquals(a.appImageDir(), b.appImageDir());\n+        assertEquals(a.buildRoot(), b.buildRoot());\n+        assertEquals(a.configDir(), b.configDir());\n+        assertEquals(a.resourceDir(), b.resourceDir());\n+    }\n+\n+\n+    private static final class TestRuntimeBuilder implements RuntimeBuilder {\n+        @Override\n+        public void create(AppImageLayout appImageLayout) {\n+            assertTrue(appImageLayout.isResolved());\n+            try {\n+                Files.createDirectories(appImageLayout.runtimeDirectory());\n+                Files.writeString(runtimeFile(appImageLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path runtimeFile(AppImageLayout appImageLayout) {\n+            return appImageLayout.runtimeDirectory().resolve(\"my-runtime\");\n+        }\n+\n+        static final String CONTENT = \"this is the runtime\";\n+\n+        static final TestRuntimeBuilder INSTANCE = new TestRuntimeBuilder();\n+    }\n+\n+\n+    private static final class TestLauncher {\n+        public void create(ApplicationLayout appLayout) {\n+            assertTrue(appLayout.isResolved());\n+            try {\n+                Files.createDirectories(appLayout.launchersDirectory());\n+                Files.writeString(launcherFile(appLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path launcherFile(ApplicationLayout appLayout) {\n+            return appLayout.launchersDirectory().resolve(\"my-launcher\");\n+        }\n+\n+        static final String CONTENT = \"this is the launcher\";\n+\n+        static final TestLauncher INSTANCE = new TestLauncher();\n+    }\n+\n+\n+    private static final class ExpectedAppImage {\n+\n+        static ExpectedAppImage build() {\n+            return new ExpectedAppImage(new HashSet<>());\n+        }\n+\n+        static ExpectedAppImage load(Path appImageRoot) throws IOException {\n+            try (var walk = Files.walk(appImageRoot)) {\n+                return new ExpectedAppImage(walk.sorted().map(path -> {\n+                    var relativePath = appImageRoot.relativize(path);\n+                    if (Files.isDirectory(path)) {\n+                        return new Directory(relativePath);\n+                    } else {\n+                        return new File(relativePath, toSupplier(() -> Files.readString(path)).get());\n+                    }\n+                }).collect(Collectors.toSet()));\n+            }\n+        }\n+\n+        ExpectedAppImage file(Path path, String content) {\n+            return add(new File(path, content));\n+        }\n+\n+        ExpectedAppImage file(String path, String content) {\n+            return file(Path.of(path), content);\n+        }\n+\n+        ExpectedAppImage dir(Path path) {\n+            return add(new Directory(path));\n+        }\n+\n+        ExpectedAppImage dir(String path) {\n+            return dir(Path.of(path));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return items.stream().map(AppImageItem::toString).sorted().collect(Collectors.joining(\"\\n\"));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(items);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if ((obj == null) || (getClass() != obj.getClass())) {\n+                return false;\n+            }\n+            ExpectedAppImage other = (ExpectedAppImage) obj;\n+            return Objects.equals(items, other.items);\n+        }\n+\n+        private ExpectedAppImage(Set<AppImageItem> items) {\n+            this.items = Objects.requireNonNull(items);\n+        }\n+\n+        private ExpectedAppImage add(AppImageItem v) {\n+            var path = v.path();\n+            if (path.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            items.add(v);\n+            while (path.getNameCount() > 1) {\n+                items.add(new Directory(path = path.getParent()));\n+            }\n+            return this;\n+        }\n+\n+        private interface AppImageItem {\n+            Path path();\n+        }\n+\n+        private record File(Path path, String content) implements AppImageItem {\n+\n+            File {\n+                Objects.requireNonNull(path);\n+                Objects.requireNonNull(content);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return String.format(\"%s[%s]\", path, content);\n+            }\n+        }\n+\n+        private record Directory(Path path) implements AppImageItem {\n+\n+            Directory {\n+                Objects.requireNonNull(path);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return path.toString();\n+            }\n+        }\n+\n+        private final Set<AppImageItem> items;\n+    }\n+\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1 = ApplicationLayout.build()\n+            .launchersDirectory(\"launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2 = ApplicationLayout.build()\n+            .launchersDirectory(\"q\/launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"qqq\/runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final Path TEST_INSTALL_DIR = Path.of(\"Acme\/My app\");\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_1.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_2.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":872,"deletions":0,"binary":false,"changes":872,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -27,1 +28,1 @@\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -51,1 +53,1 @@\n-        final var pathGroup = AppImageLayout.toPathGroup(layout);\n+        final var pathGroup = toPathGroup(layout);\n@@ -59,1 +61,28 @@\n-        final var dir = Path.of(\"foo\/bar\");\n+        testResolveAt(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        testResolveAtRepeat(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        testUnresolve(new AppImageLayout.Stub(Path.of(\"runtime\")));\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        testEmptyRootDirectory(new AppImageLayout.Stub(Path.of(\"rt\")));\n+    }\n+\n+    public static void testResolveAt(AppImageLayout testee) {\n+\n+        var dir = Path.of(\"foo\/bar\");\n+\n+        assertLayout(testee.resolveAt(dir), true, testee, dir);\n+    }\n+\n+    public static void testResolveAtRepeat(AppImageLayout testee) {\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"b\/c\")).resolveAt(Path.of(\"a\"));\n@@ -61,1 +90,20 @@\n-        final var layout = new AppImageLayout.Stub(Path.of(\"\"), Path.of(\"runtime\"));\n+        assertLayout(resolvedLayout, true, testee, Path.of(\"a\/b\/c\"));\n+    }\n+\n+    public static void testUnresolve(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"foo\/bar\"));\n+        var layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        resolvedLayout = testee.resolveAt(Path.of(\"\").toAbsolutePath());\n+        layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        assertSame(testee, testee.unresolve());\n+    }\n@@ -63,1 +111,4 @@\n-        final var resolvedLayout = layout.resolveAt(dir);\n+    public static void testEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -65,1 +116,1 @@\n-        assertNotSame(layout, resolvedLayout);\n+        assertEmptyRootDirectory(testee);\n@@ -67,2 +118,25 @@\n-        assertEquals(dir.resolve(layout.rootDirectory()), resolvedLayout.rootDirectory());\n-        assertEquals(dir.resolve(layout.runtimeDirectory()), resolvedLayout.runtimeDirectory());\n+        final var resolved = testee.resolveAt(Path.of(\"t\"));\n+\n+        assertEmptyRootDirectory(resolved);\n+    }\n+\n+    private static void assertEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            var newLayout = testee.resetRootDirectory();\n+            assertLayout(newLayout, false, Path.of(\"\"), toPathGroup(testee));\n+        } else {\n+            assertSame(testee, testee.resetRootDirectory());\n+        }\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            AppImageLayout base, Path baseResolveAt) {\n+        assertLayout(actual, expectedResolved, baseResolveAt.resolve(base.rootDirectory()),\n+                toPathGroup(base).resolveAt(baseResolveAt));\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            Path expectedRootDir, PathGroup expectedPaths) {\n+        assertEquals(expectedResolved, actual.isResolved());\n+        assertEquals(expectedRootDir, actual.rootDirectory());\n+        assertEquals(expectedPaths, toPathGroup(actual));\n@@ -70,0 +144,1 @@\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n@@ -31,2 +34,0 @@\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -39,1 +40,31 @@\n-    public void test(boolean move, Path tempDir) throws IOException {\n+    @Test\n+    public void testMove(@TempDir Path tempDir) throws IOException {\n+        test(true, tempDir);\n+    }\n+\n+    @Test\n+    public void testCopy(@TempDir Path tempDir) throws IOException {\n+        test(false, tempDir);\n+    }\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    private static void test(boolean move, Path tempDir) throws IOException {\n@@ -58,8 +89,1 @@\n-        final var layout = ApplicationLayout.build()\n-                .launchersDirectory(\"bin\")\n-                .appDirectory(\"lib\/app\")\n-                .runtimeDirectory(\"runtime\")\n-                .appModsDirectory(\"mods\")\n-                .contentDirectory(\"content\")\n-                .desktopIntegrationDirectory(\"lib\/apps\")\n-                .create();\n+        final var layout = createLayout();\n@@ -103,8 +127,9 @@\n-    @Test\n-    public void testMove(@TempDir Path tempDir) throws IOException {\n-        test(true, tempDir);\n-    }\n-\n-    @Test\n-    public void testCopy(@TempDir Path tempDir) throws IOException {\n-        test(false, tempDir);\n+    public static ApplicationLayout createLayout() {\n+        return ApplicationLayout.build()\n+                .launchersDirectory(\"bin\")\n+                .appDirectory(\"lib\/app\")\n+                .runtimeDirectory(\"runtime\")\n+                .appModsDirectory(\"mods\")\n+                .contentDirectory(\"content\")\n+                .desktopIntegrationDirectory(\"lib\/apps\")\n+                .create();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -68,0 +68,8 @@\n+    @Test\n+    public void equals() {\n+        assertEquals(new PathGroup(Map.of()), new PathGroup(Map.of()));\n+        assertEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"rab\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"Foo\", Path.of(\"bar\"))));\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PathGroupTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,4 +43,6 @@\n-    static {\n-        if (System.getProperty(\"test.src\") == null) {\n-            \/\/ Was called by somebody else but not by jtreg\n-            System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+    public static class TestSrcInitializer {\n+        static {\n+            if (System.getProperty(\"test.src\") == null) {\n+                \/\/ Was called by somebody else but not by jtreg\n+                System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+            }\n@@ -87,0 +89,4 @@\n+    static {\n+        new TestSrcInitializer();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":10,"deletions":4,"binary":false,"changes":14,"previous_filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitAdapter.java","status":"renamed"},{"patch":"@@ -27,1 +27,2 @@\n- * @compile\/module=jdk.jpackage jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n","filename":"test\/jdk\/tools\/jpackage\/junit\/windows\/junit.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -426,1 +426,6 @@\n-        return \"\" + WB.isCDSIncluded();\n+        boolean noJvmtiAdded = allFlags()\n+                .filter(s -> s.startsWith(\"-agentpath\"))\n+                .findAny()\n+                .isEmpty();\n+\n+        return \"\" + (noJvmtiAdded && WB.isCDSIncluded());\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+\n+\n+tools\/javac\/SuperInit\/EarlyAssignments.java                                                        8369090 generic-all\n+tools\/javac\/SuperInit\/SuperInitFails.java                                                          8369090 generic-all\n+tools\/javac\/SuperInit\/SuperInitGood.javatools\/javac\/processing\/model\/element\/TestValueClasses.java 8369090 generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+        \/\/ used for themes\n+        removeAll(styleSheetNames, \"theme-dark\", \"theme-light\", \"theme-os\");\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkStylesheetClasses\/CheckStylesheetClasses.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                    <footer role=\"contentinfo\"> \"\"\",\n+                    <footer> \"\"\",\n@@ -116,1 +116,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -153,1 +153,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlLandmarkRegions\/TestHtmlLandmarkRegions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -112,1 +112,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -153,1 +153,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -174,1 +174,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -202,1 +202,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -223,1 +223,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -246,1 +246,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -282,1 +282,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -302,1 +302,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -340,1 +340,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -390,1 +390,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -431,1 +431,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -463,1 +463,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -490,1 +490,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -517,1 +517,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -555,1 +555,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -584,1 +584,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlVersion\/TestHtmlVersion.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8196027 8196202 8320458\n+ * @bug 8196027 8196202 8320458 8342705\n@@ -90,0 +90,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -101,0 +104,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -112,0 +118,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -123,0 +132,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -134,0 +146,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -145,0 +160,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -157,0 +175,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/..\/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/..\/resour\\\n+                    ce-files\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -169,0 +190,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/..\/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/..\/resour\\\n+                    ce-files\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestModuleNavigation.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *           8342705\n@@ -73,0 +74,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -84,0 +88,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -95,0 +102,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -106,0 +116,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -117,0 +130,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -342,0 +358,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -353,0 +372,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -364,0 +386,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -375,0 +400,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -414,0 +442,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -429,0 +460,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestNavigation.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -130,12 +133,0 @@\n-                    <\/div>\n-                    <\/div>\n-                    <div class=\"sub-nav\">\n-                    <div class=\"nav-content\">\n-                    <ol class=\"sub-nav-list\"><\/ol>\n-                    <div class=\"nav-list-search\"><input type=\"text\" id=\"search-input\" disabled place\\\n-                    holder=\"Search documentation (type \/)\" aria-label=\"Search in documentation\" auto\\\n-                    complete=\"off\" spellcheck=\"false\"><input type=\"reset\" id=\"reset-search\" disabled\\\n-                     value=\"Reset\"><\/div>\n-                    <\/div>\n-                    <\/div>\n-                    <!-- ========= END OF TOP NAVBAR ========= -->\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSpecTag\/TestSpecTag.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-                        background-color:var(--search-tag-highlight-color);\n+                        background-color:var(--search-tag-background-color);\n+                        color:var(--search-tag-text-color);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+            \"resource-files\/moon.svg\",\n@@ -214,0 +215,1 @@\n+            \"resource-files\/sun.svg\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -133,4 +133,5 @@\n-            log.warning(LintWarnings.DivZero);\n-            log.warning(tree.pos, LintWarnings.DivZero);\n-            log.warning(tree.pos(), LintWarnings.DivZero);\n-            log.warning(nil, LintWarnings.DivZero);\n+            \/\/ some warnings that will be emitted during parsing\n+            log.warning(Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos, Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos(), Warnings.ExtraneousSemicolon);\n+            log.warning(nil, Warnings.ExtraneousSemicolon);\n","filename":"test\/langtools\/tools\/javac\/6304921\/TestLog.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -733,1 +733,0 @@\n-                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n@@ -735,0 +734,1 @@\n+                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n@@ -3,0 +2,1 @@\n+T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n@@ -3,0 +2,1 @@\n+T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Line.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n@@ -4,0 +3,1 @@\n+DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Mixed.enabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n@@ -5,3 +8,0 @@\n-DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsEnum.enabled.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-    public DocCommentTester(boolean useBreakIterator, boolean useIdentityTtransformer) {\n+    public DocCommentTester(boolean useBreakIterator, boolean useIdentityTransformer) {\n@@ -133,1 +133,1 @@\n-        this.useIdentityTransformer = useIdentityTtransformer;\n+        this.useIdentityTransformer = useIdentityTransformer;\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8298405\n+ * @bug 8298405 8356411\n@@ -662,0 +662,24 @@\n+    \/\/\/ @see Ref label\n+    \/\/\/ @see <a href=\"..\">link<a>\n+    \/\/\/ @see \"Text\"\n+    void seeTags() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: empty\n+  body: empty\n+  block tags: 3\n+    See[SEE, pos:0\n+      reference: 2\n+        Reference[REFERENCE, pos:5, Ref]\n+        RawText[MARKDOWN, pos:9, label]\n+    ]\n+    See[SEE, pos:15\n+      reference: 1\n+        RawText[MARKDOWN, pos:20, <a_href=\"..\">link<a>]\n+    ]\n+    See[SEE, pos:41\n+      reference: 1\n+        Text[TEXT, pos:46, \"Text\"]\n+    ]\n+]\n+*\/\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTest.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8332858\n+ * @bug 8332858 8356411\n@@ -56,0 +56,1 @@\n+        t.testSeeTags();\n@@ -86,0 +87,13 @@\n+    private void testSeeTags() throws Exception {\n+        \/\/ @see \"Text\" does not produce a Markdown text\n+        runTest(\"\"\"\n+                \/\/\/ @see Ref label\n+                \/\/\/ @see <a href=\"..\">link<a>\n+                \/\/\/ @see \"Text\"\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"label\",\n+                \"<a href=\\\"..\\\">link<a>\");\n+    }\n+\n@@ -181,1 +195,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTransformerPositionTest.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -4,1 +3,0 @@\n-T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -6,0 +4,3 @@\n+T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n+T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n+T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -8,1 +9,0 @@\n-T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7188968\/T7188968.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n@@ -3,0 +2,1 @@\n+TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n","filename":"test\/langtools\/tools\/javac\/lambda\/TargetType22.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify lexical lint warnings handle nested declarations with SuppressWarnings correctly\n+ * @compile\/fail\/ref=LexicalLintNesting.out -XDrawDiagnostics -Xlint:text-blocks -Werror LexicalLintNesting.java\n+ *\/\n+\n+\/\/@SuppressWarnings(\"text-blocks\")\n+public class LexicalLintNesting {\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s1 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s2 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    public static class Nested1 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s3 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s4 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested1A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s5 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s6 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s7 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s8 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested1B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s9 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            \/* WARNING HERE *\/ String s10 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s11 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s12 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s13 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s14 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Nested2 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s15 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s16 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested2A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s17 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s18 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s19 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s20 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested2B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s21 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s22 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s23 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s24 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s25 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s26 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+LexicalLintNesting.java:12:36: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:30:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:55:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:68:45: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:80:41: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:92:37: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:162:37: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -1,1 +0,0 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n@@ -3,0 +2,1 @@\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n@@ -3,0 +2,1 @@\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -602,1 +602,0 @@\n-                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n@@ -604,0 +603,1 @@\n+                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,3 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (suppress == Suppress.YES) {\n+                                expected = Set.of();\n+                            } else if (lint == Lint.ENABLE_PREVIEW) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,1 +590,0 @@\n-                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -596,0 +595,1 @@\n+                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":95,"deletions":2,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n-T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n@@ -5,0 +3,2 @@\n+T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n+T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n","filename":"test\/langtools\/tools\/javac\/varargs\/7097436\/T7097436.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -5,1 +6,0 @@\n-T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/6594914\/T6594914a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n@@ -6,2 +10,0 @@\n-T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n-T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n@@ -9,1 +11,0 @@\n-T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n@@ -11,1 +12,0 @@\n-T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n","filename":"test\/langtools\/tools\/javac\/warnings\/7090499\/T7090499.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,0 @@\n-                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n@@ -121,0 +120,1 @@\n+                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n","filename":"test\/langtools\/tools\/javac\/warnings\/UnneededStrictfpWarningToolBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -6,0 +7,4 @@\n+T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n+T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -7,1 +12,1 @@\n-T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -13,2 +18,0 @@\n-T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -16,3 +19,0 @@\n-T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n-T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/suppress\/T6480588.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    private static final String FLAG_NAME = \"LargePageSizeInBytes\";\n+    private static final String FLAG_NAME = \"LargePageHeapSizeThreshold\";\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/SizeTTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,987 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+\/*\n+*\n+ * The jtreg tests might be executed with this agent to ensure that corresponding\n+ * JDK functionality is not broken.\n+ *\n+ * IMPORTANT\n+ * The tests that are incompatible with agent should be placed\n+ * into ProblemList-jvmti-stress-agent.txt with 000000 bug.\n+ *\n+ * Test supports 2 modes:\n+ *   - standard, where the agent doesn't require debugging capabilities\n+ *   - debug, where the agent additionally test debug-related functionality\n+ *   The debug mode is incompatible with debugger tests and debug jvmti tests.\n+ *   The standard mode should be compatible with all tests except problemlisted.\n+ *\n+ *   The JVMTI agent starts jvmti agent tread that enable\/disable different\n+ *   events and call different jvmti functions concurrently with test execution.\n+ *\n+ *   The main requirement is to don't change test behaviour.\n+ *\n+ *\/\n+\n+#define JVMTI_AGENT_NAME \"JvmtiStressAgent\"\n+\n+\/* Global settings and some statistics counters *\/\n+typedef struct {\n+\n+  \/* Verbose logging support *\/\n+  jboolean is_verbose;\n+\n+  \/* If debugging functionality could be used. Set from agent args.*\/\n+  jboolean is_debugger_enabled;\n+\n+  \/* Monitor and flags to synchronize agent completion.*\/\n+  jrawMonitorID finished_lock;\n+  volatile jboolean request_agent_thread_stop;\n+  volatile jboolean is_agent_finished;\n+\n+  \/* Some settings configured in gdata_init(). *\/\n+\n+  \/* If agent enabled or not. *\/\n+  jboolean is_tracing_enabled;\n+\n+  \/* If events testing is enabled. *\/\n+  jboolean are_events_enabled;\n+\n+  \/* If interponly and frequent events testing is enabled. *\/\n+  jboolean are_frequent_events_enabled;\n+\n+  \/* Should we iterate heap *\/\n+  jboolean is_heap_iterate_enabled;\n+\n+  \/* Is Heap sampling enabled *\/\n+  jboolean is_heap_sampling_enabled;\n+\n+  jint heap_sampling_interval;\n+  jint events_interval;\n+  jint frequent_events_interval;\n+\n+  \/* Excluded events *\/\n+  jint* events_excluded;\n+  jsize events_excluded_size;\n+\n+  \/* Event statistics *\/\n+\n+  \/* The counters are racy intentionally to avoid synchronization. *\/\n+  jlong cbBreakpoint;\n+  jlong cbClassFileLoadHook;\n+  jlong cbClassLoad;\n+  jlong cbClassPrepare;\n+  jlong cbCompiledMethodLoad;\n+  jlong cbCompiledMethodUnload;\n+  jlong cbDataDumpRequest;\n+  jlong cbDynamicCodeGenerated;\n+  jlong cbException;\n+  jlong cbExceptionCatch;\n+  jlong cbFieldAccess;\n+  jlong cbFieldModification;\n+  jlong cbFramePop;\n+  jlong cbGarbageCollectionFinish;\n+  jlong cbGarbageCollectionStart;\n+  jlong cbMethodEntry;\n+  jlong cbMethodExit;\n+  jlong cbMonitorContendedEnter;\n+  jlong cbMonitorContendedEntered;\n+  jlong cbMonitorWait;\n+  jlong cbMonitorWaited;\n+  jlong cbNativeMethodBind;\n+  jlong cbObjectFree;\n+  jlong cbResourceExhausted;\n+  jlong cbSampledObjectAlloc;\n+  jlong cbSingleStep;\n+  jlong cbThreadEnd;\n+  jlong cbThreadStart;\n+  jlong cbVirtualThreadEnd;\n+  jlong cbVirtualThreadStart;\n+  jlong cbVMDeath;\n+  jlong cbVMInit;\n+  jlong cbVMObjectAlloc;\n+\n+  \/* Inspector statistics are intentionally racy. *\/\n+  jlong inspectedMethods;\n+  jlong inspectedVariables;\n+\n+  \/* File for debug output, agent shouldn't write into stdout. *\/\n+  FILE* log_file;\n+} GlobalData;\n+\n+GlobalData *gdata;\n+\n+static GlobalData*\n+gdata_init(jboolean is_debugger_enabled, jboolean is_verbose) {\n+  static GlobalData data;\n+  (void) memset(&data, 0, sizeof (GlobalData));\n+\n+  data.is_debugger_enabled = is_debugger_enabled;\n+  data.is_verbose = is_verbose;\n+\n+  data.request_agent_thread_stop = JNI_FALSE;\n+  data.is_agent_finished = JNI_FALSE;\n+\n+  \/* Set jvmti stress properties *\/\n+  data.heap_sampling_interval = 1000;\n+  data.frequent_events_interval = 10;\n+\n+  data.is_tracing_enabled = JNI_TRUE;\n+  data.are_events_enabled = JNI_TRUE;\n+  data.are_frequent_events_enabled = JNI_TRUE;\n+  \/\/ disabled so far\n+  data.is_heap_iterate_enabled = JNI_FALSE;\n+  data.is_heap_sampling_enabled = JNI_FALSE;\n+\n+\n+  if (data.is_debugger_enabled) {\n+    data.events_excluded_size = 0;\n+    data.events_excluded = nullptr;\n+  } else {\n+    data.events_excluded_size = 4;\n+    data.events_excluded = new jint[4] {\n+      JVMTI_EVENT_BREAKPOINT,\n+      JVMTI_EVENT_FIELD_ACCESS,\n+      JVMTI_EVENT_FIELD_MODIFICATION,\n+      JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,\n+    };\n+  }\n+  if (data.is_verbose) {\n+    data.log_file = fopen(\"JvmtiStressAgent.out\", \"w\");\n+  }\n+\n+  return &data;\n+}\n+\n+void\n+gdata_close() {\n+  free(gdata->events_excluded);\n+  if (gdata->is_verbose) {\n+    fclose(gdata->log_file);\n+  }\n+}\n+\n+\/\/ Internal buffer length for all messages\n+#define MESSAGE_LIMIT 16384\n+\n+void\n+debug(const char* format, ...) {\n+  if (!gdata->is_verbose) {\n+    return;\n+  }\n+  char dest[MESSAGE_LIMIT];\n+  va_list argptr;\n+  va_start(argptr, format);\n+  vsnprintf(dest, MESSAGE_LIMIT, format, argptr);\n+  va_end(argptr);\n+  \/\/ Enable if needed, tests might fail with unexpected output\n+  \/\/printf(\"%s\\n\", dest);\n+  fprintf(gdata->log_file, \"%s\\n\", dest);\n+  fflush(gdata->log_file);\n+}\n+\n+\/* Some helper functions to start\/stop jvmti stress agent thread. *\/\n+void\n+check_jni_exception(JNIEnv *jni, const char *message) {\n+  jobject exception = jni->ExceptionOccurred();\n+  if (exception != nullptr) {\n+    jni->ExceptionDescribe();\n+    fatal(jni, message);\n+  }\n+}\n+\n+jclass\n+find_class(JNIEnv *jni, const char *name) {\n+  char message[MESSAGE_LIMIT];\n+  jclass clazz = jni->FindClass(name);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find class %s.\", name);\n+  check_jni_exception(jni, message);\n+  return clazz;\n+}\n+\n+jmethodID\n+get_method_id(JNIEnv *jni, jclass clazz, const char *name, const char *sig) {\n+  char message[MESSAGE_LIMIT];\n+  jmethodID method = jni->GetMethodID(clazz, name, sig);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find method %s.\", name);\n+  check_jni_exception(jni, message);\n+  return method;\n+}\n+\n+void\n+create_agent_thread(jvmtiEnv *jvmti, JNIEnv *jni, const char *name, jvmtiStartFunction func) {\n+\n+  check_jni_exception(jni, \"JNIException before creating Agent Thread.\");\n+  jclass clazz = find_class(jni, \"java\/lang\/Thread\");\n+  jmethodID thread_ctor = get_method_id(jni, clazz, \"<init>\",\n+                                    \"(Ljava\/lang\/String;)V\");\n+\n+  jstring name_utf = jni->NewStringUTF(name);\n+  check_jni_exception(jni, \"Error creating utf name of thread.\");\n+\n+  jthread thread = jni->NewObject(clazz, thread_ctor, name_utf);\n+  check_jni_exception(jni, \"Error during instantiation of Thread object.\");\n+  jvmtiError err = jvmti->RunAgentThread(\n+                     thread, func, nullptr, JVMTI_THREAD_NORM_PRIORITY);\n+  check_jvmti_status(jni, err, \"RunAgentThread\");\n+}\n+\n+\/*\n+ * The method blocks execution until agent thread finishes.\n+ * Should be executed during VMDeath to don't run JVMTI functionality\n+ * during dead phase.\n+ *\/\n+void\n+request_agent_thread_stop_and_wait(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  gdata->request_agent_thread_stop = JNI_TRUE;\n+  while (!gdata->is_agent_finished) {\n+    rml.wait(1000);\n+  }\n+  debug(\"Native agent stopped\");\n+}\n+\n+\/*\n+ * The method is called by agent thread to ensure that thread correctly exits.\n+ *\/\n+static jboolean\n+should_stop(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  jboolean should_stop = JNI_FALSE;\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  should_stop = gdata->request_agent_thread_stop;\n+  if (should_stop == JNI_TRUE) {\n+    gdata->is_agent_finished = JNI_TRUE;\n+    rml.notify_all();\n+  }\n+  return should_stop;\n+}\n+\n+\/*\n+ * Agent stress functions. The agent is stopped in VMDeath only and should be\n+ * always ready to get JVMTI_ERROR_THREAD_NOT_ALIVE error.\n+ *\/\n+\n+\/* Read stack, frames, method, variables, etc. *\/\n+static void\n+walk_stack(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"In walk_stack: %p\", thread);\n+\n+  jvmtiFrameInfo frames[5];\n+  jint count = 0;\n+  err = jvmti->GetStackTrace(thread, 0, 5, frames, &count);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE || err == JVMTI_ERROR_WRONG_PHASE) {\n+    return;\n+  }\n+  check_jvmti_error(err, \"GetStackTrace\");\n+\n+  debug(\"Stack depth: %d\", count);\n+\n+  for (int frame_index = 0; frame_index < count; frame_index++) {\n+    char *method_name = nullptr;\n+    jint method_modifiers = 0;\n+    err = jvmti->GetMethodName(frames[frame_index].method, &method_name, nullptr, nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodName\");\n+\n+    err = jvmti->GetMethodModifiers(frames[frame_index].method, &method_modifiers);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodModifiers\");\n+\n+    debug(\"Inspecting method: %s, %d\", method_name, method_modifiers);\n+    deallocate(jvmti, jni, method_name);\n+\n+    jvmtiLocalVariableEntry* table = nullptr;\n+    jint entry_count = 0;\n+    err = jvmti->GetLocalVariableTable(frames[frame_index].method, &entry_count, &table);\n+    if (err == JVMTI_ERROR_NATIVE_METHOD || err == JVMTI_ERROR_ABSENT_INFORMATION\n+            || err == JVMTI_ERROR_WRONG_PHASE) {\n+      continue;\n+    }\n+    check_jvmti_status(jni, err, \"GetLocalVariableTable\");\n+\n+    gdata->inspectedMethods += 1;\n+    gdata->inspectedVariables += entry_count;\n+\n+    debug(\"Variables: \");\n+    for (int cnt = 0; cnt < entry_count; cnt++) {\n+      debug(\" %s  %d\", table[cnt].name, table[cnt].slot);\n+      deallocate(jvmti, jni, table[cnt].name);\n+      deallocate(jvmti, jni, table[cnt].signature);\n+      deallocate(jvmti, jni, table[cnt].generic_signature);\n+    }\n+    deallocate(jvmti, jni, table);\n+  }\n+  debug(\"---- End of stack inspection %d -----\", count);\n+}\n+\n+\/* Iterate with walk_stack through all thread. *\/\n+static void JNICALL\n+walk_all_threads_stacks(jvmtiEnv *jvmti, JNIEnv *jni) {\n+    jint threads_count = 0;\n+    jthread *threads = nullptr;\n+    jvmtiError err = JVMTI_ERROR_NONE;\n+    debug(\"Inspect:  Starting cycle...\");\n+    err = jvmti->GetAllThreads(&threads_count, &threads);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetAllThreads\");\n+    for (int t = 0; t < (int)threads_count; t++) {\n+      jvmtiThreadInfo info;\n+      debug(\"Inspecting thread num %d at addr [%p]\",t, threads[t]);\n+      err = jvmti->GetThreadInfo(threads[t], &info);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"GetThreadInfo\");\n+      \/\/ Skip agent thread itself and JFR threads to avoid potential deadlocks\n+      if (strstr(info.name, JVMTI_AGENT_NAME) == nullptr\n+          && strstr(info.name, \"JFR\") == nullptr) {\n+        \/\/ The non-intrusive actions are allowed to ensure that results of target\n+        \/\/ thread are not affected.\n+        jthread thread = threads[t];\n+        walk_stack(jvmti, jni, thread);\n+\n+        \/\/ Suspend\/resume are solo capabilities and are treated like debugging\n+        if (gdata->is_debugger_enabled) {\n+          debug(\"Inspect: Trying to suspend thread %s\", info.name);\n+          err = jvmti->SuspendThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+            debug(\"Inspect:  thread %s is not alive. Skipping.\", info.name);\n+            continue;\n+          }\n+          check_jvmti_status(jni, err, \"SuspendThread\");\n+          debug(\"Inspect:  Suspended thread %s\", info.name);\n+\n+          walk_stack(jvmti, jni, thread);\n+\n+          debug(\"Inspect: Trying to resume thread %s\", info.name);\n+          err = jvmti->ResumeThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          check_jvmti_status(jni, err, \"ResumeThread\");\n+          debug(\"Inspect:  Resumed thread %s\", info.name);\n+        }\n+\n+      }\n+      deallocate(jvmti, jni, info.name);\n+      jni->DeleteLocalRef(info.thread_group);\n+      jni->DeleteLocalRef(info.context_class_loader);\n+      jni->DeleteLocalRef(threads[t]);\n+    }\n+    deallocate(jvmti, jni, threads);\n+}\n+\n+\/* Heap inspection helpers. *\/\n+static jint JNICALL\n+heap_iteration_callback(jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data) {\n+  int* count = (int*) user_data;\n+  *count += 1;\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+static jint\n+get_heap_info(jvmtiEnv *jvmti, JNIEnv *jni, jclass klass) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  int count = 0;\n+  jvmtiHeapCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.heap_iteration_callback = &heap_iteration_callback;\n+  err = jvmti->IterateThroughHeap(0, klass, &callbacks, &count);\n+  if (err == JVMTI_ERROR_WRONG_PHASE) {\n+    return count;\n+  }\n+  check_jvmti_status(jni, err, \"IterateThroughHeap\");\n+  return count;\n+}\n+\n+\n+\/*\n+ * Events testing helper functions.\n+ *\/\n+\n+\n+int\n+is_event_frequent(int event) {\n+  \/\/ Should include all interpreter-only events and all frequent events.\n+  return event == JVMTI_EVENT_SINGLE_STEP\n+      || event == JVMTI_EVENT_METHOD_ENTRY\n+      || event == JVMTI_EVENT_METHOD_EXIT\n+      || event == JVMTI_EVENT_FRAME_POP\n+      || event == JVMTI_EVENT_FIELD_ACCESS\n+      || event == JVMTI_EVENT_FIELD_MODIFICATION\n+      || event == JVMTI_EVENT_EXCEPTION_CATCH\n+      || event == JVMTI_EVENT_EXCEPTION\n+  ;\n+}\n+\n+int\n+is_event_excluded(int event) {\n+  for (int i = 0; i < gdata->events_excluded_size; i++) {\n+    if (event == gdata->events_excluded[i]) {\n+      return JNI_TRUE;\n+    }\n+  }\n+  return JNI_FALSE;\n+}\n+\n+static void\n+enable_events(jvmtiEnv *jvmti, jboolean update_frequent_events) {\n+ debug(\"Enabling events\\n\");\n+  for(int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    if (is_event_excluded(event)) {\n+      debug(\"Event %d excluded.\", event);\n+      continue;\n+    }\n+    if (is_event_frequent(event) != update_frequent_events ) {\n+      debug(\"Event %d is not enabled as frequent\/slow.\", event);\n+      continue;\n+    }\n+    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+        static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+  debug(\"Enabling events done\\n\");\n+}\n+\n+static void\n+enable_frequent_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti, JNI_TRUE);\n+}\n+\n+static void\n+enable_common_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti,JNI_FALSE);\n+}\n+\n+\n+static void\n+disable_all_events(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  for (int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    \/\/ VM_DEATH is used to stop agent\n+    if (event == JVMTI_EVENT_VM_DEATH) {\n+      continue;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+}\n+\n+\/*\n+ * The JVMTI agent main loop.\n+ *\/\n+\n+static void JNICALL\n+stress_agent(jvmtiEnv *jvmti, JNIEnv *jni, void *p) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"Debugger: Thread started.\");\n+  while (!should_stop(jvmti, jni)) {\n+\n+    if (gdata->are_events_enabled) {\n+      enable_common_events(jvmti);\n+    }\n+\n+    \/\/ Iterate through heap and get some statistics\n+    if (gdata->is_heap_iterate_enabled) {\n+      jclass kls = find_class(jni, \"java\/lang\/String\");\n+      jlong obj_count = get_heap_info(jvmti, jni, kls);\n+      debug(\"Debugger: Heap info: %d\", obj_count);\n+    }\n+\n+\n+    \/\/ requires can_generate_sampled_object_alloc_events\n+    \/\/ which is solo capability\n+    if (gdata->is_heap_sampling_enabled) {\n+      err = jvmti->SetHeapSamplingInterval(gdata->heap_sampling_interval);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->is_tracing_enabled) {\n+      walk_all_threads_stacks(jvmti, jni);\n+    }\n+\n+    sleep_ms(gdata->events_interval);\n+\n+    err = jvmti->SetHeapSamplingInterval(0);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    if (gdata->is_heap_sampling_enabled) {\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->are_frequent_events_enabled) {\n+      enable_frequent_events(jvmti);\n+      sleep_ms(gdata->frequent_events_interval);\n+    }\n+    disable_all_events(jvmti);\n+    sleep_ms(gdata->events_interval);\n+  }\n+  debug(\"Debugger: Thread finished.\");\n+}\n+\n+\n+\/*\n+ *  Events section.\n+ *  Most of the events just increase counter and print debug info.\n+ *  The VMInit\/VMDeath are also start and stop jvmti stress agent.\n+ *\/\n+\n+static void\n+register_event(jlong *event) {\n+  (*event)++;\n+}\n+\n+static void JNICALL\n+cbVMInit(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbVMInit);\n+  debug(\"Event cbVMInit\\n\");\n+  create_agent_thread(jvmti, jni, JVMTI_AGENT_NAME, &stress_agent);\n+}\n+\n+static void JNICALL\n+cbVMDeath(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  register_event(&gdata->cbVMDeath);\n+  debug(\"Event cbVMDeath\\n\");\n+  request_agent_thread_stop_and_wait(jvmti, jni);\n+  destroy_raw_monitor(jvmti, jni, gdata->finished_lock);\n+}\n+\n+static void JNICALL\n+cbThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbClassFileLoadHook(jvmtiEnv *jvmti, JNIEnv* jni,\n+                    jclass class_being_redefined, jobject loader,\n+                    const char* name, jobject protection_domain,\n+                    jint class_data_len, const unsigned char *class_data,\n+                    jint *new_class_data_len, unsigned char **new_class_data) {\n+  \/* TODO uncomment for more stress\n+  unsigned char* new_class_data_copy = (unsigned char*) malloc(class_data_len);\n+  memcpy(new_class_data_copy, class_data, class_data_len);\n+  *new_class_data_len = class_data_len;\n+  *new_class_data = new_class_data_copy;\n+  *\/\n+  register_event(&gdata->cbClassFileLoadHook);\n+  debug(\"Event cbClassFileLoadHook\\n\");\n+}\n+\n+static void JNICALL\n+cbClassLoad(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassLoad);\n+  debug(\"Event cbClassLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbClassPrepare(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassPrepare);\n+  debug(\"Event cbClassPrepare\\n\");\n+}\n+\n+static void JNICALL\n+cbDataDumpRequest(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbDataDumpRequest);\n+  debug(\"Event cbDataDumpRequest\\n\");\n+}\n+\n+static void JNICALL\n+cbException(jvmtiEnv *jvmti,\n+            JNIEnv *jni,\n+            jthread thread,\n+            jmethodID method,\n+            jlocation location,\n+            jobject exception,\n+            jmethodID catch_method,\n+            jlocation catch_location) {\n+  register_event(&gdata->cbException);\n+  debug(\"Event cbException\\n\");\n+}\n+\n+static void JNICALL\n+cbExceptionCatch(jvmtiEnv *jvmti, JNIEnv *jni,\n+                 jthread thread, jmethodID method, jlocation location,\n+                 jobject exception) {\n+  register_event(&gdata->cbExceptionCatch);\n+  debug(\"Event cbExceptionCatch\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWait(jvmtiEnv *jvmti, JNIEnv *jni,\n+              jthread thread, jobject object, jlong timeout) {\n+  register_event(&gdata->cbMonitorWait);\n+  debug(\"Event cbMonitorWait\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWaited(jvmtiEnv *jvmti, JNIEnv *jni,\n+                jthread thread, jobject object, jboolean timed_out) {\n+  register_event(&gdata->cbMonitorWaited);\n+  debug(\"Event cbMonitorWaited\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni,\n+                        jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEnter);\n+  debug(\"Event cbMonitorContendedEnter\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv* jni,\n+                          jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEntered);\n+  debug(\"Event cbMonitorContendedEntered\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionStart(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionStart);\n+  debug(\"Event cbGarbageCollectionStart\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionFinish(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionFinish);\n+  debug(\"Event cbGarbageCollectionFinish\\n\");\n+}\n+\n+static void JNICALL\n+cbObjectFree(jvmtiEnv *jvmti, jlong tag) {\n+  register_event(&gdata->cbObjectFree);\n+  debug(\"Event cbObjectFree\\n\");\n+}\n+\n+static void JNICALL\n+cbBreakpoint(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbBreakpoint);\n+  debug(\"Event cbBreakpoint\\n\");\n+}\n+\n+static void JNICALL\n+cbSingleStep(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbSingleStep);\n+  debug(\"Event cbSingleStep\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method,\n+              jlocation location,\n+              jclass field_klass,\n+              jobject object,\n+              jfieldID field) {\n+  register_event(&gdata->cbFieldAccess);\n+  debug(\"Event cbFieldAccess\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jthread thread,\n+                    jmethodID method,\n+                    jlocation location,\n+                    jclass field_klass,\n+                    jobject object,\n+                    jfieldID field,\n+                    char signature_type,\n+                    jvalue new_value) {\n+  register_event(&gdata->cbFieldModification);\n+  debug(\"Event cbFieldModification\\n\");\n+}\n+\n+static void JNICALL\n+cbFramePop(jvmtiEnv *jvmti,\n+           JNIEnv *jni,\n+           jthread thread,\n+           jmethodID method,\n+           jboolean was_popped_by_exception) {\n+  register_event(&gdata->cbFramePop);\n+  debug(\"Event cbFramePop\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodEntry(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method) {\n+  register_event(&gdata->cbMethodEntry);\n+  debug(\"Event cbMethodEntry\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodExit(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jboolean was_popped_by_exception,\n+             jvalue return_value) {\n+  register_event(&gdata->cbMethodExit);\n+  debug(\"Event cbMethodExit\\n\");\n+}\n+\n+static void JNICALL\n+cbNativeMethodBind(jvmtiEnv *jvmti,\n+                   JNIEnv *jni,\n+                   jthread thread,\n+                   jmethodID method,\n+                   void* address,\n+                   void** new_address_ptr) {\n+  register_event(&gdata->cbNativeMethodBind);\n+  debug(\"Event cbNativeMethodBind\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodLoad(jvmtiEnv *jvmti,\n+                     jmethodID method,\n+                     jint code_size,\n+                     const void* code_addr,\n+                     jint map_length,\n+                     const jvmtiAddrLocationMap* map,\n+                     const void* compile_info) {\n+  register_event(&gdata->cbCompiledMethodLoad);\n+  debug(\"Event cbCompiledMethodLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodUnload(jvmtiEnv *jvmti,\n+                       jmethodID method,\n+                       const void* code_addr) {\n+  register_event(&gdata->cbCompiledMethodUnload);\n+  debug(\"Event cbCompiledMethodUnload\\n\");\n+}\n+\n+static void JNICALL\n+cbDynamicCodeGenerated(jvmtiEnv *jvmti,\n+                       const char* name,\n+                       const void* address,\n+                       jint length) {\n+  register_event(&gdata->cbDynamicCodeGenerated);\n+  debug(\"Event cbDynamicCodeGenerated\\n\");\n+}\n+\n+static void JNICALL\n+cbResourceExhausted(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jint flags,\n+                    const void* reserved,\n+                    const char* description) {\n+  register_event(&gdata->cbResourceExhausted);\n+  debug(\"Event cbResourceExhausted\\n\");\n+}\n+\n+static void JNICALL\n+cbVMObjectAlloc(jvmtiEnv *jvmti,\n+                JNIEnv *jni,\n+                jthread thread,\n+                jobject object,\n+                jclass object_klass,\n+                jlong size) {\n+  register_event(&gdata->cbVMObjectAlloc);\n+  debug(\"Event cbVMObjectAlloc\\n\");\n+}\n+\n+static void JNICALL\n+cbSampledObjectAlloc(jvmtiEnv *jvmti,\n+                     JNIEnv *jni,\n+                     jthread thread,\n+                     jobject object,\n+                     jclass object_klass,\n+                     jlong size) {\n+  register_event(&gdata->cbSampledObjectAlloc);\n+  debug(\"Event cbSampledObjectAlloc\\n\");\n+}\n+\n+\n+\n+static void\n+set_callbacks(jvmtiEnv *jvmti, jboolean on) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiEventCallbacks callbacks;\n+\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  if (on == JNI_FALSE) {\n+    err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+    check_jvmti_error(err, \"SetEventCallbacks\");\n+    return;\n+  }\n+  callbacks.Breakpoint = &cbBreakpoint;\n+  callbacks.ClassFileLoadHook = &cbClassFileLoadHook;\n+  callbacks.ClassLoad = &cbClassLoad;\n+  callbacks.ClassPrepare = &cbClassPrepare;\n+  callbacks.CompiledMethodLoad = &cbCompiledMethodLoad;\n+  callbacks.CompiledMethodUnload = &cbCompiledMethodUnload;\n+  callbacks.DataDumpRequest = &cbDataDumpRequest;\n+  callbacks.DynamicCodeGenerated = &cbDynamicCodeGenerated;\n+  callbacks.Exception = &cbException;\n+  callbacks.ExceptionCatch = &cbExceptionCatch;\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  callbacks.FramePop = &cbFramePop;\n+  callbacks.GarbageCollectionFinish = &cbGarbageCollectionFinish;\n+  callbacks.GarbageCollectionStart = &cbGarbageCollectionStart;\n+  callbacks.MethodEntry = &cbMethodEntry;\n+  callbacks.MethodExit = &cbMethodExit;\n+  callbacks.MonitorContendedEnter = &cbMonitorContendedEnter;\n+  callbacks.MonitorContendedEntered = &cbMonitorContendedEntered;\n+  callbacks.MonitorWait = &cbMonitorWait;\n+  callbacks.MonitorWaited = &cbMonitorWaited;\n+  callbacks.NativeMethodBind = &cbNativeMethodBind;\n+  callbacks.ObjectFree = &cbObjectFree;\n+  callbacks.ResourceExhausted = &cbResourceExhausted;\n+  callbacks.SampledObjectAlloc = &cbSampledObjectAlloc;\n+  callbacks.SingleStep = &cbSingleStep;\n+  callbacks.ThreadEnd = &cbThreadEnd;\n+  callbacks.ThreadStart = &cbThreadStart;\n+  callbacks.VirtualThreadEnd = &cbVirtualThreadEnd;\n+  callbacks.VirtualThreadStart = &cbVirtualThreadStart;\n+  callbacks.VMDeath = &cbVMDeath;\n+  callbacks.VMInit = &cbVMInit;\n+  callbacks.VMObjectAlloc = &cbVMObjectAlloc;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+}\n+\n+static\n+void get_capabilities(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  err = jvmti->GetPotentialCapabilities(&capabilities);\n+\n+  if (!gdata->is_debugger_enabled) {\n+    \/\/init_always_solo_capabilities\n+    capabilities.can_suspend = false;\n+\n+    \/\/ onload_solo\n+    capabilities.can_generate_breakpoint_events = false;\n+    capabilities.can_generate_field_access_events = false;\n+    capabilities.can_generate_field_modification_events = false;\n+  }\n+\n+  capabilities.can_generate_early_vmstart = false;\n+\n+  check_jvmti_error(err, \"GetPotentialCapabilities\");\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  jboolean is_debugger_enabled = JNI_TRUE;\n+  jboolean is_verbose = JNI_FALSE;\n+\n+  if (options != nullptr) {\n+    char *opts = strdup(options);\n+    char *token = strtok(opts, \",\");\n+\n+    while (token != nullptr) {\n+      if (strncmp(token, \"debugger=\", 9) == 0) {\n+        if (strcmp(token + 9, \"true\") == 0) {\n+          is_debugger_enabled = JNI_TRUE;\n+        } else {\n+          is_debugger_enabled = JNI_FALSE;\n+        }\n+      }\n+      if (strncmp(token, \"verbose\", 7) == 0) {\n+        is_verbose = JNI_TRUE;\n+      }\n+      token = strtok(nullptr, \",\");\n+    }\n+    free(opts);\n+  }\n+  gdata = gdata_init(is_debugger_enabled, is_verbose);\n+  get_capabilities(jvmti);\n+  gdata->finished_lock = create_raw_monitor(jvmti, \"Finished lock\");\n+  set_callbacks(jvmti, JNI_TRUE);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+    JVMTI_EVENT_VM_INIT, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM *vm) {\n+  if (!gdata->request_agent_thread_stop) {\n+    printf(\"Agent_OnUnload happened before requested stop.\\n\");\n+  }\n+  gdata_close();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp","additions":987,"deletions":0,"binary":false,"changes":987,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-    private static final String OPENSSL_BUNDLE_VERSION = \"3.0.14\";\n+    private static final String OPENSSL_BUNDLE_VERSION = \"3.5.1\";\n","filename":"test\/lib\/jdk\/test\/lib\/security\/OpensslArtifactFetcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}