{"files":[{"patch":"@@ -179,0 +179,16 @@\n+\n+# These settings are needed to run testing with jvmti agent\n+ifeq ($(OPENJDK_BUILD_OS), linux)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .so\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), windows)\n+  LIBRARY_PREFIX :=\n+  SHARED_LIBRARY_SUFFIX := .dll\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), macosx)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .dylib\n+endif\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3348,1 +3348,3 @@\n-  __ membar(__ AnyAny);\n+  if(!UseLSE) {\n+    __ membar(__ AnyAny);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,3 +110,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -202,0 +205,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6768,4 +6768,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -231,5 +231,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(*stub->entry());\n-    } else {\n-      __ unlock_object(R5, R6, R4, *stub->entry());\n-    }\n+    __ unlock_object(R5, R6, R4, *stub->entry());\n@@ -2621,19 +2617,6 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      \/\/ Add debug info for NullPointerException only if one is possible.\n-      if (op->info() != nullptr) {\n-        if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n-          explicit_null_check(obj, op->info());\n-        } else {\n-          add_debug_info_for_null_check_here(op->info());\n-        }\n-      }\n-      __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow locking\n-      \/\/ note: The slow locking code could be inlined here, however if we use\n-      \/\/       slow locking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow locking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      if (op->info() != nullptr) {\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    \/\/ Add debug info for NullPointerException only if one is possible.\n+    if (op->info() != nullptr) {\n+      if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n+        explicit_null_check(obj, op->info());\n+      } else {\n@@ -2641,2 +2624,1 @@\n-        __ null_check(obj);\n-      __ b(*op->stub()->entry());\n+    __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n@@ -2647,12 +2629,2 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow unlocking\n-      \/\/ note: The slow unlocking code could be inlined here, however if we use\n-      \/\/       slow unlocking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow unlocking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      __ b(*op->stub()->entry());\n-    }\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":38,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -949,39 +949,2 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-  } else {\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-    \/\/   \/\/ We stored the monitor address into the object's mark word.\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-    \/\/ }\n-\n-    const Register header           = R7_ARG5;\n-    const Register object_mark_addr = R8_ARG6;\n-    const Register current_header   = R9_ARG7;\n-    const Register tmp              = R10_ARG8;\n-\n-    Label count_locking, done, slow_case, cas_failed;\n-\n-    assert_different_registers(header, object_mark_addr, current_header, tmp);\n-\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(monitor, object, header, tmp, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, object);\n-        lbz(tmp, in_bytes(Klass::misc_flags_offset()), tmp);\n-        testbitdi(CR0, R0, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-        bne(CR0, slow_case);\n-      }\n+  const Register header           = R7_ARG5;\n+  const Register tmp              = R8_ARG6;\n@@ -989,56 +952,1 @@\n-      \/\/ Load markWord from object into header.\n-      ld(header, oopDesc::mark_offset_in_bytes(), object);\n-\n-      \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-      ori(header, header, markWord::unlocked_value);\n-\n-      \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-      const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-      const int mark_offset = lock_offset +\n-                              BasicLock::displaced_header_offset_in_bytes();\n-\n-      \/\/ Initialize the box (Must happen before we update the object mark!).\n-      std(header, mark_offset, monitor);\n-\n-      \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-      \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, displaced).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/header, \/*exchange_value=*\/monitor,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-               MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-               noreg,\n-               &cas_failed,\n-               \/*check without membar and ldarx first*\/true);\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object and we have now locked it.\n-      b(count_locking);\n-      bind(cas_failed);\n-\n-      \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-      \/\/   \/\/ Simple recursive case.\n-      \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if owner is self by comparing the value in the markWord of object\n-      \/\/ (current_header) with the stack pointer.\n-      sub(current_header, current_header, R1_SP);\n-\n-      assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-      load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n-\n-      and_(R0\/*==0?*\/, current_header, tmp);\n-      \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-      \/\/ header indicating it is a recursive lock.\n-      bne(CR0, slow_case);\n-      std(R0\/*==0!*\/, mark_offset, monitor);\n-      b(count_locking);\n-    }\n+  Label done, slow_case;\n@@ -1046,18 +954,9 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-\n-    \/\/ None of the above fast optimizations worked so we have to get into the\n-    \/\/ slow case of monitor enter.\n-    bind(slow_case);\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    \/\/ }\n-\n-    if (LockingMode == LM_LEGACY) {\n-      b(done);\n-      align(32, 12);\n-      bind(count_locking);\n-      inc_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  assert_different_registers(header, tmp);\n+\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n+  b(done);\n+\n+  bind(slow_case);\n+  call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+\n+  bind(done);\n@@ -1074,3 +973,3 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-  } else {\n+  const Register object           = R7_ARG5;\n+  const Register header           = R8_ARG6;\n+  const Register current_header   = R10_ARG8;\n@@ -1078,36 +977,2 @@\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n-    \/\/ }\n-\n-    const Register object           = R7_ARG5;\n-    const Register header           = R8_ARG6;\n-    const Register object_mark_addr = R9_ARG7;\n-    const Register current_header   = R10_ARG8;\n-\n-    Label free_slot;\n-    Label slow_case;\n-\n-    assert_different_registers(object, header, object_mark_addr, current_header);\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Test first if we are in the fast recursive case.\n-      ld(header, in_bytes(BasicObjectLock::lock_offset()) +\n-                 BasicLock::displaced_header_offset_in_bytes(), monitor);\n-\n-      \/\/ If the displaced header is zero, we have a recursive unlock.\n-      cmpdi(CR0, header, 0);\n-      beq(CR0, free_slot); \/\/ recursive unlock\n-    }\n-\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n+  Label free_slot;\n+  Label slow_case;\n@@ -1115,1 +980,1 @@\n-    \/\/ If we still have a lightweight lock, unlock the object and be done.\n+  assert_different_registers(object, header, current_header);\n@@ -1117,2 +982,2 @@\n-    \/\/ The object address from the monitor is in object.\n-    ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  \/\/ The object address from the monitor is in object.\n+  ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n@@ -1120,19 +985,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(object, header, slow_case);\n-    } else {\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ We have the displaced header in displaced_header. If the lock is still\n-      \/\/ lightweight, it will contain the monitor address and we'll store the\n-      \/\/ displaced header back into the object's mark word.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, monitor).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel,\n-               MacroAssembler::cmpxchgx_hint_release_lock(),\n-               noreg,\n-               &slow_case);\n-    }\n-    b(free_slot);\n+  lightweight_unlock(object, header, slow_case);\n@@ -1140,3 +987,1 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n+  b(free_slot);\n@@ -1144,5 +989,2 @@\n-    \/\/ The lock has been converted into a heavy lock and hence\n-    \/\/ we need to get into the slow case.\n-    bind(slow_case);\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    \/\/ }\n+  bind(slow_case);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n@@ -1150,2 +992,2 @@\n-    Label done;\n-    b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n+  Label done;\n+  b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n@@ -1153,10 +995,6 @@\n-    \/\/ Exchange worked, do monitor->set_obj(nullptr);\n-    align(32, 12);\n-    bind(free_slot);\n-    li(R0, 0);\n-    std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n-    if (LockingMode == LM_LEGACY) {\n-      dec_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  \/\/ Do monitor->set_obj(nullptr);\n+  align(32, 12);\n+  bind(free_slot);\n+  li(R0, 0);\n+  std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  bind(done);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":32,"deletions":194,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -232,5 +232,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ branch_optimized(Assembler::bcondAlways, *stub->entry());\n-    } else {\n-      __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n-    }\n+    __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n@@ -2717,7 +2713,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ branch_optimized(Assembler::bcondAlways, *op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1011,24 +1011,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    return;\n-  }\n-\n-  \/\/ template code: (for LM_LEGACY)\n-  \/\/\n-  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-  \/\/   \/\/ We stored the monitor address into the object's mark word.\n-  \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-  \/\/   \/\/ Simple recursive case.\n-  \/\/   monitor->lock()->set_displaced_header(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  const Register object_mark_addr = Z_ARG4;\n-  const Register current_header   = Z_ARG5;\n@@ -1040,61 +1016,1 @@\n-  \/\/ markWord header = obj->mark().set_unlocked();\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(monitor, object, header, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, object);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      z_btrue(slow_case);\n-    }\n-\n-    \/\/ Load markWord from object into header.\n-    z_lg(header, hdr_offset, object);\n-\n-    \/\/ Set header to be (markWord of object | UNLOCK_VALUE).\n-    \/\/ This will not change anything if it was unlocked before.\n-    z_oill(header, markWord::unlocked_value);\n-\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n-    \/\/ Initialize the box (Must happen before we update the object mark!).\n-    z_stg(header, mark_offset, monitor);\n-\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-    \/\/ not necessary, use offset in instruction directly.\n-    \/\/ add2reg(object_mark_addr, hdr_offset, object);\n-\n-    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-    z_csg(header, monitor, hdr_offset, object);\n-    assert(current_header == header,\n-           \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-\n-    z_bre(done);\n-\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    z_sgr(current_header, Z_SP);\n-\n-    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-\n-    \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n-    \/\/ (Z_R1 is temp and not used after here).\n-    load_const_optimized(Z_R0, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n-\n-    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-    \/\/ header indicating it is a recursive lock and be done.\n-    z_brne(slow_case);\n-    z_release();  \/\/ Member unnecessary on zarch AND because the above csg does a sync before and after.\n-    z_stg(Z_R0\/*==0!*\/, mark_offset, monitor);\n-  }\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n@@ -1102,5 +1018,0 @@\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-  \/\/ None of the above fast optimizations worked so we have to get into the\n-  \/\/ slow case of monitor enter.\n@@ -1112,2 +1023,0 @@\n-  \/\/ }\n-\n@@ -1125,22 +1034,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    return;\n-  }\n-\n-\/\/ else {\n-  \/\/ template code: (for LM_LEGACY):\n-  \/\/\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1162,39 +1049,2 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-  const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if we are in the fast recursive case.\n-    MacroAssembler::load_and_test_long(header, Address(monitor, mark_offset));\n-    z_bre(done); \/\/ header == 0 -> goto done\n-  }\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ If we still have a lightweight lock, unlock the object and be done.\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_unlock(object, header, current_header, slow_case);\n-\n-    z_bru(done);\n-  } else {\n-    \/\/ The markword is expected to be at offset 0.\n-    \/\/ This is not required on s390, at least not here.\n-    assert(hdr_offset == 0, \"unlock_object: review code below\");\n-\n-    \/\/ We have the displaced header in header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    z_lgr(current_header, monitor);\n-    z_csg(current_header, header, hdr_offset, object);\n-    z_bre(done);\n-  }\n-\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n+  lightweight_unlock(object, header, current_header, slow_case);\n+  z_bru(done);\n@@ -1209,3 +1059,0 @@\n-\n-  \/\/ }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":3,"deletions":156,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,3 +107,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -193,0 +196,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6766,26 +6766,40 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n-   \/\/byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = StringUTF16.getChar(sa, sp++);\n-   \/\/    if (c > '\\u00FF')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n-   \/\/\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n-   \/\/    byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = sa[sp++];\n-   \/\/    if (c >= '\\u0080')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n+\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/     int i = 0;\n+\/\/     for (; i < len; i++) {\n+\/\/         char c = sa[sp++];\n+\/\/         if (c > '\\u00FF')\n+\/\/             break;\n+\/\/         da[dp++] = (byte) c;\n+\/\/     }\n+\/\/     return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeISOArray0(\n+\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = StringUTF16.getChar(sa, sp++);\n+\/\/     if (c > '\\u00FF')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = sa[sp++];\n+\/\/     if (c >= '\\u0080')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":40,"deletions":26,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  \/\/ VM expects i2c entry to be always filled. The rest can be unset.\n+  \/\/ foil any attempt to call the i2c, c2i or unverified c2i entries\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -667,2 +667,11 @@\n-    if (is_dumping_preimage_static_archive() || is_dumping_final_static_archive()) {\n-      \/\/ Don't tweak execution mode\n+    if (is_dumping_preimage_static_archive()) {\n+      \/\/ Don't tweak execution mode during AOT training run\n+    } else if (is_dumping_final_static_archive()) {\n+      if (Arguments::mode() == Arguments::_comp) {\n+        \/\/ AOT assembly phase submits the non-blocking compilation requests\n+        \/\/ for methods collected during training run, then waits for all compilations\n+        \/\/ to complete. With -Xcomp, we block for each compilation request, which is\n+        \/\/ counter-productive. Switching back to mixed mode improves testing time\n+        \/\/ with AOT and -Xcomp.\n+        Arguments::set_mode_flags(Arguments::_mixed);\n+      }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1917,2 +1917,3 @@\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n+         JavaThread::current()->thread_state() == _thread_in_vm ||\n+         JavaThread::current() == java_lang_Thread::thread(java_thread),\n+         \"unsafe call to java_lang_Thread::get_thread_status()?\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n@@ -431,1 +431,1 @@\n-   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n+   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n@@ -437,1 +437,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/signature.hpp\"\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"oops\/methodData.hpp\"\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  assert(Universe::objectArrayKlass() != nullptr, \"Too early?\");\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -189,1 +189,5 @@\n-  static ObjArrayKlass* objectArrayKlass()       { return _objectArrayKlass; }\n+  static ObjArrayKlass* objectArrayKlass() {\n+    ObjArrayKlass* k = _objectArrayKlass;\n+    assert(k != nullptr, \"Object array klass should be initialized; too early?\");\n+    return k;\n+  }\n@@ -191,1 +195,5 @@\n-  static Klass* fillerArrayKlass()               { return _fillerArrayKlass; }\n+  static Klass* fillerArrayKlass() {\n+    Klass* k = _fillerArrayKlass;\n+    assert(k != nullptr, \"Filler array class should be initialized; too early?\");\n+    return k;\n+  }\n@@ -196,2 +204,3 @@\n-    assert(_typeArrayKlasses[t] != nullptr, \"domain check\");\n-    return _typeArrayKlasses[t];\n+    TypeArrayKlass* k = _typeArrayKlasses[t];\n+    assert(k != nullptr, \"Type array class should be initialized; too early?\");\n+    return k;\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  if (_resolved_indy_entries == nullptr) {\n+    return 0;\n+  }\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -669,0 +669,3 @@\n+  develop(bool, VerifyIntrinsicChecks, false,                               \\\n+          \"Verify in intrinsic that Java level checks work as expected\")    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2541,7 +2541,9 @@\n-          assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n-          ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-          uint i = 0;\n-          for (; i < call->row_limit(); i++) {\n-            ciKlass* receiver = call->receiver(i);\n-            if (receiver != nullptr) {\n-              break;\n+          if (TypeProfileCasts) {\n+            assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n+            ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n+            uint i = 0;\n+            for (; i < call->row_limit(); i++) {\n+              ciKlass* receiver = call->receiver(i);\n+              if (receiver != nullptr) {\n+                break;\n+              }\n@@ -2549,0 +2551,1 @@\n+            ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2550,1 +2553,0 @@\n-          ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -963,1 +963,5 @@\n-void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n+void LibraryCallKit::generate_string_range_check(Node* array,\n+                                                 Node* offset,\n+                                                 Node* count,\n+                                                 bool char_count,\n+                                                 bool halt_on_oob) {\n@@ -981,4 +985,11 @@\n-    PreserveJVMState pjvms(this);\n-    set_control(_gvn.transform(bailout));\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_maybe_recompile);\n+    if (halt_on_oob) {\n+      bailout = _gvn.transform(bailout)->as_Region();\n+      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n+      Node* halt = _gvn.transform(new HaltNode(bailout, frame, \"unexpected guard failure in intrinsic\"));\n+      C->root()->add_req(halt);\n+    } else {\n+      PreserveJVMState pjvms(this);\n+      set_control(_gvn.transform(bailout));\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_maybe_recompile);\n+    }\n@@ -1142,0 +1153,1 @@\n+\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1153,6 +1165,6 @@\n-  ba = must_be_not_null(ba, true);\n-\n-  \/\/ Range checks\n-  generate_string_range_check(ba, offset, len, false);\n-  if (stopped()) {\n-    return true;\n+  if (VerifyIntrinsicChecks) {\n+    ba = must_be_not_null(ba, true);\n+    generate_string_range_check(ba, offset, len, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n@@ -1160,0 +1172,1 @@\n+\n@@ -3671,1 +3684,1 @@\n-  lease_result_value->init_req(_true_path, null()); \/\/ if the lease was returned, return 0.\n+  lease_result_value->init_req(_true_path, _gvn.longcon(0)); \/\/ if the lease was returned, return 0L.\n@@ -6804,0 +6817,3 @@\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6814,2 +6830,8 @@\n-  src = must_be_not_null(src, true);\n-  dst = must_be_not_null(dst, true);\n+  \/\/ Cast source & target arrays to not-null\n+  if (VerifyIntrinsicChecks) {\n+    src = must_be_not_null(src, true);\n+    dst = must_be_not_null(dst, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n@@ -6832,0 +6854,9 @@\n+  \/\/ Check source & target bounds\n+  if (VerifyIntrinsicChecks) {\n+    generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n+    generate_string_range_check(dst, dst_offset, length, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -175,1 +175,2 @@\n-                                    Node* length, bool char_count);\n+                                    Node* length, bool char_count,\n+                                    bool halt_on_oob = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1639,0 +1639,58 @@\n+private:\n+  \/\/ Class to keep track of wins in split_thru_phi.\n+  class SplitThruPhiWins {\n+  private:\n+    \/\/ Region containing the phi we are splitting through.\n+    const Node* _region;\n+\n+    \/\/ Sum of all wins regardless of where they happen. This applies to Loops phis as well as non-loop phis.\n+    int _total_wins;\n+\n+    \/\/ For Loops, wins have different impact depending on if they happen on loop entry or on the backedge.\n+    \/\/ Number of wins on a loop entry edge if the split is through a loop head,\n+    \/\/ otherwise 0. Entry edge wins only pay dividends once on loop entry.\n+    int _loop_entry_wins;\n+    \/\/ Number of wins on a loop back-edge, which pay dividends on every iteration.\n+    int _loop_back_wins;\n+\n+  public:\n+    SplitThruPhiWins(const Node* region) :\n+      _region(region),\n+      _total_wins(0),\n+      _loop_entry_wins(0),\n+      _loop_back_wins(0) {};\n+\n+    void reset() {_total_wins = 0; _loop_entry_wins = 0; _loop_back_wins = 0;}\n+    void add_win(int ctrl_index) {\n+      if (_region->is_Loop() && ctrl_index == LoopNode::EntryControl) {\n+        _loop_entry_wins++;\n+      } else if (_region->is_Loop() && ctrl_index == LoopNode::LoopBackControl) {\n+        _loop_back_wins++;\n+      }\n+      _total_wins++;\n+    }\n+    \/\/ Is this split profitable with respect to the policy?\n+    bool profitable(int policy) const {\n+      assert(_region->is_Loop() || (_loop_entry_wins == 0 && _loop_back_wins == 0), \"wins on loop edges without a loop\");\n+      assert(!_region->is_Loop() || _total_wins == _loop_entry_wins + _loop_back_wins, \"missed some win\");\n+      \/\/ In general this means that the split has to have more wins than specified\n+      \/\/ in the policy. However, for loops we need to take into account where the\n+      \/\/ wins happen. We need to be careful when splitting, because splitting nodes\n+      \/\/ related to the iv through the phi can sufficiently rearrange the loop\n+      \/\/ structure to prevent RCE and thus vectorization. Thus, we only deem splitting\n+      \/\/ profitable if the win of a split is not on the entry edge, as such wins\n+      \/\/ only pay off once and have a high chance of messing up the loop structure.\n+      return (_loop_entry_wins == 0 && _total_wins > policy) ||\n+      \/\/ If there are wins on the entry edge but the backadge also has sufficient wins,\n+      \/\/ there is sufficient profitability to spilt regardless of the risk of messing\n+      \/\/ up the loop structure.\n+             _loop_back_wins > policy ||\n+      \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n+      \/\/ split. This is needed when we split a node and then must also split a\n+      \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n+             policy < 0;\n+    }\n+  };\n+\n+public:\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -76,1 +77,1 @@\n-  int wins = 0;\n+  SplitThruPhiWins wins(region);\n@@ -129,1 +130,1 @@\n-      wins++;\n+      wins.add_win(i);\n@@ -144,1 +145,1 @@\n-        wins++;\n+        wins.add_win(i);\n@@ -152,1 +153,1 @@\n-          wins++;\n+          wins.add_win(i);\n@@ -175,1 +176,1 @@\n-      wins = 0;\n+      wins.reset();\n@@ -180,1 +181,1 @@\n-  if (wins <= policy) {\n+  if (!wins.profitable(policy)) {\n@@ -237,0 +238,7 @@\n+#ifndef PRODUCT\n+  if (TraceLoopOpts) {\n+    tty->print(\"Split %d %s through %d Phi in %d %s\",\n+               n->_idx, n->Name(), phi->_idx, region->_idx, region->Name());\n+  }\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  inline void patch_pd_unused(intptr_t* sp);\n@@ -786,3 +787,18 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n-  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n+\n+  int adjust = frame::metadata_words_at_bottom;\n+#if INCLUDE_ASAN && defined(AARCH64)\n+  \/\/ Reading at offset frame::metadata_words_at_bottom from _cont_stack_top\n+  \/\/ will accesss memory at the callee frame, which on preemption cases will\n+  \/\/ be the VM native method being called. The Arm 64-bit ABI doesn't specify\n+  \/\/ a location where the frame record (returnpc+fp) has to be stored within\n+  \/\/ a stack frame, and GCC currently chooses to save it at the top of the\n+  \/\/ frame (lowest address). ASan treats this memory access in the callee as\n+  \/\/ an overflow access to one of the locals stored in that frame. For these\n+  \/\/ preemption cases we don't need to read these words anyways so we avoid it.\n+  if (_preempt) {\n+    adjust = 0;\n+  }\n+#endif\n+  intptr_t* from = _cont_stack_top - adjust;\n+  intptr_t* to   = chunk_top - adjust;\n+  copy_to_chunk(from, to, cont_size() + adjust);\n@@ -819,0 +835,5 @@\n+    \/\/ For stub\/native frames the fp is not used while frozen, and will be constructed\n+    \/\/ again when thawing the frame (see ThawBase::handle_preempted_continuation). We\n+    \/\/ patch it with a special bad address to help with debugging, particularly when\n+    \/\/ inspecting frames and identifying invalid accesses.\n+    patch_pd_unused(chunk_top);\n@@ -2537,1 +2558,1 @@\n-    \/\/ we copied the original fp at the time of freeze which now will have to be fixed.\n+    \/\/ we copied the fp patched during freeze, which will now have to be fixed.\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -611,1 +611,2 @@\n-    guarantee(expressions != nullptr && expressions->length() > 0, \"must have exception to throw\");\n+    guarantee(expressions != nullptr && expressions->length() == 1, \"should have only exception on stack\");\n+    guarantee(exec_mode != Unpack_exception, \"rethrow_exception set with Unpack_exception\");\n@@ -787,0 +788,1 @@\n+    assert(array->element(0)->rethrow_exception(), \"must be\");\n@@ -894,0 +896,1 @@\n+#ifdef ASSERT\n@@ -918,0 +921,1 @@\n+#endif\n@@ -982,4 +986,3 @@\n-    bool is_top_frame = true;\n-    int callee_max_locals = 0;\n-    for (int i = 0; i < cur_array->frames(); i++) {\n-      vframeArrayElement* el = cur_array->element(i);\n+    for (int frame_idx = 0; frame_idx < cur_array->frames(); frame_idx++) {\n+      bool is_top_frame = (frame_idx == 0);\n+      vframeArrayElement* el = cur_array->element(frame_idx);\n@@ -989,0 +992,2 @@\n+      methodHandle mh(thread, iframe->interpreter_frame_method());\n+      bool reexecute = el->should_reexecute();\n@@ -990,8 +995,1 @@\n-      \/\/ Get the oop map for this bci\n-      InterpreterOopMap mask;\n-      bool try_next_mask = false;\n-      int next_mask_expression_stack_size = -1;\n-      methodHandle mh(thread, iframe->interpreter_frame_method());\n-      OopMapCache::compute_one_oop_map(mh, iframe->interpreter_frame_bci(), &mask);\n-      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n-      \/\/ Get to the next bytecode if possible\n+      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -1002,0 +1000,32 @@\n+      Bytecodes::Code cur_code = str.next();\n+\n+      if (!reexecute && !Bytecodes::is_invoke(cur_code)) {\n+        \/\/ We can only compute OopMaps for the before state, so we need to roll forward\n+        \/\/ to the next bytecode.\n+        assert(is_top_frame, \"must be\");\n+        assert(falls_through(cur_code), \"must be\");\n+        assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+        assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+        \/\/ Need to subtract off the size of the result type of\n+        \/\/ the bytecode because this is not described in the\n+        \/\/ debug info but returned to the interpreter in the TOS\n+        \/\/ caching register\n+        BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n+        if (bytecode_result_type != T_ILLEGAL) {\n+          top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n+        }\n+        assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n+\n+        cur_code = str.next();\n+        \/\/ Reflect the fact that we have rolled forward and now need\n+        \/\/ top_frame_expression_stack_adjustment\n+        reexecute = true;\n+      }\n+\n+      assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+      assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+      \/\/ Get the oop map for this bci\n+      InterpreterOopMap mask;\n+      OopMapCache::compute_one_oop_map(mh, str.bci(), &mask);\n@@ -1005,3 +1035,1 @@\n-      Bytecodes::Code cur_code = str.next();\n-      Bytecodes::Code next_code = Bytecodes::_shouldnotreachhere;\n-        Bytecode_invoke invoke(mh, iframe->interpreter_frame_bci());\n+        Bytecode_invoke invoke(mh, str.bci());\n@@ -1010,1 +1038,1 @@\n-        if (i != 0 && invoke.has_member_arg()) {\n+        if (!is_top_frame && invoke.has_member_arg()) {\n@@ -1014,30 +1042,0 @@\n-      if (str.bci() < max_bci) {\n-        next_code = str.next();\n-        if (next_code >= 0) {\n-          \/\/ The interpreter oop map generator reports results before\n-          \/\/ the current bytecode has executed except in the case of\n-          \/\/ calls. It seems to be hard to tell whether the compiler\n-          \/\/ has emitted debug information matching the \"state before\"\n-          \/\/ a given bytecode or the state after, so we try both\n-          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n-            \/\/ Get expression stack size for the next bytecode\n-            InterpreterOopMap next_mask;\n-            OopMapCache::compute_one_oop_map(mh, str.bci(), &next_mask);\n-            next_mask_expression_stack_size = next_mask.expression_stack_size();\n-            if (Bytecodes::is_invoke(next_code)) {\n-              Bytecode_invoke invoke(mh, str.bci());\n-              next_mask_expression_stack_size += invoke.size_of_parameters();\n-            }\n-            \/\/ Need to subtract off the size of the result type of\n-            \/\/ the bytecode because this is not described in the\n-            \/\/ debug info but returned to the interpreter in the TOS\n-            \/\/ caching register\n-            BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n-            if (bytecode_result_type != T_ILLEGAL) {\n-              top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n-            }\n-            assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n-            try_next_mask = true;\n-          }\n-        }\n-      }\n@@ -1046,38 +1044,43 @@\n-      \/\/ This assertion may be dependent on the platform we're running on and may need modification (tested on x86 and sparc)\n-      if (!(\n-            \/* SPARC *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||\n-            \/* x86 *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||\n-            (try_next_mask &&\n-             (iframe->interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -\n-                                                                    top_frame_expression_stack_adjustment))) ||\n-            (is_top_frame && (exec_mode == Unpack_exception) && iframe->interpreter_frame_expression_stack_size() == 0) ||\n-            (is_top_frame && (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el->should_reexecute()) &&\n-             (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))\n-            )) {\n-        {\n-          \/\/ Print out some information that will help us debug the problem\n-          tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n-          tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n-          tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n-          if (try_next_mask) {\n-            tty->print_cr(\"  Next code %s\", Bytecodes::name(next_code));\n-          }\n-          tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n-                        iframe->interpreter_frame_expression_stack_size());\n-          tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n-          tty->print_cr(\"  try_next_mask = %d\", try_next_mask);\n-          tty->print_cr(\"  next_mask_expression_stack_size = %d\", next_mask_expression_stack_size);\n-          tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n-          tty->print_cr(\"  callee_max_locals = %d\", callee_max_locals);\n-          tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n-          tty->print_cr(\"  exec_mode = %d\", exec_mode);\n-          tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n-          tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n-          tty->print_cr(\"  Interpreted frames:\");\n-          for (int k = 0; k < cur_array->frames(); k++) {\n-            vframeArrayElement* el = cur_array->element(k);\n-            tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n-          }\n-          cur_array->print_on_2(tty);\n+      auto match = [&]() {\n+        int iframe_expr_ssize = iframe->interpreter_frame_expression_stack_size();\n+#if INCLUDE_JVMCI\n+        if (is_top_frame && el->rethrow_exception()) {\n+          return iframe_expr_ssize == 1;\n+        }\n+#endif\n+        \/\/ This should only be needed for C1\n+        if (is_top_frame && exec_mode == Unpack_exception && iframe_expr_ssize == 0) {\n+          return true;\n+        }\n+        if (reexecute) {\n+          int expr_ssize_before = iframe_expr_ssize + top_frame_expression_stack_adjustment;\n+          int oopmap_expr_invoke_ssize = mask.expression_stack_size() + cur_invoke_parameter_size;\n+          return expr_ssize_before == oopmap_expr_invoke_ssize;\n+        } else {\n+          int oopmap_expr_callee_ssize = mask.expression_stack_size() + callee_size_of_parameters;\n+          return iframe_expr_ssize == oopmap_expr_callee_ssize;\n+        }\n+      };\n+      if (!match()) {\n+        \/\/ Print out some information that will help us debug the problem\n+        tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n+        tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", frame_idx, cur_array->frames() - 1);\n+        tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n+        tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n+                      iframe->interpreter_frame_expression_stack_size());\n+        tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n+        tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n+        tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n+        tty->print_cr(\"  exec_mode = %d\", exec_mode);\n+        tty->print_cr(\"  original should_reexecute = %s\", el->should_reexecute() ? \"true\" : \"false\");\n+        tty->print_cr(\"  reexecute = %s%s\", reexecute ? \"true\" : \"false\",\n+                      (reexecute != el->should_reexecute()) ? \" (changed)\" : \"\");\n+#if INCLUDE_JVMCI\n+        tty->print_cr(\"  rethrow_exception = %s\", el->rethrow_exception() ? \"true\" : \"false\");\n+#endif\n+        tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n+        tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n+        tty->print_cr(\"  Interpreted frames:\");\n+        for (int k = 0; k < cur_array->frames(); k++) {\n+          vframeArrayElement* el = cur_array->element(k);\n+          tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n@@ -1085,0 +1088,1 @@\n+        cur_array->print_on_2(tty);\n@@ -1090,2 +1094,0 @@\n-      callee_max_locals = mh->max_locals();\n-      is_top_frame = false;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":89,"deletions":87,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -240,1 +240,2 @@\n-          \"page size for the environment as the maximum)\")                  \\\n+          \"page size for the environment as the maximum) \"                  \\\n+          \"(must be a power of 2)\")                                         \\\n@@ -242,0 +243,1 @@\n+          constraint(LargePageSizeInBytesConstraintFunc, AtParse)           \\\n@@ -486,0 +488,3 @@\n+  develop(bool, ZapCHeap, trueInDebug,                                      \\\n+          \"Zap allocated\/freed C heap space\")                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-        VMError::set_safepoint_timed_out_thread(p2i(cur_thread));\n+        VMError::set_safepoint_timed_out_thread(cur_thread);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2688,5 +2688,7 @@\n-    assert(no_arg_blob != nullptr &&\n-           obj_arg_blob != nullptr &&\n-           int_arg_blob != nullptr &&\n-           obj_int_arg_blob != nullptr &&\n-           obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n+    \/\/ we should always get an entry back but we don't have any\n+    \/\/ associated blob on Zero\n+    assert(_no_arg_handler != nullptr &&\n+           _obj_arg_handler != nullptr &&\n+           _int_arg_handler != nullptr &&\n+           _obj_int_arg_handler != nullptr &&\n+           _obj_obj_arg_handler != nullptr, \"Initial adapter handlers must be properly created\");\n@@ -2696,0 +2698,2 @@\n+#ifndef ZERO\n+  \/\/ no blobs to register when we are on Zero\n@@ -2701,0 +2705,1 @@\n+#endif \/\/ ZERO\n@@ -3120,0 +3125,2 @@\n+  \/\/ we can only check for the same code if there is any\n+#ifndef ZERO\n@@ -3126,0 +3133,1 @@\n+# endif \/\/ ZERO\n@@ -3228,1 +3236,2 @@\n-  int insts_size = adapter_blob->code_size();\n+  int insts_size;\n+  \/\/ on Zero the blob may be null\n@@ -3230,0 +3239,4 @@\n+  if (adapter_blob == nullptr) {\n+    return;\n+  }\n+  insts_size = adapter_blob->code_size();\n@@ -3278,0 +3291,5 @@\n+#ifdef ZERO\n+  \/\/ On zero there is no code to save and no need to create a blob and\n+  \/\/ or relocate the handler.\n+  adapter_blob = nullptr;\n+#else\n@@ -3302,0 +3320,2 @@\n+#endif \/\/ ZERO\n+\n@@ -3308,0 +3328,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -176,8 +176,0 @@\n-  if (code_size == 0) {\n-    LogTarget(Info, stubs) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print_cr(\"%s\\t not generated\", buffer_name);\n-    }\n-    return nullptr;\n-  }\n@@ -204,0 +196,9 @@\n+  if (code_size == 0) {\n+    assert(buffer.insts_size() == 0, \"should not write into buffer when bob size declared as 0\");\n+    LogTarget(Info, stubs) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"%s\\t not generated\", buffer_name);\n+    }\n+    return nullptr;\n+  }\n@@ -206,1 +207,1 @@\n-  assert(code_size == 0 || buffer.insts_remaining() > 200,\n+  assert(buffer.insts_remaining() > 200,\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -98,6 +98,0 @@\n-\n-  void  clear()                 { _len = 0; }\n-  void  trunc_to(int length)    {\n-    assert(length <= _len,\"cannot increase length\");\n-    _len = length;\n-  }\n@@ -195,5 +189,0 @@\n-  E pop() {\n-    assert(_len > 0, \"empty list\");\n-    return _data[--_len];\n-  }\n-\n@@ -253,53 +242,0 @@\n-  \/\/ Order preserving remove operations.\n-\n-  void remove(const E& elem) {\n-    \/\/ Assuming that element does exist.\n-    bool removed = remove_if_existing(elem);\n-    if (removed) return;\n-    ShouldNotReachHere();\n-  }\n-\n-  bool remove_if_existing(const E& elem) {\n-    \/\/ Returns TRUE if elem is removed.\n-    for (int i = 0; i < _len; i++) {\n-      if (_data[i] == elem) {\n-        remove_at(i);\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  void remove_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    for (int j = index + 1; j < _len; j++) {\n-      _data[j-1] = _data[j];\n-    }\n-    _len--;\n-  }\n-\n-  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n-  void remove_till(int idx) {\n-    remove_range(0, idx);\n-  }\n-\n-  \/\/ Remove all elements in the range [start - end). The order is preserved.\n-  void remove_range(int start, int end) {\n-    assert(0 <= start, \"illegal start index %d\", start);\n-    assert(start < end && end <= _len, \"erase called with invalid range (%d, %d) for length %d\", start, end, _len);\n-\n-    for (int i = start, j = end; j < length(); i++, j++) {\n-      at_put(i, at(j));\n-    }\n-    trunc_to(length() - (end - start));\n-  }\n-\n-  \/\/ The order is changed.\n-  void delete_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    if (index < --_len) {\n-      \/\/ Replace removed element with last one.\n-      _data[index] = _data[_len];\n-    }\n-  }\n-\n@@ -433,0 +369,5 @@\n+  E pop() {\n+    assert(this->_len > 0, \"empty list\");\n+    return this->_data[--this->_len];\n+  }\n+\n@@ -526,0 +467,61 @@\n+  void trunc_to(int length) {\n+    assert(length <= this->_len,\"cannot increase length\");\n+    this->_len = length;\n+  }\n+\n+  \/\/ Order preserving remove operations.\n+\n+  void remove_at(int index) {\n+    assert(0 <= index && index < this->_len,\n+           \"illegal index %d for length %d\", index, this->_len);\n+    for (int j = index + 1; j < this->_len; j++) {\n+      this->_data[j-1] = this->_data[j];\n+    }\n+    this->_len--;\n+  }\n+\n+  void remove(const E& elem) {\n+    \/\/ Assuming that element does exist.\n+    bool removed = this->remove_if_existing(elem);\n+    if (removed) return;\n+    ShouldNotReachHere();\n+  }\n+\n+  bool remove_if_existing(const E& elem) {\n+    \/\/ Returns TRUE if elem is removed.\n+    for (int i = 0; i < this->_len; i++) {\n+      if (this->_data[i] == elem) {\n+        this->remove_at(i);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n+  void remove_till(int idx) {\n+    remove_range(0, idx);\n+  }\n+\n+  \/\/ Remove all elements in the range [start - end). The order is preserved.\n+  void remove_range(int start, int end) {\n+    assert(0 <= start, \"illegal start index %d\", start);\n+    assert(start < end && end <= this->_len,\n+           \"erase called with invalid range (%d, %d) for length %d\",\n+           start, end, this->_len);\n+\n+    for (int i = start, j = end; j < this->length(); i++, j++) {\n+      this->at_put(i, this->at(j));\n+    }\n+    this->_len -= (end - start);\n+  }\n+\n+  \/\/ Replaces the designated element with the last element and shrinks by 1.\n+  void delete_at(int index) {\n+    assert(0 <= index && index < this->_len, \"illegal index %d for length %d\", index, this->_len);\n+    if (index < --this->_len) {\n+      \/\/ Replace removed element with last one.\n+      this->_data[index] = this->_data[this->_len];\n+    }\n+  }\n+\n@@ -529,0 +531,1 @@\n+  void clear() { this->_len = 0; }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":67,"deletions":64,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -2146,0 +2145,5 @@\n+\n+            public String uncheckedNewStringWithLatin1Bytes(byte[] bytes) {\n+                return String.newStringWithLatin1Bytes(bytes);\n+            }\n+\n@@ -2159,4 +2163,0 @@\n-            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8NoRepl(bytes, off, len, true);\n-            }\n-\n@@ -2175,2 +2175,2 @@\n-            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n-                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n+                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.function.BiFunction;\n@@ -321,0 +322,12 @@\n+    \/**\n+     * Constructs a new {@code String} with the supplied Latin1 bytes.\n+     * <p>\n+     * <b>WARNING: The caller of this method shall relinquish and transfer the\n+     * ownership of the byte array to the callee<\/b>, since the latter will not\n+     * make a copy.\n+     *\n+     * @param bytes the byte array source\n+     * @return the newly created string\n+     *\/\n+    String uncheckedNewStringWithLatin1Bytes(byte[] bytes);\n+\n@@ -354,10 +367,0 @@\n-    \/**\n-     * Returns a new string by decoding from the given UTF-8 bytes array.\n-     *\n-     * @param off the index of the first byte to decode\n-     * @param len the number of bytes to decode\n-     * @return the newly created string\n-     * @throws IllegalArgumentException for malformed or unmappable bytes.\n-     *\/\n-    String newStringUTF8NoRepl(byte[] bytes, int off, int len);\n-\n@@ -426,5 +429,3 @@\n-     * Encodes as many ASCII codepoints as possible from the source array into\n-     * the destination byte array, assuming that the encoding is ASCII\n-     * compatible.\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n@@ -432,3 +433,9 @@\n-     * @return the number of bytes successfully encoded, or 0 if none\n-     *\/\n-    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -427,0 +427,1 @@\n+            Objects.requireNonNull(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-        java.desktop, \/\/ for ScopedValue\n@@ -158,6 +157,1 @@\n-        jdk.incubator.vector, \/\/ participates in preview features\n-        jdk.jartool, \/\/ participates in preview features\n-        jdk.jdeps, \/\/ participates in preview features\n-        jdk.jfr, \/\/ participates in preview features\n-        jdk.jlink,   \/\/ participates in preview features\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.jdeps;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -382,4 +382,1 @@\n-         *\n-         * <p>\n-         * This category is not supported by {@code @SuppressWarnings} (yet - see JDK-8224228).\n-        TEXT_BLOCKS(\"text-blocks\", false),\n+        TEXT_BLOCKS(\"text-blocks\"),\n@@ -484,21 +481,0 @@\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(LintWarning warning) {\n-        logIfEnabled(null, warning);\n-    }\n-\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param pos source position at which to report the warning\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(DiagnosticPosition pos, LintWarning warning) {\n-        if (isEnabled(warning.getLintCategory())) {\n-            log.warning(pos, warning);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-    \/** flag: is the \"preview\" lint category enabled? *\/\n-    private final boolean verbose;\n-\n@@ -103,1 +100,0 @@\n-        verbose = Lint.instance(context).isEnabled(LintCategory.PREVIEW);\n@@ -187,3 +183,1 @@\n-        if (verbose) {\n-            log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n-        }\n+        log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,2 +92,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n-    private final Lint lint;\n@@ -114,1 +112,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -117,1 +114,0 @@\n-        lint = Lint.instance(context);\n@@ -240,3 +236,1 @@\n-     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n-    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv,\n-            Symbol s, JCTree deferDecl)\n+    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv, Symbol s)\n@@ -261,2 +255,0 @@\n-            Assert.check(deferDecl != null);\n-            deferredLintHandler.push(deferDecl);\n@@ -273,1 +265,0 @@\n-                deferredLintHandler.pop();\n@@ -290,2 +281,1 @@\n-    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv,\n-            MethodSymbol m, JCTree deferDecl)\n+    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv, MethodSymbol m)\n@@ -295,1 +285,0 @@\n-            deferredLintHandler.push(deferDecl);\n@@ -299,1 +288,0 @@\n-                deferredLintHandler.pop();\n@@ -703,1 +691,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym);\n@@ -1055,2 +1043,1 @@\n-    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env,\n-            Symbol s, JCTree deferDecl, boolean isTypeParam)\n+    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env, Symbol s, boolean isTypeParam)\n@@ -1061,3 +1048,0 @@\n-        if (deferDecl != null) {\n-            deferredLintHandler.push(deferDecl);\n-        }\n@@ -1067,2 +1051,0 @@\n-            if (deferDecl != null)\n-                deferredLintHandler.pop();\n@@ -1076,1 +1058,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym)\n@@ -1079,1 +1061,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym)));\n@@ -1114,2 +1096,1 @@\n-        private JCTree deferDecl;\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym) {\n@@ -1120,1 +1101,0 @@\n-            this.deferDecl = deferDecl;\n@@ -1125,1 +1105,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1131,1 +1111,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, true);\n@@ -1137,1 +1117,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1139,1 +1119,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, false);\n@@ -1158,12 +1138,5 @@\n-            JCTree prevDecl = deferDecl;\n-            deferDecl = tree;\n-            try {\n-                if (sym != null && sym.kind == VAR) {\n-                    \/\/ Don't visit a parameter once when the sym is the method\n-                    \/\/ and once when the sym is the parameter.\n-                    scan(tree.mods);\n-                    scan(tree.vartype);\n-                }\n-                scan(tree.init);\n-            } finally {\n-                deferDecl = prevDecl;\n+            if (sym != null && sym.kind == VAR) {\n+                \/\/ Don't visit a parameter once when the sym is the method\n+                \/\/ and once when the sym is the parameter.\n+                scan(tree.mods);\n+                scan(tree.vartype);\n@@ -1171,0 +1144,1 @@\n+            scan(tree.init);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -101,0 +102,1 @@\n+    final LintMapper lintMapper;\n@@ -119,1 +121,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -141,0 +142,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -160,1 +162,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -845,1 +846,0 @@\n-        deferredLintHandler.push(variable);\n@@ -861,1 +861,0 @@\n-            deferredLintHandler.pop();\n@@ -990,1 +989,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1229,1 +1227,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m);\n@@ -1553,1 +1551,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1612,1 +1609,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym);\n@@ -1713,1 +1710,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);\n+            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner);\n@@ -2226,1 +2223,1 @@\n-            env.info.lint.logIfEnabled(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+            log.warning(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2328,1 +2325,1 @@\n-                env.info.lint.logIfEnabled(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -4500,1 +4497,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n+        annotate.annotateLater(tree.var.mods.annotations, env, v);\n@@ -4502,1 +4499,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v);\n@@ -4741,1 +4738,1 @@\n-            env.info.lint.logIfEnabled(tree, LintWarnings.TryExplicitCloseCall);\n+            log.warning(tree, LintWarnings.TryExplicitCloseCall);\n@@ -4768,1 +4765,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4770,1 +4767,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -5572,0 +5569,3 @@\n+\n+        \/\/ Now that this tree is attributed, we can calculate the Lint configuration everywhere within it\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n@@ -5614,1 +5614,0 @@\n-            deferredLintHandler.flush(env.tree, lint);\n@@ -5798,1 +5797,0 @@\n-                deferredLintHandler.flush(env.tree, env.info.lint);\n@@ -5849,4 +5847,2 @@\n-        chk.checkModuleName(tree);\n-        chk.checkDeprecatedAnnotation(tree, msym);\n-\n-            deferredLintHandler.flush(tree, lint);\n+            chk.checkModuleName(tree);\n+            chk.checkDeprecatedAnnotation(tree, msym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    Lint lint;\n+    private Lint lint;\n@@ -167,2 +167,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-\n@@ -185,4 +183,0 @@\n-    \/** A handler for deferred lint warnings.\n-     *\/\n-    private DeferredLintHandler deferredLintHandler;\n-\n@@ -238,18 +232,9 @@\n-        LintWarning warningKey = null;\n-        if (sym.isDeprecatedForRemoval()) {\n-            if (!lint.isSuppressed(LintCategory.REMOVAL)) {\n-                if (sym.kind == MDL) {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n-                } else {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n-                }\n-            }\n-        } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {\n-            if (sym.kind == MDL) {\n-                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n-            } else {\n-                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n-            }\n-        }\n-        if (warningKey != null)\n-            log.warning(pos, warningKey);\n+        Assert.check(!importSuppression);\n+        LintWarning warningKey = sym.isDeprecatedForRemoval() ?\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedForRemovalModule(sym) :\n+                LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location())) :\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedModule(sym) :\n+                LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+        log.warning(pos, warningKey);\n@@ -263,1 +248,1 @@\n-        if (!importSuppression && !lint.isSuppressed(LintCategory.PREVIEW))\n+        if (!importSuppression)\n@@ -267,8 +252,0 @@\n-    \/** Log a preview warning.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param msg        A Warning describing the problem.\n-     *\/\n-    public void warnRestrictedAPI(DiagnosticPosition pos, Symbol sym) {\n-        lint.logIfEnabled(pos, LintWarnings.RestrictedMethod(sym.enclClass(), sym));\n-    }\n-\n@@ -280,2 +257,1 @@\n-        if (!lint.isSuppressed(LintCategory.UNCHECKED))\n-            log.warning(pos, warnKey);\n+        log.warning(pos, warnKey);\n@@ -617,3 +593,1 @@\n-            deferredLintHandler.report(_l -> {\n-                lint.logIfEnabled(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n-            });\n+            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n@@ -974,1 +948,1 @@\n-            lint.logIfEnabled(tree, LintWarnings.VarargsRedundantTrustmeAnno(\n+            log.warning(tree.pos(), LintWarnings.VarargsRedundantTrustmeAnno(\n@@ -1245,1 +1219,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1297,1 +1271,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1372,10 +1346,0 @@\n-    private void warnOnExplicitStrictfp(JCTree tree) {\n-        deferredLintHandler.push(tree);\n-        try {\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(tree.pos(), LintWarnings.Strictfp));\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n-    }\n-\n-\n@@ -1594,1 +1558,1 @@\n-            lint.logIfEnabled(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n+            log.warning(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n@@ -1918,1 +1882,1 @@\n-            lint.logIfEnabled(TreeInfo.diagnosticPositionFor(m, tree),\n+            log.warning(TreeInfo.diagnosticPositionFor(m, tree),\n@@ -1932,6 +1896,1 @@\n-            Lint prevLint = setLint(lint.augment(m));\n-            try {\n-                checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n-            } finally {\n-                setLint(prevLint);\n-            }\n+            checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n@@ -3023,7 +2982,2 @@\n-        final Lint prevLint = setLint(warnOnAnyAccessToMembers ? lint.enable(LintCategory.SERIAL) : lint);\n-        try {\n-            if (warnOnAnyAccessToMembers || isLambda)\n-                checkAccessFromSerializableElementInner(tree, isLambda);\n-        } finally {\n-            setLint(prevLint);\n-        }\n+        if (warnOnAnyAccessToMembers || isLambda)\n+            checkAccessFromSerializableElementInner(tree, isLambda);\n@@ -3033,5 +2987,4 @@\n-        if (lint.isEnabled(LintCategory.SERIAL)) {\n-            Symbol sym = TreeInfo.symbol(tree);\n-            if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n-                return;\n-            }\n+        Symbol sym = TreeInfo.symbol(tree);\n+        if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n+            return;\n+        }\n@@ -3039,7 +2992,6 @@\n-            if (sym.kind == VAR) {\n-                if ((sym.flags() & PARAMETER) != 0 ||\n-                    sym.isDirectlyOrIndirectlyLocal() ||\n-                    sym.name == names._this ||\n-                    sym.name == names._super) {\n-                    return;\n-                }\n+        if (sym.kind == VAR) {\n+            if ((sym.flags() & PARAMETER) != 0 ||\n+                sym.isDirectlyOrIndirectlyLocal() ||\n+                sym.name == names._this ||\n+                sym.name == names._super) {\n+                return;\n@@ -3047,0 +2999,1 @@\n+        }\n@@ -3048,10 +3001,5 @@\n-            if (!types.isSubtype(sym.owner.type, syms.serializableType) &&\n-                isEffectivelyNonPublic(sym)) {\n-                if (isLambda) {\n-                    if (belongsToRestrictedPackage(sym)) {\n-                        log.warning(tree.pos(),\n-                                    LintWarnings.AccessToMemberFromSerializableLambda(sym));\n-                    }\n-                } else {\n-                    log.warning(tree.pos(),\n-                                LintWarnings.AccessToMemberFromSerializableElement(sym));\n+        if (!types.isSubtype(sym.owner.type, syms.serializableType) && isEffectivelyNonPublic(sym)) {\n+            DiagnosticFlag flag = warnOnAnyAccessToMembers ? DiagnosticFlag.DEFAULT_ENABLED : null;\n+            if (isLambda) {\n+                if (belongsToRestrictedPackage(sym)) {\n+                    log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableLambda(sym));\n@@ -3059,0 +3007,2 @@\n+            } else {\n+                log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableElement(sym));\n@@ -3845,2 +3795,1 @@\n-                log.warning(pos,\n-                            LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n+                log.warning(pos, LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n@@ -3860,1 +3809,1 @@\n-            deferredLintHandler.report(_l -> warnDeprecated(pos.get(), s));\n+            warnDeprecated(pos.get(), s);\n@@ -3866,3 +3815,1 @@\n-            deferredLintHandler.report(_l -> {\n-                log.warning(pos, Warnings.SunProprietary(s));\n-            });\n+            log.warning(pos, Warnings.SunProprietary(s));\n@@ -3925,1 +3872,1 @@\n-            deferredLintHandler.report(_l -> warnRestrictedAPI(pos, s));\n+            log.warning(pos, LintWarnings.RestrictedMethod(s.enclClass(), s));\n@@ -4197,1 +4144,1 @@\n-                deferredLintHandler.report(_ -> lint.logIfEnabled(pos, LintWarnings.DivZero));\n+                log.warning(pos, LintWarnings.DivZero);\n@@ -4210,2 +4157,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PossibleLossOfPrecision(found, req)));\n+            log.warning(pos, LintWarnings.PossibleLossOfPrecision(found, req));\n@@ -4220,1 +4166,1 @@\n-            lint.logIfEnabled(tree.thenpart.pos(), LintWarnings.EmptyIf);\n+            log.warning(tree.thenpart.pos(), LintWarnings.EmptyIf);\n@@ -4367,2 +4313,1 @@\n-            lint.logIfEnabled(pos,\n-                        LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n+            log.warning(pos, LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n@@ -4410,2 +4355,1 @@\n-                            deferredLintHandler.report(_ ->\n-                                lint.logIfEnabled(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle)));\n+                            log.warning(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle));\n@@ -4447,1 +4391,1 @@\n-                        Check.this.lint.logIfEnabled(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n+                        log.warning(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n@@ -4745,2 +4689,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.ModuleNotFound(msym)));\n+            log.warning(pos, LintWarnings.ModuleNotFound(msym));\n@@ -4753,2 +4696,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PackageEmptyOrNotFound(packge)));\n+            log.warning(pos, LintWarnings.PackageEmptyOrNotFound(packge));\n@@ -4760,7 +4702,5 @@\n-            deferredLintHandler.report(_ -> {\n-                if (rd.isTransitive() && lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {\n-                    log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n-                } else {\n-                    lint.logIfEnabled(pos, LintWarnings.RequiresAutomatic);\n-                }\n-            });\n+            if (rd.isTransitive()) {    \/\/ see comment in Log.applyLint() for special logic that applies\n+                log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n+            } else {\n+                log.warning(pos, LintWarnings.RequiresAutomatic);\n+            }\n@@ -5854,1 +5794,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5861,1 +5801,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5888,1 +5828,1 @@\n-                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                log.warning(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5965,1 +5905,1 @@\n-                        .forEach(ta -> lint.logIfEnabled(typeParamTrees.get(ta.position.parameter_index).pos(),\n+                        .forEach(ta -> log.warning(typeParamTrees.get(ta.position.parameter_index).pos(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":60,"deletions":120,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -218,1 +218,0 @@\n-    private       Lint lint;\n@@ -343,1 +342,0 @@\n-        lint = Lint.instance(context);\n@@ -592,1 +590,0 @@\n-            Lint lintPrev = lint;\n@@ -595,1 +592,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -626,1 +622,0 @@\n-                lint = lintPrev;\n@@ -632,3 +627,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -638,4 +630,3 @@\n-            try {\n-                alive = Liveness.ALIVE;\n-                scanStat(tree.body);\n-                tree.completesNormally = alive != Liveness.DEAD;\n+            alive = Liveness.ALIVE;\n+            scanStat(tree.body);\n+            tree.completesNormally = alive != Liveness.DEAD;\n@@ -643,2 +634,2 @@\n-                if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n-                    log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n+            if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n+                log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n@@ -646,4 +637,1 @@\n-                clearPendingExits(true);\n-            } finally {\n-                lint = lintPrev;\n-            }\n+            clearPendingExits(true);\n@@ -664,9 +652,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -754,2 +734,1 @@\n-                    lint.logIfEnabled(l.tail.head.pos(),\n-                                LintWarnings.PossibleFallThroughIntoCase);\n+                    log.warning(l.tail.head.pos(), LintWarnings.PossibleFallThroughIntoCase);\n@@ -1262,1 +1241,1 @@\n-                    lint.logIfEnabled(TreeInfo.diagEndPos(tree.finalizer),\n+                    log.warning(TreeInfo.diagEndPos(tree.finalizer),\n@@ -1483,1 +1462,0 @@\n-            Lint lintPrev = lint;\n@@ -1491,1 +1469,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -1540,1 +1517,0 @@\n-                lint = lintPrev;\n@@ -1549,3 +1525,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -1584,1 +1557,0 @@\n-                lint = lintPrev;\n@@ -1589,9 +1561,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -2429,7 +2393,4 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try {\n-                JCClassDecl classDefPrev = classDef;\n-                int firstadrPrev = firstadr;\n-                int nextadrPrev = nextadr;\n-                ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n+            JCClassDecl classDefPrev = classDef;\n+            int firstadrPrev = firstadr;\n+            int nextadrPrev = nextadr;\n+            ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n@@ -2437,15 +2398,14 @@\n-                pendingExits = new ListBuffer<>();\n-                if (tree.name != names.empty) {\n-                    firstadr = nextadr;\n-                }\n-                classDef = tree;\n-                try {\n-                    \/\/ define all the static fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) != 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+            pendingExits = new ListBuffer<>();\n+            if (tree.name != names.empty) {\n+                firstadr = nextadr;\n+            }\n+            classDef = tree;\n+            try {\n+                \/\/ define all the static fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) != 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2455,0 +2415,1 @@\n+                }\n@@ -2456,5 +2417,5 @@\n-                    \/\/ process all the static initializers\n-                    forEachInitializer(tree, true, def -> {\n-                        scan(def);\n-                        clearPendingExits(false);\n-                    });\n+                \/\/ process all the static initializers\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    clearPendingExits(false);\n+                });\n@@ -2462,7 +2423,6 @@\n-                    \/\/ verify all static final fields got initialized\n-                    for (int i = firstadr; i < nextadr; i++) {\n-                        JCVariableDecl vardecl = vardecls[i];\n-                        VarSymbol var = vardecl.sym;\n-                        if (var.owner == classDef.sym && var.isStatic()) {\n-                            checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n-                        }\n+                \/\/ verify all static final fields got initialized\n+                for (int i = firstadr; i < nextadr; i++) {\n+                    JCVariableDecl vardecl = vardecls[i];\n+                    VarSymbol var = vardecl.sym;\n+                    if (var.owner == classDef.sym && var.isStatic()) {\n+                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2470,0 +2430,1 @@\n+                }\n@@ -2471,9 +2432,8 @@\n-                    \/\/ define all the instance fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) == 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+                \/\/ define all the instance fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) == 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2483,0 +2443,1 @@\n+                }\n@@ -2484,5 +2445,4 @@\n-                    \/\/ process all the methods\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(METHODDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the methods\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(METHODDEF)) {\n+                        scan(l.head);\n@@ -2490,0 +2450,1 @@\n+                }\n@@ -2491,5 +2452,4 @@\n-                    \/\/ process all the nested classes\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(CLASSDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the nested classes\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(CLASSDEF)) {\n+                        scan(l.head);\n@@ -2497,5 +2457,0 @@\n-                } finally {\n-                    pendingExits = pendingExitsPrev;\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    classDef = classDefPrev;\n@@ -2504,1 +2459,4 @@\n-                lint = lintPrev;\n+                pendingExits = pendingExitsPrev;\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                classDef = classDefPrev;\n@@ -2519,2 +2477,9 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n+            final Bits initsPrev = new Bits(inits);\n+            final Bits uninitsPrev = new Bits(uninits);\n+            int nextadrPrev = nextadr;\n+            int firstadrPrev = firstadr;\n+            int returnadrPrev = returnadr;\n+\n+            Assert.check(pendingExits.isEmpty());\n+            boolean isConstructorPrev = isConstructor;\n+            boolean isCompactOrGeneratedRecordConstructorPrev = isCompactOrGeneratedRecordConstructor;\n@@ -2522,18 +2487,3 @@\n-                final Bits initsPrev = new Bits(inits);\n-                final Bits uninitsPrev = new Bits(uninits);\n-                int nextadrPrev = nextadr;\n-                int firstadrPrev = firstadr;\n-                int returnadrPrev = returnadr;\n-\n-                Assert.check(pendingExits.isEmpty());\n-                boolean isConstructorPrev = isConstructor;\n-                boolean isCompactOrGeneratedRecordConstructorPrev = isCompactOrGeneratedRecordConstructor;\n-                try {\n-                    isConstructor = TreeInfo.isConstructor(tree);\n-                    isCompactOrGeneratedRecordConstructor = isConstructor && ((tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n-                            (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD));\n-\n-                    \/\/ We only track field initialization inside constructors\n-                    if (!isConstructor) {\n-                        firstadr = nextadr;\n-                    }\n+                isConstructor = TreeInfo.isConstructor(tree);\n+                isCompactOrGeneratedRecordConstructor = isConstructor && ((tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+                         (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD));\n@@ -2541,15 +2491,19 @@\n-                    \/\/ Mark all method parameters as DA\n-                    for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n-                        JCVariableDecl def = l.head;\n-                        scan(def);\n-                        Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n-                        \/*  If we are executing the code from Gen, then there can be\n-                         *  synthetic or mandated variables, ignore them.\n-                         *\/\n-                        initParam(def);\n-                    }\n-                    if (isConstructor) {\n-                        Set<VarSymbol> unsetFields = findUninitStrictFields();\n-                        if (unsetFields != null && !unsetFields.isEmpty()) {\n-                            unsetFieldsInfo.addUnsetFieldsInfo(classDef.sym, tree.body, unsetFields);\n-                        }\n+                \/\/ We only track field initialization inside constructors\n+                if (!isConstructor) {\n+                    firstadr = nextadr;\n+                }\n+\n+                \/\/ Mark all method parameters as DA\n+                for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n+                    JCVariableDecl def = l.head;\n+                    scan(def);\n+                    Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n+                    \/*  If we are executing the code from Gen, then there can be\n+                     *  synthetic or mandated variables, ignore them.\n+                     *\/\n+                    initParam(def);\n+                }\n+                if (isConstructor) {\n+                    Set<VarSymbol> unsetFields = findUninitStrictFields();\n+                    if (unsetFields != null && !unsetFields.isEmpty()) {\n+                        unsetFieldsInfo.addUnsetFieldsInfo(classDef.sym, tree.body, unsetFields);\n@@ -2557,0 +2511,1 @@\n+                }\n@@ -2558,30 +2513,27 @@\n-                    \/\/ else we are in an instance initializer block;\n-                    \/\/ leave caught unchanged.\n-                    scan(tree.body);\n-\n-                    if (isConstructor) {\n-                        boolean isSynthesized = (tree.sym.flags() &\n-                                                 GENERATEDCONSTR) != 0;\n-                        for (int i = firstadr; i < nextadr; i++) {\n-                            JCVariableDecl vardecl = vardecls[i];\n-                            VarSymbol var = vardecl.sym;\n-                            if (var.owner == classDef.sym && !var.isStatic()) {\n-                                \/\/ choose the diagnostic position based on whether\n-                                \/\/ the ctor is default(synthesized) or not\n-                                if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n-                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n-                                            var, Errors.VarNotInitializedInDefaultConstructor(var));\n-                                } else if (isCompactOrGeneratedRecordConstructor) {\n-                                    boolean isInstanceRecordField = var.enclClass().isRecord() &&\n-                                            (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n-                                            var.owner.kind == TYP;\n-                                    if (isInstanceRecordField) {\n-                                        boolean notInitialized = !inits.isMember(var.adr);\n-                                        if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n-                                        \/*  this way we indicate Lower that it should generate an initialization for this field\n-                                         *  in the compact constructor\n-                                         *\/\n-                                            var.flags_field |= UNINITIALIZED_FIELD;\n-                                        } else {\n-                                            checkInit(TreeInfo.diagEndPos(tree.body), var);\n-                                        }\n+                \/\/ else we are in an instance initializer block;\n+                \/\/ leave caught unchanged.\n+                scan(tree.body);\n+\n+                if (isConstructor) {\n+                    boolean isSynthesized = (tree.sym.flags() &\n+                                             GENERATEDCONSTR) != 0;\n+                    for (int i = firstadr; i < nextadr; i++) {\n+                        JCVariableDecl vardecl = vardecls[i];\n+                        VarSymbol var = vardecl.sym;\n+                        if (var.owner == classDef.sym && !var.isStatic()) {\n+                            \/\/ choose the diagnostic position based on whether\n+                            \/\/ the ctor is default(synthesized) or not\n+                            if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n+                                checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n+                                        var, Errors.VarNotInitializedInDefaultConstructor(var));\n+                            } else if (isCompactOrGeneratedRecordConstructor) {\n+                                boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                        (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                        var.owner.kind == TYP;\n+                                if (isInstanceRecordField) {\n+                                    boolean notInitialized = !inits.isMember(var.adr);\n+                                    if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n+                                    \/*  this way we indicate Lower that it should generate an initialization for this field\n+                                     *  in the compact constructor\n+                                     *\/\n+                                        var.flags_field |= UNINITIALIZED_FIELD;\n@@ -2589,1 +2541,1 @@\n-                                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n+                                        checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2592,1 +2544,1 @@\n-                                    checkInit(TreeInfo.diagEndPos(tree.body), var);\n+                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2594,0 +2546,2 @@\n+                            } else {\n+                                checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2597,9 +2551,1 @@\n-                    clearPendingExits(true);\n-                } finally {\n-                    inits.assign(initsPrev);\n-                    uninits.assign(uninitsPrev);\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    returnadr = returnadrPrev;\n-                    isConstructor = isConstructorPrev;\n-                    isCompactOrGeneratedRecordConstructor = isCompactOrGeneratedRecordConstructorPrev;\n+                clearPendingExits(true);\n@@ -2608,1 +2554,7 @@\n-                lint = lintPrev;\n+                inits.assign(initsPrev);\n+                uninits.assign(uninitsPrev);\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                returnadr = returnadrPrev;\n+                isConstructor = isConstructorPrev;\n+                isCompactOrGeneratedRecordConstructor = isCompactOrGeneratedRecordConstructorPrev;\n@@ -2647,12 +2599,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try{\n-                boolean track = trackable(tree.sym);\n-                if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n-                    newVar(tree);\n-                }\n-                if (tree.init != null) {\n-                    scanExpr(tree.init);\n-                    if (track) {\n-                        letInit(tree.pos(), tree.sym);\n-                    }\n+            boolean track = trackable(tree.sym);\n+            if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n+                newVar(tree);\n+            }\n+            if (tree.init != null) {\n+                scanExpr(tree.init);\n+                if (track) {\n+                    letInit(tree.pos(), tree.sym);\n@@ -2660,2 +2608,0 @@\n-            } finally {\n-                lint = lintPrev;\n@@ -2913,2 +2859,1 @@\n-            if (!resourceVarDecls.isEmpty() &&\n-                    lint.isEnabled(Lint.LintCategory.TRY)) {\n+            if (!resourceVarDecls.isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":143,"deletions":198,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -90,1 +89,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -197,10 +195,5 @@\n-        deferredLintHandler.push(tree);\n-        try {\n-            \/\/ Compute the method type\n-            m.type = signature(m, tree.typarams, tree.params,\n-                               tree.restype, tree.recvparam,\n-                               tree.thrown,\n-                               localEnv);\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n+        \/\/ Compute the method type\n+        m.type = signature(m, tree.typarams, tree.params,\n+                           tree.restype, tree.recvparam,\n+                           tree.thrown,\n+                           localEnv);\n@@ -230,1 +223,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m);\n@@ -233,1 +226,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m);\n@@ -237,1 +230,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m);\n@@ -266,11 +259,6 @@\n-        deferredLintHandler.push(tree);\n-        try {\n-            if (TreeInfo.isEnumInit(tree)) {\n-                attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n-            } else if (!tree.isImplicitlyTyped()) {\n-                attr.attribType(tree.vartype, localEnv);\n-                if (TreeInfo.isReceiverParam(tree))\n-                    checkReceiver(tree, localEnv);\n-            }\n-        } finally {\n-            deferredLintHandler.pop();\n+        if (TreeInfo.isEnumInit(tree)) {\n+            attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n+        } else if (!tree.isImplicitlyTyped()) {\n+            attr.attribType(tree.vartype, localEnv);\n+            if (TreeInfo.isReceiverParam(tree))\n+                checkReceiver(tree, localEnv);\n@@ -320,1 +308,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v);\n@@ -322,1 +310,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -112,2 +111,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n-    private final Lint lint;\n@@ -139,2 +136,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-        lint = Lint.instance(context);\n@@ -278,1 +273,0 @@\n-                deferredLintHandler.push(tree);\n@@ -286,1 +280,0 @@\n-                    deferredLintHandler.pop();\n@@ -355,2 +348,0 @@\n-            deferredLintHandler.pushImmediate(lint);\n-            Lint prevLint = chk.setLint(lint);\n@@ -380,7 +371,2 @@\n-                    deferredLintHandler.push(decl);\n-                    try {\n-                        \/\/check @Deprecated:\n-                        markDeprecated(decl.sym, decl.mods.annotations, env);\n-                    } finally {\n-                        deferredLintHandler.pop();\n-                    }\n+                    \/\/check for @Deprecated annotations\n+                    markDeprecated(decl.sym, decl.mods.annotations, env);\n@@ -388,1 +374,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle);\n@@ -392,2 +378,0 @@\n-                chk.setLint(prevLint);\n-                deferredLintHandler.pop();\n@@ -426,1 +410,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge);\n@@ -918,1 +902,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym);\n@@ -920,1 +904,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym);\n@@ -935,1 +919,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym);\n@@ -939,1 +923,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -149,3 +148,0 @@\n-    \/** The root Lint config. *\/\n-    Lint lint;\n-\n@@ -315,2 +311,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -868,2 +862,1 @@\n-                        lint.logIfEnabled(\n-                                    LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n+                        log.warning(LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n@@ -1636,1 +1629,1 @@\n-            lint.logIfEnabled(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            log.warning(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n@@ -2102,1 +2095,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFound(container, name));\n+                    log.warning(LintWarnings.AnnotationMethodNotFound(container, name));\n@@ -2104,1 +2097,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFoundReason(container,\n+                    log.warning(LintWarnings.AnnotationMethodNotFoundReason(container,\n@@ -2981,1 +2974,1 @@\n-        lint.logIfEnabled(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        log.warning(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -261,0 +261,4 @@\n+    \/** The Lint mapper.\n+     *\/\n+    protected LintMapper lintMapper;\n+\n@@ -387,0 +391,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -578,0 +583,1 @@\n+        log.reportOutstandingWarnings();\n@@ -628,0 +634,1 @@\n+        lintMapper.startParsingFile(filename);\n@@ -647,0 +654,1 @@\n+        lintMapper.finishParsingFile(tree);\n@@ -1853,0 +1861,1 @@\n+        log.reportOutstandingWarnings();\n@@ -1926,0 +1935,1 @@\n+        lintMapper = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-    \/** Handler for deferred diagnostics. *\/\n-    protected final DeferredLintHandler deferredLintHandler;\n@@ -197,1 +195,0 @@\n-        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -225,1 +222,0 @@\n-        this.deferredLintHandler = parser.deferredLintHandler;\n@@ -606,2 +602,1 @@\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n+     *     dangling comments are reported to the log as warnings.\n@@ -668,6 +663,1 @@\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n+            list.forEach(c -> reportDanglingDocComment(tree, c));\n@@ -678,1 +668,1 @@\n-     * Reports an individual dangling comment using the {@link #deferredLintHandler}.\n+     * Reports an individual dangling comment as a warning to the log.\n@@ -684,1 +674,1 @@\n-    void reportDanglingDocComment(Comment c) {\n+    void reportDanglingDocComment(JCTree tree, Comment c) {\n@@ -686,8 +676,3 @@\n-        if (pos != null) {\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+        if (pos != null && !shebang(c, pos)) {\n+            pos = pos.withLintPosition(tree.getStartPosition());\n+            S.lintWarning(pos, LintWarnings.DanglingDocComment);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-    private final Lint lint;\n@@ -209,1 +208,0 @@\n-        lint = Lint.instance(context);\n@@ -629,1 +627,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n+                       boolean allowModules, ProcessingEnvironment env) {\n@@ -650,2 +648,1 @@\n-                        add(importStringToPattern(allowModules, annotationPattern,\n-                                                  processor, log, lint));\n+                        add(importStringToPattern(allowModules, annotationPattern, processor, log));\n@@ -653,1 +650,1 @@\n-                        lint.logIfEnabled(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -666,1 +663,1 @@\n-                    lint.logIfEnabled(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -674,2 +671,1 @@\n-                            lint.logIfEnabled(LintWarnings.ProcDuplicateOptionName(optionName,\n-                                                                         p.getClass().getName()));\n+                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName, p.getClass().getName()));\n@@ -762,2 +758,1 @@\n-                                                           JavacProcessingEnvironment.this,\n-                                                           lint);\n+                                                           JavacProcessingEnvironment.this);\n@@ -891,1 +886,1 @@\n-        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n+        if (unmatchedAnnotations.size() > 0) {\n@@ -1652,1 +1647,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {\n@@ -1665,1 +1660,1 @@\n-                return warnAndNoMatches(s, p, log, lint);\n+                return warnAndNoMatches(s, p, log);\n@@ -1674,1 +1669,1 @@\n-            return warnAndNoMatches(s, p, log, lint);\n+            return warnAndNoMatches(s, p, log);\n@@ -1678,2 +1673,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n-        lint.logIfEnabled(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log) {\n+        log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1603,0 +1603,1 @@\n+# flags: default-enabled\n@@ -1927,1 +1928,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1933,1 +1934,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1939,1 +1940,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1950,1 +1951,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1962,1 +1963,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1968,1 +1969,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2205,0 +2206,1 @@\n+# flags: default-enabled\n@@ -2210,0 +2212,1 @@\n+# flags: default-enabled\n@@ -2235,0 +2238,1 @@\n+# flags: default-enabled\n@@ -2240,0 +2244,1 @@\n+# flags: default-enabled\n@@ -2252,0 +2257,1 @@\n+# flags: default-enabled\n@@ -2376,1 +2382,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2382,1 +2388,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2392,1 +2398,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2400,1 +2406,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2406,1 +2412,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2805,1 +2811,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3205,1 +3211,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3212,1 +3218,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3316,1 +3322,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3322,1 +3328,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3893,0 +3899,1 @@\n+# flags: default-enabled\n@@ -3909,0 +3916,1 @@\n+# flags: default-enabled\n@@ -4311,1 +4319,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jtreg.SkippedException;\n@@ -352,0 +353,1 @@\n+        checkCompatibleFlags();\n@@ -790,0 +792,8 @@\n+    private void checkCompatibleFlags() {\n+        for (String flag : Utils.getTestJavaOpts()) {\n+            if (flag.contains(\"-agentpath\")) {\n+                throw new SkippedException(\"Can't run test with agent.\");\n+            }\n+        }\n+    }\n+\n@@ -796,0 +806,3 @@\n+            if (flag.contains(\"agentpath\")) {\n+                throw new SkippedException(\"Can't run test with -javaagent\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.test.lib.Platform;\n@@ -63,0 +64,3 @@\n+        \/\/ On s390x, generated code is ~6x larger in fastdebug and ~1.4x in release builds vs. other archs,\n+        \/\/ hence we require slightly more minimum space.\n+        int minInitialSize = 2000 + (Platform.isS390x() ? 800 : 0);\n@@ -64,1 +68,1 @@\n-            int initialCodeCacheSizeInKb = 2000 + rand.nextInt(400);\n+            int initialCodeCacheSizeInKb = minInitialSize + rand.nextInt(400);\n","filename":"test\/hotspot\/jtreg\/compiler\/startup\/StartupOutput.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -426,1 +426,6 @@\n-        return \"\" + WB.isCDSIncluded();\n+        boolean noJvmtiAdded = allFlags()\n+                .filter(s -> s.startsWith(\"-agentpath\"))\n+                .findAny()\n+                .isEmpty();\n+\n+        return \"\" + (noJvmtiAdded && WB.isCDSIncluded());\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}