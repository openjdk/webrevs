{"files":[{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -369,1 +369,1 @@\n-    ( CONFIGURE_PRINT_ADDITIONAL_HELP=true . $generated_script PRINTF=printf )\n+    ( CONFIGURE_PRINT_ADDITIONAL_HELP=true . $generated_script PRINTF=printf ECHO=echo )\n","filename":"make\/autoconf\/configure","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-                        String transPattern = translateDateFormatLetters(calendarType, pattern, this::convertDateTimePatternLetter);\n+                        String transPattern = translateDateFormatLetters(calendarType, key, pattern, this::convertDateTimePatternLetter);\n@@ -548,1 +548,1 @@\n-                        sdfPatterns.add(i, translateDateFormatLetters(calendarType, transPattern, this::convertSDFLetter));\n+                        sdfPatterns.add(i, translateDateFormatLetters(calendarType, key, transPattern, this::convertSDFLetter));\n@@ -571,1 +571,1 @@\n-    private String translateDateFormatLetters(CalendarType calendarType, String cldrFormat, ConvertDateTimeLetters converter) {\n+    private String translateDateFormatLetters(CalendarType calendarType, String patternKey, String cldrFormat, ConvertDateTimeLetters converter) {\n@@ -590,1 +590,1 @@\n-                            converter.convert(calendarType, lastLetter, count, jrePattern);\n+                            converter.convert(calendarType, patternKey, lastLetter, count, jrePattern);\n@@ -600,1 +600,1 @@\n-                        converter.convert(calendarType, lastLetter, count, jrePattern);\n+                        converter.convert(calendarType, patternKey, lastLetter, count, jrePattern);\n@@ -617,1 +617,1 @@\n-                    converter.convert(calendarType, lastLetter, count, jrePattern);\n+                    converter.convert(calendarType, patternKey, lastLetter, count, jrePattern);\n@@ -630,1 +630,1 @@\n-            converter.convert(calendarType, lastLetter, count, jrePattern);\n+            converter.convert(calendarType, patternKey, lastLetter, count, jrePattern);\n@@ -640,1 +640,1 @@\n-            converter.convert(calendarType, lastLetter, count, jrePattern);\n+            converter.convert(calendarType, patternKey, lastLetter, count, jrePattern);\n@@ -664,1 +664,1 @@\n-    private void convertDateTimePatternLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {\n+    private void convertDateTimePatternLetter(CalendarType calendarType, String patternKey, char cldrLetter, int count, StringBuilder sb) {\n@@ -686,1 +686,1 @@\n-    private void convertSDFLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {\n+    private void convertSDFLetter(CalendarType calendarType, String patternKey, char cldrLetter, int count, StringBuilder sb) {\n@@ -725,0 +725,11 @@\n+            case 'y':\n+                \/\/ If the style is FULL\/LONG for a Japanese Calendar, make the\n+                \/\/ count == 4 for Gan-nen\n+                if (calendarType == CalendarType.JAPANESE &&\n+                        (patternKey.contains(\"full-\") ||\n+                         patternKey.contains(\"long-\"))) {\n+                    count = 4;\n+                }\n+                appendN(cldrLetter, count, sb);\n+                break;\n+\n@@ -770,0 +781,1 @@\n+                        e.getKey(),\n@@ -778,1 +790,1 @@\n-        void convert(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb);\n+        void convert(CalendarType calendarType, String patternKey, char cldrLetter, int count, StringBuilder sb);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/Bundle.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-      exelauncher.c\n+      exelauncher.c libFDLeaker.c exeFDLeakTester.c\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1853,1 +1853,1 @@\n-    __ safepoint_poll(*code_stub, true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,5 +46,5 @@\n-define_pd_global(intx, InitialCodeCacheSize,         160*K);\n-define_pd_global(intx, ReservedCodeCacheSize,        32*M );\n-define_pd_global(intx, NonProfiledCodeHeapSize,      13*M );\n-define_pd_global(intx, ProfiledCodeHeapSize,         14*M );\n-define_pd_global(intx, NonNMethodCodeHeapSize,       5*M  );\n+define_pd_global(size_t, InitialCodeCacheSize,       160*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,      32*M );\n+define_pd_global(size_t, NonProfiledCodeHeapSize,    13*M );\n+define_pd_global(size_t, ProfiledCodeHeapSize,       14*M );\n+define_pd_global(size_t, NonNMethodCodeHeapSize,     5*M  );\n@@ -52,3 +52,3 @@\n-define_pd_global(intx, CodeCacheExpansionSize,       32*K );\n-define_pd_global(uintx, CodeCacheMinBlockLength,     1);\n-define_pd_global(uintx, CodeCacheMinimumUseSpace,    400*K);\n+define_pd_global(size_t, CodeCacheExpansionSize,     32*K );\n+define_pd_global(size_t, CodeCacheMinBlockLength,    1);\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,   400*K);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_globals_aarch64.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-define_pd_global(intx, InitialCodeCacheSize,         2496*K); \/\/ Integral multiple of CodeCacheExpansionSize\n-define_pd_global(intx, CodeCacheExpansionSize,       64*K);\n+define_pd_global(size_t, InitialCodeCacheSize,       2496*K); \/\/ Integral multiple of CodeCacheExpansionSize\n+define_pd_global(size_t, CodeCacheExpansionSize,     64*K);\n@@ -72,6 +72,6 @@\n-define_pd_global(intx, ReservedCodeCacheSize,        48*M);\n-define_pd_global(intx, NonProfiledCodeHeapSize,      21*M);\n-define_pd_global(intx, ProfiledCodeHeapSize,         22*M);\n-define_pd_global(intx, NonNMethodCodeHeapSize,       5*M );\n-define_pd_global(uintx, CodeCacheMinBlockLength,     6);\n-define_pd_global(uintx, CodeCacheMinimumUseSpace,    400*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,      48*M);\n+define_pd_global(size_t, NonProfiledCodeHeapSize,    21*M);\n+define_pd_global(size_t, ProfiledCodeHeapSize,       22*M);\n+define_pd_global(size_t, NonNMethodCodeHeapSize,     5*M );\n+define_pd_global(size_t, CodeCacheMinBlockLength,    6);\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,   400*K);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_globals_aarch64.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -93,1 +93,3 @@\n-  NativeGeneralJump* jump = nativeGeneralJump_at(method_holder->next_instruction_address());\n+  NativeJump* jump = MacroAssembler::codestub_branch_needs_far_jump()\n+                         ? nativeGeneralJump_at(method_holder->next_instruction_address())\n+                         : nativeJump_at(method_holder->next_instruction_address());\n@@ -99,1 +101,1 @@\n-  NativeGeneralJump::insert_unconditional(method_holder->next_instruction_address(), entry);\n+  MacroAssembler::pd_patch_instruction(method_holder->next_instruction_address(), entry);\n","filename":"src\/hotspot\/cpu\/aarch64\/compiledIC_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/, tmp1);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, false \/* in_nmethod *\/, tmp1);\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64);\n+define_pd_global(size_t, CodeCacheSegmentSize,   64);\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -663,1 +663,1 @@\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -561,7 +561,2 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp) {\n-  if (acquire) {\n-    lea(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-    ldar(tmp, tmp);\n-  } else {\n-    ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-  }\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp) {\n+  ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n@@ -997,2 +992,6 @@\n-  movptr(rscratch1, 0);\n-  br(rscratch1);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n@@ -1002,0 +1001,4 @@\n+  if (!codestub_branch_needs_far_jump()) {\n+    \/\/ isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp = rscratch1);\n+  void safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp = rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -389,12 +389,0 @@\n-void NativeGeneralJump::insert_unconditional(address code_pos, address entry) {\n-  NativeGeneralJump* n_jump = (NativeGeneralJump*)code_pos;\n-\n-  CodeBuffer cb(code_pos, instruction_size);\n-  MacroAssembler a(&cb);\n-\n-  a.movptr(rscratch1, (uintptr_t)entry);\n-  a.br(rscratch1);\n-\n-  ICache::invalidate_range(code_pos, instruction_size);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2108, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Red Hat Inc. All rights reserved.\n@@ -386,1 +386,0 @@\n-  static void insert_unconditional(address code_pos, address entry);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2159,1 +2159,1 @@\n-    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 0)                                          \\\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubDeclarations_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -11806,0 +11806,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for aarch64\n+  }\n+\n@@ -12059,0 +12063,3 @@\n+    case preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1027,1 +1027,1 @@\n-  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1074,1 +1074,1 @@\n-  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1464,1 +1464,1 @@\n-    __ safepoint_poll(L, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(L, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1617,1 +1617,1 @@\n-  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-define_pd_global(uintx, CodeCacheMinBlockLength,     1);\n+define_pd_global(size_t, CodeCacheMinBlockLength,    1);\n","filename":"src\/hotspot\/cpu\/arm\/c1_globals_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-define_pd_global(uintx, CodeCacheMinBlockLength,     6);\n+define_pd_global(size_t, CodeCacheMinBlockLength,    6);\n","filename":"src\/hotspot\/cpu\/arm\/c2_globals_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,3 +39,3 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,     64);\n-define_pd_global(intx,  CodeEntryAlignment,       16);\n-define_pd_global(intx,  OptoLoopAlignment,        16);\n+define_pd_global(size_t, CodeCacheSegmentSize,     64);\n+define_pd_global(intx,   CodeEntryAlignment,       16);\n+define_pd_global(intx,   OptoLoopAlignment,        16);\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 0)                                          \\\n+\n+\n","filename":"src\/hotspot\/cpu\/arm\/stubDeclarations_arm.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3129,0 +3129,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for arm\n+  }\n+\n@@ -3204,0 +3208,3 @@\n+    case preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,7 +47,7 @@\n-define_pd_global(uintx,    ReservedCodeCacheSize,        32*M);\n-define_pd_global(uintx,    NonProfiledCodeHeapSize,      13*M );\n-define_pd_global(uintx,    ProfiledCodeHeapSize,         14*M );\n-define_pd_global(uintx,    NonNMethodCodeHeapSize,       5*M );\n-define_pd_global(uintx,    CodeCacheExpansionSize,       32*K);\n-define_pd_global(uintx,    CodeCacheMinBlockLength,      1);\n-define_pd_global(uintx,    CodeCacheMinimumUseSpace,     400*K);\n+define_pd_global(size_t,   ReservedCodeCacheSize,        32*M);\n+define_pd_global(size_t,   NonProfiledCodeHeapSize,      13*M );\n+define_pd_global(size_t,   ProfiledCodeHeapSize,         14*M );\n+define_pd_global(size_t,   NonNMethodCodeHeapSize,       5*M );\n+define_pd_global(size_t,   CodeCacheExpansionSize,       32*K);\n+define_pd_global(size_t,   CodeCacheMinBlockLength,      1);\n+define_pd_global(size_t,   CodeCacheMinimumUseSpace,     400*K);\n@@ -57,1 +57,1 @@\n-define_pd_global(uintx,    InitialCodeCacheSize,         160*K);\n+define_pd_global(size_t,   InitialCodeCacheSize,         160*K);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_globals_ppc.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,6 +81,6 @@\n-define_pd_global(uintx,    InitialCodeCacheSize,         2048*K); \/\/ Integral multiple of CodeCacheExpansionSize\n-define_pd_global(uintx,    ReservedCodeCacheSize,        48*M);\n-define_pd_global(uintx,    NonProfiledCodeHeapSize,      21*M);\n-define_pd_global(uintx,    ProfiledCodeHeapSize,         22*M);\n-define_pd_global(uintx,    NonNMethodCodeHeapSize,       5*M  );\n-define_pd_global(uintx,    CodeCacheExpansionSize,       64*K);\n+define_pd_global(size_t,   InitialCodeCacheSize,         2048*K); \/\/ Integral multiple of CodeCacheExpansionSize\n+define_pd_global(size_t,   ReservedCodeCacheSize,        48*M);\n+define_pd_global(size_t,   NonProfiledCodeHeapSize,      21*M);\n+define_pd_global(size_t,   ProfiledCodeHeapSize,         22*M);\n+define_pd_global(size_t,   NonNMethodCodeHeapSize,       5*M  );\n+define_pd_global(size_t,   CodeCacheExpansionSize,       64*K);\n@@ -90,2 +90,2 @@\n-define_pd_global(uintx,    CodeCacheMinBlockLength,      6);\n-define_pd_global(uintx,    CodeCacheMinimumUseSpace,     400*K);\n+define_pd_global(size_t,   CodeCacheMinBlockLength,      6);\n+define_pd_global(size_t,   CodeCacheMinimumUseSpace,     400*K);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_globals_ppc.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-    } else if (vm_reg->is_VectorSRegister()) {\n+    } else if (vm_reg->is_VectorRegister()) {\n@@ -338,1 +338,1 @@\n-      VectorSRegister vs_reg = vm_reg->as_VectorSRegister();\n+      VectorSRegister vs_reg = (vm_reg->as_VectorRegister()).to_vsr();\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,4 +62,4 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,  128);\n-define_pd_global(intx,  CodeEntryAlignment,    64);\n-define_pd_global(intx,  OptoLoopAlignment,     16);\n-define_pd_global(intx,  InlineSmallCode,       1500);\n+define_pd_global(size_t, CodeCacheSegmentSize,  128);\n+define_pd_global(intx,   CodeEntryAlignment,    64);\n+define_pd_global(intx,   OptoLoopAlignment,     16);\n+define_pd_global(intx,   InlineSmallCode,       1500);\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-\/\/ Vector-Scalar Registers\n+\/\/ Vector Registers\n@@ -260,321 +260,160 @@\n-  \/\/ 1st 32 VSRs are aliases for the FPRs which are already defined above.\n-  reg_def VSR0   (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_H (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_J (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-  reg_def VSR0_K (SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());\n-\n-  reg_def VSR1   (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-  reg_def VSR1_H (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-  reg_def VSR1_J (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-  reg_def VSR1_K (SOC, SOC, Op_RegF, 1, VMRegImpl::Bad());\n-\n-  reg_def VSR2   (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-  reg_def VSR2_H (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-  reg_def VSR2_J (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-  reg_def VSR2_K (SOC, SOC, Op_RegF, 2, VMRegImpl::Bad());\n-\n-  reg_def VSR3   (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-  reg_def VSR3_H (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-  reg_def VSR3_J (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-  reg_def VSR3_K (SOC, SOC, Op_RegF, 3, VMRegImpl::Bad());\n-\n-  reg_def VSR4   (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-  reg_def VSR4_H (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-  reg_def VSR4_J (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-  reg_def VSR4_K (SOC, SOC, Op_RegF, 4, VMRegImpl::Bad());\n-\n-  reg_def VSR5   (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-  reg_def VSR5_H (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-  reg_def VSR5_J (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-  reg_def VSR5_K (SOC, SOC, Op_RegF, 5, VMRegImpl::Bad());\n-\n-  reg_def VSR6   (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-  reg_def VSR6_H (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-  reg_def VSR6_J (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-  reg_def VSR6_K (SOC, SOC, Op_RegF, 6, VMRegImpl::Bad());\n-\n-  reg_def VSR7   (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-  reg_def VSR7_H (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-  reg_def VSR7_J (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-  reg_def VSR7_K (SOC, SOC, Op_RegF, 7, VMRegImpl::Bad());\n-\n-  reg_def VSR8   (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-  reg_def VSR8_H (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-  reg_def VSR8_J (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-  reg_def VSR8_K (SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());\n-\n-  reg_def VSR9   (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-  reg_def VSR9_H (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-  reg_def VSR9_J (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-  reg_def VSR9_K (SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());\n-\n-  reg_def VSR10  (SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-  reg_def VSR10_H(SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-  reg_def VSR10_J(SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-  reg_def VSR10_K(SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());\n-\n-  reg_def VSR11  (SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-  reg_def VSR11_H(SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-  reg_def VSR11_J(SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-  reg_def VSR11_K(SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());\n-\n-  reg_def VSR12  (SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-  reg_def VSR12_H(SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-  reg_def VSR12_J(SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-  reg_def VSR12_K(SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());\n-\n-  reg_def VSR13  (SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-  reg_def VSR13_H(SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-  reg_def VSR13_J(SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-  reg_def VSR13_K(SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());\n-\n-  reg_def VSR14  (SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-  reg_def VSR14_H(SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-  reg_def VSR14_J(SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-  reg_def VSR14_K(SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());\n-\n-  reg_def VSR15  (SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-  reg_def VSR15_H(SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-  reg_def VSR15_J(SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-  reg_def VSR15_K(SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());\n-\n-  reg_def VSR16  (SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-  reg_def VSR16_H(SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-  reg_def VSR16_J(SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-  reg_def VSR16_K(SOC, SOC, Op_RegF, 16, VMRegImpl::Bad());\n-\n-  reg_def VSR17  (SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-  reg_def VSR17_H(SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-  reg_def VSR17_J(SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-  reg_def VSR17_K(SOC, SOC, Op_RegF, 17, VMRegImpl::Bad());\n-\n-  reg_def VSR18  (SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-  reg_def VSR18_H(SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-  reg_def VSR18_J(SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-  reg_def VSR18_K(SOC, SOC, Op_RegF, 18, VMRegImpl::Bad());\n-\n-  reg_def VSR19  (SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-  reg_def VSR19_H(SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-  reg_def VSR19_J(SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-  reg_def VSR19_K(SOC, SOC, Op_RegF, 19, VMRegImpl::Bad());\n-\n-  reg_def VSR20  (SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-  reg_def VSR20_H(SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-  reg_def VSR20_J(SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-  reg_def VSR20_K(SOC, SOC, Op_RegF, 20, VMRegImpl::Bad());\n-\n-  reg_def VSR21  (SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-  reg_def VSR21_H(SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-  reg_def VSR21_J(SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-  reg_def VSR21_K(SOC, SOC, Op_RegF, 21, VMRegImpl::Bad());\n-\n-  reg_def VSR22  (SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-  reg_def VSR22_H(SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-  reg_def VSR22_J(SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-  reg_def VSR22_K(SOC, SOC, Op_RegF, 22, VMRegImpl::Bad());\n-\n-  reg_def VSR23  (SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-  reg_def VSR23_H(SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-  reg_def VSR23_J(SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-  reg_def VSR23_K(SOC, SOC, Op_RegF, 23, VMRegImpl::Bad());\n-\n-  reg_def VSR24  (SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-  reg_def VSR24_H(SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-  reg_def VSR24_J(SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-  reg_def VSR24_K(SOC, SOC, Op_RegF, 24, VMRegImpl::Bad());\n-\n-  reg_def VSR25  (SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-  reg_def VSR25_H(SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-  reg_def VSR25_J(SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-  reg_def VSR25_K(SOC, SOC, Op_RegF, 25, VMRegImpl::Bad());\n-\n-  reg_def VSR26  (SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-  reg_def VSR26_H(SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-  reg_def VSR26_J(SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-  reg_def VSR26_K(SOC, SOC, Op_RegF, 26, VMRegImpl::Bad());\n-\n-  reg_def VSR27  (SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-  reg_def VSR27_H(SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-  reg_def VSR27_J(SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-  reg_def VSR27_K(SOC, SOC, Op_RegF, 27, VMRegImpl::Bad());\n-\n-  reg_def VSR28  (SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-  reg_def VSR28_H(SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-  reg_def VSR28_J(SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-  reg_def VSR28_K(SOC, SOC, Op_RegF, 28, VMRegImpl::Bad());\n-\n-  reg_def VSR29  (SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-  reg_def VSR29_H(SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-  reg_def VSR29_J(SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-  reg_def VSR29_K(SOC, SOC, Op_RegF, 29, VMRegImpl::Bad());\n-\n-  reg_def VSR30  (SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-  reg_def VSR30_H(SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-  reg_def VSR30_J(SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-  reg_def VSR30_K(SOC, SOC, Op_RegF, 30, VMRegImpl::Bad());\n-\n-  reg_def VSR31  (SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-  reg_def VSR31_H(SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-  reg_def VSR31_J(SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-  reg_def VSR31_K(SOC, SOC, Op_RegF, 31, VMRegImpl::Bad());\n-\n-  \/\/ 2nd 32 VSRs are aliases for the VRs which are only defined here.\n-  reg_def VSR32  (SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()         );\n-  reg_def VSR32_H(SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()->next() );\n-  reg_def VSR32_J(SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()->next(2));\n-  reg_def VSR32_K(SOC, SOC, Op_RegF, 32, VSR32->as_VMReg()->next(3));\n-\n-  reg_def VSR33  (SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()         );\n-  reg_def VSR33_H(SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()->next() );\n-  reg_def VSR33_J(SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()->next(2));\n-  reg_def VSR33_K(SOC, SOC, Op_RegF, 33, VSR33->as_VMReg()->next(3));\n-\n-  reg_def VSR34  (SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()         );\n-  reg_def VSR34_H(SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()->next() );\n-  reg_def VSR34_J(SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()->next(2));\n-  reg_def VSR34_K(SOC, SOC, Op_RegF, 34, VSR34->as_VMReg()->next(3));\n-\n-  reg_def VSR35  (SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()         );\n-  reg_def VSR35_H(SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()->next() );\n-  reg_def VSR35_J(SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()->next(2));\n-  reg_def VSR35_K(SOC, SOC, Op_RegF, 35, VSR35->as_VMReg()->next(3));\n-\n-  reg_def VSR36  (SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()         );\n-  reg_def VSR36_H(SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()->next() );\n-  reg_def VSR36_J(SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()->next(2));\n-  reg_def VSR36_K(SOC, SOC, Op_RegF, 36, VSR36->as_VMReg()->next(3));\n-\n-  reg_def VSR37  (SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()         );\n-  reg_def VSR37_H(SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()->next() );\n-  reg_def VSR37_J(SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()->next(2));\n-  reg_def VSR37_K(SOC, SOC, Op_RegF, 37, VSR37->as_VMReg()->next(3));\n-\n-  reg_def VSR38  (SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()         );\n-  reg_def VSR38_H(SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()->next() );\n-  reg_def VSR38_J(SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()->next(2));\n-  reg_def VSR38_K(SOC, SOC, Op_RegF, 38, VSR38->as_VMReg()->next(3));\n-\n-  reg_def VSR39  (SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()         );\n-  reg_def VSR39_H(SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()->next() );\n-  reg_def VSR39_J(SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()->next(2));\n-  reg_def VSR39_K(SOC, SOC, Op_RegF, 39, VSR39->as_VMReg()->next(3));\n-\n-  reg_def VSR40  (SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()         );\n-  reg_def VSR40_H(SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()->next() );\n-  reg_def VSR40_J(SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()->next(2));\n-  reg_def VSR40_K(SOC, SOC, Op_RegF, 40, VSR40->as_VMReg()->next(3));\n-\n-  reg_def VSR41  (SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()         );\n-  reg_def VSR41_H(SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()->next() );\n-  reg_def VSR41_J(SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()->next(2));\n-  reg_def VSR41_K(SOC, SOC, Op_RegF, 41, VSR41->as_VMReg()->next(3));\n-\n-  reg_def VSR42  (SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()         );\n-  reg_def VSR42_H(SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()->next() );\n-  reg_def VSR42_J(SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()->next(2));\n-  reg_def VSR42_K(SOC, SOC, Op_RegF, 42, VSR42->as_VMReg()->next(3));\n-\n-  reg_def VSR43  (SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()         );\n-  reg_def VSR43_H(SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()->next() );\n-  reg_def VSR43_J(SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()->next(2));\n-  reg_def VSR43_K(SOC, SOC, Op_RegF, 43, VSR43->as_VMReg()->next(3));\n-\n-  reg_def VSR44  (SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()         );\n-  reg_def VSR44_H(SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()->next() );\n-  reg_def VSR44_J(SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()->next(2));\n-  reg_def VSR44_K(SOC, SOC, Op_RegF, 44, VSR44->as_VMReg()->next(3));\n-\n-  reg_def VSR45  (SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()         );\n-  reg_def VSR45_H(SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()->next() );\n-  reg_def VSR45_J(SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()->next(2));\n-  reg_def VSR45_K(SOC, SOC, Op_RegF, 45, VSR45->as_VMReg()->next(3));\n-\n-  reg_def VSR46  (SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()         );\n-  reg_def VSR46_H(SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()->next() );\n-  reg_def VSR46_J(SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()->next(2));\n-  reg_def VSR46_K(SOC, SOC, Op_RegF, 46, VSR46->as_VMReg()->next(3));\n-\n-  reg_def VSR47  (SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()         );\n-  reg_def VSR47_H(SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()->next() );\n-  reg_def VSR47_J(SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()->next(2));\n-  reg_def VSR47_K(SOC, SOC, Op_RegF, 47, VSR47->as_VMReg()->next(3));\n-\n-  reg_def VSR48  (SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()         );\n-  reg_def VSR48_H(SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()->next() );\n-  reg_def VSR48_J(SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()->next(2));\n-  reg_def VSR48_K(SOC, SOC, Op_RegF, 48, VSR48->as_VMReg()->next(3));\n-\n-  reg_def VSR49  (SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()         );\n-  reg_def VSR49_H(SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()->next() );\n-  reg_def VSR49_J(SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()->next(2));\n-  reg_def VSR49_K(SOC, SOC, Op_RegF, 49, VSR49->as_VMReg()->next(3));\n-\n-  reg_def VSR50  (SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()         );\n-  reg_def VSR50_H(SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()->next() );\n-  reg_def VSR50_J(SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()->next(2));\n-  reg_def VSR50_K(SOC, SOC, Op_RegF, 50, VSR50->as_VMReg()->next(3));\n-\n-  reg_def VSR51  (SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()         );\n-  reg_def VSR51_H(SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()->next() );\n-  reg_def VSR51_J(SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()->next(2));\n-  reg_def VSR51_K(SOC, SOC, Op_RegF, 51, VSR51->as_VMReg()->next(3));\n-\n-  reg_def VSR52  (SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()         );\n-  reg_def VSR52_H(SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()->next() );\n-  reg_def VSR52_J(SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()->next(2));\n-  reg_def VSR52_K(SOC, SOE, Op_RegF, 52, VSR52->as_VMReg()->next(3));\n-\n-  reg_def VSR53  (SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()         );\n-  reg_def VSR53_H(SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()->next() );\n-  reg_def VSR53_J(SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()->next(2));\n-  reg_def VSR53_K(SOC, SOE, Op_RegF, 53, VSR53->as_VMReg()->next(3));\n-\n-  reg_def VSR54  (SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()         );\n-  reg_def VSR54_H(SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()->next() );\n-  reg_def VSR54_J(SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()->next(2));\n-  reg_def VSR54_K(SOC, SOE, Op_RegF, 54, VSR54->as_VMReg()->next(3));\n-\n-  reg_def VSR55  (SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()         );\n-  reg_def VSR55_H(SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()->next() );\n-  reg_def VSR55_J(SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()->next(2));\n-  reg_def VSR55_K(SOC, SOE, Op_RegF, 55, VSR55->as_VMReg()->next(3));\n-\n-  reg_def VSR56  (SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()         );\n-  reg_def VSR56_H(SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()->next() );\n-  reg_def VSR56_J(SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()->next(2));\n-  reg_def VSR56_K(SOC, SOE, Op_RegF, 56, VSR56->as_VMReg()->next(3));\n-\n-  reg_def VSR57  (SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()         );\n-  reg_def VSR57_H(SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()->next() );\n-  reg_def VSR57_J(SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()->next(2));\n-  reg_def VSR57_K(SOC, SOE, Op_RegF, 57, VSR57->as_VMReg()->next(3));\n-\n-  reg_def VSR58  (SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()         );\n-  reg_def VSR58_H(SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()->next() );\n-  reg_def VSR58_J(SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()->next(2));\n-  reg_def VSR58_K(SOC, SOE, Op_RegF, 58, VSR58->as_VMReg()->next(3));\n-\n-  reg_def VSR59  (SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()         );\n-  reg_def VSR59_H(SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()->next() );\n-  reg_def VSR59_J(SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()->next(2));\n-  reg_def VSR59_K(SOC, SOE, Op_RegF, 59, VSR59->as_VMReg()->next(3));\n-\n-  reg_def VSR60  (SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()         );\n-  reg_def VSR60_H(SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()->next() );\n-  reg_def VSR60_J(SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()->next(2));\n-  reg_def VSR60_K(SOC, SOE, Op_RegF, 60, VSR60->as_VMReg()->next(3));\n-\n-  reg_def VSR61  (SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()         );\n-  reg_def VSR61_H(SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()->next() );\n-  reg_def VSR61_J(SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()->next(2));\n-  reg_def VSR61_K(SOC, SOE, Op_RegF, 61, VSR61->as_VMReg()->next(3));\n-\n-  reg_def VSR62  (SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()         );\n-  reg_def VSR62_H(SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()->next() );\n-  reg_def VSR62_J(SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()->next(2));\n-  reg_def VSR62_K(SOC, SOE, Op_RegF, 62, VSR62->as_VMReg()->next(3));\n-\n-  reg_def VSR63  (SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()         );\n-  reg_def VSR63_H(SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()->next() );\n-  reg_def VSR63_J(SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()->next(2));\n-  reg_def VSR63_K(SOC, SOE, Op_RegF, 63, VSR63->as_VMReg()->next(3));\n+\n+  reg_def VR0  (SOC, SOC, Op_RegF, 0, VR0->as_VMReg()         );\n+  reg_def VR0_H(SOC, SOC, Op_RegF, 0, VR0->as_VMReg()->next() );\n+  reg_def VR0_J(SOC, SOC, Op_RegF, 0, VR0->as_VMReg()->next(2));\n+  reg_def VR0_K(SOC, SOC, Op_RegF, 0, VR0->as_VMReg()->next(3));\n+\n+  reg_def VR1  (SOC, SOC, Op_RegF, 1, VR1->as_VMReg()         );\n+  reg_def VR1_H(SOC, SOC, Op_RegF, 1, VR1->as_VMReg()->next() );\n+  reg_def VR1_J(SOC, SOC, Op_RegF, 1, VR1->as_VMReg()->next(2));\n+  reg_def VR1_K(SOC, SOC, Op_RegF, 1, VR1->as_VMReg()->next(3));\n+\n+  reg_def VR2  (SOC, SOC, Op_RegF, 2, VR2->as_VMReg()         );\n+  reg_def VR2_H(SOC, SOC, Op_RegF, 2, VR2->as_VMReg()->next() );\n+  reg_def VR2_J(SOC, SOC, Op_RegF, 2, VR2->as_VMReg()->next(2));\n+  reg_def VR2_K(SOC, SOC, Op_RegF, 2, VR2->as_VMReg()->next(3));\n+\n+  reg_def VR3  (SOC, SOC, Op_RegF, 3, VR3->as_VMReg()         );\n+  reg_def VR3_H(SOC, SOC, Op_RegF, 3, VR3->as_VMReg()->next() );\n+  reg_def VR3_J(SOC, SOC, Op_RegF, 3, VR3->as_VMReg()->next(2));\n+  reg_def VR3_K(SOC, SOC, Op_RegF, 3, VR3->as_VMReg()->next(3));\n+\n+  reg_def VR4  (SOC, SOC, Op_RegF, 4, VR4->as_VMReg()         );\n+  reg_def VR4_H(SOC, SOC, Op_RegF, 4, VR4->as_VMReg()->next() );\n+  reg_def VR4_J(SOC, SOC, Op_RegF, 4, VR4->as_VMReg()->next(2));\n+  reg_def VR4_K(SOC, SOC, Op_RegF, 4, VR4->as_VMReg()->next(3));\n+\n+  reg_def VR5  (SOC, SOC, Op_RegF, 5, VR5->as_VMReg()         );\n+  reg_def VR5_H(SOC, SOC, Op_RegF, 5, VR5->as_VMReg()->next() );\n+  reg_def VR5_J(SOC, SOC, Op_RegF, 5, VR5->as_VMReg()->next(2));\n+  reg_def VR5_K(SOC, SOC, Op_RegF, 5, VR5->as_VMReg()->next(3));\n+\n+  reg_def VR6  (SOC, SOC, Op_RegF, 6, VR6->as_VMReg()         );\n+  reg_def VR6_H(SOC, SOC, Op_RegF, 6, VR6->as_VMReg()->next() );\n+  reg_def VR6_J(SOC, SOC, Op_RegF, 6, VR6->as_VMReg()->next(2));\n+  reg_def VR6_K(SOC, SOC, Op_RegF, 6, VR6->as_VMReg()->next(3));\n+\n+  reg_def VR7  (SOC, SOC, Op_RegF, 7, VR7->as_VMReg()         );\n+  reg_def VR7_H(SOC, SOC, Op_RegF, 7, VR7->as_VMReg()->next() );\n+  reg_def VR7_J(SOC, SOC, Op_RegF, 7, VR7->as_VMReg()->next(2));\n+  reg_def VR7_K(SOC, SOC, Op_RegF, 7, VR7->as_VMReg()->next(3));\n+\n+  reg_def VR8  (SOC, SOC, Op_RegF, 8, VR8->as_VMReg()         );\n+  reg_def VR8_H(SOC, SOC, Op_RegF, 8, VR8->as_VMReg()->next() );\n+  reg_def VR8_J(SOC, SOC, Op_RegF, 8, VR8->as_VMReg()->next(2));\n+  reg_def VR8_K(SOC, SOC, Op_RegF, 8, VR8->as_VMReg()->next(3));\n+\n+  reg_def VR9  (SOC, SOC, Op_RegF, 9, VR9->as_VMReg()         );\n+  reg_def VR9_H(SOC, SOC, Op_RegF, 9, VR9->as_VMReg()->next() );\n+  reg_def VR9_J(SOC, SOC, Op_RegF, 9, VR9->as_VMReg()->next(2));\n+  reg_def VR9_K(SOC, SOC, Op_RegF, 9, VR9->as_VMReg()->next(3));\n+\n+  reg_def VR10  (SOC, SOC, Op_RegF, 10, VR10->as_VMReg()         );\n+  reg_def VR10_H(SOC, SOC, Op_RegF, 10, VR10->as_VMReg()->next() );\n+  reg_def VR10_J(SOC, SOC, Op_RegF, 10, VR10->as_VMReg()->next(2));\n+  reg_def VR10_K(SOC, SOC, Op_RegF, 10, VR10->as_VMReg()->next(3));\n+\n+  reg_def VR11  (SOC, SOC, Op_RegF, 11, VR11->as_VMReg()         );\n+  reg_def VR11_H(SOC, SOC, Op_RegF, 11, VR11->as_VMReg()->next() );\n+  reg_def VR11_J(SOC, SOC, Op_RegF, 11, VR11->as_VMReg()->next(2));\n+  reg_def VR11_K(SOC, SOC, Op_RegF, 11, VR11->as_VMReg()->next(3));\n+\n+  reg_def VR12  (SOC, SOC, Op_RegF, 12, VR12->as_VMReg()         );\n+  reg_def VR12_H(SOC, SOC, Op_RegF, 12, VR12->as_VMReg()->next() );\n+  reg_def VR12_J(SOC, SOC, Op_RegF, 12, VR12->as_VMReg()->next(2));\n+  reg_def VR12_K(SOC, SOC, Op_RegF, 12, VR12->as_VMReg()->next(3));\n+\n+  reg_def VR13  (SOC, SOC, Op_RegF, 13, VR13->as_VMReg()         );\n+  reg_def VR13_H(SOC, SOC, Op_RegF, 13, VR13->as_VMReg()->next() );\n+  reg_def VR13_J(SOC, SOC, Op_RegF, 13, VR13->as_VMReg()->next(2));\n+  reg_def VR13_K(SOC, SOC, Op_RegF, 13, VR13->as_VMReg()->next(3));\n+\n+  reg_def VR14  (SOC, SOC, Op_RegF, 14, VR14->as_VMReg()         );\n+  reg_def VR14_H(SOC, SOC, Op_RegF, 14, VR14->as_VMReg()->next() );\n+  reg_def VR14_J(SOC, SOC, Op_RegF, 14, VR14->as_VMReg()->next(2));\n+  reg_def VR14_K(SOC, SOC, Op_RegF, 14, VR14->as_VMReg()->next(3));\n+\n+  reg_def VR15  (SOC, SOC, Op_RegF, 15, VR15->as_VMReg()         );\n+  reg_def VR15_H(SOC, SOC, Op_RegF, 15, VR15->as_VMReg()->next() );\n+  reg_def VR15_J(SOC, SOC, Op_RegF, 15, VR15->as_VMReg()->next(2));\n+  reg_def VR15_K(SOC, SOC, Op_RegF, 15, VR15->as_VMReg()->next(3));\n+\n+  reg_def VR16  (SOC, SOC, Op_RegF, 16, VR16->as_VMReg()         );\n+  reg_def VR16_H(SOC, SOC, Op_RegF, 16, VR16->as_VMReg()->next() );\n+  reg_def VR16_J(SOC, SOC, Op_RegF, 16, VR16->as_VMReg()->next(2));\n+  reg_def VR16_K(SOC, SOC, Op_RegF, 16, VR16->as_VMReg()->next(3));\n+\n+  reg_def VR17  (SOC, SOC, Op_RegF, 17, VR17->as_VMReg()         );\n+  reg_def VR17_H(SOC, SOC, Op_RegF, 17, VR17->as_VMReg()->next() );\n+  reg_def VR17_J(SOC, SOC, Op_RegF, 17, VR17->as_VMReg()->next(2));\n+  reg_def VR17_K(SOC, SOC, Op_RegF, 17, VR17->as_VMReg()->next(3));\n+\n+  reg_def VR18  (SOC, SOC, Op_RegF, 18, VR18->as_VMReg()         );\n+  reg_def VR18_H(SOC, SOC, Op_RegF, 18, VR18->as_VMReg()->next() );\n+  reg_def VR18_J(SOC, SOC, Op_RegF, 18, VR18->as_VMReg()->next(2));\n+  reg_def VR18_K(SOC, SOC, Op_RegF, 18, VR18->as_VMReg()->next(3));\n+\n+  reg_def VR19  (SOC, SOC, Op_RegF, 19, VR19->as_VMReg()         );\n+  reg_def VR19_H(SOC, SOC, Op_RegF, 19, VR19->as_VMReg()->next() );\n+  reg_def VR19_J(SOC, SOC, Op_RegF, 19, VR19->as_VMReg()->next(2));\n+  reg_def VR19_K(SOC, SOC, Op_RegF, 19, VR19->as_VMReg()->next(3));\n+\n+  reg_def VR20  (SOC, SOE, Op_RegF, 20, VR20->as_VMReg()         );\n+  reg_def VR20_H(SOC, SOE, Op_RegF, 20, VR20->as_VMReg()->next() );\n+  reg_def VR20_J(SOC, SOE, Op_RegF, 20, VR20->as_VMReg()->next(2));\n+  reg_def VR20_K(SOC, SOE, Op_RegF, 20, VR20->as_VMReg()->next(3));\n+\n+  reg_def VR21  (SOC, SOE, Op_RegF, 21, VR21->as_VMReg()         );\n+  reg_def VR21_H(SOC, SOE, Op_RegF, 21, VR21->as_VMReg()->next() );\n+  reg_def VR21_J(SOC, SOE, Op_RegF, 21, VR21->as_VMReg()->next(2));\n+  reg_def VR21_K(SOC, SOE, Op_RegF, 21, VR21->as_VMReg()->next(3));\n+\n+  reg_def VR22  (SOC, SOE, Op_RegF, 22, VR22->as_VMReg()         );\n+  reg_def VR22_H(SOC, SOE, Op_RegF, 22, VR22->as_VMReg()->next() );\n+  reg_def VR22_J(SOC, SOE, Op_RegF, 22, VR22->as_VMReg()->next(2));\n+  reg_def VR22_K(SOC, SOE, Op_RegF, 22, VR22->as_VMReg()->next(3));\n+\n+  reg_def VR23  (SOC, SOE, Op_RegF, 23, VR23->as_VMReg()         );\n+  reg_def VR23_H(SOC, SOE, Op_RegF, 23, VR23->as_VMReg()->next() );\n+  reg_def VR23_J(SOC, SOE, Op_RegF, 23, VR23->as_VMReg()->next(2));\n+  reg_def VR23_K(SOC, SOE, Op_RegF, 23, VR23->as_VMReg()->next(3));\n+\n+  reg_def VR24  (SOC, SOE, Op_RegF, 24, VR24->as_VMReg()         );\n+  reg_def VR24_H(SOC, SOE, Op_RegF, 24, VR24->as_VMReg()->next() );\n+  reg_def VR24_J(SOC, SOE, Op_RegF, 24, VR24->as_VMReg()->next(2));\n+  reg_def VR24_K(SOC, SOE, Op_RegF, 24, VR24->as_VMReg()->next(3));\n+\n+  reg_def VR25  (SOC, SOE, Op_RegF, 25, VR25->as_VMReg()         );\n+  reg_def VR25_H(SOC, SOE, Op_RegF, 25, VR25->as_VMReg()->next() );\n+  reg_def VR25_J(SOC, SOE, Op_RegF, 25, VR25->as_VMReg()->next(2));\n+  reg_def VR25_K(SOC, SOE, Op_RegF, 25, VR25->as_VMReg()->next(3));\n+\n+  reg_def VR26  (SOC, SOE, Op_RegF, 26, VR26->as_VMReg()         );\n+  reg_def VR26_H(SOC, SOE, Op_RegF, 26, VR26->as_VMReg()->next() );\n+  reg_def VR26_J(SOC, SOE, Op_RegF, 26, VR26->as_VMReg()->next(2));\n+  reg_def VR26_K(SOC, SOE, Op_RegF, 26, VR26->as_VMReg()->next(3));\n+\n+  reg_def VR27  (SOC, SOE, Op_RegF, 27, VR27->as_VMReg()         );\n+  reg_def VR27_H(SOC, SOE, Op_RegF, 27, VR27->as_VMReg()->next() );\n+  reg_def VR27_J(SOC, SOE, Op_RegF, 27, VR27->as_VMReg()->next(2));\n+  reg_def VR27_K(SOC, SOE, Op_RegF, 27, VR27->as_VMReg()->next(3));\n+\n+  reg_def VR28  (SOC, SOE, Op_RegF, 28, VR28->as_VMReg()         );\n+  reg_def VR28_H(SOC, SOE, Op_RegF, 28, VR28->as_VMReg()->next() );\n+  reg_def VR28_J(SOC, SOE, Op_RegF, 28, VR28->as_VMReg()->next(2));\n+  reg_def VR28_K(SOC, SOE, Op_RegF, 28, VR28->as_VMReg()->next(3));\n+\n+  reg_def VR29  (SOC, SOE, Op_RegF, 29, VR29->as_VMReg()         );\n+  reg_def VR29_H(SOC, SOE, Op_RegF, 29, VR29->as_VMReg()->next() );\n+  reg_def VR29_J(SOC, SOE, Op_RegF, 29, VR29->as_VMReg()->next(2));\n+  reg_def VR29_K(SOC, SOE, Op_RegF, 29, VR29->as_VMReg()->next(3));\n+\n+  reg_def VR30  (SOC, SOE, Op_RegF, 30, VR30->as_VMReg()         );\n+  reg_def VR30_H(SOC, SOE, Op_RegF, 30, VR30->as_VMReg()->next() );\n+  reg_def VR30_J(SOC, SOE, Op_RegF, 30, VR30->as_VMReg()->next(2));\n+  reg_def VR30_K(SOC, SOE, Op_RegF, 30, VR30->as_VMReg()->next(3));\n+\n+  reg_def VR31  (SOC, SOE, Op_RegF, 31, VR31->as_VMReg()         );\n+  reg_def VR31_H(SOC, SOE, Op_RegF, 31, VR31->as_VMReg()->next() );\n+  reg_def VR31_J(SOC, SOE, Op_RegF, 31, VR31->as_VMReg()->next(2));\n+  reg_def VR31_K(SOC, SOE, Op_RegF, 31, VR31->as_VMReg()->next(3));\n@@ -699,64 +538,32 @@\n-  VSR0 , VSR0_H , VSR0_J , VSR0_K ,\n-  VSR1 , VSR1_H , VSR1_J , VSR1_K ,\n-  VSR2 , VSR2_H , VSR2_J , VSR2_K ,\n-  VSR3 , VSR3_H , VSR3_J , VSR3_K ,\n-  VSR4 , VSR4_H , VSR4_J , VSR4_K ,\n-  VSR5 , VSR5_H , VSR5_J , VSR5_K ,\n-  VSR6 , VSR6_H , VSR6_J , VSR6_K ,\n-  VSR7 , VSR7_H , VSR7_J , VSR7_K ,\n-  VSR8 , VSR8_H , VSR8_J , VSR8_K ,\n-  VSR9 , VSR9_H , VSR9_J , VSR9_K ,\n-  VSR10, VSR10_H, VSR10_J, VSR10_K,\n-  VSR11, VSR11_H, VSR11_J, VSR11_K,\n-  VSR12, VSR12_H, VSR12_J, VSR12_K,\n-  VSR13, VSR13_H, VSR13_J, VSR13_K,\n-  VSR14, VSR14_H, VSR14_J, VSR14_K,\n-  VSR15, VSR15_H, VSR15_J, VSR15_K,\n-  VSR16, VSR16_H, VSR16_J, VSR16_K,\n-  VSR17, VSR17_H, VSR17_J, VSR17_K,\n-  VSR18, VSR18_H, VSR18_J, VSR18_K,\n-  VSR19, VSR19_H, VSR19_J, VSR19_K,\n-  VSR20, VSR20_H, VSR20_J, VSR20_K,\n-  VSR21, VSR21_H, VSR21_J, VSR21_K,\n-  VSR22, VSR22_H, VSR22_J, VSR22_K,\n-  VSR23, VSR23_H, VSR23_J, VSR23_K,\n-  VSR24, VSR24_H, VSR24_J, VSR24_K,\n-  VSR25, VSR25_H, VSR25_J, VSR25_K,\n-  VSR26, VSR26_H, VSR26_J, VSR26_K,\n-  VSR27, VSR27_H, VSR27_J, VSR27_K,\n-  VSR28, VSR28_H, VSR28_J, VSR28_K,\n-  VSR29, VSR29_H, VSR29_J, VSR29_K,\n-  VSR30, VSR30_H, VSR30_J, VSR30_K,\n-  VSR31, VSR31_H, VSR31_J, VSR31_K,\n-  VSR32, VSR32_H, VSR32_J, VSR32_K,\n-  VSR33, VSR33_H, VSR33_J, VSR33_K,\n-  VSR34, VSR34_H, VSR34_J, VSR34_K,\n-  VSR35, VSR35_H, VSR35_J, VSR35_K,\n-  VSR36, VSR36_H, VSR36_J, VSR36_K,\n-  VSR37, VSR37_H, VSR37_J, VSR37_K,\n-  VSR38, VSR38_H, VSR38_J, VSR38_K,\n-  VSR39, VSR39_H, VSR39_J, VSR39_K,\n-  VSR40, VSR40_H, VSR40_J, VSR40_K,\n-  VSR41, VSR41_H, VSR41_J, VSR41_K,\n-  VSR42, VSR42_H, VSR42_J, VSR42_K,\n-  VSR43, VSR43_H, VSR43_J, VSR43_K,\n-  VSR44, VSR44_H, VSR44_J, VSR44_K,\n-  VSR45, VSR45_H, VSR45_J, VSR45_K,\n-  VSR46, VSR46_H, VSR46_J, VSR46_K,\n-  VSR47, VSR47_H, VSR47_J, VSR47_K,\n-  VSR48, VSR48_H, VSR48_J, VSR48_K,\n-  VSR49, VSR49_H, VSR49_J, VSR49_K,\n-  VSR50, VSR50_H, VSR50_J, VSR50_K,\n-  VSR51, VSR51_H, VSR51_J, VSR51_K,\n-  VSR52, VSR52_H, VSR52_J, VSR52_K,\n-  VSR53, VSR53_H, VSR53_J, VSR53_K,\n-  VSR54, VSR54_H, VSR54_J, VSR54_K,\n-  VSR55, VSR55_H, VSR55_J, VSR55_K,\n-  VSR56, VSR56_H, VSR56_J, VSR56_K,\n-  VSR57, VSR57_H, VSR57_J, VSR57_K,\n-  VSR58, VSR58_H, VSR58_J, VSR58_K,\n-  VSR59, VSR59_H, VSR59_J, VSR59_K,\n-  VSR60, VSR60_H, VSR60_J, VSR60_K,\n-  VSR61, VSR61_H, VSR61_J, VSR61_K,\n-  VSR62, VSR62_H, VSR62_J, VSR62_K,\n-  VSR63, VSR63_H, VSR63_J, VSR63_K\n+  VR0 , VR0_H , VR0_J , VR0_K ,\n+  VR1 , VR1_H , VR1_J , VR1_K ,\n+  VR2 , VR2_H , VR2_J , VR2_K ,\n+  VR3 , VR3_H , VR3_J , VR3_K ,\n+  VR4 , VR4_H , VR4_J , VR4_K ,\n+  VR5 , VR5_H , VR5_J , VR5_K ,\n+  VR6 , VR6_H , VR6_J , VR6_K ,\n+  VR7 , VR7_H , VR7_J , VR7_K ,\n+  VR8 , VR8_H , VR8_J , VR8_K ,\n+  VR9 , VR9_H , VR9_J , VR9_K ,\n+  VR10, VR10_H, VR10_J, VR10_K,\n+  VR11, VR11_H, VR11_J, VR11_K,\n+  VR12, VR12_H, VR12_J, VR12_K,\n+  VR13, VR13_H, VR13_J, VR13_K,\n+  VR14, VR14_H, VR14_J, VR14_K,\n+  VR15, VR15_H, VR15_J, VR15_K,\n+  VR16, VR16_H, VR16_J, VR16_K,\n+  VR17, VR17_H, VR17_J, VR17_K,\n+  VR18, VR18_H, VR18_J, VR18_K,\n+  VR19, VR19_H, VR19_J, VR19_K,\n+  VR20, VR20_H, VR20_J, VR20_K,\n+  VR21, VR21_H, VR21_J, VR21_K,\n+  VR22, VR22_H, VR22_J, VR22_K,\n+  VR23, VR23_H, VR23_J, VR23_K,\n+  VR24, VR24_H, VR24_J, VR24_K,\n+  VR25, VR25_H, VR25_J, VR25_K,\n+  VR26, VR26_H, VR26_J, VR26_K,\n+  VR27, VR27_H, VR27_J, VR27_K,\n+  VR28, VR28_H, VR28_J, VR28_K,\n+  VR29, VR29_H, VR29_J, VR29_K,\n+  VR30, VR30_H, VR30_J, VR30_K,\n+  VR31, VR31_H, VR31_J, VR31_K\n@@ -1166,33 +973,33 @@\n-reg_class vs_reg(\n-  VSR32, VSR32_H, VSR32_J, VSR32_K,\n-  VSR33, VSR33_H, VSR33_J, VSR33_K,\n-  VSR34, VSR34_H, VSR34_J, VSR34_K,\n-  VSR35, VSR35_H, VSR35_J, VSR35_K,\n-  VSR36, VSR36_H, VSR36_J, VSR36_K,\n-  VSR37, VSR37_H, VSR37_J, VSR37_K,\n-  VSR38, VSR38_H, VSR38_J, VSR38_K,\n-  VSR39, VSR39_H, VSR39_J, VSR39_K,\n-  VSR40, VSR40_H, VSR40_J, VSR40_K,\n-  VSR41, VSR41_H, VSR41_J, VSR41_K,\n-  VSR42, VSR42_H, VSR42_J, VSR42_K,\n-  VSR43, VSR43_H, VSR43_J, VSR43_K,\n-  VSR44, VSR44_H, VSR44_J, VSR44_K,\n-  VSR45, VSR45_H, VSR45_J, VSR45_K,\n-  VSR46, VSR46_H, VSR46_J, VSR46_K,\n-  VSR47, VSR47_H, VSR47_J, VSR47_K,\n-  VSR48, VSR48_H, VSR48_J, VSR48_K,\n-  VSR49, VSR49_H, VSR49_J, VSR49_K,\n-  VSR50, VSR50_H, VSR50_J, VSR50_K,\n-  VSR51, VSR51_H, VSR51_J, VSR51_K,\n-  VSR52, VSR52_H, VSR52_J, VSR52_K, \/\/ non-volatile\n-  VSR53, VSR53_H, VSR53_J, VSR53_K, \/\/ non-volatile\n-  VSR54, VSR54_H, VSR54_J, VSR54_K, \/\/ non-volatile\n-  VSR55, VSR55_H, VSR55_J, VSR55_K, \/\/ non-volatile\n-  VSR56, VSR56_H, VSR56_J, VSR56_K, \/\/ non-volatile\n-  VSR57, VSR57_H, VSR57_J, VSR57_K, \/\/ non-volatile\n-  VSR58, VSR58_H, VSR58_J, VSR58_K, \/\/ non-volatile\n-  VSR59, VSR59_H, VSR59_J, VSR59_K, \/\/ non-volatile\n-  VSR60, VSR60_H, VSR60_J, VSR60_K, \/\/ non-volatile\n-  VSR61, VSR61_H, VSR61_J, VSR61_K, \/\/ non-volatile\n-  VSR62, VSR62_H, VSR62_J, VSR62_K, \/\/ non-volatile\n-  VSR63, VSR63_H, VSR63_J, VSR63_K  \/\/ non-volatile\n+reg_class v_reg(\n+  VR0 , VR0_H , VR0_J , VR0_K ,\n+  VR1 , VR1_H , VR1_J , VR1_K ,\n+  VR2 , VR2_H , VR2_J , VR2_K ,\n+  VR3 , VR3_H , VR3_J , VR3_K ,\n+  VR4 , VR4_H , VR4_J , VR4_K ,\n+  VR5 , VR5_H , VR5_J , VR5_K ,\n+  VR6 , VR6_H , VR6_J , VR6_K ,\n+  VR7 , VR7_H , VR7_J , VR7_K ,\n+  VR8 , VR8_H , VR8_J , VR8_K ,\n+  VR9 , VR9_H , VR9_J , VR9_K ,\n+  VR10, VR10_H, VR10_J, VR10_K,\n+  VR11, VR11_H, VR11_J, VR11_K,\n+  VR12, VR12_H, VR12_J, VR12_K,\n+  VR13, VR13_H, VR13_J, VR13_K,\n+  VR14, VR14_H, VR14_J, VR14_K,\n+  VR15, VR15_H, VR15_J, VR15_K,\n+  VR16, VR16_H, VR16_J, VR16_K,\n+  VR17, VR17_H, VR17_J, VR17_K,\n+  VR18, VR18_H, VR18_J, VR18_K,\n+  VR19, VR19_H, VR19_J, VR19_K,\n+  VR20, VR20_H, VR20_J, VR20_K,\n+  VR21, VR21_H, VR21_J, VR21_K,\n+  VR22, VR22_H, VR22_J, VR22_K,\n+  VR23, VR23_H, VR23_J, VR23_K,\n+  VR24, VR24_H, VR24_J, VR24_K,\n+  VR25, VR25_H, VR25_J, VR25_K,\n+  VR26, VR26_H, VR26_J, VR26_K,\n+  VR27, VR27_H, VR27_J, VR27_K,\n+  VR28, VR28_H, VR28_J, VR28_K,\n+  VR29, VR29_H, VR29_J, VR29_K,\n+  VR30, VR30_H, VR30_J, VR30_K,\n+  VR31, VR31_H, VR31_J, VR31_K\n@@ -1911,1 +1718,1 @@\n-\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_vs or\n+\/\/ Figure out which register class each belongs in: rc_int, rc_float, rc_vec or\n@@ -1913,1 +1720,1 @@\n-enum RC { rc_bad, rc_int, rc_float, rc_vs, rc_stack };\n+enum RC { rc_bad, rc_int, rc_float, rc_vec, rc_stack };\n@@ -1927,1 +1734,1 @@\n-  STATIC_ASSERT((int)ConcreteRegisterImpl::max_fpr == (int)MachRegisterNumbers::VSR0_num);\n+  STATIC_ASSERT((int)ConcreteRegisterImpl::max_fpr == (int)MachRegisterNumbers::VR0_num);\n@@ -1931,2 +1738,2 @@\n-  STATIC_ASSERT((int)ConcreteRegisterImpl::max_vsr == (int)MachRegisterNumbers::CR0_num);\n-  if (reg < ConcreteRegisterImpl::max_vsr) return rc_vs;\n+  STATIC_ASSERT((int)ConcreteRegisterImpl::max_vr == (int)MachRegisterNumbers::CR0_num);\n+  if (reg < ConcreteRegisterImpl::max_vr) return rc_vec;\n@@ -2008,3 +1815,3 @@\n-    \/\/ VectorSRegister->Memory Spill.\n-    else if (src_lo_rc == rc_vs && dst_lo_rc == rc_stack) {\n-      VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);\n+    \/\/ VectorRegister->Memory Spill.\n+    else if (src_lo_rc == rc_vec && dst_lo_rc == rc_stack) {\n+      VectorSRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]).to_vsr();\n@@ -2035,3 +1842,3 @@\n-    \/\/ Memory->VectorSRegister Spill.\n-    else if (src_lo_rc == rc_stack && dst_lo_rc == rc_vs) {\n-      VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);\n+    \/\/ Memory->VectorRegister Spill.\n+    else if (src_lo_rc == rc_stack && dst_lo_rc == rc_vec) {\n+      VectorSRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]).to_vsr();\n@@ -2060,4 +1867,4 @@\n-    \/\/ VectorSRegister->VectorSRegister.\n-    else if (src_lo_rc == rc_vs && dst_lo_rc == rc_vs) {\n-      VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);\n-      VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);\n+    \/\/ VectorRegister->VectorRegister.\n+    else if (src_lo_rc == rc_vec && dst_lo_rc == rc_vec) {\n+      VectorSRegister Rsrc = as_VectorRegister(Matcher::_regEncode[src_lo]).to_vsr();\n+      VectorSRegister Rdst = as_VectorRegister(Matcher::_regEncode[dst_lo]).to_vsr();\n@@ -2070,1 +1877,1 @@\n-      ShouldNotReachHere(); \/\/ No VSR spill.\n+      ShouldNotReachHere(); \/\/ No VR spill.\n@@ -4051,1 +3858,1 @@\n-  constraint(ALLOC_IN_RC(vs_reg));\n+  constraint(ALLOC_IN_RC(v_reg));\n@@ -5627,1 +5434,1 @@\n-    __ lxvd2x($dst$$VectorSRegister, $mem$$Register);\n+    __ lxvd2x($dst$$VectorRegister.to_vsr(), $mem$$Register);\n@@ -5640,1 +5447,1 @@\n-    __ lxv($dst$$VectorSRegister, $mem$$disp, $mem$$Register);\n+    __ lxv($dst$$VectorRegister.to_vsr(), $mem$$disp, $mem$$Register);\n@@ -6667,1 +6474,1 @@\n-    __ stxvd2x($src$$VectorSRegister, $mem$$Register);\n+    __ stxvd2x($src$$VectorRegister.to_vsr(), $mem$$Register);\n@@ -6680,1 +6487,1 @@\n-    __ stxv($src$$VectorSRegister, $mem$$disp, $mem$$Register);\n+    __ stxv($src$$VectorRegister.to_vsr(), $mem$$disp, $mem$$Register);\n@@ -6690,0 +6497,1 @@\n+  size(0);\n@@ -6698,0 +6506,1 @@\n+  size(0);\n@@ -6817,1 +6626,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description exists.\n@@ -6949,1 +6757,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description exists.\n@@ -7426,2 +7233,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -7443,2 +7248,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -7460,2 +7263,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -7477,2 +7278,0 @@\n-    \/\/ This is a Power7 instruction for which no machine description\n-    \/\/ exists. Anyways, the scheduler should be off on Power7.\n@@ -9924,7 +9723,0 @@\n-\/\/\n-\/\/ Notes on the implementation on ppc64:\n-\/\/ For Power7 and earlier, the rules are limited to those which move between a\n-\/\/ register and a stack-location, because we always have to go through memory\n-\/\/ when moving between a float register and an integer register.\n-\/\/ This restriction is removed in Power8 with the introduction of the mtfprd\n-\/\/ and mffprd instructions.\n@@ -12437,0 +12229,1 @@\n+  size(8);\n@@ -12450,0 +12243,1 @@\n+  size(8);\n@@ -12459,1 +12253,0 @@\n-\/\/ Popcnt for Power7.\n@@ -12473,1 +12266,0 @@\n-\/\/ Popcnt for Power7.\n@@ -12652,3 +12444,3 @@\n-    __ mtvsrwz($tmpV$$VectorSRegister, $src$$Register);\n-    __ xxbrw($tmpV$$VectorSRegister, $tmpV$$VectorSRegister);\n-    __ mfvsrwz($dst$$Register, $tmpV$$VectorSRegister);\n+    __ mtvsrwz($tmpV$$VectorRegister.to_vsr(), $src$$Register);\n+    __ xxbrw($tmpV$$VectorRegister.to_vsr(), $tmpV$$VectorRegister->to_vsr());\n+    __ mfvsrwz($dst$$Register, $tmpV$$VectorRegister->to_vsr());\n@@ -12724,3 +12516,3 @@\n-    __ mtvsrd($tmpV$$VectorSRegister, $src$$Register);\n-    __ xxbrd($tmpV$$VectorSRegister, $tmpV$$VectorSRegister);\n-    __ mfvsrd($dst$$Register, $tmpV$$VectorSRegister);\n+    __ mtvsrd($tmpV$$VectorRegister->to_vsr(), $src$$Register);\n+    __ xxbrd($tmpV$$VectorRegister->to_vsr(), $tmpV$$VectorRegister->to_vsr());\n+    __ mfvsrd($dst$$Register, $tmpV$$VectorRegister->to_vsr());\n@@ -12965,1 +12757,1 @@\n-    __ mtvsrwz($temp1$$VectorSRegister, $src$$Register);\n+    __ mtvsrwz($temp1$$VectorRegister->to_vsr(), $src$$Register);\n@@ -12976,1 +12768,1 @@\n-    __ xxspltw($dst$$VectorSRegister, $src$$VectorSRegister, $imm1$$constant);\n+    __ xxspltw($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr(), $imm1$$constant);\n@@ -12987,1 +12779,1 @@\n-    __ xscvdpspn($dst$$VectorSRegister, $src$$FloatRegister->to_vsr());\n+    __ xscvdpspn($dst$$VectorRegister->to_vsr(), $src$$FloatRegister->to_vsr());\n@@ -13094,1 +12886,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13107,1 +12899,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13172,1 +12964,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13185,1 +12977,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13250,1 +13042,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13263,1 +13055,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -13302,0 +13094,1 @@\n+  size(4);\n@@ -13319,1 +13112,1 @@\n-    __ vaddubm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vaddubm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13330,1 +13123,1 @@\n-    __ vadduhm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vadduhm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13341,1 +13134,1 @@\n-    __ vadduwm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vadduwm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13352,1 +13145,1 @@\n-    __ vaddfp($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vaddfp($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13363,1 +13156,1 @@\n-    __ vaddudm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vaddudm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13374,1 +13167,1 @@\n-    __ xvadddp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvadddp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13387,1 +13180,1 @@\n-    __ vsububm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsububm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13398,1 +13191,1 @@\n-    __ vsubuhm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubuhm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13409,1 +13202,1 @@\n-    __ vsubuwm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubuwm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13420,1 +13213,1 @@\n-    __ vsubfp($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubfp($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13431,1 +13224,1 @@\n-    __ vsubudm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vsubudm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13442,1 +13235,1 @@\n-    __ xvsubdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvsubdp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13457,2 +13250,2 @@\n-    __ vspltish($tmp$$VectorSRegister->to_vr(), 0);\n-    __ vmladduhm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr(), $tmp$$VectorSRegister->to_vr());\n+    __ vspltish($tmp$$VectorRegister, 0);\n+    __ vmladduhm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister, $tmp$$VectorRegister);\n@@ -13469,1 +13262,1 @@\n-    __ vmuluwm($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vmuluwm($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13480,1 +13273,1 @@\n-    __ xvmulsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmulsp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13491,1 +13284,1 @@\n-    __ xvmuldp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmuldp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13504,1 +13297,1 @@\n-    __ xvdivsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvdivsp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13515,1 +13308,1 @@\n-    __ xvdivdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvdivdp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13530,1 +13323,1 @@\n-        __ vminsw($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        __ vminsw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13533,1 +13326,1 @@\n-        __ vminsd($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        __ vminsd($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13550,1 +13343,1 @@\n-        __ vmaxsw($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        __ vmaxsw($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13553,1 +13346,1 @@\n-        __ vmaxsd($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        __ vmaxsd($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13567,1 +13360,1 @@\n-    __ vand($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vand($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13577,1 +13370,1 @@\n-    __ vor($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vor($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13587,1 +13380,1 @@\n-    __ vxor($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+    __ vxor($dst$$VectorRegister, $src1$$VectorRegister, $src2$$VectorRegister);\n@@ -13605,2 +13398,2 @@\n-    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorSRegister->to_vr(),\n-        $tmp1$$VectorSRegister->to_vr(), $tmp2$$VectorSRegister->to_vr());\n+    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorRegister,\n+        $tmp1$$VectorRegister, $tmp2$$VectorRegister);\n@@ -13621,2 +13414,2 @@\n-    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorSRegister->to_vr(),\n-        $tmp1$$VectorSRegister->to_vr(), $tmp2$$VectorSRegister->to_vr());\n+    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorRegister,\n+        $tmp1$$VectorRegister, $tmp2$$VectorRegister);\n@@ -13635,1 +13428,1 @@\n-    __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvabssp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13646,1 +13439,1 @@\n-    __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvabsdp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13683,1 +13476,1 @@\n-        __ xvrdpic($dst$$VectorSRegister, $src$$VectorSRegister);\n+        __ xvrdpic($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13686,1 +13479,1 @@\n-        __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);\n+        __ xvrdpim($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13689,1 +13482,1 @@\n-        __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);\n+        __ xvrdpip($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13706,1 +13499,1 @@\n-    __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvnegsp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13717,1 +13510,1 @@\n-    __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvnegdp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13730,1 +13523,1 @@\n-    __ xvsqrtsp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvsqrtsp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13741,1 +13534,1 @@\n-    __ xvsqrtdp($dst$$VectorSRegister, $src$$VectorSRegister);\n+    __ xvsqrtdp($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr());\n@@ -13757,1 +13550,1 @@\n-        __ vpopcntb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcntb($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13760,1 +13553,1 @@\n-        __ vpopcnth($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcnth($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13763,1 +13556,1 @@\n-        __ vpopcntw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcntw($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13766,1 +13559,1 @@\n-        __ vpopcntd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vpopcntd($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13783,1 +13576,1 @@\n-        __ vclzb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzb($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13786,1 +13579,1 @@\n-        __ vclzh($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzh($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13789,1 +13582,1 @@\n-        __ vclzw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzw($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13792,1 +13585,1 @@\n-        __ vclzd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vclzd($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13809,1 +13602,1 @@\n-        __ vctzb($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzb($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13812,1 +13605,1 @@\n-        __ vctzh($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzh($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13815,1 +13608,1 @@\n-        __ vctzw($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzw($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13818,1 +13611,1 @@\n-        __ vctzd($dst$$VectorSRegister->to_vr(), $src$$VectorSRegister->to_vr());\n+        __ vctzd($dst$$VectorRegister, $src$$VectorRegister);\n@@ -13838,1 +13631,1 @@\n-    __ xvmaddasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmaddasp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13854,1 +13647,1 @@\n-    __ xvnmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvnmsubasp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13869,1 +13662,1 @@\n-    __ xvmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmsubasp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13884,1 +13677,1 @@\n-    __ xvmaddadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmaddadp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13900,1 +13693,1 @@\n-    __ xvnmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvnmsubadp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13915,1 +13708,1 @@\n-    __ xvmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);\n+    __ xvmsubadp($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr());\n@@ -13930,0 +13723,1 @@\n+  size(12);\n@@ -13942,0 +13736,1 @@\n+  size(12);\n@@ -13954,0 +13749,1 @@\n+  size(12);\n@@ -13966,0 +13762,1 @@\n+  size(12);\n@@ -14004,0 +13801,1 @@\n+  size(4);\n@@ -14005,1 +13803,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -14018,1 +13816,1 @@\n-    __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister->to_vsr(), $src$$FloatRegister->to_vsr(), 0);\n+    __ xxpermdi($dst$$VectorRegister->to_vsr(), $src$$FloatRegister->to_vsr(), $src$$FloatRegister->to_vsr(), 0);\n@@ -14031,1 +13829,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -14043,1 +13841,1 @@\n-    __ mtvsrd($dst$$VectorSRegister, $src$$Register);\n+    __ mtvsrd($dst$$VectorRegister->to_vsr(), $src$$Register);\n@@ -14054,1 +13852,1 @@\n-    __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);\n+    __ xxpermdi($dst$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr(), $src$$VectorRegister->to_vsr(), $zero$$constant);\n@@ -14065,1 +13863,1 @@\n-    __ xxpermdi($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister, $zero$$constant);\n+    __ xxpermdi($dst$$VectorRegister->to_vsr(), $src1$$VectorRegister->to_vsr(), $src2$$VectorRegister->to_vsr(), $zero$$constant);\n@@ -14090,1 +13888,1 @@\n-    __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxlxor($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n@@ -14103,1 +13901,1 @@\n-    __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);\n+    __ xxleqv($dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr(), $dst$$VectorRegister->to_vsr());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":337,"deletions":539,"binary":false,"changes":876,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+  inline VMReg as_VMReg() const;\n@@ -395,1 +396,0 @@\n-  inline VMReg as_VMReg() const;\n@@ -487,2 +487,2 @@\n-    max_vsr = max_fpr + VectorSRegister::number_of_registers * 4,\n-    max_cnd = max_vsr + ConditionRegister::number_of_registers,\n+    max_vr  = max_fpr + VectorRegister::number_of_registers * 4,\n+    max_cnd = max_vr  + ConditionRegister::number_of_registers,\n","filename":"src\/hotspot\/cpu\/ppc\/register_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    vs_reg\n+    vec_reg\n@@ -120,1 +120,1 @@\n-    vs_reg_size       = 16\n+    vec_reg_size      = 16\n@@ -140,2 +140,2 @@\n-#define RegisterSaver_LiveVSReg(regname) \\\n-  { RegisterSaver::vs_reg,      regname->encoding(), regname->as_VMReg() }\n+#define RegisterSaver_LiveVecReg(regname) \\\n+  { RegisterSaver::vec_reg,      regname->encoding(), regname->as_VMReg() }\n@@ -223,1 +223,1 @@\n-static const RegisterSaver::LiveRegType RegisterSaver_LiveVSRegs[] = {\n+static const RegisterSaver::LiveRegType RegisterSaver_LiveVecRegs[] = {\n@@ -225,1 +225,1 @@\n-  \/\/ live vector scalar registers (optional, only these ones are used by C2):\n+  \/\/ live vector registers (optional, only these ones are used by C2):\n@@ -227,32 +227,32 @@\n-  RegisterSaver_LiveVSReg( VSR32 ),\n-  RegisterSaver_LiveVSReg( VSR33 ),\n-  RegisterSaver_LiveVSReg( VSR34 ),\n-  RegisterSaver_LiveVSReg( VSR35 ),\n-  RegisterSaver_LiveVSReg( VSR36 ),\n-  RegisterSaver_LiveVSReg( VSR37 ),\n-  RegisterSaver_LiveVSReg( VSR38 ),\n-  RegisterSaver_LiveVSReg( VSR39 ),\n-  RegisterSaver_LiveVSReg( VSR40 ),\n-  RegisterSaver_LiveVSReg( VSR41 ),\n-  RegisterSaver_LiveVSReg( VSR42 ),\n-  RegisterSaver_LiveVSReg( VSR43 ),\n-  RegisterSaver_LiveVSReg( VSR44 ),\n-  RegisterSaver_LiveVSReg( VSR45 ),\n-  RegisterSaver_LiveVSReg( VSR46 ),\n-  RegisterSaver_LiveVSReg( VSR47 ),\n-  RegisterSaver_LiveVSReg( VSR48 ),\n-  RegisterSaver_LiveVSReg( VSR49 ),\n-  RegisterSaver_LiveVSReg( VSR50 ),\n-  RegisterSaver_LiveVSReg( VSR51 ),\n-  RegisterSaver_LiveVSReg( VSR52 ),\n-  RegisterSaver_LiveVSReg( VSR53 ),\n-  RegisterSaver_LiveVSReg( VSR54 ),\n-  RegisterSaver_LiveVSReg( VSR55 ),\n-  RegisterSaver_LiveVSReg( VSR56 ),\n-  RegisterSaver_LiveVSReg( VSR57 ),\n-  RegisterSaver_LiveVSReg( VSR58 ),\n-  RegisterSaver_LiveVSReg( VSR59 ),\n-  RegisterSaver_LiveVSReg( VSR60 ),\n-  RegisterSaver_LiveVSReg( VSR61 ),\n-  RegisterSaver_LiveVSReg( VSR62 ),\n-  RegisterSaver_LiveVSReg( VSR63 )\n+  RegisterSaver_LiveVecReg( VR0 ),\n+  RegisterSaver_LiveVecReg( VR1 ),\n+  RegisterSaver_LiveVecReg( VR2 ),\n+  RegisterSaver_LiveVecReg( VR3 ),\n+  RegisterSaver_LiveVecReg( VR4 ),\n+  RegisterSaver_LiveVecReg( VR5 ),\n+  RegisterSaver_LiveVecReg( VR6 ),\n+  RegisterSaver_LiveVecReg( VR7 ),\n+  RegisterSaver_LiveVecReg( VR8 ),\n+  RegisterSaver_LiveVecReg( VR9 ),\n+  RegisterSaver_LiveVecReg( VR10 ),\n+  RegisterSaver_LiveVecReg( VR11 ),\n+  RegisterSaver_LiveVecReg( VR12 ),\n+  RegisterSaver_LiveVecReg( VR13 ),\n+  RegisterSaver_LiveVecReg( VR14 ),\n+  RegisterSaver_LiveVecReg( VR15 ),\n+  RegisterSaver_LiveVecReg( VR16 ),\n+  RegisterSaver_LiveVecReg( VR17 ),\n+  RegisterSaver_LiveVecReg( VR18 ),\n+  RegisterSaver_LiveVecReg( VR19 ),\n+  RegisterSaver_LiveVecReg( VR20 ),\n+  RegisterSaver_LiveVecReg( VR21 ),\n+  RegisterSaver_LiveVecReg( VR22 ),\n+  RegisterSaver_LiveVecReg( VR23 ),\n+  RegisterSaver_LiveVecReg( VR24 ),\n+  RegisterSaver_LiveVecReg( VR25 ),\n+  RegisterSaver_LiveVecReg( VR26 ),\n+  RegisterSaver_LiveVecReg( VR27 ),\n+  RegisterSaver_LiveVecReg( VR28 ),\n+  RegisterSaver_LiveVecReg( VR29 ),\n+  RegisterSaver_LiveVecReg( VR30 ),\n+  RegisterSaver_LiveVecReg( VR31 )\n@@ -280,1 +280,1 @@\n-  const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) \/\n+  const int vecregstosave_num    = save_vectors ? (sizeof(RegisterSaver_LiveVecRegs) \/\n@@ -283,1 +283,1 @@\n-  const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;\n+  const int register_save_size   = regstosave_num * reg_size + vecregstosave_num * vec_reg_size;\n@@ -301,2 +301,2 @@\n-  __ std(R31, frame_size_in_bytes -   reg_size - vsregstosave_num * vs_reg_size, R1_SP);\n-  __ std(R30, frame_size_in_bytes - 2*reg_size - vsregstosave_num * vs_reg_size, R1_SP);\n+  __ std(R31, frame_size_in_bytes -   reg_size - vecregstosave_num * vec_reg_size, R1_SP);\n+  __ std(R30, frame_size_in_bytes - 2*reg_size - vecregstosave_num * vec_reg_size, R1_SP);\n@@ -363,4 +363,4 @@\n-    assert(is_even(vsregstosave_num), \"expectation\");\n-    for (int i = 0; i < vsregstosave_num; i += 2) {\n-      int reg_num = RegisterSaver_LiveVSRegs[i].reg_num;\n-      assert(RegisterSaver_LiveVSRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n+    assert(is_even(vecregstosave_num), \"expectation\");\n+    for (int i = 0; i < vecregstosave_num; i += 2) {\n+      int reg_num = RegisterSaver_LiveVecRegs[i].reg_num;\n+      assert(RegisterSaver_LiveVecRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n@@ -368,1 +368,1 @@\n-      __ stxvp(as_VectorSRegister(reg_num), offset, R1_SP);\n+      __ stxvp(as_VectorRegister(reg_num).to_vsr(), offset, R1_SP);\n@@ -372,3 +372,3 @@\n-                              RegisterSaver_LiveVSRegs[i LITTLE_ENDIAN_ONLY(+1) ].vmreg);\n-        map->set_callee_saved(VMRegImpl::stack2reg((offset + vs_reg_size) >> 2),\n-                              RegisterSaver_LiveVSRegs[i BIG_ENDIAN_ONLY(+1) ].vmreg);\n+                              RegisterSaver_LiveVecRegs[i LITTLE_ENDIAN_ONLY(+1) ].vmreg);\n+        map->set_callee_saved(VMRegImpl::stack2reg((offset + vec_reg_size) >> 2),\n+                              RegisterSaver_LiveVecRegs[i BIG_ENDIAN_ONLY(+1) ].vmreg);\n@@ -376,1 +376,1 @@\n-      offset += (2 * vs_reg_size);\n+      offset += (2 * vec_reg_size);\n@@ -379,2 +379,2 @@\n-    for (int i = 0; i < vsregstosave_num; i++) {\n-      int reg_num = RegisterSaver_LiveVSRegs[i].reg_num;\n+    for (int i = 0; i < vecregstosave_num; i++) {\n+      int reg_num = RegisterSaver_LiveVecRegs[i].reg_num;\n@@ -383,1 +383,1 @@\n-        __ stxv(as_VectorSRegister(reg_num), offset, R1_SP);\n+        __ stxv(as_VectorRegister(reg_num)->to_vsr(), offset, R1_SP);\n@@ -386,1 +386,1 @@\n-        __ stxvd2x(as_VectorSRegister(reg_num), R31, R1_SP);\n+        __ stxvd2x(as_VectorRegister(reg_num)->to_vsr(), R31, R1_SP);\n@@ -390,1 +390,1 @@\n-        VMReg vsr = RegisterSaver_LiveVSRegs[i].vmreg;\n+        VMReg vsr = RegisterSaver_LiveVecRegs[i].vmreg;\n@@ -393,1 +393,1 @@\n-      offset += vs_reg_size;\n+      offset += vec_reg_size;\n@@ -414,1 +414,1 @@\n-  const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) \/\n+  const int vecregstosave_num    = save_vectors ? (sizeof(RegisterSaver_LiveVecRegs) \/\n@@ -417,1 +417,1 @@\n-  const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;\n+  const int register_save_size   = regstosave_num * reg_size + vecregstosave_num * vec_reg_size;\n@@ -459,3 +459,3 @@\n-    for (int i = 0; i < vsregstosave_num; i += 2) {\n-      int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;\n-      assert(RegisterSaver_LiveVSRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n+    for (int i = 0; i < vecregstosave_num; i += 2) {\n+      int reg_num  = RegisterSaver_LiveVecRegs[i].reg_num;\n+      assert(RegisterSaver_LiveVecRegs[i + 1].reg_num == reg_num + 1, \"or use other instructions!\");\n@@ -463,1 +463,1 @@\n-      __ lxvp(as_VectorSRegister(reg_num), offset, R1_SP);\n+      __ lxvp(as_VectorRegister(reg_num).to_vsr(), offset, R1_SP);\n@@ -465,1 +465,1 @@\n-      offset += (2 * vs_reg_size);\n+      offset += (2 * vec_reg_size);\n@@ -468,2 +468,2 @@\n-    for (int i = 0; i < vsregstosave_num; i++) {\n-      int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;\n+    for (int i = 0; i < vecregstosave_num; i++) {\n+      int reg_num  = RegisterSaver_LiveVecRegs[i].reg_num;\n@@ -472,1 +472,1 @@\n-        __ lxv(as_VectorSRegister(reg_num), offset, R1_SP);\n+        __ lxv(as_VectorRegister(reg_num).to_vsr(), offset, R1_SP);\n@@ -475,1 +475,1 @@\n-        __ lxvd2x(as_VectorSRegister(reg_num), R31, R1_SP);\n+        __ lxvd2x(as_VectorRegister(reg_num).to_vsr(), R31, R1_SP);\n@@ -478,1 +478,1 @@\n-      offset += vs_reg_size;\n+      offset += vec_reg_size;\n@@ -489,1 +489,1 @@\n-  __ ld(R31, frame_size_in_bytes - reg_size - vsregstosave_num * vs_reg_size, R1_SP);\n+  __ ld(R31, frame_size_in_bytes - reg_size - vecregstosave_num * vec_reg_size, R1_SP);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":70,"deletions":70,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 0)                                          \\\n+\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubDeclarations_ppc.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4941,0 +4941,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for ppc\n+  }\n+\n@@ -5070,0 +5074,3 @@\n+    case preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  for ( ; i < ConcreteRegisterImpl::max_vsr; ) {\n+  for ( ; i < ConcreteRegisterImpl::max_vr; ) {\n","filename":"src\/hotspot\/cpu\/ppc\/vmreg_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-inline bool is_VectorSRegister() {\n+inline bool is_VectorRegister() {\n@@ -40,1 +40,1 @@\n-         value() < ConcreteRegisterImpl::max_vsr;\n+         value() < ConcreteRegisterImpl::max_vr;\n@@ -44,1 +44,1 @@\n-  return value() >= ConcreteRegisterImpl::max_vsr &&\n+  return value() >= ConcreteRegisterImpl::max_vr &&\n@@ -63,3 +63,3 @@\n-inline VectorSRegister as_VectorSRegister() {\n-  assert(is_VectorSRegister(), \"must be\");\n-  return ::as_VectorSRegister((value() - ConcreteRegisterImpl::max_fpr) >> 2);\n+inline VectorRegister as_VectorRegister() {\n+  assert(is_VectorRegister(), \"must be\");\n+  return ::as_VectorRegister((value() - ConcreteRegisterImpl::max_fpr) >> 2);\n@@ -71,1 +71,1 @@\n-  if (is_VectorSRegister()) {\n+  if (is_VectorRegister()) {\n","filename":"src\/hotspot\/cpu\/ppc\/vmreg_ppc.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-inline VMReg VectorSRegister::as_VMReg() const {\n+inline VMReg VectorRegister::as_VMReg() const {\n@@ -49,1 +49,1 @@\n-  return VMRegImpl::as_VMReg((encoding()) + ConcreteRegisterImpl::max_vsr);\n+  return VMRegImpl::as_VMReg((encoding()) + ConcreteRegisterImpl::max_vr);\n","filename":"src\/hotspot\/cpu\/ppc\/vmreg_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,5 +46,5 @@\n-define_pd_global(intx, InitialCodeCacheSize,         160*K);\n-define_pd_global(intx, ReservedCodeCacheSize,        32*M );\n-define_pd_global(intx, NonProfiledCodeHeapSize,      13*M );\n-define_pd_global(intx, ProfiledCodeHeapSize,         14*M );\n-define_pd_global(intx, NonNMethodCodeHeapSize,       5*M  );\n+define_pd_global(size_t, InitialCodeCacheSize,       160*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,      32*M );\n+define_pd_global(size_t, NonProfiledCodeHeapSize,    13*M );\n+define_pd_global(size_t, ProfiledCodeHeapSize,       14*M );\n+define_pd_global(size_t, NonNMethodCodeHeapSize,     5*M  );\n@@ -52,3 +52,3 @@\n-define_pd_global(intx, CodeCacheExpansionSize,       32*K );\n-define_pd_global(uintx, CodeCacheMinBlockLength,     1);\n-define_pd_global(uintx, CodeCacheMinimumUseSpace,    400*K);\n+define_pd_global(size_t, CodeCacheExpansionSize,     32*K );\n+define_pd_global(size_t, CodeCacheMinBlockLength,    1);\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,   400*K);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_globals_riscv.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2173,2 +2173,1 @@\n-      assert(false, \"Should go to BoolTest::le case\");\n-      ShouldNotReachHere();\n+      cmov_cmp_fp_ge(op1, op2, dst, src, is_single);\n@@ -2180,2 +2179,1 @@\n-      assert(false, \"Should go to BoolTest::lt case\");\n-      ShouldNotReachHere();\n+      cmov_cmp_fp_gt(op1, op2, dst, src, is_single);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-define_pd_global(intx, InitialCodeCacheSize,         2496*K); \/\/ Integral multiple of CodeCacheExpansionSize\n-define_pd_global(intx, CodeCacheExpansionSize,       64*K);\n+define_pd_global(size_t, InitialCodeCacheSize,       2496*K); \/\/ Integral multiple of CodeCacheExpansionSize\n+define_pd_global(size_t, CodeCacheExpansionSize,     64*K);\n@@ -72,6 +72,6 @@\n-define_pd_global(intx, ReservedCodeCacheSize,        48*M);\n-define_pd_global(intx, NonProfiledCodeHeapSize,      21*M);\n-define_pd_global(intx, ProfiledCodeHeapSize,         22*M);\n-define_pd_global(intx, NonNMethodCodeHeapSize,       5*M );\n-define_pd_global(uintx, CodeCacheMinBlockLength,     6);\n-define_pd_global(uintx, CodeCacheMinimumUseSpace,    400*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,      48*M);\n+define_pd_global(size_t, NonProfiledCodeHeapSize,    21*M);\n+define_pd_global(size_t, ProfiledCodeHeapSize,       22*M);\n+define_pd_global(size_t, NonNMethodCodeHeapSize,     5*M );\n+define_pd_global(size_t, CodeCacheMinBlockLength,    6);\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,   400*K);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_globals_riscv.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(size_t, CodeCacheSegmentSize,   64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1271,0 +1271,12 @@\n+\/\/\n+\/\/ For CmpF\/D + CMoveI\/L, ordered ones are quite straight and simple,\n+\/\/ so, just list behaviour of unordered ones as follow.\n+\/\/\n+\/\/ Set dst (CMoveI (Binary cop (CmpF\/D op1 op2)) (Binary dst src))\n+\/\/ (If one or both inputs to the compare are NaN, then)\n+\/\/    1. (op1 lt op2) => true  => CMove: dst = src\n+\/\/    2. (op1 le op2) => true  => CMove: dst = src\n+\/\/    3. (op1 gt op2) => false => CMove: dst = dst\n+\/\/    4. (op1 ge op2) => false => CMove: dst = dst\n+\/\/    5. (op1 eq op2) => false => CMove: dst = dst\n+\/\/    6. (op1 ne op2) => true  => CMove: dst = src\n@@ -1272,5 +1284,0 @@\n-\/\/ Move src to dst only if cmp1 == cmp2,\n-\/\/ otherwise leave dst unchanged, including the case where one of them is NaN.\n-\/\/ Clarification:\n-\/\/   java code      :  cmp1 != cmp2 ? dst : src\n-\/\/   transformed to :  CMove dst, (cmp1 eq cmp2), dst, src\n@@ -1292,1 +1299,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 == cmp2\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 == cmp2\n@@ -1301,5 +1308,0 @@\n-\/\/ Keep dst unchanged only if cmp1 == cmp2,\n-\/\/ otherwise move src to dst, including the case where one of them is NaN.\n-\/\/ Clarification:\n-\/\/   java code      :  cmp1 == cmp2 ? dst : src\n-\/\/   transformed to :  CMove dst, (cmp1 ne cmp2), dst, src\n@@ -1321,1 +1323,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 != cmp2, including the case of NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 != cmp2, including the case of NaN\n@@ -1330,8 +1332,0 @@\n-\/\/ When cmp1 <= cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n-\/\/ Clarification\n-\/\/   scenario 1:\n-\/\/     java code      :  cmp2 < cmp1 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n-\/\/   scenario 2:\n-\/\/     java code      :  cmp1 > cmp2 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n@@ -1353,1 +1347,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 <= cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 <= cmp2 or either is NaN\n@@ -1362,8 +1356,24 @@\n-\/\/ When cmp1 < cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n-\/\/ Clarification\n-\/\/   scenario 1:\n-\/\/     java code      :  cmp2 <= cmp1 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n-\/\/   scenario 2:\n-\/\/     java code      :  cmp1 >= cmp2 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n+void MacroAssembler::cmov_cmp_fp_ge(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      fle_s(t0, cmp2, cmp1);\n+    } else {\n+      fle_d(t0, cmp2, cmp1);\n+    }\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 < cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 >= cmp2\n+    float_blt(cmp1, cmp2, no_set, false, true);\n+  } else {\n+    double_blt(cmp1, cmp2, no_set, false, true);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n@@ -1385,1 +1395,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 < cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 < cmp2 or either is NaN\n@@ -1394,0 +1404,24 @@\n+void MacroAssembler::cmov_cmp_fp_gt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      flt_s(t0, cmp2, cmp1);\n+    } else {\n+      flt_d(t0, cmp2, cmp1);\n+    }\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 <= cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 > cmp2\n+    float_ble(cmp1, cmp2, no_set, false, true);\n+  } else {\n+    double_ble(cmp1, cmp2, no_set, false, true);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n@@ -3742,1 +3776,1 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg) {\n@@ -3744,3 +3778,0 @@\n-  if (acquire) {\n-    membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n-  }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":65,"deletions":34,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg = t0);\n+  void safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp_reg = t0);\n@@ -663,0 +663,1 @@\n+  void cmov_cmp_fp_ge(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n@@ -664,0 +665,1 @@\n+  void cmov_cmp_fp_gt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1496,1 +1496,1 @@\n-    __ safepoint_poll(*code_stub, true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1780,9 +1780,1 @@\n-    \/\/ We need an acquire here to ensure that any subsequent load of the\n-    \/\/ global SafepointSynchronize::_state flag is ordered after this load\n-    \/\/ of the thread-local polling word. We don't want this poll to\n-    \/\/ return false (i.e. not safepointing) and a later poll of the global\n-    \/\/ SafepointSynchronize::_state spuriously to return true.\n-    \/\/ This is to avoid a race when we're in a native->Java transition\n-    \/\/ racing the code which wakes up from a safepoint.\n-\n-    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 0)                                          \\\n+\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubDeclarations_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6663,0 +6663,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for riscv\n+  }\n+\n@@ -6818,0 +6822,3 @@\n+    case preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1232,9 +1232,1 @@\n-    \/\/ We need an acquire here to ensure that any subsequent load of the\n-    \/\/ global SafepointSynchronize::_state flag is ordered after this load\n-    \/\/ of the thread-local polling word. We don't want this poll to\n-    \/\/ return false (i.e. not safepointing) and a later poll of the global\n-    \/\/ SafepointSynchronize::_state spuriously to return true.\n-    \/\/\n-    \/\/ This is to avoid a race when we're in a native->Java transition\n-    \/\/ racing the code which wakes up from a safepoint.\n-    __ safepoint_poll(L, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(L, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1391,1 +1383,1 @@\n-  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-  \/\/ Misc Intrinsics could depend on RVV\n+  \/\/ Misc Intrinsics that could depend on RVV.\n@@ -208,1 +208,1 @@\n-  if (UseZba || UseRVV) {\n+  if (!AvoidUnalignedAccesses && (UseZba || UseRVV)) {\n@@ -214,1 +214,1 @@\n-      warning(\"CRC32 intrinsic requires Zba or RVV instructions (not available on this CPU)\");\n+      warning(\"CRC32 intrinsic are not available on this CPU.\");\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,7 +47,7 @@\n-define_pd_global(uintx,    ReservedCodeCacheSize,        32*M);\n-define_pd_global(uintx,    NonProfiledCodeHeapSize,      13*M);\n-define_pd_global(uintx,    ProfiledCodeHeapSize,         14*M);\n-define_pd_global(uintx,    NonNMethodCodeHeapSize,       5*M);\n-define_pd_global(uintx,    CodeCacheExpansionSize,       32*K);\n-define_pd_global(uintx,    CodeCacheMinBlockLength,      1);\n-define_pd_global(uintx,    CodeCacheMinimumUseSpace,     400*K);\n+define_pd_global(size_t,   ReservedCodeCacheSize,        32*M);\n+define_pd_global(size_t,   NonProfiledCodeHeapSize,      13*M);\n+define_pd_global(size_t,   ProfiledCodeHeapSize,         14*M);\n+define_pd_global(size_t,   NonNMethodCodeHeapSize,       5*M);\n+define_pd_global(size_t,   CodeCacheExpansionSize,       32*K);\n+define_pd_global(size_t,   CodeCacheMinBlockLength,      1);\n+define_pd_global(size_t,   CodeCacheMinimumUseSpace,     400*K);\n@@ -57,1 +57,1 @@\n-define_pd_global(uintx,    InitialCodeCacheSize,         160*K);\n+define_pd_global(size_t,   InitialCodeCacheSize,         160*K);\n","filename":"src\/hotspot\/cpu\/s390\/c1_globals_s390.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,6 +70,6 @@\n-define_pd_global(uintx, InitialCodeCacheSize,        2048*K); \/\/ Integral multiple of CodeCacheExpansionSize\n-define_pd_global(uintx, ReservedCodeCacheSize,       48*M);\n-define_pd_global(uintx, NonProfiledCodeHeapSize,     21*M);\n-define_pd_global(uintx, ProfiledCodeHeapSize,        22*M);\n-define_pd_global(uintx, NonNMethodCodeHeapSize,      5*M);\n-define_pd_global(uintx, CodeCacheExpansionSize,      64*K);\n+define_pd_global(size_t, InitialCodeCacheSize,       2048*K); \/\/ Integral multiple of CodeCacheExpansionSize\n+define_pd_global(size_t, ReservedCodeCacheSize,      48*M);\n+define_pd_global(size_t, NonProfiledCodeHeapSize,    21*M);\n+define_pd_global(size_t, ProfiledCodeHeapSize,       22*M);\n+define_pd_global(size_t, NonNMethodCodeHeapSize,     5*M);\n+define_pd_global(size_t, CodeCacheExpansionSize,     64*K);\n@@ -79,2 +79,2 @@\n-define_pd_global(uintx, CodeCacheMinBlockLength,     4);\n-define_pd_global(uintx, CodeCacheMinimumUseSpace,    400*K);\n+define_pd_global(size_t, CodeCacheMinBlockLength,    4);\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,   400*K);\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,        256);\n+define_pd_global(size_t, CodeCacheSegmentSize,       256);\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 0)                                          \\\n+\n+\n","filename":"src\/hotspot\/cpu\/s390\/stubDeclarations_s390.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3286,0 +3286,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for s390\n+  }\n+\n@@ -3421,0 +3425,3 @@\n+    case preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,5 +45,5 @@\n-define_pd_global(uintx,  InitialCodeCacheSize,         160*K);\n-define_pd_global(uintx,  ReservedCodeCacheSize,        32*M );\n-define_pd_global(uintx,  NonProfiledCodeHeapSize,      13*M );\n-define_pd_global(uintx,  ProfiledCodeHeapSize,         14*M );\n-define_pd_global(uintx,  NonNMethodCodeHeapSize,       5*M  );\n+define_pd_global(size_t, InitialCodeCacheSize,         160*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,        32*M );\n+define_pd_global(size_t, NonProfiledCodeHeapSize,      13*M );\n+define_pd_global(size_t, ProfiledCodeHeapSize,         14*M );\n+define_pd_global(size_t, NonNMethodCodeHeapSize,       5*M  );\n@@ -51,3 +51,3 @@\n-define_pd_global(uintx,  CodeCacheExpansionSize,       32*K );\n-define_pd_global(uintx,  CodeCacheMinBlockLength,      1    );\n-define_pd_global(uintx,  CodeCacheMinimumUseSpace,     400*K);\n+define_pd_global(size_t, CodeCacheExpansionSize,       32*K );\n+define_pd_global(size_t, CodeCacheMinBlockLength,      1    );\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,     400*K);\n","filename":"src\/hotspot\/cpu\/x86\/c1_globals_x86.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4687,0 +4687,1 @@\n+  \/\/ APX REX2 encoding for pop(dst) increases the stub size by 1 byte.\n@@ -4719,1 +4720,3 @@\n-  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, 23, convertF2I_slowpath);\n+  \/\/ Using the APX extended general purpose registers increases the instruction encoding size by 1 byte.\n+  int max_size = 23 + (UseAPX ? 1 : 0);\n+  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, max_size, convertF2I_slowpath);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-define_pd_global(uintx, InitialCodeCacheSize,        2496*K); \/\/ Integral multiple of CodeCacheExpansionSize\n-define_pd_global(uintx, CodeCacheExpansionSize,      64*K);\n+define_pd_global(size_t, InitialCodeCacheSize,       2496*K); \/\/ Integral multiple of CodeCacheExpansionSize\n+define_pd_global(size_t, CodeCacheExpansionSize,     64*K);\n@@ -63,2 +63,2 @@\n-define_pd_global(uintx, InitialCodeCacheSize,        2304*K); \/\/ Integral multiple of CodeCacheExpansionSize\n-define_pd_global(uintx, CodeCacheExpansionSize,      32*K);\n+define_pd_global(size_t, InitialCodeCacheSize,       2304*K); \/\/ Integral multiple of CodeCacheExpansionSize\n+define_pd_global(size_t, CodeCacheExpansionSize,     32*K);\n@@ -82,6 +82,6 @@\n-define_pd_global(uintx, ReservedCodeCacheSize,       48*M);\n-define_pd_global(uintx, NonProfiledCodeHeapSize,     21*M);\n-define_pd_global(uintx, ProfiledCodeHeapSize,        22*M);\n-define_pd_global(uintx, NonNMethodCodeHeapSize,      5*M );\n-define_pd_global(uintx, CodeCacheMinBlockLength,     6);\n-define_pd_global(uintx, CodeCacheMinimumUseSpace,    400*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,      48*M);\n+define_pd_global(size_t, NonProfiledCodeHeapSize,    21*M);\n+define_pd_global(size_t, ProfiledCodeHeapSize,       22*M);\n+define_pd_global(size_t, NonNMethodCodeHeapSize,     5*M );\n+define_pd_global(size_t, CodeCacheMinBlockLength,    6);\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,   400*K);\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(size_t, CodeCacheSegmentSize,   64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 500)                                        \\\n+\n+\n@@ -242,1 +249,1 @@\n-  do_arch_blob(final, 31000                                             \\\n+  do_arch_blob(final, 33000                                             \\\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4068,0 +4068,5 @@\n+void StubGenerator::generate_preuniverse_stubs() {\n+  \/\/ atomic calls\n+  StubRoutines::_fence_entry                = generate_orderaccess_fence();\n+}\n+\n@@ -4103,3 +4108,0 @@\n-  \/\/ atomic calls\n-  StubRoutines::_fence_entry                = generate_orderaccess_fence();\n-\n@@ -4517,0 +4519,3 @@\n+  case preuniverse_id:\n+    generate_preuniverse_stubs();\n+    break;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -640,0 +640,1 @@\n+  void generate_preuniverse_stubs();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2114,1 +2114,1 @@\n-  return (is_intel_family_core() &&\n+  return (is_intel_server_family() &&\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,4 +41,4 @@\n-define_pd_global(uintx, CodeCacheSegmentSize, 64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n-define_pd_global(intx,  CodeEntryAlignment,   32);\n-define_pd_global(intx,  OptoLoopAlignment,    16);\n-define_pd_global(intx,  InlineSmallCode,      1000);\n+define_pd_global(size_t, CodeCacheSegmentSize, 64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(intx,   CodeEntryAlignment,   32);\n+define_pd_global(intx,   OptoLoopAlignment,    16);\n+define_pd_global(intx,   InlineSmallCode,      1000);\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,7 @@\n+#define STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub,                      \\\n+                                          do_arch_blob,                 \\\n+                                          do_arch_entry,                \\\n+                                          do_arch_entry_init)           \\\n+  do_arch_blob(preuniverse, 0)                                          \\\n+\n+\n","filename":"src\/hotspot\/cpu\/zero\/stubDeclarations_zero.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -181,0 +181,4 @@\n+  void generate_preuniverse_stubs() {\n+    StubRoutines::_fence_entry               = ShouldNotCallThisStub();\n+  }\n+\n@@ -197,1 +201,0 @@\n-    StubRoutines::_fence_entry               = ShouldNotCallThisStub();\n@@ -217,0 +220,3 @@\n+    case preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_AIX_C1_GLOBALS_AIX_HPP\n-#define OS_AIX_C1_GLOBALS_AIX_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ client compiler. (see c1_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_AIX_C1_GLOBALS_AIX_HPP\n","filename":"src\/hotspot\/os\/aix\/c1_globals_aix.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2013 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_AIX_C2_GLOBALS_AIX_HPP\n-#define OS_AIX_C2_GLOBALS_AIX_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ server compiler. (see c2_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_AIX_C2_GLOBALS_AIX_HPP\n","filename":"src\/hotspot\/os\/aix\/c2_globals_aix.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_BSD_C1_GLOBALS_BSD_HPP\n-#define OS_BSD_C1_GLOBALS_BSD_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ client compiler. (see c1_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_BSD_C1_GLOBALS_BSD_HPP\n","filename":"src\/hotspot\/os\/bsd\/c1_globals_bsd.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_BSD_C2_GLOBALS_BSD_HPP\n-#define OS_BSD_C2_GLOBALS_BSD_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ server compiler. (see c2_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_BSD_C2_GLOBALS_BSD_HPP\n","filename":"src\/hotspot\/os\/bsd\/c2_globals_bsd.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_LINUX_C1_GLOBALS_LINUX_HPP\n-#define OS_LINUX_C1_GLOBALS_LINUX_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ client compiler. (see c1_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_LINUX_C1_GLOBALS_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/c1_globals_linux.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_LINUX_C2_GLOBALS_LINUX_HPP\n-#define OS_LINUX_C2_GLOBALS_LINUX_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ server compiler. (see c2_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_LINUX_C2_GLOBALS_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/c2_globals_linux.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_WINDOWS_C1_GLOBALS_WINDOWS_HPP\n-#define OS_WINDOWS_C1_GLOBALS_WINDOWS_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ client compiler. (see c1_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_WINDOWS_C1_GLOBALS_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/c1_globals_windows.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_WINDOWS_C2_GLOBALS_WINDOWS_HPP\n-#define OS_WINDOWS_C2_GLOBALS_WINDOWS_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/\n-\/\/ Sets the default values for operating system dependent flags used by the\n-\/\/ server compiler. (see c2_globals.hpp)\n-\/\/\n-\n-#endif \/\/ OS_WINDOWS_C2_GLOBALS_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/c2_globals_windows.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,7 @@\n-  void do_NewInstance    (NewInstance*     x) { \/* nothing to do *\/ }\n+  void do_NewInstance    (NewInstance*     x) {\n+    ciInstanceKlass* c = x->klass();\n+    if (c != nullptr && !c->is_initialized() &&\n+        (!c->is_loaded() || c->has_class_initializer())) {\n+      kill_memory();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"c1\/c1_globals_pd.hpp\"\n@@ -31,0 +30,1 @@\n+#include CPU_HEADER(c1_globals)\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_C1_C1_GLOBALS_PD_HPP\n-#define SHARE_C1_C1_GLOBALS_PD_HPP\n-\n-#include \"runtime\/globals_shared.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#include CPU_HEADER(c1_globals)\n-#include OS_HEADER(c1_globals)\n-\n-#endif \/\/ SHARE_C1_C1_GLOBALS_PD_HPP\n","filename":"src\/hotspot\/share\/c1\/c1_globals_pd.hpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -729,2 +730,2 @@\n-  \/\/ AOT profiles are supported only in the JEP 483 workflow.\n-  bool can_dump_profiles = AOTClassLinking && new_aot_flags_used();\n+  \/\/ AOT profiles and AOT-compiled code are supported only in the JEP 483 workflow.\n+  bool can_dump_profile_and_compiled_code = AOTClassLinking && new_aot_flags_used();\n@@ -732,1 +733,1 @@\n-  if (is_dumping_preimage_static_archive() && can_dump_profiles) {\n+  if (is_dumping_preimage_static_archive() && can_dump_profile_and_compiled_code) {\n@@ -736,1 +737,2 @@\n-  } else if (is_dumping_final_static_archive() && can_dump_profiles) {\n+    AOTCodeCache::disable_caching(); \/\/ No AOT code generation during training run\n+  } else if (is_dumping_final_static_archive() && can_dump_profile_and_compiled_code) {\n@@ -740,0 +742,2 @@\n+    AOTCodeCache::enable_caching(); \/\/ Generate AOT code during assembly phase.\n+    disable_dumping_aot_code();     \/\/ Don't dump AOT code until metadata and heap are dumped.\n@@ -744,0 +748,1 @@\n+    AOTCodeCache::enable_caching();\n@@ -747,0 +752,1 @@\n+    AOTCodeCache::disable_caching();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -300,0 +301,2 @@\n+  \/\/ Which JIT compier is used\n+  _compiler_type = (u1)CompilerConfig::compiler_type();\n@@ -996,1 +999,1 @@\n-     aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n+    aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n@@ -2011,0 +2014,17 @@\n+  bool jvmci_compiler_is_enabled = CompilerConfig::is_jvmci_compiler_enabled();\n+  CompilerType compiler_type = CompilerConfig::compiler_type();\n+  CompilerType archive_compiler_type = CompilerType(_compiler_type);\n+  \/\/ JVMCI compiler does different type profiling settigns and generate\n+  \/\/ different code. We can't use archive which was produced\n+  \/\/ without it and reverse.\n+  \/\/ Only allow mix when JIT compilation is disabled.\n+  \/\/ Interpreter is used by default when dumping archive.\n+  bool intepreter_is_used = (archive_compiler_type == CompilerType::compiler_none) ||\n+                            (compiler_type == CompilerType::compiler_none);\n+  if (!intepreter_is_used &&\n+      jvmci_compiler_is_enabled != (archive_compiler_type == CompilerType::compiler_jvmci)) {\n+    MetaspaceShared::report_loading_error(\"The %s's JIT compiler setting (%s)\"\n+                                          \" does not equal the current setting (%s).\", file_type,\n+                                          compilertype2name(archive_compiler_type), compilertype2name(compiler_type));\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+  u1      _compiler_type;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2024,4 +2024,1 @@\n-    if (AOTCodeCache::is_on_for_use()) {\n-      tty->print_cr(\"\\n\\nAOT Code\");\n-      AOTCodeCache::print_on(tty);\n-    }\n+    AOTCodeCache::print_on(tty);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -632,0 +632,5 @@\n+bool ciInstanceKlass::has_class_initializer() {\n+  VM_ENTRY_MARK;\n+  return get_instanceKlass()->class_initializer() != nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -262,0 +262,2 @@\n+  bool has_class_initializer();\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3905,0 +3905,1 @@\n+  this_klass->set_fieldinfo_search_table(_fieldinfo_search_table);\n@@ -3916,0 +3917,2 @@\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_cp, _fieldinfo_stream, _fieldinfo_search_table));\n+\n@@ -5325,0 +5328,1 @@\n+  assert(nullptr == _fieldinfo_search_table, \"invariant\");\n@@ -5562,0 +5566,1 @@\n+  _fieldinfo_search_table(nullptr),\n@@ -5646,0 +5651,1 @@\n+  _fieldinfo_search_table = nullptr;\n@@ -5670,0 +5676,1 @@\n+  MetadataFactory::free_array<u1>(_loader_data, _fieldinfo_search_table);\n@@ -6262,1 +6269,1 @@\n-\n+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,0 +139,1 @@\n+  Array<u1>* _fieldinfo_search_table;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -685,1 +685,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -972,0 +972,7 @@\n+\n+      Array<u1>* old_table = ik->fieldinfo_search_table();\n+      Array<u1>* search_table = FieldInfoStream::create_search_table(ik->constants(), new_fis, k->class_loader_data(), CHECK);\n+      ik->set_fieldinfo_search_table(search_table);\n+      MetadataFactory::free_array<u1>(k->class_loader_data(), old_table);\n+\n+      DEBUG_ONLY(FieldInfoStream::validate_search_table(ik->constants(), new_fis, search_table));\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -87,2 +86,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -91,0 +89,21 @@\n+\/\/ The sequence of AOT code caching flags and parametters settings.\n+\/\/\n+\/\/ 1. The initial AOT code caching flags setting is done\n+\/\/ during call to CDSConfig::check_vm_args_consistency().\n+\/\/\n+\/\/ 2. The earliest AOT code state check done in compilationPolicy_init()\n+\/\/ where we set number of compiler threads for AOT assembly phase.\n+\/\/\n+\/\/ 3. We determine presence of AOT code in AOT Cache in\n+\/\/ MetaspaceShared::open_static_archive() which is calles\n+\/\/ after compilationPolicy_init() but before codeCache_init().\n+\/\/\n+\/\/ 4. AOTCodeCache::initialize() is called during universe_init()\n+\/\/ and does final AOT state and flags settings.\n+\/\/\n+\/\/ 5. Finally AOTCodeCache::init2() is called after universe_init()\n+\/\/ when all GC settings are finalized.\n+\n+\/\/ Next methods determine which action we do with AOT code depending\n+\/\/ on phase of AOT process: assembly or production.\n+\n@@ -107,0 +126,17 @@\n+\/\/ Next methods could be called regardless AOT code cache status.\n+\/\/ Initially they are called during flags parsing and finilized\n+\/\/ in AOTCodeCache::initialize().\n+void AOTCodeCache::enable_caching() {\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+}\n+\n+void AOTCodeCache::disable_caching() {\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+  FLAG_SET_ERGO(AOTAdapterCaching, false);\n+}\n+\n+bool AOTCodeCache::is_caching_enabled() {\n+  return AOTStubCaching || AOTAdapterCaching;\n+}\n+\n@@ -128,2 +164,4 @@\n-\/\/ This method is called during universe_init()\n-\/\/ and does final AOT state and flags settings.\n+\/\/ It is called from MetaspaceShared::initialize_shared_spaces()\n+\/\/ which is called from universe_init().\n+\/\/ At this point all AOT class linking seetings are finilized\n+\/\/ and AOT cache is open so we can map AOT code region.\n@@ -133,2 +171,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  disable_caching();\n@@ -139,2 +176,1 @@\n-    AOTAdapterCaching = false;\n-    AOTStubCaching = false;\n+    disable_caching();\n@@ -161,2 +197,0 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n@@ -164,0 +198,2 @@\n+    enable_caching();\n+    is_dumping = is_caching_enabled();\n@@ -165,3 +201,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n-    is_using = true;\n+    enable_caching();\n+    is_using = is_caching_enabled();\n@@ -170,0 +205,1 @@\n+    disable_caching();\n@@ -172,1 +208,2 @@\n-  if (!AOTAdapterCaching && !AOTStubCaching) {\n+  if (!(is_dumping || is_using)) {\n+    disable_caching();\n@@ -185,0 +222,1 @@\n+    disable_caching();\n@@ -204,0 +242,1 @@\n+DEBUG_ONLY( bool AOTCodeCache::_passed_init2 = false; )\n@@ -205,2 +244,1 @@\n-\/\/ This method is called after universe_init()\n-\/\/ when all GC settings are finalized.\n+\/\/ It is called after universe_init() when all GC settings are finalized.\n@@ -208,0 +246,1 @@\n+  DEBUG_ONLY( _passed_init2 = true; )\n@@ -223,1 +262,0 @@\n-  table->init_early_stubs();\n@@ -315,0 +353,7 @@\n+void AOTCodeCache::init_early_stubs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_stubs();\n+  }\n+}\n+\n@@ -347,0 +392,1 @@\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -777,0 +823,3 @@\n+  if (!is_on()) {\n+    return false; \/\/ AOT code cache was already dumped and closed.\n+  }\n@@ -1503,0 +1552,1 @@\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -1528,1 +1578,5 @@\n-    return _cache->_table->add_C_string(str);\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n+    AOTCodeAddressTable* table = addr_table();\n+    if (table != nullptr) {\n+      return table->add_C_string(str);\n+    }\n@@ -1535,2 +1589,0 @@\n-    LogStreamHandle(Trace, aot, codecache, stringtable) log; \/\/ ctor outside lock\n-    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -1553,3 +1605,1 @@\n-      if (log.is_enabled()) {\n-        log.print_cr(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n-      }\n+      log_trace(aot, codecache, stringtable)(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n@@ -1709,0 +1759,2 @@\n+\/\/ This is called after initialize() but before init2()\n+\/\/ and _cache is not set yet.\n@@ -1710,4 +1762,4 @@\n-  AOTCodeCache* cache = open_for_use();\n-  if (cache != nullptr) {\n-    uint count = cache->_load_header->entries_count();\n-    uint* search_entries = (uint*)cache->addr(cache->_load_header->entries_offset()); \/\/ [id, index]\n+  if (opened_cache != nullptr && opened_cache->for_use()) {\n+    st->print_cr(\"\\nAOT Code Cache\");\n+    uint count = opened_cache->_load_header->entries_count();\n+    uint* search_entries = (uint*)opened_cache->addr(opened_cache->_load_header->entries_offset()); \/\/ [id, index]\n@@ -1723,1 +1775,1 @@\n-      const char* saved_name = cache->addr(name_offset);\n+      const char* saved_name = opened_cache->addr(name_offset);\n@@ -1725,2 +1777,2 @@\n-      st->print_cr(\"%4u: entry_idx:%4u Kind:%u Id:%u size=%u '%s'\",\n-                   i, index, entry->kind(), entry->id(), entry->size(), saved_name);\n+      st->print_cr(\"%4u: %10s idx:%4u Id:%u size=%u '%s'\",\n+                   i, aot_code_entry_kind_name[entry->kind()], index, entry->id(), entry->size(), saved_name);\n@@ -1728,2 +1780,0 @@\n-  } else {\n-    st->print_cr(\"failed to map code cache\");\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":85,"deletions":35,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,0 +300,1 @@\n+  static void init_early_stubs_table() NOT_CDS_RETURN;\n@@ -349,1 +350,2 @@\n-  static AOTCodeCache*  _cache;\n+  static AOTCodeCache* _cache;\n+  DEBUG_ONLY( static bool _passed_init2; )\n@@ -359,1 +361,1 @@\n-  static AOTCodeCache* cache() { return _cache; }\n+  static AOTCodeCache* cache() { assert(_passed_init2, \"Too early to ask\"); return _cache; }\n@@ -363,1 +365,1 @@\n-  static bool is_on() CDS_ONLY({ return _cache != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n+  static bool is_on() CDS_ONLY({ return cache() != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n@@ -366,4 +368,0 @@\n-\n-  static bool is_dumping_adapter() NOT_CDS_RETURN_(false);\n-  static bool is_using_adapter() NOT_CDS_RETURN_(false);\n-\n@@ -371,0 +369,1 @@\n+  static bool is_dumping_adapter() NOT_CDS_RETURN_(false);\n@@ -372,0 +371,4 @@\n+  static bool is_using_adapter() NOT_CDS_RETURN_(false);\n+  static void enable_caching() NOT_CDS_RETURN;\n+  static void disable_caching() NOT_CDS_RETURN;\n+  static bool is_caching_enabled() NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-  size_t size_initial = MIN2((size_t)InitialCodeCacheSize, rs.size());\n+  size_t size_initial = MIN2(InitialCodeCacheSize, rs.size());\n@@ -1109,1 +1109,1 @@\n-  assert(CodeCacheSegmentSize >= (uintx)CodeEntryAlignment, \"CodeCacheSegmentSize must be large enough to align entry points\");\n+  assert(CodeCacheSegmentSize >= (size_t)CodeEntryAlignment, \"CodeCacheSegmentSize must be large enough to align entry points\");\n@@ -1111,1 +1111,1 @@\n-  assert(CodeCacheSegmentSize >= (uintx)OptoLoopAlignment,  \"CodeCacheSegmentSize must be large enough to align inner loops\");\n+  assert(CodeCacheSegmentSize >= (size_t)OptoLoopAlignment,  \"CodeCacheSegmentSize must be large enough to align inner loops\");\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -575,2 +575,2 @@\n-      int max_count = (ReservedCodeCacheSize - (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3))) \/ (int)buffer_size;\n-      if (count > max_count) {\n+      size_t max_count = (ReservedCodeCacheSize - (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3))) \/ buffer_size;\n+      if ((size_t)count > max_count) {\n@@ -578,1 +578,1 @@\n-        count = MAX2(max_count, min_count);\n+        count = MAX2((int)max_count, min_count);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-                    MIN2(CODE_CACHE_DEFAULT_LIMIT, (size_t)ReservedCodeCacheSize * 5));\n+                    MIN2(CODE_CACHE_DEFAULT_LIMIT, ReservedCodeCacheSize * 5));\n@@ -478,1 +478,1 @@\n-  uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n+  size_t min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n@@ -481,1 +481,1 @@\n-                \"Invalid ReservedCodeCacheSize: %dK. Must be at least InitialCodeCacheSize=%dK.\\n\",\n+                \"Invalid ReservedCodeCacheSize: %zuK. Must be at least InitialCodeCacheSize=%zuK.\\n\",\n@@ -486,1 +486,1 @@\n-                \"Invalid ReservedCodeCacheSize=%dK. Must be at least %uK.\\n\", ReservedCodeCacheSize\/K,\n+                \"Invalid ReservedCodeCacheSize=%zuK. Must be at least %zuK.\\n\", ReservedCodeCacheSize\/K,\n@@ -492,1 +492,1 @@\n-                \"Invalid ReservedCodeCacheSize=%dM. Must be at most %uM.\\n\", ReservedCodeCacheSize\/M,\n+                \"Invalid ReservedCodeCacheSize=%zuM. Must be at most %zuM.\\n\", ReservedCodeCacheSize\/M,\n@@ -497,1 +497,1 @@\n-                \"Invalid NonNMethodCodeHeapSize=%dK. Must be at least %uK.\\n\", NonNMethodCodeHeapSize\/K,\n+                \"Invalid NonNMethodCodeHeapSize=%zuK. Must be at least %zuK.\\n\", NonNMethodCodeHeapSize\/K,\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+  inline static CompilerType compiler_type();\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,0 +134,13 @@\n+\/\/ Return type of most optimizing compiler which is used\n+inline CompilerType CompilerConfig::compiler_type() {\n+  CompilerType compiler_type = CompilerType::compiler_none; \/\/ Interpreter only\n+  if (CompilerConfig::is_c2_enabled()) {\n+    compiler_type = CompilerType::compiler_c2;\n+  } else if (CompilerConfig::is_jvmci_compiler_enabled()) {\n+    compiler_type = CompilerType::compiler_jvmci;\n+  } else if (CompilerConfig::is_c1_enabled()) {\n+    compiler_type = CompilerType::compiler_c1;\n+  }\n+  return compiler_type;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-#include \"c1\/c1_globals_pd.hpp\"\n+#include \"c1\/c1_globals.hpp\"\n@@ -39,1 +39,1 @@\n-#include \"opto\/c2_globals_pd.hpp\"\n+#include \"opto\/c2_globals.hpp\"\n@@ -64,5 +64,5 @@\n-define_pd_global(uintx,  InitialCodeCacheSize,       160*K);\n-define_pd_global(uintx,  ReservedCodeCacheSize,      32*M);\n-define_pd_global(uintx,  NonProfiledCodeHeapSize,    0);\n-define_pd_global(uintx,  ProfiledCodeHeapSize,       0);\n-define_pd_global(uintx,  NonNMethodCodeHeapSize,     32*M);\n+define_pd_global(size_t, InitialCodeCacheSize,       160*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,      32*M);\n+define_pd_global(size_t, NonProfiledCodeHeapSize,    0);\n+define_pd_global(size_t, ProfiledCodeHeapSize,       0);\n+define_pd_global(size_t, NonNMethodCodeHeapSize,     32*M);\n@@ -70,3 +70,3 @@\n-define_pd_global(uintx,  CodeCacheExpansionSize,     32*K);\n-define_pd_global(uintx,  CodeCacheMinBlockLength,    1);\n-define_pd_global(uintx,  CodeCacheMinimumUseSpace,   200*K);\n+define_pd_global(size_t, CodeCacheExpansionSize,     32*K);\n+define_pd_global(size_t, CodeCacheMinBlockLength,    1);\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,   200*K);\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals_pd.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -350,0 +350,4 @@\n+  if (obj_regions > num_available_regions()) {\n+    \/\/ Can't satisfy this allocation; early-return.\n+    return nullptr;\n+  }\n@@ -498,1 +502,1 @@\n-                       \" bytes, heap = %zu bytes\", word_size, reserved.word_size());\n+                       \" bytes, heap = %zu bytes\", word_size * HeapWordSize, reserved.byte_size());\n@@ -1000,1 +1004,1 @@\n-bool G1CollectedHeap::expand(size_t expand_bytes, WorkerThreads* pretouch_workers, double* expand_time_ms) {\n+bool G1CollectedHeap::expand(size_t expand_bytes, WorkerThreads* pretouch_workers) {\n@@ -1012,1 +1016,0 @@\n-  double expand_heap_start_time_sec = os::elapsedTime();\n@@ -1017,4 +1020,0 @@\n-  if (expand_time_ms != nullptr) {\n-    *expand_time_ms = (os::elapsedTime() - expand_heap_start_time_sec) * MILLIUNITS;\n-  }\n-\n@@ -2396,3 +2395,4 @@\n-    double expand_ms = 0.0;\n-    if (!expand(expand_bytes, _workers, &expand_ms)) {\n-      \/\/ We failed to expand the heap. Cannot do anything about it.\n+    Ticks expand_start = Ticks::now();\n+    if (expand(expand_bytes, _workers)) {\n+      double expand_ms = (Ticks::now() - expand_start).seconds() * MILLIUNITS;\n+      phase_times()->record_expand_heap_time(expand_ms);\n@@ -2400,1 +2400,0 @@\n-    phase_times()->record_expand_heap_time(expand_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers = nullptr, double* expand_time_ms = nullptr);\n+  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers);\n@@ -972,1 +972,1 @@\n-    return num_inactive_regions() == 0 && num_free_regions() == 0;\n+    return num_available_regions() == 0;\n@@ -991,1 +991,1 @@\n-  uint num_available_regions() const { return _hrm.num_available_regions(); }\n+  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n@@ -997,1 +997,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -480,4 +480,0 @@\n-  \/\/ Check if we can actually satisfy the allocation.\n-  if (num_regions > num_available_regions()) {\n-    return G1_NO_HRM_INDEX;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,2 +242,0 @@\n-  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -628,0 +628,28 @@\n+bool ShenandoahBarrierC2Support::is_anti_dependent_load_at_control(PhaseIdealLoop* phase, Node* maybe_load, Node* store,\n+                                                                   Node* control) {\n+  return maybe_load->is_Load() && phase->C->can_alias(store->adr_type(), phase->C->get_alias_index(maybe_load->adr_type())) &&\n+         phase->ctrl_or_self(maybe_load) == control;\n+}\n+\n+void ShenandoahBarrierC2Support::maybe_push_anti_dependent_loads(PhaseIdealLoop* phase, Node* maybe_store, Node* control, Unique_Node_List &wq) {\n+  if (!maybe_store->is_Store() && !maybe_store->is_LoadStore()) {\n+    return;\n+  }\n+  Node* mem = maybe_store->in(MemNode::Memory);\n+  for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n+    Node* u = mem->fast_out(i);\n+    if (is_anti_dependent_load_at_control(phase, u, maybe_store, control)) {\n+      wq.push(u);\n+    }\n+  }\n+}\n+\n+void ShenandoahBarrierC2Support::push_data_inputs_at_control(PhaseIdealLoop* phase, Node* n, Node* ctrl, Unique_Node_List &wq) {\n+  for (uint i = 0; i < n->req(); i++) {\n+    Node* in = n->in(i);\n+    if (in != nullptr && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n+      wq.push(in);\n+    }\n+  }\n+}\n+\n@@ -642,16 +670,3 @@\n-      if (m->is_Store() || m->is_LoadStore()) {\n-        \/\/ Take anti-dependencies into account\n-        Node* mem = m->in(MemNode::Memory);\n-        for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n-          Node* u = mem->fast_out(i);\n-          if (u->is_Load() && phase->C->can_alias(m->adr_type(), phase->C->get_alias_index(u->adr_type())) &&\n-              phase->ctrl_or_self(u) == c) {\n-            wq.push(u);\n-          }\n-        }\n-      }\n-      for (uint i = 0; i < m->req(); i++) {\n-        if (m->in(i) != nullptr && phase->ctrl_or_self(m->in(i)) == c) {\n-          wq.push(m->in(i));\n-        }\n-      }\n+      \/\/ Take anti-dependencies into account\n+      maybe_push_anti_dependent_loads(phase, m, c, wq);\n+      push_data_inputs_at_control(phase, m, c, wq);\n@@ -1008,1 +1023,14 @@\n-void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& uses_to_ignore, uint last, PhaseIdealLoop* phase) {\n+void ShenandoahBarrierC2Support::collect_nodes_above_barrier(Unique_Node_List &nodes_above_barrier, PhaseIdealLoop* phase, Node* ctrl, Node* init_raw_mem) {\n+  nodes_above_barrier.clear();\n+  if (phase->has_ctrl(init_raw_mem) && phase->get_ctrl(init_raw_mem) == ctrl && !init_raw_mem->is_Phi()) {\n+    nodes_above_barrier.push(init_raw_mem);\n+  }\n+  for (uint next = 0; next < nodes_above_barrier.size(); next++) {\n+    Node* n = nodes_above_barrier.at(next);\n+    \/\/ Take anti-dependencies into account\n+    maybe_push_anti_dependent_loads(phase, n, ctrl, nodes_above_barrier);\n+    push_data_inputs_at_control(phase, n, ctrl, nodes_above_barrier);\n+  }\n+}\n+\n+void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& nodes_above_barrier, uint last, PhaseIdealLoop* phase) {\n@@ -1019,13 +1047,1 @@\n-  uses_to_ignore.clear();\n-  if (phase->has_ctrl(init_raw_mem) && phase->get_ctrl(init_raw_mem) == ctrl && !init_raw_mem->is_Phi()) {\n-    uses_to_ignore.push(init_raw_mem);\n-  }\n-  for (uint next = 0; next < uses_to_ignore.size(); next++) {\n-    Node *n = uses_to_ignore.at(next);\n-    for (uint i = 0; i < n->req(); i++) {\n-      Node* in = n->in(i);\n-      if (in != nullptr && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n-        uses_to_ignore.push(in);\n-      }\n-    }\n-  }\n+  collect_nodes_above_barrier(nodes_above_barrier, phase, ctrl, init_raw_mem);\n@@ -1037,1 +1053,1 @@\n-        !uses_to_ignore.member(u) &&\n+        !nodes_above_barrier.member(u) &&\n@@ -1041,2 +1057,1 @@\n-      Node* c = old_c;\n-      if (c != ctrl ||\n+      if (old_c != ctrl ||\n@@ -1316,1 +1331,1 @@\n-  Unique_Node_List uses_to_ignore;\n+  Unique_Node_List nodes_above_barriers;\n@@ -1411,1 +1426,1 @@\n-    fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);\n+    fix_ctrl(lrb, region, fixer, uses, nodes_above_barriers, last, phase);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":50,"deletions":35,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+\n+  static void collect_nodes_above_barrier(Unique_Node_List &nodes_above_barrier, PhaseIdealLoop* phase, Node* ctrl,\n+                                          Node* init_raw_mem);\n+\n@@ -66,1 +70,1 @@\n-  static void fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& uses_to_ignore, uint last, PhaseIdealLoop* phase);\n+  static void fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& nodes_above_barrier, uint last, PhaseIdealLoop* phase);\n@@ -79,0 +83,5 @@\n+  static void push_data_inputs_at_control(PhaseIdealLoop* phase, Node* n, Node* ctrl,\n+                                          Unique_Node_List &wq);\n+  static bool is_anti_dependent_load_at_control(PhaseIdealLoop* phase, Node* maybe_load, Node* store, Node* control);\n+\n+  static void maybe_push_anti_dependent_loads(PhaseIdealLoop* phase, Node* maybe_store, Node* control, Unique_Node_List &wq);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -418,4 +418,0 @@\n-\n-  if (heap->mode()->is_generational()) {\n-    heap->old_generation()->card_scan()->mark_read_table_as_clean();\n-  }\n@@ -647,0 +643,4 @@\n+\n+  if (heap->mode()->is_generational()) {\n+    heap->old_generation()->card_scan()->mark_read_table_as_clean();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -139,3 +139,9 @@\n-      if (heap->mode()->is_generational() && _generation->is_young()) {\n-        \/\/ Swap remembered sets for young\n-        _generation->swap_card_tables();\n+      if (heap->mode()->is_generational()) {\n+        \/\/ Clean the read table before swapping it. The end goal here is to have a clean\n+        \/\/ write table, and to have the read table updated with the previous write table.\n+        heap->old_generation()->card_scan()->mark_read_table_as_clean();\n+\n+        if (_generation->is_young()) {\n+          \/\/ Swap remembered sets for young\n+          _generation->swap_card_tables();\n+        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-#define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_int_flag, do_intx_flag, do_uintx_flag) \\\n+#define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_int_flag, do_size_t_flag, do_intx_flag, do_uintx_flag) \\\n@@ -357,1 +357,1 @@\n-  do_uintx_flag(CodeCacheSegmentSize)                                      \\\n+  do_size_t_flag(CodeCacheSegmentSize)                                     \\\n@@ -544,4 +544,5 @@\n-#define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)\n-#define ADD_INT_FLAG(name)   ADD_FLAG(int, name, BOXED_LONG)\n-#define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)\n-#define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)\n+#define ADD_BOOL_FLAG(name)   ADD_FLAG(bool, name, BOXED_BOOLEAN)\n+#define ADD_INT_FLAG(name)    ADD_FLAG(int, name, BOXED_LONG)\n+#define ADD_SIZE_T_FLAG(name) ADD_FLAG(size_t, name, BOXED_LONG)\n+#define ADD_INTX_FLAG(name)   ADD_FLAG(intx, name, BOXED_LONG)\n+#define ADD_UINTX_FLAG(name)  ADD_FLAG(uintx, name, BOXED_LONG)\n@@ -549,1 +550,1 @@\n-  len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);\n+  len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);\n@@ -553,1 +554,1 @@\n-  PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INT_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)\n+  PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INT_FLAG, ADD_SIZE_T_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  _nesting.check(_set_arena); \/\/ Check if a potential reallocation in the arena is safe\n","filename":"src\/hotspot\/share\/libadt\/vectset.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    _nesting.check(_set_arena); \/\/ Check if a potential reallocation in the arena is safe\n","filename":"src\/hotspot\/share\/libadt\/vectset.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  LOG_TAG(vmatree) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-  number_of_segments = MAX2((int)CodeCacheMinBlockLength, (int)number_of_segments);\n+  number_of_segments = MAX2(CodeCacheMinBlockLength, number_of_segments);\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  if (!VirtualMemoryTracker::walk_virtual_memory(&virtual_memory_walker)) {\n+  if (!VirtualMemoryTracker::Instance::walk_virtual_memory(&virtual_memory_walker)) {\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-    return VirtualMemoryTracker::walk_virtual_memory(this);\n+    return VirtualMemoryTracker::Instance::walk_virtual_memory(this);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"logging\/log.hpp\"\n@@ -32,0 +33,2 @@\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -435,7 +438,14 @@\n-    CommittedRegionIterator itr = reserved_rgn->iterate_committed_regions();\n-    const CommittedMemoryRegion* committed_rgn = itr.next();\n-    if (committed_rgn->size() == reserved_rgn->size() && committed_rgn->call_stack()->equals(*stack)) {\n-      \/\/ One region spanning the entire reserved region, with the same stack trace.\n-      \/\/ Don't print this regions because the \"reserved and committed\" line above\n-      \/\/ already indicates that the region is committed.\n-      assert(itr.next() == nullptr, \"Unexpectedly more than one regions\");\n+    bool reserved_and_committed = false;\n+    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*reserved_rgn,\n+                                                                  [&](CommittedMemoryRegion& committed_rgn) {\n+      if (committed_rgn.equals(*reserved_rgn)) {\n+        \/\/ One region spanning the entire reserved region, with the same stack trace.\n+        \/\/ Don't print this regions because the \"reserved and committed\" line above\n+        \/\/ already indicates that the region is committed.\n+        reserved_and_committed = true;\n+        return false;\n+      }\n+      return true;\n+    });\n+\n+    if (reserved_and_committed) {\n@@ -446,3 +456,1 @@\n-  CommittedRegionIterator itr = reserved_rgn->iterate_committed_regions();\n-  const CommittedMemoryRegion* committed_rgn;\n-  while ((committed_rgn = itr.next()) != nullptr) {\n+  auto print_committed_rgn = [&](const CommittedMemoryRegion& crgn) {\n@@ -450,2 +458,2 @@\n-    if (amount_in_current_scale(committed_rgn->size()) == 0) continue;\n-    stack = committed_rgn->call_stack();\n+    if (amount_in_current_scale(crgn.size()) == 0) return;\n+    stack = crgn.call_stack();\n@@ -454,1 +462,1 @@\n-      print_virtual_memory_region(\"committed\", committed_rgn->base(), committed_rgn->size());\n+      print_virtual_memory_region(\"committed\", crgn.base(), crgn.size());\n@@ -459,1 +467,1 @@\n-        INDENT_BY(4, stack->print_on(out);)\n+        INDENT_BY(4, _stackprinter.print_stack(stack);)\n@@ -462,1 +470,7 @@\n-  }\n+  };\n+\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*reserved_rgn,\n+                                                                  [&](CommittedMemoryRegion& crgn) {\n+    print_committed_rgn(crgn);\n+    return true;\n+  });\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        !VirtualMemoryTracker::initialize(level)) {\n+        !VirtualMemoryTracker::Instance::initialize(level)) {\n@@ -129,1 +129,1 @@\n-       VirtualMemoryTracker::print_containing_region(p, out));\n+       VirtualMemoryTracker::Instance::print_containing_region(p, out));\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, mem_tag);\n+      VirtualMemoryTracker::Instance::add_reserved_region((address)addr, size, stack, mem_tag);\n@@ -143,1 +143,1 @@\n-      VirtualMemoryTracker::remove_released_region((address)addr, size);\n+      VirtualMemoryTracker::Instance::remove_released_region((address)addr, size);\n@@ -151,1 +151,1 @@\n-      VirtualMemoryTracker::remove_uncommitted_region((address)addr, size);\n+      VirtualMemoryTracker::Instance::remove_uncommitted_region((address)addr, size);\n@@ -161,2 +161,2 @@\n-      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, mem_tag);\n-      VirtualMemoryTracker::add_committed_region((address)addr, size, stack);\n+      VirtualMemoryTracker::Instance::add_reserved_region((address)addr, size, stack, mem_tag);\n+      VirtualMemoryTracker::Instance::add_committed_region((address)addr, size, stack);\n@@ -172,1 +172,1 @@\n-      VirtualMemoryTracker::add_committed_region((address)addr, size, stack);\n+      VirtualMemoryTracker::Instance::add_committed_region((address)addr, size, stack);\n@@ -220,1 +220,1 @@\n-      VirtualMemoryTracker::split_reserved_region((address)addr, size, split, mem_tag, split_tag);\n+      VirtualMemoryTracker::Instance::split_reserved_region((address)addr, size, split, mem_tag, split_tag);\n@@ -233,1 +233,1 @@\n-      VirtualMemoryTracker::set_reserved_region_type((address)addr, size, mem_tag);\n+      VirtualMemoryTracker::Instance::set_reserved_region_tag((address)addr, size, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-      return;\n+      return true;\n@@ -94,1 +94,1 @@\n-        _stack_storage.get(prev->val().out.stack()).print_on(stream);\n+        _stack_storage.get(prev->val().out.reserved_stack()).print_on(stream);\n@@ -99,0 +99,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-\n-private:\n@@ -50,1 +48,0 @@\n-public:\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  friend class VMTWithVMATreeTest;\n@@ -215,1 +216,1 @@\n-        return;\n+        return true;\n@@ -221,0 +222,1 @@\n+      return true;\n@@ -385,1 +387,3 @@\n-      f(head);\n+      if (!f(head)) {\n+        return;\n+      }\n@@ -412,1 +416,3 @@\n-        f(head);\n+        if (!f(head)) {\n+          return;\n+        }\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -51,1 +50,1 @@\n-  VirtualMemoryTracker::snapshot_thread_stacks();\n+  VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"nmt\/regionsTree.hpp\"\n+\n+VMATree::SummaryDiff RegionsTree::commit_region(address addr, size_t size, const NativeCallStack& stack) {\n+  return commit_mapping((VMATree::position)addr, size, make_region_data(stack, mtNone), \/*use tag inplace*\/ true);\n+}\n+\n+VMATree::SummaryDiff RegionsTree::uncommit_region(address addr, size_t size) {\n+  return uncommit_mapping((VMATree::position)addr, size, make_region_data(NativeCallStack::empty_stack(), mtNone));\n+}\n+\n+#ifdef ASSERT\n+void RegionsTree::NodeHelper::print_on(outputStream* st) {\n+  auto st_str = [&](VMATree::StateType s){\n+    return s == VMATree::StateType::Released ? \"Rl\" :\n+           s == VMATree::StateType::Reserved ? \"Rv\" : \"Cm\";\n+  };\n+  st->print_cr(\"pos: \" INTPTR_FORMAT \" \"\n+                \"%s, %s <|> %s, %s\",\n+                p2i((address)position()),\n+                st_str(in_state()),\n+                NMTUtil::tag_to_name(in_tag()),\n+                st_str(out_state()),\n+                NMTUtil::tag_to_name(out_tag())\n+                );\n+}\n+\n+void RegionsTree::print_on(outputStream* st) {\n+  visit_in_order([&](Node* node) {\n+    NodeHelper curr(node);\n+    curr.print_on(st);\n+    return true;\n+  });\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef NMT_REGIONSTREE_HPP\n+#define NMT_REGIONSTREE_HPP\n+\n+#include \"logging\/log.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/vmatree.hpp\"\n+\n+\n+class ReservedMemoryRegion;\n+class CommittedMemoryRegion;\n+\/\/ RegionsTree extends VMATree to add some more specific API and also defines a helper\n+\/\/ for processing the tree nodes in a shorter and more meaningful way.\n+class RegionsTree : public VMATree {\n+  NativeCallStackStorage _ncs_storage;\n+  bool _with_storage;\n+\n+ public:\n+  RegionsTree(bool with_storage) : VMATree() , _ncs_storage(with_storage), _with_storage(with_storage) { }\n+\n+  ReservedMemoryRegion find_reserved_region(address addr);\n+\n+  SummaryDiff commit_region(address addr, size_t size, const NativeCallStack& stack);\n+  SummaryDiff uncommit_region(address addr, size_t size);\n+\n+  using Node = VMATree::TreapNode;\n+\n+  class NodeHelper {\n+      Node* _node;\n+      public:\n+      NodeHelper() : _node(nullptr) { }\n+      NodeHelper(Node* node) : _node(node) { }\n+      inline bool is_valid() const { return _node != nullptr; }\n+      inline void clear_node() { _node = nullptr; }\n+      inline VMATree::position position() const { return _node->key(); }\n+      inline bool is_committed_begin() const { return ((uint8_t)out_state() & (uint8_t)VMATree::StateType::Committed) >= 2; }\n+      inline bool is_released_begin() const { return out_state() == VMATree::StateType::Released; }\n+      inline bool is_reserved_begin() const { return ((uint8_t)out_state() & (uint8_t)VMATree::StateType::Reserved) == 1; }\n+      inline VMATree::StateType in_state() const { return _node->val().in.type(); }\n+      inline VMATree::StateType out_state() const { return _node->val().out.type(); }\n+      inline size_t distance_from(const NodeHelper& other) const {\n+        assert (position() > other.position(), \"negative distance\");\n+        return position() - other.position();\n+      }\n+      inline NativeCallStackStorage::StackIndex out_stack_index() const { return _node->val().out.reserved_stack(); }\n+      inline MemTag in_tag() const { return _node->val().in.mem_tag(); }\n+      inline MemTag out_tag() const { return _node->val().out.mem_tag(); }\n+      inline void set_in_tag(MemTag tag) { _node->val().in.set_tag(tag); }\n+      inline void set_out_tag(MemTag tag) { _node->val().out.set_tag(tag); }\n+      DEBUG_ONLY(void print_on(outputStream* st);)\n+    };\n+\n+  DEBUG_ONLY(void print_on(outputStream* st);)\n+\n+  template<typename F>\n+  void visit_committed_regions(const ReservedMemoryRegion& rgn, F func);\n+\n+  template<typename F>\n+  void visit_reserved_regions(F func);\n+\n+  inline RegionData make_region_data(const NativeCallStack& ncs, MemTag tag) {\n+    return RegionData(_ncs_storage.push(ncs), tag);\n+  }\n+\n+  inline const NativeCallStack stack(NodeHelper& node) {\n+    if (!_with_storage) {\n+      return NativeCallStack::empty_stack();\n+    }\n+    NativeCallStackStorage::StackIndex si = node.out_stack_index();\n+    return _ncs_storage.get(si);\n+  }\n+};\n+\n+#endif \/\/ NMT_REGIONSTREE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.hpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_NMT_REGIONSTREE_INLINE_HPP\n+#define SHARE_NMT_REGIONSTREE_INLINE_HPP\n+\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+\n+template<typename F>\n+void RegionsTree::visit_committed_regions(const ReservedMemoryRegion& rgn, F func) {\n+  position start = (position)rgn.base();\n+  size_t end = reinterpret_cast<size_t>(rgn.end()) + 1;\n+  size_t comm_size = 0;\n+\n+  NodeHelper prev;\n+  visit_range_in_order(start, end, [&](Node* node) {\n+    NodeHelper curr(node);\n+    if (prev.is_valid() && prev.is_committed_begin()) {\n+      CommittedMemoryRegion cmr((address)prev.position(), curr.distance_from(prev), stack(prev));\n+      if (!func(cmr)) {\n+        return false;\n+      }\n+    }\n+    prev = curr;\n+    return true;\n+  });\n+}\n+\n+template<typename F>\n+void RegionsTree::visit_reserved_regions(F func) {\n+  NodeHelper begin_node, prev;\n+  size_t rgn_size = 0;\n+\n+  visit_in_order([&](Node* node) {\n+    NodeHelper curr(node);\n+    if (prev.is_valid()) {\n+      rgn_size += curr.distance_from(prev);\n+    } else {\n+      begin_node = curr;\n+      rgn_size = 0;\n+    }\n+    prev = curr;\n+    if (curr.is_released_begin() || begin_node.out_tag() != curr.out_tag()) {\n+      auto st = stack(begin_node);\n+      if (rgn_size == 0) {\n+        prev.clear_node();\n+        return true;\n+      }\n+      ReservedMemoryRegion rmr((address)begin_node.position(), rgn_size, st, begin_node.out_tag());\n+      if (!func(rmr)) {\n+        return false;\n+      }\n+      rgn_size = 0;\n+      if (!curr.is_released_begin()) {\n+        begin_node = curr;\n+      } else {\n+        begin_node.clear_node();\n+        prev.clear_node();\n+      }\n+    }\n+\n+    return true;\n+  });\n+}\n+\n+#endif \/\/SHARE_NMT_REGIONSTREE_INLINE_HPP\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -55,1 +54,1 @@\n-  VirtualMemoryTracker::add_reserved_region((address)base, size, stack, mtThreadStack);\n+  VirtualMemoryTracker::Instance::add_reserved_region((address)base, size, stack, mtThreadStack);\n@@ -65,1 +64,1 @@\n-  VirtualMemoryTracker::remove_released_region((address)base, size);\n+  MemTracker::record_virtual_memory_release((address)base, size);\n","filename":"src\/hotspot\/share\/nmt\/threadStackTracker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -25,2 +26,0 @@\n-#include \"memory\/metaspaceStats.hpp\"\n-#include \"memory\/metaspaceUtils.hpp\"\n@@ -28,2 +27,0 @@\n-#include \"nmt\/nativeCallStackPrinter.hpp\"\n-#include \"nmt\/threadStackTracker.hpp\"\n@@ -31,0 +28,2 @@\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -34,0 +33,1 @@\n+VirtualMemoryTracker* VirtualMemoryTracker::Instance::_tracker = nullptr;\n@@ -50,1 +50,1 @@\n-  VirtualMemoryTracker::snapshot_thread_stacks();\n+  VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n@@ -54,31 +54,6 @@\n-SortedLinkedList<ReservedMemoryRegion, compare_reserved_region_base>* VirtualMemoryTracker::_reserved_regions;\n-\n-int compare_committed_region(const CommittedMemoryRegion& r1, const CommittedMemoryRegion& r2) {\n-  return r1.compare(r2);\n-}\n-\n-int compare_reserved_region_base(const ReservedMemoryRegion& r1, const ReservedMemoryRegion& r2) {\n-  return r1.compare(r2);\n-}\n-\n-static bool is_mergeable_with(CommittedMemoryRegion* rgn, address addr, size_t size, const NativeCallStack& stack) {\n-  return rgn->adjacent_to(addr, size) && rgn->call_stack()->equals(stack);\n-}\n-\n-static bool is_same_as(CommittedMemoryRegion* rgn, address addr, size_t size, const NativeCallStack& stack) {\n-  \/\/ It would have made sense to use rgn->equals(...), but equals returns true for overlapping regions.\n-  return rgn->same_region(addr, size) && rgn->call_stack()->equals(stack);\n-}\n-\n-static LinkedListNode<CommittedMemoryRegion>* find_preceding_node_from(LinkedListNode<CommittedMemoryRegion>* from, address addr) {\n-  LinkedListNode<CommittedMemoryRegion>* preceding = nullptr;\n-\n-  for (LinkedListNode<CommittedMemoryRegion>* node = from; node != nullptr; node = node->next()) {\n-    CommittedMemoryRegion* rgn = node->data();\n-\n-    \/\/ We searched past the region start.\n-    if (rgn->end() > addr) {\n-      break;\n-    }\n-\n-    preceding = node;\n+bool VirtualMemoryTracker::Instance::initialize(NMT_TrackingLevel level) {\n+  assert(_tracker == nullptr, \"only call once\");\n+  if (level >= NMT_summary) {\n+    void* tracker = os::malloc(sizeof(VirtualMemoryTracker), mtNMT);\n+    if (tracker == nullptr) return false;\n+    _tracker = new (tracker) VirtualMemoryTracker(level == NMT_detail);\n@@ -86,2 +61,1 @@\n-\n-  return preceding;\n+  return true;\n@@ -90,3 +64,0 @@\n-static bool try_merge_with(LinkedListNode<CommittedMemoryRegion>* node, address addr, size_t size, const NativeCallStack& stack) {\n-  if (node != nullptr) {\n-    CommittedMemoryRegion* rgn = node->data();\n@@ -94,7 +65,4 @@\n-    if (is_mergeable_with(rgn, addr, size, stack)) {\n-      rgn->expand_region(addr, size);\n-      return true;\n-    }\n-  }\n-\n-  return false;\n+void VirtualMemoryTracker::Instance::add_reserved_region(address base_addr, size_t size,\n+  const NativeCallStack& stack, MemTag mem_tag) {\n+    assert(_tracker != nullptr, \"Sanity check\");\n+    _tracker->add_reserved_region(base_addr, size, stack, mem_tag);\n@@ -103,7 +71,4 @@\n-static bool try_merge_with(LinkedListNode<CommittedMemoryRegion>* node, LinkedListNode<CommittedMemoryRegion>* other) {\n-  if (other == nullptr) {\n-    return false;\n-  }\n-\n-  CommittedMemoryRegion* rgn = other->data();\n-  return try_merge_with(node, rgn->base(), rgn->size(), *rgn->call_stack());\n+void VirtualMemoryTracker::add_reserved_region(address base_addr, size_t size,\n+  const NativeCallStack& stack, MemTag mem_tag) {\n+  VMATree::SummaryDiff diff = tree()->reserve_mapping((size_t)base_addr, size, tree()->make_region_data(stack, mem_tag));\n+  apply_summary_diff(diff);\n@@ -112,51 +77,3 @@\n-bool ReservedMemoryRegion::add_committed_region(address addr, size_t size, const NativeCallStack& stack) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(contain_region(addr, size), \"Not contain this region\");\n-\n-  \/\/ Find the region that fully precedes the [addr, addr + size) region.\n-  LinkedListNode<CommittedMemoryRegion>* prev = find_preceding_node_from(_committed_regions.head(), addr);\n-  LinkedListNode<CommittedMemoryRegion>* next = (prev != nullptr ? prev->next() : _committed_regions.head());\n-\n-  if (next != nullptr) {\n-    \/\/ Ignore request if region already exists.\n-    if (is_same_as(next->data(), addr, size, stack)) {\n-      return true;\n-    }\n-\n-    \/\/ The new region is after prev, and either overlaps with the\n-    \/\/ next region (and maybe more regions), or overlaps with no region.\n-    if (next->data()->overlap_region(addr, size)) {\n-      \/\/ Remove _all_ overlapping regions, and parts of regions,\n-      \/\/ in preparation for the addition of this new region.\n-      remove_uncommitted_region(addr, size);\n-\n-      \/\/ The remove could have split a region into two and created a\n-      \/\/ new prev region. Need to reset the prev and next pointers.\n-      prev = find_preceding_node_from((prev != nullptr ? prev : _committed_regions.head()), addr);\n-      next = (prev != nullptr ? prev->next() : _committed_regions.head());\n-    }\n-  }\n-\n-  \/\/ At this point the previous overlapping regions have been\n-  \/\/ cleared, and the full region is guaranteed to be inserted.\n-  VirtualMemorySummary::record_committed_memory(size, mem_tag());\n-\n-  \/\/ Try to merge with prev and possibly next.\n-  if (try_merge_with(prev, addr, size, stack)) {\n-    if (try_merge_with(prev, next)) {\n-      \/\/ prev was expanded to contain the new region\n-      \/\/ and next, need to remove next from the list\n-      _committed_regions.remove_after(prev);\n-    }\n-\n-    return true;\n-  }\n-\n-  \/\/ Didn't merge with prev, try with next.\n-  if (try_merge_with(next, addr, size, stack)) {\n-    return true;\n-  }\n-\n-  \/\/ Couldn't merge with any regions - create a new region.\n-  return add_committed_region(CommittedMemoryRegion(addr, size, stack));\n+void VirtualMemoryTracker::Instance::set_reserved_region_tag(address addr, size_t size, MemTag mem_tag) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->set_reserved_region_tag(addr, size, mem_tag);\n@@ -165,31 +82,3 @@\n-bool ReservedMemoryRegion::remove_uncommitted_region(LinkedListNode<CommittedMemoryRegion>* node,\n-  address addr, size_t size) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-\n-  CommittedMemoryRegion* rgn = node->data();\n-  assert(rgn->contain_region(addr, size), \"Has to be contained\");\n-  assert(!rgn->same_region(addr, size), \"Can not be the same region\");\n-\n-  if (rgn->base() == addr ||\n-      rgn->end() == addr + size) {\n-    rgn->exclude_region(addr, size);\n-    return true;\n-  } else {\n-    \/\/ split this region\n-    address top =rgn->end();\n-    \/\/ use this region for lower part\n-    size_t exclude_size = rgn->end() - addr;\n-    rgn->exclude_region(addr, exclude_size);\n-\n-    \/\/ higher part\n-    address high_base = addr + size;\n-    size_t  high_size = top - high_base;\n-\n-    CommittedMemoryRegion high_rgn(high_base, high_size, *rgn->call_stack());\n-    LinkedListNode<CommittedMemoryRegion>* high_node = _committed_regions.add(high_rgn);\n-    assert(high_node == nullptr || node->next() == high_node, \"Should be right after\");\n-    return (high_node != nullptr);\n-  }\n-\n-  return false;\n+void VirtualMemoryTracker::set_reserved_region_tag(address addr, size_t size, MemTag mem_tag) {\n+    VMATree::SummaryDiff diff = tree()->set_tag((VMATree::position) addr, size, mem_tag);\n+    apply_summary_diff(diff);\n@@ -198,30 +87,4 @@\n-bool ReservedMemoryRegion::remove_uncommitted_region(address addr, size_t sz) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(sz > 0, \"Invalid size\");\n-\n-  CommittedMemoryRegion del_rgn(addr, sz, *call_stack());\n-  address end = addr + sz;\n-\n-  LinkedListNode<CommittedMemoryRegion>* head = _committed_regions.head();\n-  LinkedListNode<CommittedMemoryRegion>* prev = nullptr;\n-  CommittedMemoryRegion* crgn;\n-\n-  while (head != nullptr) {\n-    crgn = head->data();\n-\n-    if (crgn->same_region(addr, sz)) {\n-      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), mem_tag());\n-      _committed_regions.remove_after(prev);\n-      return true;\n-    }\n-\n-    \/\/ del_rgn contains crgn\n-    if (del_rgn.contain_region(crgn->base(), crgn->size())) {\n-      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), mem_tag());\n-      head = head->next();\n-      _committed_regions.remove_after(prev);\n-      continue;  \/\/ don't update head or prev\n-    }\n-\n-    \/\/ Found addr in the current crgn. There are 2 subcases:\n-    if (crgn->contain_address(addr)) {\n+void VirtualMemoryTracker::Instance::apply_summary_diff(VMATree::SummaryDiff diff) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->apply_summary_diff(diff);\n+}\n@@ -229,4 +92,24 @@\n-      \/\/ (1) Found addr+size in current crgn as well. (del_rgn is contained in crgn)\n-      if (crgn->contain_address(end - 1)) {\n-        VirtualMemorySummary::record_uncommitted_memory(sz, mem_tag());\n-        return remove_uncommitted_region(head, addr, sz); \/\/ done!\n+void VirtualMemoryTracker::apply_summary_diff(VMATree::SummaryDiff diff) {\n+  VMATree::SingleDiff::delta reserve_delta, commit_delta;\n+  size_t reserved, committed;\n+  MemTag tag = mtNone;\n+  auto print_err = [&](const char* str) {\n+#ifdef ASSERT\n+    log_error(nmt)(\"summary mismatch, at %s, for %s,\"\n+                   \" diff-reserved:  %ld\"\n+                   \" diff-committed: %ld\"\n+                   \" vms-reserved: %zu\"\n+                   \" vms-committed: %zu\",\n+                   str, NMTUtil::tag_to_name(tag), (long)reserve_delta, (long)commit_delta, reserved, committed);\n+#endif\n+  };\n+\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    reserve_delta = diff.tag[i].reserve;\n+    commit_delta = diff.tag[i].commit;\n+    tag = NMTUtil::index_to_tag(i);\n+    reserved = VirtualMemorySummary::as_snapshot()->by_tag(tag)->reserved();\n+    committed = VirtualMemorySummary::as_snapshot()->by_tag(tag)->committed();\n+    if (reserve_delta != 0) {\n+      if (reserve_delta > 0) {\n+        VirtualMemorySummary::record_reserved_memory(reserve_delta, tag);\n@@ -234,4 +117,5 @@\n-        \/\/ (2) Did not find del_rgn's end in crgn.\n-        size_t size = crgn->end() - del_rgn.base();\n-        crgn->exclude_region(addr, size);\n-        VirtualMemorySummary::record_uncommitted_memory(size, mem_tag());\n+        if ((size_t)-reserve_delta <= reserved) {\n+          VirtualMemorySummary::record_released_memory(-reserve_delta, tag);\n+        } else {\n+          print_err(\"release\");\n+        }\n@@ -239,27 +123,0 @@\n-\n-    } else if (crgn->contain_address(end - 1)) {\n-      \/\/ Found del_rgn's end, but not its base addr.\n-      size_t size = del_rgn.end() - crgn->base();\n-      crgn->exclude_region(crgn->base(), size);\n-      VirtualMemorySummary::record_uncommitted_memory(size, mem_tag());\n-      return true;  \/\/ should be done if the list is sorted properly!\n-    }\n-\n-    prev = head;\n-    head = head->next();\n-  }\n-\n-  return true;\n-}\n-\n-void ReservedMemoryRegion::move_committed_regions(address addr, ReservedMemoryRegion& rgn) {\n-  assert(addr != nullptr, \"Invalid address\");\n-\n-  \/\/ split committed regions\n-  LinkedListNode<CommittedMemoryRegion>* head =\n-    _committed_regions.head();\n-  LinkedListNode<CommittedMemoryRegion>* prev = nullptr;\n-\n-  while (head != nullptr) {\n-    if (head->data()->base() >= addr) {\n-      break;\n@@ -267,9 +124,16 @@\n-    prev = head;\n-    head = head->next();\n-  }\n-\n-  if (head != nullptr) {\n-    if (prev != nullptr) {\n-      prev->set_next(head->next());\n-    } else {\n-      _committed_regions.set_head(nullptr);\n+    if (commit_delta != 0) {\n+      if (commit_delta > 0) {\n+        if ((size_t)commit_delta <= ((size_t)reserve_delta + reserved)) {\n+          VirtualMemorySummary::record_committed_memory(commit_delta, tag);\n+        }\n+        else {\n+          print_err(\"commit\");\n+        }\n+      }\n+      else {\n+        if ((size_t)-commit_delta <= committed) {\n+          VirtualMemorySummary::record_uncommitted_memory(-commit_delta, tag);\n+        } else {\n+          print_err(\"uncommit\");\n+        }\n+      }\n@@ -278,2 +142,0 @@\n-\n-  rgn._committed_regions.set_head(head);\n@@ -282,20 +144,4 @@\n-size_t ReservedMemoryRegion::committed_size() const {\n-  size_t committed = 0;\n-  LinkedListNode<CommittedMemoryRegion>* head =\n-    _committed_regions.head();\n-  while (head != nullptr) {\n-    committed += head->data()->size();\n-    head = head->next();\n-  }\n-  return committed;\n-}\n-\n-void ReservedMemoryRegion::set_mem_tag(MemTag new_mem_tag) {\n-  assert((mem_tag() == mtNone || mem_tag() == new_mem_tag),\n-         \"Overwrite memory tag for region [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), %u->%u.\",\n-         p2i(base()), p2i(end()), (unsigned)mem_tag(), (unsigned)new_mem_tag);\n-  if (mem_tag() != new_mem_tag) {\n-    VirtualMemorySummary::move_reserved_memory(mem_tag(), new_mem_tag, size());\n-    VirtualMemorySummary::move_committed_memory(mem_tag(), new_mem_tag, committed_size());\n-    _mem_tag = new_mem_tag;\n-  }\n+void VirtualMemoryTracker::Instance::add_committed_region(address addr, size_t size,\n+  const NativeCallStack& stack) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->add_committed_region(addr, size, stack);\n@@ -304,18 +150,4 @@\n-address ReservedMemoryRegion::thread_stack_uncommitted_bottom() const {\n-  assert(mem_tag() == mtThreadStack, \"Only for thread stack\");\n-  LinkedListNode<CommittedMemoryRegion>* head = _committed_regions.head();\n-  address bottom = base();\n-  address top = base() + size();\n-  while (head != nullptr) {\n-    address committed_top = head->data()->base() + head->data()->size();\n-    if (committed_top < top) {\n-      \/\/ committed stack guard pages, skip them\n-      bottom = head->data()->base() + head->data()->size();\n-      head = head->next();\n-    } else {\n-      assert(top == committed_top, \"Sanity\");\n-      break;\n-    }\n-  }\n-\n-  return bottom;\n+void VirtualMemoryTracker::add_committed_region(address addr, size_t size,\n+  const NativeCallStack& stack) {\n+    VMATree::SummaryDiff diff = tree()->commit_region(addr, size, stack);\n+    apply_summary_diff(diff);\n@@ -324,8 +156,3 @@\n-bool VirtualMemoryTracker::initialize(NMT_TrackingLevel level) {\n-  assert(_reserved_regions == nullptr, \"only call once\");\n-  if (level >= NMT_summary) {\n-    _reserved_regions = new (std::nothrow, mtNMT)\n-      SortedLinkedList<ReservedMemoryRegion, compare_reserved_region_base>();\n-    return (_reserved_regions != nullptr);\n-  }\n-  return true;\n+void VirtualMemoryTracker::Instance::remove_uncommitted_region(address addr, size_t size) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->remove_uncommitted_region(addr, size);\n@@ -334,5 +161,1 @@\n-bool VirtualMemoryTracker::add_reserved_region(address base_addr, size_t size,\n-    const NativeCallStack& stack, MemTag mem_tag) {\n-  assert(base_addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n+void VirtualMemoryTracker::remove_uncommitted_region(address addr, size_t size) {\n@@ -340,82 +163,2 @@\n-\n-  ReservedMemoryRegion  rgn(base_addr, size, stack, mem_tag);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-\n-  log_debug(nmt)(\"Add reserved region \\'%s\\' (\" INTPTR_FORMAT \", %zu)\",\n-                rgn.mem_tag_name(), p2i(rgn.base()), rgn.size());\n-  if (reserved_rgn == nullptr) {\n-    VirtualMemorySummary::record_reserved_memory(size, mem_tag);\n-    return _reserved_regions->add(rgn) != nullptr;\n-  } else {\n-    \/\/ Deal with recursive reservation\n-    \/\/ os::reserve_memory() -> pd_reserve_memory() -> os::reserve_memory()\n-    \/\/ See JDK-8198226.\n-    if (reserved_rgn->same_region(base_addr, size) &&\n-        (reserved_rgn->mem_tag() == mem_tag || reserved_rgn->mem_tag() == mtNone)) {\n-      reserved_rgn->set_call_stack(stack);\n-      reserved_rgn->set_mem_tag(mem_tag);\n-      return true;\n-    } else {\n-      assert(reserved_rgn->overlap_region(base_addr, size), \"Must be\");\n-\n-      \/\/ Overlapped reservation.\n-      \/\/ It can happen when the regions are thread stacks, as JNI\n-      \/\/ thread does not detach from VM before exits, and leads to\n-      \/\/ leak JavaThread object\n-      if (reserved_rgn->mem_tag() == mtThreadStack) {\n-        guarantee(!CheckJNICalls, \"Attached JNI thread exited without being detached\");\n-        \/\/ Overwrite with new region\n-\n-        \/\/ Release old region\n-        VirtualMemorySummary::record_uncommitted_memory(reserved_rgn->committed_size(), reserved_rgn->mem_tag());\n-        VirtualMemorySummary::record_released_memory(reserved_rgn->size(), reserved_rgn->mem_tag());\n-\n-        \/\/ Add new region\n-        VirtualMemorySummary::record_reserved_memory(rgn.size(), mem_tag);\n-\n-        *reserved_rgn = rgn;\n-        return true;\n-      }\n-\n-      \/\/ CDS mapping region.\n-      \/\/ CDS reserves the whole region for mapping CDS archive, then maps each section into the region.\n-      \/\/ NMT reports CDS as a whole.\n-      if (reserved_rgn->mem_tag() == mtClassShared) {\n-        log_debug(nmt)(\"CDS reserved region \\'%s\\' as a whole (\" INTPTR_FORMAT \", %zu)\",\n-                      reserved_rgn->mem_tag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n-        assert(reserved_rgn->contain_region(base_addr, size), \"Reserved CDS region should contain this mapping region\");\n-        return true;\n-      }\n-\n-      \/\/ Mapped CDS string region.\n-      \/\/ The string region(s) is part of the java heap.\n-      if (reserved_rgn->mem_tag() == mtJavaHeap) {\n-        log_debug(nmt)(\"CDS reserved region \\'%s\\' as a whole (\" INTPTR_FORMAT \", %zu)\",\n-                      reserved_rgn->mem_tag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n-        assert(reserved_rgn->contain_region(base_addr, size), \"Reserved heap region should contain this mapping region\");\n-        return true;\n-      }\n-\n-      if (reserved_rgn->mem_tag() == mtCode) {\n-        assert(reserved_rgn->contain_region(base_addr, size), \"Reserved code region should contain this mapping region\");\n-        return true;\n-      }\n-\n-      \/\/ Print some more details.\n-      stringStream ss;\n-      ss.print_cr(\"Error: old region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %s.\\n\"\n-                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %s.\",\n-                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()), NMTUtil::tag_to_name(reserved_rgn->mem_tag()),\n-                    p2i(base_addr), p2i(base_addr + size), NMTUtil::tag_to_name(mem_tag));\n-      if (MemTracker::tracking_level() == NMT_detail) {\n-        ss.print_cr(\"Existing region allocated from:\");\n-        reserved_rgn->call_stack()->print_on(&ss);\n-        ss.print_cr(\"New region allocated from:\");\n-        stack.print_on(&ss);\n-      }\n-      log_debug(nmt)(\"%s\", ss.freeze());\n-\n-      ShouldNotReachHere();\n-      return false;\n-    }\n-  }\n+  VMATree::SummaryDiff diff = tree()->uncommit_region(addr, size);\n+  apply_summary_diff(diff);\n@@ -424,15 +167,3 @@\n-void VirtualMemoryTracker::set_reserved_region_type(address addr, size_t size, MemTag mem_tag) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion   rgn(addr, 1);\n-  ReservedMemoryRegion*  reserved_rgn = _reserved_regions->find(rgn);\n-  if (reserved_rgn != nullptr) {\n-    assert(reserved_rgn->contain_address(addr), \"Containment\");\n-    if (reserved_rgn->mem_tag() != mem_tag) {\n-      assert(reserved_rgn->mem_tag() == mtNone, \"Overwrite memory tag (should be mtNone, is: \\\"%s\\\")\",\n-             NMTUtil::tag_to_name(reserved_rgn->mem_tag()));\n-      reserved_rgn->set_mem_tag(mem_tag);\n-    }\n-  }\n+void VirtualMemoryTracker::Instance::remove_released_region(address addr, size_t size) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->remove_released_region(addr, size);\n@@ -441,20 +172,3 @@\n-bool VirtualMemoryTracker::add_committed_region(address addr, size_t size,\n-  const NativeCallStack& stack) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-\n-  if (reserved_rgn == nullptr) {\n-    log_debug(nmt)(\"Add committed region \\'%s\\', No reserved region found for  (\" INTPTR_FORMAT \", %zu)\",\n-                  rgn.mem_tag_name(),  p2i(rgn.base()), rgn.size());\n-  }\n-  assert(reserved_rgn != nullptr, \"Add committed region, No reserved region found\");\n-  assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n-  bool result = reserved_rgn->add_committed_region(addr, size, stack);\n-  log_debug(nmt)(\"Add committed region \\'%s\\'(\" INTPTR_FORMAT \", %zu) %s\",\n-                reserved_rgn->mem_tag_name(),  p2i(rgn.base()), rgn.size(), (result ? \"Succeeded\" : \"Failed\"));\n-  return result;\n+void VirtualMemoryTracker::remove_released_region(address addr, size_t size) {\n+  VMATree::SummaryDiff diff = tree()->release_mapping((VMATree::position)addr, size);\n+  apply_summary_diff(diff);\n@@ -463,15 +177,3 @@\n-bool VirtualMemoryTracker::remove_uncommitted_region(address addr, size_t size) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-  assert(reserved_rgn != nullptr, \"No reserved region (\" INTPTR_FORMAT \", %zu)\", p2i(addr), size);\n-  assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n-  const char* type_name = reserved_rgn->mem_tag_name();  \/\/ after remove, info is not complete\n-  bool result = reserved_rgn->remove_uncommitted_region(addr, size);\n-  log_debug(nmt)(\"Removed uncommitted region \\'%s\\' (\" INTPTR_FORMAT \", %zu) %s\",\n-                 type_name,  p2i(addr), size, (result ? \" Succeeded\" : \"Failed\"));\n-  return result;\n+void VirtualMemoryTracker::Instance::split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->split_reserved_region(addr, size, split, mem_tag, split_mem_tag);\n@@ -480,19 +182,3 @@\n-bool VirtualMemoryTracker::remove_released_region(ReservedMemoryRegion* rgn) {\n-  assert(rgn != nullptr, \"Sanity check\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  \/\/ uncommit regions within the released region\n-  ReservedMemoryRegion backup(*rgn);\n-  bool result = rgn->remove_uncommitted_region(rgn->base(), rgn->size());\n-  log_debug(nmt)(\"Remove uncommitted region \\'%s\\' (\" INTPTR_FORMAT \", %zu) %s\",\n-                backup.mem_tag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n-  if (!result) {\n-    return false;\n-  }\n-\n-  VirtualMemorySummary::record_released_memory(rgn->size(), rgn->mem_tag());\n-  result =  _reserved_regions->remove(*rgn);\n-  log_debug(nmt)(\"Removed region \\'%s\\' (\" INTPTR_FORMAT \", %zu) from _reserved_regions %s\" ,\n-                backup.mem_tag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n-  return result;\n+void VirtualMemoryTracker::split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  add_reserved_region(addr, split, NativeCallStack::empty_stack(), mem_tag);\n+  add_reserved_region(addr + split, size - split, NativeCallStack::empty_stack(), split_mem_tag);\n@@ -501,17 +187,4 @@\n-bool VirtualMemoryTracker::remove_released_region(address addr, size_t size) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-\n-  if (reserved_rgn == nullptr) {\n-    log_debug(nmt)(\"No reserved region found for (\" INTPTR_FORMAT \", %zu)!\",\n-                  p2i(rgn.base()), rgn.size());\n-  }\n-  assert(reserved_rgn != nullptr, \"No reserved region\");\n-  if (reserved_rgn->same_region(addr, size)) {\n-    return remove_released_region(reserved_rgn);\n-  }\n+bool VirtualMemoryTracker::Instance::print_containing_region(const void* p, outputStream* st) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  return _tracker->print_containing_region(p, st);\n+}\n@@ -519,2 +192,3 @@\n-  \/\/ uncommit regions within the released region\n-  if (!reserved_rgn->remove_uncommitted_region(addr, size)) {\n+bool VirtualMemoryTracker::print_containing_region(const void* p, outputStream* st) {\n+  ReservedMemoryRegion rmr = tree()->find_reserved_region((address)p);\n+  if (!rmr.contain_address((address)p)) {\n@@ -523,21 +197,4 @@\n-\n-  if (reserved_rgn->mem_tag() == mtClassShared) {\n-    if (reserved_rgn->contain_region(addr, size)) {\n-      \/\/ This is an unmapped CDS region, which is part of the reserved shared\n-      \/\/ memory region.\n-      \/\/ See special handling in VirtualMemoryTracker::add_reserved_region also.\n-      return true;\n-    }\n-\n-    if (size > reserved_rgn->size()) {\n-      \/\/ This is from release the whole region spanning from archive space to class space,\n-      \/\/ so we release them altogether.\n-      ReservedMemoryRegion class_rgn(addr + reserved_rgn->size(),\n-                                     (size - reserved_rgn->size()));\n-      ReservedMemoryRegion* cls_rgn = _reserved_regions->find(class_rgn);\n-      assert(cls_rgn != nullptr, \"Class space region  not recorded?\");\n-      assert(cls_rgn->mem_tag() == mtClass, \"Must be class mem tag\");\n-      remove_released_region(reserved_rgn);\n-      remove_released_region(cls_rgn);\n-      return true;\n-    }\n+  st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n+               p2i(p), p2i(rmr.base()), p2i(rmr.end()), NMTUtil::tag_to_enum_name(rmr.mem_tag()));\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    rmr.call_stack()->print_on(st);\n@@ -545,0 +202,3 @@\n+  st->cr();\n+  return true;\n+}\n@@ -546,1 +206,4 @@\n-  VirtualMemorySummary::record_released_memory(size, reserved_rgn->mem_tag());\n+bool VirtualMemoryTracker::Instance::walk_virtual_memory(VirtualMemoryWalker* walker) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  return _tracker->walk_virtual_memory(walker);\n+}\n@@ -548,15 +211,4 @@\n-  assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n-  if (reserved_rgn->base() == addr ||\n-      reserved_rgn->end() == addr + size) {\n-      reserved_rgn->exclude_region(addr, size);\n-    return true;\n-  } else {\n-    address top = reserved_rgn->end();\n-    address high_base = addr + size;\n-    ReservedMemoryRegion high_rgn(high_base, top - high_base,\n-      *reserved_rgn->call_stack(), reserved_rgn->mem_tag());\n-\n-    \/\/ use original region for lower region\n-    reserved_rgn->exclude_region(addr, top - addr);\n-    LinkedListNode<ReservedMemoryRegion>* new_rgn = _reserved_regions->add(high_rgn);\n-    if (new_rgn == nullptr) {\n+bool VirtualMemoryTracker::walk_virtual_memory(VirtualMemoryWalker* walker) {\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n+  tree()->visit_reserved_regions([&](ReservedMemoryRegion& rgn) {\n+    if (!walker->do_allocation_site(&rgn)) {\n@@ -564,3 +216,0 @@\n-    } else {\n-      reserved_rgn->move_committed_regions(addr, *new_rgn->data());\n-      return true;\n@@ -568,1 +217,3 @@\n-  }\n+    return true;\n+  });\n+  return true;\n@@ -571,13 +222,9 @@\n-\/\/ Given an existing memory mapping registered with NMT, split the mapping in\n-\/\/  two. The newly created two mappings will be registered under the call\n-\/\/  stack and the memory tags of the original section.\n-bool VirtualMemoryTracker::split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_tag) {\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-  assert(reserved_rgn->same_region(addr, size), \"Must be identical region\");\n-  assert(reserved_rgn != nullptr, \"No reserved region\");\n-  assert(reserved_rgn->committed_size() == 0, \"Splitting committed region?\");\n-\n-  NativeCallStack original_stack = *reserved_rgn->call_stack();\n-  MemTag original_tag = reserved_rgn->mem_tag();\n+size_t ReservedMemoryRegion::committed_size() const {\n+  size_t committed = 0;\n+  size_t result = 0;\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*this, [&](CommittedMemoryRegion& crgn) {\n+    result += crgn.size();\n+    return true;\n+  });\n+  return result;\n+}\n@@ -585,7 +232,14 @@\n-  const char* name = reserved_rgn->mem_tag_name();\n-  remove_released_region(reserved_rgn);\n-  log_debug(nmt)(\"Split region \\'%s\\' (\" INTPTR_FORMAT \", %zu)  with size %zu\",\n-                name, p2i(rgn.base()), rgn.size(), split);\n-  \/\/ Now, create two new regions.\n-  add_reserved_region(addr, split, original_stack, mem_tag);\n-  add_reserved_region(addr + split, size - split, original_stack, split_tag);\n+address ReservedMemoryRegion::thread_stack_uncommitted_bottom() const {\n+  address bottom = base();\n+  address top = base() + size();\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*this, [&](CommittedMemoryRegion& crgn) {\n+    address committed_top = crgn.base() + crgn.size();\n+    if (committed_top < top) {\n+      \/\/ committed stack guard pages, skip them\n+      bottom = crgn.base() + crgn.size();\n+    } else {\n+      assert(top == committed_top, \"Sanity, top=\" INTPTR_FORMAT \" , com-top=\" INTPTR_FORMAT, p2i(top), p2i(committed_top));\n+      return false;;\n+    }\n+    return true;\n+  });\n@@ -593,1 +247,1 @@\n-  return true;\n+  return bottom;\n@@ -596,1 +250,0 @@\n-\n@@ -648,1 +301,0 @@\n-      ReservedMemoryRegion* region = const_cast<ReservedMemoryRegion*>(rgn);\n@@ -660,1 +312,1 @@\n-        region->add_committed_region(committed_start, committed_size, ncs);\n+        VirtualMemoryTracker::Instance::add_committed_region(committed_start, committed_size, ncs);\n@@ -673,1 +325,1 @@\n-void VirtualMemoryTracker::snapshot_thread_stacks() {\n+void VirtualMemoryTracker::Instance::snapshot_thread_stacks() {\n@@ -678,9 +330,5 @@\n-bool VirtualMemoryTracker::walk_virtual_memory(VirtualMemoryWalker* walker) {\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n-  \/\/ Check that the _reserved_regions haven't been deleted.\n-  if (_reserved_regions != nullptr) {\n-    LinkedListNode<ReservedMemoryRegion>* head = _reserved_regions->head();\n-    while (head != nullptr) {\n-      const ReservedMemoryRegion* rgn = head->peek();\n-      if (!walker->do_allocation_site(rgn)) {\n+ReservedMemoryRegion RegionsTree::find_reserved_region(address addr) {\n+    ReservedMemoryRegion rmr;\n+    auto contain_region = [&](ReservedMemoryRegion& region_in_tree) {\n+      if (region_in_tree.contain_address(addr)) {\n+        rmr = region_in_tree;\n@@ -689,4 +337,4 @@\n-      head = head->next();\n-    }\n-   }\n-  return true;\n+      return true;\n+    };\n+    visit_reserved_regions(contain_region);\n+    return rmr;\n@@ -695,30 +343,3 @@\n-class PrintRegionWalker : public VirtualMemoryWalker {\n-private:\n-  const address               _p;\n-  outputStream*               _st;\n-  NativeCallStackPrinter      _stackprinter;\n-public:\n-  PrintRegionWalker(const void* p, outputStream* st) :\n-    _p((address)p), _st(st), _stackprinter(st) { }\n-\n-  bool do_allocation_site(const ReservedMemoryRegion* rgn) {\n-    if (rgn->contain_address(_p)) {\n-      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n-        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), NMTUtil::tag_to_enum_name(rgn->mem_tag()));\n-      if (MemTracker::tracking_level() == NMT_detail) {\n-        _stackprinter.print_stack(rgn->call_stack());\n-        _st->cr();\n-      }\n-      return false;\n-    }\n-    return true;\n-  }\n-};\n-\n-\/\/ If p is contained within a known memory region, print information about it to the\n-\/\/ given stream and return true; false otherwise.\n-bool VirtualMemoryTracker::print_containing_region(const void* p, outputStream* st) {\n-  PrintRegionWalker walker(p, st);\n-  return !walk_virtual_memory(&walker);\n-\n-}\n+bool CommittedMemoryRegion::equals(const ReservedMemoryRegion& rmr) const {\n+  return size() == rmr.size() && call_stack()->equals(*(rmr.call_stack()));\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":164,"deletions":543,"binary":false,"changes":707,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/metaspace.hpp\" \/\/ For MetadataType\n-#include \"memory\/metaspaceStats.hpp\"\n@@ -32,1 +29,2 @@\n-#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/vmatree.hpp\"\n+#include \"nmt\/regionsTree.hpp\"\n@@ -34,1 +32,0 @@\n-#include \"utilities\/linkedlist.hpp\"\n@@ -38,0 +35,16 @@\n+\/\/ VirtualMemoryTracker (VMT) is an internal class of the MemTracker.\n+\/\/ All the Hotspot code use only the MemTracker interface to register the memory operations in NMT.\n+\/\/ Memory regions can be reserved\/committed\/uncommitted\/released by calling MemTracker API which in turn call the corresponding functions in VMT.\n+\/\/ VMT uses RegionsTree to hold and manage the memory regions. Each region has two nodes that each one has address of the region (start\/end) and\n+\/\/ state (reserved\/released\/committed) and MemTag of the regions before and after it.\n+\/\/\n+\/\/ The memory operations of Reserve\/Commit\/Uncommit\/Release are tracked by updating\/inserting\/deleting the nodes in the tree. When an operation\n+\/\/ changes nodes in the tree, the summary of the changes is returned back in a SummaryDiff struct. This struct shows that how much reserve\/commit amount\n+\/\/ of any specific MemTag is changed. The summary of every operation is accumulated in VirtualMemorySummary class.\n+\/\/\n+\/\/ Not all operations are valid in VMT. The following predicates are checked before the operation is applied to the tree and\/or VirtualMemorySummary:\n+\/\/   - committed size of a MemTag should be <= of its reserved size\n+\/\/   - uncommitted size of a MemTag should be <= of its committed size\n+\/\/   - released size of a MemTag should be <= of its reserved size\n+\n+\n@@ -279,2 +292,5 @@\n-  CommittedMemoryRegion(address addr, size_t size, const NativeCallStack& stack) :\n-    VirtualMemoryRegion(addr, size), _stack(stack) { }\n+  CommittedMemoryRegion()\n+    : VirtualMemoryRegion((address)1, 1), _stack(NativeCallStack::empty_stack()) { }\n+\n+  CommittedMemoryRegion(address addr, size_t size, const NativeCallStack& stack)\n+    : VirtualMemoryRegion(addr, size), _stack(stack) { }\n@@ -284,0 +300,1 @@\n+  bool equals(const ReservedMemoryRegion& other) const;\n@@ -286,4 +303,0 @@\n-\n-typedef LinkedListIterator<CommittedMemoryRegion> CommittedRegionIterator;\n-\n-int compare_committed_region(const CommittedMemoryRegion&, const CommittedMemoryRegion&);\n@@ -292,3 +305,0 @@\n-  SortedLinkedList<CommittedMemoryRegion, compare_committed_region>\n-    _committed_regions;\n-\n@@ -296,1 +306,1 @@\n-  MemTag           _mem_tag;\n+  MemTag         _mem_tag;\n@@ -299,0 +309,5 @@\n+  bool is_valid() { return base() != (address)1 && size() != 1;}\n+\n+  ReservedMemoryRegion()\n+    : VirtualMemoryRegion((address)1, 1), _stack(NativeCallStack::empty_stack()), _mem_tag(mtNone) { }\n+\n@@ -300,2 +315,2 @@\n-    MemTag mem_tag) :\n-    VirtualMemoryRegion(base, size), _stack(stack), _mem_tag(mem_tag) { }\n+    MemTag mem_tag = mtNone)\n+    : VirtualMemoryRegion(base, size), _stack(stack), _mem_tag(mem_tag) { }\n@@ -304,2 +319,2 @@\n-  ReservedMemoryRegion(address base, size_t size) :\n-    VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _mem_tag(mtNone) { }\n+  ReservedMemoryRegion(address base, size_t size)\n+    : VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _mem_tag(mtNone) { }\n@@ -308,2 +323,2 @@\n-  ReservedMemoryRegion(const ReservedMemoryRegion& rr) :\n-    VirtualMemoryRegion(rr.base(), rr.size()) {\n+  ReservedMemoryRegion(const ReservedMemoryRegion& rr)\n+    : VirtualMemoryRegion(rr.base(), rr.size()) {\n@@ -316,1 +331,0 @@\n-  void  set_mem_tag(MemTag mem_tag);\n@@ -322,4 +336,1 @@\n-  bool    add_committed_region(address addr, size_t size, const NativeCallStack& stack);\n-  bool    remove_uncommitted_region(address addr, size_t size);\n-\n-  size_t  committed_size() const;\n+  size_t committed_size() const;\n@@ -327,7 +338,0 @@\n-  \/\/ move committed regions that higher than specified address to\n-  \/\/ the new region\n-  void    move_committed_regions(address addr, ReservedMemoryRegion& rgn);\n-\n-  CommittedRegionIterator iterate_committed_regions() const {\n-    return CommittedRegionIterator(_committed_regions.head());\n-  }\n@@ -339,1 +343,1 @@\n-    _stack   = *other.call_stack();\n+    _stack = *other.call_stack();\n@@ -341,8 +345,0 @@\n-    _committed_regions.clear();\n-\n-    CommittedRegionIterator itr = other.iterate_committed_regions();\n-    const CommittedMemoryRegion* rgn = itr.next();\n-    while (rgn != nullptr) {\n-      _committed_regions.add(*rgn);\n-      rgn = itr.next();\n-    }\n@@ -353,13 +349,1 @@\n-  const char* mem_tag_name() const { return NMTUtil::tag_to_name(_mem_tag); }\n-\n- private:\n-  \/\/ The committed region contains the uncommitted region, subtract the uncommitted\n-  \/\/ region from this committed region\n-  bool remove_uncommitted_region(LinkedListNode<CommittedMemoryRegion>* node,\n-    address addr, size_t sz);\n-\n-  bool add_committed_region(const CommittedMemoryRegion& rgn) {\n-    assert(rgn.base() != nullptr, \"Invalid base address\");\n-    assert(size() > 0, \"Invalid size\");\n-    return _committed_regions.add(rgn) != nullptr;\n-  }\n+  const char* tag_name() const { return NMTUtil::tag_to_name(_mem_tag); }\n@@ -368,2 +352,0 @@\n-int compare_reserved_region_base(const ReservedMemoryRegion& r1, const ReservedMemoryRegion& r2);\n-\n@@ -375,4 +357,0 @@\n-\/\/ Main class called from MemTracker to track virtual memory allocations, commits and releases.\n-class VirtualMemoryTracker : AllStatic {\n-  friend class VirtualMemoryTrackerTest;\n-  friend class CommittedVirtualMemoryTest;\n@@ -380,2 +358,2 @@\n- public:\n-  static bool initialize(NMT_TrackingLevel level);\n+class VirtualMemoryTracker {\n+  RegionsTree _tree;\n@@ -383,1 +361,2 @@\n-  static bool add_reserved_region (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag);\n+ public:\n+  VirtualMemoryTracker(bool is_detailed_mode) : _tree(is_detailed_mode) { }\n@@ -385,5 +364,5 @@\n-  static bool add_committed_region      (address base_addr, size_t size, const NativeCallStack& stack);\n-  static bool remove_uncommitted_region (address base_addr, size_t size);\n-  static bool remove_released_region    (address base_addr, size_t size);\n-  static bool remove_released_region    (ReservedMemoryRegion* rgn);\n-  static void set_reserved_region_type  (address addr, size_t size, MemTag mem_tag);\n+  void add_reserved_region       (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  void add_committed_region      (address base_addr, size_t size, const NativeCallStack& stack);\n+  void remove_uncommitted_region (address base_addr, size_t size);\n+  void remove_released_region    (address base_addr, size_t size);\n+  void set_reserved_region_tag   (address addr, size_t size, MemTag mem_tag);\n@@ -393,2 +372,2 @@\n-  \/\/  stack and the memory tag of the original section.\n-  static bool split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_type);\n+  \/\/  stack and the memory tags of the original section.\n+  void split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag);\n@@ -397,1 +376,1 @@\n-  static bool walk_virtual_memory(VirtualMemoryWalker* walker);\n+  bool walk_virtual_memory(VirtualMemoryWalker* walker);\n@@ -401,1 +380,1 @@\n-  static bool print_containing_region(const void* p, outputStream* st);\n+  bool print_containing_region(const void* p, outputStream* st);\n@@ -404,4 +383,27 @@\n-  static void snapshot_thread_stacks();\n-\n- private:\n-  static SortedLinkedList<ReservedMemoryRegion, compare_reserved_region_base>* _reserved_regions;\n+  void snapshot_thread_stacks();\n+  void apply_summary_diff(VMATree::SummaryDiff diff);\n+  RegionsTree* tree() { return &_tree; }\n+\n+  class Instance : public AllStatic {\n+    friend class VirtualMemoryTrackerTest;\n+    friend class CommittedVirtualMemoryTest;\n+\n+    static VirtualMemoryTracker* _tracker;\n+\n+   public:\n+    using RegionData = VMATree::RegionData;\n+    static bool initialize(NMT_TrackingLevel level);\n+\n+    static void add_reserved_region       (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+    static void add_committed_region      (address base_addr, size_t size, const NativeCallStack& stack);\n+    static void remove_uncommitted_region (address base_addr, size_t size);\n+    static void remove_released_region    (address base_addr, size_t size);\n+    static void set_reserved_region_tag   (address addr, size_t size, MemTag mem_tag);\n+    static void split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag);\n+    static bool walk_virtual_memory(VirtualMemoryWalker* walker);\n+    static bool print_containing_region(const void* p, outputStream* st);\n+    static void snapshot_thread_stacks();\n+    static void apply_summary_diff(VMATree::SummaryDiff diff);\n+\n+    static RegionsTree* tree() { return _tracker->tree(); }\n+  };\n@@ -410,2 +412,1 @@\n-#endif \/\/ SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n-\n+#endif \/\/ SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":80,"deletions":79,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-const VMATree::RegionData VMATree::empty_regiondata{NativeCallStackStorage::StackIndex{}, mtNone};\n@@ -33,2 +32,55 @@\n-const char* VMATree::statetype_strings[3] = {\n-  \"reserved\", \"committed\", \"released\",\n+\/\/ Semantics\n+\/\/ This tree is used to store and track the state of virtual memory regions.\n+\/\/ The nodes in the tree are key-value pairs where the key is the memory address and the value is the State of the memory regions.\n+\/\/ The State of a region describes whether the region is released, reserved or committed, which MemTag it has and where in\n+\/\/ Hotspot (using call-stacks) it is reserved or committed.\n+\/\/ Each node holds the State of the regions to its left and right. Each memory region is described by two\n+\/\/ memory addresses for its start and end.\n+\/\/ For example, to describe the region that starts at memory address 0xA000 with size 0x1000, there will be two nodes\n+\/\/ with the keys 0xA000 (node A) and 0xB000 (node B) in the tree. The value of the key-value pairs of node A and\n+\/\/ node B describe the region's State, using right of A and left of B (<--left--A--right-->.....<--left--B--right-->...).\n+\/\/\n+\/\/ Virtual memory can be reserved, committed, uncommitted and released. For each operation a request\n+\/\/ (<from-address, to-address, operation, tag, call-stack, which-tag-to-use >) is sent to the tree to handle.\n+\/\/\n+\/\/ The expected changes are described here for each operation:\n+\/\/\n+\/\/ ### Reserve a region\n+\/\/ When a region is reserved, all the overlapping regions in the tree should:\n+\/\/   - be marked as Reserved\n+\/\/   - take MemTag of the operation\n+\/\/   - store call-stack of the request to the reserve call-stack\n+\/\/   - clear commit call-stack\n+\/\/\n+\/\/ ### Commit a region\n+\/\/ When a region is committed, all the overlapping regions in the tree should:\n+\/\/   - be marked as Committed\n+\/\/   - take MemTag of the operation or MemTag of the existing region, depends on which-tag-to-use in the request\n+\/\/   - if the region is in Released state\n+\/\/     - mark the region as both Reserved and Committed\n+\/\/     - store the call-stack of the request to the reserve call-stack\n+\/\/   - store the call-stack of the request to the commit call-stack\n+\/\/\n+\/\/ ### Uncommit a region\n+\/\/ When a region is uncommitted, all the overlapping regions in the tree should:\n+\/\/   - be ignored if the region is in Released state\n+\/\/   - be marked as Reserved\n+\/\/   - not change the MemTag\n+\/\/   - not change the reserve call-stack\n+\/\/   - clear commit call-stack\n+\/\/\n+\/\/ ### Release a region\n+\/\/ When a region is released, all the overlapping regions in the tree should:\n+\/\/   - be marked as Released\n+\/\/   - set the MemTag to mtNone\n+\/\/   - clear both reserve and commit call-stack\n+\/\/\n+\/\/ ---  Accounting\n+\/\/ After each operation, the tree should be able to report how much memory is reserved or committed per MemTag.\n+\/\/ So for each region that changes to a new State, the report should contain (separately for each tag) the amount\n+\/\/ of reserve and commit that are changed (increased or decreased) due to the operation.\n+\n+const VMATree::RegionData VMATree::empty_regiondata{NativeCallStackStorage::invalid, mtNone};\n+\n+const char* VMATree::statetype_strings[4] = {\n+  \"released\",\"reserved\", \"only-committed\", \"committed\",\n@@ -37,1 +89,157 @@\n-VMATree::SummaryDiff VMATree::register_mapping(position A, position B, StateType state,\n+VMATree::SIndex VMATree::get_new_reserve_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  const int op = req.op_to_index();\n+  const Operation oper = req.op();\n+  assert(op >= 0 && op < 4, \"should be\");\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {rq, rq, rq},   \/\/ op == Reserve\n+                           {es, es, es},   \/\/ op == Commit\n+                           {es, es, es}    \/\/ op == Uncommit\n+                           };\n+  \/\/ When committing a Released region, the reserve-call-stack of the region should also be as what is in the request\n+  if (oper == Operation::Commit && ex == StateType::Released) {\n+    return rq;\n+  } else {\n+    return result[op][state_to_index(ex)];\n+  }\n+}\n+\n+VMATree::SIndex VMATree::get_new_commit_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  const int op_index = req.op_to_index();\n+  const Operation op = req.op();\n+  assert(op_index >= 0 && op_index < 4, \"should be\");\n+                         \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {ES, ES, ES},   \/\/ op == Reserve\n+                           {rq, rq, rq},   \/\/ op == Commit\n+                           {ES, ES, ES}    \/\/ op == Uncommit\n+                        };\n+  return result[op_index][state_to_index(ex)];\n+}\n+\n+VMATree::StateType VMATree::get_new_state(const StateType ex, const RequestInfo& req) const {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  const int op = req.op_to_index();\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  StateType result[4][3] = {\/\/ Rl  Rs   C\n+                              {Rl, Rl, Rl},   \/\/ op == Release\n+                              {Rs, Rs, Rs},   \/\/ op == Reserve\n+                              { C,  C,  C},   \/\/ op == Commit\n+                              {Rl, Rs, Rs}    \/\/ op == Uncommit\n+                           };\n+  return result[op][state_to_index(ex)];\n+}\n+\n+MemTag VMATree::get_new_tag(const MemTag ex, const RequestInfo& req) const {\n+  switch(req.op()) {\n+    case Operation::Release:\n+      return mtNone;\n+    case Operation::Reserve:\n+      return req.tag;\n+    case Operation::Commit:\n+      return req.use_tag_inplace ? ex : req.tag;\n+    case Operation::Uncommit:\n+      return ex;\n+    default:\n+      break;\n+  }\n+  return mtNone;\n+}\n+\n+void VMATree::compute_summary_diff(const SingleDiff::delta region_size,\n+                                   const MemTag current_tag,\n+                                   const StateType& ex,\n+                                   const RequestInfo& req,\n+                                   const MemTag operation_tag,\n+                                   SummaryDiff& diff) const {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  const int op = req.op_to_index();\n+  const Operation oper =  req.op();\n+  assert(op >= 0 && op < 4, \"should be\");\n+\n+  SingleDiff::delta a = region_size;\n+  \/\/ A region with size `a` has a state as <column> and an operation is requested as in <row>\n+  \/\/ The region has tag `current_tag` and the operation has tag `operation_tag`.\n+  \/\/ For each state, we decide how much to be added\/subtracted from current_tag to operation_tag. Two tables for reserve and commit.\n+  \/\/ Each pair of <x,y> in the table means add `x` to current_tag and add `y` to operation_tag. There are 3 pairs in each row for 3 states.\n+  \/\/ For example, `reserve[1][4,5]` says `-a,a` means:\n+  \/\/    - we are reserving with operation_tag a region which is already commited with current_tag\n+  \/\/    - since we are reserving, then `a` will be added to operation_tag. (`y` is `a`)\n+  \/\/    - since we uncommitting (by reserving) then `a` is to be subtracted from current_tag. (`x` is `-a`).\n+  \/\/    - amount of uncommitted size is in table `commit[1][4,5]` which is `-a,0` that means subtract `a` from current_tag.\n+                                       \/\/ existing state\n+  SingleDiff::delta reserve[4][3*2] = {\/\/ Rl    Rs     C\n+                                         {0,0, -a,0, -a,0 },   \/\/ op == Release\n+                                         {0,a, -a,a, -a,a },   \/\/ op == Reserve\n+                                         {0,a, -a,a, -a,a },   \/\/ op == Commit\n+                                         {0,0,  0,0,  0,0 }    \/\/ op == Uncommit\n+                                      };\n+  SingleDiff::delta commit[4][3*2] = {\/\/ Rl    Rs     C\n+                                        {0,0,  0,0, -a,0 },    \/\/ op == Release\n+                                        {0,0,  0,0, -a,0 },    \/\/ op == Reserve\n+                                        {0,a,  0,a, -a,a },    \/\/ op == Commit\n+                                        {0,0,  0,0, -a,0 }     \/\/ op == Uncommit\n+                                     };\n+  SingleDiff& from_rescom = diff.tag[NMTUtil::tag_to_index(current_tag)];\n+  SingleDiff&   to_rescom = diff.tag[NMTUtil::tag_to_index(operation_tag)];\n+  int st = state_to_index(ex);\n+  from_rescom.reserve += reserve[op][st * 2    ];\n+    to_rescom.reserve += reserve[op][st * 2 + 1];\n+  from_rescom.commit  +=  commit[op][st * 2    ];\n+    to_rescom.commit  +=  commit[op][st * 2 + 1];\n+\n+}\n+\/\/ update the region state between n1 and n2. Since n1 and n2 are pointers, any update of them will be visible from tree.\n+\/\/ If n1 is noop, it can be removed because its left region (n1->val().in) is already decided and its right state (n1->val().out) is decided here.\n+\/\/ The state of right of n2 (n2->val().out) cannot be decided here yet.\n+void VMATree::update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n+  assert(n1 != nullptr,\"sanity\");\n+  assert(n2 != nullptr,\"sanity\");\n+  \/\/.........n1......n2......\n+  \/\/          ^------^\n+  \/\/             |\n+  IntervalState exSt = n1->val().out; \/\/ existing state info\n+\n+\n+  StateType existing_state              = exSt.type();\n+  MemTag    existing_tag                = exSt.mem_tag();\n+  SIndex    existing_reserve_callstack  = exSt.reserved_stack();\n+  SIndex    existing_commit_callstack   = exSt.committed_stack();\n+\n+  StateType new_state                   = get_new_state(existing_state, req);\n+  MemTag    new_tag                     = get_new_tag(n1->val().out.mem_tag(), req);\n+  SIndex    new_reserve_callstack       = get_new_reserve_callstack(existing_reserve_callstack, existing_state, req);\n+  SIndex    new_commit_callstack        = get_new_commit_callstack(existing_commit_callstack, existing_state, req);\n+\n+  \/\/  n1........n2\n+  \/\/ out-->\n+  n1->val().out.set_tag(new_tag);\n+  n1->val().out.set_type(new_state);\n+  n1->val().out.set_reserve_stack(new_reserve_callstack);\n+  n1->val().out.set_commit_stack(new_commit_callstack);\n+\n+  \/\/  n1........n2\n+  \/\/         <--in\n+  n2->val().in.set_tag(new_tag);\n+  n2->val().in.set_type(new_state);\n+  n2->val().in.set_reserve_stack(new_reserve_callstack);\n+  n2->val().in.set_commit_stack(new_commit_callstack);\n+\n+  SingleDiff::delta region_size = n2->key() - n1->key();\n+  compute_summary_diff(region_size, existing_tag, existing_state, req, new_tag, diff);\n+}\n+\n+\n+VMATree::SummaryDiff VMATree::register_mapping(position _A, position _B, StateType state,\n@@ -39,4 +247,2 @@\n-  assert(!use_tag_inplace || metadata.mem_tag == mtNone,\n-         \"If using use_tag_inplace, then the supplied tag should be mtNone, was instead: %s\", NMTUtil::tag_to_name(metadata.mem_tag));\n-  if (A == B) {\n-    \/\/ A 0-sized mapping isn't worth recording.\n+\n+  if (_A == _B) {\n@@ -45,1 +251,3 @@\n-\n+  assert(_A < _B, \"should be\");\n+  SummaryDiff diff;\n+  RequestInfo req{_A, _B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n@@ -54,0 +262,4 @@\n+  stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n+  stB.in.set_commit_stack(NativeCallStackStorage::invalid);\n+  VMATreap::Range rA = _tree.find_enclosing_range(_A);\n+  VMATreap::Range rB = _tree.find_enclosing_range(_B);\n@@ -55,13 +267,67 @@\n-  \/\/ First handle A.\n-  \/\/ Find closest node that is LEQ A\n-  bool LEQ_A_found = false;\n-  AddressState LEQ_A;\n-  TreapNode* leqA_n = _tree.closest_leq(A);\n-  if (leqA_n == nullptr) {\n-    assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    if (use_tag_inplace) {\n-      log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    }\n-    \/\/ No match. We add the A node directly, unless it would have no effect.\n-    if (!stA.is_noop()) {\n-      _tree.upsert(A, stA);\n+  \/\/ nodes:          .....X.......Y...Z......W........U\n+  \/\/ request:                 A------------------B\n+  \/\/ X,Y = enclosing_nodes(A)\n+  \/\/ W,U = enclosing_nodes(B)\n+  \/\/ The cases are whether or not X and Y exists and X == A. (A == Y doesn't happen since it is searched by 'lt' predicate)\n+  \/\/ The cases are whether or not W and U exists and W == B. (B == U doesn't happen since it is searched by 'lt' predicate)\n+\n+  \/\/ We update regions in 3 sections: 1) X..A..Y, 2) Y....W, 3) W..B..U\n+  \/\/ Y: is the closest node greater than A, but less than B\n+  \/\/ W: is the closest node less than B, but greater than A\n+  \/\/ The regions in [Y,W) are updated in a loop. We update X..A..Y before the loop and W..B..U after the loop.\n+  \/\/ The table below summarizes the overlap cases. The overlapping case depends on whether X, Y, W and U exist or not,\n+  \/\/ and if they exist whether they are the same or not.\n+  \/\/ In the notations here, when there is not dot ('.') between two nodes it meaans that they are the same. For example,\n+  \/\/ ...XA....Y.... means X == A.\n+\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ row  1:  .........A...YW.............B.....  \/\/ it is impossible, since it means only one node exists in the tree.\n+  \/\/ row  2:  .........A...Y..........W...B.....\n+  \/\/ row  3:  .........A...Y.............WB.....\n+\n+  \/\/ row  4:  .....X...A..................B.....\n+  \/\/ row  5:  .....X...A...YW.............B.....\n+  \/\/ row  6:  .....X...A...Y..........W...B.....\n+  \/\/ row  7:  .....X...A...Y.............WB.....\n+\n+  \/\/ row  8:  ........XA..................B.....\n+  \/\/ row  9:  ........XA...YW.............B.....\n+  \/\/ row 10:  ........XA...Y..........W...B.....\n+  \/\/ row 11:  ........XA...Y.............WB.....\n+\n+  \/\/ row 12:  .........A..................B....U\n+  \/\/ row 13:  .........A...YW.............B....U\n+  \/\/ row 14:  .........A...Y..........W...B....U\n+  \/\/ row 15:  .........A...Y.............WB....U\n+\n+  \/\/ row 16:  .....X...A..................B....U\n+  \/\/ row 17:  .....X...A...YW.............B....U\n+  \/\/ row 18:  .....X...A...Y..........W...B....U\n+  \/\/ row 19:  .....X...A...Y.............WB....U\n+\n+  \/\/ row 20:  ........XA..................B....U\n+  \/\/ row 21:  ........XA...YW.............B....U\n+  \/\/ row 22:  ........XA...Y..........W...B....U\n+  \/\/ row 23:  ........XA...Y.............WB....U\n+\n+\n+  \/\/ We intentionally did not summarize\/compress the cases to keep them as separate.\n+  \/\/ This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain\n+  \/\/ the corresponding code more easily.\n+  \/\/ Mapping of table to row, row to switch-case should be consistent. If one changes, the others have\n+  \/\/ to be updated accordingly. The sequence of dependecies is: table -> row no -> switch(row)-case -> code.\n+  \/\/ Meaning that whenever any of one item in this sequence is changed, the rest of the consequent items to\n+  \/\/ be checked\/changed.\n+\n+  TreapNode* X = rA.start;\n+  TreapNode* Y = rA.end;\n+  TreapNode* W = rB.start;\n+  TreapNode* U = rB.end;\n+  TreapNode nA{_A, stA, 0}; \/\/ the node that represents A\n+  TreapNode nB{_B, stB, 0}; \/\/ the node that represents B\n+  TreapNode* A = &nA;\n+  TreapNode* B = &nB;\n+  auto upsert_if= [&](TreapNode* node) {\n+    if (!node->val().is_noop()) {\n+      _tree.upsert(node->key(), node->val());\n@@ -69,12 +335,9 @@\n-  } else {\n-    LEQ_A_found = true;\n-    LEQ_A = AddressState{leqA_n->key(), leqA_n->val()};\n-    StateType leqA_state = leqA_n->val().out.type();\n-    StateType new_state = stA.out.type();\n-    \/\/ If we specify use_tag_inplace then the new region takes over the current tag instead of the tag in metadata.\n-    \/\/ This is important because the VirtualMemoryTracker API doesn't require supplying the tag for some operations.\n-    if (use_tag_inplace) {\n-      assert(leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n-      MemTag tag = leqA_n->val().out.mem_tag();\n-      stA.out.set_tag(tag);\n-      stB.in.set_tag(tag);\n+  };\n+  \/\/ update region between n1 and n2\n+  auto update = [&](TreapNode* n1, TreapNode* n2) {\n+    update_region(n1, n2, req, diff);\n+  };\n+  auto remove_if = [&](TreapNode* node) -> bool{\n+    if (node->val().is_noop()) {\n+      _tree.remove(node->key());\n+      return true;\n@@ -82,40 +345,14 @@\n-\n-    \/\/ Unless we know better, let B's outgoing state be the outgoing state of the node at or preceding A.\n-    \/\/ Consider the case where the found node is the start of a region enclosing [A,B)\n-    stB.out = out_state(leqA_n);\n-\n-    \/\/ Direct address match.\n-    if (leqA_n->key() == A) {\n-      \/\/ Take over in state from old address.\n-      stA.in = in_state(leqA_n);\n-\n-      \/\/ We may now be able to merge two regions:\n-      \/\/ If the node's old state matches the new, it becomes a noop. That happens, for example,\n-      \/\/ when expanding a committed area: commit [x1, A); ... commit [A, x3)\n-      \/\/ and the result should be a larger area, [x1, x3). In that case, the middle node (A and le_n)\n-      \/\/ is not needed anymore. So we just remove the old node.\n-      stB.in = stA.out;\n-      if (stA.is_noop()) {\n-        \/\/ invalidates leqA_n\n-        _tree.remove(leqA_n->key());\n-      } else {\n-        \/\/ If the state is not matching then we have different operations, such as:\n-        \/\/ reserve [x1, A); ... commit [A, x2); or\n-        \/\/ reserve [x1, A), mem_tag1; ... reserve [A, x2), mem_tag2; or\n-        \/\/ reserve [A, x1), mem_tag1; ... reserve [A, x2), mem_tag2;\n-        \/\/ then we re-use the existing out node, overwriting its old metadata.\n-        leqA_n->val() = stA;\n-      }\n-    } else {\n-      \/\/ The address must be smaller.\n-      assert(A > leqA_n->key(), \"must be\");\n-\n-      \/\/ We add a new node, but only if there would be a state change. If there would not be a\n-      \/\/ state change, we just omit the node.\n-      \/\/ That happens, for example, when reserving within an already reserved region with identical metadata.\n-      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n-      if (stA.is_noop()) {\n-        \/\/ Nothing to do.\n-      } else {\n-        \/\/ Add new node.\n-        _tree.upsert(A, stA);\n+    return false;\n+  };\n+  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n+  \/\/ update regions in range A to B\n+  auto update_loop = [&]() {\n+    TreapNode* prev = nullptr;\n+    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n+      if (prev != nullptr) {\n+        update_region(prev, curr, req, diff);\n+        \/\/ during visit, structure of the tree should not be changed\n+        \/\/ keep the keys to be removed, and remove them later\n+        if (prev->val().is_noop()) {\n+          to_be_removed.push(prev->key());\n+        }\n@@ -123,2 +360,35 @@\n-    }\n-  }\n+      prev = curr;\n+      return true;\n+    });\n+  };\n+  \/\/ update region of [A,T)\n+  auto update_A = [&](TreapNode* T) {\n+    A->val().out = A->val().in;\n+    update(A, T);\n+  };\n+  bool X_exists = X != nullptr;\n+  bool Y_exists = Y != nullptr && Y->key() <= _B;\n+  bool W_exists = W != nullptr && W->key() > _A;\n+  bool U_exists = U != nullptr;\n+  bool X_eq_A = X_exists && X->key() == _A;\n+  bool W_eq_B = W_exists && W->key() == _B;\n+  bool Y_eq_W = Y_exists && W_exists && W->key() == Y->key();\n+  int row = -1;\n+#ifdef ASSERT\n+  auto print_case = [&]() {\n+    log_trace(vmatree)(\" req: %4d---%4d\", (int)_A, (int)_B);\n+    log_trace(vmatree)(\" row: %2d\", row);\n+    log_trace(vmatree)(\" X: %4ld\", X_exists ? (long)X->key() : -1);\n+    log_trace(vmatree)(\" Y: %4ld\", Y_exists ? (long)Y->key() : -1);\n+    log_trace(vmatree)(\" W: %4ld\", W_exists ? (long)W->key() : -1);\n+    log_trace(vmatree)(\" U: %4ld\", U_exists ? (long)U->key() : -1);\n+  };\n+#endif\n+  \/\/ Order of the nodes if they exist are as: X <= A < Y <= W <= B < U\n+  \/\/             A---------------------------B\n+  \/\/       X           Y          YW         WB          U\n+  \/\/       XA          Y          YW         WB          U\n+  if (!X_exists && !Y_exists                       && !U_exists) { row =  0; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  1; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  2; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  3; }\n@@ -126,26 +396,4 @@\n-  \/\/ Now we handle B.\n-  \/\/ We first search all nodes that are (A, B]. All of these nodes\n-  \/\/ need to be deleted and summary accounted for. The last node before B determines B's outgoing state.\n-  \/\/ If there is no node between A and B, its A's incoming state.\n-  GrowableArrayCHeap<AddressState, mtNMT> to_be_deleted_inbetween_a_b;\n-  bool B_needs_insert = true;\n-\n-  \/\/ Find all nodes between (A, B] and record their addresses and values. Also update B's\n-  \/\/ outgoing state.\n-  _tree.visit_range_in_order(A + 1, B + 1, [&](TreapNode* head) {\n-    int cmp_B = PositionComparator::cmp(head->key(), B);\n-    stB.out = out_state(head);\n-    if (cmp_B < 0) {\n-      \/\/ Record all nodes preceding B.\n-      to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n-    } else if (cmp_B == 0) {\n-      \/\/ Re-purpose B node, unless it would result in a noop node, in\n-      \/\/ which case record old node at B for deletion and summary accounting.\n-      if (stB.is_noop()) {\n-        to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n-      } else {\n-        head->val() = stB;\n-      }\n-      B_needs_insert = false;\n-    }\n-  });\n+  if ( X_exists && !Y_exists                       && !U_exists) { row =  4; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  5; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  6; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  7; }\n@@ -153,6 +401,4 @@\n-  \/\/ Insert B node if needed\n-  if (B_needs_insert && \/\/ Was not already inserted\n-      !stB.is_noop())   \/\/ The operation is differing\n-    {\n-    _tree.upsert(B, stB);\n-  }\n+  if ( X_eq_A   && !Y_exists                       && !U_exists) { row =  8; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  9; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row = 10; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B && !U_exists) { row = 11; }\n@@ -160,4 +406,4 @@\n-  \/\/ We now need to:\n-  \/\/ a) Delete all nodes between (A, B]. Including B in the case of a noop.\n-  \/\/ b) Perform summary accounting\n-  SummaryDiff diff;\n+  if (!X_exists && !Y_exists                       &&  U_exists) { row = 12; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 13; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 14; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 15; }\n@@ -165,11 +411,4 @@\n-  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found) {\n-    \/\/ We must have smashed a hole in an existing region (or replaced it entirely).\n-    \/\/ LEQ_A < A < B <= C\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(LEQ_A.out().mem_tag())];\n-    if (LEQ_A.out().type() == StateType::Reserved) {\n-      rescom.reserve -= B - A;\n-    } else if (LEQ_A.out().type() == StateType::Committed) {\n-      rescom.commit -= B - A;\n-      rescom.reserve -= B - A;\n-    }\n-  }\n+  if ( X_exists && !Y_exists                       &&  U_exists) { row = 16; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 17; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 18; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 19; }\n@@ -177,16 +416,4 @@\n-  \/\/ Track the previous node.\n-  AddressState prev{A, stA};\n-  for (int i = 0; i < to_be_deleted_inbetween_a_b.length(); i++) {\n-    const AddressState delete_me = to_be_deleted_inbetween_a_b.at(i);\n-    _tree.remove(delete_me.address);\n-\n-    \/\/ Perform summary accounting\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(delete_me.in().mem_tag())];\n-    if (delete_me.in().type() == StateType::Reserved) {\n-      rescom.reserve -= delete_me.address - prev.address;\n-    } else if (delete_me.in().type() == StateType::Committed) {\n-      rescom.commit -= delete_me.address - prev.address;\n-      rescom.reserve -= delete_me.address - prev.address;\n-    }\n-    prev = delete_me;\n-  }\n+  if ( X_eq_A   && !Y_exists                       &&  U_exists) { row = 20; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 21; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 22; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B &&  U_exists) { row = 23; }\n@@ -194,11 +421,39 @@\n-  if (prev.address != A && prev.out().type() != StateType::Released) {\n-    \/\/ The last node wasn't released, so it must be connected to a node outside of (A, B)\n-    \/\/ A - prev - B - (some node >= B)\n-    \/\/ It might be that prev.address == B == (some node >= B), this is fine.\n-    if (prev.out().type() == StateType::Reserved) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.reserve -= B - prev.address;\n-    } else if (prev.out().type() == StateType::Committed) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.commit -= B - prev.address;\n-      rescom.reserve -= B - prev.address;\n+    switch(row) {\n+    \/\/ row  0:  .........A..................B.....\n+    case 0: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  1:  .........A...YW.............B.....\n+    case 1: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+    \/\/ row  2:  .........A...Y..........W...B.....\n+    case 2: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(Y);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  3:  .........A...Y.............WB.....\n+    case 3: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row  4:  .....X...A..................B.....\n+    case 4: {\n+      A->val().in = X->val().out;\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n@@ -206,0 +461,180 @@\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    case 5: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(Y, B);\n+      remove_if(Y);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  6:  .....X...A...Y..........W...B.....\n+    case 6: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  7:  .....X...A...Y.............WB.....\n+    case 7: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row  8:  ........XA..................B.....\n+    case 8: {\n+      update(X, B);\n+      remove_if(X);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  9:  ........XA...YW.............B.....\n+    case 9: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 10:  ........XA...Y..........W...B.....\n+    case 10: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 11:  ........XA...Y.............WB.....\n+    case 11: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 12:  .........A..................B....U\n+    case 12: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 13:  .........A...YW.............B....U\n+    case 13: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 14:  .........A...Y..........W...B....U\n+    case 14: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 15:  .........A...Y.............WB....U\n+    case 15: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 16:  .....X...A..................B....U\n+    case 16: {\n+      A->val().in = X->val().out;\n+      update_A(B);\n+      upsert_if(A);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    case 17: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 18:  .....X...A...Y..........W...B....U\n+    case 18: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 19:  .....X...A...Y.............WB....U\n+    case 19: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 20:  ........XA..................B....U\n+    case 20: {\n+      update(X, B);\n+      remove_if(X);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    case 21: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 22:  ........XA...Y..........W...B....U\n+    case 22: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 23:  ........XA...Y.............WB....U\n+    case 23: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n@@ -208,7 +643,3 @@\n-  \/\/ Finally, we can register the new region [A, B)'s summary data.\n-  SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(stA.out.mem_tag())];\n-  if (state == StateType::Reserved) {\n-    rescom.reserve += B - A;\n-  } else if (state == StateType::Committed) {\n-    rescom.commit += B - A;\n-    rescom.reserve += B - A;\n+  \/\/ Remove the 'noop' nodes that found inside the loop\n+  while(to_be_removed.length() != 0) {\n+    _tree.remove(to_be_removed.pop());\n@@ -216,0 +647,1 @@\n+\n@@ -222,2 +654,3 @@\n-    out->print(\"%zu (%s) - %s - \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n-               statetype_to_string(out_state(current).type()));\n+    out->print(\"%zu (%s) - %s [%d, %d]-> \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+              statetype_to_string(out_state(current).type()), current->val().out.reserved_stack(), current->val().out.committed_stack());\n+    return true;\n@@ -271,1 +704,1 @@\n-    RegionData new_data = RegionData(out.stack(), tag);\n+    RegionData new_data = RegionData(out.reserved_stack(), tag);\n@@ -292,1 +725,1 @@\n-      RegionData new_data = RegionData(out.stack(), tag);\n+      RegionData new_data = RegionData(out.reserved_stack(), tag);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":594,"deletions":161,"binary":false,"changes":755,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -43,0 +44,1 @@\n+  friend class VMTWithVMATreeTest;\n@@ -47,0 +49,1 @@\n+  using SIndex = NativeCallStackStorage::StackIndex;\n@@ -58,1 +61,3 @@\n-  enum class StateType : uint8_t { Reserved, Committed, Released, LAST };\n+  \/\/ Bit fields view: bit 0 for Reserved, bit 1 for Committed.\n+  \/\/ Setting a region as Committed preserves the Reserved state.\n+  enum class StateType : uint8_t { Reserved = 1, Committed = 3, Released = 0, st_number_of_states = 4 };\n@@ -61,1 +66,1 @@\n-  static const char* statetype_strings[static_cast<uint8_t>(StateType::LAST)];\n+  static const char* statetype_strings[static_cast<uint8_t>(StateType::st_number_of_states)];\n@@ -67,1 +72,1 @@\n-    assert(type != StateType::LAST, \"must be\");\n+    assert(type < StateType::st_number_of_states, \"must be\");\n@@ -73,1 +78,1 @@\n-    const NativeCallStackStorage::StackIndex stack_idx;\n+    const SIndex stack_idx;\n@@ -78,1 +83,1 @@\n-    RegionData(NativeCallStackStorage::StackIndex stack_idx, MemTag mem_tag)\n+    RegionData(SIndex stack_idx, MemTag mem_tag)\n@@ -94,1 +99,2 @@\n-    NativeCallStackStorage::StackIndex sidx;\n+    NativeCallStackStorage::StackIndex _reserved_stack;\n+    NativeCallStackStorage::StackIndex _committed_stack;\n@@ -97,1 +103,11 @@\n-    IntervalState() : type_tag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, _reserved_stack(NativeCallStackStorage::invalid), _committed_stack(NativeCallStackStorage::invalid) {}\n+    IntervalState(const StateType type,\n+                  const MemTag mt,\n+                  const NativeCallStackStorage::StackIndex res_stack,\n+                  const NativeCallStackStorage::StackIndex com_stack) {\n+      assert(!(type == StateType::Released) || mt == mtNone, \"Released state-type must have memory tag mtNone\");\n+      type_tag[0] = static_cast<uint8_t>(type);\n+      type_tag[1] = static_cast<uint8_t>(mt);\n+      _reserved_stack = res_stack;\n+      _committed_stack = com_stack;\n+    }\n@@ -102,1 +118,2 @@\n-      sidx = data.stack_idx;\n+      _reserved_stack = data.stack_idx;\n+      _committed_stack = NativeCallStackStorage::invalid;\n@@ -113,2 +130,5 @@\n-    RegionData regiondata() const {\n-      return RegionData{sidx, mem_tag()};\n+    RegionData reserved_regiondata() const {\n+      return RegionData{_reserved_stack, mem_tag()};\n+    }\n+    RegionData committed_regiondata() const {\n+      return RegionData{_committed_stack, mem_tag()};\n@@ -121,2 +141,33 @@\n-    NativeCallStackStorage::StackIndex stack() const {\n-     return sidx;\n+    NativeCallStackStorage::StackIndex reserved_stack() const {\n+      return _reserved_stack;\n+    }\n+\n+    NativeCallStackStorage::StackIndex committed_stack() const {\n+      return _committed_stack;\n+    }\n+\n+    void set_reserve_stack(NativeCallStackStorage::StackIndex idx) {\n+      _reserved_stack = idx;\n+    }\n+\n+    void set_commit_stack(NativeCallStackStorage::StackIndex idx) {\n+      _committed_stack = idx;\n+    }\n+\n+    bool has_reserved_stack() {\n+      return _reserved_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    bool has_committed_stack() {\n+      return _committed_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    void set_type(StateType t) {\n+      type_tag[0] = static_cast<uint8_t>(t);\n+    }\n+\n+    bool equals(const IntervalState& other) const {\n+      return mem_tag()          == other.mem_tag()          &&\n+             type()             == other.type()             &&\n+             reserved_stack()   == other.reserved_stack()   &&\n+             committed_stack()  == other.committed_stack();\n@@ -133,0 +184,5 @@\n+      if (in.type() == StateType::Released &&\n+          in.type() == out.type() &&\n+          in.mem_tag() == out.mem_tag()) {\n+        return true;\n+      }\n@@ -134,1 +190,2 @@\n-             RegionData::equals(in.regiondata(), out.regiondata());\n+             RegionData::equals(in.reserved_regiondata(), out.reserved_regiondata()) &&\n+             RegionData::equals(in.committed_regiondata(), out.committed_regiondata());\n@@ -196,0 +253,24 @@\n+  enum Operation {Release, Reserve, Commit, Uncommit};\n+  struct RequestInfo {\n+    position A, B;\n+    StateType _op;\n+    MemTag tag;\n+    SIndex callstack;\n+    bool use_tag_inplace;\n+    Operation op() const {\n+      return\n+            _op == StateType::Reserved && !use_tag_inplace  ? Operation::Reserve  :\n+            _op == StateType::Committed                     ? Operation::Commit   :\n+            _op == StateType::Reserved &&  use_tag_inplace  ? Operation::Uncommit :\n+             Operation::Release;\n+    }\n+\n+    int op_to_index() const {\n+      return\n+            _op == StateType::Reserved && !use_tag_inplace  ? 1 :\n+            _op == StateType::Committed                     ? 2 :\n+            _op == StateType::Reserved &&  use_tag_inplace  ? 3 :\n+             0;\n+    }\n+  };\n+\n@@ -198,0 +279,12 @@\n+  StateType get_new_state(const StateType existinting_state, const RequestInfo& req) const;\n+  MemTag get_new_tag(const MemTag existinting_tag, const RequestInfo& req) const;\n+  SIndex get_new_reserve_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  SIndex get_new_commit_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  void compute_summary_diff(const SingleDiff::delta region_size, const MemTag t1, const StateType& ex, const RequestInfo& req, const MemTag new_tag, SummaryDiff& diff) const;\n+  void update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff);\n+  int state_to_index(const StateType st) const {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  }\n@@ -218,6 +311,2 @@\n-  SummaryDiff release_mapping(position from, size size) {\n-    return register_mapping(from, from + size, StateType::Released, VMATree::empty_regiondata);\n-  }\n-\n-  VMATreap& tree() {\n-    return _tree;\n+  SummaryDiff release_mapping(position from, position sz) {\n+    return register_mapping(from, from + sz, StateType::Released, VMATree::empty_regiondata);\n@@ -235,1 +324,5 @@\n-\n+  template<typename F>\n+  void visit_range_in_order(const position& from, const position& to, F f) {\n+    _tree.visit_range_in_order(from, to, f);\n+  }\n+  VMATreap& tree() { return _tree; }\n@@ -237,1 +330,0 @@\n-\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":113,"deletions":21,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  static address  base_addr()        { return  (address)&_base; }\n+  static address  base_addr()        { return (address)&_base; }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n@@ -27,0 +29,1 @@\n+#include \"utilities\/packedTable.hpp\"\n@@ -40,2 +43,4 @@\n-                _field_flags.is_injected() ? lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8(),\n-                contended_group());\n+                _field_flags.is_generic() ? (_field_flags.is_injected() ?\n+                  lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8()\n+                  ) : \"\",\n+                is_contended() ? contended_group() : 0);\n@@ -65,0 +70,2 @@\n+  assert(fields->length() == java_fields + injected_fields, \"must be\");\n+\n@@ -71,1 +78,3 @@\n-  int storage_size = sizer.consumer()->position() + 1;\n+  \/\/ Originally there was an extra byte with 0 terminating the reading;\n+  \/\/ now we check limits instead.\n+  int storage_size = sizer.consumer()->position();\n@@ -82,2 +91,1 @@\n-    FieldInfo* fi = fields->adr_at(i);\n-    writer.map_field_info(*fi);\n+    writer.map_field_info(fields->at(i));\n@@ -88,1 +96,2 @@\n-  int jfc = r.next_uint();\n+  int jfc, ifc;\n+  r.read_field_counts(&jfc, &ifc);\n@@ -90,1 +99,0 @@\n-  int ifc = r.next_uint();\n@@ -122,0 +130,78 @@\n+int FieldInfoStream::compare_name_and_sig(const Symbol* n1, const Symbol* s1, const Symbol* n2, const Symbol* s2) {\n+  int cmp = n1->fast_compare(n2);\n+  return cmp != 0 ? cmp : s1->fast_compare(s2);\n+}\n+\n+\n+\/\/ We use both name and signature during the comparison; while JLS require unique\n+\/\/ names for fields, JVMS requires only unique name + signature combination.\n+struct field_pos {\n+  Symbol* _name;\n+  Symbol* _signature;\n+  int _index;\n+  int _position;\n+};\n+\n+class FieldInfoSupplier: public PackedTableBuilder::Supplier {\n+  const field_pos* _positions;\n+  size_t _elements;\n+\n+public:\n+  FieldInfoSupplier(const field_pos* positions, size_t elements): _positions(positions), _elements(elements) {}\n+\n+  bool next(uint32_t* key, uint32_t* value) override {\n+    if (_elements == 0) {\n+      return false;\n+    }\n+    *key = _positions->_position;\n+    *value = _positions->_index;\n+    ++_positions;\n+    --_elements;\n+    return true;\n+  }\n+};\n+\n+Array<u1>* FieldInfoStream::create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS) {\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    \/\/ We cannot use search table; in case of dynamic archives it should be sorted by \"requested\" addresses,\n+    \/\/ but Symbol* addresses are coming from _constants, which has \"buffered\" addresses.\n+    \/\/ For background, see new comments inside allocate_node_impl in symbolTable.cpp\n+    return nullptr;\n+  }\n+\n+  FieldInfoReader r(fis);\n+  int java_fields;\n+  int injected_fields;\n+  r.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields >= 0, \"must be\");\n+  if (java_fields == 0 || fis->length() == 0 || static_cast<uint>(java_fields) < BinarySearchThreshold) {\n+    return nullptr;\n+  }\n+\n+  ResourceMark rm;\n+  field_pos* positions = NEW_RESOURCE_ARRAY(field_pos, java_fields);\n+  for (int i = 0; i < java_fields; ++i) {\n+    assert(r.has_next(), \"number of fields must match\");\n+\n+    positions[i]._position = r.position();\n+    FieldInfo fi;\n+    r.read_field_info(fi);\n+\n+    positions[i]._name = fi.name(cp);\n+    positions[i]._signature = fi.signature(cp);\n+    positions[i]._index = i;\n+  }\n+  auto compare_pair = [](const void* v1, const void* v2) {\n+    const field_pos* p1 = reinterpret_cast<const field_pos*>(v1);\n+    const field_pos* p2 = reinterpret_cast<const field_pos*>(v2);\n+    return compare_name_and_sig(p1->_name, p1->_signature, p2->_name, p2->_signature);\n+  };\n+  qsort(positions, java_fields, sizeof(field_pos), compare_pair);\n+\n+  PackedTableBuilder builder(fis->length() - 1, java_fields - 1);\n+  Array<u1>* table = MetadataFactory::new_array<u1>(loader_data, java_fields * builder.element_bytes(), CHECK_NULL);\n+  FieldInfoSupplier supplier(positions, java_fields);\n+  builder.fill(table->data(), static_cast<size_t>(table->length()), supplier);\n+  return table;\n+}\n+\n@@ -123,2 +209,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n-  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -126,2 +210,4 @@\n-  *java_fields_count = r.next_uint();\n-  *injected_fields_count = r.next_uint();\n+  r.read_field_counts(java_fields_count, injected_fields_count);\n+  int length = *java_fields_count + *injected_fields_count;\n+\n+  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -134,1 +220,0 @@\n-  assert(array->length() == *java_fields_count + *injected_fields_count, \"Must be\");\n@@ -139,1 +224,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n@@ -141,2 +225,3 @@\n-  int java_field_count = r.next_uint();\n-  int injected_fields_count = r.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  r.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -149,0 +234,114 @@\n+\n+class FieldInfoComparator: public PackedTableLookup::Comparator {\n+  const FieldInfoReader* _reader;\n+  ConstantPool* _cp;\n+  const Symbol* _name;\n+  const Symbol* _signature;\n+\n+public:\n+  FieldInfoComparator(const FieldInfoReader* reader, ConstantPool* cp, const Symbol* name, const Symbol* signature):\n+    _reader(reader), _cp(cp), _name(name), _signature(signature) {}\n+\n+  int compare_to(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    r2.read_name_and_signature(&name_index, &sig_index);\n+    Symbol* mid_name = _cp->symbol_at(name_index);\n+    Symbol* mid_sig = _cp->symbol_at(sig_index);\n+\n+    return FieldInfoStream::compare_name_and_sig(_name, _signature, mid_name, mid_sig);\n+  }\n+\n+#ifdef ASSERT\n+  void reset(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, signature_index;\n+    r2.read_name_and_signature(&name_index, &signature_index);\n+    _name = _cp->symbol_at(name_index);\n+    _signature = _cp->symbol_at(signature_index);\n+  }\n+#endif \/\/ ASSERT\n+};\n+\n+#ifdef ASSERT\n+void FieldInfoStream::validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n+  if (search_table == nullptr) {\n+    return;\n+  }\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields > 0, \"must be\");\n+\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n+  assert(lookup.element_bytes() * java_fields == static_cast<unsigned int>(search_table->length()), \"size does not match\");\n+\n+  FieldInfoComparator comparator(&reader, cp, nullptr, nullptr);\n+  \/\/ Check 1: assert that elements have the correct order based on the comparison function\n+  lookup.validate_order(comparator);\n+\n+  \/\/ Check 2: Iterate through the original stream (not just search_table) and try if lookup works as expected\n+  reader.set_position_and_next_index(0, 0);\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  while (reader.has_next()) {\n+    int field_start = reader.position();\n+    FieldInfo fi;\n+    reader.read_field_info(fi);\n+    if (fi.field_flags().is_injected()) {\n+      \/\/ checking only java fields that precede injected ones\n+      break;\n+    }\n+\n+    FieldInfoReader r2(fis);\n+    int index = r2.search_table_lookup(search_table, fi.name(cp), fi.signature(cp), cp, java_fields);\n+    assert(index == static_cast<int>(fi.index()), \"wrong index: %d != %u\", index, fi.index());\n+    assert(index == r2.next_index(), \"index should match\");\n+    assert(field_start == r2.position(), \"must find the same position\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+void FieldInfoStream::print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n+  if (search_table == nullptr) {\n+    return;\n+  }\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields > 0, \"must be\");\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n+  auto printer = [&] (size_t offset, uint32_t position, uint32_t index) {\n+    reader.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    reader.read_name_and_signature(&name_index, &sig_index);\n+    Symbol* name = cp->symbol_at(name_index);\n+    Symbol* sig = cp->symbol_at(sig_index);\n+    st->print(\"   [%zu] #%d,#%d = \", offset, name_index, sig_index);\n+    name->print_symbol_on(st);\n+    st->print(\":\");\n+    sig->print_symbol_on(st);\n+    st->print(\" @ %p,%p\", name, sig);\n+    st->cr();\n+  };\n+\n+  lookup.iterate(printer);\n+}\n+\n+int FieldInfoReader::search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields) {\n+  assert(java_fields >= 0, \"must be\");\n+  if (java_fields == 0) {\n+    return -1;\n+  }\n+  FieldInfoComparator comp(this, cp, name, signature);\n+  PackedTableLookup lookup(_r.limit() - 1, java_fields - 1, search_table);\n+  uint32_t position;\n+  static_assert(sizeof(uint32_t) == sizeof(_next_index), \"field size assert\");\n+  if (lookup.search(comp, &position, reinterpret_cast<uint32_t*>(&_next_index))) {\n+    _r.set_position(static_cast<int>(position));\n+    return _next_index;\n+  } else {\n+    return -1;\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":214,"deletions":15,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -253,1 +253,0 @@\n-\n@@ -256,5 +255,0 @@\n-  friend class FieldInfoStream;\n-  friend class ClassFileParser;\n-  friend class FieldStreamBase;\n-  friend class FieldInfo;\n-\n@@ -264,1 +258,1 @@\n-  public:\n+public:\n@@ -267,2 +261,2 @@\n-  private:\n-  uint32_t next_uint() { return _r.next_uint(); }\n+private:\n+  inline uint32_t next_uint() { return _r.next_uint(); }\n@@ -272,3 +266,5 @@\n-  int has_next() { return _r.has_next(); }\n-  int position() { return _r.position(); }\n-  int next_index() { return _next_index; }\n+  void read_field_counts(int* java_fields, int* injected_fields);\n+  int has_next() const { return _r.position() < _r.limit(); }\n+  int position() const { return _r.position(); }\n+  int next_index() const { return _next_index; }\n+  void read_name_and_signature(u2* name_index, u2* signature_index);\n@@ -276,0 +272,3 @@\n+\n+  int search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields);\n+\n@@ -302,0 +301,5 @@\n+  friend class FieldInfoReader;\n+  friend class FieldInfoComparator;\n+\n+ private:\n+  static int compare_name_and_sig(const Symbol* n1, const Symbol* s1, const Symbol* n2, const Symbol* s2);\n@@ -309,1 +313,2 @@\n-                                                          ClassLoaderData* loader_data, TRAPS);\n+                                           ClassLoaderData* loader_data, TRAPS);\n+  static Array<u1>* create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS);\n@@ -312,0 +317,4 @@\n+\n+  DEBUG_ONLY(static void validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);)\n+\n+  static void print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -60,2 +60,4 @@\n-  fir.skip(1);\n-  return fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return injected_fields_count;\n@@ -66,1 +68,4 @@\n-  return fir.next_uint() + fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count + injected_fields_count;\n@@ -69,1 +74,7 @@\n-inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) { return FieldInfoReader(fis).next_uint(); }\n+inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count;\n+}\n@@ -106,1 +117,1 @@\n-  : _r(fi->data(), 0),\n+  : _r(fi->data(), fi->length()),\n@@ -109,0 +120,10 @@\n+inline void FieldInfoReader::read_field_counts(int* java_fields, int* injected_fields) {\n+  *java_fields = next_uint();\n+  *injected_fields = next_uint();\n+}\n+\n+inline void FieldInfoReader::read_name_and_signature(u2* name_index, u2* signature_index) {\n+  *name_index = checked_cast<u2>(next_uint());\n+  *signature_index = checked_cast<u2>(next_uint());\n+}\n+\n@@ -111,2 +132,1 @@\n-  fi._name_index = checked_cast<u2>(next_uint());\n-  fi._signature_index = checked_cast<u2>(next_uint());\n+  read_name_and_signature(&fi._name_index, &fi._signature_index);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -62,1 +62,1 @@\n-  private:\n+ private:\n@@ -64,3 +64,8 @@\n-    int java_fields_count = _reader.next_uint();\n-    int injected_fields_count = _reader.next_uint();\n-    assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    int java_fields_count;\n+    int injected_fields_count;\n+    _reader.read_field_counts(&java_fields_count, &injected_fields_count);\n+    if (_limit < _index) {\n+      _limit = java_fields_count + injected_fields_count;\n+    } else {\n+      assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    }\n@@ -71,0 +76,1 @@\n+\n@@ -154,0 +160,2 @@\n+  Array<u1>* _search_table;\n+\n@@ -155,1 +163,2 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()),\n+    _search_table(k->fieldinfo_search_table()) {}\n@@ -165,1 +174,0 @@\n-    return -1;\n@@ -180,0 +188,4 @@\n+\n+  \/\/ Performs either a linear search or binary search through the stream\n+  \/\/ looking for a matching name\/signature combo\n+  bool lookup(const Symbol* name, const Symbol* signature);\n@@ -192,1 +204,0 @@\n-  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,7 +36,3 @@\n-         _constants(constantPoolHandle(Thread::current(), constants)), _index(start) {\n-  _index = start;\n-  if (limit < start) {\n-    _limit = FieldInfoStream::num_total_fields(_fieldinfo_stream);\n-  } else {\n-    _limit = limit;\n-  }\n+         _constants(constantPoolHandle(Thread::current(), constants)),\n+         _index(start),\n+         _limit(limit) {\n@@ -46,1 +42,1 @@\n-FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n+FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n@@ -51,1 +47,1 @@\n-        _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n+        _limit(-1) {\n@@ -60,1 +56,1 @@\n-         _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n+         _limit(-1) {\n@@ -65,0 +61,19 @@\n+inline bool JavaFieldStream::lookup(const Symbol* name, const Symbol* signature) {\n+  if (_search_table != nullptr) {\n+    int index = _reader.search_table_lookup(_search_table, name, signature, _constants(), _limit);\n+    if (index >= 0) {\n+      assert(index < _limit, \"must be\");\n+      _index = index;\n+      _reader.read_field_info(_fi_buf);\n+      return true;\n+    }\n+  } else {\n+    for (; !done(); next()) {\n+      if (this->name() == name && this->signature() == signature) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -749,0 +749,5 @@\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+    MetadataFactory::free_array<u1>(loader_data, fieldinfo_search_table());\n+  }\n+  set_fieldinfo_search_table(nullptr);\n+\n@@ -2072,7 +2077,6 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n-    Symbol* f_name = fs.name();\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n-      return true;\n-    }\n+  JavaFieldStream fs(this);\n+  if (fs.lookup(name, sig)) {\n+    assert(fs.name() == name, \"name must match\");\n+    assert(fs.signature() == sig, \"signature must match\");\n+    fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n+    return true;\n@@ -2908,0 +2912,1 @@\n+  it->push(&_fieldinfo_search_table);\n@@ -3010,0 +3015,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -3126,0 +3133,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -4119,0 +4128,5 @@\n+\n+  if (fieldinfo_search_table() != nullptr) {\n+    st->print_cr(BULLET\"---- field info search table:\");\n+    FieldInfoStream::print_search_table(st, _constants, _fieldinfo_stream, _fieldinfo_search_table);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+  Array<u1>*          _fieldinfo_search_table;\n@@ -488,0 +489,3 @@\n+  Array<u1>* fieldinfo_search_table() const { return _fieldinfo_search_table; }\n+  void set_fieldinfo_search_table(Array<u1>* table) { _fieldinfo_search_table = table; }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,2 +223,2 @@\n-       last_ctd = ctd;\n-       mtd->notice_toplevel_compilation(level);\n+      last_ctd = ctd;\n+      mtd->notice_toplevel_compilation(level);\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,5 +40,2 @@\n-void Block_Array::grow( uint i ) {\n-  _nesting.check(_arena); \/\/ Check if a potential reallocation in the arena is safe\n-  if (i < Max()) {\n-    return; \/\/ No need to grow\n-  }\n+void Block_Array::grow(uint i) {\n+  assert(i >= Max(), \"Should have been checked before, use maybe_grow?\");\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,7 @@\n-  void grow( uint i );          \/\/ Grow array node to fit\n+  void maybe_grow(uint i) {\n+    _nesting.check(_arena);     \/\/ Check if a potential reallocation in the arena is safe\n+    if (i >= Max()) {\n+      grow(i);\n+    }\n+  }\n+  void grow(uint i);            \/\/ Grow array node to fit\n@@ -71,1 +77,1 @@\n-  void map( uint i, Block *n ) { grow(i); _blocks[i] = n; }\n+  void map( uint i, Block *n ) { maybe_grow(i); _blocks[i] = n; }\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"opto\/c2_globals_pd.hpp\"\n@@ -31,0 +30,1 @@\n+#include CPU_HEADER(c2_globals)\n@@ -681,4 +681,6 @@\n-          \"Verify Iterative Global Value Numbering\"                         \\\n-          \"=XY, with Y: verify Def-Use modifications during IGVN\"           \\\n-          \"          X: verify that type(n) == n->Value() after IGVN\"       \\\n-          \"X and Y in 0=off; 1=on\")                                         \\\n+          \"Verify Iterative Global Value Numbering =DCBA, with:\"            \\\n+          \"  D: verify Node::Identity did not miss opportunities\"           \\\n+          \"  C: verify Node::Ideal did not miss opportunities\"              \\\n+          \"  B: verify that type(n) == n->Value() after IGVN\"               \\\n+          \"  A: verify Def-Use modifications during IGVN\"                   \\\n+          \"Each can be 0=off or 1=on\")                                      \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_OPTO_C2_GLOBALS_PD_HPP\n-#define SHARE_OPTO_C2_GLOBALS_PD_HPP\n-\n-#include \"runtime\/globals_shared.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#include CPU_HEADER(c2_globals)\n-#include OS_HEADER(c2_globals)\n-\n-#endif \/\/ SHARE_OPTO_C2_GLOBALS_PD_HPP\n","filename":"src\/hotspot\/share\/opto\/c2_globals_pd.hpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -555,1 +555,5 @@\n-  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  const TypeInteger* this_type = this->type()->isa_integer(bt);\n+  if (this_type == nullptr) {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5047,1 +5047,3 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n@@ -5075,1 +5077,1 @@\n-    log()->head(\"late_inline method='%d'  inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n+    log()->head(\"late_inline method='%d' inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -957,2 +957,2 @@\n-  inline Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n-                                       int idx, bool can_grow = false);\n+  Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n+                                int idx, bool can_grow = false);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4405,1 +4405,3 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1049,2 +1049,1 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->empty()) {\n+        if (failtype->filter(type2) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    if (mask->Opcode() == Op_LShiftI && phase->type(mask->in(1))->is_int()->is_con()) {\n+    if (mask->Opcode() == Op_LShiftI && phase->type(mask->in(1))->isa_int() && phase->type(mask->in(1))->is_int()->is_con()) {\n@@ -156,1 +156,1 @@\n-    if (mask->Opcode() == Op_LShiftL && phase->type(mask->in(1))->is_long()->is_con()) {\n+    if (mask->Opcode() == Op_LShiftL && phase->type(mask->in(1))->isa_long() && phase->type(mask->in(1))->is_long()->is_con()) {\n@@ -196,1 +196,1 @@\n-    if (mask->Opcode() == Op_LShiftI && phase->type(mask->in(1))->is_int()->is_con()) {\n+    if (mask->Opcode() == Op_LShiftI && phase->type(mask->in(1))->isa_int() && phase->type(mask->in(1))->is_int()->is_con()) {\n@@ -213,1 +213,1 @@\n-    if (mask->Opcode() == Op_LShiftL && phase->type(mask->in(1))->is_long()->is_con()) {\n+    if (mask->Opcode() == Op_LShiftL && phase->type(mask->in(1))->isa_long() && phase->type(mask->in(1))->is_long()->is_con()) {\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7258,0 +7258,4 @@\n+  record_for_igvn(exit_block);\n+  record_for_igvn(memory_phi);\n+  record_for_igvn(result_phi);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,7 +68,2 @@\n-      ++_inode_top;\n-      if ((_inode_top + 1) >= _inode_max) grow();\n-      _inode_top->node = parent;\n-      _inode_top->indx = (uint)indx;\n-      ++_inode_top;\n-      _inode_top->node = n;\n-      _inode_top->indx = (uint)ns;\n+      Node_Stack::push(parent, (uint)indx);\n+      Node_Stack::push(n, (uint)ns);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2808,1 +2808,0 @@\n-  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n@@ -3048,4 +3047,0 @@\n-  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n-  if (_inode_top < _inode_max) {\n-    return; \/\/ No need to grow\n-  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1650,0 +1650,1 @@\n+    _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n@@ -1901,0 +1902,7 @@\n+\n+  void maybe_grow() {\n+    _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n+    if (_inode_top >= _inode_max) {\n+      grow();\n+    }\n+  }\n@@ -1902,0 +1910,1 @@\n+\n@@ -1924,1 +1933,1 @@\n-    grow();\n+    maybe_grow();\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1075,1 +1075,5 @@\n-  if (is_verify_Value()) {\n+  assert(_worklist.size() == 0, \"igvn worklist must be empty before verify\");\n+\n+  if (is_verify_Value() ||\n+      is_verify_Ideal() ||\n+      is_verify_Identity()) {\n@@ -1083,1 +1087,4 @@\n-      failure |= verify_node_value(n);\n+      if (is_verify_Value())    { failure |= verify_Value_for(n); }\n+      if (is_verify_Ideal())    { failure |= verify_Ideal_for(n, false); }\n+      if (is_verify_Ideal())    { failure |= verify_Ideal_for(n, true); }\n+      if (is_verify_Identity()) { failure |= verify_Identity_for(n); }\n@@ -1100,0 +1107,21 @@\n+\n+  verify_empty_worklist(nullptr);\n+}\n+\n+void PhaseIterGVN::verify_empty_worklist(Node* node) {\n+  \/\/ Verify that the igvn worklist is empty. If no optimization happened, then\n+  \/\/ nothing needs to be on the worklist.\n+  if (_worklist.size() == 0) { return; }\n+\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  for (uint j = 0; j < _worklist.size(); j++) {\n+    Node* n = _worklist.at(j);\n+    ss.print(\"igvn.worklist[%d] \", j);\n+    n->dump(\"\\n\", false, &ss);\n+  }\n+  if (_worklist.size() != 0 && node != nullptr) {\n+    ss.print_cr(\"Previously optimized:\");\n+    node->dump(\"\\n\", false, &ss);\n+  }\n+  tty->print_cr(\"%s\", ss.as_string());\n+  assert(false, \"igvn worklist must still be empty after verify\");\n@@ -1107,1 +1135,1 @@\n-bool PhaseIterGVN::verify_node_value(Node* n) {\n+bool PhaseIterGVN::verify_Value_for(Node* n) {\n@@ -1152,9 +1180,867 @@\n-  tty->cr();\n-  tty->print_cr(\"Missed Value optimization:\");\n-  n->dump_bfs(3, nullptr, \"\");\n-  tty->print_cr(\"Current type:\");\n-  told->dump_on(tty);\n-  tty->cr();\n-  tty->print_cr(\"Optimized type:\");\n-  tnew->dump_on(tty);\n-  tty->cr();\n+\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Value optimization:\");\n+  n->dump_bfs(3, nullptr, \"\", &ss);\n+  ss.print_cr(\"Current type:\");\n+  told->dump_on(&ss);\n+  ss.cr();\n+  ss.print_cr(\"Optimized type:\");\n+  tnew->dump_on(&ss);\n+  ss.cr();\n+  tty->print_cr(\"%s\", ss.as_string());\n+  return true;\n+}\n+\n+\/\/ Check that all Ideal optimizations that could be done were done.\n+\/\/ Returns true if it found missed optimization opportunities and\n+\/\/         false otherwise (no missed optimization, or skipped verification).\n+bool PhaseIterGVN::verify_Ideal_for(Node* n, bool can_reshape) {\n+  \/\/ First, we check a list of exceptions, where we skip verification,\n+  \/\/ because there are known cases where Ideal can optimize after IGVN.\n+  \/\/ Some may be expected and cannot be fixed, and others should be fixed.\n+  switch (n->Opcode()) {\n+    \/\/ RangeCheckNode::Ideal looks up the chain for about 999 nodes\n+    \/\/ (see \"Range-Check scan limit\"). So, it is possible that something\n+    \/\/ is optimized in that input subgraph, and the RangeCheck was not\n+    \/\/ added to the worklist because it would be too expensive to walk\n+    \/\/ down the graph for 1000 nodes and put all on the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    case Op_RangeCheck:\n+      return false;\n+\n+    \/\/ IfNode::Ideal does:\n+    \/\/   Node* prev_dom = search_identical(dist, igvn);\n+    \/\/ which means we seach up the CFG, traversing at most up to a distance.\n+    \/\/ If anything happens rather far away from the If, we may not put the If\n+    \/\/ back on the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_If:\n+      return false;\n+\n+    \/\/ IfNode::simple_subsuming\n+    \/\/ Looks for dominating test that subsumes the current test.\n+    \/\/ Notification could be difficult because of larger distance.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   runtime\/exceptionMsgs\/ArrayIndexOutOfBoundsException\/ArrayIndexOutOfBoundsExceptionTest.java#id1\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CountedLoopEnd:\n+      return false;\n+\n+    \/\/ LongCountedLoopEndNode::Ideal\n+    \/\/ Probably same issue as above.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/predicates\/assertion\/TestAssertionPredicates.java#NoLoopPredicationXbatch\n+    \/\/   -XX:StressLongCountedLoop=2000000 -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LongCountedLoopEnd:\n+      return false;\n+\n+    \/\/ RegionNode::Ideal does \"Skip around the useless IF diamond\".\n+    \/\/   245  IfTrue  === 244\n+    \/\/   258  If  === 245 257\n+    \/\/   259  IfTrue  === 258  [[ 263 ]]\n+    \/\/   260  IfFalse  === 258  [[ 263 ]]\n+    \/\/   263  Region  === 263 260 259  [[ 263 268 ]]\n+    \/\/ to\n+    \/\/   245  IfTrue  === 244\n+    \/\/   263  Region  === 263 245 _  [[ 263 268 ]]\n+    \/\/\n+    \/\/ \"Useless\" means that there is no code in either branch of the If.\n+    \/\/ I found a case where this was not done yet during IGVN.\n+    \/\/ Why does the Region not get added to IGVN worklist when the If diamond becomes useless?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_Region:\n+      return false;\n+\n+    \/\/ In AddNode::Ideal, we call \"commute\", which swaps the inputs so\n+    \/\/ that smaller idx are first. Tracking it back, it led me to\n+    \/\/ PhaseIdealLoop::remix_address_expressions which swapped the edges.\n+    \/\/\n+    \/\/ Example:\n+    \/\/   Before PhaseIdealLoop::remix_address_expressions\n+    \/\/     154  AddI  === _ 12 144\n+    \/\/   After PhaseIdealLoop::remix_address_expressions\n+    \/\/     154  AddI  === _ 144 12\n+    \/\/   After AddNode::Ideal\n+    \/\/     154  AddI  === _ 12 144\n+    \/\/\n+    \/\/ I suspect that the node should be added to the IGVN worklist after\n+    \/\/ PhaseIdealLoop::remix_address_expressions\n+    \/\/\n+    \/\/ This is the only case I looked at, there may be others. Found like this:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    \/\/\n+    \/\/ The following hit the same logic in PhaseIdealLoop::remix_address_expressions.\n+    \/\/\n+    \/\/ Note: currently all of these fail also for other reasons, for example\n+    \/\/ because of \"commute\" doing the reordering with the phi below. Once\n+    \/\/ that is resolved, we can come back to this issue here.\n+    \/\/\n+    \/\/ case Op_AddD:\n+    \/\/ case Op_AddI:\n+    \/\/ case Op_AddL:\n+    \/\/ case Op_AddF:\n+    \/\/ case Op_MulI:\n+    \/\/ case Op_MulL:\n+    \/\/ case Op_MulF:\n+    \/\/ case Op_MulD:\n+    \/\/   if (n->in(1)->_idx > n->in(2)->_idx) {\n+    \/\/     \/\/ Expect \"commute\" to revert this case.\n+    \/\/     return false;\n+    \/\/   }\n+    \/\/   break; \/\/ keep verifying\n+\n+    \/\/ AddFNode::Ideal calls \"commute\", which can reorder the inputs for this:\n+    \/\/   Check for tight loop increments: Loop-phi of Add of loop-phi\n+    \/\/ It wants to take the phi into in(1):\n+    \/\/    471  Phi  === 435 38 390\n+    \/\/    390  AddF  === _ 471 391\n+    \/\/\n+    \/\/ Other Associative operators are also affected equally.\n+    \/\/\n+    \/\/ Investigate why this does not happen earlier during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddD:\n+    \/\/case Op_AddI: \/\/ Also affected for other reasons, see case further down.\n+    \/\/case Op_AddL: \/\/ Also affected for other reasons, see case further down.\n+    case Op_AddF:\n+    case Op_MulI:\n+    case Op_MulL:\n+    case Op_MulF:\n+    case Op_MulD:\n+    case Op_MinF:\n+    case Op_MinD:\n+    case Op_MaxF:\n+    case Op_MaxD:\n+    \/\/ XorINode::Ideal\n+    \/\/ Found with:\n+    \/\/   compiler\/intrinsics\/chacha\/TestChaCha20.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_XorI:\n+    case Op_XorL:\n+    \/\/ It seems we may have similar issues with the HF cases.\n+    \/\/ Found with aarch64:\n+    \/\/   compiler\/vectorization\/TestFloat16VectorOperations.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddHF:\n+    case Op_MulHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      return false;\n+\n+    \/\/ In MulNode::Ideal the edges can be swapped to help value numbering:\n+    \/\/\n+    \/\/    \/\/ We are OK if right is a constant, or right is a load and\n+    \/\/    \/\/ left is a non-constant.\n+    \/\/    if( !(t2->singleton() ||\n+    \/\/          (in(2)->is_Load() && !(t1->singleton() || in(1)->is_Load())) ) ) {\n+    \/\/      if( t1->singleton() ||       \/\/ Left input is a constant?\n+    \/\/          \/\/ Otherwise, sort inputs (commutativity) to help value numbering.\n+    \/\/          (in(1)->_idx > in(2)->_idx) ) {\n+    \/\/        swap_edges(1, 2);\n+    \/\/\n+    \/\/ Why was this not done earlier during IGVN?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/    test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithG1.java\n+    \/\/    -XX:VerifyIterativeGVN=1110\n+    case Op_AndI:\n+    \/\/ Same for AndL.\n+    \/\/ Found with:\n+    \/\/   compiler\/intrinsics\/bigInteger\/MontgomeryMultiplyTest.java\n+    \/\/    -XX:VerifyIterativeGVN=1110\n+    case Op_AndL:\n+      return false;\n+\n+    \/\/ SubLNode::Ideal does transform like:\n+    \/\/   Convert \"c1 - (y+c0)\" into \"(c1-c0) - y\"\n+    \/\/\n+    \/\/ In IGVN before verification:\n+    \/\/   8423  ConvI2L  === _ 3519  [[ 8424 ]]  #long:-2\n+    \/\/   8422  ConvI2L  === _ 8399  [[ 8424 ]]  #long:3..256:www\n+    \/\/   8424  AddL  === _ 8422 8423  [[ 8383 ]]  !orig=[8382]\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8016 8424  [[ 8156 ]]  !orig=[8154]\n+    \/\/\n+    \/\/ And then in verification:\n+    \/\/   8338  ConL  === 0  [[ 8339 8424 ]]  #long:-2     <----- Was constant folded.\n+    \/\/   8422  ConvI2L  === _ 8399  [[ 8424 ]]  #long:3..256:www\n+    \/\/   8424  AddL  === _ 8422 8338  [[ 8383 ]]  !orig=[8382]\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8016 8424  [[ 8156 ]]  !orig=[8154]\n+    \/\/\n+    \/\/ So the form changed from:\n+    \/\/   c1 - (y + [8423  ConvI2L])\n+    \/\/ to\n+    \/\/   c1 - (y + -2)\n+    \/\/ but the SubL was not added to the IGVN worklist. Investigate why.\n+    \/\/ There could be other issues too.\n+    \/\/\n+    \/\/ There seems to be a related AddL IGVN optimization that triggers\n+    \/\/ the same SubL optimization, so investigate that too.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_SubL:\n+      return false;\n+\n+    \/\/ SubINode::Ideal does\n+    \/\/ Convert \"x - (y+c0)\" into \"(x-y) - c0\" AND\n+    \/\/ Convert \"c1 - (y+c0)\" into \"(c1-c0) - y\"\n+    \/\/\n+    \/\/ Investigate why this does not yet happen during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/c2\/IVTest.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_SubI:\n+      return false;\n+\n+    \/\/ AddNode::IdealIL does transform like:\n+    \/\/   Convert x + (con - y) into \"(x - y) + con\"\n+    \/\/\n+    \/\/ In IGVN before verification:\n+    \/\/   8382  ConvI2L\n+    \/\/   8381  ConvI2L  === _ 791  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8381 8382\n+    \/\/   8168  ConvI2L\n+    \/\/   8156  AddL  === _ 8168 8383  [[ 8158 ]]\n+    \/\/\n+    \/\/ And then in verification:\n+    \/\/   8424  AddL\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0  <--- Was constant folded.\n+    \/\/   8383  SubL  === _ 8016 8424\n+    \/\/   8168  ConvI2L\n+    \/\/   8156  AddL  === _ 8168 8383  [[ 8158 ]]\n+    \/\/\n+    \/\/ So the form changed from:\n+    \/\/   x + (ConvI2L(0) - [8382  ConvI2L])\n+    \/\/ to\n+    \/\/   x + (0 - [8424  AddL])\n+    \/\/ but the AddL was not added to the IGVN worklist. Investigate why.\n+    \/\/ There could be other issues, too. For example with \"commute\", see above.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_AddL:\n+      return false;\n+\n+    \/\/ SubTypeCheckNode::Ideal calls SubTypeCheckNode::verify_helper, which does\n+    \/\/   Node* cmp = phase->transform(new CmpPNode(subklass, in(SuperKlass)));\n+    \/\/   record_for_cleanup(cmp, phase);\n+    \/\/ This verification code in the Ideal code creates new nodes, and checks\n+    \/\/ if they fold in unexpected ways. This means some nodes are created and\n+    \/\/ added to the worklist, even if the SubTypeCheck is not optimized. This\n+    \/\/ goes agains the assumption of the verification here, which assumes that\n+    \/\/ if the node is not optimized, then no new nodes should be created, and\n+    \/\/ also no nodes should be added to the worklist.\n+    \/\/ I see two options:\n+    \/\/  1) forbid what verify_helper does, because for each Ideal call it\n+    \/\/     uses memory and that is suboptimal. But it is not clear how that\n+    \/\/     verification can be done otherwise.\n+    \/\/  2) Special case the verification here. Probably the new nodes that\n+    \/\/     were just created are dead, i.e. they are not connected down to\n+    \/\/     root. We could verify that, and remove those nodes from the graph\n+    \/\/     by setting all their inputs to nullptr. And of course we would\n+    \/\/     have to remove those nodes from the worklist.\n+    \/\/ Maybe there are other options too, I did not dig much deeper yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    case Op_SubTypeCheck:\n+      return false;\n+\n+    \/\/ LoopLimitNode::Ideal when stride is constant power-of-2, we can do a lowering\n+    \/\/ to other nodes: Conv, Add, Sub, Mul, And ...\n+    \/\/\n+    \/\/  107  ConI  === 0  [[ ... ]]  #int:2\n+    \/\/   84  LoadRange  === _ 7 83\n+    \/\/   50  ConI  === 0  [[ ... ]]  #int:0\n+    \/\/  549  LoopLimit  === _ 50 84 107\n+    \/\/\n+    \/\/ I stepped backward, to see how the node was generated, and I found that it was\n+    \/\/ created in PhaseIdealLoop::exact_limit and not changed since. It is added to the\n+    \/\/ IGVN worklist. I quickly checked when it goes into LoopLimitNode::Ideal after\n+    \/\/ that, and it seems we want to skip lowering it until after loop-opts, but never\n+    \/\/ add call record_for_post_loop_opts_igvn. This would be an easy fix, but there\n+    \/\/ could be other issues too.\n+    \/\/\n+    \/\/ Fond with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_LoopLimit:\n+      return false;\n+\n+    \/\/ PhiNode::Ideal calls split_flow_path, which tries to do this:\n+    \/\/ \"This optimization tries to find two or more inputs of phi with the same constant\n+    \/\/ value. It then splits them into a separate Phi, and according Region.\"\n+    \/\/\n+    \/\/ Example:\n+    \/\/   130  DecodeN  === _ 129\n+    \/\/    50  ConP  === 0  [[ 18 91 99 18 ]]  #null\n+    \/\/    18  Phi  === 14 50 130 50  [[ 133 ]]  #java\/lang\/Object *  Oop:java\/lang\/Object *\n+    \/\/\n+    \/\/  turns into:\n+    \/\/\n+    \/\/    50  ConP  === 0  [[ 99 91 18 ]]  #null\n+    \/\/   130  DecodeN  === _ 129  [[ 18 ]]\n+    \/\/    18  Phi  === 14 130 50  [[ 133 ]]  #java\/lang\/Object *  Oop:java\/lang\/Object *\n+    \/\/\n+    \/\/ We would have to investigate why this optimization does not happen during IGVN.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_Phi:\n+      return false;\n+\n+    \/\/ MemBarNode::Ideal does \"Eliminate volatile MemBars for scalar replaced objects\".\n+    \/\/ For examle \"The allocated object does not escape\".\n+    \/\/\n+    \/\/ It seems the difference to earlier calls to MemBarNode::Ideal, is that there\n+    \/\/ alloc->as_Allocate()->does_not_escape_thread() returned false, but in verification\n+    \/\/ it returned true. Why does the MemBarStoreStore not get added to the IGVN\n+    \/\/ worklist when this change happens?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_MemBarStoreStore:\n+      return false;\n+\n+    \/\/ ConvI2LNode::Ideal converts\n+    \/\/   648  AddI  === _ 583 645  [[ 661 ]]\n+    \/\/   661  ConvI2L  === _ 648  [[ 664 ]]  #long:0..maxint-1:www\n+    \/\/ into\n+    \/\/   772  ConvI2L  === _ 645  [[ 773 ]]  #long:-120..maxint-61:www\n+    \/\/   771  ConvI2L  === _ 583  [[ 773 ]]  #long:60..120:www\n+    \/\/   773  AddL  === _ 771 772  [[ ]]\n+    \/\/\n+    \/\/ We have to investigate why this does not happen during IGVN in this case.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_ConvI2L:\n+      return false;\n+\n+    \/\/ AddNode::IdealIL can do this transform (and similar other ones):\n+    \/\/   Convert \"a*b+a*c into a*(b+c)\n+    \/\/ The example had AddI(MulI(a, b), MulI(a, c)). Why did this not happen\n+    \/\/ during IGVN? There was a mutation for one of the MulI, and only\n+    \/\/ after that the pattern was as needed for the optimization. The MulI\n+    \/\/ was added to the IGVN worklist, but not the AddI. This probably\n+    \/\/ can be fixed by adding the correct pattern in add_users_of_use_to_worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddI:\n+      return false;\n+\n+    \/\/ ArrayCopyNode::Ideal\n+    \/\/    calls ArrayCopyNode::prepare_array_copy\n+    \/\/    calls Compile::conv_I2X_index        -> is called with sizetype = intcon(0), I think that\n+    \/\/                                            is not expected, and we create a range int:0..-1\n+    \/\/    calls Compile::constrained_convI2L   -> creates ConvI2L(intcon(1), int:0..-1)\n+    \/\/                                            note: the type is already empty!\n+    \/\/    calls PhaseIterGVN::transform\n+    \/\/    calls PhaseIterGVN::transform_old\n+    \/\/    calls PhaseIterGVN::subsume_node     -> subsume ConvI2L with TOP\n+    \/\/    calls Unique_Node_List::push         -> pushes TOP to worklist\n+    \/\/\n+    \/\/ Once we get back to ArrayCopyNode::prepare_array_copy, we get back TOP, and\n+    \/\/ return false. This means we eventually return nullptr from ArrayCopyNode::Ideal.\n+    \/\/\n+    \/\/ Question: is it ok to push anything to the worklist during ::Ideal, if we will\n+    \/\/           return nullptr, indicating nothing happened?\n+    \/\/           Is it smart to do transform in Compile::constrained_convI2L, and then\n+    \/\/           check for TOP in calls ArrayCopyNode::prepare_array_copy?\n+    \/\/           Should we just allow TOP to land on the worklist, as an exception?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/arraycopy\/TestArrayCopyAsLoadsStores.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_ArrayCopy:\n+      return false;\n+\n+    \/\/ CastLLNode::Ideal\n+    \/\/    calls ConstraintCastNode::optimize_integer_cast -> pushes CastLL through SubL\n+    \/\/\n+    \/\/ Could be a notification issue, where updates inputs of CastLL do not notify\n+    \/\/ down through SubL to CastLL.\n+    \/\/\n+    \/\/ Found With:\n+    \/\/   compiler\/c2\/TestMergeStoresMemorySegment.java#byte-array\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CastLL:\n+      return false;\n+\n+    \/\/ Similar case happens to CastII\n+    \/\/\n+    \/\/ Found With:\n+    \/\/   compiler\/c2\/TestScalarReplacementMaxLiveNodes.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CastII:\n+      return false;\n+\n+    \/\/ MaxLNode::Ideal\n+    \/\/   calls AddNode::Ideal\n+    \/\/   calls commute -> decides to swap edges\n+    \/\/\n+    \/\/ Another notification issue, because we check inputs of inputs?\n+    \/\/ MaxL -> Phi -> Loop\n+    \/\/ MaxL -> Phi -> MaxL\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestIfMinMax.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_MaxL:\n+    case Op_MinL:\n+      return false;\n+\n+    \/\/ OrINode::Ideal\n+    \/\/   calls AddNode::Ideal\n+    \/\/   calls commute -> left is Load, right not -> commute.\n+    \/\/\n+    \/\/ Not sure why notification does not work here, seems like\n+    \/\/ the depth is only 1, so it should work. Needs investigation.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/codegen\/TestCharVect2.java#id0\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_OrI:\n+    case Op_OrL:\n+      return false;\n+\n+    \/\/ Bool -> constant folded to 1.\n+    \/\/ Issue with notification?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_Bool:\n+      return false;\n+\n+    \/\/ LShiftLNode::Ideal\n+    \/\/ Looks at pattern: \"(x + x) << c0\", converts it to \"x << (c0 + 1)\"\n+    \/\/ Probably a notification issue.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/conversions\/TestMoveConvI2LOrCastIIThruAddIs.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LShiftL:\n+      return false;\n+\n+    \/\/ LShiftINode::Ideal\n+    \/\/ pattern: ((x + con1) << con2) -> x << con2 + con1 << con2\n+    \/\/ Could be issue with notification of inputs of inputs\n+    \/\/\n+    \/\/ Side-note: should cases like these not be shared between\n+    \/\/            LShiftI and LShiftL?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/escapeAnalysis\/Test6689060.java\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110 -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LShiftI:\n+      return false;\n+\n+    \/\/ AddPNode::Ideal seems to do set_req without removing lock first.\n+    \/\/ Found with various vector tests tier1-tier3.\n+    case Op_AddP:\n+      return false;\n+\n+    \/\/ StrIndexOfNode::Ideal\n+    \/\/ Found in tier1-3.\n+    case Op_StrIndexOf:\n+    case Op_StrIndexOfChar:\n+      return false;\n+\n+    \/\/ StrEqualsNode::Identity\n+    \/\/\n+    \/\/ Found (linux x64 only?) with:\n+    \/\/   serviceability\/sa\/ClhsdbThreadContext.java\n+    \/\/   -XX:+UnlockExperimentalVMOptions -XX:LockingMode=1 -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_StrEquals:\n+      return false;\n+\n+    \/\/ AryEqNode::Ideal\n+    \/\/ Not investigated. Reshapes itself and adds lots of nodes to the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java\n+    \/\/   -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -XX:+StressUnstableIfTraps -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_AryEq:\n+      return false;\n+\n+    \/\/ MergeMemNode::Ideal\n+    \/\/ Found in tier1-3. Did not investigate further yet.\n+    case Op_MergeMem:\n+      return false;\n+\n+    \/\/ URShiftINode::Ideal\n+    \/\/ Found in tier1-3. Did not investigate further yet.\n+    case Op_URShiftI:\n+      return false;\n+\n+    \/\/ CMoveINode::Ideal\n+    \/\/ Found in tier1-3. Did not investigate further yet.\n+    case Op_CMoveI:\n+      return false;\n+\n+    \/\/ CmpPNode::Ideal calls isa_const_java_mirror\n+    \/\/ and generates new constant nodes, even if no progress is made.\n+    \/\/ We can probably rewrite this so that only types are generated.\n+    \/\/ It seems that object types are not hashed, we could investigate\n+    \/\/ if that is an option as well.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1110 -Xcomp --version\n+    case Op_CmpP:\n+      return false;\n+\n+    \/\/ MinINode::Ideal\n+    \/\/ Did not investigate, but there are some patterns that might\n+    \/\/ need more notification.\n+    case Op_MinI:\n+    case Op_MaxI: \/\/ preemptively removed it as well.\n+      return false;\n+  }\n+\n+  if (n->is_Load()) {\n+    \/\/ LoadNode::Ideal uses tries to find an earlier memory state, and\n+    \/\/ checks can_see_stored_value for it.\n+    \/\/\n+    \/\/ Investigate why this was not already done during IGVN.\n+    \/\/ A similar issue happens with Identity.\n+    \/\/\n+    \/\/ There seem to be other cases where loads go up some steps, like\n+    \/\/ LoadNode::Ideal going up 10x steps to find dominating load.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccess.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_Store()) {\n+    \/\/ StoreNode::Ideal can do this:\n+    \/\/  \/\/ Capture an unaliased, unconditional, simple store into an initializer.\n+    \/\/  \/\/ Or, if it is independent of the allocation, hoist it above the allocation.\n+    \/\/ That replaces the Store with a MergeMem.\n+    \/\/\n+    \/\/ We have to investigate why this does not happen during IGVN in this case.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    return false;\n+  }\n+\n+  if (n->is_Vector()) {\n+    \/\/ VectorNode::Ideal swaps edges, but only for ops\n+    \/\/ that are deemed commutable. But swap_edges\n+    \/\/ requires the hash to be invariant when the edges\n+    \/\/ are swapped, which is not implemented for these\n+    \/\/ vector nodes. This seems not to create any trouble\n+    \/\/ usually, but we can also get graphs where in the\n+    \/\/ end the nodes are not all commuted, so there is\n+    \/\/ definitively an issue here.\n+    \/\/\n+    \/\/ Probably we have two options: kill the hash, or\n+    \/\/ properly make the hash commutation friendly.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/vectorapi\/TestMaskedMacroLogicVector.java\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110 -XX:+UseParallelGC -XX:+UseNUMA\n+    return false;\n+  }\n+\n+  if (n->is_Region()) {\n+    \/\/ LoopNode::Ideal calls RegionNode::Ideal.\n+    \/\/ CountedLoopNode::Ideal calls RegionNode::Ideal too.\n+    \/\/ But I got an issue because RegionNode::optimize_trichotomy\n+    \/\/ then modifies another node, and pushes nodes to the worklist\n+    \/\/ Not sure if this is ok, modifying another node like that.\n+    \/\/ Maybe it is, then we need to look into what to do with\n+    \/\/ the nodes that are now on the worklist, maybe just clear\n+    \/\/ them out again. But maybe modifying other nodes like that\n+    \/\/ is also bad design. In the end, we return nullptr for\n+    \/\/ the current CountedLoop. But the extra nodes on the worklist\n+    \/\/ trip the asserts later on.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/eliminateAutobox\/TestShortBoxing.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_CallJava()) {\n+    \/\/ CallStaticJavaNode::Ideal\n+    \/\/ Led to a crash:\n+    \/\/   assert((is_CallStaticJava() && cg->is_mh_late_inline()) || (is_CallDynamicJava() && cg->is_virtual_late_inline())) failed: mismatch\n+    \/\/\n+    \/\/ Did not investigate yet, could be a bug.\n+    \/\/ Or maybe it does not expect to be called during verification.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/jdk\/jdk\/incubator\/vector\/VectorRuns.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+\n+    \/\/ CallDynamicJavaNode::Ideal, and I think also for CallStaticJavaNode::Ideal\n+    \/\/  and possibly their subclasses.\n+    \/\/ During late inlining it can call CallJavaNode::register_for_late_inline\n+    \/\/ That means we do more rounds of late inlining, but might fail.\n+    \/\/ Then we do IGVN again, and register the node again for late inlining.\n+    \/\/ This creates an endless cycle. Everytime we try late inlining, we\n+    \/\/ are also creating more nodes, especially SafePoint and MergeMem.\n+    \/\/ These nodes are immediately rejected when the inlining fails in the\n+    \/\/ do_late_inline_check, but they still grow the memory, until we hit\n+    \/\/ the MemLimit and crash.\n+    \/\/ The assumption here seems that CallDynamicJavaNode::Ideal does not get\n+    \/\/ called repeatedly, and eventually we terminate. I fear this is not\n+    \/\/ a great assumption to make. We should investigate more.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-U\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  \/\/ The number of nodes shoud not increase.\n+  uint old_unique = C->unique();\n+\n+  Node* i = n->Ideal(this, can_reshape);\n+  \/\/ If there was no new Idealization, we are probably happy.\n+  if (i == nullptr) {\n+    if (old_unique < C->unique()) {\n+      stringStream ss; \/\/ Print as a block without tty lock.\n+      ss.cr();\n+      ss.print_cr(\"Ideal optimization did not make progress but created new unused nodes.\");\n+      ss.print_cr(\"  old_unique = %d, unique = %d\", old_unique, C->unique());\n+      n->dump_bfs(1, nullptr, \"\", &ss);\n+      tty->print_cr(\"%s\", ss.as_string());\n+      return true;\n+    }\n+\n+    verify_empty_worklist(n);\n+\n+    \/\/ Everything is good.\n+    return false;\n+  }\n+\n+  \/\/ We just saw a new Idealization which was not done during IGVN.\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Ideal optimization (can_reshape=%s):\", can_reshape ? \"true\": \"false\");\n+  if (i == n) {\n+    ss.print_cr(\"The node was reshaped by Ideal.\");\n+  } else {\n+    ss.print_cr(\"The node was replaced by Ideal.\");\n+    ss.print_cr(\"Old node:\");\n+    n->dump_bfs(1, nullptr, \"\", &ss);\n+  }\n+  ss.print_cr(\"The result after Ideal:\");\n+  i->dump_bfs(1, nullptr, \"\", &ss);\n+  tty->print_cr(\"%s\", ss.as_string());\n+  return true;\n+}\n+\n+\/\/ Check that all Identity optimizations that could be done were done.\n+\/\/ Returns true if it found missed optimization opportunities and\n+\/\/         false otherwise (no missed optimization, or skipped verification).\n+bool PhaseIterGVN::verify_Identity_for(Node* n) {\n+  \/\/ First, we check a list of exceptions, where we skip verification,\n+  \/\/ because there are known cases where Ideal can optimize after IGVN.\n+  \/\/ Some may be expected and cannot be fixed, and others should be fixed.\n+  switch (n->Opcode()) {\n+    \/\/ SafePointNode::Identity can remove SafePoints, but wants to wait until\n+    \/\/ after loopopts:\n+    \/\/   \/\/ Transforming long counted loops requires a safepoint node. Do not\n+    \/\/   \/\/ eliminate a safepoint until loop opts are over.\n+    \/\/   if (in(0)->is_Proj() && !phase->C->major_progress()) {\n+    \/\/\n+    \/\/ I think the check for major_progress does delay it until after loopopts\n+    \/\/ but it does not ensure that the node is on the IGVN worklist after\n+    \/\/ loopopts. I think we should try to instead check for\n+    \/\/ phase->C->post_loop_opts_phase() and call record_for_post_loop_opts_igvn.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_SafePoint:\n+      return false;\n+\n+    \/\/ MergeMemNode::Identity replaces the MergeMem with its base_memory if it\n+    \/\/ does not record any other memory splits.\n+    \/\/\n+    \/\/ I did not deeply investigate, but it looks like MergeMemNode::Identity\n+    \/\/ never got called during IGVN for this node, investigate why.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_MergeMem:\n+      return false;\n+\n+    \/\/ ConstraintCastNode::Identity finds casts that are the same, except that\n+    \/\/ the control is \"higher up\", i.e. dominates. The call goes via\n+    \/\/ ConstraintCastNode::dominating_cast to PhaseGVN::is_dominator_helper,\n+    \/\/ which traverses up to 100 idom steps. If anything gets optimized somewhere\n+    \/\/ away from the cast, but within 100 idom steps, the cast may not be\n+    \/\/ put on the IGVN worklist any more.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_CastPP:\n+    case Op_CastII:\n+    case Op_CastLL:\n+      return false;\n+\n+    \/\/ Same issue for CheckCastPP, uses ConstraintCastNode::Identity and\n+    \/\/ checks dominator, which may be changed, but too far up for notification\n+    \/\/ to work.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestSkeletonPredicates.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CheckCastPP:\n+      return false;\n+\n+    \/\/ In SubNode::Identity, we do:\n+    \/\/   Convert \"(X+Y) - Y\" into X and \"(X+Y) - X\" into Y\n+    \/\/ In the example, the AddI had an input replaced, the AddI is\n+    \/\/ added to the IGVN worklist, but the SubI is one link further\n+    \/\/ down and is not added. I checked add_users_of_use_to_worklist\n+    \/\/ where I would expect the SubI would be added, and I cannot\n+    \/\/ find the pattern, only this one:\n+    \/\/   If changed AddI\/SubI inputs, check CmpU for range check optimization.\n+    \/\/\n+    \/\/ Fix this \"notification\" issue and check if there are any other\n+    \/\/ issues.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_SubI:\n+    case Op_SubL:\n+      return false;\n+\n+    \/\/ PhiNode::Identity checks for patterns like:\n+    \/\/   r = (x != con) ? x : con;\n+    \/\/ that can be constant folded to \"x\".\n+    \/\/\n+    \/\/ Call goes through PhiNode::is_cmove_id and CMoveNode::is_cmove_id.\n+    \/\/ I suspect there was some earlier change to one of the inputs, but\n+    \/\/ not all relevant outputs were put on the IGVN worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithG1.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_Phi:\n+      return false;\n+\n+    \/\/ ConvI2LNode::Identity does\n+    \/\/ convert I2L(L2I(x)) => x\n+    \/\/\n+    \/\/ Investigate why this did not already happen during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-A\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_ConvI2L:\n+      return false;\n+\n+    \/\/ MaxNode::find_identity_operation\n+    \/\/  Finds patterns like Max(A, Max(A, B)) -> Max(A, B)\n+    \/\/  This can be a 2-hop search, so maybe notification is not\n+    \/\/  good enough.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/codegen\/TestBooleanVect.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_MaxL:\n+    case Op_MinL:\n+    case Op_MaxI:\n+    case Op_MinI:\n+    case Op_MaxF:\n+    case Op_MinF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MaxD:\n+    case Op_MinD:\n+      return false;\n+\n+\n+    \/\/ AddINode::Identity\n+    \/\/ Converts (x-y)+y to x\n+    \/\/ Could be issue with notification\n+    \/\/\n+    \/\/ Turns out AddL does the same.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/  compiler\/c2\/Test6792161.java\n+    \/\/  -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_AddI:\n+    case Op_AddL:\n+      return false;\n+\n+    \/\/ AbsINode::Identity\n+    \/\/ Not investigated yet.\n+    case Op_AbsI:\n+      return false;\n+  }\n+\n+  if (n->is_Load()) {\n+    \/\/ LoadNode::Identity tries to look for an earlier store value via\n+    \/\/ can_see_stored_value. I found an example where this led to\n+    \/\/ an Allocation, where we could assume the value was still zero.\n+    \/\/ So the LoadN can be replaced with a zerocon.\n+    \/\/\n+    \/\/ Investigate why this was not already done during IGVN.\n+    \/\/ A similar issue happens with Ideal.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    return false;\n+  }\n+\n+  if (n->is_Store()) {\n+    \/\/ StoreNode::Identity\n+    \/\/ Not investigated, but found missing optimization for StoreI.\n+    \/\/ Looks like a StoreI is replaced with an InitializeNode.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   applications\/ctw\/modules\/java_base_2.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -Djava.awt.headless=true -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_Vector()) {\n+    \/\/ Found with tier1-3. Not investigated yet.\n+    \/\/ The observed issue was with AndVNode::Identity\n+    return false;\n+  }\n+\n+  Node* i = n->Identity(this);\n+  \/\/ If we cannot find any other Identity, we are happy.\n+  if (i == n) {\n+    verify_empty_worklist(n);\n+    return false;\n+  }\n+\n+  \/\/ The verification just found a new Identity that was not found during IGVN.\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Identity optimization:\");\n+  ss.print_cr(\"Old node:\");\n+  n->dump_bfs(1, nullptr, \"\", &ss);\n+  ss.print_cr(\"New node:\");\n+  i->dump_bfs(1, nullptr, \"\", &ss);\n+  tty->print_cr(\"%s\", ss.as_string());\n@@ -1943,1 +2829,1 @@\n-\/\/ We have a list of exceptions, see comments in verify_node_value.\n+\/\/ We have a list of exceptions, see comments in verify_Value_for.\n@@ -1948,1 +2834,1 @@\n-    failure |= verify_node_value(n);\n+    failure |= verify_Value_for(n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":900,"deletions":14,"binary":false,"changes":914,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,1 +497,4 @@\n-  bool verify_node_value(Node* n);\n+  bool verify_Value_for(Node* n);\n+  bool verify_Ideal_for(Node* n, bool can_reshape);\n+  bool verify_Identity_for(Node* n);\n+  void verify_empty_worklist(Node* n);\n@@ -598,0 +601,8 @@\n+  static bool is_verify_Ideal() {\n+    \/\/ '-XX:VerifyIterativeGVN=100'\n+    return ((VerifyIterativeGVN % 1000) \/ 100) == 1;\n+  }\n+  static bool is_verify_Identity() {\n+    \/\/ '-XX:VerifyIterativeGVN=1000'\n+    return ((VerifyIterativeGVN % 10000) \/ 1000) == 1;\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  flags(ITER_GVN_AFTER_VECTOR,          \"Iter GVN after vector box elimination\") \\\n+  flags(ITER_GVN_AFTER_VECTOR,          \"Iter GVN after Vector Box Elimination\") \\\n@@ -52,4 +52,7 @@\n-  flags(BEFORE_BEAUTIFY_LOOPS,          \"Before beautify loops\") \\\n-  flags(AFTER_BEAUTIFY_LOOPS,           \"After beautify loops\") \\\n-  flags(BEFORE_LOOP_UNROLLING,          \"Before Loop Unrolling\") \\\n-  flags(AFTER_LOOP_UNROLLING,           \"After Loop Unrolling\") \\\n+  flags(PHASEIDEAL_BEFORE_EA,           \"PhaseIdealLoop before EA\") \\\n+  flags(AFTER_EA,                       \"After Escape Analysis\") \\\n+  flags(ITER_GVN_AFTER_EA,              \"Iter GVN after EA\") \\\n+  flags(BEFORE_BEAUTIFY_LOOPS,          \"Before Beautify Loops\") \\\n+  flags(AFTER_BEAUTIFY_LOOPS,           \"After Beautify Loops\") \\\n+  flags(BEFORE_CLOOPS,                  \"Before CountedLoop\") \\\n+  flags(AFTER_CLOOPS,                   \"After CountedLoop\") \\\n@@ -72,0 +75,1 @@\n+  flags(ITER_GVN_AFTER_ELIMINATION,     \"Iter GVN after Eliminating Allocations and Locks\") \\\n@@ -74,11 +78,2 @@\n-  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,                     \"AutoVectorization 1, Before Apply\") \\\n-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, After Apply Memop Reordering\") \\\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, After Adjusting Pre-Loop Limit\") \\\n-  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, After Adding Speculative Runtime Checks\") \\\n-  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, After Apply\") \\\n-  flags(BEFORE_CLOOPS,                  \"Before CountedLoop\") \\\n-  flags(AFTER_CLOOPS,                   \"After CountedLoop\") \\\n-  flags(PHASEIDEAL_BEFORE_EA,           \"PhaseIdealLoop before EA\") \\\n-  flags(AFTER_EA,                       \"After Escape Analysis\") \\\n-  flags(ITER_GVN_AFTER_EA,              \"Iter GVN after EA\") \\\n-  flags(ITER_GVN_AFTER_ELIMINATION,     \"Iter GVN after eliminating allocations and locks\") \\\n+  flags(BEFORE_LOOP_UNROLLING,          \"Before Loop Unrolling\") \\\n+  flags(AFTER_LOOP_UNROLLING,           \"After Loop Unrolling\") \\\n@@ -88,0 +83,5 @@\n+  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,                     \"AutoVectorization 1, before Apply\") \\\n+  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, after Apply Memop Reordering\") \\\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, after Adjusting Pre-loop Limit\") \\\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, after Adding Speculative Runtime Checks\") \\\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, after Apply\") \\\n@@ -97,15 +97,15 @@\n-  flags(BARRIER_EXPANSION,              \"Barrier expand\") \\\n-  flags(OPTIMIZE_FINISHED,              \"Optimize finished\") \\\n-  flags(BEFORE_MATCHING,                \"Before matching\") \\\n-  flags(MATCHING,                       \"After matching\") \\\n-  flags(GLOBAL_CODE_MOTION,             \"Global code motion\") \\\n-  flags(INITIAL_LIVENESS,               \"Initial liveness\") \\\n-  flags(LIVE_RANGE_STRETCHING,          \"Live range stretching\") \\\n-  flags(AGGRESSIVE_COALESCING,          \"Aggressive coalescing\") \\\n-  flags(INITIAL_SPILLING,               \"Initial spilling\") \\\n-  flags(CONSERVATIVE_COALESCING,        \"Conservative coalescing\") \\\n-  flags(ITERATIVE_SPILLING,             \"Iterative spilling\") \\\n-  flags(AFTER_ITERATIVE_SPILLING,       \"After iterative spilling\") \\\n-  flags(POST_ALLOCATION_COPY_REMOVAL,   \"Post-allocation copy removal\") \\\n-  flags(MERGE_MULTI_DEFS,               \"Merge multiple definitions\") \\\n-  flags(FIX_UP_SPILLS,                  \"Fix up spills\") \\\n+  flags(BARRIER_EXPANSION,              \"Barrier Expand\") \\\n+  flags(OPTIMIZE_FINISHED,              \"Optimize Finished\") \\\n+  flags(BEFORE_MATCHING,                \"Before Matching\") \\\n+  flags(MATCHING,                       \"After Matching\") \\\n+  flags(GLOBAL_CODE_MOTION,             \"Global Code Motion\") \\\n+  flags(INITIAL_LIVENESS,               \"Initial Liveness\") \\\n+  flags(LIVE_RANGE_STRETCHING,          \"Live Range Stretching\") \\\n+  flags(AGGRESSIVE_COALESCING,          \"Aggressive Coalescing\") \\\n+  flags(INITIAL_SPILLING,               \"Initial Spilling\") \\\n+  flags(CONSERVATIVE_COALESCING,        \"Conservative Coalescing\") \\\n+  flags(ITERATIVE_SPILLING,             \"Iterative Spilling\") \\\n+  flags(AFTER_ITERATIVE_SPILLING,       \"After Iterative Spilling\") \\\n+  flags(POST_ALLOCATION_COPY_REMOVAL,   \"Post-allocation Copy Removal\") \\\n+  flags(MERGE_MULTI_DEFS,               \"Merge Multiple Definitions\") \\\n+  flags(FIX_UP_SPILLS,                  \"Fix up Spills\") \\\n@@ -115,2 +115,2 @@\n-  flags(POSTALLOC_EXPAND,               \"Post-Allocation Expand\") \\\n-  flags(MACH_ANALYSIS,                  \"After mach analysis\") \\\n+  flags(POSTALLOC_EXPAND,               \"Post-allocation Expand\") \\\n+  flags(MACH_ANALYSIS,                  \"After Mach Analysis\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/printinlining.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1081 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/rangeinference.hpp\"\n+#include \"opto\/type.hpp\"\n+#include \"utilities\/intn_t.hpp\"\n+#include \"utilities\/tuple.hpp\"\n+\n+\/\/ If the cardinality of a TypeInt is below this threshold, use min widen, see\n+\/\/ TypeIntPrototype<S, U>::normalize_widen\n+constexpr juint SMALL_TYPEINT_THRESHOLD = 3;\n+\n+\/\/ This represents the result of an iterative calculation\n+template <class T>\n+class AdjustResult {\n+public:\n+  bool _progress; \/\/ whether there is progress compared to the last iteration\n+  bool _present;  \/\/ whether the result is empty, typically due to the calculation arriving at contradiction\n+  T _result;\n+\n+  bool empty() const {\n+    return !_present;\n+  }\n+\n+  static AdjustResult<T> make_empty() {\n+    return {true, false, {}};\n+  }\n+};\n+\n+\/\/ This is the result of canonicalizing a simple interval (see TypeInt at\n+\/\/ type.hpp)\n+template <class U>\n+class SimpleCanonicalResult {\n+  static_assert(U(-1) > U(0), \"bit info should be unsigned\");\n+public:\n+  const bool _present;       \/\/ whether this is an empty set\n+  const RangeInt<U> _bounds; \/\/ The bounds must be in the same half of the integer domain (see TypeInt)\n+  const KnownBits<U> _bits;\n+\n+  SimpleCanonicalResult(bool present, const RangeInt<U>& bounds, const KnownBits<U>& bits)\n+    : _present(present), _bounds(bounds), _bits(bits) {\n+    if (!present) {\n+      return;\n+    }\n+    \/\/ Do some verification\n+    assert(bits.is_satisfied_by(bounds._lo) && bits.is_satisfied_by(bounds._hi), \"must be canonical\");\n+    \/\/ 0b1000...\n+    constexpr U mid_point = (std::numeric_limits<U>::max() >> 1) + U(1);\n+    assert((bounds._lo < mid_point) == (bounds._hi < mid_point), \"must be a simple interval, see Lemma 4\");\n+  }\n+\n+  bool empty() const {\n+    return !_present;\n+  }\n+\n+  static SimpleCanonicalResult<U> make_empty() {\n+    return SimpleCanonicalResult(false, {}, {});\n+  }\n+};\n+\n+\/\/ Find the minimum value that is not less than lo and satisfies bits. If there\n+\/\/ does not exist one such number, the calculation will return a value < lo.\n+\/\/\n+\/\/ Formally, this function tries to find the minimum value that is not less\n+\/\/ than lo and satisfies bits, assuming such value exists. The cases where such\n+\/\/ value does not exists automatically follows.\n+\/\/\n+\/\/ If there exists a value not less than lo and satisfies bits, then this\n+\/\/ function will always find one such value. The converse is also true, that is\n+\/\/ if this function finds a value not less than lo and satisfies bits, then it\n+\/\/ must trivially be the case that there exists one such value. As a result,\n+\/\/ the negation of those statements are also equivalent, there does not exists\n+\/\/ a value not less than lo and satisfies bits if and only if this function\n+\/\/ does not return one such value.\n+\/\/\n+\/\/ In practice, since the algorithm always ensures that the returned value\n+\/\/ satisfies bits, we only need to check if it is not less than lo.\n+\/\/\n+\/\/ Here, we view a number in binary as a bit string. As a result,  the first\n+\/\/ bit refers to the highest bit (the MSB), the last bit refers to the lowest\n+\/\/ bit (the LSB), a bit comes before (being higher than) another if it is more\n+\/\/ significant, and a bit comes after (being lower than) another if it is less\n+\/\/ significant. For a value n with w bits, we denote n[0] the first (highest)\n+\/\/ bit of n, n[1] the second bit, ..., n[w - 1] the last (lowest) bit of n.\n+template <class U>\n+static U adjust_lo(U lo, const KnownBits<U>& bits) {\n+  \/\/ Violation of lo with respects to bits\n+  \/\/ E.g: lo    = 1100\n+  \/\/      zeros = 0100\n+  \/\/      ones  = 1001\n+  \/\/ zero_violation = 0100, i.e the second bit should be zero, but it is 1 in\n+  \/\/ lo. Similarly, one_violation = 0001, i.e the last bit should be one, but\n+  \/\/ it is 0 in lo. These make lo not satisfy the bit constraints, which\n+  \/\/ results in us having to find the smallest value that satisfies bits.\n+  U zero_violation = lo & bits._zeros;\n+  U one_violation = ~lo & bits._ones;\n+  if (zero_violation == one_violation) {\n+    \/\/ This means lo does not violate bits, it is the result\n+    assert(zero_violation == U(0), \"\");\n+    return lo;\n+  }\n+\n+  \/*\n+  1. Intuition:\n+  Call r the lowest value not smaller than lo that satisfies bits, consider the\n+  first bit in r that is different from the corresponding bit in lo:\n+    - Since r is larger than lo the bit must be 0 in lo and 1 in r\n+    - Since r must satisify bits the bit must be 0 in zeros\n+    - Since r should be the smallest value, this bit should be the lowest one\n+      possible\n+\n+  E.g:      1 2 3 4 5 6\n+       lo = 1 0 0 1 1 0\n+        x = 1 0 1 0 1 0\n+        y = 0 1 1 1 1 1\n+  x would be larger than lo since the first different bit is the 3rd one,\n+  while y is smaller than lo because the first different bit is the 1st bit.\n+  Next, consider:\n+       x1 = 1 0 1 0 1 0\n+       x2 = 1 0 0 1 1 1\n+  Both x1 and x2 are larger than lo, but x1 > x2 since its first different\n+  bit from lo is the 3rd one, while with x2 it is the 7th one. As a result,\n+  if both x1 and x2 satisfy bits, x2 would be closer to our true result.\n+\n+  2. Formality:\n+\n+  Call r the smallest value not smaller than lo that satisfies bits. Since lo\n+  does not satisfy bits, lo < r (2.1)\n+\n+  Call i the largest bit index such that:\n+\n+  - lo[x] satisfies bits for 0 <= x < i (2.2)\n+  - zeros[i] = 0                        (2.3)\n+  - lo[i]    = 0                        (2.4)\n+\n+  Consider v:\n+\n+  - v[x] = lo[x], for 0 <= x < i        (2.5)\n+  - v[i] = 1                            (2.6)\n+  - v[x] = ones[x], for x > i           (2.7)\n+\n+  We will prove that v == r.\n+\n+  a. Firstly, we prove that r <= v:\n+\n+    a.1. lo < v, since:\n+      lo[x] == v[x], for 0 <= x < i (according to 2.5)\n+      lo[i] <  v[i] (according to 2.4 and 2.6, lo[i] == 0 < v[i] == 1)\n+      bits at x > i have lower significance, and are thus irrelevant\n+\n+    a.2. v satisfies bits, because:\n+      v[x] satisfies bits for 0 <= x < i (according to 2.2 and 2.5)\n+      v[i] satisfies bits:\n+        According to 2.3 and 2.6, zeros[i] == 0 and v[i] == 1, v[i] does not violate\n+        bits, which means v[i] satisfies bits\n+      v[x] satisfies bits for x > i:\n+        Assume bits is not contradictory, we cannot have:\n+          ones[x]  == 1, v[x] == 0 (according to 2.7, v[x] == ones[x])\n+          zeros[x] == 1, v[x] == 1 (according to 2.7, ones[x] == v[x] == 1, which means\n+                                    bits is contradictory)\n+\n+    From a.1 and a.2, v > lo and v satisfies bits. Which means r <= v since r is the\n+    smallest such value.\n+\n+  b. Secondly, from r <= v, we prove that r == v. Suppose the contradiction r < v:\n+\n+    Since r < v, there must be a bit position j that:\n+\n+    r[j] == 0               (2.b.1)\n+    v[j] == 1               (2.b.2)\n+    r[x] == v[x], for x < j (2.b.3)\n+\n+    b.1. If j < i\n+      This means that:\n+      r[j]  == 0                (according to 2.b.1)\n+      lo[j] == 1                (according to 2.b.2 and 2.5, lo[j] == v[j] == 1 because j < i)\n+      r[x]  == lo[x], for x < j (according to 2.b.3 and 2.5, lo[x] == v[x] == r[x] with x < j < i)\n+      bits at x > j have lower significance, and are thus irrelevant\n+\n+      Which leads to r < lo, which contradicts that lo < r (acording to 2.1)\n+\n+    b.2. If j == i\n+      Since r > lo (according to 2.1), there must exist a bit index k such that:\n+\n+      r[k]  == 1                (2.b.2.1)\n+      lo[k] == 0                (2.b.2.2)\n+      r[x]  == lo[x], for x < k (2.b.2.3)\n+\n+      Then, since we have:\n+      r[x]  == v[x],  for x < i (according to 2.b.3)\n+      v[x]  == lo[x], for x < i (according to 2.5)\n+      r[i]  == 0                (according to 2.b.1 because i == j)\n+      lo[i] == 0                (according to 2.4)\n+\n+      this leads to: r[x] == lo[x], for x <= i\n+      while r[k] == 1 != lo[k] == 0, we can conclude that k > i\n+\n+      However, since:\n+      lo[x] satisfies bits for 0 <= x < k:\n+        According to 2.b.2.3, lo[x] == r[x] and r satisfies bits\n+      zeros[k] == 0 (according to 2.b.2.1, r[k] == 1 and r satisfies bits)\n+      lo[k]    == 0 (according to 2.b.2.2)\n+\n+      This contradicts the assumption that i is the largest bit index satisfying such conditions.\n+\n+    b.3. If j > i\n+      ones[j] == v[j] (according to 2.7 since j > i)\n+      v[j]    == 1    (according to 2.b.2)\n+      r[j]    == 0    (according to 2.b.1)\n+\n+      This means that r[j] == 0 and ones[j] == 1, this contradicts the assumption that r\n+      satisfies bits.\n+\n+    All cases lead to contradictions, which mean r < v is incorrect, which means that\n+    r == v, which means the value v having the above form is the lowest value not smaller\n+    than lo that satisfies bits.\n+\n+  3. Conclusion\n+    Our objective now is to find the largest value i that satisfies:\n+    - lo[x] satisfies bits for 0 <= x < i (3.1)\n+    - zeros[i] = 0                        (3.2)\n+    - lo[i] = 0                           (3.3)\n+  *\/\n+\n+  \/\/ The algorithm depends on whether the first violation violates zeros or\n+  \/\/ ones. If it violates zeros, we have the bit being 1 in zero_violation and\n+  \/\/ 0 in one_violation. Since all higher bits are 0 in zero_violation and\n+  \/\/ one_violation, we have zero_violation > one_violation. Similarly, if the\n+  \/\/ first violation violates ones, we have zero_violation < one_violation.\n+  if (zero_violation < one_violation) {\n+    \/\/ This means that the first bit that does not satisfy the bit requirement\n+    \/\/ is a 0 that should be a 1. Obviously, since the bit at that position in\n+    \/\/ ones is 1, the same bit in zeros is 0.\n+    \/\/\n+    \/\/ From section 3 above, we know i is the largest bit index such that:\n+    \/\/ - lo[x] satisfies bits for 0 <= x < i (3.1)\n+    \/\/ - zeros[i] = 0                        (3.2)\n+    \/\/ - lo[i] = 0                           (3.3)\n+    \/\/\n+    \/\/ For the given i, we know that lo satisfies all bits before i, hence (3.1)\n+    \/\/ holds. Further, lo[i] = 0 (3.3), and we have a one violation at i, hence\n+    \/\/ zero[i] = 0 (3.2). Any smaller i would not be the largest possible such\n+    \/\/ index. Any larger i would violate (3.1), since lo[i] does not satisfy bits.\n+    \/\/ As a result, the first violation is the bit i we are looking for.\n+    \/\/\n+    \/\/ E.g:      1 2 3 4 5 6 7 8\n+    \/\/      lo = 1 1 0 0 0 1 1 0\n+    \/\/   zeros = 0 0 1 0 0 1 0 0\n+    \/\/    ones = 0 1 0 1 0 0 1 0\n+    \/\/   1-vio = 0 0 0 1 0 0 0 0\n+    \/\/   0-vio = 0 0 0 0 0 1 0 0\n+    \/\/ Since the result must have the 4th bit set, it must be at least:\n+    \/\/           1 1 0 1 0 0 0 0\n+    \/\/ This value must satisfy zeros, because all bits before the 4th bit have\n+    \/\/ already satisfied zeros, and all bits after the 4th bit are all 0 now.\n+    \/\/ Just OR this value with ones to obtain the final result.\n+\n+    \/\/ first_violation is the position of the violation counting from the\n+    \/\/ highest bit down (0-based), since i == 4, first_violation == 3\n+    juint first_violation = count_leading_zeros(one_violation);\n+    \/\/           1 0 0 0 0 0 0 0\n+    constexpr U highest_bit = (std::numeric_limits<U>::max() >> 1) + U(1);\n+    \/\/ This is the bit at which we want to change the bit 0 in lo to a 1, and\n+    \/\/ all bits after to zero. This is similar to an operation that aligns lo\n+    \/\/ up to the next multiple of this modulo.\n+    \/\/           0 0 0 1 0 0 0 0\n+    U alignment = highest_bit >> first_violation;\n+    \/\/ This is the first value which have the violated bit being 1, which means\n+    \/\/ that the result should not be smaller than this.\n+    \/\/ This is a standard operation to align a value up to the next multiple of\n+    \/\/ a certain power of 2. Since alignment is a power of 2, -alignment is a\n+    \/\/ value having all the bits being 1 upto the location of the bit in\n+    \/\/ alignment (in the example, -alignment = 11110000). As a result,\n+    \/\/ lo & -alignment set all bits after the bit in alignment to 0, which is\n+    \/\/ equivalent to rounding lo down to a multiple of alignment. To round lo\n+    \/\/ up to the next multiple of alignment, we add alignment to the rounded\n+    \/\/ down value.\n+    \/\/ Note that this computation cannot overflow as the bit in lo that is at\n+    \/\/ the same position as the only bit 1 in alignment must be 0. As a result,\n+    \/\/ this operation just set that bit to 1 and set all the bits after to 0.\n+    \/\/ We now have:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = 0, for x > i          (not yet 2.7)\n+    \/\/           1 1 0 1 0 0 0 0\n+    U new_lo = (lo & -alignment) + alignment;\n+    \/\/ Note that there exists no value x not larger than i such that\n+    \/\/ new_lo[x] == 0 and ones[x] == 1. This is because all bits of lo before i\n+    \/\/ should satisfy bits, and new_lo[i] == 1. As a result, doing\n+    \/\/ new_lo |= bits.ones will give us a value such that:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = ones[x], for x > i    (2.7)\n+    \/\/ This is the result we are looking for.\n+    \/\/           1 1 0 1 0 0 1 0\n+    new_lo |= bits._ones;\n+    \/\/ Note that in this case, new_lo is always a valid answer. That is, it is\n+    \/\/ a value not less than lo and satisfies bits.\n+    assert(lo < new_lo, \"the result must be valid\");\n+    return new_lo;\n+  } else {\n+    assert(zero_violation > one_violation, \"remaining case\");\n+    \/\/ This means that the first bit that does not satisfy the bit requirement\n+    \/\/ is a 1 that should be a 0.\n+    \/\/\n+    \/\/ From section 3 above, we know i is the largest bit index such that:\n+    \/\/ - lo[x] satisfies bits for 0 <= x < i (3.1)\n+    \/\/ - zeros[i] = 0                        (3.2)\n+    \/\/ - lo[i] = 0                           (3.3)\n+    \/\/\n+    \/\/ We know that lo satisfies all bits before first_violation, hence (3.1)\n+    \/\/ holds. However, first_violation is not the value i we are looking for\n+    \/\/ because lo[first_violation] == 1. We can also see that any larger value\n+    \/\/ of i would violate (3.1) since lo[first_violation] does not satisfy\n+    \/\/ bits. As a result, we should find the last index x upto first_violation\n+    \/\/ such that lo[x] == zeros[x] == 0. That value of x would be the value of\n+    \/\/ i we are looking for.\n+    \/\/\n+    \/\/ E.g:      1 2 3 4 5 6 7 8\n+    \/\/      lo = 1 0 0 0 1 1 1 0\n+    \/\/   zeros = 0 0 0 1 0 1 0 0\n+    \/\/    ones = 1 0 0 0 0 0 1 1\n+    \/\/   1-vio = 0 0 0 0 0 0 0 1\n+    \/\/   0-vio = 0 0 0 0 0 1 0 0\n+    \/\/ The first violation is the 6th bit, which should be 0. We want to flip\n+    \/\/ it to 0. However, since we must obtain a value larger than lo, we must\n+    \/\/ find an earlier bit that can be flipped from 0 to 1. The 5th cannot be\n+    \/\/ the bit we are looking for, because it is already 1, the 4th bit also\n+    \/\/ cannot be, because it must be 0. As a result, the last bit we can flip,\n+    \/\/ which is the first different bit between the result and lo must be the\n+    \/\/ 3rd bit. As a result, the result must not be smaller than:\n+    \/\/           1 0 1 0 0 0 0 0\n+    \/\/ This one satisfies zeros so we can use the logic in the previous case,\n+    \/\/ just OR with ones to obtain the final result, which is:\n+    \/\/           1 0 1 0 0 0 1 1\n+\n+    juint first_violation = count_leading_zeros(zero_violation);\n+    \/\/ This masks out all bits after the first violation\n+    \/\/           1 1 1 1 1 0 0 0\n+    U find_mask = ~(std::numeric_limits<U>::max() >> first_violation);\n+    \/\/ We want to find the last index x upto first_violation such that\n+    \/\/ lo[x] == zeros[x] == 0.\n+    \/\/ We start with all bits where lo[x] == zeros[x] == 0:\n+    \/\/           0 1 1 0 0 0 0 1\n+    U neither = ~(lo | bits._zeros);\n+    \/\/ Now let us find all the bit indices x upto first_violation such that\n+    \/\/ lo[x] == zeros[x] == 0. The last one of these bits must be at index i.\n+    \/\/           0 1 1 0 0 0 0 0\n+    U neither_upto_first_violation = neither & find_mask;\n+    \/\/ We now want to select the last one of these candidates, which is exactly\n+    \/\/ the last index x upto first_violation such that lo[x] == zeros[x] == 0.\n+    \/\/ This would be the value i we are looking for.\n+    \/\/ Similar to the other case, we want to obtain the value with only the bit\n+    \/\/ i set, this is equivalent to extracting the last set bit of\n+    \/\/ neither_upto_first_violation, do it directly without going through i.\n+    \/\/ The formula x & (-x) will give us the last set bit of an integer x\n+    \/\/ (please see the x86 instruction blsi).\n+    \/\/ In our example, i == 2\n+    \/\/           0 0 1 0 0 0 0 0\n+    U alignment = neither_upto_first_violation & (-neither_upto_first_violation);\n+    \/\/ Set the bit of lo at i and unset all the bits after, this is the\n+    \/\/ smallest value that satisfies bits._zeros. Similar to the above case,\n+    \/\/ this is similar to aligning lo up to the next multiple of alignment.\n+    \/\/ Also similar to the above case, this computation cannot overflow.\n+    \/\/ We now have:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = 0, for x > i          (not yet 2.7)\n+    \/\/           1 0 1 0 0 0 0 0\n+    U new_lo = (lo & -alignment) + alignment;\n+    \/\/ Note that there exists no value x not larger than i such that\n+    \/\/ new_lo[x] == 0 and ones[x] == 1. This is because all bits of lo before i\n+    \/\/ should satisfy bits, and new_lo[i] == 1. As a result, doing\n+    \/\/ new_lo |= bits.ones will give us a value such that:\n+    \/\/ - new_lo[x] = lo[x], for 0 <= x < i (2.5)\n+    \/\/ - new_lo[i] = 1                     (2.6)\n+    \/\/ - new_lo[x] = ones[x], for x > i    (2.7)\n+    \/\/ This is the result we are looking for.\n+    \/\/           1 0 1 0 0 0 1 1\n+    new_lo |= bits._ones;\n+    \/\/ Note that formally, this function assumes that there exists a value not\n+    \/\/ smaller than lo and satisfies bits. This implies the existence of the\n+    \/\/ index i satisfies (3.1-3.3), which means that\n+    \/\/ neither_upto_first_violation != 0. The converse is\n+    \/\/ also true, if neither_upto_first_violation != 0, then an index i\n+    \/\/ satisfies (3.1-3.3) exists, which implies the existence of a value not\n+    \/\/ smaller than lo and satisfies bits. As a result, the negation of those\n+    \/\/ statements are equivalent. neither_upto_first_violation == 0 if and only\n+    \/\/ if there does not exists a value not smaller than lo and satisfies bits.\n+    \/\/ In this case, alignment == 0 and new_lo == bits._ones. We know that, if\n+    \/\/ the assumption of this function holds, we return a value satisfying\n+    \/\/ bits, and if the assumption of this function does not hold, the returned\n+    \/\/ value would be bits._ones, which also satisfies bits. As a result, this\n+    \/\/ function always returns a value satisfying bits, regardless whether if\n+    \/\/ the assumption of this function holds. In conclusion, the caller only\n+    \/\/ needs to check lo <= new_lo to find the cases where there exists no\n+    \/\/ value not smaller than lo and satisfies bits (see the overview of the\n+    \/\/ function).\n+    assert(lo < new_lo || new_lo == bits._ones, \"invalid result must be bits._ones\");\n+    return new_lo;\n+  }\n+}\n+\n+\/\/ Try to tighten the bound constraints from the known bit information. I.e, we\n+\/\/ find the smallest value not smaller than lo, as well as the largest value\n+\/\/ not larger than hi both of which satisfy bits\n+\/\/ E.g: lo = 0010, hi = 1001\n+\/\/ zeros = 0011\n+\/\/ ones  = 0000\n+\/\/ -> 4-aligned\n+\/\/\n+\/\/         0    1    2    3    4    5    6    7    8    9    10\n+\/\/         0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010\n+\/\/ bits:   ok   .    .    .    ok   .    .    .    ok   .    .\n+\/\/ bounds:           lo                                 hi\n+\/\/ adjust:           --------> lo                  hi <---\n+template <class U>\n+static AdjustResult<RangeInt<U>>\n+adjust_unsigned_bounds_from_bits(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  U new_lo = adjust_lo(bounds._lo, bits);\n+  if (new_lo < bounds._lo) {\n+    \/\/ This means we wrapped around, which means no value not less than lo\n+    \/\/ satisfies bits\n+    return AdjustResult<RangeInt<U>>::make_empty();\n+  }\n+\n+  \/\/ We need to find the largest value not larger than hi that satisfies bits\n+  \/\/ One possible method is to do similar to adjust_lo, just with the other\n+  \/\/ direction\n+  \/\/ However, we can observe that if v satisfies {bits._zeros, bits._ones},\n+  \/\/ then ~v would satisfy {bits._ones, bits._zeros}. Combine with the fact\n+  \/\/ that bitwise-not is a strictly decreasing function, if new_hi is the\n+  \/\/ largest value not larger than hi that satisfies {bits._zeros, bits._ones},\n+  \/\/ then ~new_hi is the smallest value not smaller than ~hi that satisfies\n+  \/\/ {bits._ones, bits._zeros}.\n+  \/\/\n+  \/\/ Proof:\n+  \/\/ Calling h the smallest value not smaller than ~hi that satisfies\n+  \/\/ {bits._ones, bits._zeros}.\n+  \/\/\n+  \/\/ 1. Since h satisfies {bits._ones, bits._zeros}, ~h satisfies\n+  \/\/   {bits._zeros, bits._ones}. Assume the contradiction ~h does not satisfy\n+  \/\/   {bits._zeros, bits._ones}, There can be 2 cases:\n+  \/\/   1.1. There is a bit in ~h that is 0 where the corresponding bit in ones\n+  \/\/     is 1. This implies the corresponding bit in h is 1. But this is\n+  \/\/     contradictory since h satisfies {bits._ones, bits._zeros}.\n+  \/\/   1.2. There is a bit in ~h that is 1 where the corresponding bit in zeros\n+  \/\/     is 1. Similarly, this leads to contradiction because h needs to\n+  \/\/     satisfy {bits._ones, bits._zeros}.\n+  \/\/\n+  \/\/ 2. Assume there is a value k that is larger than ~h such that k is not\n+  \/\/ larger than hi, i.e. ~h < k <= hi, and k satisfies {bits._zeros, bits._ones}.\n+  \/\/ As a result, ~k would satisfy {bits._ones, bits._zeros}. And since bitwise-not\n+  \/\/ is a strictly decreasing function, given ~h < k <= hi, we have h > ~k >= ~hi.\n+  \/\/ This contradicts the assumption that h is the smallest value not smaller than\n+  \/\/ ~hi and satisfies {bits._ones, bits._zeros}.\n+  \/\/\n+  \/\/ As a result, ~h is the largest value not larger than hi that satisfies\n+  \/\/ bits (QED).\n+  U h = adjust_lo(~bounds._hi, {bits._ones, bits._zeros});\n+  if (h < ~bounds._hi) {\n+    return AdjustResult<RangeInt<U>>::make_empty();\n+  }\n+\n+  U new_hi = ~h;\n+  bool progress = (new_lo != bounds._lo) || (new_hi != bounds._hi);\n+  bool present = new_lo <= new_hi;\n+  return {progress, present, {new_lo, new_hi}};\n+}\n+\n+\/\/ Try to tighten the known bit constraints from the bound information by\n+\/\/ extracting the common prefix of lo and hi and combining with the current\n+\/\/ bit constraints\n+\/\/ E.g: lo = 010011\n+\/\/      hi = 010100,\n+\/\/ then all values in [lo, hi] would be\n+\/\/           010***\n+template <class U>\n+static AdjustResult<KnownBits<U>>\n+adjust_bits_from_unsigned_bounds(const KnownBits<U>& bits, const RangeInt<U>& bounds) {\n+  \/\/ Find the mask to filter the common prefix, all values between bounds._lo\n+  \/\/ and bounds._hi should share this common prefix in terms of bits\n+  U mismatch = bounds._lo ^ bounds._hi;\n+  \/\/ Find the first mismatch, all bits before it are the same in bounds._lo and\n+  \/\/ bounds._hi\n+  U match_mask = mismatch == U(0) ? std::numeric_limits<U>::max()\n+                                  : ~(std::numeric_limits<U>::max() >> count_leading_zeros(mismatch));\n+  \/\/ match_mask & bounds._lo is the common prefix, extract zeros and ones from\n+  \/\/ it\n+  U common_prefix_zeros = match_mask & ~bounds._lo;\n+  assert(common_prefix_zeros == (match_mask & ~bounds._hi), \"\");\n+  U new_zeros = bits._zeros | common_prefix_zeros;\n+\n+  U common_prefix_ones = match_mask & bounds._lo;\n+  assert(common_prefix_ones == (match_mask & bounds._hi), \"\");\n+  U new_ones = bits._ones | common_prefix_ones;\n+\n+  bool progress = (new_zeros != bits._zeros) || (new_ones != bits._ones);\n+  bool present = ((new_zeros & new_ones) == U(0));\n+  return {progress, present, {new_zeros, new_ones}};\n+}\n+\n+\/\/ Try to tighten both the bounds and the bits at the same time.\n+\/\/ Iteratively tighten one using the other until no progress is made.\n+\/\/ This function converges because at each iteration, some bits that are unknown\n+\/\/ are made known. As there are at most 64 bits, the number of iterations should\n+\/\/ not be larger than 64.\n+\/\/ This function is called simple because it deals with a simple intervals (see\n+\/\/ TypeInt at type.hpp).\n+template <class U>\n+static SimpleCanonicalResult<U>\n+canonicalize_constraints_simple(const RangeInt<U>& bounds, const KnownBits<U>& bits) {\n+  assert((bounds._lo ^ bounds._hi) < (std::numeric_limits<U>::max() >> 1) + U(1), \"bounds must be a simple interval\");\n+\n+  AdjustResult<KnownBits<U>> canonicalized_bits = adjust_bits_from_unsigned_bounds(bits, bounds);\n+  if (canonicalized_bits.empty()) {\n+    return SimpleCanonicalResult<U>::make_empty();\n+  }\n+  AdjustResult<RangeInt<U>> canonicalized_bounds{true, true, bounds};\n+  \/\/ Since bits are derived from bounds in the previous iteration and vice\n+  \/\/ versa, if one does not show progress, the other will also not show\n+  \/\/ progress, so we terminate early\n+  while (true) {\n+    canonicalized_bounds = adjust_unsigned_bounds_from_bits(canonicalized_bounds._result, canonicalized_bits._result);\n+    if (!canonicalized_bounds._progress || canonicalized_bounds.empty()) {\n+      return SimpleCanonicalResult<U>(canonicalized_bounds._present, canonicalized_bounds._result, canonicalized_bits._result);\n+    }\n+    canonicalized_bits = adjust_bits_from_unsigned_bounds(canonicalized_bits._result, canonicalized_bounds._result);\n+    if (!canonicalized_bits._progress || canonicalized_bits.empty()) {\n+      return SimpleCanonicalResult<U>(canonicalized_bits._present, canonicalized_bounds._result, canonicalized_bits._result);\n+    }\n+  }\n+}\n+\n+\/\/ Tighten all constraints of a TypeIntPrototype to its canonical form.\n+\/\/ i.e the result represents the same set as the input, each bound belongs to\n+\/\/ the set and for each bit position that is not constrained, there exists 2\n+\/\/ values with the bit value at that position being set and unset, respectively,\n+\/\/ such that both belong to the set represented by the constraints.\n+template <class S, class U>\n+typename TypeIntPrototype<S, U>::CanonicalizedTypeIntPrototype\n+TypeIntPrototype<S, U>::canonicalize_constraints() const {\n+  RangeInt<S> srange = _srange;\n+  RangeInt<U> urange = _urange;\n+  \/\/ Trivial contradictions\n+  if (srange._lo > srange._hi ||\n+      urange._lo > urange._hi ||\n+      (_bits._zeros & _bits._ones) != U(0)) {\n+    return CanonicalizedTypeIntPrototype::make_empty();\n+  }\n+\n+  \/\/ We try to make [srange._lo, S(urange._hi)] and\n+  \/\/ [S(urange._lo), srange._hi] be both simple intervals (as defined in\n+  \/\/ TypeInt at type.hpp)\n+  if (S(urange._lo) > S(urange._hi)) {\n+    \/\/ This means that S(urange._lo) >= 0 and S(urange._hi) < 0 because here we\n+    \/\/ know that U(urange._lo) <= U(urange._hi)\n+    if (S(urange._hi) < srange._lo) {\n+      \/\/ This means that there should be no element in the interval\n+      \/\/ [min_S, S(urange._hi)], tighten urange._hi to max_S\n+      \/\/ Signed:\n+      \/\/ min_S----uhi---------lo---------0--------ulo==========hi----max_S\n+      \/\/ Unsigned:\n+      \/\/                                 0--------ulo==========hi----max_S min_S-----uhi---------lo---------\n+      urange._hi = U(std::numeric_limits<S>::max());\n+    } else if (S(urange._lo) > srange._hi) {\n+      \/\/ This means that there should be no element in the interval\n+      \/\/ [S(urange._lo), max_S], tighten urange._lo to min_S\n+      \/\/ Signed:\n+      \/\/ min_S----lo=========uhi---------0--------hi----------ulo----max_S\n+      \/\/ Unsigned:\n+      \/\/                                 0--------hi----------ulo----max_S min_S----lo=========uhi---------\n+      urange._lo = U(std::numeric_limits<S>::min());\n+    }\n+  }\n+\n+  \/\/ Now [srange._lo, S(urange._hi)] and [S(urange._lo), srange._hi] are both\n+  \/\/ simple intervals (as defined in TypeInt at type.hpp), we process them\n+  \/\/ separately and combine the results\n+  if (S(urange._lo) <= S(urange._hi)) {\n+    \/\/ The 2 simple intervals should be tightened to the same result\n+    urange._lo = U(MAX2(S(urange._lo), srange._lo));\n+    urange._hi = U(MIN2(S(urange._hi), srange._hi));\n+    if (urange._lo > urange._hi || S(urange._lo) > S(urange._hi)) {\n+      return CanonicalizedTypeIntPrototype::make_empty();\n+    }\n+\n+    auto type = canonicalize_constraints_simple(urange, _bits);\n+    return {type._present, {{S(type._bounds._lo), S(type._bounds._hi)},\n+                            type._bounds, type._bits}};\n+  }\n+\n+  \/\/ The 2 simple intervals can be tightened into 2 separate results\n+  auto neg_type = canonicalize_constraints_simple({U(srange._lo), urange._hi}, _bits);\n+  auto pos_type = canonicalize_constraints_simple({urange._lo, U(srange._hi)}, _bits);\n+\n+  if (neg_type.empty() && pos_type.empty()) {\n+    return CanonicalizedTypeIntPrototype::make_empty();\n+  } else if (neg_type.empty()) {\n+    return {true, {{S(pos_type._bounds._lo), S(pos_type._bounds._hi)},\n+                   pos_type._bounds, pos_type._bits}};\n+  } else if (pos_type.empty()) {\n+    return {true, {{S(neg_type._bounds._lo), S(neg_type._bounds._hi)},\n+                   neg_type._bounds, neg_type._bits}};\n+  } else {\n+    return {true, {{S(neg_type._bounds._lo), S(pos_type._bounds._hi)},\n+                   {pos_type._bounds._lo, neg_type._bounds._hi},\n+                   {neg_type._bits._zeros & pos_type._bits._zeros, neg_type._bits._ones & pos_type._bits._ones}}};\n+  }\n+}\n+\n+template <class S, class U>\n+int TypeIntPrototype<S, U>::normalize_widen(int widen) const {\n+  \/\/ Certain normalizations keep us sane when comparing types.\n+  \/\/ The 'SMALL_TYPEINT_THRESHOLD' covers constants and also CC and its relatives.\n+  if (TypeIntHelper::cardinality_from_bounds(_srange, _urange) <= U(SMALL_TYPEINT_THRESHOLD)) {\n+    return Type::WidenMin;\n+  }\n+  if (_srange._lo == std::numeric_limits<S>::min() && _srange._hi == std::numeric_limits<S>::max() &&\n+      _urange._lo == std::numeric_limits<U>::min() && _urange._hi == std::numeric_limits<U>::max() &&\n+      _bits._zeros == U(0) && _bits._ones == U(0)) {\n+    \/\/ bottom type\n+    return Type::WidenMax;\n+  }\n+  return widen;\n+}\n+\n+#ifdef ASSERT\n+template <class S, class U>\n+bool TypeIntPrototype<S, U>::contains(S v) const {\n+  U u(v);\n+  return v >= _srange._lo && v <= _srange._hi &&\n+         u >= _urange._lo && u <= _urange._hi &&\n+         _bits.is_satisfied_by(u);\n+}\n+\n+\/\/ Verify that this set representation is canonical\n+template <class S, class U>\n+void TypeIntPrototype<S, U>::verify_constraints() const {\n+  \/\/ Assert that the bounds cannot be further tightened\n+  assert(contains(_srange._lo) && contains(_srange._hi) &&\n+         contains(S(_urange._lo)) && contains(S(_urange._hi)), \"\");\n+\n+  \/\/ Assert that the bits cannot be further tightened\n+  if (U(_srange._lo) == _urange._lo) {\n+    assert(!adjust_bits_from_unsigned_bounds(_bits, _urange)._progress, \"\");\n+  } else {\n+    RangeInt<U> neg_range{U(_srange._lo), _urange._hi};\n+    auto neg_bits = adjust_bits_from_unsigned_bounds(_bits, neg_range);\n+    assert(neg_bits._present, \"\");\n+    assert(!adjust_unsigned_bounds_from_bits(neg_range, neg_bits._result)._progress, \"\");\n+\n+    RangeInt<U> pos_range{_urange._lo, U(_srange._hi)};\n+    auto pos_bits = adjust_bits_from_unsigned_bounds(_bits, pos_range);\n+    assert(pos_bits._present, \"\");\n+    assert(!adjust_unsigned_bounds_from_bits(pos_range, pos_bits._result)._progress, \"\");\n+\n+    assert((neg_bits._result._zeros & pos_bits._result._zeros) == _bits._zeros &&\n+           (neg_bits._result._ones & pos_bits._result._ones) == _bits._ones, \"\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+template class TypeIntPrototype<jint, juint>;\n+template class TypeIntPrototype<jlong, julong>;\n+template class TypeIntPrototype<intn_t<1>, uintn_t<1>>;\n+template class TypeIntPrototype<intn_t<2>, uintn_t<2>>;\n+template class TypeIntPrototype<intn_t<3>, uintn_t<3>>;\n+template class TypeIntPrototype<intn_t<4>, uintn_t<4>>;\n+\n+\/\/ Compute the meet of 2 types. When dual is true, the subset relation in CT is\n+\/\/ reversed. This means that the result of 2 CTs would be the intersection of\n+\/\/ them if dual is true, and be the union of them if dual is false. The subset\n+\/\/ relation in the Type hierarchy is still the same, however. E.g. the result\n+\/\/ of 1 CT and Type::BOTTOM would always be Type::BOTTOM, and the result of 1\n+\/\/ CT and Type::TOP would always be the CT instance itself.\n+template <class CT>\n+const Type* TypeIntHelper::int_type_xmeet(const CT* i1, const Type* t2) {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (i1 == t2 || t2 == Type::TOP) {\n+    return i1;\n+  }\n+  const CT* i2 = t2->try_cast<CT>();\n+  if (i2 != nullptr) {\n+    assert(i1->_is_dual == i2->_is_dual, \"must have the same duality\");\n+    using S = std::remove_const_t<decltype(CT::_lo)>;\n+    using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+    if (!i1->_is_dual) {\n+      \/\/ meet (a.k.a union)\n+      return CT::make_or_top(TypeIntPrototype<S, U>{{MIN2(i1->_lo, i2->_lo), MAX2(i1->_hi, i2->_hi)},\n+                                                    {MIN2(i1->_ulo, i2->_ulo), MAX2(i1->_uhi, i2->_uhi)},\n+                                                    {i1->_bits._zeros & i2->_bits._zeros, i1->_bits._ones & i2->_bits._ones}},\n+                             MAX2(i1->_widen, i2->_widen), false);\n+    } else {\n+      \/\/ join (a.k.a intersection)\n+      return CT::make_or_top(TypeIntPrototype<S, U>{{MAX2(i1->_lo, i2->_lo), MIN2(i1->_hi, i2->_hi)},\n+                                                    {MAX2(i1->_ulo, i2->_ulo), MIN2(i1->_uhi, i2->_uhi)},\n+                                                    {i1->_bits._zeros | i2->_bits._zeros, i1->_bits._ones | i2->_bits._ones}},\n+                             MIN2(i1->_widen, i2->_widen), true);\n+    }\n+  }\n+\n+  assert(t2->base() != i1->base(), \"\");\n+  switch (t2->base()) {          \/\/ Switch on original type\n+  case Type::AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case Type::RawPtr:                  \/\/ reuses local variables\n+  case Type::OopPtr:\n+  case Type::InstPtr:\n+  case Type::AryPtr:\n+  case Type::MetadataPtr:\n+  case Type::KlassPtr:\n+  case Type::InstKlassPtr:\n+  case Type::AryKlassPtr:\n+  case Type::NarrowOop:\n+  case Type::NarrowKlass:\n+  case Type::Int:\n+  case Type::Long:\n+  case Type::HalfFloatTop:\n+  case Type::HalfFloatCon:\n+  case Type::HalfFloatBot:\n+  case Type::FloatTop:\n+  case Type::FloatCon:\n+  case Type::FloatBot:\n+  case Type::DoubleTop:\n+  case Type::DoubleCon:\n+  case Type::DoubleBot:\n+  case Type::Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+  default:                      \/\/ All else is a mistake\n+    i1->typerr(t2);\n+    return nullptr;\n+  }\n+}\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeInt* i1, const Type* t2);\n+template const Type* TypeIntHelper::int_type_xmeet(const TypeLong* i1, const Type* t2);\n+\n+\/\/ Called in PhiNode::Value during CCP, monotically widen the value set, do so rigorously\n+\/\/ first, after WidenMax attempts, if the type has still not converged we speed up the\n+\/\/ convergence by abandoning the bounds\n+template <class CT>\n+const Type* TypeIntHelper::int_type_widen(const CT* new_type, const CT* old_type, const CT* limit_type) {\n+  using S = std::remove_const_t<decltype(CT::_lo)>;\n+  using U = std::remove_const_t<decltype(CT::_ulo)>;\n+\n+  if (old_type == nullptr) {\n+    return new_type;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no widening\n+  if (int_type_is_equal(new_type, old_type)) {\n+    return old_type;\n+  }\n+\n+  \/\/ If old guy contains new, then we probably widened too far & dropped to\n+  \/\/ bottom. Return the wider fellow.\n+  if (int_type_is_subset(old_type, new_type)) {\n+    return old_type;\n+  }\n+\n+  \/\/ Neither contains each other, weird?\n+  if (!int_type_is_subset(new_type, old_type)) {\n+    return CT::TYPE_DOMAIN;\n+  }\n+\n+  \/\/ If old guy was a constant, do not bother\n+  if (old_type->singleton()) {\n+    return new_type;\n+  }\n+\n+  \/\/ If new guy contains old, then we widened\n+  \/\/ If new guy is already wider than old, no widening\n+  if (new_type->_widen > old_type->_widen) {\n+    return new_type;\n+  }\n+\n+  if (new_type->_widen < Type::WidenMax) {\n+    \/\/ Returned widened new guy\n+    TypeIntPrototype<S, U> prototype{{new_type->_lo, new_type->_hi}, {new_type->_ulo, new_type->_uhi}, new_type->_bits};\n+    return CT::make_or_top(prototype, new_type->_widen + 1);\n+  }\n+\n+  \/\/ Speed up the convergence by abandoning the bounds, there are only a couple of bits so\n+  \/\/ they converge fast\n+  S min = std::numeric_limits<S>::min();\n+  S max = std::numeric_limits<S>::max();\n+  U umin = std::numeric_limits<U>::min();\n+  U umax = std::numeric_limits<U>::max();\n+  U zeros = new_type->_bits._zeros;\n+  U ones = new_type->_bits._ones;\n+  if (limit_type != nullptr) {\n+    min = limit_type->_lo;\n+    max = limit_type->_hi;\n+    umin = limit_type->_ulo;\n+    umax = limit_type->_uhi;\n+    zeros |= limit_type->_bits._zeros;\n+    ones |= limit_type->_bits._ones;\n+  }\n+  TypeIntPrototype<S, U> prototype{{min, max}, {umin, umax}, {zeros, ones}};\n+  return CT::make_or_top(prototype, Type::WidenMax);\n+}\n+template const Type* TypeIntHelper::int_type_widen(const TypeInt* new_type, const TypeInt* old_type, const TypeInt* limit_type);\n+template const Type* TypeIntHelper::int_type_widen(const TypeLong* new_type, const TypeLong* old_type, const TypeLong* limit_type);\n+\n+\/\/ Called by PhiNode::Value during GVN, monotonically narrow the value set, only\n+\/\/ narrow if the bits change or if the bounds are tightened enough to avoid\n+\/\/ slow convergence\n+template <class CT>\n+const Type* TypeIntHelper::int_type_narrow(const CT* new_type, const CT* old_type) {\n+  using S = decltype(CT::_lo);\n+  using U = decltype(CT::_ulo);\n+\n+  if (new_type->singleton() || old_type == nullptr) {\n+    return new_type;\n+  }\n+\n+  \/\/ If new guy is equal to old guy, no narrowing\n+  if (int_type_is_equal(new_type, old_type)) {\n+    return old_type;\n+  }\n+\n+  \/\/ If old guy was maximum range, allow the narrowing\n+  if (int_type_is_equal(old_type, CT::TYPE_DOMAIN)) {\n+    return new_type;\n+  }\n+\n+  \/\/ Doesn't narrow; pretty weird\n+  if (!int_type_is_subset(old_type, new_type)) {\n+    return new_type;\n+  }\n+\n+  \/\/ Bits change\n+  if (old_type->_bits._zeros != new_type->_bits._zeros || old_type->_bits._ones != new_type->_bits._ones) {\n+    return new_type;\n+  }\n+\n+  \/\/ Only narrow if the range shrinks a lot\n+  U oc = cardinality_from_bounds(RangeInt<S>{old_type->_lo, old_type->_hi},\n+                                 RangeInt<U>{old_type->_ulo, old_type->_uhi});\n+  U nc = cardinality_from_bounds(RangeInt<S>{new_type->_lo, new_type->_hi},\n+                                 RangeInt<U>{new_type->_ulo, new_type->_uhi});\n+  return (nc > (oc >> 1) + (SMALL_TYPEINT_THRESHOLD * 2)) ? old_type : new_type;\n+}\n+template const Type* TypeIntHelper::int_type_narrow(const TypeInt* new_type, const TypeInt* old_type);\n+template const Type* TypeIntHelper::int_type_narrow(const TypeLong* new_type, const TypeLong* old_type);\n+\n+\n+#ifndef PRODUCT\n+template <class T>\n+static const char* int_name_near(T origin, const char* xname, char* buf, size_t buf_size, T n) {\n+  if (n < origin) {\n+    if (n <= origin - 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s-\" INT32_FORMAT, xname, jint(origin - n));\n+  } else if (n > origin) {\n+    if (n >= origin + 10000) {\n+      return nullptr;\n+    }\n+    os::snprintf_checked(buf, buf_size, \"%s+\" INT32_FORMAT, xname, jint(n - origin));\n+  } else {\n+    return xname;\n+  }\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::intname(char* buf, size_t buf_size, jint n) {\n+  const char* str = int_name_near<jint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jint>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::uintname(char* buf, size_t buf_size, juint n) {\n+  const char* str = int_name_near<juint>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<juint>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, UINT32_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::longname(char* buf, size_t buf_size, jlong n) {\n+  const char* str = int_name_near<jlong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(min_jlong, \"minlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<jlong>(min_jint, \"minint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n+  return buf;\n+}\n+\n+const char* TypeIntHelper::ulongname(char* buf, size_t buf_size, julong n) {\n+  const char* str = int_name_near<julong>(max_julong, \"maxulong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_jlong, \"maxlong\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_juint, \"maxuint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  str = int_name_near<julong>(max_jint, \"maxint\", buf, buf_size, n);\n+  if (str != nullptr) {\n+    return str;\n+  }\n+\n+  os::snprintf_checked(buf, buf_size, JULONG_FORMAT\"u\", n);\n+  return buf;\n+}\n+\n+template <class U>\n+const char* TypeIntHelper::bitname(char* buf, size_t buf_size, U zeros, U ones) {\n+  constexpr juint W = sizeof(U) * 8;\n+\n+  if (buf_size < W + 1) {\n+    return \"#####\";\n+  }\n+\n+  for (juint i = 0; i < W; i++) {\n+    U mask = U(1) << (W - 1 - i);\n+    if ((zeros & mask) != 0) {\n+      buf[i] = '0';\n+    } else if ((ones & mask) != 0) {\n+      buf[i] = '1';\n+    } else {\n+      buf[i] = '*';\n+    }\n+  }\n+  buf[W] = 0;\n+  return buf;\n+}\n+template const char* TypeIntHelper::bitname(char* buf, size_t buf_size, juint zeros, juint ones);\n+template const char* TypeIntHelper::bitname(char* buf, size_t buf_size, julong zeros, julong ones);\n+\n+void TypeIntHelper::int_type_dump(const TypeInt* t, outputStream* st, bool verbose) {\n+  char buf1[40], buf2[40], buf3[40], buf4[40], buf5[40];\n+  if (int_type_is_equal(t, TypeInt::INT)) {\n+    st->print(\"int\");\n+  } else if (t->is_con()) {\n+    st->print(\"int:%s\", intname(buf1, sizeof(buf1), t->get_con()));\n+  } else if (int_type_is_equal(t, TypeInt::BOOL)) {\n+    st->print(\"bool\");\n+  } else if (int_type_is_equal(t, TypeInt::BYTE)) {\n+    st->print(\"byte\");\n+  } else if (int_type_is_equal(t, TypeInt::CHAR)) {\n+    st->print(\"char\");\n+  } else if (int_type_is_equal(t, TypeInt::SHORT)) {\n+    st->print(\"short\");\n+  } else {\n+    if (verbose) {\n+      st->print(\"int:%s..%s, %s..%s, %s\",\n+                intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n+    } else {\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"int:>=%s\", intname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"int:<=%s\", intname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"int:%s..%s\", intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"int:%s..%s, %s..%s\",\n+                  intname(buf1, sizeof(buf1), t->_lo), intname(buf2, sizeof(buf2), t->_hi),\n+                  uintname(buf3, sizeof(buf3), t->_ulo), uintname(buf4, sizeof(buf4), t->_uhi));\n+      }\n+\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeInt::INT) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n+\n+void TypeIntHelper::int_type_dump(const TypeLong* t, outputStream* st, bool verbose) {\n+  char buf1[80], buf2[80], buf3[80], buf4[80], buf5[80];\n+  if (int_type_is_equal(t, TypeLong::LONG)) {\n+    st->print(\"long\");\n+  } else if (t->is_con()) {\n+    st->print(\"long:%s\", longname(buf1, sizeof(buf1), t->get_con()));\n+  } else {\n+    if (verbose) {\n+      st->print(\"long:%s..%s, %s..%s, bits:%s\",\n+                longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi),\n+                bitname(buf5, sizeof(buf5), t->_bits._zeros, t->_bits._ones));\n+    } else {\n+      if (t->_lo >= 0) {\n+        if (t->_hi == max_jint) {\n+          st->print(\"long:>=%s\", longname(buf1, sizeof(buf1), t->_lo));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else if (t->_hi < 0) {\n+        if (t->_lo == min_jint) {\n+          st->print(\"long:<=%s\", longname(buf1, sizeof(buf1), t->_hi));\n+        } else {\n+          st->print(\"long:%s..%s\", longname(buf1, sizeof(buf1), t->_lo), longname(buf2, sizeof(buf2), t->_hi));\n+        }\n+      } else {\n+        st->print(\"long:%s..%s, %s..%s\",\n+                  longname(buf1, sizeof(buf1), t->_lo), longname(buf2,sizeof(buf2), t-> _hi),\n+                  ulongname(buf3, sizeof(buf3), t->_ulo), ulongname(buf4, sizeof(buf4), t->_uhi));\n+      }\n+    }\n+  }\n+\n+  if (t->_widen > 0 && t != TypeLong::LONG) {\n+    st->print(\", widen: %d\", t->_widen);\n+  }\n+}\n+#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":1081,"deletions":0,"binary":false,"changes":1081,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_RANGEINFERENCE_HPP\n+#define SHARE_OPTO_RANGEINFERENCE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <type_traits>\n+\n+class outputStream;\n+class Type;\n+class TypeInt;\n+class TypeLong;\n+\n+\/\/ A simple range in the signed or unsigned domain\n+template <class T>\n+class RangeInt {\n+public:\n+  T _lo;\n+  T _hi;\n+};\n+\n+\/**\n+ * Bits that are known to be 0 or 1. A value v satisfies this constraint iff\n+ * (v & zeros) == 0 && (v & ones) == ones. I.e, any bit that is 1 in zeros must\n+ * be 0 in v, and any bit that is 1 in ones must be 1 in v.\n+ *\n+ * I.e, for each bit position from 0 to sizeof(U) - 1, the corresponding bits\n+ * of zeros, ones and the allowed bit in v must follow:\n+ *\n+ * zeros    ones    allowed bits\n+ * 0        0       0 or 1\n+ * 1        0       0\n+ * 0        1       1\n+ * 1        1       none (impossible state)\n+ *\n+ * E.g:\n+ * zeros: 00110100\n+ * ones:  10000010\n+ * Then:  10001010 would satisfy the bit constraints\n+ * while: 10011000 would not since the bit at the 4th position violates\n+ * zeros and the bit at the 7th position violates ones\n+ *\n+ * A KnownBits is sane if there is no position at which a bit must be both set\n+ * and unset at the same time. That is (zeros & ones) == 0.\n+ *\/\n+template <class U>\n+class KnownBits {\n+  static_assert(U(-1) > U(0), \"bit info should be unsigned\");\n+\n+public:\n+  U _zeros;\n+  U _ones;\n+\n+  bool is_satisfied_by(U v) const {\n+    return (v & _zeros) == U(0) && (v & _ones) == _ones;\n+  }\n+};\n+\n+\/\/ All the information needed to construct a TypeInt\/TypeLong, the constraints\n+\/\/ here may be arbitrary and need to be canonicalized to construct a\n+\/\/ TypeInt\/TypeLong\n+template <class S, class U>\n+class TypeIntPrototype {\n+public:\n+  static_assert(S(-1) < S(0), \"\");\n+  static_assert(U(-1) > U(0), \"\");\n+  static_assert(sizeof(S) == sizeof(U), \"\");\n+\n+  RangeInt<S> _srange;\n+  RangeInt<U> _urange;\n+  KnownBits<U> _bits;\n+\n+private:\n+  friend class TypeInt;\n+  friend class TypeLong;\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_exhaustive();\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_simple();\n+\n+  template <class T1, class T2>\n+  friend void test_canonicalize_constraints_random();\n+\n+  \/\/ A canonicalized version of a TypeIntPrototype, if the prototype represents\n+  \/\/ an empty type, _present is false, otherwise, _data is canonical\n+  class CanonicalizedTypeIntPrototype {\n+  public:\n+    bool _present; \/\/ whether this is an empty set\n+    TypeIntPrototype<S, U> _data;\n+\n+    bool empty() const {\n+      return !_present;\n+    }\n+\n+    static CanonicalizedTypeIntPrototype make_empty() {\n+      return {false, {}};\n+    }\n+  };\n+\n+  CanonicalizedTypeIntPrototype canonicalize_constraints() const;\n+  int normalize_widen(int w) const;\n+#ifdef ASSERT\n+  bool contains(S v) const;\n+  void verify_constraints() const;\n+#endif \/\/ ASSERT\n+};\n+\n+\/\/ Various helper functions for TypeInt\/TypeLong operations\n+class TypeIntHelper {\n+public:\n+  \/\/ Calculate the cardinality of a TypeInt\/TypeLong ignoring the bits\n+  \/\/ constraints, the return value is the cardinality minus 1 to not overflow\n+  \/\/ with the bottom type\n+  template <class S, class U>\n+  static U cardinality_from_bounds(const RangeInt<S>& srange, const RangeInt<U>& urange) {\n+    static_assert(S(-1) < S(0), \"\");\n+    static_assert(U(-1) > U(0), \"\");\n+    static_assert(sizeof(S) == sizeof(U), \"\");\n+\n+    if (U(srange._lo) == urange._lo) {\n+      \/\/ srange is the same as urange\n+      assert(U(srange._hi) == urange._hi, \"\");\n+      \/\/ The cardinality is (hi - lo + 1), we return the result minus 1\n+      return urange._hi - urange._lo;\n+    }\n+\n+    \/\/ srange intersects with urange in 2 intervals [srange._lo, urange._hi]\n+    \/\/ and [urange._lo, srange._hi]\n+    \/\/ The cardinality is (uhi - lo + 1) + (hi - ulo + 1), we return the result\n+    \/\/ minus 1\n+    return (urange._hi - U(srange._lo)) + (U(srange._hi) - urange._lo) + U(1);\n+  }\n+\n+  template <class CT>\n+  static const Type* int_type_xmeet(const CT* i1, const Type* t2);\n+\n+  template <class CT>\n+  static bool int_type_is_equal(const CT* t1, const CT* t2) {\n+    return t1->_lo == t2->_lo && t1->_hi == t2->_hi &&\n+           t1->_ulo == t2->_ulo && t1->_uhi == t2->_uhi &&\n+           t1->_bits._zeros == t2->_bits._zeros && t1->_bits._ones == t2->_bits._ones;\n+  }\n+\n+  template <class CT>\n+  static bool int_type_is_subset(const CT* super, const CT* sub) {\n+    return super->_lo <= sub->_lo && super->_hi >= sub->_hi &&\n+           super->_ulo <= sub->_ulo && super->_uhi >= sub->_uhi &&\n+           \/\/ All bits that are known in super must also be known to be the same\n+           \/\/ value in sub, &~ (and not) is the same as a set subtraction on bit\n+           \/\/ sets\n+           (super->_bits._zeros &~ sub->_bits._zeros) == 0 && (super->_bits._ones &~ sub->_bits._ones) == 0;\n+  }\n+\n+  template <class CT>\n+  static const Type* int_type_widen(const CT* new_type, const CT* old_type, const CT* limit_type);\n+\n+  template <class CT>\n+  static const Type* int_type_narrow(const CT* new_type, const CT* old_type);\n+\n+#ifndef PRODUCT\n+  static const char* intname(char* buf, size_t buf_size, jint n);\n+  static const char* uintname(char* buf, size_t buf_size, juint n);\n+  static const char* longname(char* buf, size_t buf_size, jlong n);\n+  static const char* ulongname(char* buf, size_t buf_size, julong n);\n+\n+  template <class U>\n+  static const char* bitname(char* buf, size_t buf_size, U zeros, U ones);\n+\n+  static void int_type_dump(const TypeInt* t, outputStream* st, bool verbose);\n+  static void int_type_dump(const TypeLong* t, outputStream* st, bool verbose);\n+#endif \/\/ PRODUCT\n+};\n+\n+#endif \/\/ SHARE_OPTO_RANGEINFERENCE_HPP\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -483,1 +484,0 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n@@ -542,19 +542,21 @@\n-  TypeInt::MINUS_1 = TypeInt::make(-1);  \/\/ -1\n-  TypeInt::ZERO    = TypeInt::make( 0);  \/\/  0\n-  TypeInt::ONE     = TypeInt::make( 1);  \/\/  1\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::MINUS_1  = TypeInt::make(-1);  \/\/ -1\n+  TypeInt::ZERO     = TypeInt::make( 0);  \/\/  0\n+  TypeInt::ONE      = TypeInt::make( 1);  \/\/  1\n+  TypeInt::BOOL     = TypeInt::make( 0, 1, WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC       = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT    = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT    = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ    = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE    = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_LE    = TypeInt::make(-1, 0, WidenMin);\n+  TypeInt::CC_GE    = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE     = TypeInt::make(-128, 127,     WidenMin); \/\/ Bytes\n+  TypeInt::UBYTE    = TypeInt::make(0, 255,        WidenMin); \/\/ Unsigned Bytes\n+  TypeInt::CHAR     = TypeInt::make(0, 65535,      WidenMin); \/\/ Java chars\n+  TypeInt::SHORT    = TypeInt::make(-32768, 32767, WidenMin); \/\/ Java shorts\n+  TypeInt::NON_ZERO = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::POS      = TypeInt::make(0, max_jint,   WidenMin); \/\/ Non-neg values\n+  TypeInt::POS1     = TypeInt::make(1, max_jint,   WidenMin); \/\/ Positive values\n+  TypeInt::INT      = TypeInt::make(min_jint, max_jint, WidenMax); \/\/ 32-bit integers\n+  TypeInt::SYMINT   = TypeInt::make(-max_jint, max_jint, WidenMin); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -562,1 +564,1 @@\n-  \/\/ a trinary (-1,0,+1) integer result AND as an efficient long\n+  \/\/ a trinary (-1, 0, +1) integer result AND as an efficient long\n@@ -564,16 +566,17 @@\n-  assert( TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n-  assert( (juint)(TypeInt::CC->_hi - TypeInt::CC->_lo) <= SMALLINT, \"CC is truly small\");\n-\n-  TypeLong::MAX = TypeLong::make(max_jlong);  \/\/ Long MAX\n-  TypeLong::MIN = TypeLong::make(min_jlong);  \/\/ Long MIN\n-  TypeLong::MINUS_1 = TypeLong::make(-1);        \/\/ -1\n-  TypeLong::ZERO    = TypeLong::make( 0);        \/\/  0\n-  TypeLong::ONE     = TypeLong::make( 1);        \/\/  1\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n-  TypeLong::TYPE_DOMAIN  = TypeLong::LONG;\n+  assert(TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n+\n+  TypeLong::MAX = TypeLong::make(max_jlong); \/\/ Long MAX\n+  TypeLong::MIN = TypeLong::make(min_jlong); \/\/ Long MIN\n+  TypeLong::MINUS_1  = TypeLong::make(-1);   \/\/ -1\n+  TypeLong::ZERO     = TypeLong::make( 0);   \/\/  0\n+  TypeLong::ONE      = TypeLong::make( 1);   \/\/  1\n+  TypeLong::NON_ZERO = TypeLong::make_or_top(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::POS      = TypeLong::make(0, max_jlong, WidenMin); \/\/ Non-neg values\n+  TypeLong::NEG      = TypeLong::make(min_jlong, -1, WidenMin);\n+  TypeLong::LONG     = TypeLong::make(min_jlong, max_jlong, WidenMax); \/\/ 64-bit integers\n+  TypeLong::INT      = TypeLong::make((jlong)min_jint, (jlong)max_jint,WidenMin);\n+  TypeLong::UINT     = TypeLong::make(0, (jlong)max_juint, WidenMin);\n+  TypeLong::TYPE_DOMAIN = TypeLong::LONG;\n@@ -1821,25 +1824,23 @@\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n-}\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -1847,3 +1848,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+TypeInt::TypeInt(const TypeIntPrototype<jint, juint>& t, int widen, bool dual)\n+  : TypeInteger(Int, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1852,9 +1854,4 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1862,1 +1859,1 @@\n-  return w;\n+  return (new TypeInt(canonicalized_t._data, widen, dual))->hashcons()->is_int();\n@@ -1865,3 +1862,4 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+const TypeInt* TypeInt::make(jint con) {\n+  juint ucon = con;\n+  return (new TypeInt(TypeIntPrototype<jint, juint>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                      WidenMin, false))->hashcons()->is_int();\n@@ -1870,44 +1868,3 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeInt::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeInt\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Int:                     \/\/ Int vs Int?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeInt* TypeInt::make(jint lo, jint hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, widen)->is_int();\n@@ -1916,55 +1873,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen) {\n+  return make_or_top(t, widen, false);\n+}\n@@ -1972,3 +1877,6 @@\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+bool TypeInt::contains(jint i) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  juint u = i;\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -1977,9 +1885,4 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n+bool TypeInt::contains(const TypeInt* t) const {\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -1987,2 +1890,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeInt::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t);\n+}\n@@ -1990,2 +1894,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                     _widen, !_is_dual);\n+}\n@@ -1993,2 +1899,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_int(), limit->isa_int());\n+}\n@@ -1996,8 +1904,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2006,1 +1910,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_int());\n@@ -2010,1 +1914,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -2012,1 +1917,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2014,0 +1919,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -2017,1 +1924,2 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                        this->_widen, false))->hashcons();\n@@ -2024,3 +1932,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -2032,1 +1940,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n@@ -2041,43 +1950,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2088,1 +1954,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2092,1 +1958,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2097,14 +1963,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n-}\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -2112,3 +1976,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n+TypeLong::TypeLong(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual)\n+  : TypeInteger(Long, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -2117,9 +1982,4 @@\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -2127,1 +1987,1 @@\n-  return w;\n+  return (new TypeLong(canonicalized_t._data, widen, dual))->hashcons()->is_long();\n@@ -2130,3 +1990,4 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const TypeLong* TypeLong::make(jlong con) {\n+  julong ucon = con;\n+  return (new TypeLong(TypeIntPrototype<jlong, julong>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                       WidenMin, false))->hashcons()->is_long();\n@@ -2135,45 +1996,3 @@\n-\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeLong::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeLong\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Long:                    \/\/ Long vs Long?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeLong* TypeLong::make(jlong lo, jlong hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, widen)->is_long();\n@@ -2182,58 +2001,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen) {\n+  return make_or_top(t, widen, false);\n+}\n@@ -2241,3 +2005,6 @@\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+bool TypeLong::contains(jlong i) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  julong u = i;\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -2246,9 +2013,4 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n+bool TypeLong::contains(const TypeLong* t) const {\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -2256,2 +2018,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeLong::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t);\n+}\n@@ -2259,2 +2022,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                      _widen, !_is_dual);\n+}\n@@ -2262,2 +2027,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_long(), limit->isa_long());\n+}\n@@ -2265,8 +2032,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2275,1 +2038,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_long());\n@@ -2279,1 +2042,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -2281,1 +2045,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2283,0 +2047,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -2286,1 +2052,2 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                         this->_widen, false))->hashcons();\n@@ -2293,3 +2060,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -2301,1 +2068,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n@@ -2310,55 +2078,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeLong\n-#ifndef PRODUCT\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n-  } else {\n-    return xname;\n-  }\n-  return buf;\n-}\n-\n-static const char* longname(char* buf, size_t buf_size, jlong n) {\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n-    st->print(\"long\");\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n-\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2369,1 +2082,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2373,1 +2086,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2376,0 +2089,19 @@\n+\/\/------------------------------dump2------------------------------------------\n+#ifndef PRODUCT\n+void TypeInt::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeInt::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n+}\n+\n+void TypeLong::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeLong::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n+}\n+#endif\n+\n@@ -2684,1 +2416,7 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n+      return size;\n+    }\n@@ -2686,2 +2424,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable,\n+                         isize, _stable && a->_stable,\n@@ -5299,1 +5036,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -5301,1 +5038,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -5303,0 +5041,1 @@\n+  }\n@@ -5532,1 +5271,6 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      assert(tm == Type::TOP || tm == Type::BOTTOM, \"\");\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":230,"deletions":486,"binary":false,"changes":716,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n@@ -78,0 +80,3 @@\n+template <class T, class U>\n+class TypeIntPrototype;\n+\n@@ -313,0 +318,4 @@\n+  \/\/ This has the same semantics as std::dynamic_cast<TypeClass*>(this)\n+  template <typename TypeClass>\n+  const TypeClass* try_cast() const;\n+\n@@ -626,1 +635,6 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _is_dual(dual), _widen(w) {}\n+\n+  \/\/ Denote that a set is a dual set.\n+  \/\/ Dual sets are only used to compute the join of 2 sets, and not used\n+  \/\/ outside.\n+  const bool _is_dual;\n@@ -646,0 +660,148 @@\n+\/**\n+ * Definition:\n+ *\n+ * A TypeInt represents a set of non-empty jint values. A jint v is an element\n+ * of a TypeInt iff:\n+ *\n+ *   v >= _lo && v <= _hi &&\n+ *   juint(v) >= _ulo && juint(v) <= _uhi &&\n+ *   _bits.is_satisfied_by(v)\n+ *\n+ * Multiple sets of parameters can represent the same set.\n+ * E.g: consider 2 TypeInt t1, t2\n+ *\n+ * t1._lo = 2, t1._hi = 7, t1._ulo = 0, t1._uhi = 5, t1._bits._zeros = 0x00000000, t1._bits._ones = 0x1\n+ * t2._lo = 3, t2._hi = 5, t2._ulo = 3, t2._uhi = 5, t2._bits._zeros = 0xFFFFFFF8, t2._bits._ones = 0x1\n+ *\n+ * Then, t1 and t2 both represent the set {3, 5}. We can also see that the\n+ * constraints of t2 are the tightest possible. I.e there exists no TypeInt t3\n+ * which also represents {3, 5} such that any of these would be true:\n+ *\n+ *  1)  t3._lo  > t2._lo\n+ *  2)  t3._hi  < t2._hi\n+ *  3)  t3._ulo > t2._ulo\n+ *  4)  t3._uhi < t2._uhi\n+ *  5)  (t3._bits._zeros &~ t2._bis._zeros) != 0\n+ *  6)  (t3._bits._ones  &~ t2._bits._ones) != 0\n+ *\n+ * The 5-th condition mean that the subtraction of the bitsets represented by\n+ * t3._bits._zeros and t2._bits._zeros is not empty, which means that the\n+ * bits in t3._bits._zeros is not a subset of those in t2._bits._zeros, the\n+ * same applies to _bits._ones\n+ *\n+ * To simplify reasoning about the types in optimizations, we canonicalize\n+ * every TypeInt to its tightest form, already at construction. E.g a TypeInt\n+ * t with t._lo < 0 will definitely contain negative values. It also makes it\n+ * trivial to determine if a TypeInt instance is a subset of another.\n+ *\n+ * Lemmas:\n+ *\n+ * 1. Since every TypeInt instance is non-empty and canonicalized, all the\n+ *   bounds must also be elements of such TypeInt. Or else, we can tighten the\n+ *   bounds by narrowing it by one, which contradicts the assumption of the\n+ *   TypeInt being canonical.\n+ *\n+ * 2.\n+ *   2.1.  _lo <= jint(_ulo)\n+ *   2.2.  _lo <= _hi\n+ *   2.3.  _lo <= jint(_uhi)\n+ *   2.4.  _ulo <= juint(_lo)\n+ *   2.5.  _ulo <= juint(_hi)\n+ *   2.6.  _ulo <= _uhi\n+ *   2.7.  _hi >= _lo\n+ *   2.8.  _hi >= jint(_ulo)\n+ *   2.9.  _hi >= jint(_uhi)\n+ *   2.10. _uhi >= juint(_lo)\n+ *   2.11. _uhi >= _ulo\n+ *   2.12. _uhi >= juint(_hi)\n+ *\n+ *   Proof of lemma 2:\n+ *\n+ *   2.1. _lo <= jint(_ulo):\n+ *     According the lemma 1, _ulo is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _ulo in the signed\n+ *     domain, or in a more programmatical way, _lo <= jint(_ulo).\n+ *   2.2. _lo <= _hi:\n+ *     According the lemma 1, _hi is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _hi.\n+ *\n+ *   The other inequalities can be proved in a similar manner.\n+ *\n+ * 3. Given 2 jint values x, y where either both >= 0 or both < 0. Then:\n+ *\n+ *   x <= y iff juint(x) <= juint(y)\n+ *   I.e. x <= y in the signed domain iff x <= y in the unsigned domain\n+ *\n+ * 4. Either _lo == jint(_ulo) and _hi == jint(_uhi), or each element of a\n+ *   TypeInt lies in either interval [_lo, jint(_uhi)] or [jint(_ulo), _hi]\n+ *   (note that these intervals are disjoint in this case).\n+ *\n+ *   Proof of lemma 4:\n+ *\n+ *   For a TypeInt t, there are 3 possible cases:\n+ *\n+ *   a. t._lo >= 0, we have:\n+ *\n+ *     0 <= t_lo <= jint(t._ulo)           (lemma 2.1)\n+ *     juint(t._lo) <= juint(jint(t._ulo)) (lemma 3)\n+ *                  == t._ulo              (juint(jint(v)) == v with juint v)\n+ *                  <= juint(t._lo)        (lemma 2.4)\n+ *\n+ *     Which means that t._lo == jint(t._ulo).\n+ *\n+ *     Furthermore,\n+ *\n+ *     0 <= t._lo <= t._hi                 (lemma 2.2)\n+ *     0 <= t._lo <= jint(t._uhi)          (lemma 2.3)\n+ *     t._hi >= jint(t._uhi)               (lemma 2.9)\n+ *\n+ *     juint(t._hi) >= juint(jint(t._uhi)) (lemma 3)\n+ *                  == t._uhi              (juint(jint(v)) == v with juint v)\n+ *                  >= juint(t._hi)        (lemma 2.12)\n+ *\n+ *     Which means that t._hi == jint(t._uhi).\n+ *     In this case, t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ *   b. t._hi < 0. Similarly, we can conclude that:\n+ *     t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ *   c. t._lo < 0, t._hi >= 0.\n+ *\n+ *     Since t._ulo <= juint(t._hi) (lemma 2.5), we must have jint(t._ulo) >= 0\n+ *     because all negative values is larger than all non-negative values in the\n+ *     unsigned domain.\n+ *\n+ *     Since t._uhi >= juint(t._lo) (lemma 2.10), we must have jint(t._uhi) < 0\n+ *     similar to the reasoning above.\n+ *\n+ *     In this case, each element of t belongs to either [t._lo, jint(t._uhi)] or\n+ *     [jint(t._ulo), t._hi].\n+ *\n+ *     Below is an illustration of the TypeInt in this case, the intervals that\n+ *     the elements can be in are marked using the = symbol. Note how the\n+ *     negative range in the signed domain wrap around in the unsigned domain.\n+ *\n+ *     Signed:\n+ *     -----lo=========uhi---------0--------ulo==========hi-----\n+ *     Unsigned:\n+ *                                 0--------ulo==========hi----------lo=========uhi---------\n+ *\n+ *   This property is useful for our analysis of TypeInt values. Additionally,\n+ *   it can be seen that _lo and jint(_uhi) are both < 0 or both >= 0, and the\n+ *   same applies to jint(_ulo) and _hi.\n+ *\n+ *   We call [_lo, jint(_uhi)] and [jint(_ulo), _hi] \"simple intervals\". Then,\n+ *   a TypeInt consists of 2 simple intervals, each of which has its bounds\n+ *   being both >= 0 or both < 0. If both simple intervals lie in the same half\n+ *   of the integer domain, they must be the same (i.e _lo == jint(_ulo) and\n+ *   _hi == jint(_uhi)). Otherwise, [_lo, jint(_uhi)] must lie in the negative\n+ *   half and [jint(_ulo), _hi] must lie in the non-negative half of the signed\n+ *   domain (equivalently, [_lo, jint(_uhi)] must lie in the upper half and\n+ *   [jint(_ulo), _hi] must lie in the lower half of the unsigned domain).\n+ *\/\n+class TypeInt : public TypeInteger {\n+private:\n+  TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual);\n@@ -647,0 +809,1 @@\n+  friend class TypeIntHelper;\n@@ -648,5 +811,0 @@\n-\/\/------------------------------TypeInt----------------------------------------\n-\/\/ Class of integer ranges, the set of integers between a lower bound and an\n-\/\/ upper bound, inclusive.\n-class TypeInt : public TypeInteger {\n-  TypeInt( jint lo, jint hi, int w );\n@@ -654,1 +812,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -658,1 +816,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -662,1 +820,5 @@\n-  const jint _lo, _hi;          \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeInt if it satisfies all\n+  \/\/ the below constraints, see contains(jint)\n+  const jint _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const juint _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<juint> _bits;\n@@ -664,1 +826,1 @@\n-  static const TypeInt *make(jint lo);\n+  static const TypeInt* make(jint con);\n@@ -666,1 +828,2 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const TypeInt* make(jint lo, jint hi, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen);\n@@ -669,1 +832,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -671,1 +834,5 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  \/\/ Check if a jint\/TypeInt is a subset of this TypeInt (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n@@ -673,1 +840,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -675,4 +842,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -685,23 +852,25 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-  static const TypeInt *as_self(const Type *t) { return t->is_int(); }\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+\n+  static const TypeInt* as_self(const Type* t) { return t->is_int(); }\n@@ -709,1 +878,2 @@\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const;\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+  void dump_verbose() const;\n@@ -713,4 +883,1 @@\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-\/\/ Class of long integer ranges, the set of integers between a lower bound and\n-\/\/ an upper bound, inclusive.\n+\/\/ Similar to TypeInt\n@@ -718,1 +885,6 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+private:\n+  TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual);\n+\n+  friend class TypeIntHelper;\n+\n@@ -721,1 +893,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -729,1 +901,5 @@\n-  const jlong _lo, _hi;         \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeLong if it satisfies all\n+  \/\/ the below constraints, see contains(jlong)\n+  const jlong _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const julong _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<julong> _bits;\n@@ -731,1 +907,1 @@\n-  static const TypeLong *make(jlong lo);\n+  static const TypeLong* make(jlong con);\n@@ -733,1 +909,2 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const TypeLong* make(jlong lo, jlong hi, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen);\n@@ -736,1 +913,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -739,0 +916,4 @@\n+  \/\/ Check if a jlong\/TypeLong is a subset of this TypeLong (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n@@ -748,4 +929,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -753,10 +934,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -765,1 +948,1 @@\n-  static const TypeLong *as_self(const Type *t) { return t->is_long(); }\n+  static const TypeLong* as_self(const Type* t) { return t->is_long(); }\n@@ -768,1 +951,2 @@\n-  virtual void dump2( Dict &d, uint, outputStream *st  ) const;\/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const;\/\/ Specialized per-Type dumping\n+  void dump_verbose() const;\n@@ -2445,0 +2629,10 @@\n+template <>\n+inline const TypeInt* Type::try_cast<TypeInt>() const {\n+  return isa_int();\n+}\n+\n+template <>\n+inline const TypeLong* Type::try_cast<TypeLong>() const {\n+  return isa_long();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":262,"deletions":68,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -3603,0 +3603,7 @@\n+\n+    Array<u1>* old_table = scratch_class->fieldinfo_search_table();\n+    Array<u1>* search_table = FieldInfoStream::create_search_table(scratch_class->constants(), new_fis, scratch_class->class_loader_data(), CHECK);\n+    scratch_class->set_fieldinfo_search_table(search_table);\n+    MetadataFactory::free_array<u1>(scratch_class->class_loader_data(), old_table);\n+\n+    DEBUG_ONLY(FieldInfoStream::validate_search_table(scratch_class->constants(), new_fis, search_table));\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2528,1 +2528,1 @@\n-      if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {\n+      if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (size_t)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,2 +158,2 @@\n-JVMFlag::Error CodeCacheSegmentSizeConstraintFunc(uintx value, bool verbose) {\n-  if (CodeCacheSegmentSize < (uintx)CodeEntryAlignment) {\n+JVMFlag::Error CodeCacheSegmentSizeConstraintFunc(size_t value, bool verbose) {\n+  if (CodeCacheSegmentSize < (size_t)CodeEntryAlignment) {\n@@ -177,1 +177,1 @@\n-  if (CodeCacheSegmentSize < (uintx)OptoLoopAlignment) {\n+  if (CodeCacheSegmentSize < (size_t)OptoLoopAlignment) {\n@@ -206,1 +206,1 @@\n-  if ((uintx)CodeEntryAlignment > CodeCacheSegmentSize) {\n+  if ((size_t)CodeEntryAlignment > CodeCacheSegmentSize) {\n@@ -302,0 +302,1 @@\n+  const int max_modes = 4;\n@@ -303,1 +304,1 @@\n-  for (int i = 0; i < 2; i++) {\n+  for (int i = 0; i < max_modes; i++) {\n@@ -315,1 +316,1 @@\n-                        \"for VerifyIterativeGVN: maximal 2 digits\\n\", original_value);\n+                        \"for VerifyIterativeGVN: maximal %d digits\\n\", original_value, max_modes);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  f(uintx, CodeCacheSegmentSizeConstraintFunc)          \\\n+  f(size_t, CodeCacheSegmentSizeConstraintFunc)         \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,14 +102,2 @@\n-JVMFlag::Error PerfDataSamplingIntervalFunc(int value, bool verbose) {\n-  if ((value % PeriodicTask::interval_gran != 0)) {\n-    JVMFlag::printError(verbose,\n-                        \"PerfDataSamplingInterval (%d) must be \"\n-                        \"evenly divisible by PeriodicTask::interval_gran (%d)\\n\",\n-                        value, PeriodicTask::interval_gran);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error VMPageSizeConstraintFunc(uintx value, bool verbose) {\n-  uintx min = (uintx)os::vm_page_size();\n+JVMFlag::Error VMPageSizeConstraintFunc(size_t value, bool verbose) {\n+  size_t min = os::vm_page_size();\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,1 @@\n-  f(int,    PerfDataSamplingIntervalFunc)             \\\n-  f(uintx,  VMPageSizeConstraintFunc)                 \\\n+  f(size_t, VMPageSizeConstraintFunc)                 \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1531,1 +1531,1 @@\n-  product_pd(uintx, CodeCacheSegmentSize, EXPERIMENTAL,                     \\\n+  product_pd(size_t, CodeCacheSegmentSize, EXPERIMENTAL,                    \\\n@@ -1546,1 +1546,1 @@\n-  product_pd(uintx, InitialCodeCacheSize,                                   \\\n+  product_pd(size_t, InitialCodeCacheSize,                                  \\\n@@ -1550,1 +1550,1 @@\n-  develop_pd(uintx, CodeCacheMinimumUseSpace,                               \\\n+  develop_pd(size_t, CodeCacheMinimumUseSpace,                              \\\n@@ -1552,1 +1552,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1557,1 +1557,1 @@\n-  product_pd(uintx, ReservedCodeCacheSize,                                  \\\n+  product_pd(size_t, ReservedCodeCacheSize,                                 \\\n@@ -1561,1 +1561,1 @@\n-  product_pd(uintx, NonProfiledCodeHeapSize,                                \\\n+  product_pd(size_t, NonProfiledCodeHeapSize,                               \\\n@@ -1563,1 +1563,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1565,1 +1565,1 @@\n-  product_pd(uintx, ProfiledCodeHeapSize,                                   \\\n+  product_pd(size_t, ProfiledCodeHeapSize,                                  \\\n@@ -1567,1 +1567,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1569,1 +1569,1 @@\n-  product_pd(uintx, NonNMethodCodeHeapSize,                                 \\\n+  product_pd(size_t, NonNMethodCodeHeapSize,                                \\\n@@ -1573,1 +1573,1 @@\n-  product_pd(uintx, CodeCacheExpansionSize,                                 \\\n+  product_pd(size_t, CodeCacheExpansionSize,                                \\\n@@ -1575,1 +1575,1 @@\n-          range(32*K, max_uintx)                                            \\\n+          range(32*K, SIZE_MAX)                                             \\\n@@ -1577,1 +1577,1 @@\n-  product_pd(uintx, CodeCacheMinBlockLength, DIAGNOSTIC,                    \\\n+  product_pd(size_t, CodeCacheMinBlockLength, DIAGNOSTIC,                   \\\n@@ -2058,0 +2058,4 @@\n+                                                                            \\\n+  develop(uint, BinarySearchThreshold, 16,                                  \\\n+          \"Minimal number of elements in a sorted collection to prefer\"     \\\n+          \"binary search over simple linear search.\" )                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+void preuniverse_stubs_init();\n@@ -73,1 +74,1 @@\n-jint universe_init();           \/\/ depends on codeCache_init and initial_stubs_init\n+jint universe_init();           \/\/ depends on codeCache_init and preuniverse_stubs_init\n@@ -133,7 +134,4 @@\n-  \/\/ stub routines in initial blob are referenced by later generated code\n-  initial_stubs_init();\n-  \/\/ stack overflow exception blob is referenced by the interpreter\n-  SharedRuntime::generate_initial_stubs();\n-  jint status = universe_init();  \/\/ dependent on codeCache_init and\n-                                  \/\/ initial_stubs_init and metaspace_init.\n-  if (status != JNI_OK)\n+  \/\/ initialize stubs needed before we can init the universe\n+  preuniverse_stubs_init();\n+  jint status = universe_init();  \/\/ dependent on codeCache_init and preuniverse_stubs_init\n+  if (status != JNI_OK) {\n@@ -141,1 +139,1 @@\n-\n+  }\n@@ -149,1 +147,1 @@\n-  AOTCodeCache::init2();     \/\/ depends on universe_init\n+  AOTCodeCache::init2();     \/\/ depends on universe_init, must be before initial_stubs_init\n@@ -151,0 +149,5 @@\n+\n+  initial_stubs_init();      \/\/ initial stub routines\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n+  AOTCodeCache::init_early_stubs_table();  \/\/ need this after initial_stubs\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -578,0 +578,1 @@\n+    assert (StubRoutines::catch_exception_entry() != nullptr, \"must be generated before\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -294,5 +294,20 @@\n-  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n-  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n-  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n-  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n-  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+  static address throw_AbstractMethodError_entry()          {\n+    assert(_throw_AbstractMethodError_blob != nullptr, \"\");\n+    return _throw_AbstractMethodError_blob->entry_point();\n+  }\n+  static address throw_IncompatibleClassChangeError_entry() {\n+    assert(_throw_IncompatibleClassChangeError_blob != nullptr, \"\");\n+    return  _throw_IncompatibleClassChangeError_blob->entry_point();\n+  }\n+  static address throw_NullPointerException_at_call_entry() {\n+    assert(_throw_NullPointerException_at_call_blob != nullptr, \"\");\n+    return  _throw_NullPointerException_at_call_blob->entry_point();\n+  }\n+  static address throw_StackOverflowError_entry()           {\n+    assert(_throw_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_StackOverflowError_blob->entry_point();\n+  }\n+  static address throw_delayed_StackOverflowError_entry()   {\n+    assert(_throw_delayed_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_delayed_StackOverflowError_blob->entry_point();\n+  }\n@@ -301,2 +316,8 @@\n-  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n-  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+  static address jfr_write_checkpoint() {\n+    assert(_jfr_write_checkpoint_blob != nullptr, \"\");\n+    return _jfr_write_checkpoint_blob->entry_point();\n+  }\n+  static address jfr_return_lease()     {\n+    assert(_jfr_return_lease_blob != nullptr, \"\");\n+    return _jfr_return_lease_blob->entry_point();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-\/\/ are generated in batches into one of four distinct BufferBlobs:\n+\/\/ are generated in batches into one of five distinct BufferBlobs:\n@@ -190,4 +190,5 @@\n-\/\/ 1) Initial stubs\n-\/\/ 2) Continuation stubs\n-\/\/ 3) Compiler stubs\n-\/\/ 4) Final stubs\n+\/\/ 1) PreUniverse stubs\n+\/\/ 2) Initial stubs\n+\/\/ 3) Continuation stubs\n+\/\/ 4) Compiler stubs\n+\/\/ 5) Final stubs\n@@ -281,0 +282,1 @@\n+\/\/   _preuniverse_stubs_code_size  =   500,\n@@ -514,0 +516,4 @@\n+#ifndef STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required initial stubs and entries\"\n+#endif\n+\n@@ -546,1 +552,15 @@\n-#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                     \\\n+#define STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                 \\\n+                                     do_stub,                           \\\n+                                     do_entry, do_entry_init,           \\\n+                                     do_entry_array,                    \\\n+                                     do_arch_blob,                      \\\n+                                     do_arch_entry, do_arch_entry_init) \\\n+  do_blob(preuniverse)                                                  \\\n+  do_stub(preuniverse, fence)                                           \\\n+  do_entry(preuniverse, fence, fence_entry, fence_entry)                \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub, do_arch_blob,              \\\n+                                    do_arch_entry, do_arch_entry_init)  \\\n+  end_blob(preuniverse)                                                 \\\n+\n+#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                      \\\n@@ -563,2 +583,0 @@\n-  do_stub(initial, fence)                                               \\\n-  do_entry(initial, fence, fence_entry, fence_entry)                    \\\n@@ -1025,0 +1043,6 @@\n+  STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                       \\\n+                               do_stub,                                 \\\n+                               do_entry, do_entry_init,                 \\\n+                               do_entry_array,                          \\\n+                               do_arch_blob,                            \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -189,4 +189,0 @@\n-\/\/\n-\/\/ Note: to break cycle with universe initialization, stubs are generated in two phases.\n-\/\/ The first one generates stubs needed during universe init (e.g., _handle_must_compile_first_entry).\n-\/\/ The second phase includes all other stubs (which may depend on universe being initialized.)\n@@ -202,0 +198,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n@@ -212,0 +209,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n@@ -228,0 +226,8 @@\n+  if (code_size == 0) {\n+    LogTarget(Info, stubs) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"%s\\t not generated\", buffer_name);\n+      return nullptr;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n+  static CallStub call_stub()                              { assert(_call_stub_entry != nullptr, \"\"); return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -775,1 +775,0 @@\n-    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n@@ -777,0 +776,1 @@\n+    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -39,1 +40,2 @@\n-template <typename T> unsigned count_leading_zeros(T v) {\n+template <typename T, ENABLE_IF(std::is_arithmetic<T>::value)>\n+unsigned count_leading_zeros(T v) {\n","filename":"src\/hotspot\/share\/utilities\/count_leading_zeros.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,5 @@\n+  const T* get() const {\n+    assert(_initialized, \"must be initialized before access\");\n+    return &_t;\n+  }\n+\n@@ -63,0 +68,4 @@\n+  const T& operator*() const {\n+    return *get();\n+  }\n+\n@@ -67,0 +76,4 @@\n+  const T* operator->() const {\n+    return get();\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/deferred.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_INTN_T_HPP\n+#define SHARE_UTILITIES_INTN_T_HPP\n+\n+#include \"utilities\/count_leading_zeros.hpp\"\n+\n+#include <limits>\n+\n+template <unsigned int nbits>\n+class uintn_t;\n+\n+\/\/ This class represents a signed integer type with the width of exactly nbits\n+\/\/ bits. Conceptually, nbits == 8 gives a type equivalent to int8_t,\n+\/\/ nbits == 16 gives a type equivalent to int16_t, and so on. This class may be\n+\/\/ used to verify the correctness of an algorithm that is supposed to be\n+\/\/ applicable to all fixed-width integral types. With small nbits, it makes it\n+\/\/ possible to perform an exhaustive test that exercises the algorithm with all\n+\/\/ possible input values.\n+\/\/ Implementation-wise, this class currently only supports 0 < nbits <= 8. Also\n+\/\/ note that this class is implemented so that overflows in alrithmetic\n+\/\/ operations are well-defined and wrap-around.\n+template <unsigned int nbits>\n+class intn_t {\n+  static_assert(0 < nbits && nbits <= 8, \"should not be larger than char\");\n+\n+private:\n+  \/\/ Only the lowest nbits bits are important, operations should act as if it\n+  \/\/ sign extends the lowest nbits to an int, performs the calculation on ints,\n+  \/\/ then truncates the result to nbits. In practice, we do not need to\n+  \/\/ truncate the result, as the lowest nbits will be sign extended in the next\n+  \/\/ operations. We can also sign extends the operands sparingly, for example,\n+  \/\/ addition or subtraction do not need this sign extension, and we can add or\n+  \/\/ subtract the value of _v directly. This is because the lowest nbits bits\n+  \/\/ of a sum or a difference only depends on the lowest nbits bits of the\n+  \/\/ operands.\n+  uint _v;\n+\n+  constexpr static uint _mask = (1 << nbits) - 1;\n+\n+  friend class uintn_t<nbits>;\n+\n+public:\n+  explicit constexpr intn_t(int v) : _v(v) {}\n+  constexpr intn_t() : _v(0) {}\n+  constexpr intn_t(const intn_t&) = default;\n+  constexpr intn_t& operator=(const intn_t&) = default;\n+  explicit constexpr intn_t(uintn_t<nbits> v);\n+\n+  \/\/ Sign extension\n+  explicit constexpr operator int() const {\n+    int shift = 32 - nbits;\n+    return int(_v << shift) >> shift;\n+  }\n+\n+  constexpr static int min = std::numeric_limits<unsigned int>::max() << (nbits - 1);\n+  constexpr static int max = (1 << (nbits - 1)) - 1;\n+  static_assert(min < max, \"\");\n+\n+  constexpr bool operator==(intn_t o) const { return (_v & _mask) == (o._v & _mask); }\n+  constexpr bool operator<(intn_t o) const { return int(*this) < int(o); }\n+  constexpr bool operator>(intn_t o) const { return int(*this) > int(o); }\n+  constexpr bool operator<=(intn_t o) const { return int(*this) <= int(o); }\n+  constexpr bool operator>=(intn_t o) const { return int(*this) >= int(o); }\n+};\n+\n+template <unsigned int nbits>\n+unsigned count_leading_zeros(uintn_t<nbits>);\n+\n+\/\/ The unsigned version of intn_t<nbits>\n+template <unsigned int nbits>\n+class uintn_t {\n+  static_assert(0 < nbits && nbits <= 8, \"should not be larger than char\");\n+\n+private:\n+  \/\/ Similar to intn_t<nbits>, the difference is that the operation should act\n+  \/\/ as if it zero extends the lowest nbits bits of the operands.\n+  uint _v;\n+\n+  constexpr static uint _mask = (1 << nbits) - 1;\n+\n+  friend class intn_t<nbits>;\n+\n+  friend unsigned count_leading_zeros<nbits>(uintn_t<nbits>);\n+\n+public:\n+  explicit constexpr uintn_t(int v) : _v(v) {}\n+  constexpr uintn_t() : _v(0) {}\n+  constexpr uintn_t(const uintn_t&) = default;\n+  constexpr uintn_t& operator=(const uintn_t&) = default;\n+  explicit constexpr uintn_t(intn_t<nbits> v) : _v(v._v) {}\n+\n+  \/\/ Zero extension\n+  explicit constexpr operator uint() const { return _v & _mask; }\n+\n+  constexpr static int min = 0;\n+  constexpr static int max = _mask;\n+  static_assert(min < max, \"\");\n+\n+  constexpr bool operator==(uintn_t o) const { return (_v & _mask) == (o._v & _mask); }\n+  constexpr bool operator!=(uintn_t o) const { return (_v & _mask) != (o._v & _mask); }\n+  constexpr bool operator<(uintn_t o) const { return (_v & _mask) < (o._v & _mask); }\n+  constexpr bool operator>(uintn_t o) const { return (_v & _mask) > (o._v & _mask); }\n+  constexpr bool operator<=(uintn_t o) const { return (_v & _mask) <= (o._v & _mask); }\n+  constexpr bool operator>=(uintn_t o) const { return (_v & _mask) >= (o._v & _mask); }\n+  constexpr uintn_t operator+(uintn_t o) const { return uintn_t(_v + o._v); }\n+  constexpr uintn_t operator-(uintn_t o) const { return uintn_t(_v - o._v); }\n+  constexpr uintn_t operator&(uintn_t o) const { return uintn_t(_v & o._v); }\n+  constexpr uintn_t operator|(uintn_t o) const { return uintn_t(_v | o._v); }\n+  constexpr uintn_t operator^(uintn_t o) const { return uintn_t(_v ^ o._v); }\n+  constexpr uintn_t operator>>(unsigned int s) const { return uintn_t((_v & _mask) >> s); }\n+  constexpr uintn_t operator<<(unsigned int s) const { return uintn_t(_v << s); }\n+  constexpr uintn_t operator~() const { return uintn_t(~_v); }\n+  constexpr uintn_t operator-() const { return uintn_t(-_v); }\n+  constexpr uintn_t& operator|=(uintn_t o) { _v |= o._v; return *this; }\n+};\n+\n+template <unsigned int nbits>\n+constexpr intn_t<nbits>::intn_t(uintn_t<nbits> v) : _v(v._v) {}\n+\n+namespace std {\n+\n+template <unsigned int nbits>\n+class numeric_limits<intn_t<nbits>> {\n+public:\n+  constexpr static intn_t<nbits> min() { return intn_t<nbits>(intn_t<nbits>::min); }\n+  constexpr static intn_t<nbits> max() { return intn_t<nbits>(intn_t<nbits>::max); }\n+};\n+\n+template <unsigned int nbits>\n+class numeric_limits<uintn_t<nbits>> {\n+public:\n+  constexpr static uintn_t<nbits> min() { return uintn_t<nbits>(uintn_t<nbits>::min); }\n+  constexpr static uintn_t<nbits> max() { return uintn_t<nbits>(uintn_t<nbits>::max); }\n+};\n+\n+} \/\/ namespace std\n+\n+template <unsigned int nbits>\n+inline unsigned count_leading_zeros(uintn_t<nbits> v) {\n+  return count_leading_zeros<unsigned int>(v._v & uintn_t<nbits>::_mask) - (32 - nbits);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_INTN_T_HPP\n","filename":"src\/hotspot\/share\/utilities\/intn_t.hpp","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+  friend class VMTWithVMATreeTest;\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include <cstring>\n+\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/count_leading_zeros.hpp\"\n+#include \"utilities\/packedTable.hpp\"\n+\n+\/\/ The thresholds are inclusive, and in practice the limits are rounded\n+\/\/ to the nearest power-of-two - 1.\n+\/\/ Based on the max_key and max_value we figure out the number of bits required to store\n+\/\/ key and value; imagine that only as bits (not aligned to byte boundary... yet).\n+\/\/ Then we concatenate the bits for key and value, and 'add' 1-7 padding zeroes\n+\/\/ (high-order bits) to align on bytes.\n+\/\/ In the end we have each element in the table consuming 1-8 bytes (case with 0 bits for key\n+\/\/ is ruled out).\n+PackedTableBase::PackedTableBase(uint32_t max_key, uint32_t max_value) {\n+  unsigned int key_bits = max_key == 0 ? 0 : 32 - count_leading_zeros(max_key);\n+  unsigned int value_bits = max_value == 0 ? 0 : 32 - count_leading_zeros(max_value);\n+  _element_bytes = align_up(key_bits + value_bits, 8) \/ 8;\n+  \/\/ shifting left by 32 is undefined behaviour, and in practice returns 1\n+  _key_mask = key_bits >= 32 ? -1 : (1U << key_bits) - 1;\n+  _value_shift = key_bits;\n+  _value_mask = value_bits >= 32 ? -1 : (1U << value_bits) - 1;\n+  guarantee(_element_bytes > 0, \"wouldn't work\");\n+  assert(_element_bytes <= sizeof(uint64_t), \"shouldn't happen\");\n+}\n+\n+\/\/ Note: we require the supplier to provide the elements in the final order as we can't easily sort\n+\/\/ within this method - qsort() accepts only pure function as comparator.\n+void PackedTableBuilder::fill(u1* table, size_t table_length, Supplier &supplier) const {\n+  uint32_t key, value;\n+  size_t offset = 0;\n+  for (; offset <= table_length && supplier.next(&key, &value); offset += _element_bytes) {\n+    assert((key & ~_key_mask) == 0, \"key out of bounds\");\n+    assert((value & ~_value_mask) == 0, \"value out of bounds: %x vs. %x (%x)\", value, _value_mask, ~_value_mask);\n+    uint64_t element = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n+    for (unsigned int i = 0; i < _element_bytes; ++i) {\n+      table[offset + i] = static_cast<u1>(0xFF & element);\n+      element >>= 8;\n+    }\n+  }\n+\n+  assert(offset == table_length, \"Did not fill whole array\");\n+  assert(!supplier.next(&key, &value), \"Supplier has more elements\");\n+}\n+\n+uint64_t PackedTableLookup::read_element(size_t offset) const {\n+  uint64_t element = 0;\n+  for (unsigned int i = 0; i < _element_bytes; ++i) {\n+    element |= static_cast<uint64_t>(_table[offset + i]) << (8 * i);\n+  }\n+  assert((element & ~((uint64_t) _key_mask | ((uint64_t) _value_mask << _value_shift))) == 0, \"read too much\");\n+  return element;\n+}\n+\n+bool PackedTableLookup::search(Comparator& comparator, uint32_t* found_key, uint32_t* found_value) const {\n+  unsigned int low = 0, high = checked_cast<unsigned int>(_table_length \/ _element_bytes);\n+  assert(low < high, \"must be\");\n+  while (low < high) {\n+    unsigned int mid = low + (high - low) \/ 2;\n+    assert(mid >= low && mid < high, \"integer overflow?\");\n+    uint64_t element = read_element(_element_bytes * mid);\n+    \/\/ Ignoring high 32 bits in element on purpose\n+    uint32_t key = static_cast<uint32_t>(element) & _key_mask;\n+    int cmp = comparator.compare_to(key);\n+    if (cmp == 0) {\n+      *found_key = key;\n+      \/\/ Since __builtin_memcpy in read_element does not copy bits outside the element\n+      \/\/ anything above _value_mask << _value_shift should be zero.\n+      *found_value = checked_cast<uint32_t>(element >> _value_shift) & _value_mask;\n+      return true;\n+    } else if (cmp < 0) {\n+      high = mid;\n+    } else {\n+      low = mid + 1;\n+    }\n+  }\n+  return false;\n+}\n+\n+#ifdef ASSERT\n+void PackedTableLookup::validate_order(Comparator &comparator) const {\n+  auto validator = [&] (size_t offset, uint32_t key, uint32_t value) {\n+    if (offset != 0) {\n+      assert(comparator.compare_to(key) < 0, \"not sorted\");\n+    }\n+    comparator.reset(key);\n+  };\n+  iterate(validator);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/packedTable.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Base for space-optimized structure supporting binary search. Each element\n+\/\/ consists of up to 32-bit key, and up to 32-bit value; these are packed\n+\/\/ into a bit-record with 1-byte alignment.\n+\/\/ The keys are ordered according to a custom comparator.\n+class PackedTableBase {\n+protected:\n+  unsigned int _element_bytes;\n+  uint32_t _key_mask;\n+  unsigned int _value_shift;\n+  uint32_t _value_mask;\n+\n+public:\n+  PackedTableBase(uint32_t max_key, uint32_t max_value);\n+\n+  \/\/ Returns number of bytes each element will occupy.\n+  inline unsigned int element_bytes(void) const { return _element_bytes; }\n+};\n+\n+\/\/ Helper class for constructing a packed table in the provided array.\n+class PackedTableBuilder: public PackedTableBase {\n+public:\n+  class Supplier {\n+  public:\n+    \/\/ Returns elements with already ordered keys.\n+    \/\/ This function should return true when the key and value was set,\n+    \/\/ and false when there's no more elements.\n+    \/\/ Packed table does NOT support duplicate keys.\n+    virtual bool next(uint32_t* key, uint32_t* value) = 0;\n+  };\n+\n+  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n+  \/\/ to the nearest power-of-two - 1.\n+  \/\/ See PackedTableBase constructor for details.\n+  PackedTableBuilder(uint32_t max_key, uint32_t max_value): PackedTableBase(max_key, max_value) {}\n+\n+  \/\/ Constructs a packed table in the provided array, filling it with elements\n+  \/\/ from the supplier. Note that no comparator is requied by this method -\n+  \/\/ the supplier must return elements with already ordered keys.\n+  \/\/ The table_length (in bytes) should match number of elements provided\n+  \/\/ by the supplier (when Supplier::next() returns false the whole array should\n+  \/\/ be filled).\n+  void fill(u1* table, size_t table_length, Supplier &supplier) const;\n+};\n+\n+\/\/ Helper class for lookup in a packed table.\n+class PackedTableLookup: public PackedTableBase {\n+  const u1* const _table;\n+  const size_t _table_length;\n+\n+  uint64_t read_element(size_t offset) const;\n+\n+public:\n+\n+  \/\/ The comparator implementation does not have to store a key (uint32_t);\n+  \/\/ the idea is that key can point into a different structure that hosts data\n+  \/\/ suitable for the actual comparison. That's why PackedTableLookup::search(...)\n+  \/\/ returns the key it found as well as the value.\n+  class Comparator {\n+  public:\n+    \/\/ Returns negative\/0\/positive if the target referred to by this comparator\n+    \/\/ is lower\/equal\/higher than the target referred to by the key.\n+    virtual int compare_to(uint32_t key) = 0;\n+    \/\/ Changes the target this comparator refers to.\n+    DEBUG_ONLY(virtual void reset(uint32_t key) = 0);\n+  };\n+\n+  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n+  \/\/ to the nearest power-of-two - 1.\n+  \/\/ See PackedTableBase constructor for details.\n+  PackedTableLookup(uint32_t max_key, uint32_t max_value, const u1 *table, size_t table_length):\n+    PackedTableBase(max_key, max_value), _table(table), _table_length(table_length) {}\n+\n+  PackedTableLookup(uint32_t max_key, uint32_t max_value, const Array<u1> *table):\n+    PackedTableLookup(max_key, max_value, table->data(), static_cast<size_t>(table->length())) {}\n+\n+  \/\/ Performs a binary search in the packed table, looking for an element with key\n+  \/\/ referring to a target equal according to the comparator.\n+  \/\/ When the element is found, found_key and found_value are updated from the element\n+  \/\/ and the function returns true.\n+  \/\/ When the element is not found, found_key and found_value are not changed and\n+  \/\/ the function returns false.\n+  bool search(Comparator& comparator, uint32_t* found_key, uint32_t* found_value) const;\n+\n+  \/\/ Asserts that elements in the packed table follow the order defined by the comparator.\n+  DEBUG_ONLY(void validate_order(Comparator &comparator) const);\n+\n+  template<typename Function>\n+  void iterate(Function func) const {\n+    for (size_t offset = 0; offset < _table_length; offset += _element_bytes) {\n+      uint64_t element = read_element(offset);\n+      uint32_t key = static_cast<uint32_t>(element) & _key_mask;\n+      uint32_t value = checked_cast<uint32_t>(element >> _value_shift) & _value_mask;\n+      func(offset, key, value);\n+    }\n+  }\n+};\n","filename":"src\/hotspot\/share\/utilities\/packedTable.hpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,1 @@\n-    int next_length() {\n+    int next_length() const {\n@@ -273,1 +273,1 @@\n-    bool has_next() {\n+    bool has_next() const {\n@@ -287,2 +287,3 @@\n-    OFF limit() { return _limit; }\n-    OFF position() { return _position; }\n+    OFF limit() const { return _limit; }\n+    OFF position() const { return _position; }\n+    void set_limit(OFF limit) { _limit = limit; }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1592,0 +1592,5 @@\n+     * @apiNote\n+     * To determine whether a string contains only\n+     * {@linkplain Character#isWhitespace(int) white space}, use\n+     * {@link #isBlank() isBlank}.\n+     *\n@@ -3830,3 +3835,7 @@\n-     * <p>\n-     * This method may be used to trim space (as defined above) from\n-     * the beginning and end of a string.\n+     *\n+     * @apiNote\n+     * This method removes leading and trailing space characters and ASCII control\n+     * characters from the string. To remove characters using a Unicode-based definition of\n+     * {@linkplain Character#isWhitespace(int) white space}, use {@link #strip() strip},\n+     * {@link #stripIndent() stripIndent}, {@link #stripLeading() stripLeading}, or\n+     * {@link #stripTrailing() stripTrailing}.\n@@ -3937,7 +3946,3 @@\n-     * Returns {@code true} if the string is empty or contains only\n-     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n-     * otherwise {@code false}.\n-     *\n-     * @return {@code true} if the string is empty or contains only\n-     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n-     *         otherwise {@code false}\n+     * {@return {@code true} if the string is {@linkplain #isEmpty empty} or contains\n+     * only {@linkplain Character#isWhitespace(int) white space} codepoints,\n+     * otherwise {@code false}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1123,3 +1123,1 @@\n-     * unspecified exceptions being thrown. Examples of such problematic operations are\n-     * {@link java.nio.channels.AsynchronousSocketChannel#read(ByteBuffer)} and\n-     * {@link java.nio.channels.AsynchronousSocketChannel#write(ByteBuffer)}.\n+     * unspecified exceptions being thrown.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1375,1 +1375,1 @@\n-     * {@code double} (or {@code float}) into a {@code BigDecimal}, as\n+     * {@code double} into a {@code BigDecimal}, as\n@@ -1379,0 +1379,5 @@\n+     * <p>\n+     * While a {@code float} argument {@code v} can be passed to this method,\n+     * the result often contains many more trailing digits than the precision\n+     * of a {@code float}.\n+     * Consider using {@code new BigDecimal(Float.toString(v))} instead.\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,24 +165,0 @@\n-    \/**\n-     * Set the TTL (time-to-live) option.\n-     * @param ttl a byte specifying the TTL value\n-     *\n-     * @deprecated use setTimeToLive instead.\n-     * @throws    IOException if an I\/O exception occurs while setting\n-     * the time-to-live option.\n-     * @see #getTTL()\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    protected abstract void setTTL(byte ttl) throws IOException;\n-\n-    \/**\n-     * Retrieve the TTL (time-to-live) option.\n-     *\n-     * @throws    IOException if an I\/O exception occurs\n-     * while retrieving the time-to-live option\n-     * @deprecated use getTimeToLive instead.\n-     * @return a byte representing the TTL value\n-     * @see #setTTL(byte)\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    protected abstract byte getTTL() throws IOException;\n-\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,20 +191,0 @@\n-    \/**\n-     * Set the default time-to-live for multicast packets sent out\n-     * on this {@code MulticastSocket} in order to control the\n-     * scope of the multicasts.\n-     *\n-     * <p>The ttl is an <b>unsigned<\/b> 8-bit quantity, and so <B>must<\/B> be\n-     * in the range {@code 0 <= ttl <= 0xFF }.\n-     *\n-     * @param      ttl the time-to-live\n-     * @throws     IOException if an I\/O exception occurs\n-     *             while setting the default time-to-live value, or the socket is closed.\n-     * @deprecated use the {@link #setTimeToLive(int)} method instead, which uses\n-     *             <b>int<\/b> instead of <b>byte<\/b> as the type for ttl.\n-     * @see #getTTL()\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    public void setTTL(byte ttl) throws IOException {\n-        delegate().setTTL(ttl);\n-    }\n-\n@@ -240,16 +220,0 @@\n-    \/**\n-     * Get the default time-to-live for multicast packets sent out on\n-     * the socket.\n-     *\n-     * @throws    IOException if an I\/O exception occurs\n-     *            while getting the default time-to-live value, or the socket is closed.\n-     * @return the default time-to-live value\n-     * @deprecated use the {@link #getTimeToLive()} method instead,\n-     * which returns an <b>int<\/b> instead of a <b>byte<\/b>.\n-     * @see #setTTL(byte)\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    public byte getTTL() throws IOException {\n-        return delegate().getTTL();\n-    }\n-\n@@ -469,43 +433,0 @@\n-\n-    \/**\n-     * Sends a datagram packet to the destination, with a TTL (time-to-live)\n-     * other than the default for the socket.  This method\n-     * need only be used in instances where a particular TTL is desired;\n-     * otherwise it is preferable to set a TTL once on the socket, and\n-     * use that default TTL for all packets.  This method does <B>not\n-     * <\/B> alter the default TTL for the socket. Its behavior may be\n-     * affected by {@code setInterface}.\n-     *\n-     * @param p is the packet to be sent. The packet should contain\n-     * the destination multicast ip address and the data to be sent.\n-     * One does not need to be the member of the group to send\n-     * packets to a destination multicast address.\n-     * @param ttl optional time to live for multicast packet.\n-     * default ttl is 1.\n-     *\n-     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n-     * @throws     PortUnreachableException may be thrown if the socket is connected\n-     *             to a currently unreachable destination. Note, there is no\n-     *             guarantee that the exception will be thrown.\n-     * @throws     IllegalArgumentException if the socket is connected,\n-     *             and connected address and packet address differ, or\n-     *             if the socket is not connected and the packet address\n-     *             is not set or if its port is out of range.\n-     *\n-     *\n-     * @deprecated Use the following code or its equivalent instead:\n-     *  <pre>{@code   ......\n-     *  int ttl = mcastSocket.getOption(StandardSocketOptions.IP_MULTICAST_TTL);\n-     *  mcastSocket.setOption(StandardSocketOptions.IP_MULTICAST_TTL, newttl);\n-     *  mcastSocket.send(p);\n-     *  mcastSocket.setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n-     *  ......}<\/pre>\n-     *\n-     * @see DatagramSocket#send\n-     * @see DatagramSocket#receive\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.4\")\n-    public void send(DatagramPacket p, byte ttl)\n-        throws IOException {\n-        delegate().send(p, ttl);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":1,"deletions":80,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,6 +570,0 @@\n-    \/**\n-     * The lock on the socket's TTL. This is for set\/getTTL and\n-     * send(packet,ttl).\n-     *\/\n-    private final Object ttlLock = new Object();\n-\n@@ -587,8 +581,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public void setTTL(byte ttl) throws IOException {\n-        if (isClosed())\n-            throw new SocketException(\"Socket is closed\");\n-        getImpl().setTTL(ttl);\n-    }\n-\n@@ -605,8 +591,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public byte getTTL() throws IOException {\n-        if (isClosed())\n-            throw new SocketException(\"Socket is closed\");\n-        return getImpl().getTTL();\n-    }\n-\n@@ -799,46 +777,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    @Override\n-    public void send(DatagramPacket p, byte ttl)\n-            throws IOException {\n-        if (isClosed())\n-            throw new SocketException(\"Socket is closed\");\n-        synchronized(ttlLock) {\n-            synchronized(p) {\n-                InetAddress packetAddress = p.getAddress();\n-                checkAddress(packetAddress, \"send\");\n-                if (connectState == ST_NOT_CONNECTED) {\n-                    if (packetAddress == null) {\n-                        throw new IllegalArgumentException(\"Address not set\");\n-                    }\n-                } else {\n-                    \/\/ we're connected\n-                    if (packetAddress == null) {\n-                        p.setAddress(connectedAddress);\n-                        p.setPort(connectedPort);\n-                    } else if ((!packetAddress.equals(connectedAddress)) ||\n-                            p.getPort() != connectedPort) {\n-                        throw new IllegalArgumentException(\"connected address and packet address\" +\n-                                \" differ\");\n-                    }\n-                }\n-                byte dttl = getTTL();\n-                try {\n-                    if (ttl != dttl) {\n-                        \/\/ set the ttl\n-                        getImpl().setTTL(ttl);\n-                    }\n-                    if (p.getPort() == 0) {\n-                        throw new SocketException(\"Can't send to port 0\");\n-                    }\n-                    \/\/ call the datagram method to send\n-                    getImpl().send(p);\n-                } finally {\n-                    \/\/ set it back to default\n-                    if (ttl != dttl) {\n-                        getImpl().setTTL(dttl);\n-                    }\n-                }\n-            } \/\/ synch p\n-        }  \/\/synch ttl\n-    } \/\/method\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetMulticastSocket.java","additions":1,"deletions":69,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -624,0 +624,7 @@\n+     * @apiNote Establishing a TCP\/IP connection is subject to connect timeout settings\n+     * in the operating system. The typical operating system timeout is in the range of tens of\n+     * seconds to minutes. If the operating system timeout expires before the\n+     * {@code timeout} specified to this method then an {@code IOException} is thrown.\n+     * The {@code timeout} specified to this method is typically a timeout value that is\n+     * shorter than the operating system timeout.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,0 +237,24 @@\n+\n+    \/\/ Maximum number of bytes to set in one call to {@code Unsafe.setMemory}.\n+    \/\/ This threshold allows safepoint polling during large memory operations.\n+    static final long UNSAFE_SET_THRESHOLD = 1024 * 1024;\n+\n+    \/**\n+     * Sets a block of memory starting from a given address to a specified byte value.\n+     *\n+     * @param srcAddr\n+     *        the starting memory address\n+     * @param count\n+     *        the number of bytes to set\n+     * @param value\n+     *        the byte value to set\n+     *\/\n+    static void setMemory(long srcAddr, long count, byte value) {\n+        long offset = 0;\n+        while (offset < count) {\n+            long len = Math.min(UNSAFE_SET_THRESHOLD, count - offset);\n+            UNSAFE.setMemory(srcAddr + offset, len, value);\n+            offset += len;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Bits.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-        UNSAFE.setMemory(base, size, (byte) 0);\n+        Bits.setMemory(base, size, (byte) 0);\n@@ -433,0 +433,6 @@\n+#end[rw]\n+\n+    public $Type$Buffer append(CharSequence csq, int start, int end) {\n+#if[rw]\n+        if (csq == null)\n+            return super.append(csq, start, end);\n@@ -434,1 +440,0 @@\n-    private $Type$Buffer appendChars(CharSequence csq, int start, int end) {\n@@ -451,7 +456,1 @@\n-            if (csq instanceof String str) {\n-                str.getChars(start, start + count, buf, 0);\n-            } else if (csq instanceof StringBuilder sb) {\n-                sb.getChars(start, start + count, buf, 0);\n-            } else if (csq instanceof StringBuffer sb) {\n-                sb.getChars(start, start + count, buf, 0);\n-            }\n+            csq.getChars(start, start + count, buf, 0);\n@@ -468,2 +467,0 @@\n-    }\n-#end[rw] \n@@ -471,6 +468,0 @@\n-    public $Type$Buffer append(CharSequence csq) {\n-#if[rw] \n-        if (csq instanceof StringBuilder) \n-            return appendChars(csq, 0, csq.length());\n- \n-        return super.append(csq);\n@@ -481,2 +472,2 @@\n- \n-    public $Type$Buffer append(CharSequence csq, int start, int end) { \n+\n+    public $Type$Buffer append(CharSequence csq) {\n@@ -484,3 +475,3 @@\n-        if (csq instanceof String || csq instanceof StringBuffer ||\n-            csq instanceof StringBuilder)\n-            return appendChars(csq, start, end);\n+        \/\/ See comment regarding StringBuilder on HeapBuffer.append.\n+        if (csq instanceof StringBuilder)\n+            return append(csq, 0, csq.length());\n@@ -488,1 +479,1 @@\n-        return super.append(csq, start, end);\n+        return super.append(csq);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,5 @@\n-    private $Type$Buffer appendChars(CharSequence csq, int start, int end) {\n+    public $Type$Buffer append(CharSequence csq, int start, int end) {\n+#if[rw]\n+        if (csq == null)\n+            return super.append(csq, start, end);\n+\n@@ -305,7 +309,1 @@\n-        if (csq instanceof String str) {\n-            str.getChars(start, end, hb, ix(pos));\n-        } else if (csq instanceof StringBuilder sb) {\n-            sb.getChars(start, end, hb, ix(pos));\n-        } else if (csq instanceof StringBuffer sb) {\n-            sb.getChars(start, end, hb, ix(pos));\n-        }\n+        csq.getChars(start, end, hb, ix(pos));\n@@ -316,8 +314,0 @@\n-    }\n-\n-    public $Type$Buffer append(CharSequence csq) {\n-#if[rw]\n-        if (csq instanceof StringBuilder)\n-            return appendChars(csq, 0, csq.length());\n-\n-        return super.append(csq);\n@@ -329,1 +319,1 @@\n-    public $Type$Buffer append(CharSequence csq, int start, int end) {\n+    public $Type$Buffer append(CharSequence csq) {\n@@ -331,3 +321,3 @@\n-        if (csq instanceof String || csq instanceof StringBuffer ||\n-            csq instanceof StringBuilder)\n-            return appendChars(csq, start, end);\n+        \/\/ See comment regarding StringBuilder on method append() above.\n+        if (csq instanceof StringBuilder)\n+            return append(csq, 0, csq.length());\n@@ -335,1 +325,1 @@\n-        return super.append(csq, start, end);\n+        return super.append(csq);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n@@ -100,1 +102,2 @@\n-     *          If the buffer is read-only\n+     *          If the buffer is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -131,1 +134,2 @@\n-     *          If the buffer is read-only\n+     *          If the buffer is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -180,0 +184,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If the buffer is a view of a {@link MemorySegment} allocated from a\n+     *          {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -208,0 +215,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If the buffer is a view of a {@link MemorySegment} allocated from a\n+     *          {@linkplain Arena#ofConfined() thread-confined arena}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/AsynchronousByteChannel.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n@@ -696,1 +698,3 @@\n-     *          If the position is negative or the buffer is read-only\n+     *          If the position is negative, or the buffer is read-only or a view of a\n+     *          {@link MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n@@ -731,1 +735,3 @@\n-     *          If the position is negative or the buffer is read-only\n+     *          If the position is negative, or the buffer is read-only or a view of a\n+     *          {@link MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n@@ -762,1 +768,3 @@\n-     *          If the position is negative\n+     *          If the position is negative or the buffer is a view of a {@link\n+     *          MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n@@ -798,1 +806,3 @@\n-     *          If the position is negative\n+     *          If the position is negative or the buffer is a view of a {@link\n+     *          MemorySegment} allocated from a {@linkplain Arena#ofConfined()\n+     *          thread-confined arena}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/AsynchronousFileChannel.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n@@ -382,1 +384,2 @@\n-     *          If the buffer is read-only\n+     *          If the buffer is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -491,1 +494,2 @@\n-     *          If the buffer is read-only\n+     *          If any of the buffers is read-only or a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -541,0 +545,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If the buffer is a view of a {@link MemorySegment} allocated from\n+     *          a {@linkplain Arena#ofConfined() thread-confined arena}\n@@ -555,0 +562,1 @@\n+     * @throws  IllegalArgumentException       {@inheritDoc}\n@@ -571,0 +579,1 @@\n+     * @throws  IllegalArgumentException    {@inheritDoc}\n@@ -641,0 +650,3 @@\n+     * @throws  IllegalArgumentException\n+     *          If any of the buffers is a view of a {@link MemorySegment}\n+     *          allocated from a {@linkplain Arena#ofConfined() thread-confined arena}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/AsynchronousSocketChannel.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-     * We avoid the need for auxilliary data structures by embedding\n+     * We avoid the need for auxiliary data structures by embedding\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-    private transient int count;\n+    private transient volatile int count;\n@@ -209,0 +209,2 @@\n+     *\n+     * @return true if the node was added; false otherwise\n@@ -212,1 +214,2 @@\n-        if (count >= capacity)\n+        int c;\n+        if ((c = count) >= capacity)\n@@ -221,1 +224,1 @@\n-        ++count;\n+        count = c + 1;\n@@ -228,0 +231,2 @@\n+     *\n+     * @return true if the node was added; false otherwise\n@@ -231,1 +236,2 @@\n-        if (count >= capacity)\n+        int c;\n+        if ((c = count) >= capacity)\n@@ -240,1 +246,1 @@\n-        ++count;\n+        count = c + 1;\n@@ -337,0 +343,2 @@\n+        if (count >= capacity)\n+            return false;\n@@ -352,0 +360,2 @@\n+        if (count >= capacity)\n+            return false;\n@@ -370,1 +380,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -387,1 +397,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -461,0 +471,1 @@\n+        if (count == 0) return null;\n@@ -471,0 +482,1 @@\n+        if (count == 0) return null;\n@@ -482,1 +494,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -495,1 +507,1 @@\n-        lock.lock();\n+        lock.lockInterruptibly();\n@@ -561,0 +573,1 @@\n+        if (count == 0) return null;\n@@ -571,0 +584,1 @@\n+        if (count == 0) return null;\n@@ -721,7 +735,1 @@\n-        final ReentrantLock lock = this.lock;\n-        lock.lock();\n-        try {\n-            return capacity - count;\n-        } finally {\n-            lock.unlock();\n-        }\n+        return capacity - count;\n@@ -809,7 +817,1 @@\n-        final ReentrantLock lock = this.lock;\n-        lock.lock();\n-        try {\n-            return count;\n-        } finally {\n-            lock.unlock();\n-        }\n+        return count;\n@@ -861,1 +863,1 @@\n-        int n = 0;\n+        long n = 0;\n@@ -881,1 +883,2 @@\n-            if (count + n <= capacity) {\n+            long cnt;\n+            if ((cnt = count + n) <= capacity) {\n@@ -888,1 +891,1 @@\n-                count += n;\n+                count = (int)cnt;\n@@ -897,0 +900,1 @@\n+        beg = end = null; \/\/ help GC\n@@ -997,2 +1001,2 @@\n-                f.prev = null;\n-                f.next = null;\n+                f.prev = f;\n+                f.next = f;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedBlockingDeque.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -322,0 +322,1 @@\n+        java.security.sasl,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -624,4 +624,4 @@\n-            String reqHost = requests.findValue(\"Host\");\n-            if (reqHost == null || !reqHost.equalsIgnoreCase(host)) {\n-                requests.set(\"Host\", host);\n-            }\n+            \/\/ if the \"Host\" header hasn't been explicitly set, then set its\n+            \/\/ value to the one determined through the request URL\n+            requests.setIfNotSet(\"Host\", host);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -43,0 +45,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -218,0 +222,4 @@\n+        if (dst.isReadOnly())\n+            throw new IllegalArgumentException(\"Read-only buffer\");\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -229,0 +237,4 @@\n+        if (dst.isReadOnly())\n+            throw new IllegalArgumentException(\"Read-only buffer\");\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -240,0 +252,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -251,0 +265,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousFileChannelImpl.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -53,0 +55,2 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n@@ -284,0 +288,2 @@\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -298,0 +304,2 @@\n+        if (NIO_ACCESS.isThreadConfined(dst))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -313,3 +321,3 @@\n-        ByteBuffer[] bufs = Util.subsequence(dsts, offset, length);\n-        for (int i=0; i<bufs.length; i++) {\n-            if (bufs[i].isReadOnly())\n+        dsts = Util.subsequence(dsts, offset, length);\n+        for (ByteBuffer dst : dsts) {\n+            if (dst.isReadOnly())\n@@ -317,0 +325,2 @@\n+            if (NIO_ACCESS.isThreadConfined(dst))\n+                throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -318,1 +328,1 @@\n-        read(true, null, bufs, timeout, unit, attachment, handler);\n+        read(true, null, dsts, timeout, unit, attachment, handler);\n@@ -387,0 +397,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -399,0 +411,2 @@\n+        if (NIO_ACCESS.isThreadConfined(src))\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n@@ -415,0 +429,5 @@\n+        for (ByteBuffer src : srcs) {\n+            if (NIO_ACCESS.isThreadConfined(src)) {\n+                throw new IllegalArgumentException(\"Buffer is thread confined\");\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -375,3 +374,0 @@\n-    \/\/ used to coordinate changing TTL with the deprecated send method\n-    private final ReentrantLock sendLock = new ReentrantLock();\n-\n@@ -383,6 +379,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public void setTTL(byte ttl) throws IOException {\n-        setTimeToLive(Byte.toUnsignedInt(ttl));\n-    }\n-\n@@ -391,12 +381,1 @@\n-        sendLock.lock();\n-        try {\n-            setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n-        } finally {\n-            sendLock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public byte getTTL() throws IOException {\n-        return (byte) getTimeToLive();\n+        setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n@@ -407,6 +386,1 @@\n-        sendLock.lock();\n-        try {\n-            return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);\n-        } finally {\n-            sendLock.unlock();\n-        }\n+        return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);\n@@ -561,17 +535,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public void send(DatagramPacket p, byte ttl) throws IOException {\n-        sendLock.lock();\n-        try {\n-            int oldValue = getTimeToLive();\n-            try {\n-                setTTL(ttl);\n-                send(p);\n-            } finally {\n-                setTimeToLive(oldValue);\n-            }\n-        } finally {\n-            sendLock.unlock();\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":2,"deletions":45,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-            throw new IllegalStateException(\"Confined session not supported\");\n+            throw new IllegalArgumentException(\"Buffer is thread confined\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,0 +330,2 @@\n+        IOUtil.acquireScope(dst, true);\n+\n@@ -352,0 +354,1 @@\n+                    IOUtil.releaseScope(dst);\n@@ -384,0 +387,2 @@\n+        IOUtil.acquireScope(src, true);\n+\n@@ -406,0 +411,1 @@\n+                    IOUtil.releaseScope(src);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SimpleAsynchronousFileChannelImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.charset.Charset;\n@@ -1476,1 +1477,1 @@\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n+        BufferedReader reader = stdinAwareReader(in);\n@@ -2831,1 +2832,1 @@\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n+        BufferedReader reader = stdinAwareReader(in);\n@@ -3536,2 +3537,1 @@\n-        return (new BufferedReader(new InputStreamReader(\n-                                        System.in))).readLine();\n+        return stdinAwareReader(System.in).readLine();\n@@ -3547,2 +3547,8 @@\n-        return (new BufferedReader(new InputStreamReader(\n-                                        System.in))).readLine();\n+        return stdinAwareReader(System.in).readLine();\n+    }\n+\n+    private static BufferedReader stdinAwareReader(InputStream in) {\n+        InputStreamReader reader = in == System.in\n+                ? new InputStreamReader(in, Charset.forName(System.getProperty(\"stdin.encoding\"), Charset.defaultCharset()))\n+                : new InputStreamReader(in);\n+        return new BufferedReader(reader);\n@@ -3735,1 +3741,1 @@\n-        in = new BufferedReader(new InputStreamReader(System.in));\n+        in = stdinAwareReader(System.in);\n@@ -4241,2 +4247,1 @@\n-            reply = (new BufferedReader(new InputStreamReader\n-                                        (System.in))).readLine();\n+            reply = stdinAwareReader(System.in).readLine();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.nio.charset.Charset;\n@@ -133,2 +134,3 @@\n-        String result = new BufferedReader\n-            (new InputStreamReader(System.in)).readLine();\n+        Charset charset = Charset.forName(System.getProperty(\"stdin.encoding\"), Charset.defaultCharset());\n+        InputStreamReader reader = new InputStreamReader(System.in, charset);\n+        String result = new BufferedReader(reader).readLine();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ConsoleCallbackHandler.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1015,0 +1015,1 @@\n+    disallowAlg http:\/\/www.w3.org\/TR\/1999\/REC-xpath-19991116,\\\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1452,3 +1452,4 @@\n-        (JVM) shuts down. This option is not available if the disk option is set\n-        to false. For a list of available views, see `jfr help view`. By default,\n-        no report is generated.\n+        (JVM) shuts down. To specify more than one view, use the report-on-exit\n+        parameter repeatedly. This option is not available if the disk option\n+        is set to false. For a list of available views, see `jfr help view`.\n+        By default, no report is generated.\n","filename":"src\/java.base\/share\/man\/java.md","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,0 +152,13 @@\n+static char *computeToken(JLI_List *parts, const char *anchor, const char *nextc) {\n+    char *token;\n+    if ((*parts)->size == 0) {\n+        token = clone_substring(anchor, nextc - anchor);\n+    } else {\n+        JLI_List_addSubstring(*parts, anchor, nextc - anchor);\n+        token = JLI_List_combine(*parts);\n+        JLI_List_free(*parts);\n+        *parts = JLI_List_new(4);\n+    }\n+    return token;\n+}\n+\n@@ -249,8 +262,1 @@\n-                if (pctx->parts->size == 0) {\n-                    token = clone_substring(anchor, nextc - anchor);\n-                } else {\n-                    JLI_List_addSubstring(pctx->parts, anchor, nextc - anchor);\n-                    token = JLI_List_combine(pctx->parts);\n-                    JLI_List_free(pctx->parts);\n-                    pctx->parts = JLI_List_new(4);\n-                }\n+                token = computeToken(&pctx->parts, anchor, nextc);\n@@ -265,0 +271,7 @@\n+                \/\/ return non-zero length token, terminated by the number sign\n+                if (nextc - anchor > 0) {\n+                    token = computeToken(&pctx->parts, anchor, nextc);\n+                    pctx->cptr = nextc + 1;\n+                    return token;\n+                }\n+                \/\/ anchor after number sign\n","filename":"src\/java.base\/share\/native\/libjli\/args.c","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -55,0 +55,15 @@\n+int\n+markCloseOnExec(int fd)\n+{\n+    const int flags = fcntl(fd, F_GETFD);\n+    if (flags < 0) {\n+        return -1;\n+    }\n+    if ((flags & FD_CLOEXEC) == 0) {\n+        if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {\n+            return -1;\n+        }\n+    }\n+    return 0;\n+}\n+\n@@ -71,1 +86,1 @@\n-closeDescriptors(void)\n+markDescriptorsCloseOnExec(void)\n@@ -75,11 +90,5 @@\n-    int from_fd = FAIL_FILENO + 1;\n-\n-    \/* We're trying to close all file descriptors, but opendir() might\n-     * itself be implemented using a file descriptor, and we certainly\n-     * don't want to close that while it's in use.  We assume that if\n-     * opendir() is implemented using a file descriptor, then it uses\n-     * the lowest numbered file descriptor, just like open().  So we\n-     * close a couple explicitly.  *\/\n-\n-    close(from_fd);          \/* for possible use by opendir() *\/\n-    close(from_fd + 1);      \/* another one for good luck *\/\n+    \/* This function marks all file descriptors beyond stderr as CLOEXEC.\n+     * That includes the file descriptor used for the fail pipe: we want that\n+     * one to stay open up until the execve, but it should be closed with the\n+     * execve. *\/\n+    const int fd_from = STDERR_FILENO + 1;\n@@ -94,1 +103,1 @@\n-        return 0;\n+        return -1;\n@@ -99,2 +108,6 @@\n-            (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd + 2)\n-            close(fd);\n+            (fd = strtol(dirp->d_name, NULL, 10)) >= fd_from) {\n+            if (markCloseOnExec(fd) == -1) {\n+                closedir(dp);\n+                return -1;\n+            }\n+        }\n@@ -105,1 +118,1 @@\n-    return 1;\n+    return 0;\n@@ -397,1 +410,1 @@\n-    if (closeDescriptors() == 0) { \/* failed,  close the old way *\/\n+    if (markDescriptorsCloseOnExec() == -1) { \/* failed,  close the old way *\/\n@@ -400,2 +413,2 @@\n-        for (fd = FAIL_FILENO + 1; fd < max_fd; fd++)\n-            if (close(fd) == -1 && errno != EBADF)\n+        for (fd = STDERR_FILENO + 1; fd < max_fd; fd++)\n+            if (markCloseOnExec(fd) == -1 && errno != EBADF)\n@@ -416,3 +429,0 @@\n-    if (fcntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == -1)\n-        goto WhyCantJohnnyExec;\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -413,2 +413,4 @@\n-        void releaseBufferIfSubstituted() {\n-            if (buf != dst && RELEASED.compareAndSet(this, false, true)) {\n+        void releaseScopeOrCacheSubstitute() {\n+            if (buf == dst) {\n+                IOUtil.releaseScope(dst);\n+            } else if (RELEASED.compareAndSet(this, false, true)) {\n@@ -447,1 +449,1 @@\n-            if (dst instanceof DirectBuffer) {\n+            if (dst.isDirect()) {\n@@ -449,1 +451,2 @@\n-                address = ((DirectBuffer)dst).address() + pos;\n+                IOUtil.acquireScope(dst, true);\n+                address = IOUtil.bufferAddress(dst) + pos;\n@@ -452,1 +455,1 @@\n-                address = ((DirectBuffer)buf).address();\n+                address = IOUtil.bufferAddress(buf) + pos;\n@@ -482,1 +485,1 @@\n-                    releaseBufferIfSubstituted();\n+                    releaseScopeOrCacheSubstitute();\n@@ -497,2 +500,2 @@\n-            \/\/ return direct buffer to cache if substituted\n-            releaseBufferIfSubstituted();\n+            \/\/ release direct buffer scope or return substitute to cache\n+            releaseScopeOrCacheSubstitute();\n@@ -515,2 +518,2 @@\n-                \/\/ return direct buffer to cache if substituted\n-                releaseBufferIfSubstituted();\n+                \/\/ release direct buffer scope or return substitute to cache\n+                releaseScopeOrCacheSubstitute();\n@@ -603,2 +606,4 @@\n-        void releaseBufferIfSubstituted() {\n-            if (buf != src && RELEASED.compareAndSet(this, false, true)) {\n+        void releaseScopeOrCacheSubstitute() {\n+            if (buf == src) {\n+                IOUtil.releaseScope(src);\n+            } else if (RELEASED.compareAndSet(this, false, true)) {\n@@ -627,1 +632,1 @@\n-            if (src instanceof DirectBuffer) {\n+            if (src.isDirect()) {\n@@ -629,1 +634,2 @@\n-                address = ((DirectBuffer)src).address() + pos;\n+                IOUtil.acquireScope(src, true);\n+                address = IOUtil.bufferAddress(src) + pos;\n@@ -637,1 +643,1 @@\n-                address = ((DirectBuffer)buf).address();\n+                address = IOUtil.bufferAddress(buf) + pos;\n@@ -660,1 +666,1 @@\n-                releaseBufferIfSubstituted();\n+                releaseScopeOrCacheSubstitute();\n@@ -679,2 +685,2 @@\n-            \/\/ return direct buffer to cache if substituted\n-            releaseBufferIfSubstituted();\n+            \/\/ release direct buffer scope or return substitute to cache\n+            releaseScopeOrCacheSubstitute();\n@@ -693,2 +699,2 @@\n-            \/\/ return direct buffer to cache if substituted\n-            releaseBufferIfSubstituted();\n+            \/\/ release direct buffer scope or return substitute to cache\n+            releaseScopeOrCacheSubstitute();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousFileChannelImpl.java","additions":27,"deletions":21,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1123,0 +1123,3 @@\n+\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n@@ -1140,0 +1143,3 @@\n+\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKFileChooserUI.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,3 +121,0 @@\n-         } else {\n-             System.out.println(\"Unexpected condition in registerKeyStroke\");\n-             Thread.dumpStack();\n@@ -211,5 +208,0 @@\n-         if (e.isConsumed()) {\n-              System.out.println(\"Acquired pre-used event!\");\n-              Thread.dumpStack();\n-         }\n-\n@@ -269,4 +261,0 @@\n-             } else  {\n-                 System.out.println( \"Unexpected condition in fireKeyboardAction \" + tmp);\n-                 \/\/ This means that tmp wasn't null, a JComponent, or a Vector.  What is it?\n-                 Thread.dumpStack();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/KeyboardManager.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,19 +94,0 @@\n-\n-    \/**\n-     * Create the action map for Password Field.  This map provides\n-     * same actions for double mouse click and\n-     * and for triple mouse click (see bug 4231444).\n-     *\/\n-\n-    ActionMap createActionMap() {\n-        ActionMap map = super.createActionMap();\n-        if (map.get(DefaultEditorKit.selectWordAction) != null) {\n-            Action a = map.get(DefaultEditorKit.selectLineAction);\n-            if (a != null) {\n-                map.remove(DefaultEditorKit.selectWordAction);\n-                map.put(DefaultEditorKit.selectWordAction, a);\n-            }\n-        }\n-        return map;\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicPasswordFieldUI.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -650,0 +650,16 @@\n+\n+        if (getComponent() instanceof JPasswordField) {\n+            \/\/ Edit the action map for Password Field.  This map provides\n+            \/\/ same actions for double mouse click and\n+            \/\/ and for triple mouse click (see bugs 4231444, 8354646).\n+\n+            if (map.get(DefaultEditorKit.selectWordAction) != null) {\n+                map.remove(DefaultEditorKit.selectWordAction);\n+\n+                Action a = map.get(DefaultEditorKit.selectLineAction);\n+                if (a != null) {\n+                    map.put(DefaultEditorKit.selectWordAction, a);\n+                }\n+            }\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTextUI.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,15 +111,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    protected void installKeyboardActions() {\n-        super.installKeyboardActions();\n-        ActionMap map = SwingUtilities.getUIActionMap(getComponent());\n-        if (map != null && map.get(DefaultEditorKit.selectWordAction) != null) {\n-            Action a = map.get(DefaultEditorKit.selectLineAction);\n-            if (a != null) {\n-                map.put(DefaultEditorKit.selectWordAction, a);\n-            }\n-        }\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthPasswordFieldUI.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -361,2 +361,1 @@\n-                if (peerMap.get(target) == peer) {\n-                    peerMap.remove(target);\n+                if (peerMap.remove(target, peer)) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AWTAutoShutdown.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.io.Serial;\n+\n@@ -43,0 +45,2 @@\n+\n+    @Serial\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/IllegalClassFormatException.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.io.Serial;\n+\n@@ -37,0 +39,2 @@\n+\n+    @Serial\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/UnmodifiableClassException.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.io.Serial;\n+\n@@ -34,1 +36,0 @@\n-\n@@ -36,0 +37,2 @@\n+\n+    @Serial\n","filename":"src\/java.instrument\/share\/classes\/java\/lang\/instrument\/UnmodifiableModuleException.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -346,24 +346,0 @@\n-    \/**\n-     * Compares this descriptor to the given object.  The objects are equal if\n-     * the given object is also a Descriptor, and if the two Descriptors have\n-     * the same field names (possibly differing in case) and the same\n-     * associated values.  The respective values for a field in the two\n-     * Descriptors are equal if the following conditions hold:\n-     *\n-     * <ul>\n-     * <li>If one value is null then the other must be too.<\/li>\n-     * <li>If one value is a primitive array then the other must be a primitive\n-     * array of the same type with the same elements.<\/li>\n-     * <li>If one value is an object array then the other must be too and\n-     * {@link Arrays#deepEquals(Object[],Object[])} must return true.<\/li>\n-     * <li>Otherwise {@link Object#equals(Object)} must return true.<\/li>\n-     * <\/ul>\n-     *\n-     * @param o the object to compare with.\n-     *\n-     * @return {@code true} if the objects are the same; {@code false}\n-     * otherwise.\n-     *\n-     *\/\n-    \/\/ Note: this Javadoc is copied from javax.management.Descriptor\n-    \/\/       due to 6369229.\n@@ -397,22 +373,0 @@\n-    \/**\n-     * <p>Returns the hash code value for this descriptor.  The hash\n-     * code is computed as the sum of the hash codes for each field in\n-     * the descriptor.  The hash code of a field with name {@code n}\n-     * and value {@code v} is {@code n.toLowerCase().hashCode() ^ h}.\n-     * Here {@code h} is the hash code of {@code v}, computed as\n-     * follows:<\/p>\n-     *\n-     * <ul>\n-     * <li>If {@code v} is null then {@code h} is 0.<\/li>\n-     * <li>If {@code v} is a primitive array then {@code h} is computed using\n-     * the appropriate overloading of {@code java.util.Arrays.hashCode}.<\/li>\n-     * <li>If {@code v} is an object array then {@code h} is computed using\n-     * {@link Arrays#deepHashCode(Object[])}.<\/li>\n-     * <li>Otherwise {@code h} is {@code v.hashCode()}.<\/li>\n-     * <\/ul>\n-     *\n-     * @return A hash code value for this object.\n-     *\n-     *\/\n-    \/\/ Note: this Javadoc is copied from javax.management.Descriptor\n-    \/\/       due to 6369229.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ImmutableDescriptor.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -699,25 +699,0 @@\n-    \/**\n-     * Compares this descriptor to the given object.  The objects are equal if\n-     * the given object is also a Descriptor, and if the two Descriptors have\n-     * the same field names (possibly differing in case) and the same\n-     * associated values.  The respective values for a field in the two\n-     * Descriptors are equal if the following conditions hold:\n-     *\n-     * <ul>\n-     * <li>If one value is null then the other must be too.<\/li>\n-     * <li>If one value is a primitive array then the other must be a primitive\n-     * array of the same type with the same elements.<\/li>\n-     * <li>If one value is an object array then the other must be too and\n-     * {@link java.util.Arrays#deepEquals(Object[],Object[]) Arrays.deepEquals}\n-     * must return true.<\/li>\n-     * <li>Otherwise {@link Object#equals(Object)} must return true.<\/li>\n-     * <\/ul>\n-     *\n-     * @param o the object to compare with.\n-     *\n-     * @return {@code true} if the objects are the same; {@code false}\n-     * otherwise.\n-     *\n-     *\/\n-    \/\/ Note: this Javadoc is copied from javax.management.Descriptor\n-    \/\/       due to 6369229.\n@@ -735,22 +710,0 @@\n-    \/**\n-     * <p>Returns the hash code value for this descriptor.  The hash\n-     * code is computed as the sum of the hash codes for each field in\n-     * the descriptor.  The hash code of a field with name {@code n}\n-     * and value {@code v} is {@code n.toLowerCase().hashCode() ^ h}.\n-     * Here {@code h} is the hash code of {@code v}, computed as\n-     * follows:<\/p>\n-     *\n-     * <ul>\n-     * <li>If {@code v} is null then {@code h} is 0.<\/li>\n-     * <li>If {@code v} is a primitive array then {@code h} is computed using\n-     * the appropriate overloading of {@code java.util.Arrays.hashCode}.<\/li>\n-     * <li>If {@code v} is an object array then {@code h} is computed using\n-     * {@link java.util.Arrays#deepHashCode(Object[]) Arrays.deepHashCode}.<\/li>\n-     * <li>Otherwise {@code h} is {@code v.hashCode()}.<\/li>\n-     * <\/ul>\n-     *\n-     * @return A hash code value for this object.\n-     *\n-     *\/\n-    \/\/ Note: this Javadoc is copied from javax.management.Descriptor\n-    \/\/       due to 6369229.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/DescriptorSupport.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-     *         is in the set of observed MBeans, or <code>null<\/code> otherwise.\n+     *         is in the set of observed MBeans, or <code>0<\/code> otherwise.\n","filename":"src\/java.management\/share\/classes\/javax\/management\/monitor\/CounterMonitorMBean.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,2 +136,1 @@\n-     * stubs.  However, the connectors specified by the JMX Remote API do\n-     * (JMXMP Connector and RMI Connector).<\/p>\n+     * stubs.  The RMI Connector does so.<\/p>\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnectorServer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -189,2 +189,1 @@\n-     * stubs.  However, the connectors specified by the JMX Remote API do\n-     * (JMXMP Connector and RMI Connector).<\/p>\n+     * stubs.  The RMI Connector does so.<\/p>\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnectorServerMBean.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -241,2 +241,2 @@\n-     * @param protocol the protocol part of the URL.  If null, defaults\n-     * to <code>jmxmp<\/code>.\n+     * @param protocol the protocol part of the URL.  Must be specified,\n+     * there is no default.\n@@ -258,1 +258,1 @@\n-     * <code>port<\/code> is negative.\n+     * <code>port<\/code> is negative, or if protocol is null.\n@@ -268,2 +268,2 @@\n-     * @param protocol the protocol part of the URL.  If null, defaults\n-     * to <code>jmxmp<\/code>.\n+     * @param protocol the protocol part of the URL.  Must be specified,\n+     * there is no default.\n@@ -288,1 +288,1 @@\n-     * <code>port<\/code> is negative.\n+     * <code>port<\/code> is negative, or if protocol is null.\n@@ -293,3 +293,3 @@\n-        if (protocol == null)\n-            protocol = \"jmxmp\";\n-\n+        if (protocol == null) {\n+            throw new MalformedURLException(\"Misssing protocol name\");\n+        }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXServiceURL.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,1 @@\n- * MBean server manageable remotely. The specification of this\n- * functionality is completed by Part III of the\n- * <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- * JMX Specification, version 1.4<\/a><\/p>\n+ * MBean server manageable remotely.<\/p>\n@@ -35,1 +32,1 @@\n- * <p>The JMX specification defines the notion of <b>connectors<\/b>.\n+ * <p>JMX defines the notion of <b>connectors<\/b>.\n@@ -44,2 +41,1 @@\n- * a given protocol. The JMX Remote API allows the use of different\n- * type of connectors:\n+ * a given protocol.\n@@ -47,1 +43,1 @@\n- *       <ul>\n+ *      <ul>\n@@ -50,1 +46,1 @@\n- *         MBeanServer through RMI.\n+ *     MBeanServer through RMI.\n@@ -52,6 +48,1 @@\n- *        <li>The JMX Remote API also defines an optional connector called\n- *         <b>JMXMP Connector<\/b> implementing the JMX Message Protocol\n- *     (JMXMP). As it is optional, it is not part of this bundle (see\n- *     note below).\n- *\n- *        <li>User-defined connector protocols are also possible using the\n+ *        <li>Other connector protocols are also possible using the\n@@ -59,11 +50,2 @@\n- *     JMXConnectorFactory} and, optionally, the Generic Connector\n- *     (not part of this bundle, see note below).\n- *       <\/ul>\n- *\n- *       <p><u>Note<\/u>: the optional packages implementing\n- *         the optional part of the <em>JMX Remote API<\/em>\n- *         are not included in the <em>Java SE Platform<\/em>\n- *         but are available from the <em>JMX Remote API\n- *     <a href=\"https:\/\/www.oracle.com\/technetwork\/java\/javasebusiness\/downloads\/java-archive-downloads-java-plat-419418.html\">\n- *     Reference Implementation<\/a><\/em>.<\/p>\n- *\n+ *     JMXConnectorFactory}.\n+ *     <\/ul>\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/package-info.java","additions":9,"deletions":27,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.FileInputStream;\n@@ -38,0 +37,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -51,1 +51,0 @@\n-import java.util.function.Function;\n@@ -231,1 +230,0 @@\n-        private final Function<Path, InputStream> inputStreamSupplier;\n@@ -238,1 +236,0 @@\n-            boolean defaultFS = true;\n@@ -240,8 +237,0 @@\n-            try {\n-                path.toFile().getPath();\n-            } catch (UnsupportedOperationException uoe) {\n-                \/\/ path not associated with the default file system provider\n-                defaultFS = false;\n-            }\n-\n-            \/\/ existence check must be after FS checks\n@@ -251,4 +240,0 @@\n-            boolean finalDefaultFS = defaultFS;\n-            Function<Path, InputStream> inputStreamSupplier = (p) ->\n-                    createInputStream(p, finalDefaultFS);\n-\n@@ -262,1 +247,1 @@\n-            return new FilePublisher(path, length, inputStreamSupplier);\n+            return new FilePublisher(path, length);\n@@ -265,14 +250,1 @@\n-        private static InputStream createInputStream(Path path,\n-                                                     boolean defaultFS) {\n-            try {\n-                return defaultFS\n-                            ? new FileInputStream(path.toFile())\n-                            : Files.newInputStream(path);\n-            } catch (IOException io) {\n-                throw new UncheckedIOException(io);\n-            }\n-        }\n-\n-        private FilePublisher(Path name,\n-                              long length,\n-                              Function<Path, InputStream> inputStreamSupplier) {\n+        private FilePublisher(Path name, long length) {\n@@ -281,1 +253,0 @@\n-            this.inputStreamSupplier = inputStreamSupplier;\n@@ -289,1 +260,8 @@\n-                is = inputStreamSupplier.apply(path);\n+                \/\/ Throw `FileNotFoundException` to match the specification of `BodyPublishers::ofFile\n+                if (!Files.isRegularFile(path)) {\n+                    throw new FileNotFoundException(path + \" (Not a regular file)\");\n+                }\n+                is = Files.newInputStream(path);\n+            } catch (NoSuchFileException nsfe) {\n+                \/\/ Throw `FileNotFoundException` to match the specification of `BodyPublishers::ofFile`\n+                t = new FileNotFoundException(path + \" (No such file or directory)\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":11,"deletions":33,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -159,1 +159,2 @@\n- * authentication.\n+ * authentication. The number of authentication attempts is always one greater than the\n+ * retry limit, as the initial request does not count toward the retries.\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.charset.Charset;\n@@ -258,2 +259,2 @@\n-            BufferedReader in = new BufferedReader\n-                    (new InputStreamReader(getIn()));\n+            Charset charset = Charset.forName(System.getProperty(\"stdin.encoding\"), Charset.defaultCharset());\n+            BufferedReader in = new BufferedReader(new InputStreamReader(System.in, charset));\n@@ -405,5 +406,0 @@\n-    \/\/ input stream from where we will read\n-    private static InputStream getIn() {\n-        return System.in;\n-    }\n-\n","filename":"src\/java.scripting\/share\/classes\/com\/sun\/tools\/script\/shell\/Main.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.charset.Charset;\n@@ -89,1 +90,1 @@\n-        this(new InputStreamReader(System.in),\n+        this(stdinReader(),\n@@ -96,0 +97,5 @@\n+    private static InputStreamReader stdinReader() {\n+        Charset charset = Charset.forName(System.getProperty(\"stdin.encoding\"), Charset.defaultCharset());\n+        return new InputStreamReader(System.in, charset);\n+    }\n+\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/SimpleScriptContext.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n@@ -307,2 +309,1 @@\n-                BufferedReader cis =\n-                    new BufferedReader(new InputStreamReader(System.in));\n+                BufferedReader cis = stdinReader();\n@@ -406,0 +407,6 @@\n+    private static BufferedReader stdinReader() {\n+        Charset charset = Charset.forName(System.getProperty(\"stdin.encoding\"), Charset.defaultCharset());\n+        Reader reader = new InputStreamReader(System.in, charset);\n+        return new BufferedReader(reader);\n+    }\n+\n@@ -415,2 +422,1 @@\n-                BufferedReader cis =\n-                    new BufferedReader(new InputStreamReader(System.in));\n+                BufferedReader cis = stdinReader();\n","filename":"src\/java.security.jgss\/windows\/classes\/sun\/security\/krb5\/internal\/tools\/Ktab.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.security.jca.JCAUtil;\n+\n@@ -30,0 +32,1 @@\n+import java.security.SecureRandom;\n@@ -32,1 +35,0 @@\n-import java.util.Random;\n@@ -55,0 +57,4 @@\n+\n+    \/* SecureRandom instance to generate random digits used in challenge *\/\n+    private static final SecureRandom SECURE_RANDOM = JCAUtil.getDefSecureRandom();\n+\n@@ -116,2 +122,1 @@\n-                Random random = new Random();\n-                long rand = random.nextLong();\n+                long rand = SECURE_RANDOM.nextLong();\n","filename":"src\/java.security.sasl\/share\/classes\/com\/sun\/security\/sasl\/CramMD5Server.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.Random;\n@@ -40,0 +39,1 @@\n+import java.security.SecureRandom;\n@@ -62,0 +62,1 @@\n+import sun.security.jca.JCAUtil;\n@@ -135,0 +136,3 @@\n+    \/* SecureRandom instance to generate nonce *\/\n+    private static final SecureRandom SECURE_RANDOM = JCAUtil.getDefSecureRandom();\n+\n@@ -272,1 +276,0 @@\n-     * Could use SecureRandom to be more secure but it is very slow.\n@@ -296,2 +299,0 @@\n-        \/\/ SecureRandom random = new SecureRandom();\n-        Random random = new Random();\n@@ -299,1 +300,1 @@\n-        random.nextBytes(randomData);\n+        SECURE_RANDOM.nextBytes(randomData);\n","filename":"src\/java.security.sasl\/share\/classes\/com\/sun\/security\/sasl\/digest\/DigestMD5Base.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.nio.charset.Charset;\n@@ -799,2 +800,2 @@\n-            BufferedReader in =\n-                    new BufferedReader(new InputStreamReader(System.in));\n+            Charset charset = Charset.forName(System.getProperty(\"stdin.encoding\"), Charset.defaultCharset());\n+            BufferedReader in = new BufferedReader(new InputStreamReader(System.in, charset));\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTY.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-     * @return the data amount unit, default {@code BYTES}, not {@code null}\n+     * @return the data amount unit, default {@code BYTES}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/DataAmount.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-     * @return a description, not {@code null}\n+     * @return a description\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Description.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-     * @return a human-readable name, not {@code null}\n+     * @return a human-readable name\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Label.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-     * @return the default setting value, not {@code null}\n+     * @return the default setting value, default {@code \"everyChunk\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Period.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-     * @return the threshold, default {@code \"0 ns\"}, not {@code null}\n+     * @return the threshold, default {@code \"0 ns\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Threshold.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-     * @return the throttle value, default {@code \"off\"} not {@code null}\n+     * @return the throttle value, default {@code \"off\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Throttle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-     * @return the time span unit, default {@link #NANOSECONDS}, not {@code null}\n+     * @return the time span unit, default {@code NANOSECONDS}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Timespan.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-     * @return time stamp unit, not {@code null}\n+     * @return time stamp unit, default {@code MILLISECONDS_SINCE_EPOCH}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Timestamp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -505,3 +505,5 @@\n-                           Machine (JVM) shuts down. This option is not available if the\n-                           disk option is set to false. For a list of available views,\n-                           see 'jfr help view'. By default, no report is generated.\n+                           Machine (JVM) shuts down. To specify more than one view, use\n+                           the `report-on-exit` parameter repeatedly, for each view. This\n+                           option is not available if the disk option is set to false.\n+                           For a list of available views, see `jfr help view`. By default,\n+                           no report is generated.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,0 +110,7 @@\n+    final String getContentOrEmptyQuote() {\n+        if (content == null || content.isEmpty()) {\n+            return \"\\\"\\\"\";\n+        }\n+        return content;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/model\/XmlElement.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.jfr.internal.tracing.Filter;\n+\n@@ -38,1 +40,1 @@\n-        String content = getContent();\n+        String content = getContentOrEmptyQuote();\n@@ -60,1 +62,1 @@\n-        ui.println(getLabel() + \": \" + getContent() + \"  (default)\");\n+        ui.println(getLabel() + \": \" + getContentOrEmptyQuote() + \"  (default)\");\n@@ -74,1 +76,1 @@\n-            ui.println(\"Using default: \" + getContent());\n+            ui.println(\"Using default: \" + getContentOrEmptyQuote());\n@@ -77,0 +79,12 @@\n+        if (isMethodFilter()) {\n+            if (!Filter.isValid(line)) {\n+                ui.println(\"\"\"\n+                Not a valid method filter. A filter can be an annotation \\\n+                (@jakarta.ws.rs.GET), a full qualified class name (com.example.Foo), \\\n+                a fully qualified method reference (java.lang.HashMap::resize) or a \\\n+                class initializer (::<clinit>). Use <init> for constructors. \\\n+                Separate multiple filters with semicolon.\\\n+                \"\"\");\n+                return false;\n+            }\n+        }\n@@ -93,0 +107,4 @@\n+\n+    private boolean isMethodFilter() {\n+        return getContentType().orElse(\"text\").equals(\"method-filter\");\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/model\/XmlText.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -474,2 +474,2 @@\n-table = \"COLUMN 'Timed Method', 'Invocations', 'Min. Tim', 'Max. Time', 'Average Time'\n-         FORMAT none, none, ms-precision:6\n+table = \"COLUMN 'Timed Method', 'Invocations', 'Min. Time', 'Max. Time', 'Average Time'\n+         FORMAT none, none, ms-precision:6, ms-precision:6, ms-precision:6\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.tracing.Filter;\n@@ -50,0 +51,1 @@\n+    @Override\n@@ -51,1 +53,1 @@\n-        return PlatformTracer.isValidFilter(text);\n+        return Filter.isValid(text);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/MethodSetting.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Set;\n+\n@@ -32,1 +34,1 @@\n-        \/\/ Used by EventWriter\n+        \/\/ Used by EventWriter, directly or indirectly.\n@@ -34,1 +36,3 @@\n-        \"jdk\/internal\/misc\/Unsafe;\",\n+        \"jdk\/internal\/misc\/Unsafe\",\n+        \"java\/lang\/StringLatin1\",\n+        \"java\/lang\/StringUTF16\",\n@@ -41,1 +45,2 @@\n-        \"jdk\/internal\/\", \/\/ jdk\/internal\/classfile, jdk\/internal\/loader and jdk\/internal\/foreign\n+        \/\/ Also to avoid recursion with EventWriter::putString\n+        \"jdk\/internal\/\", \/\/ jdk\/internal\/classfile, \/\/ jdk\/internal\/vm, jdk\/internal\/util, jdk\/internal\/loader and jdk\/internal\/foreign\n@@ -45,1 +50,1 @@\n-    private static final String[] EXCLUDED_METHODS = {\n+    private static final Set<String> EXCLUDED_METHODS = Set.of(\n@@ -49,2 +54,10 @@\n-        \"java.lang.Number::<init>\"\n-    };\n+        \"java.lang.Number::<init>\",\n+        \/\/ Used by EventWriter::putString, directly or indirectly.\n+        \"java.lang.String::charAt\",\n+        \"java.lang.String::length\",\n+        \"java.lang.String::coder\", \/\/ Used by charAt(int)\n+        \"java.lang.String::checkIndex\", \/\/ Used by charAt(int)\n+        \"java.lang.String::isLatin1\", \/\/ Used by charAt()\n+        \"java.lang.String::equals\", \/\/ Used by StringPool\n+        \"java.lang.String::hashCode\" \/\/ Used by StringPool\n+    );\n@@ -53,6 +66,1 @@\n-        for (String method : EXCLUDED_METHODS) {\n-            if (method.equals(methodName)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        return EXCLUDED_METHODS.contains(methodName);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/ExcludeList.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -33,1 +33,5 @@\n-record Filter(String className, String methodName, String annotationName, Modification modification) {\n+public record Filter(String className, String methodName, String annotationName, Modification modification) {\n+\n+    public static boolean isValid(String filter) {\n+        return of(filter, Modification.NONE) != null;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Filter.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,4 +161,0 @@\n-    public static boolean isValidFilter(String text) {\n-        return Filter.of(text, null) != null;\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/PlatformTracer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1192,1 +1192,2 @@\n-      <text name=\"method-timing\" label=\"Method Timing\" contentType=\"text\"><\/text>\n+      <text name=\"method-timing\" label=\"Method Timing Filter\" contentType=\"method-filter\"\n+            description=\"A filter can be an annotation (@jakarta.ws.rs.GET), a full qualified class name (com.example.Foo), a fully qualified method reference (java.lang.HashMap::resize) or a class initializer (::&lt;clinit&gt;). Use &lt;init&gt; for constructors. Separate multiple filters with semicolon.\"><\/text>\n@@ -1194,1 +1195,2 @@\n-      <text name=\"method-trace\" label=\"Method Trace\" contentType=\"text\"><\/text>\n+      <text name=\"method-trace\" label=\"Method Trace Filter\" contentType=\"method-filter\"\n+            description=\"A filter can be an annotation (@jakarta.ws.rs.GET), a full qualified class name (com.example.Foo), a fully qualified method reference (java.lang.HashMap::resize) or a class initializer (::&lt;clinit&gt;). Use &lt;init&gt; for constructors. Separate multiple filters with semicolon.\"><\/text>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1191,1 +1191,2 @@\n-      <text name=\"method-timing\" label=\"Method Timing\" contentType=\"text\"><\/text>\n+      <text name=\"method-timing\" label=\"Method Timing Filter\" contentType=\"method-filter\"\n+            description=\"A filter can be an annotation (@jakarta.ws.rs.GET), a full qualified class name (com.example.Foo), a fully qualified method reference (java.lang.HashMap::resize) or a class initializer (::&lt;clinit&gt;). Use &lt;init&gt; for constructors. Separate multiple filters with semicolon.\"><\/text>\n@@ -1193,1 +1194,2 @@\n-      <text name=\"method-trace\" label=\"Method Trace\" contentType=\"text\"><\/text>\n+      <text name=\"method-trace\" label=\"Method Trace Filter\" contentType=\"method-filter\"\n+            description=\"A filter can be an annotation (@jakarta.ws.rs.GET), a full qualified class name (com.example.Foo), a fully qualified method reference (java.lang.HashMap::resize) or a class initializer (::&lt;clinit&gt;). Use &lt;init&gt; for constructors. Separate multiple filters with semicolon.\"><\/text>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,3 @@\n+        if (html) {\n+            new TidyChecker();\n+        }\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/DocCheck.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @build DocTester toolbox.TestRunner\n+ * @build DocTester toolbox.TestRunner jtreg.SkippedException\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/checks\/jdkCheckHtml.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jtreg.SkippedException;\n@@ -167,2 +168,1 @@\n-                System.err.println(\"tidy not found on PATH\");\n-                return Path.of(\"tidy\"); \/\/non-null placeholder return; exception would be better\n+                throw new jtreg.SkippedException(\"tidy not found on PATH\");\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/checkers\/TidyChecker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"unittest.hpp\"\n-\n-\/\/ Tests the assignment operator of ReservedMemoryRegion\n-TEST_VM(NMT, ReservedRegionCopy) {\n-  address dummy1 = (address)0x10000000;\n-  NativeCallStack stack1(&dummy1, 1);\n-  ReservedMemoryRegion region1(dummy1, os::vm_page_size(), stack1, mtThreadStack);\n-  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region1.mem_tag());\n-  region1.add_committed_region(dummy1, os::vm_page_size(), stack1);\n-  address dummy2 = (address)0x20000000;\n-  NativeCallStack stack2(&dummy2, 1);\n-  ReservedMemoryRegion region2(dummy2, os::vm_page_size(), stack2, mtCode);\n-  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region2.mem_tag());\n-  region2.add_committed_region(dummy2, os::vm_page_size(), stack2);\n-\n-  region2 = region1;\n-\n-  CommittedRegionIterator itr = region2.iterate_committed_regions();\n-  const CommittedMemoryRegion* rgn = itr.next();\n-  ASSERT_EQ(rgn->base(), dummy1); \/\/ Now we should see dummy1\n-  ASSERT_EQ(region2.mem_tag(), mtThreadStack); \/\/ Should be correct memory tag\n-  ASSERT_EQ(region2.call_stack()->get_frame(0), dummy1); \/\/ Check the stack\n-  rgn = itr.next();\n-  ASSERT_EQ(rgn, (const CommittedMemoryRegion*)nullptr); \/\/ and nothing else\n-}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_reserved_region.cpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -29,1 +30,0 @@\n-\n@@ -75,0 +75,1 @@\n+      return true;\n@@ -164,0 +165,1 @@\n+      return true;\n@@ -171,0 +173,1 @@\n+      return true;\n@@ -177,0 +180,1 @@\n+      return true;\n@@ -187,0 +191,1 @@\n+      return true;\n@@ -193,0 +198,1 @@\n+      return true;\n@@ -200,0 +206,1 @@\n+      return true;\n@@ -211,0 +218,1 @@\n+      return true;\n@@ -220,0 +228,1 @@\n+      return true;\n@@ -229,0 +238,1 @@\n+      return true;\n@@ -244,0 +254,1 @@\n+      return true;\n@@ -253,0 +264,1 @@\n+      return true;\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"nmt\/vmatree.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+class NMTRegionsTreeTest : public testing::Test {\n+ public:\n+  RegionsTree rt;\n+  NMTRegionsTreeTest() : rt(true) { }\n+};\n+\n+TEST_VM_F(NMTRegionsTreeTest, ReserveCommitTwice) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  VMATree::RegionData rd2 = rt.make_region_data(ncs, mtGC);\n+  VMATree::SummaryDiff diff;\n+  diff = rt.reserve_mapping(0, 100, rd);\n+  EXPECT_EQ(100, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  diff = rt.commit_region(0, 50, ncs);\n+  diff = rt.reserve_mapping(0, 100, rd);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  diff = rt.reserve_mapping(0, 100, rd2);\n+  EXPECT_EQ(-100, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(100, diff.tag[NMTUtil::tag_to_index(mtGC)].reserve);\n+  diff = rt.commit_region(0, 50, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtGC)].reserve);\n+  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtGC)].commit);\n+  diff = rt.commit_region(0, 50, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, CommitUncommitRegion) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(0, 100, rd);\n+  VMATree::SummaryDiff diff = rt.commit_region(0, 50, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  diff = rt.commit_region((address)60, 10, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(10, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  diff = rt.uncommit_region(0, 50);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, FindReservedRegion) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(1000, 50, rd);\n+  rt.reserve_mapping(1200, 50, rd);\n+  rt.reserve_mapping(1300, 50, rd);\n+  rt.reserve_mapping(1400, 50, rd);\n+  ReservedMemoryRegion rmr;\n+  rmr = rt.find_reserved_region((address)1205);\n+  EXPECT_EQ(rmr.base(), (address)1200);\n+  rmr = rt.find_reserved_region((address)1305);\n+  EXPECT_EQ(rmr.base(), (address)1300);\n+  rmr = rt.find_reserved_region((address)1405);\n+  EXPECT_EQ(rmr.base(), (address)1400);\n+  rmr = rt.find_reserved_region((address)1005);\n+  EXPECT_EQ(rmr.base(), (address)1000);\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, VisitReservedRegions) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(1000, 50, rd);\n+  rt.reserve_mapping(1200, 50, rd);\n+  rt.reserve_mapping(1300, 50, rd);\n+  rt.reserve_mapping(1400, 50, rd);\n+\n+  rt.visit_reserved_regions([&](const ReservedMemoryRegion& rgn) {\n+    EXPECT_EQ(((size_t)rgn.base()) % 100, 0UL);\n+    EXPECT_EQ(rgn.size(), 50UL);\n+    return true;\n+  });\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, VisitCommittedRegions) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(1000, 50, rd);\n+  rt.reserve_mapping(1200, 50, rd);\n+  rt.reserve_mapping(1300, 50, rd);\n+  rt.reserve_mapping(1400, 50, rd);\n+\n+  rt.commit_region((address)1010, 5UL, ncs);\n+  rt.commit_region((address)1020, 5UL, ncs);\n+  rt.commit_region((address)1030, 5UL, ncs);\n+  rt.commit_region((address)1040, 5UL, ncs);\n+  ReservedMemoryRegion rmr((address)1000, 50);\n+  size_t count = 0;\n+  rt.visit_committed_regions(rmr, [&](CommittedMemoryRegion& crgn) {\n+    count++;\n+    EXPECT_EQ((((size_t)crgn.base()) % 100) \/ 10, count);\n+    EXPECT_EQ(crgn.size(), 5UL);\n+    return true;\n+  });\n+  EXPECT_EQ(count, 4UL);\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/nmt\/test_regions_tree.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -39,1 +40,1 @@\n-  constexpr static const int si_len = 2;\n+  constexpr static const int si_len = 4;\n@@ -46,0 +47,2 @@\n+    stacks[2] = make_stack(0xC);\n+    stacks[3] = make_stack(0xD);\n@@ -47,1 +50,3 @@\n-    si[1] = ncs.push(stacks[0]);\n+    si[1] = ncs.push(stacks[1]);\n+    si[2] = ncs.push(stacks[2]);\n+    si[3] = ncs.push(stacks[3]);\n@@ -81,0 +86,1 @@\n+      return true;\n@@ -102,0 +108,5 @@\n+    \/\/                      900---1000\n+    \/\/                 800--900\n+    \/\/            700--800\n+    \/\/        ...\n+    \/\/ 0--100\n@@ -137,0 +148,1 @@\n+      return true;\n@@ -162,0 +174,1 @@\n+      return true;\n@@ -170,0 +183,156 @@\n+  template<int NodeCount> struct ExpectedTree {\n+    int nodes[NodeCount];\n+    MemTag tags[NodeCount + 1];\n+    VMATree::StateType states[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex res_si[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex com_si[NodeCount + 1];\n+  };\n+\n+  using State = VMATree::StateType;\n+  using SIndex = VMATree::SIndex;\n+\n+  struct UpdateCallInfo {\n+    VMATree::IntervalState ex_st;\n+    VMATree::RequestInfo req;\n+    VMATree::IntervalState new_st;\n+    int reserve[2], commit[2];\n+  };\n+\n+  void call_update_region(const UpdateCallInfo upd) {\n+    VMATree::TreapNode n1{upd.req.A, {}, 0}, n2{upd.req.B, {}, 0};\n+    n1.val().out= upd.ex_st;\n+    n2.val().in = n1.val().out;\n+    Tree tree;\n+    VMATree::SummaryDiff diff;\n+    tree.update_region(&n1, &n2, upd.req, diff);\n+    int from = NMTUtil::tag_to_index(upd.ex_st.mem_tag());\n+    int   to = NMTUtil::tag_to_index(upd.new_st.mem_tag());\n+    stringStream ss;\n+    ss.print(\"Ex. State: %d, op: %d, use-tag:%d, from==to: %d\",\n+             (int)upd.ex_st.type(), (int)upd.req.op_to_index(), upd.req.use_tag_inplace, from == to);\n+    const char* failed_case = ss.base();\n+    EXPECT_EQ(n1.val().out.type(), upd.new_st.type()) << failed_case;\n+    EXPECT_EQ(n1.val().out.mem_tag(), upd.new_st.mem_tag()) << failed_case;\n+    EXPECT_EQ(n1.val().out.reserved_stack(), upd.new_st.reserved_stack()) << failed_case;\n+    EXPECT_EQ(n1.val().out.committed_stack(), upd.new_st.committed_stack()) << failed_case;\n+\n+    if (from == to) {\n+      EXPECT_EQ(diff.tag[from].reserve, upd.reserve[0] + upd.reserve[1]) << failed_case;\n+      EXPECT_EQ(diff.tag[from].commit, upd.commit[0] + upd.commit[1]) << failed_case;\n+    } else {\n+      EXPECT_EQ(diff.tag[from].reserve, upd.reserve[0]) << failed_case;\n+      EXPECT_EQ(diff.tag[from].commit, upd.commit[0]) << failed_case;\n+      EXPECT_EQ(diff.tag[to].reserve, upd.reserve[1]) << failed_case;\n+      EXPECT_EQ(diff.tag[to].commit, upd.commit[1]) << failed_case;\n+    }\n+  }\n+\n+  template<int N>\n+  void create_tree(Tree& tree, ExpectedTree<N>& et, int line_no) {\n+    using SIndex = NativeCallStackStorage::StackIndex;\n+    const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+    VMATree::IntervalChange st;\n+    for (int i = 0; i < N; i++) {\n+      st.in.set_type(et.states[i]);\n+      st.in.set_tag(et.tags[i]);\n+      if (et.res_si[i] >= 0) {\n+        st.in.set_reserve_stack(et.res_si[i]);\n+      } else {\n+        st.in.set_reserve_stack(ES);\n+      }\n+      if (et.com_si[i] >= 0) {\n+        st.in.set_commit_stack(et.com_si[i]);\n+      } else {\n+        st.in.set_commit_stack(ES);\n+      }\n+\n+      st.out.set_type(et.states[i+1]);\n+      st.out.set_tag(et.tags[i+1]);\n+      if (et.res_si[i+1] >= 0) {\n+        st.out.set_reserve_stack(et.res_si[i+1]);\n+      } else {\n+        st.out.set_reserve_stack(ES);\n+      }\n+      if (et.com_si[i+1] >= 0) {\n+        st.out.set_commit_stack(et.com_si[i+1]);\n+      } else {\n+        st.out.set_commit_stack(ES);\n+      }\n+      tree.tree().upsert((VMATree::position)et.nodes[i], st);\n+    }\n+}\n+\n+  template <int N>\n+  void check_tree(Tree& tree, const ExpectedTree<N>& et, int line_no) {\n+    using Node = VMATree::TreapNode;\n+    auto left_released = [&](Node n) -> bool {\n+      return n.val().in.type() == VMATree::StateType::Released and\n+            n.val().in.mem_tag() == mtNone;\n+    };\n+    auto right_released = [&](Node n) -> bool {\n+      return n.val().out.type() == VMATree::StateType::Released and\n+            n.val().out.mem_tag() == mtNone;\n+    };\n+    for (int i = 0; i < N; i++) {\n+      VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n+      ASSERT_TRUE(r.start != nullptr);\n+      Node node = *r.start;\n+      ASSERT_EQ(node.key(), (VMATree::position)et.nodes[i]) << \"at line \" << line_no;\n+      if (i == (N -1)) { \/\/ last node\n+        EXPECT_TRUE(right_released(node)) << \"right-of last node is not Released\";\n+        break;\n+      }\n+      if (i == 0) { \/\/ first node\n+        EXPECT_TRUE(left_released(node)) << \"left-of first node is not Released\";\n+      }\n+      stringStream ss(50);\n+      ss.print(\"test at line: %d, for node: %d\", line_no, et.nodes[i]);\n+      const char* for_this_node = ss.base();\n+      EXPECT_EQ(node.val().out.type(), et.states[i+1]) << for_this_node;\n+      EXPECT_EQ(node.val().out.mem_tag(), et.tags[i+1]) << for_this_node;\n+      if (et.res_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_reserved_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_reserved_stack()) << for_this_node;\n+      }\n+      if (et.com_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.committed_stack(), et.com_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.committed_stack(), et.com_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_committed_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_committed_stack()) << for_this_node;\n+      }\n+    }\n+  }\n+\n+  template<int N>\n+  void print_tree(const ExpectedTree<N>& et, int line_no) {\n+    const State Rs = State::Reserved;\n+    const State Rl = State::Released;\n+    const State C = State::Committed;\n+    stringStream ss;\n+    ss.print_cr(\"Tree nodes for line %d\", line_no);\n+    ss.print_cr(\"    \/\/            1         2         3         4         5\");\n+    ss.print_cr(\"    \/\/  012345678901234567890123456789012345678901234567890\");\n+    ss.print   (\"    \/\/  \");\n+    int j = 0;\n+    for (int i = 0; i < N; i++) {\n+      char state_char = et.states[i+1] == Rl ? '.' :\n+                        et.states[i+1] == Rs ? 'r' :\n+                        et.states[i+1] ==  C ? 'C' : ' ';\n+      if (i == 0 && et.nodes[i] != 0) {\n+        for (j = 0; j < et.nodes[i]; j++) {\n+          ss.put('.');\n+        }\n+      }\n+      for (j = et.nodes[i]; i < (N - 1) && j < et.nodes[i + 1]; j++) {\n+        ss.put(state_char);\n+      }\n+    }\n+    for (; j <= 50; j++) {\n+      ss.put('.');\n+    }\n+    tty->print_cr(\"%s\", ss.base());\n+  }\n@@ -182,1 +351,11 @@\n-TEST_VM_F(NMTVMATreeTest, UseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, DuplicateReserve) {\n+  VMATree::RegionData rd{si[0], mtTest};\n+  Tree tree;\n+  tree.reserve_mapping(100, 100, rd);\n+  tree.reserve_mapping(100, 100, rd);\n+  EXPECT_EQ(2, count_nodes(tree));\n+  VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(110);\n+  EXPECT_EQ(100, (int)(r.end->key() - r.start->key()));\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, UseTagInplace) {\n@@ -184,5 +363,9 @@\n-  VMATree::RegionData rd1(si[0], mtTest);\n-  VMATree::RegionData rd2(si[1], mtNone);\n-  tree.reserve_mapping(0, 100, rd1);\n-  tree.commit_mapping(20, 50, rd2, true);\n-  tree.uncommit_mapping(30, 10, rd2);\n+  VMATree::RegionData rd_Test_cs0(si[0], mtTest);\n+  VMATree::RegionData rd_None_cs1(si[1], mtNone);\n+  tree.reserve_mapping(0, 100, rd_Test_cs0);\n+  \/\/ reserve:   0---------------------100\n+  \/\/ commit:        20**********70\n+  \/\/ uncommit:          30--40\n+  \/\/ post-cond: 0---20**30--40**70----100\n+  tree.commit_mapping(20, 50, rd_None_cs1, true);\n+  tree.uncommit_mapping(30, 10, rd_None_cs1);\n@@ -196,0 +379,1 @@\n+    return true;\n@@ -214,4 +398,4 @@\n-    VMATree::RegionData rd{si[0], mtTest };\n-    VMATree::RegionData rd2{si[1], mtNMT };\n-    tree.reserve_mapping(0, 100, rd);\n-    tree.reserve_mapping(100, 100, rd2);\n+    VMATree::RegionData rd_Test_cs0{si[0], mtTest};\n+    VMATree::RegionData rd_NMT_cs1{si[1], mtNMT};\n+    tree.reserve_mapping(0, 100, rd_Test_cs0);\n+    tree.reserve_mapping(100, 100, rd_NMT_cs1);\n@@ -225,4 +409,4 @@\n-    VMATree::RegionData rd{si[0], mtTest };\n-    VMATree::RegionData rd2{si[1], mtNMT };\n-    tree.commit_mapping(50, 50, rd2);\n-    tree.reserve_mapping(0, 100, rd);\n+    VMATree::RegionData rd_Test_cs0{si[0], mtTest};\n+    VMATree::RegionData rd_NMT_cs1{si[1], mtNMT};\n+    tree.commit_mapping(50, 50, rd_NMT_cs1);\n+    tree.reserve_mapping(0, 100, rd_Test_cs0);\n@@ -232,1 +416,1 @@\n-        EXPECT_EQ(x->val().out.regiondata().mem_tag, mtTest);\n+        EXPECT_EQ(x->val().out.reserved_regiondata().mem_tag, mtTest);\n@@ -234,0 +418,1 @@\n+      return true;\n@@ -241,6 +426,6 @@\n-    VMATree::RegionData rd{si[0], mtTest };\n-    VMATree::RegionData rd2{si[1], mtNMT };\n-    VMATree::RegionData rd3{si[0], mtNone };\n-    tree.reserve_mapping(0, 100, rd);\n-    tree.reserve_mapping(0, 50, rd2);\n-    tree.reserve_mapping(50, 50, rd3);\n+    VMATree::RegionData rd_Test_cs0{si[0], mtTest};\n+    VMATree::RegionData rd_NMT_cs1{si[1], mtNMT};\n+    VMATree::RegionData rd_None_cs0{si[0], mtNone};\n+    tree.reserve_mapping(0, 100, rd_Test_cs0);\n+    tree.reserve_mapping(0, 50, rd_NMT_cs1);\n+    tree.reserve_mapping(50, 50, rd_None_cs0);\n@@ -251,1 +436,1 @@\n-    Tree::RegionData rd{si[0], mtNMT};\n+    VMATree::RegionData rd_NMT_cs0{si[0], mtNMT};\n@@ -253,1 +438,1 @@\n-    tree.reserve_mapping(0, 500000, rd);\n+    tree.reserve_mapping(0, 500000, rd_NMT_cs0);\n@@ -261,2 +446,2 @@\n-    Tree::RegionData rd{si[0], mtNMT};\n-    VMATree::RegionData rd2{si[1], mtTest};\n+    VMATree::RegionData rd_NMT_cs0{si[0], mtNMT};\n+    VMATree::RegionData rd_Test_cs1{si[1], mtTest};\n@@ -264,2 +449,2 @@\n-    tree.reserve_mapping(0, 100, rd);\n-    tree.commit_mapping(0, 100, rd2);\n+    tree.reserve_mapping(0, 100, rd_NMT_cs0);\n+    tree.commit_mapping(0, 100, rd_Test_cs1);\n@@ -268,1 +453,1 @@\n-        EXPECT_EQ(mtTest, x->val().out.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().out.reserved_regiondata().mem_tag);\n@@ -271,1 +456,1 @@\n-        EXPECT_EQ(mtTest, x->val().in.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().in.reserved_regiondata().mem_tag);\n@@ -273,0 +458,1 @@\n+      return true;\n@@ -278,2 +464,2 @@\n-    Tree::RegionData rd{si[0], mtNMT};\n-    tree.reserve_mapping(0, 0, rd);\n+    VMATree::RegionData rd_NMT_cs0{si[0], mtNMT};\n+    tree.reserve_mapping(0, 0, rd_NMT_cs0);\n@@ -281,1 +467,1 @@\n-    tree.commit_mapping(0, 0, rd);\n+    tree.commit_mapping(0, 0, rd_NMT_cs0);\n@@ -292,1 +478,1 @@\n-    NCS::StackIndex stack;\n+    NCS::StackIndex reserve_stack;\n@@ -297,1 +483,1 @@\n-  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree, int line_no) {\n@@ -314,2 +500,2 @@\n-      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag());\n-      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag());\n+      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag()) << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag()) << \" and at test-line: \" << line_no;\n@@ -317,2 +503,2 @@\n-      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n-      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      EXPECT_EQ(expect.reserve_stack, found.start->val().out.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.reserve_stack, found.end->val().in.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n@@ -327,0 +513,2 @@\n+  NCS::StackIndex es = NCS::invalid; \/\/ empty or no stack is stored\n+\n@@ -340,1 +528,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -356,0 +544,7 @@\n+    \/\/ 0---------------------------------------------------600\n+    \/\/        100****225\n+    \/\/                           550***560\n+    \/\/                                       565***575\n+    \/\/ 0------100****225---------550***560---565***575-----600\n+    \/\/ 0------100****225---500---550***560---565***575-----600\n+    \/\/ <-------mtGC---------><-----------mtClassShared------->\n@@ -364,1 +559,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -377,1 +572,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -393,1 +588,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -406,1 +601,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -421,1 +616,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -427,1 +622,1 @@\n-        {50,  75,        mtNone, si, State::Released},\n+        {50,  75,        mtNone, es, State::Released},\n@@ -436,1 +631,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -447,1 +642,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -453,1 +648,1 @@\n-        { 1,  50, mtNone, si, State::Released},\n+        { 1,  50, mtNone, es, State::Released},\n@@ -455,1 +650,1 @@\n-        {75,  99, mtNone, si, State::Released},\n+        {75,  99, mtNone, es, State::Released},\n@@ -464,1 +659,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -471,2 +666,2 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n-    Tree::RegionData rd2(NCS::StackIndex(), mtNMT);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_NMT_cs0(NCS::StackIndex(), mtNMT);\n@@ -474,1 +669,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -477,1 +678,9 @@\n-    all_diff = tree.reserve_mapping(50, 25, rd2);\n+    all_diff = tree.reserve_mapping(50, 25, rd_NMT_cs0);\n+\/\/              1         2         3         4         5         6         7         8         9         10         11\n+\/\/    01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCC..........\n+\/\/    Legend:\n+\/\/     A - Test (reserved)\n+\/\/     B - Native Memory Tracking (reserved)\n+\/\/     C - Test (reserved)\n+\/\/     . - free\n@@ -484,1 +693,1 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n@@ -486,1 +695,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -490,0 +705,4 @@\n+\/\/            1         2         3         4         5         6         7         8         9         10        11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  ..............................................................................................................\n+\/\/  Legend:\n@@ -494,1 +713,1 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n@@ -496,1 +715,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -499,1 +724,7 @@\n-    all_diff = tree.commit_mapping(0, 100, rd);\n+    all_diff = tree.commit_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n@@ -505,1 +736,1 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n@@ -507,1 +738,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 10, rd_Test_cs0);\n+\/\/            1         2\n+\/\/  01234567890123456789\n+\/\/  AAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -509,2 +746,8 @@\n-    EXPECT_EQ(diff.reserve, 100);\n-    all_diff = tree.reserve_mapping(100, 100, rd);\n+    EXPECT_EQ(diff.reserve, 10);\n+    all_diff = tree.reserve_mapping(10, 10, rd_Test_cs0);\n+\/\/            1         2         3\n+\/\/  012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -512,1 +755,1 @@\n-    EXPECT_EQ(100, diff.reserve);\n+    EXPECT_EQ(10, diff.reserve);\n@@ -515,2 +758,2 @@\n-  Tree::RegionData rd(NCS::StackIndex(), mtTest);\n-    Tree::RegionData rd2(NCS::StackIndex(), mtNMT);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_NMT_cs0(NCS::StackIndex(), mtNMT);\n@@ -518,1 +761,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 10, rd_Test_cs0);\n+\/\/            1         2\n+\/\/  01234567890123456789\n+\/\/  AAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -520,2 +769,9 @@\n-    EXPECT_EQ(diff.reserve, 100);\n-    all_diff = tree.reserve_mapping(100, 100, rd2);\n+    EXPECT_EQ(diff.reserve, 10);\n+    all_diff = tree.reserve_mapping(10, 10, rd_NMT_cs0);\n+\/\/            1         2         3\n+\/\/  012345678901234567890123456789\n+\/\/  AAAAAAAAAABBBBBBBBBB..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  B - Native Memory Tracking (reserved)\n+\/\/  . - free\n@@ -525,1 +781,1 @@\n-    EXPECT_EQ(100, diff.reserve);\n+    EXPECT_EQ(10, diff.reserve);\n@@ -531,6 +787,24 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n-    tree.commit_mapping(128, 128, rd);\n-    tree.commit_mapping(512, 128, rd);\n-    VMATree::SummaryDiff diff = tree.commit_mapping(0, 1024, rd);\n-    EXPECT_EQ(768, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-    EXPECT_EQ(768, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n+    tree.commit_mapping(16, 16, rd_Test_cs0);\n+\/\/            1         2         3         4\n+\/\/  0123456789012345678901234567890123456789\n+\/\/  ................aaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    tree.commit_mapping(32, 32, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  ................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    VMATree::SummaryDiff diff = tree.commit_mapping(0, 64, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    EXPECT_EQ(16, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(16, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n@@ -540,0 +814,12 @@\n+TEST_VM_F(NMTVMATreeTest, SummaryAccountingReserveAsUncommit) {\n+  Tree tree;\n+  Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+  VMATree::SummaryDiff diff1 = tree.reserve_mapping(1200, 100, rd);\n+  VMATree::SummaryDiff diff2 = tree.commit_mapping(1210, 50, rd);\n+  EXPECT_EQ(100, diff1.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(50, diff2.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  VMATree::SummaryDiff diff3 = tree.reserve_mapping(1220, 20, rd);\n+  EXPECT_EQ(-20, diff3.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  EXPECT_EQ(0, diff3.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+}\n+\n@@ -716,4 +1002,15 @@\n-        const NativeCallStack& start_stack = ncss.get(startn->val().out.stack());\n-        const NativeCallStack& end_stack = ncss.get(endn->val().in.stack());\n-        ASSERT_TRUE(starti.stack.equals(start_stack));\n-        ASSERT_TRUE(endi.stack.equals(end_stack));\n+        const NativeCallStack& start_stack = ncss.get(startn->val().out.reserved_stack());\n+        const NativeCallStack& end_stack = ncss.get(endn->val().in.reserved_stack());\n+        \/\/ If start-node of a reserved region is committed, the stack is stored in the second_stack of the node.\n+        if (startn->val().out.has_committed_stack()) {\n+          const NativeCallStack& start_second_stack = ncss.get(startn->val().out.committed_stack());\n+          ASSERT_TRUE(starti.stack.equals(start_stack) || starti.stack.equals(start_second_stack));\n+        } else {\n+          ASSERT_TRUE(starti.stack.equals(start_stack));\n+        }\n+        if (endn->val().in.has_committed_stack()) {\n+          const NativeCallStack& end_second_stack = ncss.get(endn->val().in.committed_stack());\n+          ASSERT_TRUE(endi.stack.equals(end_stack) || endi.stack.equals(end_second_stack));\n+        } else {\n+          ASSERT_TRUE(endi.stack.equals(end_stack));\n+        }\n@@ -728,1 +1025,1 @@\n-TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseTagInplace) {\n@@ -730,4 +1027,13 @@\n-  VMATree::RegionData rd1(si[0], mtTest);\n-  VMATree::RegionData rd2(si[1], mtNone);\n-  tree.reserve_mapping(0, 100, rd1);\n-  VMATree::SummaryDiff diff = tree.commit_mapping(0, 50, rd2, true);\n+  VMATree::RegionData rd_Test_cs0(si[0], mtTest);\n+  VMATree::RegionData rd_None_cs1(si[1], mtNone);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  ..................................................\n+  tree.reserve_mapping(0, 50, rd_Test_cs0);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+VMATree::SummaryDiff diff = tree.commit_mapping(0, 25, rd_None_cs1, true);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  CCCCCCCCCCCCCCCCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrr\n@@ -735,2 +1041,6 @@\n-  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-  diff = tree.commit_mapping(60, 10, rd2, true);\n+  EXPECT_EQ(25, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+\n+  diff = tree.commit_mapping(30, 5, rd_None_cs1, true);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  CCCCCCCCCCCCCCCCCCCCCCCCCrrrrrCCCCCrrrrrrrrrrrrrrr\n@@ -738,2 +1048,6 @@\n-  EXPECT_EQ(10, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-  diff = tree.uncommit_mapping(0, 50, rd2);\n+  EXPECT_EQ(5, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+\n+  diff = tree.uncommit_mapping(0, 25, rd_None_cs1);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrCCCCCrrrrrrrrrrrrrrr\n@@ -741,1 +1055,960 @@\n-  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  EXPECT_EQ(-25, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+}\n+\n+\/\/ How the memory regions are visualized:\n+\/\/            1         2         3         4         5         6         7       |\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789        |_> memory address\n+\/\/  aaaaaaBBBBBBBcccccccDDDDDDDeeeeeeeFFFFFFFF...........................         |->some letters showing the state of the memory\n+\/\/ Legend:\n+\/\/ . - None (free\/released)\n+\/\/ r - MemTag (reserved)\n+\/\/ C - MemTag (committed)\n+\/\/ MemTag is Test if omitted.\n+\n+TEST_VM_F(NMTVMATreeTest, SeparateStacksForCommitAndReserve) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+\n+  {\/\/ Check committing into a reserved region inherits the call stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1); \/\/ reserve in an empty tree\n+    \/\/ Pre: empty tree.\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr.\n+    ExpectedTree<2> et1 = {{     0,     50        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+    tree.commit_mapping(25, 10, rd_None_cs2, true); \/\/ commit at the middle of the region\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrCCCCCCCCCCrrrrrrrrrrrrrrr.\n+    ExpectedTree<4> et2 = {{     0,     25,     35,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+\n+    tree.commit_mapping(0, 20, rd_None_cs2, true); \/\/ commit at the beginning of the region\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCCrrrrrCCCCCCCCCCrrrrrrrrrrrrrrr.\n+    ExpectedTree<5> et3 = {{     0,     20,     25,     35,    50         },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et3, __LINE__);\n+\n+    tree.commit_mapping(40, 10, rd_None_cs2, true); \/\/ commit at the end of the region\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCCrrrrrCCCCCCCCCCrrrrrCCCCCCCCCC.\n+    ExpectedTree<6> et4 = {{     0,     20,     25,     35,     40,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , C     , Rs    , C     , Rs    , C     , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , si_2  , -1    , si_2  , -1    , si_2  , -1    }};\n+    check_tree(tree, et4, __LINE__);\n+  }\n+  {\/\/ committing overlapped regions does not destroy the old call-stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1); \/\/ reserving in an empty tree\n+    \/\/ Pre: empty tree.\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<2> et1 = {{      0  , 50         },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+\n+    tree.commit_mapping(10, 10, rd_None_cs2, true);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<4> et2 = {{     0,     10,     20,    50         },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+\n+    SIndex si_3 = si[2];\n+    VMATree::RegionData rd_Test_cs3(si_3, mtTest);\n+    \/\/ commit with overlap at the region's start\n+    tree.commit_mapping(5, 10, rd_Test_cs3);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<5> et3 = {{     0,      5,     15,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_3  , si_2  , -1    , -1    }};\n+    check_tree(tree, et3, __LINE__);\n+\n+    SIndex si_4 = si[3];\n+    VMATree::RegionData call_stack_4(si_4, mtTest);\n+    \/\/ commit with overlap at the region's end\n+    tree.commit_mapping(15, 10, call_stack_4);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<5> et4 = {{     0,      5,     15,     25,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_3  , si_4  , -1    , -1    }};\n+    check_tree(tree, et4, __LINE__);\n+  }\n+  {\/\/ uncommit should not store any call-stack\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1);\n+\n+    tree.commit_mapping(10, 10, rd_None_cs2, true);\n+\n+    tree.commit_mapping(0, 5, rd_None_cs2, true);\n+\n+    tree.uncommit_mapping(0, 3, rd_None_cs2);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrCCrrrrrCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<6> et1 = {{     0,     3,       5,     10,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+\n+    tree.uncommit_mapping(5, 10, rd_None_cs2);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrCCrrrrrrrrrrCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr.\n+    ExpectedTree<6> et2 = {{     0,      3,      5,     15,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+  }\n+  {\/\/ reserve after reserve, but only different call-stacks\n+    SIndex si_4 = si[3];\n+    VMATree::RegionData call_stack_4(si_4, mtTest);\n+\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1);\n+    tree.reserve_mapping(10, 10, call_stack_4);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<4> et1 = {{     0,     10,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_4  , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+  }\n+  {\/\/ commit without reserve\n+    Tree tree;\n+    tree.commit_mapping(0, 50, rd_Test_cs1);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n+    ExpectedTree<2> et = {{     0,      50       },\n+                          {mtNone, mtTest, mtNone},\n+                          {Rl    , C     , Rl    },\n+                          {-1    , si_1  , -1    },\n+                          {-1    , si_1  , -1    }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\/\/ reserve after commit\n+    Tree tree;\n+    tree.commit_mapping(0, 50, rd_None_cs2);\n+    tree.reserve_mapping(0, 50, rd_Test_cs1);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<2> et = {{     0,      50       },\n+                          {mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , -1    },\n+                          {-1    , -1    , -1    }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows0To3) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ case of empty tree is already covered in other tests.\n+  \/\/ row 1 is impossible. See the implementation.\n+  {\n+    \/\/ row  2:  .........A...Y.......................W.....B..........\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    Tree tree;\n+    ExpectedTree<5> pre = {{    10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC..........................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<6> et = {{     5,     10,     12,     14,     16,     25        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  3:  .........A...Y.......................WB.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<5> pre = {{    10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 5);\n+    ExpectedTree<6> et = {{   5,      10,     12,     14,     16,      20        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows4to7) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  {\n+    \/\/ row  4:  .....X...A..................B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(20, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr..........CCCCCCCCCCCCCCCCCCCC...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20);\n+    ExpectedTree<4> et = {{     0,     10,     20,     40        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrrrrrr....................................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     5,     15,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 10, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 10);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20 - 15);\n+    ExpectedTree<4> et = {{     5,     10,     15,     20        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  6:  .....X...A.....Y.......................W.....B...\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,      5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCCCCCCCCC........................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<8> et = {{     0,      5,      7,    10,      12,     14,     16,     27        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  7:  .....X...A...Y.......................WB.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,      5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 13, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 13);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 3);\n+    ExpectedTree<8> et = {{     0,      5,      7,     10,     12,     14,     16,     20        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows8to11) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+  {\n+    \/\/ row  8:  ........XA..................B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    \/\/ nodes:   0--------50...........................\n+    \/\/            si1\n+    \/\/            -\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0--------50*****************250\n+    \/\/            si1        si2\n+    \/\/            -          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCCCCCCCCCCC.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20);\n+    ExpectedTree<3> et = {{     0,     10,     30        },\n+                          {mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    },\n+                          {-1    , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  9:  ........XA....YW.............B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(0, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<3> et = {{     0,     10,     20        },\n+                          {mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 10:  ........XA...Y.......................W.....B...\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrrrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<6> pre = {{     5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC..........................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 25 - 20);\n+    ExpectedTree<6> et = {{     5,     10,     12,     14,     16,     25        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 11:  ........XA...Y.......................WB.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrrrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<6> pre = {{     5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 0);\n+    ExpectedTree<6> et = {{     5,     10,     12,     14,     16,     20        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows12to15) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  {\n+    \/\/ row 12:  .........A..................B.....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..............................rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    30,     40        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20);\n+    ExpectedTree<4> et = {{     5,     25,     30,     40        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 13:  .........A...YW.............B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrrrrrrrrrrrr.....................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    10,     30        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCCrrrrr.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 30 - 25);\n+    ExpectedTree<4> et = {{     5,     10,     25,     30        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 14:  .........A...Y.......................W....B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<7> pre = {{    10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, (10 - 5) + ( 25 - 20));\n+    ExpectedTree<8> et = {{     5,     10,     12,     14,     16,     25,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 15:  .........A...Y.......................WB....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<7> pre = {{    10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCC..........rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10 - 5);\n+    ExpectedTree<8> et = {{     5,     10,     12,     14,     16,     20,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows16to19) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+  {\n+    \/\/ row 16:  .....X...A..................B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr....................rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,    10,      30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(15, 10, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.....CCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 10);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,     40        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr..........rrrrrrrrrr.....................\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,     20,     30        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(15, 10, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.....CCCCCCCCCCrrrrr.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 10);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20 - 15);\n+    ExpectedTree<6> et = {{     0,     10,     15,     20,     25,     30        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 18:  ....X....A...Y.......................W....B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCCCCCCCCC...rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, (10 - 7) + (27 - 20));\n+    ExpectedTree<10> et = {{     0,      5,      7,     12,     14,     16,     20,     27,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 19:  .....X...A...Y.......................WB....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 13, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCC..........rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 13);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10 - 7);\n+    ExpectedTree<10> et = {{     0,      5,      7,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows20to23) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  {\n+    \/\/ row 20:  ........XA..................B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr....................rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,      30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 15);\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr..........rrrrrrrrrr.....................\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,     20,     30        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCCCCCCrrrrr.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20 - 10);\n+    ExpectedTree<5> et = {{     0,     10,     20,     25,     30        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 22:  ........XA...Y.......................W....B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, (10 - 5) + (25 - 20));\n+    ExpectedTree<9> et = {{     0,      5,     12,     14,     16,     20,    25,      30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 23:  ........XA...Y.......................WB....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCC..........rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10 - 5);\n+    ExpectedTree<9> et = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, UpdateRegionTest) {\n+  using State = VMATree::StateType;\n+  using SIndex = VMATree::SIndex;\n+  SIndex ES = NativeCallStackStorage::invalid;\n+  SIndex s0 = si[0];\n+  SIndex s1 = si[1];\n+  SIndex s2 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  const int a = 100;\n+  const MemTag ReqTag = mtTest;\n+  const VMATree::RequestInfo       ReleaseRequest{0, a, Rl, mtNone, ES, false};\n+  const VMATree::RequestInfo       ReserveRequest{0, a, Rs, ReqTag, s2, false};\n+  const VMATree::RequestInfo        CommitRequest{0, a,  C, ReqTag, s2, false};\n+  const VMATree::RequestInfo      UncommitRequest{0, a, Rs, mtNone, ES, true};\n+  const VMATree::RequestInfo CopyTagCommitRequest{0, a,  C, ReqTag, s2, true};\n+                              \/\/  existing state           request              expected state     expected diff\n+                              \/\/ st   tag    stacks                           st   tag    stacks   reserve  commit\n+                              \/\/ --  ------  ------  ----------------------   --  ------  ------   -------  -------\n+  UpdateCallInfo  call_info[]={{{Rl, mtNone, ES, ES},        ReleaseRequest, {Rl, mtNone, ES, ES}, {0,  0}, {0,  0}},\n+                               {{Rl, mtNone, ES, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  a}, {0,  0}},\n+                               {{Rl, mtNone, ES, ES},         CommitRequest, { C, ReqTag, s2, s2}, {0,  a}, {0,  a}},\n+                               {{Rl, mtNone, ES, ES},  CopyTagCommitRequest, { C, mtNone, s2, s2}, {0,  a}, {0,  a}},\n+                               {{Rl, mtNone, ES, ES},       UncommitRequest, {Rl, mtNone, ES, ES}, {0,  0}, {0,  0}},\n+                               {{Rs,   mtGC, s0, ES},        ReleaseRequest, {Rl, mtNone, ES, ES}, {-a, 0}, {0,  0}},\n+                               {{Rs,   mtGC, s0, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {-a, a}, {0,  0}}, \/\/ diff tag\n+                               {{Rs, mtTest, s0, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  0}, {0,  0}}, \/\/ same tag\n+                               {{Rs,   mtGC, s0, ES},         CommitRequest, { C, ReqTag, s0, s2}, {-a, a}, {0,  a}},\n+                               {{Rs,   mtGC, s0, ES},  CopyTagCommitRequest, { C,   mtGC, s0, s2}, {0,  0}, {0,  a}},\n+                               {{Rs,   mtGC, s0, ES},       UncommitRequest, {Rs,   mtGC, s0, ES}, {0,  0}, {0,  0}},\n+                               {{ C,   mtGC, s0, s1},        ReleaseRequest, {Rl, mtNone, ES, ES}, {-a, 0}, {-a, 0}},\n+                               {{ C,   mtGC, s0, s1},        ReserveRequest, {Rs, ReqTag, s2, ES}, {-a, a}, {-a, 0}}, \/\/ diff tag\n+                               {{ C, mtTest, s0, s1},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  0}, {-a, 0}}, \/\/ same tag\n+                               {{ C,   mtGC, s0, s1},         CommitRequest, { C, ReqTag, s0, s2}, {-a, a}, {-a, a}},\n+                               {{ C,   mtGC, s0, s1},  CopyTagCommitRequest, { C,   mtGC, s0, s2}, {0,  0}, {-a, a}},\n+                               {{ C,   mtGC, s0, s1},       UncommitRequest, {Rs,   mtGC, s0, ES}, {0,  0}, {-a, 0}}\n+                              };\n+  for (auto ci : call_info) {\n+    call_update_region(ci);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":1365,"deletions":92,"binary":false,"changes":1457,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/rangeinference.hpp\"\n+#include \"opto\/type.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/intn_t.hpp\"\n+#include \"unittest.hpp\"\n+\n+template <class U>\n+static U uniform_random();\n+\n+template <>\n+juint uniform_random<juint>() {\n+  return os::random();\n+}\n+\n+template <>\n+julong uniform_random<julong>() {\n+  return (julong(os::random()) << 32) | julong(juint(os::random()));\n+}\n+\n+static void test_canonicalize_constraints_trivial() {\n+  ASSERT_FALSE(TypeInt::NON_ZERO->contains(0));\n+  ASSERT_TRUE(TypeInt::NON_ZERO->contains(1));\n+  ASSERT_TRUE(TypeInt::NON_ZERO->contains(-1));\n+  ASSERT_TRUE(TypeInt::CC_NE->contains(-1));\n+  ASSERT_TRUE(TypeInt::CC_NE->contains(1));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(0));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(-2));\n+  ASSERT_FALSE(TypeInt::CC_NE->contains(2));\n+  ASSERT_FALSE(TypeLong::NON_ZERO->contains(jlong(0)));\n+  ASSERT_TRUE(TypeLong::NON_ZERO->contains(jlong(1)));\n+  ASSERT_TRUE(TypeLong::NON_ZERO->contains(jlong(-1)));\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_exhaustive() {\n+  {\n+    TypeIntPrototype<S, U> t{{S(0), S(0)}, {U(0), U(0)}, {U(-1), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_TRUE(new_t._present);\n+    DEBUG_ONLY(ASSERT_TRUE(t.contains(S(0))));\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(1))));\n+  }\n+  {\n+    TypeIntPrototype<S, U> t{{S(0), S(0)}, {U(1), U(1)}, {U(-1), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_FALSE(new_t._present);\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(0))));\n+    DEBUG_ONLY(ASSERT_FALSE(t.contains(S(1))));\n+  }\n+  {\n+    TypeIntPrototype<S, U> t{{S(S::min), S(S::max)}, {U(U::min), U(U::max)}, {U(0), U(0)}};\n+    auto new_t = t.canonicalize_constraints();\n+    ASSERT_TRUE(new_t._present);\n+    for (int v = S::min; v <= S::max; v++) {\n+      DEBUG_ONLY(ASSERT_TRUE(t.contains(S(v))));\n+    }\n+  }\n+  for (int lo = S::min; lo <= S::max; lo++) {\n+    for (int hi = lo; hi <= S::max; hi++) {\n+      for (int ulo = U::min; ulo <= U::max; ulo++) {\n+        for (int uhi = ulo; uhi <= U::max; uhi++) {\n+          for (int zeros = U::min; zeros <= U::max; zeros++) {\n+            for (int ones = U::min; ones <= U::max; ones++) {\n+              TypeIntPrototype<S, U> t{{S(lo), S(hi)}, {U(ulo), U(uhi)}, {U(zeros), U(ones)}};\n+              auto new_t = t.canonicalize_constraints();\n+              if (new_t._present) {\n+                DEBUG_ONLY(new_t._data.verify_constraints());\n+              }\n+              for (int v = S::min; v <= S::max; v++) {\n+                if (!new_t._present) {\n+                  DEBUG_ONLY(ASSERT_FALSE(t.contains(S(v))));\n+                } else {\n+                  DEBUG_ONLY(ASSERT_EQ(t.contains(S(v)), new_t._data.contains(S(v))));\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_simple() {\n+  constexpr int parameters = 1000;\n+  for (int i = 0; i < parameters; i++) {\n+    S a = uniform_random<U>();\n+    S b = uniform_random<U>();\n+\n+    {\n+      S lo = MIN2<S>(a, b);\n+      S hi = MAX2<S>(a, b);\n+      TypeIntPrototype<S, U> t{{lo, hi}, {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()},\n+                               {0, 0}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(lo, new_t._data._srange._lo);\n+      ASSERT_EQ(hi, new_t._data._srange._hi);\n+      if (U(lo) <= U(hi)) {\n+        ASSERT_EQ(U(lo), new_t._data._urange._lo);\n+        ASSERT_EQ(U(hi), new_t._data._urange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<U>::min(), new_t._data._urange._lo);\n+        ASSERT_EQ(std::numeric_limits<U>::max(), new_t._data._urange._hi);\n+      }\n+    }\n+\n+    {\n+      U ulo = MIN2<U>(a, b);\n+      U uhi = MAX2<U>(a, b);\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n+                               {ulo, uhi}, {0, 0}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(ulo, new_t._data._urange._lo);\n+      ASSERT_EQ(uhi, new_t._data._urange._hi);\n+      if (S(ulo) <= S(uhi)) {\n+        ASSERT_EQ(S(ulo), new_t._data._srange._lo);\n+        ASSERT_EQ(S(uhi), new_t._data._srange._hi);\n+      } else {\n+        ASSERT_EQ(std::numeric_limits<S>::min(), new_t._data._srange._lo);\n+        ASSERT_EQ(std::numeric_limits<S>::max(), new_t._data._srange._hi);\n+      }\n+    }\n+\n+    {\n+      U intersection = a & b;\n+      U zeros = a ^ intersection;\n+      U ones = b ^ intersection;\n+      TypeIntPrototype<S, U> t{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()},\n+                               {std::numeric_limits<U>::min(), std::numeric_limits<U>::max()}, {zeros, ones}};\n+      auto new_t = t.canonicalize_constraints();\n+      ASSERT_TRUE(new_t._present);\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+      ASSERT_EQ(zeros, new_t._data._bits._zeros);\n+      ASSERT_EQ(ones, new_t._data._bits._ones);\n+      ASSERT_EQ(ones, new_t._data._urange._lo);\n+      ASSERT_EQ(~zeros, new_t._data._urange._hi);\n+    }\n+  }\n+}\n+\n+template <class S, class U>\n+static void test_canonicalize_constraints_random() {\n+  constexpr int samples = 1000;\n+  constexpr int parameters = 1000;\n+  for (int i = 0; i < parameters; i++) {\n+    S s1 = uniform_random<U>();\n+    S s2 = uniform_random<U>();\n+    S lo = MIN2(s1, s2);\n+    S hi = MAX2(s1, s2);\n+    U u1 = uniform_random<U>();\n+    U u2 = uniform_random<U>();\n+    U ulo = MIN2(u1, u2);\n+    U uhi = MAX2(u1, u2);\n+    U b1 = uniform_random<U>();\n+    U b2 = uniform_random<U>();\n+    U intersection = b1 & b2;\n+    U zeros = b1 ^ intersection;\n+    U ones = b2 ^ intersection;\n+    TypeIntPrototype<S, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n+    auto new_t = t.canonicalize_constraints();\n+    if (new_t._present) {\n+      DEBUG_ONLY(new_t._data.verify_constraints());\n+    }\n+    for (int j = 0; j < samples; j++) {\n+      S v = uniform_random<U>();\n+      if (!new_t._present) {\n+        DEBUG_ONLY(ASSERT_FALSE(t.contains(v)));\n+      } else {\n+        DEBUG_ONLY(ASSERT_EQ(t.contains(v), new_t._data.contains(v)));\n+      }\n+    }\n+  }\n+}\n+\n+TEST_VM(opto, canonicalize_constraints) {\n+  test_canonicalize_constraints_trivial();\n+  test_canonicalize_constraints_exhaustive<intn_t<1>, uintn_t<1>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<2>, uintn_t<2>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<3>, uintn_t<3>>();\n+  test_canonicalize_constraints_exhaustive<intn_t<4>, uintn_t<4>>();\n+  test_canonicalize_constraints_simple<jint, juint>();\n+  test_canonicalize_constraints_simple<jlong, julong>();\n+  test_canonicalize_constraints_random<jint, juint>();\n+  test_canonicalize_constraints_random<jlong, julong>();\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -25,1 +25,2 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -40,1 +41,1 @@\n-    VirtualMemoryTracker::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n+    VirtualMemoryTracker::Instance::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n@@ -43,1 +44,1 @@\n-    VirtualMemoryTracker::snapshot_thread_stacks();\n+    VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n@@ -45,2 +46,3 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(stack_end, stack_size));\n-    ASSERT_TRUE(rmr != nullptr);\n+    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region(stack_end);\n+    ASSERT_TRUE(rmr_found.is_valid());\n+    ASSERT_EQ(rmr_found.base(), stack_end);\n@@ -48,4 +50,0 @@\n-    ASSERT_EQ(rmr->base(), stack_end);\n-    ASSERT_EQ(rmr->size(), stack_size);\n-\n-    CommittedRegionIterator iter = rmr->iterate_committed_regions();\n@@ -59,4 +57,3 @@\n-\n-    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n-      if (region->base() + region->size() == stack_top) {\n-        ASSERT_TRUE(region->size() <= stack_size);\n+    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr) {\n+      if (cmr.base() + cmr.size() == stack_top) {\n+        EXPECT_TRUE(cmr.size() <= stack_size);\n@@ -65,2 +62,1 @@\n-\n-      if(i_addr < stack_top && i_addr >= region->base()) {\n+      if(i_addr < stack_top && i_addr >= cmr.base()) {\n@@ -69,1 +65,0 @@\n-\n@@ -71,1 +66,3 @@\n-    }\n+      return true;\n+    });\n+\n@@ -75,1 +72,0 @@\n-    ASSERT_TRUE(found_stack_top);\n@@ -77,0 +73,1 @@\n+    ASSERT_TRUE(found_stack_top);\n@@ -103,4 +100,0 @@\n-    address frame = (address)0x1235;\n-    NativeCallStack stack(&frame, 1);\n-    VirtualMemoryTracker::add_reserved_region((address)base, size, stack, mtThreadStack);\n-\n@@ -108,1 +101,5 @@\n-    VirtualMemoryTracker::snapshot_thread_stacks();\n+    VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n+\n+    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    ASSERT_TRUE(rmr_found.is_valid());\n+    ASSERT_EQ(rmr_found.base(), (address)base);\n@@ -110,2 +107,0 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion((address)base, size));\n-    ASSERT_TRUE(rmr != nullptr);\n@@ -114,6 +109,3 @@\n-    CommittedRegionIterator iter = rmr->iterate_committed_regions();\n-    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n-      if (region->size() == size) {\n-        \/\/ platforms that do not support precise tracking.\n-        ASSERT_TRUE(iter.next() == nullptr);\n-        break;\n+    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr){\n+      if (cmr.size() == size) {\n+        return false;\n@@ -122,1 +114,1 @@\n-        check_covered_pages(region->base(), region->size(), (address)base, touch_pages, page_num);\n+        check_covered_pages(cmr.base(), cmr.size(), (address)base, touch_pages, page_num);\n@@ -124,1 +116,2 @@\n-    }\n+      return true;\n+    });\n@@ -135,4 +128,3 @@\n-    VirtualMemoryTracker::remove_released_region((address)base, size);\n-\n-    rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion((address)base, size));\n-    ASSERT_TRUE(rmr == nullptr);\n+    VirtualMemoryTracker::Instance::remove_released_region((address)base, size);\n+    rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    ASSERT_TRUE(!rmr_found.is_valid());\n@@ -236,2 +228,1 @@\n-TEST_VM(CommittedVirtualMemoryTracker, test_committed_virtualmemory_region) {\n-\n+TEST_VM(NMTCommittedVirtualMemoryTracker, test_committed_virtualmemory_region) {\n@@ -254,1 +245,1 @@\n-TEST_VM(CommittedVirtualMemory, test_committed_in_range){\n+TEST_VM(NMTCommittedVirtualMemory, test_committed_in_range){\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":31,"deletions":40,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -59,6 +60,6 @@\n-static void diagnostic_print(ReservedMemoryRegion* rmr) {\n-  CommittedRegionIterator iter = rmr->iterate_committed_regions();\n-  LOG(\"In reserved region \" PTR_FORMAT \", size 0x%zx:\", p2i(rmr->base()), rmr->size());\n-  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n-    LOG(\"   committed region: \" PTR_FORMAT \", size 0x%zx\", p2i(region->base()), region->size());\n-  }\n+static void diagnostic_print(const ReservedMemoryRegion& rmr) {\n+  LOG(\"In reserved region \" PTR_FORMAT \", size %X:\", p2i(rmr.base()), rmr.size());\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n+    LOG(\"   committed region: \" PTR_FORMAT \", size %X\", p2i(region.base()), region.size());\n+    return true;\n+  });\n@@ -67,2 +68,1 @@\n-static void check_inner(ReservedMemoryRegion* rmr, R* regions, size_t regions_size, const char* file, int line) {\n-  CommittedRegionIterator iter = rmr->iterate_committed_regions();\n+static void check_inner(const ReservedMemoryRegion& rmr, R* regions, size_t regions_size, const char* file, int line) {\n@@ -77,1 +77,1 @@\n-  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n@@ -79,3 +79,3 @@\n-    EXPECT_EQ(region->base(), regions[i]._addr) << WHERE;\n-    EXPECT_EQ(region->size(), regions[i]._size) << WHERE;\n-    size += region->size();\n+    EXPECT_EQ(region.base(), regions[i]._addr) << WHERE;\n+    EXPECT_EQ(region.size(), regions[i]._size) << WHERE;\n+    size += region.size();\n@@ -83,1 +83,2 @@\n-  }\n+    return true;\n+  });\n@@ -86,1 +87,1 @@\n-  EXPECT_EQ(size, rmr->committed_size()) << WHERE;\n+  EXPECT_EQ(size, rmr.committed_size()) << WHERE;\n@@ -106,1 +107,2 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    ReservedMemoryRegion rmr = VirtualMemoryTracker::Instance::tree()->find_reserved_region(addr);\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n@@ -108,2 +110,2 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -117,1 +119,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -123,1 +125,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -129,1 +131,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n@@ -135,2 +137,2 @@\n-    rmr->remove_uncommitted_region(addr, 3 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -142,1 +144,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -148,1 +150,1 @@\n-      rmr->add_committed_region(addr, cs, stack2);\n+      rtree->commit_region(addr, cs, stack2);\n@@ -155,1 +157,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack2);\n+      rtree->commit_region(addr + 2 * cs, cs, stack2);\n@@ -163,2 +165,2 @@\n-    rmr->remove_uncommitted_region(addr, 3 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -168,0 +170,2 @@\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    rtree->tree().remove_all();\n@@ -181,3 +185,0 @@\n-    \/\/ Add the reserved memory\n-    VirtualMemoryTracker::add_reserved_region(addr, size, stack, mtTest);\n-\n@@ -185,1 +186,1 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n@@ -187,2 +188,2 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -196,2 +197,2 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n-      rmr->add_committed_region(addr + 3 * cs, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr + 3 * cs, 2 * cs, stack);\n@@ -204,1 +205,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, 2 * cs, stack);\n+      rtree->commit_region(addr + 2 * cs, 2 * cs, stack);\n@@ -210,2 +211,2 @@\n-    rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n-    ASSERT_EQ(rmr->committed_size(), 4 * cs);\n+    rtree->uncommit_region(addr + 2 * cs, cs);\n+    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n@@ -214,1 +215,1 @@\n-      rmr->add_committed_region(addr + cs, 2 * cs, stack);\n+      rtree->commit_region(addr + cs, 2 * cs, stack);\n@@ -220,2 +221,2 @@\n-    rmr->remove_uncommitted_region(addr, 5 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 5 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -227,2 +228,2 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n-      rmr->add_committed_region(addr + 3 * cs, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr + 3 * cs, 2 * cs, stack);\n@@ -235,1 +236,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, 2 * cs, stack2);\n+      rtree->commit_region(addr + 2 * cs, 2 * cs, stack2);\n@@ -243,3 +244,3 @@\n-    rmr->add_committed_region(addr, 5 * cs, stack);\n-    rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n-    ASSERT_EQ(rmr->committed_size(), 4 * cs);\n+    rtree->commit_region(addr, 5 * cs, stack);\n+    rtree->uncommit_region(addr + 2 * cs, cs);\n+    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n@@ -248,1 +249,1 @@\n-      rmr->add_committed_region(addr + cs, 2 * cs, stack2);\n+      rtree->commit_region(addr + cs, 2 * cs, stack2);\n@@ -257,0 +258,2 @@\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    rtree->tree().remove_all();\n@@ -272,1 +275,1 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n@@ -274,2 +277,3 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -283,1 +287,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -289,1 +293,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -295,1 +299,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -301,1 +305,1 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n@@ -307,1 +311,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -313,1 +317,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -319,1 +323,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n@@ -325,1 +329,1 @@\n-      rmr->add_committed_region(addr + 1 * cs, cs, stack);\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n@@ -331,2 +335,2 @@\n-    rmr->remove_uncommitted_region(addr, 3 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -336,2 +340,2 @@\n-    rmr->add_committed_region(addr,              cs, stack);\n-    rmr->add_committed_region(addr + 2 * cs, 3 * cs, stack);\n+    rtree->commit_region(addr,              cs, stack);\n+    rtree->commit_region(addr + 2 * cs, 3 * cs, stack);\n@@ -339,1 +343,1 @@\n-    rmr->add_committed_region(addr + 2 * cs,     cs, stack);\n+    rtree->commit_region(addr + 2 * cs,     cs, stack);\n@@ -346,1 +350,1 @@\n-    rmr->add_committed_region(addr + 3 * cs,     cs, stack);\n+    rtree->commit_region(addr + 3 * cs,     cs, stack);\n@@ -353,1 +357,1 @@\n-    rmr->add_committed_region(addr + 4 * cs,     cs, stack);\n+    rtree->commit_region(addr + 4 * cs,     cs, stack);\n@@ -361,2 +365,2 @@\n-    rmr->remove_uncommitted_region(addr, 5 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 5 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -367,1 +371,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -373,1 +377,1 @@\n-      rmr->add_committed_region(addr, cs, stack2);\n+      rtree->commit_region(addr, cs, stack2);\n@@ -379,1 +383,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -386,1 +390,1 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n@@ -392,1 +396,1 @@\n-      rmr->add_committed_region(addr, cs, stack2);\n+      rtree->commit_region(addr, cs, stack2);\n@@ -399,1 +403,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack2);\n+      rtree->commit_region(addr + cs, cs, stack2);\n@@ -405,1 +409,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack2);\n+      rtree->commit_region(addr + 2 * cs, cs, stack2);\n@@ -411,1 +415,1 @@\n-      rmr->add_committed_region(addr + 1 * cs, cs, stack);\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n@@ -431,0 +435,2 @@\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    rtree->tree().remove_all();\n@@ -445,1 +451,1 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n@@ -447,2 +453,2 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -454,1 +460,1 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n+      rtree->commit_region(addr, 3 * cs, stack);\n@@ -459,1 +465,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -464,3 +470,3 @@\n-      rmr->add_committed_region(addr + 0 * cs, cs, stack);\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n-      rmr->add_committed_region(addr + 4 * cs, cs, stack);\n+      rtree->commit_region(addr + 0 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 4 * cs, cs, stack);\n@@ -469,1 +475,1 @@\n-        rmr->remove_uncommitted_region(addr, cs);\n+        rtree->uncommit_region(addr, cs);\n@@ -476,1 +482,1 @@\n-      rmr->add_committed_region(addr,          cs, stack);\n+      rtree->commit_region(addr,          cs, stack);\n@@ -479,1 +485,1 @@\n-        rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n+        rtree->uncommit_region(addr + 2 * cs, cs);\n@@ -486,1 +492,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n@@ -489,1 +495,1 @@\n-        rmr->remove_uncommitted_region(addr + 4 * cs, cs);\n+        rtree->uncommit_region(addr + 4 * cs, cs);\n@@ -495,1 +501,1 @@\n-      rmr->remove_uncommitted_region(addr, 5 * cs);\n+      rtree->uncommit_region(addr, 5 * cs);\n@@ -500,2 +506,2 @@\n-      rmr->add_committed_region(addr + 1 * cs, cs, stack);\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -506,2 +512,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 1 * cs, cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 1 * cs, cs);\n@@ -512,1 +518,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -517,2 +523,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 0 * cs, cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 0 * cs, cs);\n@@ -522,1 +528,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -527,2 +533,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 2 * cs, cs);\n@@ -532,1 +538,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -537,2 +543,2 @@\n-      rmr->add_committed_region(addr + 1 * cs, 4 * cs, stack);\n-      rmr->remove_uncommitted_region(addr, 2 * cs);\n+      rtree->commit_region(addr + 1 * cs, 4 * cs, stack);\n+      rtree->uncommit_region(addr, 2 * cs);\n@@ -542,1 +548,1 @@\n-      rmr->remove_uncommitted_region(addr + 1 * cs, 4 * cs);\n+      rtree->uncommit_region(addr + 1 * cs, 4 * cs);\n@@ -547,2 +553,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 2 * cs, 2 * cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 2 * cs, 2 * cs);\n@@ -552,1 +558,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -572,1 +578,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":114,"deletions":108,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"utilities\/intn_t.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Sanity tests for off-by-one errors\n+static_assert(intn_t<1>::min == -1 && intn_t<1>::max == 0, \"\");\n+static_assert(intn_t<2>::min == -2 && intn_t<2>::max == 1, \"\");\n+static_assert(intn_t<3>::min == -4 && intn_t<3>::max == 3, \"\");\n+static_assert(uintn_t<1>::max == 1, \"\");\n+static_assert(uintn_t<2>::max == 3, \"\");\n+static_assert(uintn_t<3>::max == 7, \"\");\n+\n+template <unsigned int nbits>\n+static void test_intn_t() {\n+  static_assert(std::numeric_limits<intn_t<nbits>>::min() <= intn_t<nbits>(-1) &&\n+                intn_t<nbits>(-1) < intn_t<nbits>(0) &&\n+                intn_t<nbits>(0) <= std::numeric_limits<intn_t<nbits>>::max(), \"basic sanity\");\n+  constexpr int period = intn_t<nbits>::max - intn_t<nbits>::min + 1;\n+  for (int i = std::numeric_limits<signed char>::min(); i < std::numeric_limits<signed char>::max(); i++) {\n+    ASSERT_EQ(intn_t<nbits>(i), intn_t<nbits>(i + period));\n+    ASSERT_EQ(int(intn_t<nbits>(i)), int(intn_t<nbits>(i + period)));\n+  }\n+  for (int i = intn_t<nbits>::min; i <= intn_t<nbits>::max; i++) {\n+    ASSERT_EQ(i, int(intn_t<nbits>(i)));\n+    if (i > intn_t<nbits>::min) {\n+      ASSERT_TRUE(intn_t<nbits>(i - 1) < intn_t<nbits>(i));\n+    } else {\n+      ASSERT_TRUE(intn_t<nbits>(i - 1) > intn_t<nbits>(i));\n+    }\n+    if (i < intn_t<nbits>::max) {\n+      ASSERT_TRUE(intn_t<nbits>(i) < intn_t<nbits>(i + 1));\n+    } else {\n+      ASSERT_TRUE(intn_t<nbits>(i) > intn_t<nbits>(i + 1));\n+    }\n+  }\n+}\n+\n+TEST(utilities, intn_t) {\n+  test_intn_t<1>();\n+  test_intn_t<2>();\n+  test_intn_t<3>();\n+  test_intn_t<4>();\n+  test_intn_t<5>();\n+  test_intn_t<6>();\n+  test_intn_t<7>();\n+  test_intn_t<8>();\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_intn_t.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"utilities\/packedTable.hpp\"\n+#include \"unittest.hpp\"\n+\n+class Supplier: public PackedTableBuilder::Supplier {\n+  uint32_t* _keys;\n+  uint32_t* _values;\n+  size_t _num_keys;\n+\n+public:\n+  Supplier(uint32_t* keys, uint32_t* values, size_t num_keys):\n+    _keys(keys), _values(values), _num_keys(num_keys) {}\n+\n+  bool next(uint32_t* key, uint32_t* value) override {\n+    if (_num_keys == 0) {\n+      return false;\n+    }\n+    *key = *_keys;\n+    ++_keys;\n+    if (_values != nullptr) {\n+      *value = *_values;\n+      ++_values;\n+    } else {\n+      *value = 0;\n+    }\n+    --_num_keys;\n+    return true;\n+  }\n+};\n+\n+class Comparator: public PackedTableLookup::Comparator {\n+  uint32_t _current;\n+\n+public:\n+  int compare_to(uint32_t key) override {\n+    return _current < key ? -1 : (_current > key ? 1 : 0);\n+  }\n+\n+  void reset(uint32_t key) DEBUG_ONLY(override) {\n+    _current = key;\n+  }\n+};\n+\n+static void test(uint32_t max_key, uint32_t max_value, unsigned int length) {\n+  if (length > max_key + 1) {\n+    \/\/ can't generate more keys, as keys must be unique\n+    return;\n+  }\n+  PackedTableBuilder builder(max_key, max_value);\n+  size_t table_length = length * builder.element_bytes();\n+  u1* table = new u1[table_length];\n+\n+  uint32_t* keys = new uint32_t[length];\n+  uint32_t* values = max_value != 0 ? new uint32_t[length] : nullptr;\n+  for (unsigned int i = 0; i < length; ++i) {\n+    keys[i] = i;\n+    if (values != nullptr) {\n+      values[i] = i % max_value;\n+    }\n+  }\n+  Supplier sup(keys, values, length);\n+  builder.fill(table, table_length, sup);\n+\n+  Comparator comparator;\n+  PackedTableLookup lookup(max_key, max_value, table, table_length);\n+#ifdef ASSERT\n+  lookup.validate_order(comparator);\n+#endif\n+\n+  for (unsigned int i = 0; i < length; ++i) {\n+    uint32_t key, value;\n+    comparator.reset(keys[i]);\n+    EXPECT_TRUE(lookup.search(comparator, &key, &value));\n+    EXPECT_EQ(key, keys[i]);\n+    if (values != nullptr) {\n+      EXPECT_EQ(value, values[i]);\n+    } else {\n+      EXPECT_EQ(value, 0U);\n+    }\n+  }\n+\n+  delete[] keys;\n+  delete[] values;\n+}\n+\n+static void test_with_bits(uint32_t max_key, uint32_t max_value) {\n+  \/\/ Some small sizes\n+  for (unsigned int i = 0; i <= 100; ++i) {\n+    test(max_key, max_value, i);\n+  }\n+  test(max_key, max_value, 10000);\n+}\n+\n+TEST(PackedTableLookup, lookup) {\n+  for (int key_bits = 1; key_bits <= 32; ++key_bits) {\n+    for (int value_bits = 0; value_bits <= 32; ++value_bits) {\n+      test_with_bits(static_cast<uint32_t>((1ULL << key_bits) - 1),\n+                     static_cast<uint32_t>((1ULL << value_bits) - 1));\n+    }\n+  }\n+}\n+\n+TEST(PackedTableBase, element_bytes) {\n+  {\n+    PackedTableBuilder builder(1, 0);\n+    EXPECT_EQ(builder.element_bytes(), 1U);\n+  }\n+  {\n+    PackedTableBuilder builder(15, 15);\n+    EXPECT_EQ(builder.element_bytes(), 1U);\n+  }\n+  {\n+    PackedTableBuilder builder(15, 16);\n+    EXPECT_EQ(builder.element_bytes(), 2U);\n+  }\n+  {\n+    PackedTableBuilder builder(31, 7);\n+    EXPECT_EQ(builder.element_bytes(), 1U);\n+  }\n+  {\n+    PackedTableBuilder builder(32, 7);\n+    EXPECT_EQ(builder.element_bytes(), 2U);\n+  }\n+  {\n+    PackedTableBuilder builder(-1, 0);\n+    EXPECT_EQ(builder.element_bytes(), 4U);\n+  }\n+  {\n+    PackedTableBuilder builder(-1, 1);\n+    EXPECT_EQ(builder.element_bytes(), 5U);\n+  }\n+  {\n+    PackedTableBuilder builder(-1, -1);\n+    EXPECT_EQ(builder.element_bytes(), 8U);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_packedTable.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-serviceability\/jvmti\/vthread\/SuspendWithInterruptLock\/SuspendWithInterruptLock.java#default 8312064 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-compiler\/startup\/StartupOutput.java 8358129 windows-all\n+compiler\/c2\/aarch64\/TestStaticCallStub.java 8359963 linux-aarch64,macosx-aarch64\n@@ -136,0 +136,1 @@\n+runtime\/valhalla\/inlinetypes\/classloading\/ConcurrentClassLoadingTest.java 8367412 linux-aarch64\n@@ -302,1 +303,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/TestDescription.java 8358094 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @library \/test\/lib \/\n+ * @bug 8359200\n+ * @key randomness\n+ * @requires vm.flagless & vm.compiler2.enabled & vm.debug == true\n+ * @summary Test that -XX:OptoNodeListSize does not crash the VM.\n+ * @run driver compiler.arguments.TestOptoNodeListSize\n+ *\/\n+\n+package compiler.arguments;\n+\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Utils;\n+\n+public class TestOptoNodeListSize {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            int size = RANDOM.nextInt(1000) + 1;\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:OptoNodeListSize=\" + size,\n+                \"-Xcomp\", \"-XX:-TieredCompilation\", \"compiler.arguments.TestOptoNodeListSize\", \"run\");\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            output.shouldHaveExitValue(0);\n+        } else {\n+            System.out.println(\"Test passed.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestOptoNodeListSize.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that C1 respects that static initializers can have memory side effects.\n+ * @bug 8357782\n+ * @requires vm.compiler1.enabled\n+ * @comment Since static initializers only execute in the first execution of the class initializer, we need -Xcomp.\n+ * @run main\/othervm -Xcomp -XX:TieredStopAtLevel=1 -XX:CompileCommand=compileonly,compiler\/c1\/A$B.test compiler.c1.TestStaticInitializerSideEffect\n+ *\/\n+\n+package compiler.c1;\n+\n+public class TestStaticInitializerSideEffect {\n+    public static void main(String[] args) {\n+        A.B.test();\n+    }\n+}\n+\n+class A {\n+    static class B {\n+        static String field;\n+\n+        static void test() {\n+            \/\/ This unused variable triggers local value numbering to remove\n+            \/\/ the field load in the constructor below if it is not killed\n+            \/\/ before.\n+            String tmp = field;\n+            \/\/ The class initializer of C should kill the LVN effect of tmp due\n+            \/\/ to the memory side effects of the static initializer.\n+            new C(field);\n+        }\n+    }\n+\n+    static class C {\n+        \/\/ When executing the class initializer, this has a side effect.\n+        static {\n+            B.field = \"Hello\";\n+        }\n+\n+        C(String val) {\n+            \/\/ If C1 does not respect that side effect, we crash here.\n+            if (val == null) {\n+                throw new RuntimeException(\"Should not reach here\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestStaticInitializerSideEffect.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Run with -Xcomp to test -XX:VerifyIterativeGVN=11 in debug builds.\n+ * @summary Run with -Xcomp to test -XX:VerifyIterativeGVN=1111 in debug builds.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:VerifyIterativeGVN=11 compiler.c2.TestVerifyIterativeGVN\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:VerifyIterativeGVN=1111 compiler.c2.TestVerifyIterativeGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.aarch64;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @summary Calls to c2i interface stubs should be generated with near branches\n+ * for segmented code cache up to 250MB\n+ * @library \/test\/lib \/\n+ *\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.debug == false\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run driver compiler.c2.aarch64.TestStaticCallStub\n+ *\/\n+public class TestStaticCallStub {\n+\n+    static String[] nearStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"b\"};\n+    static String[] farStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"mov\", \"movk\", \"movk\", \"br\"};\n+\n+    static String extractOpcode(String line) {\n+        line = line.trim();\n+        int semicolonIndex = line.indexOf(';');\n+        if (semicolonIndex != -1) {\n+            line = line.substring(0, semicolonIndex).trim();\n+        }\n+\n+        String[] words = line.split(\"\\\\s+\");\n+        if (words.length > 1) {\n+            return words[1];\n+        }\n+\n+        return \"\";\n+    }\n+\n+    static List<String> extractOpcodesN(ListIterator<String> itr, int n) {\n+        List<String> extractedOpcodes = new ArrayList<>();\n+\n+        while (itr.hasNext() && extractedOpcodes.size() < n) {\n+            String opcode = extractOpcode(itr.next());\n+            if (!opcode.isEmpty()) {\n+                extractedOpcodes.add(opcode);\n+            }\n+        }\n+\n+        return extractedOpcodes;\n+    }\n+\n+    static void verifyNearStaticCall(ListIterator<String> itr) {\n+        List<String> extractedOpcodes = extractOpcodesN(itr, nearStaticCallOpcodeSeq.length);\n+\n+        if (!Arrays.asList(nearStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n+            throw new RuntimeException(\"for code cache < 250MB the static call stub is expected to be implemented using near branch\");\n+        }\n+\n+        return;\n+    }\n+\n+    static void verifyFarStaticCall(ListIterator<String> itr) {\n+        List<String> extractedOpcodes = extractOpcodesN(itr, farStaticCallOpcodeSeq.length);\n+\n+        if (!Arrays.asList(farStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n+            throw new RuntimeException(\"for code cache > 250MB the static call stub is expected to be implemented using far branch\");\n+        }\n+\n+        return;\n+    }\n+\n+    static void runVM(boolean bigCodeCache) throws Exception {\n+        String className = TestStaticCallStub.class.getName();\n+        String[] procArgs = {\n+            \"-XX:-Inline\",\n+            \"-Xcomp\",\n+            \"-Xbatch\",\n+            \"-XX:+TieredCompilation\",\n+            \"-XX:+SegmentedCodeCache\",\n+            \"-XX:ReservedCodeCacheSize=\" + (bigCodeCache ? \"256M\" : \"200M\"),\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n+            className};\n+\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(procArgs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        List<String> lines = output.asLines();\n+\n+        ListIterator<String> itr = lines.listIterator();\n+        while (itr.hasNext()) {\n+            String line = itr.next();\n+            if (line.contains(\"{static_stub}\")) {\n+                itr.previous();\n+                if (bigCodeCache) {\n+                    verifyFarStaticCall(itr);\n+                } else {\n+                    verifyNearStaticCall(itr);\n+                }\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(\"Assembly output: static call stub is not found\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            \/\/ Main VM: fork VM with options\n+            runVM(true);\n+            runVM(false);\n+            return;\n+        }\n+        if (args.length > 0) {\n+            \/\/ We are in a forked VM. Just exit\n+            System.out.println(\"Ok\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestStaticCallStub.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8351645\n+ * @summary C2: ExpandBitsNode::Ideal hits assert because of TOP input\n+ * @library \/test\/lib \/\n+ * @run driver compiler.intrinsics.TestCompressExpandTopInput\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+public class TestCompressExpandTopInput {\n+\n+    public static int [] array_I0 = IntStream.range(0, 10000).toArray();\n+    public static int [] array_I1 = IntStream.range(10000, 20000).toArray();\n+    public static long [] array_L0 = LongStream.range(0, 10000).toArray();\n+    public static long [] array_L1 = LongStream.range(10000, 20000).toArray();\n+\n+    public static int oneI = 1;\n+    public static long oneL = 1L;\n+\n+    public static long [] GOLD_COMPRESS_LONG = testCompressBitsLong();\n+    public static long [] GOLD_EXPAND_LONG = testExpandBitsLong();\n+    public static int [] GOLD_COMPRESS_INT = testCompressBitsInt();\n+    public static int [] GOLD_EXPAND_INT = testExpandBitsInt();\n+\n+    @Test\n+    public static long[] testExpandBitsLong() {\n+        long[] out = new long[10000];\n+        for (int i = 0; i < out.length; i++) {\n+            long y = array_L0[i] % oneL;\n+            long x = (array_L1[i] | 4294967298L) << -7640610671680100954L;\n+            out[i] = Long.expand(y, x);\n+        }\n+        return out;\n+    }\n+\n+    @Check(test=\"testExpandBitsLong\")\n+    public static void checkExpandBitsLong(long [] actual) {\n+        for (int i = 0; i < GOLD_EXPAND_LONG.length; i++) {\n+            Verify.checkEQ(GOLD_EXPAND_LONG[i], actual[i]);\n+        }\n+    }\n+\n+    @Test\n+    public static long[] testCompressBitsLong() {\n+        long[] out = new long[10000];\n+        for (int i = 0; i < out.length; i++) {\n+            long y = array_L0[i] % oneL;\n+            long x = (array_L1[i] | 4294967298L) << -7640610671680100954L;\n+            out[i] = Long.compress(y, x);\n+        }\n+        return out;\n+    }\n+\n+    @Check(test=\"testCompressBitsLong\")\n+    public static void checkCompressBitsLong(long [] actual) {\n+        for (int i = 0; i < GOLD_COMPRESS_LONG.length; i++) {\n+            Verify.checkEQ(GOLD_COMPRESS_LONG[i], actual[i]);\n+        }\n+    }\n+\n+    @Test\n+    public static int[] testExpandBitsInt() {\n+        int[] out = new int[10000];\n+        for (int i = 0; i < out.length; i++) {\n+            int y = array_I0[i] % oneI;\n+            int x = (array_I1[i] | 22949672) << -76406101;\n+            out[i] = Integer.expand(y, x);\n+        }\n+        return out;\n+    }\n+\n+    @Check(test=\"testExpandBitsInt\")\n+    public static void checkExpandBitsInt(int [] actual) {\n+        for (int i = 0; i < GOLD_EXPAND_INT.length; i++) {\n+            Verify.checkEQ(GOLD_EXPAND_INT[i], actual[i]);\n+        }\n+    }\n+\n+    @Test\n+    public static int[] testCompressBitsInt() {\n+        int[] out = new int[10000];\n+        for (int i = 0; i < out.length; i++) {\n+            int y = array_I0[i] % oneI;\n+            int x = (array_I1[i] | 429497) << -764061068;\n+            out[i] = Integer.compress(y, x);\n+        }\n+        return out;\n+    }\n+\n+    @Check(test=\"testCompressBitsInt\")\n+    public static void checkCompressBitsInt(int [] actual) {\n+        for (int i = 0; i < GOLD_COMPRESS_INT.length; i++) {\n+            Verify.checkEQ(GOLD_COMPRESS_INT[i], actual[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+StressIGVN\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestCompressExpandTopInput.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,1005 @@\n+\/*\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8358892\n+ * @summary The test is to trigger code path of BoolTest::ge\/gt in C2_MacroAssembler::enc_cmove_cmp_fp\n+ * @requires os.arch == \"riscv64\"\n+ * @requires vm.debug\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestFPComparison2\n+ *\/\n+public class TestFPComparison2 {\n+    static final double[] DOUBLES = new double[] {\n+        Double.NEGATIVE_INFINITY,\n+        -Double.MAX_VALUE,\n+        -1.0,\n+        -Double.MIN_VALUE,\n+        -0.0,\n+        0.0,\n+        Double.MIN_VALUE,\n+        1.0,\n+        Double.MAX_VALUE,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+    };\n+\n+    static final float[] FLOATS = new float[] {\n+        Float.NEGATIVE_INFINITY,\n+        -Float.MAX_VALUE,\n+        -1.0F,\n+        -Float.MIN_VALUE,\n+        -0.0F,\n+        0.0F,\n+        Float.MIN_VALUE,\n+        1.0F,\n+        Float.MAX_VALUE,\n+        Float.POSITIVE_INFINITY,\n+        Float.NaN,\n+    };\n+\n+    static final int[] INTS = new int[] {\n+        Integer.MIN_VALUE,\n+        -100,\n+        -1,\n+        0,\n+        1,\n+        100,\n+        Integer.MAX_VALUE,\n+    };\n+\n+    public static void main(String[] args) {\n+        List<String> options = List.of(\"-XX:-TieredCompilation\", \"-Xlog:jit+compilation=trace\");\n+        \/\/ Booltest::ge\n+        TestFramework framework = new TestFramework(Test_ge_1.class);\n+        framework.addFlags(options.toArray(new String[0])).start();\n+\n+        framework = new TestFramework(Test_ge_2.class);\n+        framework.addFlags(options.toArray(new String[0])).start();\n+\n+        \/\/ Booltest::gt\n+        framework = new TestFramework(Test_gt_1.class);\n+        framework.addFlags(options.toArray(new String[0])).start();\n+\n+        framework = new TestFramework(Test_gt_2.class);\n+        framework.addFlags(options.toArray(new String[0])).start();\n+    }\n+}\n+\n+class Test_ge_1 {\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_fixed_1_0(float x, float y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x > y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x <= y\n+        return !(x <= y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_fixed_1_0(float x, float y) {\n+        return !(x <= y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_fixed_1_0(double x, double y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x > y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x <= y\n+        return !(x <= y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_fixed_1_0(double x, double y) {\n+        return !(x <= y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_fixed_0_1(float x, float y) {\n+        return !(x <= y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_fixed_0_1(float x, float y) {\n+        return !(x <= y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_fixed_0_1(double x, double y) {\n+        return !(x <= y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_fixed_0_1(double x, double y) {\n+        return !(x <= y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_fixed_10_20(float x, float y) {\n+        return !(x <= y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_fixed_10_20(float x, float y) {\n+        return !(x <= y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_fixed_10_20(double x, double y) {\n+        return !(x <= y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_fixed_10_20(double x, double y) {\n+        return !(x <= y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_variable_results(float x, float y, int a, int b) {\n+        return !(x <= y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_variable_results(float x, float y, int a, int b) {\n+        return !(x <= y) ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_variable_results(double x, double y, int a, int b) {\n+        return !(x <= y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_variable_results(double x, double y, int a, int b) {\n+        return !(x <= y) ? a : b;\n+    }\n+\n+    @Run(test = {\"test_float_BoolTest_ge_fixed_1_0\", \"test_double_BoolTest_ge_fixed_1_0\",\n+                 \"test_float_BoolTest_ge_fixed_0_1\", \"test_double_BoolTest_ge_fixed_0_1\",\n+                 \"test_float_BoolTest_ge_fixed_10_20\", \"test_double_BoolTest_ge_fixed_10_20\",\n+                 \"test_float_BoolTest_ge_variable_results\", \"test_double_BoolTest_ge_variable_results\"})\n+    public void runTests() {\n+        int err = 0;\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_ge_fixed_1_0(x, y);\n+                int expected = golden_float_BoolTest_ge_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (ge, 1, 0), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_ge_fixed_1_0(x, y);\n+                int expected = golden_double_BoolTest_ge_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (ge, 1, 0), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_ge_fixed_0_1(x, y);\n+                int expected = golden_float_BoolTest_ge_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (ge, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_ge_fixed_0_1(x, y);\n+                int expected = golden_double_BoolTest_ge_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (ge, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_ge_fixed_10_20(x, y);\n+                int expected = golden_float_BoolTest_ge_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (ge, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_ge_fixed_10_20(x, y);\n+                int expected = golden_double_BoolTest_ge_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (ge, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_float_BoolTest_ge_variable_results(x, y, a, b);\n+                        int expected = golden_float_BoolTest_ge_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Float failed (ge), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_double_BoolTest_ge_variable_results(x, y, a, b);\n+                        int expected = golden_double_BoolTest_ge_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Double failed (ge), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (err != 0) {\n+            throw new RuntimeException(\"Some tests failed\");\n+        }\n+    }\n+}\n+\n+class Test_ge_2 {\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_fixed_1_0(float x, float y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x < y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x >= y\n+        return !(x >= y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_fixed_1_0(float x, float y) {\n+        return !(x >= y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_fixed_1_0(double x, double y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x < y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x >= y\n+        return !(x >= y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_fixed_1_0(double x, double y) {\n+        return !(x >= y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_fixed_0_1(float x, float y) {\n+        return !(x >= y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_fixed_0_1(float x, float y) {\n+        return !(x >= y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_fixed_0_1(double x, double y) {\n+        return !(x >= y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_fixed_0_1(double x, double y) {\n+        return !(x >= y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_fixed_10_20(float x, float y) {\n+        return !(x >= y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_fixed_10_20(float x, float y) {\n+        return !(x >= y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_fixed_10_20(double x, double y) {\n+        return !(x >= y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_fixed_10_20(double x, double y) {\n+        return !(x >= y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_ge_variable_results(float x, float y, int a, int b) {\n+        return !(x >= y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_ge_variable_results(float x, float y, int a, int b) {\n+        return !(x >= y) ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_ge_variable_results(double x, double y, int a, int b) {\n+        return !(x >= y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_ge_variable_results(double x, double y, int a, int b) {\n+        return !(x >= y) ? a : b;\n+    }\n+\n+    @Run(test = {\"test_float_BoolTest_ge_fixed_1_0\", \"test_double_BoolTest_ge_fixed_1_0\",\n+                 \"test_float_BoolTest_ge_fixed_0_1\", \"test_double_BoolTest_ge_fixed_0_1\",\n+                 \"test_float_BoolTest_ge_fixed_10_20\", \"test_double_BoolTest_ge_fixed_10_20\",\n+                 \"test_float_BoolTest_ge_variable_results\", \"test_double_BoolTest_ge_variable_results\"})\n+    public void runTests() {\n+        int err = 0;\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_ge_fixed_1_0(x, y);\n+                int expected = golden_float_BoolTest_ge_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (ge), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_ge_fixed_1_0(x, y);\n+                int expected = golden_double_BoolTest_ge_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (ge), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_ge_fixed_0_1(x, y);\n+                int expected = golden_float_BoolTest_ge_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (ge, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_ge_fixed_0_1(x, y);\n+                int expected = golden_double_BoolTest_ge_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (ge, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_ge_fixed_10_20(x, y);\n+                int expected = golden_float_BoolTest_ge_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (ge, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_ge_fixed_10_20(x, y);\n+                int expected = golden_double_BoolTest_ge_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (ge, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_float_BoolTest_ge_variable_results(x, y, a, b);\n+                        int expected = golden_float_BoolTest_ge_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Float failed (ge), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_double_BoolTest_ge_variable_results(x, y, a, b);\n+                        int expected = golden_double_BoolTest_ge_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Double failed (ge), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (err != 0) {\n+            throw new RuntimeException(\"Some tests failed\");\n+        }\n+    }\n+}\n+\n+class Test_gt_1 {\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_fixed_1_0(float x, float y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x >= y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x < y\n+        return !(x < y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_fixed_1_0(float x, float y) {\n+        return !(x < y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_fixed_1_0(double x, double y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x >= y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x < y\n+        return !(x < y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_fixed_1_0(double x, double y) {\n+        return !(x < y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_fixed_0_1(float x, float y) {\n+        return !(x < y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_fixed_0_1(float x, float y) {\n+        return !(x < y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_fixed_0_1(double x, double y) {\n+        return !(x < y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_fixed_0_1(double x, double y) {\n+        return !(x < y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_fixed_10_20(float x, float y) {\n+        return !(x < y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_fixed_10_20(float x, float y) {\n+        return !(x < y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_fixed_10_20(double x, double y) {\n+        return !(x < y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_fixed_10_20(double x, double y) {\n+        return !(x < y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_variable_results(float x, float y, int a, int b) {\n+        return !(x < y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_variable_results(float x, float y, int a, int b) {\n+        return !(x < y) ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_variable_results(double x, double y, int a, int b) {\n+        return !(x < y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_variable_results(double x, double y, int a, int b) {\n+        return !(x < y) ? a : b;\n+    }\n+\n+    @Run(test = {\"test_float_BoolTest_gt_fixed_1_0\", \"test_double_BoolTest_gt_fixed_1_0\",\n+                 \"test_float_BoolTest_gt_fixed_0_1\", \"test_double_BoolTest_gt_fixed_0_1\",\n+                 \"test_float_BoolTest_gt_fixed_10_20\", \"test_double_BoolTest_gt_fixed_10_20\",\n+                 \"test_float_BoolTest_gt_variable_results\", \"test_double_BoolTest_gt_variable_results\"})\n+    public void runTests() {\n+        int err = 0;\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_gt_fixed_1_0(x, y);\n+                int expected = golden_float_BoolTest_gt_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (gt), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_gt_fixed_1_0(x, y);\n+                int expected = golden_double_BoolTest_gt_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (gt), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_gt_fixed_0_1(x, y);\n+                int expected = golden_float_BoolTest_gt_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (gt, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_gt_fixed_0_1(x, y);\n+                int expected = golden_double_BoolTest_gt_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (gt, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_gt_fixed_10_20(x, y);\n+                int expected = golden_float_BoolTest_gt_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (gt, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_gt_fixed_10_20(x, y);\n+                int expected = golden_double_BoolTest_gt_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (gt, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_float_BoolTest_gt_variable_results(x, y, a, b);\n+                        int expected = golden_float_BoolTest_gt_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Float failed (gt), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_double_BoolTest_gt_variable_results(x, y, a, b);\n+                        int expected = golden_double_BoolTest_gt_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Double failed (gt), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (err != 0) {\n+            throw new RuntimeException(\"Some tests failed\");\n+        }\n+    }\n+}\n+\n+class Test_gt_2 {\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_fixed_1_0(float x, float y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x <= y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x > y\n+        return !(x > y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_fixed_1_0(float x, float y) {\n+        return !(x > y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_fixed_1_0(double x, double y) {\n+        \/\/ return 1\n+        \/\/      when either x or y is NaN\n+        \/\/      when neither is NaN, and x <= y\n+        \/\/ return 0\n+        \/\/      when neither is NaN, and x > y\n+        return !(x > y) ? 1 : 0;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_fixed_1_0(double x, double y) {\n+        return !(x > y) ? 1 : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_fixed_0_1(float x, float y) {\n+        return !(x > y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_fixed_0_1(float x, float y) {\n+        return !(x > y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_fixed_0_1(double x, double y) {\n+        return !(x > y) ? 0 : 1;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_fixed_0_1(double x, double y) {\n+        return !(x > y) ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_fixed_10_20(float x, float y) {\n+        return !(x > y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_fixed_10_20(float x, float y) {\n+        return !(x > y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_fixed_10_20(double x, double y) {\n+        return !(x > y) ? 10 : 20;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_fixed_10_20(double x, double y) {\n+        return !(x > y) ? 10 : 20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_float_BoolTest_gt_variable_results(float x, float y, int a, int b) {\n+        return !(x > y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_float_BoolTest_gt_variable_results(float x, float y, int a, int b) {\n+        return !(x > y) ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMOVE_I, \"1\"})\n+    public static int test_double_BoolTest_gt_variable_results(double x, double y, int a, int b) {\n+        return !(x > y) ? a : b;\n+    }\n+    @DontCompile\n+    public static int golden_double_BoolTest_gt_variable_results(double x, double y, int a, int b) {\n+        return !(x > y) ? a : b;\n+    }\n+\n+    @Run(test = {\"test_float_BoolTest_gt_fixed_1_0\", \"test_double_BoolTest_gt_fixed_1_0\",\n+                 \"test_float_BoolTest_gt_fixed_0_1\", \"test_double_BoolTest_gt_fixed_0_1\",\n+                 \"test_float_BoolTest_gt_fixed_10_20\", \"test_double_BoolTest_gt_fixed_10_20\",\n+                 \"test_float_BoolTest_gt_variable_results\", \"test_double_BoolTest_gt_variable_results\"})\n+    public void runTests() {\n+        int err = 0;\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_gt_fixed_1_0(x, y);\n+                int expected = golden_float_BoolTest_gt_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (gt), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_gt_fixed_1_0(x, y);\n+                int expected = golden_double_BoolTest_gt_fixed_1_0(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (gt), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_gt_fixed_0_1(x, y);\n+                int expected = golden_float_BoolTest_gt_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (gt, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_gt_fixed_0_1(x, y);\n+                int expected = golden_double_BoolTest_gt_fixed_0_1(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (gt, 0, 1), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                int actual = test_float_BoolTest_gt_fixed_10_20(x, y);\n+                int expected = golden_float_BoolTest_gt_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Float failed (gt, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                int actual = test_double_BoolTest_gt_fixed_10_20(x, y);\n+                int expected = golden_double_BoolTest_gt_fixed_10_20(x, y);\n+                if (actual != expected) {\n+                    System.out.println(\"Double failed (gt, 10, 20), x: \" + x + \", y: \" + y +\n+                                        \", actual: \" + actual + \", expected: \" + expected);\n+                    err++;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.FLOATS.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.FLOATS.length; j++) {\n+                float x = TestFPComparison2.FLOATS[i];\n+                float y = TestFPComparison2.FLOATS[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_float_BoolTest_gt_variable_results(x, y, a, b);\n+                        int expected = golden_float_BoolTest_gt_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Float failed (gt), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < TestFPComparison2.DOUBLES.length; i++) {\n+            for (int j = 0; j < TestFPComparison2.DOUBLES.length; j++) {\n+                double x = TestFPComparison2.DOUBLES[i];\n+                double y = TestFPComparison2.DOUBLES[j];\n+                for (int m = 0; m < TestFPComparison2.INTS.length; m++) {\n+                    for (int n = 0; n < TestFPComparison2.INTS.length; n++) {\n+                        int a = TestFPComparison2.INTS[m];\n+                        int b = TestFPComparison2.INTS[n];\n+                        int actual = test_double_BoolTest_gt_variable_results(x, y, a, b);\n+                        int expected = golden_double_BoolTest_gt_variable_results(x, y, a, b);\n+                        if (actual != expected) {\n+                            System.out.println(\"Double failed (gt), x: \" + x + \", y: \" + y + \", a: \" + a + \", b: \" + b +\n+                                               \", actual: \" + actual + \", expected: \" + expected);\n+                            err++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (err != 0) {\n+            throw new RuntimeException(\"Some tests failed\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFPComparison2.java","additions":1005,"deletions":0,"binary":false,"changes":1005,"status":"added"},{"patch":"@@ -191,1 +191,1 @@\n-        long minUseSpace = WHITE_BOX.getUintxVMFlag(\"CodeCacheMinimumUseSpace\");\n+        long minUseSpace = WHITE_BOX.getSizeTVMFlag(\"CodeCacheMinimumUseSpace\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-            = WhiteBox.getWhiteBox().getUintxVMFlag(\"CodeCacheSegmentSize\");\n+            = WhiteBox.getWhiteBox().getSizeTVMFlag(\"CodeCacheSegmentSize\");\n@@ -46,1 +46,1 @@\n-            = WhiteBox.getWhiteBox().getUintxVMFlag(\"CodeCacheMinBlockLength\");\n+            = WhiteBox.getWhiteBox().getSizeTVMFlag(\"CodeCacheMinBlockLength\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/CodeCacheUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-            = Helper.WHITE_BOX.getUintxVMFlag(\"ReservedCodeCacheSize\");\n+            = Helper.WHITE_BOX.getSizeTVMFlag(\"ReservedCodeCacheSize\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/RandomAllocationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    private static final long largeBlobSize = Helper.WHITE_BOX.getUintxVMFlag(\"ReservedCodeCacheSize\") >> 6;\n-    private static final long codeCacheMinBlockLength = Helper.WHITE_BOX.getUintxVMFlag(\"CodeCacheMinBlockLength\");\n+    private static final long largeBlobSize = Helper.WHITE_BOX.getSizeTVMFlag(\"ReservedCodeCacheSize\") >> 6;\n+    private static final long codeCacheMinBlockLength = Helper.WHITE_BOX.getSizeTVMFlag(\"CodeCacheMinBlockLength\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/ReturnBlobToWrongHeapTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8359121\n+ * @summary Region node introduced by ArraysSupport.mismatch must be disconnected,\n+ *          and not just put aside as dead: when simplifying\n+ *          Proj -> Region -> If -> ...\n+ *          into\n+ *          Proj -> If -> ...\n+ *               -> Region\n+ *          the dead Region node must be removed from Proj's outputs.\n+ * @modules java.base\/jdk.internal.util\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.igvn.RemoveDeadRegionFromVectorizedMismatchIntrinsic::test\n+ *                   compiler.igvn.RemoveDeadRegionFromVectorizedMismatchIntrinsic\n+ * @run main compiler.igvn.RemoveDeadRegionFromVectorizedMismatchIntrinsic\n+ *\/\n+package compiler.igvn;\n+\n+import jdk.internal.util.ArraysSupport;\n+\n+public class RemoveDeadRegionFromVectorizedMismatchIntrinsic {\n+    public static void main(String[] args) {\n+        ArraysSupport.mismatch(new int[0], new int[0], 0);  \/\/ loads ArraysSupport\n+        test(new byte[0], new byte[0]);\n+    }\n+\n+    public static int test(byte[] a, byte[] b) {\n+        int i = ArraysSupport.vectorizedMismatch(a, 0, b, 0, 0, 0);\n+        return i >= 0 ? i : 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/RemoveDeadRegionFromVectorizedMismatchIntrinsic.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-    DEFAULT(\"For IR node placeholder strings as defined in class IRNode only\"),\n+    DEFAULT(                        \"For IR node placeholder strings as defined in class IRNode only\"),\n@@ -42,43 +42,25 @@\n-    BEFORE_STRINGOPTS(\"Before StringOpts\"),\n-    AFTER_STRINGOPTS(\"After StringOpts\"),\n-    BEFORE_REMOVEUSELESS(\"Before RemoveUseless\"),\n-    AFTER_PARSING(\"After Parsing\"),\n-    BEFORE_ITER_GVN(\"Before Iter GVN\"),\n-    ITER_GVN1(\"Iter GVN 1\"),\n-    AFTER_ITER_GVN_STEP(\"After Iter GVN Step\"),\n-    AFTER_ITER_GVN(\"After Iter GVN\"),\n-    INCREMENTAL_INLINE_STEP(\"Incremental Inline Step\"),\n-    INCREMENTAL_INLINE_CLEANUP(\"Incremental Inline Cleanup\"),\n-    INCREMENTAL_INLINE(\"Incremental Inline\"),\n-    INCREMENTAL_BOXING_INLINE(\"Incremental Boxing Inline\"),\n-    EXPAND_VUNBOX(\"Expand VectorUnbox\"),\n-    SCALARIZE_VBOX(\"Scalarize VectorBox\"),\n-    INLINE_VECTOR_REBOX(\"Inline Vector Rebox Calls\"),\n-    EXPAND_VBOX(\"Expand VectorBox\"),\n-    ELIMINATE_VBOX_ALLOC(\"Eliminate VectorBoxAllocate\"),\n-    ITER_GVN_BEFORE_EA(\"Iter GVN before EA\"),\n-    ITER_GVN_AFTER_VECTOR(\"Iter GVN after vector box elimination\"),\n-    BEFORE_LOOP_OPTS(\"Before Loop Optimizations\"),\n-    BEFORE_BEAUTIFY_LOOPS(\"Before beautify loops\"),\n-    AFTER_BEAUTIFY_LOOPS(\"After beautify loops\"),\n-    BEFORE_LOOP_UNROLLING(\"Before Loop Unrolling\"),\n-    AFTER_LOOP_UNROLLING(\"After Loop Unrolling\"),\n-    BEFORE_SPLIT_IF(\"Before Split-If\"),\n-    AFTER_SPLIT_IF(\"After Split-If\"),\n-    BEFORE_LOOP_PREDICATION_IC(\"Before Loop Predication IC\"),\n-    AFTER_LOOP_PREDICATION_IC(\"After Loop Predication IC\"),\n-    BEFORE_LOOP_PREDICATION_RC(\"Before Loop Predication RC\"),\n-    AFTER_LOOP_PREDICATION_RC(\"After Loop Predication RC\"),\n-    BEFORE_PARTIAL_PEELING(\"Before Partial Peeling\"),\n-    AFTER_PARTIAL_PEELING(\"After Partial Peeling\"),\n-    BEFORE_LOOP_PEELING(\"Before Loop Peeling\"),\n-    AFTER_LOOP_PEELING(\"After Loop Peeling\"),\n-    BEFORE_LOOP_UNSWITCHING(\"Before Loop Unswitching\"),\n-    AFTER_LOOP_UNSWITCHING(\"After Loop Unswitching\"),\n-    BEFORE_RANGE_CHECK_ELIMINATION(\"Before Range Check Elimination\"),\n-    AFTER_RANGE_CHECK_ELIMINATION(\"After Range Check Elimination\"),\n-    BEFORE_PRE_MAIN_POST(\"Before Pre\/Main\/Post Loops\"),\n-    AFTER_PRE_MAIN_POST(\"After Pre\/Main\/Post Loops\"),\n-    SUPERWORD1_BEFORE_SCHEDULE(\"Superword 1, Before Schedule\"),\n-    SUPERWORD2_BEFORE_OUTPUT(\"Superword 2, Before Output\"),\n-    SUPERWORD3_AFTER_OUTPUT(\"Superword 3, After Output\"),\n+    BEFORE_STRINGOPTS(              \"Before StringOpts\"),\n+    AFTER_STRINGOPTS(               \"After StringOpts\"),\n+    BEFORE_REMOVEUSELESS(           \"Before RemoveUseless\"),\n+    AFTER_PARSING(                  \"After Parsing\"),\n+    BEFORE_ITER_GVN(                \"Before Iter GVN\"),\n+    ITER_GVN1(                      \"Iter GVN 1\"),\n+    AFTER_ITER_GVN_STEP(            \"After Iter GVN Step\"),\n+    AFTER_ITER_GVN(                 \"After Iter GVN\"),\n+    INCREMENTAL_INLINE_STEP(        \"Incremental Inline Step\"),\n+    INCREMENTAL_INLINE_CLEANUP(     \"Incremental Inline Cleanup\"),\n+    INCREMENTAL_INLINE(             \"Incremental Inline\"),\n+    INCREMENTAL_BOXING_INLINE(      \"Incremental Boxing Inline\"),\n+    EXPAND_VUNBOX(                  \"Expand VectorUnbox\"),\n+    SCALARIZE_VBOX(                 \"Scalarize VectorBox\"),\n+    INLINE_VECTOR_REBOX(            \"Inline Vector Rebox Calls\"),\n+    EXPAND_VBOX(                    \"Expand VectorBox\"),\n+    ELIMINATE_VBOX_ALLOC(           \"Eliminate VectorBoxAllocate\"),\n+    ITER_GVN_BEFORE_EA(             \"Iter GVN before EA\"),\n+    ITER_GVN_AFTER_VECTOR(          \"Iter GVN after Vector Box Elimination\"),\n+    BEFORE_LOOP_OPTS(               \"Before Loop Optimizations\"),\n+    PHASEIDEAL_BEFORE_EA(           \"PhaseIdealLoop before EA\"),\n+    AFTER_EA(                       \"After Escape Analysis\"),\n+    ITER_GVN_AFTER_EA(              \"Iter GVN after EA\"),\n+    BEFORE_BEAUTIFY_LOOPS(          \"Before Beautify Loops\"),\n+    AFTER_BEAUTIFY_LOOPS(           \"After Beautify Loops\"),\n@@ -86,41 +68,60 @@\n-    BEFORE_CLOOPS(\"Before CountedLoop\", RegexType.IDEAL_INDEPENDENT, ActionOnRepeat.KEEP_FIRST),\n-    AFTER_CLOOPS(\"After CountedLoop\"),\n-    PHASEIDEAL_BEFORE_EA(\"PhaseIdealLoop before EA\"),\n-    AFTER_EA(\"After Escape Analysis\"),\n-    ITER_GVN_AFTER_EA(\"Iter GVN after EA\"),\n-    ITER_GVN_AFTER_ELIMINATION(\"Iter GVN after eliminating allocations and locks\"),\n-    PHASEIDEALLOOP1(\"PhaseIdealLoop 1\"),\n-    PHASEIDEALLOOP2(\"PhaseIdealLoop 2\"),\n-    PHASEIDEALLOOP3(\"PhaseIdealLoop 3\"),\n-    BEFORE_CCP1(\"Before PhaseCCP 1\"),\n-    CCP1(\"PhaseCCP 1\"),\n-    ITER_GVN2(\"Iter GVN 2\"),\n-    PHASEIDEALLOOP_ITERATIONS(\"PhaseIdealLoop iterations\"),\n-    AFTER_LOOP_OPTS(\"After Loop Optimizations\"),\n-    AFTER_MERGE_STORES(\"After Merge Stores\"),\n-    BEFORE_MACRO_EXPANSION(\"Before Macro Expansion\"),\n-    AFTER_MACRO_EXPANSION_STEP(\"After Macro Expansion Step\"),\n-    AFTER_MACRO_EXPANSION(\"After Macro Expansion\"),\n-    BARRIER_EXPANSION(\"Barrier expand\"),\n-    OPTIMIZE_FINISHED(\"Optimize finished\"),\n-    PRINT_IDEAL(\"PrintIdeal\"),\n-    BEFORE_MATCHING(\"Before matching\"),\n-    MATCHING(\"After matching\", RegexType.MACH),\n-    GLOBAL_CODE_MOTION(\"Global code motion\", RegexType.MACH),\n-    INITIAL_LIVENESS(\"Initial liveness\", RegexType.MACH),\n-    LIVE_RANGE_STRETCHING(\"Live range stretching\", RegexType.MACH),\n-    AGGRESSIVE_COALESCING(\"Aggressive coalescing\", RegexType.MACH),\n-    INITIAL_SPILLING(\"Initial spilling\", RegexType.MACH),\n-    CONSERVATIVE_COALESCING(\"Conservative coalescing\", RegexType.MACH, ActionOnRepeat.KEEP_FIRST),\n-    ITERATIVE_SPILLING(\"Iterative spilling\", RegexType.MACH, ActionOnRepeat.KEEP_FIRST),\n-    AFTER_ITERATIVE_SPILLING(\"After iterative spilling\", RegexType.MACH),\n-    POST_ALLOCATION_COPY_REMOVAL(\"Post-allocation copy removal\", RegexType.MACH),\n-    MERGE_MULTI_DEFS(\"Merge multiple definitions\", RegexType.MACH),\n-    FIX_UP_SPILLS(\"Fix up spills\", RegexType.MACH),\n-    REGISTER_ALLOCATION(\"Register Allocation\", RegexType.MACH),\n-    BLOCK_ORDERING(\"Block Ordering\", RegexType.MACH),\n-    PEEPHOLE(\"Peephole\", RegexType.MACH),\n-    POSTALLOC_EXPAND(\"Post-Allocation Expand\", RegexType.MACH),\n-    MACH_ANALYSIS(\"After mach analysis\", RegexType.MACH),\n-    FINAL_CODE(\"Final Code\", RegexType.MACH),\n-    END(\"End\"),\n+    BEFORE_CLOOPS(                  \"Before CountedLoop\", RegexType.IDEAL_INDEPENDENT, ActionOnRepeat.KEEP_FIRST),\n+    AFTER_CLOOPS(                   \"After CountedLoop\"),\n+    BEFORE_LOOP_UNROLLING(          \"Before Loop Unrolling\"),\n+    AFTER_LOOP_UNROLLING(           \"After Loop Unrolling\"),\n+    BEFORE_SPLIT_IF(                \"Before Split-If\"),\n+    AFTER_SPLIT_IF(                 \"After Split-If\"),\n+    BEFORE_LOOP_PREDICATION_IC(     \"Before Loop Predication IC\"),\n+    AFTER_LOOP_PREDICATION_IC(      \"After Loop Predication IC\"),\n+    BEFORE_LOOP_PREDICATION_RC(     \"Before Loop Predication RC\"),\n+    AFTER_LOOP_PREDICATION_RC(      \"After Loop Predication RC\"),\n+    BEFORE_PARTIAL_PEELING(         \"Before Partial Peeling\"),\n+    AFTER_PARTIAL_PEELING(          \"After Partial Peeling\"),\n+    BEFORE_LOOP_PEELING(            \"Before Loop Peeling\"),\n+    AFTER_LOOP_PEELING(             \"After Loop Peeling\"),\n+    BEFORE_LOOP_UNSWITCHING(        \"Before Loop Unswitching\"),\n+    AFTER_LOOP_UNSWITCHING(         \"After Loop Unswitching\"),\n+    BEFORE_RANGE_CHECK_ELIMINATION( \"Before Range Check Elimination\"),\n+    AFTER_RANGE_CHECK_ELIMINATION(  \"After Range Check Elimination\"),\n+    ITER_GVN_AFTER_ELIMINATION(     \"Iter GVN after Eliminating Allocations and Locks\"),\n+    BEFORE_PRE_MAIN_POST(           \"Before Pre\/Main\/Post Loops\"),\n+    AFTER_PRE_MAIN_POST(            \"After Pre\/Main\/Post Loops\"),\n+    PHASEIDEALLOOP1(                \"PhaseIdealLoop 1\"),\n+    PHASEIDEALLOOP2(                \"PhaseIdealLoop 2\"),\n+    PHASEIDEALLOOP3(                \"PhaseIdealLoop 3\"),\n+    AUTO_VECTORIZATION1_BEFORE_APPLY(                    \"AutoVectorization 1, before Apply\"),\n+    AUTO_VECTORIZATION2_AFTER_REORDER(                   \"AutoVectorization 2, after Apply Memop Reordering\"),\n+    AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT(              \"AutoVectorization 3, after Adjusting Pre-loop Limit\"),\n+    AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS(\"AutoVectorization 4, after Adding Speculative Runtime Checks\"),\n+    BEFORE_CCP1(                    \"Before PhaseCCP 1\"),\n+    CCP1(                           \"PhaseCCP 1\"),\n+    ITER_GVN2(                      \"Iter GVN 2\"),\n+    PHASEIDEALLOOP_ITERATIONS(      \"PhaseIdealLoop Iterations\"),\n+    AFTER_LOOP_OPTS(                \"After Loop Optimizations\"),\n+    AFTER_MERGE_STORES(             \"After Merge Stores\"),\n+    BEFORE_MACRO_EXPANSION(         \"Before Macro Expansion\"),\n+    AFTER_MACRO_EXPANSION_STEP(     \"After Macro Expansion Step\"),\n+    AFTER_MACRO_EXPANSION(          \"After Macro Expansion\"),\n+    BARRIER_EXPANSION(              \"Barrier Expand\"),\n+    OPTIMIZE_FINISHED(              \"Optimize Finished\"),\n+    PRINT_IDEAL(                    \"PrintIdeal\"),\n+    BEFORE_MATCHING(                \"Before Matching\"),\n+    MATCHING(                       \"After Matching\", RegexType.MACH),\n+    GLOBAL_CODE_MOTION(             \"Global Code Motion\", RegexType.MACH),\n+    INITIAL_LIVENESS(               \"Initial Liveness\", RegexType.MACH),\n+    LIVE_RANGE_STRETCHING(          \"Live Range Stretching\", RegexType.MACH),\n+    AGGRESSIVE_COALESCING(          \"Aggressive Coalescing\", RegexType.MACH),\n+    INITIAL_SPILLING(               \"Initial Spilling\", RegexType.MACH),\n+    CONSERVATIVE_COALESCING(        \"Conservative Coalescing\", RegexType.MACH, ActionOnRepeat.KEEP_FIRST),\n+    ITERATIVE_SPILLING(             \"Iterative Spilling\", RegexType.MACH, ActionOnRepeat.KEEP_FIRST),\n+    AFTER_ITERATIVE_SPILLING(       \"After Iterative Spilling\", RegexType.MACH),\n+    POST_ALLOCATION_COPY_REMOVAL(   \"Post-allocation Copy Removal\", RegexType.MACH),\n+    MERGE_MULTI_DEFS(               \"Merge Multiple Definitions\", RegexType.MACH),\n+    FIX_UP_SPILLS(                  \"Fix up Spills\", RegexType.MACH),\n+    REGISTER_ALLOCATION(            \"Register Allocation\", RegexType.MACH),\n+    BLOCK_ORDERING(                 \"Block Ordering\", RegexType.MACH),\n+    PEEPHOLE(                       \"Peephole\", RegexType.MACH),\n+    POSTALLOC_EXPAND(               \"Post-allocation Expand\", RegexType.MACH),\n+    MACH_ANALYSIS(                  \"After Mach Analysis\", RegexType.MACH),\n+    FINAL_CODE(                     \"Final Code\", RegexType.MACH),\n+    END(                            \"End\"),\n@@ -128,1 +129,1 @@\n-    PRINT_OPTO_ASSEMBLY(\"PrintOptoAssembly\", RegexType.OPTO_ASSEMBLY),\n+    PRINT_OPTO_ASSEMBLY(            \"PrintOptoAssembly\", RegexType.OPTO_ASSEMBLY),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":87,"deletions":86,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        return new HookAnchorToken(this, Token.parse(tokens));\n+        return new HookAnchorToken(this, TokenParser.parse(tokens));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-        return new TemplateBody(Token.parse(tokens));\n+        return new TemplateBody(TokenParser.parse(tokens));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n@@ -32,3 +28,1 @@\n- * {@link Token}s or {@link String}s or some permitted boxed primitives. These are then parsed\n- * and all non-{@link Token}s are converted to {@link StringToken}s. The parsing also flattens\n- * {@link List}s.\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives.\n@@ -36,1 +30,1 @@\n-sealed interface Token permits StringToken,\n+public sealed interface Token permits StringToken,\n@@ -45,34 +39,1 @@\n-                               NothingToken\n-{\n-    static List<Token> parse(Object[] objects) {\n-        if (objects == null) {\n-            throw new IllegalArgumentException(\"Unexpected tokens: null\");\n-        }\n-        List<Token> outputList = new ArrayList<>();\n-        parseToken(Arrays.asList(objects), outputList);\n-        return outputList;\n-    }\n-\n-    private static void parseList(List<?> inputList, List<Token> outputList) {\n-        for (Object o : inputList) {\n-            parseToken(o, outputList);\n-        }\n-    }\n-\n-    private static void parseToken(Object o, List<Token> outputList) {\n-        if (o == null) {\n-            throw new IllegalArgumentException(\"Unexpected token: null\");\n-        }\n-        switch (o) {\n-            case Token t   -> outputList.add(t);\n-            case String s  -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Integer s -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Long s    -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Double s  -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Float s   -> outputList.add(new StringToken(Renderer.format(s)));\n-            case Boolean s -> outputList.add(new StringToken(Renderer.format(s)));\n-            case List<?> l -> parseList(l, outputList);\n-            default -> throw new IllegalArgumentException(\"Unexpected token: \" + o);\n-        }\n-    }\n-}\n+                               NothingToken {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Token.java","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Helper class for {@link Token}, to keep the parsing methods package private.\n+ *\n+ * <p>\n+ * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives. These are then parsed\n+ * and all non-{@link Token}s are converted to {@link StringToken}s. The parsing also flattens\n+ * {@link List}s.\n+ *\/\n+final class TokenParser {\n+    static List<Token> parse(Object[] objects) {\n+        if (objects == null) {\n+            throw new IllegalArgumentException(\"Unexpected tokens: null\");\n+        }\n+        List<Token> outputList = new ArrayList<>();\n+        parseToken(Arrays.asList(objects), outputList);\n+        return outputList;\n+    }\n+\n+    private static void parseList(List<?> inputList, List<Token> outputList) {\n+        for (Object o : inputList) {\n+            parseToken(o, outputList);\n+        }\n+    }\n+\n+    private static void parseToken(Object o, List<Token> outputList) {\n+        if (o == null) {\n+            throw new IllegalArgumentException(\"Unexpected token: null\");\n+        }\n+        switch (o) {\n+            case Token t   -> outputList.add(t);\n+            case String s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Integer s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Long s    -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Double s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Float s   -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Boolean s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case List<?> l -> parseList(l, outputList);\n+            default -> throw new IllegalArgumentException(\"Unexpected token: \" + o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TokenParser.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.Template;\n+\n+\/**\n+ * The {@link CodeGenerationDataNameType} extends the {@link DataName.Type} with\n+ * additional functionality for code generation. These types with their extended\n+ * functionality can be used with many other code generation facilities in the\n+ * library, such as generating random {@code Expression}s.\n+ *\/\n+public interface CodeGenerationDataNameType extends DataName.Type {\n+\n+    \/**\n+     * This method provides a random constant value for the type, which can\n+     * be used as a token inside a {@link Template}.\n+     *\n+     * @return A random constant value.\n+     *\/\n+    Object con();\n+\n+    \/**\n+     * The byte {@link PrimitiveType}.\n+     *\n+     * @return The byte {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType bytes()    { return PrimitiveType.BYTES; }\n+\n+    \/**\n+     * The short {@link PrimitiveType}.\n+     *\n+     * @return The short {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType shorts()   { return PrimitiveType.SHORTS; }\n+\n+    \/**\n+     * The char {@link PrimitiveType}.\n+     *\n+     * @return The char {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType chars()    { return PrimitiveType.CHARS; }\n+\n+    \/**\n+     * The int {@link PrimitiveType}.\n+     *\n+     * @return The int {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType ints()     { return PrimitiveType.INTS; }\n+\n+    \/**\n+     * The long {@link PrimitiveType}.\n+     *\n+     * @return The long {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType longs()    { return PrimitiveType.LONGS; }\n+\n+    \/**\n+     * The float {@link PrimitiveType}.\n+     *\n+     * @return The float {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType floats()   { return PrimitiveType.FLOATS; }\n+\n+    \/**\n+     * The double {@link PrimitiveType}.\n+     *\n+     * @return The double {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType doubles()  { return PrimitiveType.DOUBLES; }\n+\n+    \/**\n+     * The boolean {@link PrimitiveType}.\n+     *\n+     * @return The boolean {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType booleans() { return PrimitiveType.BOOLEANS; }\n+\n+    \/**\n+     * List of all {@link PrimitiveType}s.\n+     *\/\n+    List<PrimitiveType> PRIMITIVE_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs(),\n+        floats(),\n+        doubles(),\n+        booleans()\n+    );\n+\n+    \/**\n+     * List of all integral {@link PrimitiveType}s (byte, char, short, int, long).\n+     *\/\n+    List<PrimitiveType> INTEGRAL_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs()\n+    );\n+\n+    \/**\n+     * List of all subword {@link PrimitiveType}s (byte, char, short).\n+     *\/\n+    List<PrimitiveType> SUBWORD_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts()\n+    );\n+\n+    \/**\n+     * List of all floating {@link PrimitiveType}s (float, double).\n+     *\/\n+    List<PrimitiveType> FLOATING_TYPES = List.of(\n+        floats(),\n+        doubles()\n+    );\n+\n+    \/**\n+     * List of all integral and floating {@link PrimitiveType}s.\n+     *\/\n+    List<PrimitiveType> INTEGRAL_AND_FLOATING_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs(),\n+        floats(),\n+        doubles()\n+    );\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/CodeGenerationDataNameType.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.RestrictableGenerator;\n+\n+import compiler.lib.template_framework.DataName;\n+\n+\/**\n+ * The {@link PrimitiveType} models Java's primitive types, and provides a set\n+ * of useful methods for code generation, such as the {@link #byteSize} and\n+ * {@link #boxedTypeName}.\n+ *\/\n+public final class PrimitiveType implements CodeGenerationDataNameType {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final RestrictableGenerator<Integer> GEN_BYTE = Generators.G.safeRestrict(Generators.G.ints(), Byte.MIN_VALUE, Byte.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    private static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+    private static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+\n+    private static enum Kind { BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE, BOOLEAN };\n+\n+    \/\/ We have one static instance each, so we do not have duplicated instances.\n+    static final PrimitiveType BYTES    = new PrimitiveType(Kind.BYTE   );\n+    static final PrimitiveType SHORTS   = new PrimitiveType(Kind.SHORT  );\n+    static final PrimitiveType CHARS    = new PrimitiveType(Kind.CHAR   );\n+    static final PrimitiveType INTS     = new PrimitiveType(Kind.INT    );\n+    static final PrimitiveType LONGS    = new PrimitiveType(Kind.LONG   );\n+    static final PrimitiveType FLOATS   = new PrimitiveType(Kind.FLOAT  );\n+    static final PrimitiveType DOUBLES  = new PrimitiveType(Kind.DOUBLE );\n+    static final PrimitiveType BOOLEANS = new PrimitiveType(Kind.BOOLEAN);\n+\n+    final Kind kind;\n+\n+    \/\/ Private constructor so nobody can create duplicate instances.\n+    private PrimitiveType(Kind kind) {\n+        this.kind = kind;\n+    }\n+\n+    @Override\n+    public boolean isSubtypeOf(DataName.Type other) {\n+        return (other instanceof PrimitiveType pt) && pt.kind == kind;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return switch (kind) {\n+            case BYTE    -> \"byte\";\n+            case SHORT   -> \"short\";\n+            case CHAR    -> \"char\";\n+            case INT     -> \"int\";\n+            case LONG    -> \"long\";\n+            case FLOAT   -> \"float\";\n+            case DOUBLE  -> \"double\";\n+            case BOOLEAN -> \"boolean\";\n+        };\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name();\n+    }\n+\n+    public Object con() {\n+        return switch (kind) {\n+            case BYTE    -> \"(byte)\" + GEN_BYTE.next();\n+            case SHORT   -> \"(short)\" + GEN_SHORT.next();\n+            case CHAR    -> \"(char)\" + GEN_CHAR.next();\n+            case INT     -> GEN_INT.next();\n+            case LONG    -> GEN_LONG.next();\n+            case FLOAT   -> GEN_FLOAT.next();\n+            case DOUBLE  -> GEN_DOUBLE.next();\n+            case BOOLEAN -> RANDOM.nextBoolean();\n+        };\n+    }\n+\n+    \/**\n+     * Provides the size of the type in bytes.\n+     *\n+     * @return Size of the type in bytes.\n+     * @throws UnsupportedOperationException for boolean which has no defined size.\n+     *\/\n+    public int byteSize() {\n+        return switch (kind) {\n+            case BYTE    -> 1;\n+            case SHORT, CHAR -> 2;\n+            case INT, FLOAT -> 4;\n+            case LONG, DOUBLE -> 8;\n+            case BOOLEAN -> { throw new UnsupportedOperationException(\"boolean does not have a defined 'size'\"); }\n+        };\n+    }\n+\n+    \/**\n+     * Provides the name of the boxed type.\n+     *\n+     * @return the name of the boxed type.\n+     *\/\n+    public String boxedTypeName() {\n+        return switch (kind) {\n+            case BYTE    -> \"Byte\";\n+            case SHORT   -> \"Short\";\n+            case CHAR    -> \"Character\";\n+            case INT     -> \"Integer\";\n+            case LONG    -> \"Long\";\n+            case FLOAT   -> \"Float\";\n+            case DOUBLE  -> \"Double\";\n+            case BOOLEAN -> \"Boolean\";\n+        };\n+    }\n+\n+    \/**\n+     * Indicates if the type is a floating point type.\n+     *\n+     * @return true iff the type is a floating point type.\n+     *\/\n+    public boolean isFloating() {\n+        return switch (kind) {\n+            case BYTE, SHORT, CHAR, INT, LONG, BOOLEAN -> false;\n+            case FLOAT, DOUBLE -> true;\n+        };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+\/**\n+ * This class provides a {@link #render} method that can be used to simplify generating\n+ * source code when using the {@link TestFramework} (also known as IR Framework) to run\n+ * a list of tests.\n+ *\n+ * <p>\n+ * The idea is that the user only has to generate the code for the individual tests,\n+ * and can then pass the corresponding list of {@link TemplateToken}s to this\n+ * provided {@link #render} method which generates the surrounding class and the main\n+ * method that invokes the {@link TestFramework}, so that all the generated tests\n+ * are run.\n+ *\/\n+public final class TestFrameworkClass {\n+\n+    \/\/ Ensure there can be no instance, and we do not have to document the constructor.\n+    private TestFrameworkClass() {}\n+\n+    \/**\n+     * This method renders a list of {@code testTemplateTokens} into the body of a class\n+     * and generates a {@code main} method which launches the {@link TestFramework}\n+     * to run the generated tests.\n+     *\n+     * <p>\n+     * The generated {@code main} method is to be invoked with a {@code vmFlags} argument,\n+     * which must be a {@link String[]}, specifying the VM flags for the Test VM, in which\n+     * the tests will be run. Thus, one can generate the test class once, and invoke its\n+     * {@code main} method multiple times, each time with a different set of VM flags.\n+     *\n+     * <p>\n+     * The internal {@link Template} sets the {@link Hooks#CLASS_HOOK} for the scope of\n+     * all test methods.\n+     *\n+     * @param packageName The package name of the test class.\n+     * @param className The name of the test class.\n+     * @param imports A set of imports.\n+     * @param classpath The classpath from {@link CompileFramework#getEscapedClassPathOfCompiledClasses},\n+     *                  so that the Test VM has access to the class files that are compiled from the\n+     *                  generated source code.\n+     * @param testTemplateTokens The list of tests to be generated into the test class.\n+     *                           Every test must be annotated with {@code @Test}, so that\n+     *                           the {@link TestFramework} can later find and run them.\n+     * @return The generated source code of the test class as a {@link String}.\n+     *\/\n+    public static String render(final String packageName,\n+                                final String className,\n+                                final Set<String> imports,\n+                                final String classpath,\n+                                final List<TemplateToken> testTemplateTokens) {\n+        var template = Template.make(() -> body(\n+            let(\"packageName\", packageName),\n+            let(\"className\", className),\n+            let(\"classpath\", classpath),\n+            \"\"\"\n+            package #packageName;\n+            \/\/ --- IMPORTS start ---\n+            import compiler.lib.ir_framework.*;\n+            \"\"\",\n+            imports.stream().map(i -> \"import \" + i + \";\\n\").toList(),\n+            \"\"\"\n+            \/\/ --- IMPORTS end   ---\n+            public class #className {\n+            \/\/ --- CLASS_HOOK insertions start ---\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+            \/\/ --- CLASS_HOOK insertions end   ---\n+                public static void main(String[] vmFlags) {\n+                    TestFramework framework = new TestFramework(#className.class);\n+                    framework.addFlags(\"-classpath\", \"#classpath\");\n+                    framework.addFlags(vmFlags);\n+                    framework.start();\n+                }\n+            \/\/ --- LIST OF TESTS start ---\n+            \"\"\",\n+            testTemplateTokens\n+            ),\n+            \"\"\"\n+            \/\/ --- LIST OF TESTS end   ---\n+            }\n+            \"\"\"\n+        ));\n+        return template.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/TestFrameworkClass.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350576\n+ * @summary Optimization bails out and hits an assert:\n+ *          assert(false) failed: reduction has ctrl or bad vector_input\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.LoopReductionHasControlOrBadInput::*\n+ *      compiler.loopopts.LoopReductionHasControlOrBadInput\n+ * @run main compiler.loopopts.LoopReductionHasControlOrBadInput\n+ *\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class LoopReductionHasControlOrBadInput {\n+    static long lFld;\n+    static long lArr[] = new long[400];\n+\n+    static void test() {\n+        int i = 1;\n+        do {\n+            long x = -1;\n+            lArr[i] = i;\n+            lFld += i | x;\n+        } while (++i < 355);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 100; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LoopReductionHasControlOrBadInput.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -63,1 +63,0 @@\n-        Process[] pr = new Process[200];\n@@ -68,6 +67,1 @@\n-            pr[i] = pb.start();\n-        }\n-        for (int i = 0; i < 200; i++) {\n-            out = new OutputAnalyzer(pr[i]);\n-            \/\/ The VM should not crash but will probably fail with a \"CodeCache is full. Compiler has been disabled.\" message\n-            out.stdoutShouldNotContain(\"# A fatal error\");\n+            out = new OutputAnalyzer(pb.start());\n@@ -78,0 +72,2 @@\n+            \/\/ The VM should not crash but will probably fail with a \"CodeCache is full. Compiler has been disabled.\" message\n+            out.stdoutShouldNotContain(\"# A fatal error\");\n","filename":"test\/hotspot\/jtreg\/compiler\/startup\/StartupOutput.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            = WHITE_BOX.getUintxVMFlag(\"ReservedCodeCacheSize\");\n+            = WHITE_BOX.getSizeTVMFlag(\"ReservedCodeCacheSize\");\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/AllocationCodeBlobTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8358334\n+ * @summary C2\/Shenandoah: incorrect execution with Unsafe\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:+UseShenandoahGC\n+ *                   TestLostAntiDependencyAtExpansion\n+ *\n+ *\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestLostAntiDependencyAtExpansion {\n+    static final jdk.internal.misc.Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) {\n+        long addr = UNSAFE.allocateMemory(8);\n+        for (int i = 0; i < 20_000; i++) {\n+            UNSAFE.putLong(addr, 42L);\n+            long res = test1(addr);\n+            if (res != 42L) {\n+                throw new RuntimeException(\"Incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    static class A {\n+        long field;\n+    }\n+\n+    static A a = new A();\n+\n+    private static long test1(long addr) {\n+        long tmp = UNSAFE.getLong(addr);\n+\n+        UNSAFE.putLong(addr, 0L);\n+\n+        return tmp + a.field;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLostAntiDependencyAtExpansion.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import static org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n+import static org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8352075\n+ * @library \/test\/lib\n+ * @library \/testlibrary\/asm\n+ * @run main\/othervm LocalFieldLookupTest\n+ *\/\n+\/*\n+ * @test id=custom-threshold\n+ * @bug 8352075\n+ * @library \/test\/lib\n+ * @library \/testlibrary\/asm\n+ * @requires vm.debug == true\n+ * @run main\/othervm LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=0 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=1 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=15 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=100000 LocalFieldLookupTest\n+ *\/\n+public class LocalFieldLookupTest {\n+    private static final String TEST_CLASS_NAME = \"Test\";\n+    private static final int MAX_FIELDS_IN_METHOD = 10000;\n+\n+    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n+        \/\/ Test small classes, covering the tested thresholds\n+        for (int i = 0; i <= 33; ++i) {\n+            makeClass(i).newInstance();\n+        }\n+        \/\/ Test classes around 256 fields (index encoding 1\/2 bytes) to check off-by-one errors\n+        for (int i = 254; i <= 259; ++i) {\n+            makeClass(255).newInstance();\n+        }\n+        \/\/ We would like to test #fields that create have the stream about 65536 bytes long;\n+        \/\/ this value is not exposed, though, so these are rather experimentally found values,\n+        \/\/ hence fragile. Moreover, since the stream length is incremented by about 8 bytes\n+        \/\/ for each field we cannot test for off-by-one errors reliably.\n+        for (int i = 8433; i <= 8437; ++i) {\n+            makeClass(i).newInstance();\n+        }\n+        \/\/ The largest class we can create - this one has 65533 entries in the constant pool\n+        makeClass(26205).newInstance();\n+    }\n+\n+    public static Class<?> makeClass(int fields) throws ClassNotFoundException {\n+        ClassWriter writer = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+        writer.visit(49, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, TEST_CLASS_NAME,null, \"java\/lang\/Object\", null);\n+\n+        for (int i = 0; i < fields; i += 2) {\n+            writer.visitField(ACC_PUBLIC, \"f\" + i, \"I\",  null, null);\n+            \/\/ Let's use duplicate names to confirm search takes signatures into account\n+            if (i + 1 < fields) {\n+                writer.visitField(ACC_PUBLIC, \"f\" + i, \"J\",  null, null);\n+            }\n+        }\n+        \/\/ We initialize fields in multiple methods to avoid running into bytecode limit per method\n+        MethodVisitor fi = null;\n+        for (int i = 0; i < fields; i+= 2) {\n+            if (fi == null) {\n+                fi = writer.visitMethod(ACC_PRIVATE, \"init\" + i, \"()V\", null, null);\n+                fi.visitCode();\n+            }\n+            fi.visitVarInsn(Opcodes.ALOAD, 0);\n+            fi.visitInsn(Opcodes.ICONST_2);\n+            fi.visitFieldInsn(PUTFIELD, TEST_CLASS_NAME, \"f\" + i, \"I\");\n+            if (i + 1 < fields) {\n+                fi.visitVarInsn(Opcodes.ALOAD, 0);\n+                fi.visitInsn(Opcodes.LCONST_1);\n+                fi.visitFieldInsn(PUTFIELD, TEST_CLASS_NAME, \"f\" + i, \"J\");\n+            }\n+            if (i % MAX_FIELDS_IN_METHOD == MAX_FIELDS_IN_METHOD - 2) {\n+                fi.visitInsn(Opcodes.RETURN);\n+                fi.visitMaxs(0, 0);\n+                fi.visitEnd();\n+                fi = null;\n+            }\n+        }\n+        if (fi != null) {\n+            fi.visitInsn(Opcodes.RETURN);\n+            fi.visitMaxs(0, 0);\n+            fi.visitEnd();\n+        }\n+        {\n+            MethodVisitor mv = writer.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitVarInsn(ALOAD, 0);\n+            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+            for (int i = 0; i < fields; i += MAX_FIELDS_IN_METHOD) {\n+                mv.visitVarInsn(ALOAD, 0);\n+                mv.visitMethodInsn(INVOKESPECIAL, TEST_CLASS_NAME, \"init\" + i, \"()V\", false);\n+            }\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+        }\n+        writer.visitEnd();\n+\n+        byte[] bytecode = writer.toByteArray();\n+        ClassLoader cl = new ClassLoader() {\n+            @Override\n+            protected Class<?> findClass(String name) throws ClassNotFoundException {\n+                if (!TEST_CLASS_NAME.equals(name)) {\n+                    throw new ClassNotFoundException();\n+                }\n+                return defineClass(TEST_CLASS_NAME, bytecode, 0, bytecode.length);\n+            }\n+        };\n+        return cl.loadClass(TEST_CLASS_NAME);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldStream\/LocalFieldLookupTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -172,8 +172,11 @@\n-          if (pretouch_committed <= (no_pretouch_committed + expected_delta)) {\n-            throw new RuntimeException(\"Expected a higher amount of committed with pretouch stacks\" +\n-                                       \"PreTouch amount: \" + pretouch_committed +\n-                                       \"NoPreTouch amount: \" + (no_pretouch_committed + expected_delta));\n-          }\n-          if (actual_delta < expected_delta) {\n-            throw new RuntimeException(\"Expected a higher delta between stack committed of with and without pretouch.\" +\n-                                       \"Expected: \" + expected_delta + \" Actual: \" + actual_delta);\n+          if (((double)pretouch_committed) \/ ((double)no_pretouch_committed) < 1.20) {\n+            if (pretouch_committed <= (no_pretouch_committed + expected_delta)) {\n+              throw new RuntimeException(\"Expected a higher amount of committed with pretouch stacks\" +\n+                                        \" PreTouch amount: \" + pretouch_committed +\n+                                        \" NoPreTouch amount: \" + no_pretouch_committed +\n+                                        \" Expected delta: \" + expected_delta);\n+            }\n+            if (actual_delta < expected_delta) {\n+              throw new RuntimeException(\"Expected a higher delta between stack committed of with and without pretouch.\" +\n+                                        \" Expected: \" + expected_delta + \" Actual: \" + actual_delta);\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -56,3 +56,1 @@\n-            case \"SIGSTOP\": {\n-                throw new SkippedException(\"signals SIGWAITING, SIGKILL and SIGSTOP can't be tested\");\n-            }\n+            case \"SIGSTOP\":\n@@ -60,5 +58,1 @@\n-                if (Platform.isLinux()) {\n-                    throw new SkippedException(\"SIGUSR2 can't be tested on Linux\");\n-                } else if (Platform.isOSX()) {\n-                    throw new SkippedException(\"SIGUSR2 can't be tested on OS X\");\n-                }\n+                throw new SkippedException(\"signals SIGWAITING, SIGKILL, SIGSTOP and SIGUSR2 can't be tested\");\n","filename":"test\/hotspot\/jtreg\/runtime\/signal\/SigTestDriver.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @requires os.family != \"windows\" & os.family != \"aix\"\n- *\n- * @summary converted from VM testbase runtime\/signal\/sigusr201.\n- * VM testbase keywords: [signal, runtime, linux, macosx]\n- *\n- * @library \/test\/lib\n- * @run main\/native SigTestDriver SIGUSR2\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/signal\/TestSigusr2.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.ArrayList;\n+import java.util.Collection;\n@@ -44,1 +46,1 @@\n-    private static final Set<String> excludedTestExtensions = Set.of(\".c\", \".java\", \".jar\", \".class\", \".zip\");\n+    private static final Set<String> excludedTestExtensions = extend(new HashSet<>(List.of(\".c\", \".java\", \".jar\", \".class\", \".zip\")), \"excludedTestExtensions\");\n@@ -49,0 +51,12 @@\n+    \/**\n+     * Extends {@code toExtend} with the comma separated entries in the value of the\n+     * {@code propertyName} system property.\n+     *\/\n+    private static <T extends Collection<String>> T extend(T toExtend, String propertyName) {\n+        String extensions = System.getProperty(propertyName);\n+        if (extensions != null) {\n+            toExtend.addAll(List.of(extensions.split(\",\")));\n+        }\n+        return toExtend;\n+    }\n+\n@@ -75,1 +89,1 @@\n-        List<String> sourceExclusions = List.of(\n+        List<String> sourceExclusions = extend(new ArrayList<>(List.of(\n@@ -78,1 +92,1 @@\n-        );\n+        )), \"sourceExclusions\");\n@@ -80,1 +94,1 @@\n-        List<String> testExclusions = List.of(\n+        List<String> testExclusions = extend(new ArrayList<>(List.of(\n@@ -83,1 +97,1 @@\n-        );\n+        )), \"testExclusions\");\n","filename":"test\/hotspot\/jtreg\/sources\/TestNoNULL.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8358772\n+ * @summary Demonstrate the use of PrimitiveTypes form the Template Library.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main template_framework.examples.TestPrimitiveTypes\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.HashMap;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.dataNames;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+\n+\/**\n+ * This test shows the use of {@link PrimitiveType}.\n+ *\/\n+public class TestPrimitiveTypes {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnerTest.main();\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {});\n+    }\n+\n+    \/\/ Generate a Java source file as String\n+    public static String generate() {\n+        \/\/ Generate a list of test methods.\n+        Map<String, TemplateToken> tests = new HashMap<>();\n+\n+        \/\/ The boxing tests check if we can autobox with \"boxedTypeName\".\n+        var boxingTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+            let(\"CON1\", type.con()),\n+            let(\"CON2\", type.con()),\n+            let(\"Boxed\", type.boxedTypeName()),\n+            \"\"\"\n+            public static void #name() {\n+                #type c1 = #CON1;\n+                #type c2 = #CON2;\n+                #Boxed b1 = c1;\n+                #Boxed b2 = c2;\n+                Verify.checkEQ(c1, b1);\n+                Verify.checkEQ(c2, b2);\n+            }\n+            \"\"\"\n+        ));\n+\n+        for (PrimitiveType type : CodeGenerationDataNameType.PRIMITIVE_TYPES) {\n+            String name = \"test_boxing_\" + type.name();\n+            tests.put(name, boxingTemplate.asToken(name, type));\n+        }\n+\n+        \/\/ Integral and Float types have a size. Also test if \"isFloating\" is correct.\n+        var integralFloatTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+            let(\"size\", type.byteSize()),\n+            let(\"isFloating\", type.isFloating()),\n+            \"\"\"\n+            public static void #name() {\n+                \/\/ Test byteSize via creation of array.\n+                #type[] array = new #type[1];\n+                MemorySegment ms = MemorySegment.ofArray(array);\n+                if (#size != ms.byteSize()) {\n+                    throw new RuntimeException(\"byteSize mismatch #type\");\n+                }\n+\n+                \/\/ Test isFloating via rounding.\n+                double value = 1.5;\n+                #type rounded = (#type)value;\n+                boolean isFloating = value != rounded;\n+                if (isFloating == #isFloating) {\n+                    throw new RuntimeException(\"isFloating mismatch #type\");\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        for (PrimitiveType type : CodeGenerationDataNameType.INTEGRAL_AND_FLOATING_TYPES) {\n+            String name = \"test_integral_floating_\" + type.name();\n+            tests.put(name, integralFloatTemplate.asToken(name, type));\n+        }\n+\n+        \/\/ Finally, test the type by creating some DataNames (variables), and sampling\n+        \/\/ from them. There should be no cross-over between the types.\n+        var variableTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+            let(\"CON\", type.con()),\n+            addDataName($(\"var\"), type, MUTABLE),\n+            \"\"\"\n+            #type $var = #CON;\n+            \"\"\"\n+        ));\n+\n+        var sampleTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+            let(\"var\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+            let(\"CON\", type.con()),\n+            \"\"\"\n+            #var = #CON;\n+            \"\"\"\n+        ));\n+\n+        var namesTemplate = Template.make(() -> body(\n+            \"\"\"\n+            public static void test_names() {\n+            \"\"\",\n+            Hooks.METHOD_HOOK.anchor(\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(type ->\n+                        Hooks.METHOD_HOOK.insert(variableTemplate.asToken(type))\n+                    ).toList()\n+                ),\n+                \"\"\"\n+                \/\/ Now sample:\n+                \"\"\",\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(sampleTemplate::asToken).toList()\n+                )\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        tests.put(\"test_names\", namesTemplate.asToken());\n+\n+        \/\/ Finally, put all the tests together in a class, and invoke all\n+        \/\/ tests from the main method.\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            import compiler.lib.verify.*;\n+            import java.lang.foreign.MemorySegment;\n+\n+            public class InnerTest {\n+                public static void main() {\n+            \"\"\",\n+            \/\/ Call all test methods from main.\n+            tests.keySet().stream().map(\n+                n -> List.of(n, \"();\\n\")\n+            ).toList(),\n+            \"\"\"\n+                }\n+            \"\"\",\n+            \/\/ Now add all the test methods.\n+            tests.values().stream().toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render the template to a String.\n+        return template.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestFrameworkClass.TEMPLATE which allows generating many tests and running them with the IR TestFramework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver template_framework.examples.TestWithTestFrameworkClass\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+\n+import compiler.lib.generators.Generators;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+\/**\n+ * This is a basic IR verification test, in combination with Generators for random input generation\n+ * and Verify for output verification.\n+ * <p>\n+ * The \"@compile\" command for JTREG is required so that the frameworks used in the Template code\n+ * are compiled and available for the Test-VM.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class TestWithTestFrameworkClass {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnterTest.main(new String[] {});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {}});\n+\n+        \/\/ We can also pass VM flags for the Test VM.\n+        \/\/ p.xyz.InnterTest.main(new String[] {\"-Xbatch\"});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {\"-Xbatch\"}});\n+    }\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+        \/\/ A simple template that adds a comment.\n+        var commentTemplate = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ Comment inserted from test method to class hook.\n+            \"\"\"\n+        ));\n+\n+        \/\/ We define a Test-Template:\n+        \/\/ - static fields for inputs: INPUT_A and INPUT_B\n+        \/\/   - Data generated with Generators and hashtag replacement #con1.\n+        \/\/ - GOLD value precomputed with dedicated call to test.\n+        \/\/   - This ensures that the GOLD value is computed in the interpreter\n+        \/\/     most likely, since the test method is not yet compiled.\n+        \/\/     This allows us later to compare to the results of the compiled\n+        \/\/     code.\n+        \/\/     The input data is cloned, so that the original INPUT_A is never\n+        \/\/     modified and can serve as identical input in later calls to test.\n+        \/\/ - In the Setup method, we clone the input data, since the input data\n+        \/\/   could be modified inside the test method.\n+        \/\/ - The test method makes use of hashtag replacements (#con2 and #op).\n+        \/\/ - The Check method verifies the results of the test method with the\n+        \/\/   GOLD value.\n+        var testTemplate = Template.make(\"op\", (String op) -> body(\n+            let(\"size\", Generators.G.safeRestrict(Generators.G.ints(), 10_000, 20_000).next()),\n+            let(\"con1\", Generators.G.ints().next()),\n+            let(\"con2\", Generators.G.safeRestrict(Generators.G.ints(), 1, Integer.MAX_VALUE).next()),\n+            \"\"\"\n+            \/\/ --- $test start ---\n+            \/\/ $test with size=#size and op=#op\n+            private static int[] $INPUT_A = new int[#size];\n+            static {\n+                Generators.G.fill(Generators.G.ints(), $INPUT_A);\n+            }\n+            private static int $INPUT_B = #con1;\n+            private static Object $GOLD = $test($INPUT_A.clone(), $INPUT_B);\n+\n+            @Setup\n+            public static Object[] $setup() {\n+                \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+                return new Object[] {$INPUT_A.clone(), $INPUT_B};\n+            }\n+\n+            @Test\n+            @Arguments(setup = \"$setup\")\n+            public static Object $test(int[] a, int b) {\n+                for (int i = 0; i < a.length; i++) {\n+                    int con = #con2;\n+                    a[i] = (a[i] * con) #op b;\n+                }\n+                return a;\n+            }\n+\n+            @Check(test = \"$test\")\n+            public static void $check(Object result) {\n+                Verify.checkEQ(result, $GOLD);\n+            }\n+            \/\/ --- $test end   ---\n+            \"\"\",\n+            \/\/ Good to know: we can insert to the class hook, which is set for the\n+            \/\/ TestFrameworkClass scope:\n+            Hooks.CLASS_HOOK.insert(commentTemplate.asToken())\n+        ));\n+\n+        \/\/ Create a test for each operator.\n+        List<String> ops = List.of(\"+\", \"-\", \"*\", \"&\", \"|\");\n+        List<TemplateToken> testTemplateTokens = ops.stream().map(testTemplate::asToken).toList();\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"p.xyz\", \"InnerTest\",\n+            \/\/ Set of imports.\n+            Set.of(\"compiler.lib.generators.*\",\n+                   \"compiler.lib.verify.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestWithTestFrameworkClass.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-        BufferedReader inputStreamReader = new BufferedReader(new InputStreamReader(\n-                System.in, System.getProperty(\"stdin.encoding\")));\n+        BufferedReader inputStreamReader = new BufferedReader(new InputStreamReader(System.in));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach010\/attach010Agent00.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+    bool finish = false;\n@@ -68,1 +69,1 @@\n-            nsk_jvmti_aod_disableEventAndFinish(agentName, JVMTI_EVENT_CLASS_LOAD, success, jvmti, jni);\n+            finish = true;\n@@ -78,2 +79,2 @@\n-    if (!success) {\n-        nsk_jvmti_aod_disableEventAndFinish(agentName, JVMTI_EVENT_CLASS_LOAD, 0, jvmti, jni);\n+    if (finish || !success) {\n+        nsk_jvmti_aod_disableEventAndFinish(agentName, JVMTI_EVENT_CLASS_LOAD, success, jvmti, jni);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent00.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+    bool finish = false;\n@@ -78,2 +79,1 @@\n-\n-            nsk_jvmti_aod_disableEventAndFinish(agentName, JVMTI_EVENT_CLASS_PREPARE, success, jvmti, jni);\n+            finish = true;\n@@ -89,2 +89,2 @@\n-    if (!success) {\n-        nsk_jvmti_aod_disableEventAndFinish(agentName, JVMTI_EVENT_CLASS_PREPARE, 0, jvmti, jni);\n+    if (finish || !success) {\n+        nsk_jvmti_aod_disableEventAndFinish(agentName, JVMTI_EVENT_CLASS_PREPARE, success, jvmti, jni);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    bool finish = false;\n@@ -84,2 +85,1 @@\n-\n-            nsk_jvmti_aod_disableEventsAndFinish(agentName, testEvents, testEventsNumber, success, jvmti, jni);\n+            finish = true;\n@@ -95,2 +95,2 @@\n-    if (!success) {\n-        nsk_jvmti_aod_disableEventsAndFinish(agentName, testEvents, testEventsNumber, 0, jvmti, jni);\n+    if (finish || !success) {\n+        nsk_jvmti_aod_disableEventsAndFinish(agentName, testEvents, testEventsNumber, success, jvmti, jni);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent02.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+    bool finish = false;\n@@ -87,2 +88,1 @@\n-\n-            nsk_jvmti_aod_disableEventsAndFinish(agentName, testEvents, testEventsNumber, success, jvmti, jni);\n+            finish = true;\n@@ -98,2 +98,2 @@\n-    if (!success) {\n-        nsk_jvmti_aod_disableEventsAndFinish(agentName, testEvents, testEventsNumber, 0, jvmti, jni);\n+    if (finish || !success) {\n+        nsk_jvmti_aod_disableEventsAndFinish(agentName, testEvents, testEventsNumber, success, jvmti, jni);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent03.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * or remote mode according to test command line options.\n+ * mode according to test command line options.\n@@ -97,1 +97,1 @@\n-     * Defines mode (local or remote) and type of connector (default, launching,\n+     * Defines mode (local) and type of connector (default, launching,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1847 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share.jpda;\n-\n-import java.io.*;\n-import java.net.*;\n-import java.util.*;\n-\n-import nsk.share.*;\n-\n-\/**\n- * <code>BindServer<\/code> is an utility to perform JPDA tests\n- * in remote mode across network.\n- * <p>\n- * This utility should be started on remote host. It listens for connection\n- * from JPDA tests and launches debuggee VM on this host.\n- * <p>\n- * <code>BindServer<\/code> works together with <code>Binder<\/code> used in\n- * the tests to incapsulate actions required for launching debuggee VM.\n- * See <code>ProcessBinder<\/code> and <code>DebugeeArgumentHandler<\/code>\n- * to know how run tests in local or remote mode across network or\n- * on an single host.\n- * <p>\n- * <code>BindServer<\/code> is started on the debuggee host.\n- * It recognizes following command line options:\n- * <ul>\n- *   <li><code>-bind.file=<i>filename<\/i><\/code> - configuration file\n- *   <li><code>-verbose<\/code> - print verbose messages\n- * <\/ul>\n- * <p>\n- * Only required option is <code>-bind.file<\/code>, which points to the file\n- * where pairs of particular pathes are presented as they are seen from\n- * both hosts along with some other <code>BindServer<\/code> options.\n- * See <i>execution.html<\/i> to read more about format of bind-file.\n- *\n- * @see DebugeeBinder\n- * @see DebugeeArgumentHandler\n- *\/\n-public final class BindServer {\n-\n-    \/** Version of <code>BindServer<\/code> implementation. *\/\n-    public static final long VERSION = 2;\n-\n-    \/** Timeout in milliseconds used for waiting for inner threads. *\/\n-    private static long THREAD_TIMEOUT = DebugeeBinder.THREAD_TIMEOUT;      \/\/ milliseconds\n-\n-    private static int PASSED = 0;\n-    private static int FAILED = 2;\n-    private static int JCK_BASE = 95;\n-\n-    private static int TRACE_LEVEL_PACKETS = 10;\n-    private static int TRACE_LEVEL_THREADS = 20;\n-    private static int TRACE_LEVEL_ACTIONS = 30;\n-    private static int TRACE_LEVEL_SOCKETS = 40;\n-    private static int TRACE_LEVEL_IO = 50;\n-\n-    private static String pathSeparator = System.getProperty(\"path.separator\");\n-    private static String fileSeparator = System.getProperty(\"file.separator\");\n-\n-    private static char pathSeparatorChar = pathSeparator.charAt(0);\n-    private static char fileSeparatorChar = fileSeparator.charAt(0);\n-\n-    private static Log log = null;\n-    private static Log.Logger logger = null;\n-    private static ArgumentHandler argHandler = null;\n-\n-    private static String pathConvertions[][] = null;\n-\n-\n-    private int totalRequests = 0;\n-    private int acceptedRequests = 0;\n-    private int unauthorizedRequests = 0;\n-    private int busyRequests = 0;\n-\n-    \/**\n-     * Start <code>BindServer<\/code> utility from command line.\n-     * This method invokes <code>run()<\/code> and redirects output\n-     * to <code>System.err<\/code>.\n-     *\n-     * @param argv list of command line arguments\n-     *\/\n-    public static void main (String argv[]) {\n-        System.exit(run(argv,System.err) + JCK_BASE);\n-    }\n-\n-    \/**\n-     * Start <code>BindServer<\/code> utility from JCK-compatible\n-     * environment.\n-     *\n-     * @param argv list of command line arguments\n-     * @param out outpur stream for log messages\n-     *\n-     * @return FAILED if error occured\n-     *         PASSED oterwise\n-     *\/\n-    public static int run(String argv[], PrintStream out) {\n-        return new BindServer().runIt(argv, out);\n-    }\n-    \/**\n-     * Perform execution of <code>BindServer<\/code>.\n-     * This method handles command line arguments, starts seperate\n-     * thread for listening connection from test on remote host,\n-     * and waits for command \"exit\" from a user.\n-     * Finally it closes all conections and prints connections\n-     * statiscs.\n-     *\n-     * @param argv list of command line arguments\n-     * @param out outpur stream for log messages\n-     *\n-     * @return FAILED if error occured\n-     *         PASSED oterwise\n-     *\/\n-    private int runIt(String argv[], PrintStream out) {\n-        try {\n-            argHandler = new ArgumentHandler(argv);\n-        } catch (ArgumentHandler.BadOption e) {\n-            out.println(\"ERROR: \" + e.getMessage());\n-            return FAILED;\n-        }\n-\n-        if (argHandler.getArguments().length > 0) {\n-            out.println(\"ERROR: \" + \"Too many positional arguments in command line\");\n-            return FAILED;\n-        }\n-\n-        log = new Log(out, argHandler);\n-        logger = new Log.Logger(log, \"\");\n-\n-        logger.trace(TRACE_LEVEL_THREADS, \"BindServer: starting main thread\");\n-\n-        logger.display(\"Listening to port: \" + argHandler.getBindPortNumber());\n-        logger.display(\"Authorizing host: \" + argHandler.getDebuggerHost());\n-\n-        pathConvertions = new String[][] {\n-            { \"TESTED_JAVA_HOME\", argHandler.getDebuggerJavaHome(), argHandler.getDebugeeJavaHome() },\n-            { \"TESTBASE\", argHandler.getDebuggerTestbase(), argHandler.getDebugeeTestbase() },\n-            { \"WORKDIR\", argHandler.getDebuggerWorkDir(), argHandler.getDebugeeWorkDir() }\n-        };\n-\n-        logger.display(\"Translating pathes:\");\n-        for (int i = 0; i < pathConvertions.length; i++) {\n-            logger.display(pathConvertions[i][0] + \":\" +\"\\n\"\n-                         + \"  \" + pathConvertions[i][1] + \"\\n\"\n-                         + \"  =>\" + \"\\n\"\n-                         + \"  \" + pathConvertions[i][2]);\n-        }\n-\n-        String windir = argHandler.getDebugeeWinDir();\n-        if (!(windir == null || windir.equals(\"\"))) {\n-            logger.display(\"Using WINDIR: \\n\"\n-                         + \"  \" + argHandler.getDebugeeWinDir());\n-        }\n-\n-        BufferedReader stdIn = new BufferedReader(\n-            new InputStreamReader(System.in, System.getProperty(\"stdin.encoding\")));\n-        try (ListeningThread listeningThread = new ListeningThread(this)) {\n-            listeningThread.bind();\n-            listeningThread.start();\n-\n-            System.out.println(\"\\n\"\n-                              + \"BindServer started\" + \"\\n\"\n-                              + \"Type \\\"exit\\\" to shut down BindServer\"\n-                              + \"\\n\");\n-\n-            for (; ; ) {\n-                try {\n-                    String userInput = stdIn.readLine();\n-                    if (userInput == null || userInput.equals(\"exit\")\n-                            || userInput.equals(\"quit\")) {\n-                        logger.display(\"Shutting down BindServer\");\n-                        stdIn.close();\n-                        stdIn = null;\n-                        break;\n-                    } else if (userInput.trim().equals(\"\")) {\n-                        continue;\n-                    } else {\n-                        System.out.println(\"ERROR: Unknown command: \" + userInput);\n-                    }\n-                } catch (IOException e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    throw new Failure(\"Caught exception while reading console command:\\n\\t\"\n-                            + e);\n-                }\n-            }\n-\n-            printSummary(System.out);\n-\n-            logger.trace(TRACE_LEVEL_THREADS, \"BindServer: exiting main thread\");\n-        }\n-\n-        return PASSED;\n-    }\n-\n-    \/**\n-     * Print usefull summary statistics about connections occured.\n-     *\n-     * @param out output stream for printing statistics\n-     *\/\n-    private void printSummary(PrintStream out) {\n-        out.println(\"\\n\"\n-                + \"Connections summary:\" + \"\\n\"\n-                + \"  Tolal connections:     \" + totalRequests + \"\\n\"\n-                + \"  Accepted authorized:   \" + acceptedRequests + \"\\n\"\n-                + \"  Rejected unauthorized  \" + unauthorizedRequests + \"\\n\"\n-                + \"  Rejected being busy:   \" + busyRequests + \"\\n\");\n-    };\n-\n-    \/**\n-     * Check if given <code>path<\/code> starts with the specified prefix taking\n-     * into account difference between <code>slashChar<code> used in <code>path<\/code>\n-     * and <code>fileSeparatorChar<\/code> used in <code>prefix<\/code>.\n-     *\n-     * @param path path to check\n-     * @param prefix prefix to compare with\n-     * @param slashChar file separator used in <code>path<\/code>\n-     *\/\n-    private static boolean checkPathPrefix(String path, String prefix, char slashChar) {\n-        int prefixLength = prefix.length();\n-        if (prefixLength > path.length()) {\n-            return false;\n-        }\n-        for (int i = 0; i < prefixLength; i++) {\n-            char pathChar = path.charAt(i);\n-            char prefixChar = prefix.charAt(i);\n-\n-            if (pathChar != prefixChar) {\n-                if ((pathChar == slashChar || pathChar == fileSeparatorChar\n-                         || pathChar == '\\\\' || pathChar == '\/')\n-                    && (prefixChar == slashChar || prefixChar == fileSeparatorChar\n-                         || prefixChar == '\\\\' || prefixChar == '\/')) {\n-                    \/\/ do nothing\n-                } else {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Convert given path according to list of prefixes from\n-     * <code>pathConvertions<\/code> table.\n-     *\n-     * @param path path for converting\n-     * @param slash file separator used in <code>path<\/code>\n-     * @param name path identifier used for error messages\n-     * @param strict force throwing Failure if path is not matched\n-     *\n-     * @return string with the converted path\n-     *\n-     * @throws Failure if path does not matched for translation\n-     *\/\n-    private static String convertPath(String path, String slash, String name, boolean strict) {\n-        if (path == null)\n-            return null;\n-\n-        char slashChar = slash.charAt(0);\n-\n-        for (int i = 0; i < pathConvertions.length; i++) {\n-            String from = pathConvertions[i][1];\n-            String to = pathConvertions[i][2];\n-            if (checkPathPrefix(path, from, slashChar)) {\n-                return (to + path.substring(from.length())).replace(slashChar, fileSeparatorChar);\n-            }\n-        }\n-        if (strict) {\n-            throw new Failure(\"Path not matched for translation \" + name + \":\\n\\t\" + path);\n-        }\n-        return path;\n-    }\n-\n-    \/**\n-     * Convert given list of pathes according to list of prefixes from\n-     * <code>pathConvertions<\/code> table by invoking <code>convertPath()<\/code>\n-     * for each path from the list.\n-     *\n-     * @param list list of pathes for converting\n-     * @param slash file separator used in pathes\n-     * @param name path identifier used for error messages\n-     * @param strict force throwing Failure if some path is not matched\n-     *\n-     * @return list of strings with converted pathes\n-     *\n-     * @throws Failure if some path does not matched for translation\n-     *\n-     * @see #convertPath()\n-     *\/\n-    private static String[] convertPathes(String[] list, String slash, String name, boolean strict) {\n-        String[] converted = new String[list.length];\n-        for (int i = 0; i < list.length; i++) {\n-            converted[i] = convertPath(list[i], slash, name, strict);\n-        }\n-        return converted;\n-    }\n-\n-    \/**\n-     * Pause current thread for specified amount of time in milliseconds,\n-     * This method uses <code>Object.wait(long)<\/code> method as a reliable\n-     * method which prevents whole VM from suspending.\n-     *\n-     * @param millisecs - amount of time in milliseconds\n-     *\/\n-    private static void sleeping(int millisecs) {\n-        Object obj = new Object();\n-\n-        synchronized(obj) {\n-            try {\n-                obj.wait(millisecs);\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                new Failure(\"Thread interrupted while sleeping:\\n\\t\" + e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Wait for given thread finished for specified timeout or\n-     * interrupt this thread if not finished.\n-     *\n-     * @param thr thread to wait for\n-     * @param millisecs timeout in milliseconds\n-     *\/\n-    private static void waitInterruptThread(Thread thr, long millisecs) {\n-        if (thr != null) {\n-            String name = thr.getName();\n-            try {\n-                if (thr.isAlive()) {\n-                    logger.trace(TRACE_LEVEL_THREADS, \"Waiting for thread: \" + name);\n-                    thr.join(millisecs);\n-                }\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure (\"Thread interrupted while waiting for another thread:\\n\\t\"\n-                                     + e);\n-            } finally {\n-                if (thr.isAlive()) {\n-                    logger.trace(TRACE_LEVEL_THREADS, \"Interrupting not finished thread: \" + name);\n-                    thr.interrupt();\n-\/*\n-                    logger.display(\"Stopping not finished thread: \" + thr);\n-                    thr.stop();\n- *\/\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Wait for given thread finished for default timeout\n-     * <code>THREAD_TIMEOUT<\/code> and\n-     * interrupt this thread if not finished.\n-     *\n-     * @param thr thread to wait for\n-     *\/\n-    private static void waitInterruptThread(Thread thr) {\n-        waitInterruptThread(thr, THREAD_TIMEOUT);\n-    }\n-\n-\/\/\/\/\/\/\/\/\/ Thread listening a TCP\/IP socket \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An inner thread used for listening connection from remote test\n-     * and starting separate serving thread for each accepted connection.\n-     *\n-     * @see ServingThread\n-     *\/\n-    private static class ListeningThread extends Thread implements AutoCloseable {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-\n-        private BindServer owner = null;\n-        private volatile ServingThread servingThread = null;\n-        private volatile int taskCount = 0;\n-\n-        private ObjectOutputStream socOut = null;\n-        private ObjectInputStream socIn = null;\n-\n-        private String autorizedHostName = argHandler.getDebuggerHost();\n-        private InetAddress autorizedInetAddresses[] = null;\n-        private int port = argHandler.getBindPortNumber();\n-        private Socket socket = null;\n-        private ServerSocket serverSocket = null;\n-        private InetAddress clientInetAddr = null;\n-        private String clientHostName = null;\n-        private SocketConnection connection = null;\n-\n-        \/**\n-         * Make listening thread for given <code>BindServer<\/code> object\n-         * as an owner and bind it to listening port by invoking method\n-         * <code>bind()<\/code>.\n-         *\n-         * @see bind()\n-         *\/\n-        public ListeningThread(BindServer owner) {\n-            super(\"ListeningThread\");\n-            this.owner = owner;\n-            try {\n-                autorizedInetAddresses = InetAddress.getAllByName(autorizedHostName);\n-            } catch (UnknownHostException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Cannot resolve DEBUGGER_HOST value: \" + autorizedHostName);\n-            }\n-        }\n-\n-        \/**\n-         * Bind ServerSocket to the specified port.\n-         *\/\n-        public void bind() {\n-            for (int i = 0; !shouldStop && i < DebugeeBinder.CONNECT_TRIES; i++) {\n-                try {\n-                    logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: binding to server socket ...\");\n-                    \/\/ length of the queue = 2\n-                    serverSocket = new ServerSocket(port, 2);\n-                    \/\/ timeout for the ServerSocket.accept()\n-                    serverSocket.setSoTimeout(DebugeeBinder.CONNECT_TRY_DELAY);\n-                    logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: socket bound: \" + serverSocket);\n-                    logger.display(\"Bound to listening port\");\n-                    return;\n-                } catch (BindException e) {\n-                    logger.display(\"Socket binding try #\" + i + \" failed:\\n\\t\" + e);\n-                    sleeping(DebugeeBinder.CONNECT_TRY_DELAY);\n-                } catch (IOException e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    throw new Failure(\"Caught exception while binding to socket:\\n\\t\"\n-                                    + e);\n-                }\n-            }\n-            throw new Failure(\"Unable to bind to socket after \"\n-                + DebugeeBinder.CONNECT_TRIES + \" tries\");\n-        }\n-\n-        \/**\n-         * Accept socket connection from authorized remote host and\n-         * start separate <code>SrvingThread<\/code> to handle each connection.\n-         * Connection from unauthorized hosts or connections made while\n-         * current connection is alive are rejected.\n-         *\n-         * @see ServingThread\n-         * @see #llowConnection()\n-         * @see allowServing()\n-         *\/\n-        public void run() {\n-            String reply = null;\n-\n-            logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread: started\");\n-            logger.display(\"Listening for connection from remote host\");\n-            while(!(shouldStop || isInterrupted())) {\n-                try {\n-                    try {\n-                        logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: waiting for connection from test\");\n-                        socket = serverSocket.accept();\n-                        logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: connection accepted\");\n-                    } catch(InterruptedIOException e) {\n-\/\/                        logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: timeout of waiting for connection from test\");\n-                        continue;\n-                    }\n-                    owner.totalRequests++;\n-                    logger.display(\"\");\n-                    clientInetAddr = socket.getInetAddress();\n-                    clientHostName = clientInetAddr.getHostName();\n-                    logger.display(\"Connection #\" + owner.totalRequests\n-                                    + \" requested from host: \" + clientHostName);\n-                    connection = new SocketConnection(logger, \"BindServer\");\n-\/\/                    connection.setPingTimeout(DebugeeBinder.PING_TIMEOUT);\n-                    connection.setSocket(socket);\n-                    socket = null;\n-                    if (allowConnection()) {\n-                        if (allowServing()) {\n-                            owner.acceptedRequests++;\n-                            reply = \"host authorized: \" + clientHostName;\n-                            logger.display(\"Accepting connection #\" + owner.acceptedRequests\n-                                            + \": \" + reply);\n-                            servingThread = new ServingThread(this, connection);\n-                            servingThread.start();\n-                            cleanHostConnection();\n-                        } else {\n-                            owner.busyRequests++;\n-                            reply = \"BindServer is busy\";\n-                            logger.complain(\"Rejecting connection #\" + owner.busyRequests\n-                                            + \": \" + reply);\n-                            connection.writeObject(new RequestFailed(reply));\n-                            closeHostConnection();\n-                        }\n-                    } else {\n-                        owner.unauthorizedRequests++;\n-                        reply = \"host unauthorized: \" + clientHostName;\n-                        logger.complain(\"Rejecting connection #\" + owner.unauthorizedRequests\n-                                            + \": \" + reply);\n-                        connection.writeObject(new RequestFailed(reply));\n-                        closeHostConnection();\n-                    }\n-                } catch (Exception e) {\n-                    logger.complain(\"Caught exception while accepting connection:\\n\" + e);\n-                    e.printStackTrace(log.getOutStream());\n-                }\n-            }\n-            logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread: exiting\");\n-            closeConnection();\n-        }\n-\n-        \/**\n-         * Check if the connection made is from authorized host.\n-         *\n-         * @return true if connection is allowed because host authorized\n-         *         false if connection is rejected because host unauthorized\n-         *\/\n-        private boolean allowConnection() {\n-            \/\/ check if local host from loopback address\n-            if (autorizedHostName.equals(\"localhost\"))\n-                return clientInetAddr.isLoopbackAddress();\n-\n-            \/\/ check if equal hostname\n-            if (autorizedHostName.equals(clientHostName))\n-                return true;\n-\n-            \/\/ check if equal host address\n-            for (int i = 0; i < autorizedInetAddresses.length; i++) {\n-                if (clientInetAddr.equals(autorizedInetAddresses[i])) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        \/**\n-         * Check if no current connection exists or it is dead.\n-         * If current connection presents it will be tested by pinging\n-         * remote host and aborted if host sends no reply. If an alive\n-         * connection exists, new connection will be rejected.\n-         *\n-         * @return true if no alive connection exists\n-         *         false otherwise\n-         *\/\n-        private boolean allowServing() {\n-            if (servingThread == null) {\n-                return true;\n-            }\n-            if (servingThread.done) {\n-                return true;\n-            }\n-            if (!servingThread.isConnectionAlive()) {\n-                logger.display(\"# WARNING: Previous connection from remote host is dead: aborting connection\");\n-                servingThread.close();\n-                servingThread = null;\n-                return true;\n-            }\n-\n-\/*\n-            logger.complain(\"Previous connection from remote host is alive: starting new connection\");\n-            servingThread = null;\n-            return true;\n- *\/\n-            logger.complain(\"Previous connection from remote host is alive: reject new connection\");\n-            return false;\n-        }\n-\n-        \/**\n-         * Wait for this thread finished\n-         * for specified timeout or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close socket connection from remote host.\n-         *\/\n-        private void closeHostConnection() {\n-            if (connection != null) {\n-                connection.close();\n-            }\n-            if (socket != null) {\n-                try {\n-                    socket.close();\n-                } catch (IOException e) {\n-                    logger.complain(\"Caught IOException while closing socket:\\n\\t\"\n-                                    + e);\n-                }\n-                socket = null;\n-            }\n-        }\n-\n-        \/**\n-         * Assign <null> to connection and socket objects\n-         * but do not close them.\n-         *\/\n-        private void cleanHostConnection() {\n-            connection = null;\n-            socket = null;\n-        }\n-\n-        \/**\n-         * Close all connections and sockets.\n-         *\/\n-        private void closeConnection() {\n-            closeHostConnection();\n-            if (serverSocket != null) {\n-                try {\n-                    serverSocket.close();\n-                } catch (IOException e) {\n-                    logger.complain(\"Caught IOException while closing ServerSocket:\\n\\t\"\n-                                    + e);\n-                }\n-                serverSocket = null;\n-            }\n-        }\n-\n-        \/**\n-         * Close thread by closing all connections and waiting\n-         * for thread to finish.\n-         *\n-         * @see #closeConnection()\n-         *\/\n-        @Override\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            try {\n-                closeHostConnection();\n-                if (servingThread != null) {\n-                    servingThread.close();\n-                    servingThread = null;\n-                }\n-                waitForThread(THREAD_TIMEOUT);\n-                closeConnection();\n-                closed = true;\n-                logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread closed\");\n-            } catch (Throwable e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while closing ListeningThread:\\n\\t\" + e);\n-            }\n-        }\n-\n-    } \/\/ ListeningThread\n-\n-\/\/\/\/\/\/\/\/\/ Thread working with a communication channel \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An internal thread for handling each connection from a test\n-     * on remote host. It reads requests from test and starts separate\n-     * <code>LaunchingThread<\/code> to execute each request.\n-     *\n-     * @see LaunchingThread\n-     *\/\n-    private static class ServingThread extends Thread {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-        private volatile boolean done = false;\n-\n-        private ListeningThread owner = null;\n-        private LaunchingThread launchingThread = null;\n-\n-        private SocketConnection connection = null;\n-\n-        \/**\n-         * Make serving thread with specified input\/output connection streams\n-         * and given <code>Listenerthread<\/code> as an owner.\n-         *\n-         * @param owner owner of this thread\n-         * @param connection established socket connection with test\n-         *\/\n-        public ServingThread(ListeningThread owner, SocketConnection connection) {\n-            super(\"ServingThread\");\n-            this.owner = owner;\n-            this.connection = connection;\n-        }\n-\n-        \/**\n-         * Read requests from socket connection and start <code>LaunchingThread<\/code>\n-         * to perform each requested action.\n-         *\/\n-        public void run() {\n-            logger.trace(TRACE_LEVEL_THREADS, \"ServingThread: starting handling requests from debugger\");\n-            try {\n-                \/\/ sending OK(version)\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"ServingThread: sending initial OK(VERSION) to debugger\");\n-                connection.writeObject(new OK(VERSION));\n-\n-                \/\/ receiving TaskID(id)\n-                logger.trace(TRACE_LEVEL_IO, \"ServingThread: waiting for TaskID from debugger\");\n-                Object taskID = connection.readObject();\n-                logger.trace(TRACE_LEVEL_IO, \"ServingThread: received TaskID from debugger: \" + taskID);\n-                if (taskID instanceof TaskID) {\n-                    String id = ((TaskID)taskID).id;\n-                    owner.taskCount++;\n-                    logger.println(\"[\" + owner.taskCount + \"\/\" + owner.owner.totalRequests + \"]: \" + id);\n-                } else {\n-                    throw new Failure(\"Unexpected TaskID received form debugger: \" + taskID);\n-                }\n-\n-                \/\/ starting launching thread\n-                launchingThread = new LaunchingThread(this, connection);\n-                launchingThread.start();\n-\n-                \/\/ receiving and handling requests\n-                while(!(shouldStop || isInterrupted())) {\n-                    logger.trace(TRACE_LEVEL_IO, \"ServingThread: waiting for request from debugger\");\n-                    Object request = connection.readObject();\n-                    logger.trace(TRACE_LEVEL_IO, \"ServingThread: received request from debugger: \" + request);\n-                    if (request == null) {\n-                        logger.display(\"Connection closed\");\n-                        break;\n-                    } else if (request instanceof Disconnect) {\n-                        logger.display(\"Closing connection by request\");\n-                        request = null;\n-                        break;\n-                    } else {\n-                        boolean success = false;\n-                        long timeToFinish = System.currentTimeMillis() + THREAD_TIMEOUT;\n-                        while (System.currentTimeMillis() < timeToFinish) {\n-                            if (launchingThread.doneRequest()) {\n-                                success = true;\n-                                logger.trace(TRACE_LEVEL_ACTIONS, \"ServingThread: asking launching thread to handle request: \" + request);\n-                                launchingThread.handleRequest(request);\n-                                break;\n-                            }\n-                            try {\n-                                launchingThread.join(DebugeeBinder.TRY_DELAY);\n-                            } catch (InterruptedException e) {\n-                                throw new Failure(\"ServingThread interrupted while waiting for LaunchingThread:\\n\\t\"\n-                                                + e);\n-                            }\n-                        }\n-                        if (!success) {\n-                            logger.complain(\"Rejecting request because of being busy:\\n\" + request);\n-                            connection.writeObject(\n-                                new RequestFailed(\"Busy with handling previous request\"));\n-                        }\n-                    }\n-                }\n-            } catch (Exception e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while handling request:\\n\\t\" + e);\n-            } finally {\n-                logger.trace(TRACE_LEVEL_THREADS, \"ServingThread: exiting\");\n-                closeConnection();\n-                done = true;\n-            }\n-        }\n-\n-        \/**\n-         * Check if present socket connection is alive.\n-         *\/\n-        private boolean isConnectionAlive() {\n-            return (connection != null && connection.isConnected());\n-        }\n-\n-        \/**\n-         * Wait for this thread finished\n-         * for specified timeout or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close socket connection from remote host.\n-         *\/\n-        private void closeConnection() {\n-            if (connection != null) {\n-                connection.close();\n-            }\n-            if (launchingThread != null) {\n-                launchingThread.handleRequest(null);\n-            }\n-        }\n-\n-        \/**\n-         * Close thread closing socket connection and\n-         * waiting for thread finished.\n-         *\/\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            closeConnection();\n-            if (launchingThread != null) {\n-                launchingThread.close();\n-                launchingThread = null;\n-            }\n-            waitForThread(THREAD_TIMEOUT);\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"ServingThread closed\");\n-        }\n-\n-    } \/\/ ServingThread\n-\n-\/\/\/\/\/\/\/\/\/ Thread serving a particular Binder's request \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An internal thread to execute each request from a test on remote host.\n-     * Requests are coming from ServingThread by invoking handleRequest(Object)\n-     * method.\n-     *\/\n-    private static class LaunchingThread extends Thread {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-        public volatile boolean done = false;\n-\n-        private ServingThread owner = null;\n-\/\/        private ProcessWaitingThread waitingThread = null;\n-        private Process process = null;\n-\n-        private StreamRedirectingThread stdoutRedirectingThread = null;\n-        private StreamRedirectingThread stderrRedirectingThread = null;\n-\n-        \/** Notification about request occurence. *\/\n-        private volatile Object notification = new Object();\n-        \/** Request to execute. *\/\n-        private volatile Object request = null;\n-        \/** Socket stream to send replies to. *\/\n-        private SocketConnection connection = null;\n-\n-        \/**\n-         * Make thread for executing requests from a test and\n-         * send reply.\n-         *\n-         * @param owner owner of this thread\n-         * @connection socket connection for sending replies\n-         *\/\n-        public LaunchingThread(ServingThread owner, SocketConnection connection) {\n-            super(\"LaunchingThread\");\n-            this.owner = owner;\n-            this.connection = connection;\n-        }\n-\n-        \/**\n-         * Notify this thread that new request has come.\n-         *\n-         * @param request request to execute\n-         *\/\n-        public void handleRequest(Object request) {\n-            synchronized (notification) {\n-                this.request = request;\n-                notification.notifyAll();\n-            }\n-        }\n-\n-        \/**\n-         * Check if request has been executed.\n-         *\/\n-        public boolean doneRequest() {\n-            return done;\n-        }\n-\n-        \/**\n-         * Wait for request notification from <code>ServingThread<\/code>\n-         * and execute an action according to the request.\n-         * Request <i>null<\/code> means thread should finish.\n-         *\/\n-        public void run() {\n-            logger.trace(TRACE_LEVEL_THREADS, \"LaunchingThread: started to handle request\");\n-            done = true;\n-            while (!isInterrupted()) {\n-                \/\/ wait for new request notification\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchingThread: waiting for request\");\n-                synchronized (notification) {\n-                    try {\n-                        notification.wait();\n-                    } catch (InterruptedException e) {\n-                        logger.complain(\"LaunchingThread interrupted while waiting for request:\\n\\t\"\n-                                        + e);\n-                        break;\n-                    }\n-                }\n-\n-                \/\/ execute the request\n-                try {\n-                    logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchingThread: handling request: \" + request);\n-                    if (request == null) {\n-                        break;\n-                    } else if (request instanceof LaunchDebugee) {\n-                        launchDebugee((LaunchDebugee)request);\n-                    } else if (request instanceof WaitForDebugee) {\n-                        waitForDebugee((WaitForDebugee)request);\n-                    } else if (request instanceof DebugeeExitCode) {\n-                        debugeeExitCode((DebugeeExitCode)request);\n-                    } else if (request instanceof KillDebugee) {\n-                        killDebugee((KillDebugee)request);\n-                    } else {\n-                        String reason = \"Unknown request: \" + request;\n-                        logger.complain(reason);\n-                        sendReply(new RequestFailed(reason));\n-                    }\n-                } catch (Exception e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    logger.complain(\"Caught exception while handling request:\\n\\t\" + e);\n-                }\n-                done = true;\n-            }\n-            done = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"LaunchingThread: exiting\");\n-            closeConnection();\n-        }\n-\n-        \/**\n-         * Send given reply to remote test.\n-         *\n-         * @param reply reply object to send\n-         *\/\n-        public void sendReply(Object reply) throws IOException {\n-            connection.writeObject(reply);\n-        }\n-\n-        \/**\n-         * Send given output line to remote test.\n-         *\n-         * @param reply wrapper object for output line to send\n-         *\/\n-        public void sendStreamMessage(RedirectedStream wrapper) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"Sending output line wrapper to debugger: \" + wrapper);\n-            if (connection.isConnected()) {\n-                sendReply(wrapper);\n-            } else {\n-                logger.complain(\"NOT redirected: \" + wrapper.line);\n-            }\n-        }\n-\n-        \/**\n-         * Launch two <code>StreamRedirectingThread<\/code> threads to redirect\n-         * stdin\/stderr output of debuggee VM process via <code>BindServer<\/code>\n-         * connection.\n-         *\n-         * @param process debuggee VM process\n-         *\/\n-        private void launchStreamRedirectors(Process process) {\n-            stdoutRedirectingThread =\n-                new StdoutRedirectingThread(this, process.getInputStream(),\n-                                            DebugeeProcess.DEBUGEE_STDOUT_LOG_PREFIX);\n-            stdoutRedirectingThread.start();\n-            stderrRedirectingThread =\n-                new StderrRedirectingThread(this, process.getErrorStream(),\n-                                            DebugeeProcess.DEBUGEE_STDERR_LOG_PREFIX);\n-            stderrRedirectingThread.start();\n-        }\n-\n-        \/**\n-         * Execute request for launching debuggee.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void launchDebugee(LaunchDebugee request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchDebugee: handle request: \" + request);\n-\n-            if (process != null) {\n-                logger.complain(\"Unable to launch debuggee: process already launched\");\n-                sendReply(new RequestFailed(\"Debuggee process already launched\"));\n-                return;\n-            }\n-\n-            try {\n-                String[] cmd = request.cmd;\n-                cmd[0] = convertPath(cmd[0], request.slash, \"TESTED_JAVA_HOME\", true);\n-                for (int i = 1; i < cmd.length; i++) {\n-                    cmd[i] = convertPath(cmd[i], request.slash, \"JAVA_ARGS\", false);\n-                }\n-                String workDir = convertPath(request.workDir, request.slash, \"WORKDIR\", true);\n-                String[] classPathes = convertPathes(request.classPathes, request.slash, \"CLASSPATH\", true);\n-                String windir = argHandler.getDebugeeWinDir();\n-\n-                boolean win = (!(windir == null || windir.equals(\"\")));\n-                String[] envp = new String[win ? 3 : 1] ;\n-                envp[0] = \"CLASSPATH=\" + ArgumentParser.joinArguments(classPathes, \"\", pathSeparator);\n-                if (win) {\n-                    envp[1] = \"WINDIR=\" + windir;\n-                    envp[2] = \"SystemRoot=\" + windir;\n-                }\n-\n-                logger.display(\"Setting environment:\\n\"\n-                                + \"  \" + ArgumentHandler.joinArguments(envp, \"\", \"\\n  \"));\n-                logger.display(\"Setting work dir:\\n\"\n-                                + \"  \" + workDir);\n-                logger.display(\"Launching debuggee:\\n\"\n-                                + \"  \" + ArgumentHandler.joinArguments(cmd, \"\\\"\"));\n-\n-                process = Runtime.getRuntime().exec(cmd, envp, new File(workDir));\n-                logger.display(\"  debuggee launched successfully\");\n-\n-                launchStreamRedirectors(process);\n-            } catch (Exception e) {\n-                if (!(e instanceof Failure)) {\n-                    e.printStackTrace(log.getOutStream());\n-                }\n-                logger.complain(\"Caught exception while launching debuggee:\\n\\t\" + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-\n-            sendReply(new OK());\n-        }\n-\n-        \/**\n-         * Execute request for waiting for debuggee exited.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void waitForDebugee(WaitForDebugee request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"WaitForDebugee: handle request: \" + request);\n-\n-            if (process == null) {\n-                String reply = \"No debuggee process to wait for\";\n-                logger.complain(reply);\n-                sendReply(new RequestFailed(reply));\n-                return;\n-            }\n-\n-            logger.display(\"Waiting for debuggee to exit\");\n-\/*\n-            \/\/ because timeout is not supported now\n-            \/\/ we do not use separate thread for waiting for process\n-            \/\/ and so following lines are commented out\n-\n-            waitingThread = new ProcessWaitingThread();\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchingThread: starting thread for waiting for debugee process\");\n-            waitingThread.start();\n-            try {\n-                waitingThread.join(request.timeout);\n-                if (waitingThread.isAlive()) {\n-                    String reply = \"Timeout exceeded while waiting for debuggee to exit\";\n-                    logger.complain(reply);\n-                    waitingThread.interrupt();\n-                    sendReply(socOut, new RequestFailed(reply));\n-                    return;\n-                }\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while waiting for debuggee:\\n\\t\" + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-            int exitStatus = waitingThread.exitStatus;\n-            waitingThread = null;\n- *\/\n-            int exitStatus;\n-            try {\n-                exitStatus = process.waitFor();\n-                waitForRedirectors(THREAD_TIMEOUT);\n-                process.destroy();\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while waiting for debuggee process to exit:\\n\\t\"\n-                                + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-            logger.display(\"  debuggee exited with exit status: \" + exitStatus);\n-            sendReply(new OK(exitStatus));\n-        }\n-\n-        \/**\n-         * Execute request for returning debuggee exit code.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void debugeeExitCode(DebugeeExitCode request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"DebugeeExitCode: handle request: \" + request);\n-\n-            if (process == null) {\n-                String reply = \"No debuggee process to get exit code for\";\n-                logger.complain(reply);\n-                sendReply(new RequestFailed(reply));\n-                return;\n-            }\n-\n-            int exitStatus = 0;\n-            try {\n-                exitStatus = process.exitValue();\n-            } catch (IllegalThreadStateException e) {\n-                logger.display(\"# WARNING: Caught exception while getting exit status of debuggee:\\n\\t\"\n-                                + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"DebugeeExitCode: return debuggee exit status: \" + exitStatus);\n-            sendReply(new OK(exitStatus));\n-        }\n-\n-        \/**\n-         * Execute request for unconditional terminating debuggee process.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void killDebugee(KillDebugee request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"killDebugee: handle request: \" + request);\n-\n-            if (process == null) {\n-                String reply = \"No debuggee process to kill\";\n-                logger.complain(reply);\n-                sendReply(new RequestFailed(reply));\n-                return;\n-            }\n-\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"killDebugee: killing debuggee process\");\n-            process.destroy();\n-\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"killDebugee: debuggee process killed\");\n-            sendReply(new OK());\n-        }\n-\n-        \/**\n-         * Terminate debigee VM process if still alive.\n-         *\/\n-        private void terminateDebugeeAtExit() {\n-            if (process != null) {\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"Checking that debuggee process has exited correctly\");\n-                try {\n-                    int value = process.exitValue();\n-                } catch (IllegalThreadStateException e) {\n-                    logger.complain(\"Debuggee process has not exited correctly: trying to kill it\");\n-                    process.destroy();\n-                    try {\n-                        int value = process.exitValue();\n-                    } catch (IllegalThreadStateException ie) {\n-                        logger.complain(\"Debuggee process is alive after killing it\");\n-                    }\n-                    process = null;\n-                    return;\n-                }\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"Debuggee process has exited correctly\");\n-            }\n-        }\n-\n-        \/**\n-         * Wait for stream redirecting threads finished\n-         * for specified timeout.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        private void waitForRedirectors(long millis) {\n-            try {\n-                if (stdoutRedirectingThread != null) {\n-                    stdoutRedirectingThread.join(millis);\n-                }\n-                if (stderrRedirectingThread != null) {\n-                    stderrRedirectingThread.join(millis);\n-                }\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while waiting for debuggee process exited:\\n\\t\"\n-                                + e);\n-            }\n-        }\n-\n-        \/**\n-         * Wait for this thread finished\n-         * for specified timeout or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            handleRequest(null);\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close connection with debuggee.\n-         *\/\n-        public void closeConnection() {\n-            \/\/ no connections to close\n-        }\n-\n-        \/**\n-         * Close thread by closing all connections with debuggee,\n-         * finishing all redirectors and wait for thread finished.\n-         *\/\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            closeConnection();\n-            terminateDebugeeAtExit();\n-            if (stdoutRedirectingThread != null) {\n-                stdoutRedirectingThread.close();\n-                stdoutRedirectingThread = null;\n-            }\n-            if (stderrRedirectingThread != null) {\n-                stderrRedirectingThread.close();\n-                stderrRedirectingThread = null;\n-            }\n-            waitForThread(THREAD_TIMEOUT);\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"LaunchingThread closed\");\n-        }\n-\n-        \/**\n-         * An inner thread for waiting for debuggee process exited\n-         * and saving its exit status. (currently not used)\n-         *\/\n-\/*\n-        private class ProcessWaitingThread extends Thread {\n-            int exitStatus = 0;\n-\n-            ProcessWaitingThread() {\n-                super(\"ProcessWaitingThread\");\n-            }\n-\n-            public void run() {\n-                logger.trace(TRACE_LEVEL_THREADS, \"ProcessWaitingThread: starting waiting for process\");\n-                try {\n-                    exitStatus = process.waitFor();\n-                } catch (InterruptedException e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    logger.complain(\"Caught exception while waiting for debuggee process:\\n\\t\"\n-                                    + e);\n-                }\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"ProcessWaitingThread: process finished with status: \" + exitStatus);\n-                logger.trace(TRACE_LEVEL_THREADS, \"ProcessWaitingThread: exiting\");\n-            }\n-\n-            public synchronized void close() {\n-                logger.trace(TRACE_LEVEL_THREADS, \"ProcessWaitingThread closed\");\n-            }\n-\n-        } \/\/ ProcessWaitingThread\n- *\/\n-    } \/\/ LaunchingThread\n-\n-\/\/\/\/\/\/\/\/\/ Redirecting threads \/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An abstract base class for internal threads which redirects stderr\/stdout\n-     * output from debuggee process via <code>BindServer<\/code> connection.\n-     * <p>\n-     * Two derived classes will redirect <i>stderr<\/i> or <\/i>stdout<\/i> stream\n-     * by enwrapping stream line by <code>DebugeeStderr<\/code> or\n-     * <code>DebugeeStderr<\/code> objects. They should implement only one\n-     * abstract method <code>enwrapLine(String)<\/code> to make the difference.\n-     *\/\n-    public static abstract class StreamRedirectingThread extends Thread {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-\n-        private LaunchingThread owner = null;\n-\n-        private BufferedReader bin = null;\n-        private String prefix = null;\n-\n-        \/**\n-         * Make a thread to enwrap and redirect lines from specified\n-         * input stream with given prefix.\n-         *\n-         * @param owner owner of this thread\n-         * @param is input stream to redirect lines from\n-         * @param prefix prefix to add to each line\n-         *\/\n-        public StreamRedirectingThread(LaunchingThread owner, InputStream is, String prefix) {\n-            super(\"StreamRedirectingThread\");\n-            this.prefix = prefix;\n-            this.owner = owner;\n-            bin = new BufferedReader(new InputStreamReader(is));\n-        }\n-\n-        \/**\n-         * Read lines from an input stream, enwrap them, and send to remote\n-         * test via <code>BindServer<\/code> connection.\n-         *\/\n-        public void run() {\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread: starting redirect output stream\");\n-            try {\n-                String line;\n-                logger.trace(TRACE_LEVEL_IO, \"StreamRedirectingThread: waiting for line from debuggee output\");\n-                while(!shouldStop) {\n-                    line = bin.readLine();\n-                    if (line == null)\n-                        break;\n-                    owner.sendStreamMessage(enwrapLine(prefix + line));\n-                }\n-            } catch (EOFException e) {\n-                logger.display(\"Debuggee output stream closed by process\");\n-            } catch (IOException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.display(\"# WARNING: Connection to debuggee output stream aborted:\\n\\t\" + e);\n-            } catch (Exception e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while redirecting debuggee output stream:\\n\\t\"\n-                                + e);\n-            }\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread: exiting\");\n-            closeConnection();\n-        }\n-\n-        \/**\n-         * Envrap output line by the appropriate wrapper.\n-         * @param line line to enwrap\n-         *\/\n-        protected abstract RedirectedStream enwrapLine(String line);\n-\n-        \/**\n-         * Wait for this thread finished or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close redirected process output stream.\n-         *\/\n-        public void closeConnection() {\n-            if (closed) {\n-                return;\n-            }\n-            if (bin != null) {\n-                try {\n-                    bin.close();\n-                } catch (IOException e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    logger.complain(\"Caught exception while closing debuggee output stream:\\n\\t\"\n-                                    + e);\n-                }\n-                bin = null;\n-            }\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread closed\");\n-        }\n-\n-        \/**\n-         * Close thread by waiting redirected stream closed\n-         * and finish the thread.\n-         *\/\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            waitForThread(THREAD_TIMEOUT);\n-            closeConnection();\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread closed\");\n-        }\n-\n-    } \/\/ StreamRedirectingThread\n-\n-    \/**\n-     * Particalar case of <code>StreamRedirectingThread<\/code> to redirect\n-     * <i>stderr<\/i> stream by enwrapping lines into <code>DebugeeStderr<\/code>\n-     * objects.\n-     *\/\n-    private static class StderrRedirectingThread extends StreamRedirectingThread {\n-\n-        \/**\n-         * Make a thread to redirect <i>stderr<\/i> output stream.\n-         *\/\n-        StderrRedirectingThread(LaunchingThread owner, InputStream is, String prefix) {\n-            super(owner, is, prefix);\n-            setName(\"StderrRedirectingThread\");\n-        }\n-\n-        \/**\n-         * Enwrap given line into <code>DebugeeStderr<\/code> object.\n-         *\/\n-        protected RedirectedStream enwrapLine(String line) {\n-            return new DebugeeStderr(line);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Particalar case of <code>StreamRedirectingThread<\/code> to redirect\n-     * <i>stdout<\/i> stream by enwrapping lines into <code>DebugeeStdout<\/code>\n-     * objects.\n-     *\/\n-    private static class StdoutRedirectingThread extends StreamRedirectingThread {\n-\n-        \/**\n-         * Make a thread to redirect <i>stdout<\/i> output stream.\n-         *\/\n-        StdoutRedirectingThread(LaunchingThread owner, InputStream is, String prefix) {\n-            super(owner, is, prefix);\n-            setName(\"StdoutRedirectingThread\");\n-        }\n-\n-        \/**\n-         * Enwrap given line into <code>DebugeeStdout<\/code> object.\n-         *\/\n-        protected RedirectedStream enwrapLine(String line) {\n-            return new DebugeeStdout(line);\n-        }\n-\n-    }\n-\n-\/\/\/\/\/\/\/\/\/ BinderServer's packets \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base serializable object to transmit request or reply\n-     * via <code>BindServer<\/code> connection.\n-     *\/\n-    public static class Packet implements Serializable {}\n-\n-    \/\/\/\/\/\/\/\/\/ Binder's requests \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base class to represent request to <code>BindServer<\/code>.\n-     *\/\n-    public static abstract class Request extends Packet {}\n-\n-    \/**\n-     * This class implements task identification command.\n-     *\/\n-    public static class TaskID extends Request {\n-        public String id;\n-\n-        public TaskID(String id) {\n-            this.id = id;\n-        }\n-\n-        public String toString() {\n-            return \"TaskID: id=\" + id;\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for launching a debugee.\n-     *\/\n-    public static class LaunchDebugee extends Request {\n-        public String slash;         \/\/ slash symbol used on debugger host\n-        public String[] cmd;         \/\/ command line arguments as seen on debugger host\n-        public String workDir;       \/\/ path to working directory as seen on debugger host\n-        public String[] classPathes; \/\/ list of class pathes as seen on debugger host\n-\n-        public LaunchDebugee(String[] cmd, String slash, String workDir,\n-                            String[] pathes, String[] classPathes,\n-                            String[] libPathes) {\n-            this.cmd = cmd;\n-            this.slash = slash;\n-            this.workDir = workDir;\n-            this.classPathes = classPathes;\n-        }\n-\n-        public String toString() {\n-            return \"LaunchDebugee:\"\n-                + \"\\n\\tcommand=\" + ArgumentParser.joinArguments(cmd, \"\\\"\")\n-                + \"\\n\\tWORKDIR=\" + workDir\n-                + \"\\n\\tCLASSPATH=\" + ArgumentParser.joinArguments(classPathes, \"\", \":\")\n-                + \"\\n\\tslash=\" + slash;\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for waiting for debugee\n-     * termination.\n-     *\/\n-    public static class WaitForDebugee extends Request {\n-        public long timeout = 0; \/\/ timeout in minutes for waiting\n-\n-        public WaitForDebugee(long value) {\n-            timeout = value;\n-        }\n-\n-        public String toString() {\n-            return \"WaitForDebugee: timeout=\" + timeout;\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for exit code of\n-     * debugee process.\n-     *\/\n-    public static class DebugeeExitCode extends Request {\n-        public String toString() {\n-            return \"SebugeeExitCode\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for killing debugee process.\n-     *\/\n-    public static class KillDebugee extends Request {\n-        public String toString() {\n-            return \"KillDebugee\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request to disconnect connection with test.\n-     *\/\n-    public static class Disconnect extends Request {\n-        public String toString() {\n-            return \"Disconnect\";\n-        }\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/ BindServer's responses \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base class to represent response from <code>BindServer<\/code>.\n-     *\/\n-    public static abstract class Response extends Packet {}\n-\n-    \/**\n-     * This class implements a response that a previoulsy received\n-     * request has been successfully performed.\n-     *\/\n-    public static class OK extends Response {\n-        public long info = BindServer.VERSION; \/\/ optional additional info\n-\n-        public OK() {\n-        }\n-\n-        public OK(long value) {\n-            info = value;\n-        }\n-\n-        public String toString() {\n-            return \"OK(\" + info + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a response that the BindServer is\n-     * unable to serve a previoulsy received request.\n-     *\/\n-    public static class RequestFailed extends Response {\n-        public String reason; \/\/ the short explanation of failure\n-\n-        public RequestFailed(String reason) {\n-            this.reason = reason;\n-        }\n-\n-        public String toString() {\n-            return \"RequestFailed(\" + reason + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a response that the BindServer is\n-     * unable to serve a previoulsy received request because of\n-     * caught exception.\n-     *\/\n-    public static class CaughtException extends RequestFailed {\n-        public CaughtException(Exception cause) {\n-            super(\"Caught exception: \" + cause);\n-        }\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/ Wrappers for redirected messages \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base class to represent wrappers for redirected streams.\n-     *\/\n-    public static class RedirectedStream extends Packet {\n-        public String line; \/\/ line containing line from redirected stream\n-\n-        public RedirectedStream(String str) {\n-            line = str;\n-        }\n-\n-        public String toString() {\n-            return \"RedirectedStream(\" + line + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class enwraps redirected line of <i>stdout<\/i> stream.\n-     *\/\n-    public static class DebugeeStdout extends RedirectedStream {\n-\n-        public DebugeeStdout(String str) {\n-            super(str);\n-        }\n-\n-        public String toString() {\n-            return \"DebugeeStdout(\" + line + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class enwraps redirected line of <i>stderr<\/i> stream.\n-     *\/\n-    public static class DebugeeStderr extends RedirectedStream {\n-        public DebugeeStderr(String str) {\n-            super(str);\n-        }\n-\n-        public String toString() {\n-            return \"DebugeeStderr(\" + line + \")\";\n-        }\n-    }\n-\n-\/\/\/\/\/\/\/ ArgumentHandler for BindServer command line \/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * This class is used to parse arguments from command line\n-     * and specified <i>bind-file<\/i>,\n-     *\/\n-    private static class ArgumentHandler extends ArgumentParser {\n-\n-        protected Properties fileOptions;\n-\n-        \/**\n-         * Make parser object for command line arguments.\n-         *\n-         * @param args list of command line arguments\n-         *\/\n-        public ArgumentHandler(String[] args) {\n-            super(args);\n-        }\n-\n-        \/**\n-         * Check if given command line option is aloowed.\n-         *\n-         * @param option option name\n-         * @param value option value\n-         *\/\n-        protected boolean checkOption(String option, String value) {\n-            if (option.equals(\"bind.file\")) {\n-                \/\/ accept any file name\n-                return true;\n-            }\n-            return super.checkOption(option, value);\n-        }\n-\n-        \/**\n-         * Check if all recignized options are compatible.\n-         *\/\n-        protected void checkOptions() {\n-            if (getBindFileName() == null) {\n-                throw new BadOption(\"Option -bind.file is requred \");\n-            }\n-            super.checkOptions();\n-        }\n-\n-        \/**\n-         * Check if value of this option points to a existing directory.\n-         *\n-         * @param option option name\n-         * @param dir option value\n-         *\/\n-        private void checkDir(String option, String dir) {\n-            File file = new File(dir);\n-            if (!file.exists()) {\n-                throw new BadOption(option + \" does not exist: \" + dir);\n-            }\n-            if (!file.isAbsolute()) {\n-                throw new BadOption(option + \" is not absolute pathname: \" + dir);\n-            }\n-            if (!file.isDirectory()) {\n-                throw new BadOption(option + \" is not directory: \" + dir);\n-            }\n-        }\n-\n-        \/**\n-         * Check if option from <i>bind-file<\/i> is allowed.\n-         *\n-         * @param option option name\n-         * @param value option value\n-         *\/\n-        protected boolean checkAdditionalOption(String option, String value) {\n-\n-            if (option.equals(\"DEBUGGER_HOST\")) {\n-                \/\/ accept any hostname\n-                return true;\n-            }\n-\n-            if (option.equals(\"BINDSERVER_PORT\")) {\n-                \/\/ accept only integer value\n-                try {\n-                    int port = Integer.parseInt(value);\n-                } catch (NumberFormatException e) {\n-                    throw new Failure(\"Not integer value of bind-file option \" + option\n-                                        + \": \" + value);\n-                }\n-                return true;\n-            }\n-\n-            if (option.equals(\"DEBUGGER_TESTED_JAVA_HOME\")\n-                    || option.equals(\"DEBUGGER_WORKDIR\")\n-                    || option.equals(\"DEBUGGER_TESTBASE\")) {\n-                if (value == null || value.equals(\"\")) {\n-                    throw new BadOption(\"Empty value of bind-file option \" + option);\n-                }\n-                return true;\n-            }\n-\n-            if (option.equals(\"DEBUGGEE_TESTED_JAVA_HOME\")\n-                    || option.equals(\"DEBUGGEE_WORKDIR\")\n-                    || option.equals(\"DEBUGGEE_TESTBASE\")) {\n-                if (value == null || value.equals(\"\")) {\n-                    throw new BadOption(\"Empty value of bind-file option \" + option);\n-                }\n-                checkDir(option, value);\n-                return true;\n-            }\n-\n-            if (option.equals(\"DEBUGGEE_WINDIR\")) {\n-                if (!(value == null || value.equals(\"\"))) {\n-                    checkDir(option, value);\n-                }\n-                return true;\n-            }\n-\n-            return false;\n-        }\n-\n-        \/**\n-         * Check if all recignized options form <i>bind-file<\/i> are compatible.\n-         *\/\n-        protected void checkAdditionalOptions() {\n-\n-            if (getDebuggerJavaHome() == null) {\n-                throw new BadOption(\"Option DEBUGGER_JAVA_HOME missed from bind-file\");\n-            }\n-            if (getDebuggerWorkDir() == null) {\n-                throw new BadOption(\"Option DEBUGGER_WORKDIR missed from bind-file\");\n-            }\n-            if (getDebuggerTestbase() == null) {\n-                throw new BadOption(\"Option DEBUGGER_TESTBASE missed from bind-file\");\n-            }\n-\n-            if (getDebugeeJavaHome() == null) {\n-                throw new BadOption(\"Option DEBUGGEE_JAVA_HOME missed from bind-file\");\n-            }\n-            if (getDebugeeWorkDir() == null) {\n-                throw new BadOption(\"Option DEBUGGEE_WORKDIR missed from bind-file\");\n-            }\n-            if (getDebugeeTestbase() == null) {\n-                throw new BadOption(\"Option DEBUGGEE_TESTBASE missed from bind-file\");\n-            }\n-        }\n-\n-        \/**\n-         * Parse options form specified <i>bind-file<\/i>.\n-         *\/\n-        protected void parseAdditionalOptions() {\n-            Enumeration keys = fileOptions.keys();\n-            while (keys.hasMoreElements()) {\n-                String option = (String)keys.nextElement();\n-                String value = fileOptions.getProperty(option);\n-                if (! checkAdditionalOption(option, value)) {\n-                    throw new BadOption(\"Unrecognized bind-file option: \" + option);\n-                }\n-            }\n-            checkAdditionalOptions();\n-        }\n-\n-        \/**\n-         * Parse all options from command line and specified <i>bind-file<\/i>.\n-         *\/\n-        protected void parseArguments() {\n-            super.parseArguments();\n-            String fileName = getBindFileName();\n-            try {\n-                FileInputStream bindFile = new FileInputStream(fileName);\n-                fileOptions = new Properties();\n-                fileOptions.load(bindFile);\n-                bindFile.close();\n-            } catch(FileNotFoundException e) {\n-                throw new BadOption(\"Unable to open bind-file \" + fileName + \": \" + e);\n-            } catch(IOException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Caught exception while reading bind-file:\\n\" + e);\n-            }\n-            parseAdditionalOptions();\n-        }\n-\n-        \/** Return name of specified <i>bind-file<i>. *\/\n-        public String getBindFileName() {\n-            return options.getProperty(\"bind.file\");\n-        }\n-\n-        \/** Return specified debuggee host name . *\/\n-        public String getDebuggerHost() {\n-            return fileOptions.getProperty(\"DEBUGGER_HOST\", \"localhost\");\n-        }\n-\n-        \/** Return string representation of port number for <code>BindServer<code> connection. *\/\n-        public String getBindPort() {\n-            return fileOptions.getProperty(\"BINDSERVER_PORT\", \"9000\");\n-        }\n-\n-        \/** Return specified port number for <code>BindServer<code> connection. *\/\n-        public int getBindPortNumber() {\n-            try {\n-                return Integer.parseInt(getBindPort());\n-            } catch (NumberFormatException e) {\n-                throw new Failure(\"Not integer value of BindServer port\");\n-            }\n-        }\n-\n-        \/** Return specified path to tested JDK used for debuggee VM. *\/\n-        public String getDebugeeJavaHome() {\n-            return fileOptions.getProperty(\"DEBUGGEE_TESTED_JAVA_HOME\");\n-        }\n-\n-        \/** Return specified path to tested JDK used for debugger. *\/\n-        public String getDebuggerJavaHome() {\n-            return fileOptions.getProperty(\"DEBUGGER_TESTED_JAVA_HOME\");\n-        }\n-\n-        \/** Return specified path to working dir from debuggee host. *\/\n-        public String getDebugeeWorkDir() {\n-            return fileOptions.getProperty(\"DEBUGGEE_WORKDIR\");\n-        }\n-\n-        \/** Return specified path to working dir from debugger host. *\/\n-        public String getDebuggerWorkDir() {\n-            return fileOptions.getProperty(\"DEBUGGER_WORKDIR\");\n-        }\n-\n-        \/** Return specified path to testbase dir from debuggee host. *\/\n-        public String getDebugeeTestbase() {\n-            return fileOptions.getProperty(\"DEBUGGEE_TESTBASE\");\n-        }\n-\n-        \/** Return specified path to testbase dir from debugger host. *\/\n-        public String getDebuggerTestbase() {\n-            return fileOptions.getProperty(\"DEBUGGER_TESTBASE\");\n-        }\n-\n-        \/** Return specified path to system directory on Wimdows platform. *\/\n-        public String getDebugeeWinDir() {\n-            return fileOptions.getProperty(\"DEBUGGEE_WINDIR\");\n-        }\n-\n-    } \/\/ ArgumentHandler\n-\n-} \/\/ BindServer\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/BindServer.java","additions":0,"deletions":1847,"binary":false,"changes":1847,"status":"deleted"},{"patch":"@@ -70,2 +70,0 @@\n- * <li> <code>-bind.port=<\/code>&lt;<i>port<\/i>&gt; -\n- *   port number for BindServer connection\n@@ -424,41 +422,0 @@\n-    private boolean bindPortInited = false;\n-    \/**\n-     * Return string representation of the port number for BindServer connection,\n-     * specified by <code>-bind.port<\/code> command line option, or\n-     * \"<i>DEFAULT_BIND_PORT<\/i>\" string by default.\n-     *\n-     * @see #getBindPortNumber()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getBindPort() {\n-        String port = options.getProperty(\"bind.port\");\n-        if (port == null) {\n-            if (!bindPortInited) {\n-                port = findFreePort();\n-                if (port == null) {\n-                    port = DEFAULT_BIND_PORT;\n-                }\n-                options.setProperty(\"bind.port\", port);\n-                bindPortInited = true;\n-            }\n-        }\n-        return port;\n-    }\n-\n-    \/**\n-     * Return port number for BindServer connection,\n-     * specified by <code>-bind.port<\/code> command line option, or\n-     * \"<i>DEFAULT_BIND_PORT<\/i>\" port number by default.\n-     *\n-     * @see #getBindPort()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public int getBindPortNumber() {\n-        String value = getBindPort();\n-        try {\n-            return Integer.parseInt(value);\n-        } catch (NumberFormatException e) {\n-            throw new TestBug(\"Not integer value of \\\"bind.port\\\" argument: \" + value);\n-        }\n-    }\n-\n@@ -686,1 +643,0 @@\n-            || option.equals(\"bind.port\")\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeArgumentHandler.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n- * @see BindServer\n@@ -57,0 +56,1 @@\n+ * @see nsk.share.jdb.Launcher\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeBinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * that the process should be started in (locally, remotely or manually).\n+ * that the process should be started in (locally).\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n- * This channel is based on TCP\/IP sockets and works in all\n- * modes (local, remote and manual). In a remote mode\n- * connection to <code>BindServer<\/code> is used for redirecting IOPipe messages.\n- * In all other modes direct TCP\/IP coonnection between two VMs is used.\n+ * This channel is based on TCP\/IP sockets.\n@@ -37,1 +34,2 @@\n- * @see BindServer\n+ * @see jpda.DebugeeArgumentHandler\n+ * @see jpda.DebugeeProcess\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/IOPipe.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @requires os.maxMemory > 3G\n@@ -40,0 +41,1 @@\n+ *      -Xmx2G\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_InternedStrings\/TestDescription.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @requires os.maxMemory > 3G\n@@ -40,0 +41,1 @@\n+ *      -Xmx2G\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_InternedStrings_NonbranchyTree\/TestDescription.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @requires os.maxMemory > 3G\n@@ -40,0 +41,1 @@\n+ *      -Xmx2G\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_Strings_ArrayOf\/TestDescription.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @requires os.maxMemory > 3G\n@@ -40,0 +41,1 @@\n+ *      -Xmx2G\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Humongous_InternedStrings\/TestDescription.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,0 @@\n-import java.util.*;\n-\n@@ -57,3 +55,0 @@\n-import java.io.*;\n-import java.text.*;\n-\n@@ -139,3 +134,0 @@\n-        final InputStreamReader isr = new InputStreamReader(System.in);\n-        final BufferedReader    br  = new BufferedReader(isr);\n-\n@@ -147,49 +139,38 @@\n-                    synchronized( isr ) {\n-                        boolean done = false;\n-                        try {\n-                            \/\/ For each thread, run until numHits bkpts have been hit\n-                            for( int i = 0; i < nhits; i++ ) {\n-                                \/\/ This is a tendril from the original jdb test.\n-                                \/\/ It could probably be deleted.\n-                                System.out.println(\"Thread \" + threadName + \" Enter a string: \");\n-                                String s = \"test\" + num;\n-                                switch (num) {\n-                                case 0: bkpt0(); break;\n-                                case 1: bkpt1(); break;\n-                                case 2: bkpt2(); break;\n-                                case 3: bkpt3(); break;\n-                                case 4: bkpt4(); break;\n-                                case 5: bkpt5(); break;\n-                                case 6: bkpt6(); break;\n-                                case 7: bkpt7(); break;\n-                                case 8: bkpt8(); break;\n-                                case 9: bkpt9(); break;\n-                                case 10: bkpt10(); break;\n-                                case 11: bkpt11(); break;\n-                                case 12: bkpt12(); break;\n-                                case 13: bkpt13(); break;\n-                                case 14: bkpt14(); break;\n-                                case 15: bkpt15(); break;\n-                                case 16: bkpt16(); break;\n-                                case 17: bkpt17(); break;\n-                                case 18: bkpt18(); break;\n-                                case 19: bkpt19(); break;\n-                                case 20: bkpt20(); break;\n-                                case 21: bkpt21(); break;\n-                                case 22: bkpt22(); break;\n-                                case 23: bkpt23(); break;\n-                                case 24: bkpt24(); break;\n-                                case 25: bkpt25(); break;\n-                                case 26: bkpt26(); break;\n-                                case 27: bkpt27(); break;\n-                                case 28: bkpt28(); break;\n-                                case 29: bkpt29(); break;\n-                                }\n-                                System.out.println(\"Thread \" + threadName + \" You entered : \" + s);\n-\n-                                if( s.compareTo( \"quit\" ) == 0 )\n-                                    done = true;\n-                            }\n-                        } catch(Exception e) {\n-                            System.out.println(\"WOOPS\");\n-                        }\n+            try {\n+                \/\/ For each thread, run until numHits bkpts have been hit\n+                for( int i = 0; i < nhits; i++ ) {\n+                    \/\/ This is a tendril from the original jdb test.\n+                    \/\/ It could probably be deleted.\n+                    System.out.println(\"Thread \" + threadName + \" Enter a string: \");\n+                    String s = \"test\" + num;\n+                    switch (num) {\n+                    case 0: bkpt0(); break;\n+                    case 1: bkpt1(); break;\n+                    case 2: bkpt2(); break;\n+                    case 3: bkpt3(); break;\n+                    case 4: bkpt4(); break;\n+                    case 5: bkpt5(); break;\n+                    case 6: bkpt6(); break;\n+                    case 7: bkpt7(); break;\n+                    case 8: bkpt8(); break;\n+                    case 9: bkpt9(); break;\n+                    case 10: bkpt10(); break;\n+                    case 11: bkpt11(); break;\n+                    case 12: bkpt12(); break;\n+                    case 13: bkpt13(); break;\n+                    case 14: bkpt14(); break;\n+                    case 15: bkpt15(); break;\n+                    case 16: bkpt16(); break;\n+                    case 17: bkpt17(); break;\n+                    case 18: bkpt18(); break;\n+                    case 19: bkpt19(); break;\n+                    case 20: bkpt20(); break;\n+                    case 21: bkpt21(); break;\n+                    case 22: bkpt22(); break;\n+                    case 23: bkpt23(); break;\n+                    case 24: bkpt24(); break;\n+                    case 25: bkpt25(); break;\n+                    case 26: bkpt26(); break;\n+                    case 27: bkpt27(); break;\n+                    case 28: bkpt28(); break;\n+                    case 29: bkpt29(); break;\n@@ -197,0 +178,2 @@\n+                    System.out.println(\"Thread \" + threadName + \" You entered : \" + s);\n+\n@@ -198,1 +181,4 @@\n-            );\n+            } catch (Exception e) {\n+                System.out.println(\"WOOPS\");\n+            }\n+        });\n","filename":"test\/jdk\/com\/sun\/jdi\/MultiBreakpointsTest.java","additions":45,"deletions":59,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException\n@@ -55,3 +57,1 @@\n-            System.out.println(\"SCTP protocol is not supported\");\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new jtreg.SkippedException(\"SCTP protocol is not supported\");\n@@ -66,3 +66,1 @@\n-            System.out.println(\"Cannot locate lsof in \" + lsofDirs);\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new jtreg.SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/CloseDescriptors.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-            (new InputStreamReader(System.in)).readLine();\n+            (new InputStreamReader(System.in, System.getProperty(\"stdin.encoding\"))).readLine();\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/ClientCallbackHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-            (new InputStreamReader(System.in)).readLine();\n+            (new InputStreamReader(System.in, System.getProperty(\"stdin.encoding\"))).readLine();\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/digest\/ClientCallbackHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-        frame.setLocation(500,500);\n+        frame.setLocationRelativeTo(null);\n","filename":"test\/jdk\/java\/awt\/MenuItem\/SetLabelTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @bug 6191897\n+ * @bug 6191897 8354646\n","filename":"test\/jdk\/java\/awt\/TextField\/SetEchoCharWordOpsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n@@ -82,2 +83,2 @@\n-                    handler -> handler.propagateHandlerFromFuture(channel.write(bb)),\n-                    handler -> handler.propagateHandlerFromFuture(channel.read(bb)),\n+                    handler -> channel.write(bb),\n+                    handler -> channel.read(bb),\n@@ -94,4 +95,1 @@\n-                ioOp.accept(handler);\n-                handler.await()\n-                        .assertFailedWith(ISE)\n-                        .assertExceptionMessage(\"Confined session not supported\");\n+                expectThrows(IAE, () -> ioOp.accept(handler));\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-   @library \/test\/lib\n+   @requires (os.family == \"windows\")\n@@ -33,2 +33,0 @@\n-import jtreg.SkippedException;\n-\n@@ -37,5 +35,0 @@\n-        String osName = System.getProperty(\"os.name\");\n-        if (!osName.startsWith(\"Windows\")) {\n-            throw new SkippedException(\"This test is run only on Windows\");\n-        }\n-\n","filename":"test\/jdk\/java\/io\/File\/MaxPath.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,16 +284,1 @@\n-        \/\/ on Windows we test with the DOS hidden attribute set\n-        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            DosFileAttributeView view = Files\n-                .getFileAttributeView(file.toPath(), DosFileAttributeView.class);\n-            view.setHidden(true);\n-            try {\n-                assertTrue(file.isHidden());\n-                assertTrue(link2file.isHidden());\n-                assertTrue(link2link2file.isHidden());\n-            } finally {\n-                view.setHidden(false);\n-            }\n-            assertFalse(file.isHidden());\n-            assertFalse(link2file.isHidden());\n-            assertFalse(link2link2file.isHidden());\n-        }\n+        testDOSHiddenAttributes();\n@@ -365,0 +350,20 @@\n+     static void testDOSHiddenAttributes() throws IOException {\n+        \/\/ on Windows we test with the DOS hidden attribute set\n+        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            header(\"testDOSHiddenAttributes\");\n+            DosFileAttributeView view = Files\n+                .getFileAttributeView(file.toPath(), DosFileAttributeView.class);\n+            view.setHidden(true);\n+            try {\n+                assertTrue(file.isHidden());\n+                assertTrue(link2file.isHidden());\n+                assertTrue(link2link2file.isHidden());\n+            } finally {\n+                view.setHidden(false);\n+            }\n+            assertFalse(file.isHidden());\n+            assertFalse(link2file.isHidden());\n+            assertFalse(link2link2file.isHidden());\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/io\/File\/SymLinks.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-                int n = new InputStreamReader(System.in).read(buf,0,buf.length);\n+                int n = new InputStreamReader(System.in, System.getProperty(\"stdin.encoding\")).read(buf,0,buf.length);\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test id=posix_spawn\n+ * @summary Check that we don't leak FDs\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=posix_spawn -agentlib:FDLeaker FDLeakTest\n+ *\/\n+\n+\/**\n+ * @test id=fork\n+ * @summary Check that we don't leak FDs\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=fork -agentlib:FDLeaker FDLeakTest\n+ *\/\n+\n+\/**\n+ * @test id=vfork\n+ * @summary Check that we don't leak FDs\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=vfork -agentlib:FDLeaker FDLeakTest\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+public class FDLeakTest {\n+    \/\/ This test has two native parts:\n+    \/\/ - a library invoked with -agentlib that ensures that, in the parent JVM, we open\n+    \/\/   a native fd without setting FD_CLOEXEC (libFDLeaker.c). This is necessary because\n+    \/\/   there is no way to do this from Java: if Java functions correctly, all files the\n+    \/\/   user could open via its APIs should be marked with FD_CLOEXEC.\n+    \/\/ - a small native executable that tests - without using \/proc - whether any file\n+    \/\/   descriptors other than stdin\/out\/err are open.\n+    \/\/\n+    \/\/ What should happen: In the child process, between the initial fork and the exec of\n+    \/\/ the target binary, we should close all filedescriptors that are not stdin\/out\/err.\n+    \/\/ If that works, the child process should not see any other file descriptors save\n+    \/\/ those three.\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"FDLeakTester\");\n+        pb.inheritIO();\n+        Process p = pb.start();\n+        p.waitFor();\n+        if (p.exitValue() != 0) {\n+            throw new RuntimeException(\"Failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/FDLeakTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+\/* Check if any fd past stderr is valid; if true, print warning on stderr and return -1\n+ *\n+ * Note: check without accessing \/proc since:\n+ * - non-portable\n+ * - may cause creation of temporary file descriptors\n+ *\/\n+int main(int argc, char** argv) {\n+    int errors = 0;\n+    int rc = 0;\n+    char buf[128];\n+    int max_fd = (int)sysconf(_SC_OPEN_MAX);\n+    if (max_fd == -1) {\n+        snprintf(buf, sizeof(buf), \"*** sysconf(_SC_OPEN_MAX) failed? (%d) ***\\n\", errno);\n+        rc = write(2, buf, strlen(buf));\n+        max_fd = 10000;\n+    }\n+    \/\/ We start after stderr fd\n+    for (int fd = 3; fd < max_fd; fd++) {\n+        if (fcntl(fd, F_GETFD, 0) >= 0) {\n+            \/\/ Error: found valid file descriptor\n+            errors++;\n+            snprintf(buf, sizeof(buf), \"*** Parent leaked file descriptor %d ***\\n\", fd);\n+            rc = write(2, buf, strlen(buf));\n+        }\n+    }\n+    return errors > 0 ? -1 : 0;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/exeFDLeakTester.c","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jvmti.h\"\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  const char* filename = \".\/testfile_FDLeaker.txt\";\n+  FILE* f = fopen(filename, \"w\");\n+  if (f == NULL) {\n+    return JNI_ERR;\n+  }\n+  printf(\"Opened and leaked %s (%d)\", filename, fileno(f));\n+  return JNI_OK;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/libFDLeaker.c","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,38 +111,0 @@\n-\n-        if (sock instanceof MulticastSocket) {\n-            sock.disconnect();\n-            testTTL((MulticastSocket)sock);\n-        }\n-    }\n-\n-    private void testTTL(MulticastSocket sock) throws Exception {\n-        out.println(\"Testing deprecated send TTL with \" + sock.getClass());\n-        final byte ttl = 100;\n-        InetAddress addr = loopbackAddress;\n-        byte[] buf;\n-        DatagramPacket p;\n-        int port = serversock.getLocalPort();\n-\n-        out.println(\"Checking send to non-connected address ...\");\n-        try {\n-            out.println(\"Checking send with no packet address\");\n-            buf = (\"Hello, server\"+(++i)).getBytes();\n-            p = new DatagramPacket(buf, buf.length);\n-            sock.send(p,ttl);\n-            throw new AssertionError(\"Expected IllegalArgumentException not received\");\n-        } catch (IllegalArgumentException x) {\n-            out.println(\"Got expected exception: \" + x);\n-        }\n-\n-        out.println(\"Connecting to connected address: \" + sock);\n-        sock.connect(addr, port);\n-\n-        try {\n-            out.println(\"Checking send with different address than connected\");\n-            buf = (\"Hello, server\"+(++i)).getBytes();\n-            p = new DatagramPacket(buf, buf.length, addr, port+1);\n-            sock.send(p, ttl);\n-            throw new AssertionError(\"Expected IllegalArgumentException not received\");\n-        } catch (IllegalArgumentException x) {\n-            out.println(\"Got expected exception: \" + x);\n-        }\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/AddressNotSet.java","additions":1,"deletions":39,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-     * Test getTimeToLive\/setTimeToLive\/getTTL\/getTTL and IP_MULTICAST_TTL socket\n+     * Test getTimeToLive\/setTimeToLive and IP_MULTICAST_TTL socket\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketMulticasting.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,8 +124,0 @@\n-        @Override\n-        protected void setTTL(byte ttl) throws IOException { }\n-\n-        @Override\n-        protected byte getTTL() throws IOException {\n-            return 0;\n-        }\n-\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/OldDatagramSocketImplTest.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n- *          throw expected Execption when passed a DatagramPacket\n+ *          throw expected Exception when passed a DatagramPacket\n@@ -129,1 +129,1 @@\n-                Sender.of(new MulticastSocket(null), (byte) 0),\n+                Sender.of(new MulticastSocket(null)),\n@@ -131,3 +131,1 @@\n-                Sender.of(DatagramChannel.open().socket()),\n-                Sender.of((MulticastSocket)\n-                        DatagramChannel.open().socket(), (byte) 0)\n+                Sender.of(DatagramChannel.open().socket())\n@@ -182,6 +180,0 @@\n-        static Sender<IOException> of(MulticastSocket socket, byte ttl) {\n-            SenderImpl.Send<IOException> send =\n-                    (pkt) -> socket.send(pkt, ttl);\n-            return new SenderImpl<>(socket, send, socket::close, SE);\n-        }\n-\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendCheck.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,9 +66,0 @@\n-        @Override\n-        protected void setTTL(byte ttl) throws IOException {\n-        }\n-\n-        @Override\n-        protected byte getTTL() throws IOException {\n-            return 0;\n-        }\n-\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetDatagramSocketImplFactory\/java.base\/java\/net\/MyDatagramSocketImplFactory.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,2 +108,0 @@\n-        @Override protected void setTTL(byte ttl) { }\n-        @Override protected byte getTTL() { return 0; }\n","filename":"test\/jdk\/java\/net\/DatagramSocketImpl\/TestCreate.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,2 +102,0 @@\n-        @Override protected void setTTL(byte ttl) { }\n-        @Override protected byte getTTL() { return 0; }\n","filename":"test\/jdk\/java\/net\/DatagramSocketImpl\/TestDefaultBehavior.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.List;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8359709\n+ * @summary verify that if the Host header is allowed to be set by the application\n+ *          then the correct value gets set in a HTTP request issued through\n+ *          java.net.HttpURLConnection\n+ * @library \/test\/lib\n+ * @run junit HostHeaderTest\n+ * @run junit\/othervm -Dsun.net.http.allowRestrictedHeaders=true HostHeaderTest\n+ * @run junit\/othervm -Dsun.net.http.allowRestrictedHeaders=false HostHeaderTest\n+ *\/\n+class HostHeaderTest {\n+\n+    private static final String SERVER_CTX_ROOT = \"\/8359709\/\";\n+    private static final boolean allowsHostHeader = Boolean.getBoolean(\"sun.net.http.allowRestrictedHeaders\");\n+\n+    private static HttpServer server;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        final InetSocketAddress addr = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        server = HttpServer.create(addr, 0);\n+        server.createContext(SERVER_CTX_ROOT, new Handler());\n+        server.start();\n+        System.err.println(\"started server at \" + server.getAddress());\n+    }\n+\n+    @AfterAll\n+    static void afterAll() throws Exception {\n+        if (server != null) {\n+            System.err.println(\"stopping server \" + server.getAddress());\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    void testHostHeader() throws Exception {\n+        final InetSocketAddress serverAddr = server.getAddress();\n+        final URL reqURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(serverAddr.getPort())\n+                .path(SERVER_CTX_ROOT)\n+                .build().toURL();\n+        final URLConnection conn = reqURL.openConnection(Proxy.NO_PROXY);\n+\n+        conn.setRequestProperty(\"Host\", \"foobar\");\n+        if (!allowsHostHeader) {\n+            \/\/ if restricted headers aren't allowed to be set by the user, then\n+            \/\/ we expect the previous call to setRequestProperty to not set the Host\n+            \/\/ header\n+            assertNull(conn.getRequestProperty(\"Host\"), \"Host header unexpectedly set\");\n+        }\n+\n+        assertInstanceOf(HttpURLConnection.class, conn);\n+        final HttpURLConnection httpURLConn = (HttpURLConnection) conn;\n+\n+        \/\/ send the HTTP request\n+        System.err.println(\"sending request \" + reqURL);\n+        final int respCode = httpURLConn.getResponseCode();\n+        assertEquals(200, respCode, \"unexpected response code\");\n+        \/\/ verify that the server side handler received the expected\n+        \/\/ Host header value in the request\n+        try (final InputStream is = httpURLConn.getInputStream()) {\n+            final byte[] resp = is.readAllBytes();\n+            \/\/ if Host header wasn't explicitly set, then we expect it to be\n+            \/\/ derived from the request URL\n+            final String expected = allowsHostHeader\n+                    ? \"foobar\"\n+                    : reqURL.getHost() + \":\" + reqURL.getPort();\n+            final String actual = new String(resp, US_ASCII);\n+            assertEquals(expected, actual, \"unexpected Host header received on server side\");\n+        }\n+    }\n+\n+    private static final class Handler implements HttpHandler {\n+        private static final int NO_RESPONSE_BODY = -1;\n+\n+        @Override\n+        public void handle(final HttpExchange exchange) throws IOException {\n+            final List<String> headerVals = exchange.getRequestHeaders().get(\"Host\");\n+            System.err.println(\"Host header has value(s): \" + headerVals);\n+            \/\/ unexpected Host header value, respond with 400 status code\n+            if (headerVals == null || headerVals.size() != 1) {\n+                System.err.println(\"Unexpected header value(s) for Host header: \" + headerVals);\n+                exchange.sendResponseHeaders(400, NO_RESPONSE_BODY);\n+                return;\n+            }\n+            \/\/ respond back with the Host header value that we found in the request\n+            final byte[] response = headerVals.getFirst().getBytes(US_ASCII);\n+            exchange.sendResponseHeaders(200, response.length);\n+            try (final OutputStream os = exchange.getResponseBody()) {\n+                os.write(response);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/HostHeaderTest.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4089415\n- * @summary Test MulticastSocket send for modification of ttl\n- *\n- *\/\n-import java.io.*;\n-import java.net.*;\n-\n-public class MulticastTTL {\n-\n-    public static void main(String args[]) throws Exception {\n-        MulticastSocket soc = null;\n-        DatagramPacket pac = null;\n-        InetAddress sin = null;\n-        byte [] array = new byte[65537];\n-        int port = 0;\n-        byte old_ttl = 0;\n-        byte new_ttl = 64;\n-        byte ttl = 0;\n-\n-        sin = InetAddress.getByName(\"224.80.80.80\");\n-        soc = new MulticastSocket();\n-        port = soc.getLocalPort();\n-        old_ttl = soc.getTTL();\n-        pac = new DatagramPacket(array, array.length, sin, port);\n-\n-        try {\n-            soc.send(pac, new_ttl);\n-        } catch(java.io.IOException e) {\n-            ttl = soc.getTTL();\n-            soc.close();\n-            if(ttl != old_ttl)\n-                throw new RuntimeException(\"TTL \");\n-        }\n-        soc.close();\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/MulticastTTL.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,0 @@\n-        assertThrows(SE, () -> ms.send(pkt, (byte) 0));\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SendPortZero.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,10 +209,0 @@\n-        @Override\n-        protected void setTTL(byte ttl) throws IOException {\n-            shouldNotComeHere();\n-        }\n-\n-        @Override\n-        protected byte getTTL() throws IOException {\n-            return shouldNotComeHere();\n-        }\n-\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackOption.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4189640\n- * @summary Make setTTL\/getTTL works\n- * @run main SetTTLAndGetTTL\n- *\/\n-\n-import java.net.*;\n-\n-public class SetTTLAndGetTTL {\n-\n-    public static void main(String args[]) throws Exception {\n-        MulticastSocket soc = null;\n-\n-        try {\n-            soc = new MulticastSocket();\n-        } catch(Exception e) {\n-            throw new Exception(\"Unexpected Exception\");\n-        }\n-\n-        soc.setTTL((byte)200);\n-        byte ttlValue = soc.getTTL();\n-        if (ttlValue != (byte)200)\n-            throw new Exception(\"setTTL\/getTTL is broken\");\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetTTLAndGetTTL.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-        soc.setTTL((byte)0);\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetTTLTo0.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,2 +127,0 @@\n-        @Override protected void setTTL(byte ttl) { }\n-        @Override protected byte getTTL() { return 0; }\n","filename":"test\/jdk\/java\/net\/SocketOption\/CachedImplOptions.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,4 +165,0 @@\n-        protected void setTTL(byte ttl) throws IOException { }\n-\n-        protected byte getTTL() throws IOException { return 0; }\n-\n","filename":"test\/jdk\/java\/net\/SocketOption\/ImmutableOptions.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,4 @@\n+import java.net.Proxy;\n+import java.net.ProxySelector;\n+import java.net.SocketAddress;\n+import java.net.URI;\n@@ -60,0 +64,13 @@\n+        if (!EARLY_PARSING) {\n+            \/\/ we will open the connection in that case.\n+            \/\/ make sure no proxy is selected\n+            ProxySelector.setDefault(new ProxySelector() {\n+                @Override\n+                public List<Proxy> select(URI uri) {\n+                    return List.of(Proxy.NO_PROXY);\n+                }\n+                @Override\n+                public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {\n+                }\n+            });\n+        }\n","filename":"test\/jdk\/java\/net\/URL\/EarlyOrDelayedParsing.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,255 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8235459\n- * @summary Confirm that HttpRequest.BodyPublishers#ofFile(Path)\n- *          works as expected\n- * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n- * @build jdk.httpclient.test.lib.common.HttpServerAdapters jdk.test.lib.net.SimpleSSLContext\n- *        SecureZipFSProvider\n- * @run testng\/othervm FilePublisherPermsTest\n- *\/\n-\n-import jdk.test.lib.net.SimpleSSLContext;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import javax.net.ssl.SSLContext;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpRequest.BodyPublisher;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.net.http.HttpResponse;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.security.*;\n-import java.util.Map;\n-import jdk.httpclient.test.lib.common.HttpServerAdapters;\n-\n-import static java.lang.System.out;\n-import static java.net.http.HttpClient.Builder.NO_PROXY;\n-import static java.net.http.HttpClient.Version.HTTP_1_1;\n-import static java.net.http.HttpClient.Version.HTTP_2;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n-\n-public class FilePublisherPermsTest implements HttpServerAdapters {\n-\n-    SSLContext sslContext;\n-    HttpServerAdapters.HttpTestServer httpTestServer;    \/\/ HTTP\/1.1      [ 4 servers ]\n-    HttpServerAdapters.HttpTestServer httpsTestServer;   \/\/ HTTPS\/1.1\n-    HttpServerAdapters.HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n-    HttpServerAdapters.HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n-    String httpURI;\n-    String httpsURI;\n-    String http2URI;\n-    String https2URI;\n-\n-    FileSystem zipFs;\n-    static Path zipFsPath;\n-    static Path defaultFsPath;\n-\n-    String policyFile;\n-\n-    \/\/ Default file system set up\n-    static final String DEFAULT_FS_MSG = \"default fs\";\n-\n-    private Path defaultFsFile() throws Exception {\n-        var file = Path.of(\"defaultFile.txt\");\n-        if (Files.notExists(file)) {\n-            Files.createFile(file);\n-            Files.writeString(file, DEFAULT_FS_MSG);\n-        }\n-        assertEquals(Files.readString(file), DEFAULT_FS_MSG);\n-        return file;\n-    }\n-\n-    @DataProvider(name = \"defaultFsData\")\n-    public Object[][] defaultFsData() {\n-        return new Object[][]{\n-                { httpURI,   defaultFsPath },\n-                { httpsURI,  defaultFsPath },\n-                { http2URI,  defaultFsPath },\n-                { https2URI, defaultFsPath },\n-                { httpURI,   defaultFsPath },\n-                { httpsURI,  defaultFsPath },\n-                { http2URI,  defaultFsPath },\n-                { https2URI, defaultFsPath },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"defaultFsData\")\n-    public void testDefaultFs(String uriString, Path path)\n-            throws Exception {\n-        out.printf(\"\\n\\n--- testDefaultFs(%s, %s): starting\\n\",\n-                uriString, path);\n-        BodyPublisher bodyPublisher = BodyPublishers.ofFile(path);\n-        send(uriString, bodyPublisher);\n-    }\n-\n-    \/\/ Zip File system set up\n-    static final String ZIP_FS_MSG = \"zip fs\";\n-\n-    static FileSystem newZipFs(Path zipFile) throws Exception {\n-        return FileSystems.newFileSystem(zipFile, Map.of(\"create\", \"true\"));\n-    }\n-\n-    static FileSystem newSecureZipFs(Path zipFile) throws Exception {\n-        FileSystem fs = newZipFs(zipFile);\n-        return new SecureZipFSProvider(fs.provider()).newFileSystem(fs);\n-    }\n-\n-    static Path zipFsFile(FileSystem fs) throws Exception {\n-        var file = fs.getPath(\"fileInZip.txt\");\n-        if (Files.notExists(file)) {\n-            Files.createFile(file);\n-            Files.writeString(file, ZIP_FS_MSG);\n-        }\n-        assertEquals(Files.readString(file), ZIP_FS_MSG);\n-        return file;\n-    }\n-\n-    @DataProvider(name = \"zipFsData\")\n-    public Object[][] zipFsData() {\n-        return new Object[][]{\n-                { httpURI,   zipFsPath },\n-                { httpsURI,  zipFsPath },\n-                { http2URI,  zipFsPath },\n-                { https2URI, zipFsPath },\n-                { httpURI,   zipFsPath },\n-                { httpsURI,  zipFsPath },\n-                { http2URI,  zipFsPath },\n-                { https2URI, zipFsPath },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"zipFsData\")\n-    public void testZipFs(String uriString, Path path) throws Exception {\n-        out.printf(\"\\n\\n--- testZipFsCustomPerm(%s, %s): starting\\n\", uriString, path);\n-        BodyPublisher bodyPublisher = BodyPublishers.ofFile(path);\n-        send(uriString, bodyPublisher);\n-    }\n-\n-    @Test\n-    public void testFileNotFound() throws Exception {\n-        out.printf(\"\\n\\n--- testFileNotFound(): starting\\n\");\n-        var zipPath = Path.of(\"fileNotFound.zip\");\n-        try (FileSystem fs = newZipFs(zipPath)) {\n-            Path fileInZip = zipFsFile(fs);\n-            Files.deleteIfExists(fileInZip);\n-            BodyPublishers.ofFile(fileInZip);\n-            fail();\n-        } catch (FileNotFoundException e) {\n-            out.println(\"Caught expected: \" + e);\n-        }\n-        var path = Path.of(\"fileNotFound.txt\");\n-        try {\n-            Files.deleteIfExists(path);\n-            BodyPublishers.ofFile(path);\n-            fail();\n-        } catch (FileNotFoundException e) {\n-            out.println(\"Caught expected: \" + e);\n-        }\n-    }\n-\n-    private void send(String uriString, BodyPublisher bodyPublisher)\n-        throws Exception {\n-        HttpClient client = HttpClient.newBuilder()\n-                        .proxy(NO_PROXY)\n-                        .sslContext(sslContext)\n-                        .build();\n-        var req = HttpRequest.newBuilder(URI.create(uriString))\n-                .POST(bodyPublisher)\n-                .build();\n-        client.send(req, HttpResponse.BodyHandlers.discarding());\n-    }\n-\n-\n-    static class HttpEchoHandler implements HttpServerAdapters.HttpTestHandler {\n-        @Override\n-        public void handle(HttpServerAdapters.HttpTestExchange t) throws IOException {\n-            try (InputStream is = t.getRequestBody();\n-                 OutputStream os = t.getResponseBody()) {\n-                byte[] bytes = is.readAllBytes();\n-                t.sendResponseHeaders(200, bytes.length);\n-                os.write(bytes);\n-            }\n-        }\n-    }\n-\n-    @BeforeTest\n-    public void setup() throws Exception {\n-        sslContext = new SimpleSSLContext().get();\n-        if (sslContext == null)\n-            throw new AssertionError(\"Unexpected null sslContext\");\n-\n-        zipFs = newSecureZipFs(Path.of(\"file.zip\"));\n-        zipFsPath = zipFsFile(zipFs);\n-        defaultFsPath = defaultFsFile();\n-\n-        httpTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n-        httpTestServer.addHandler(\n-                new FilePublisherPermsTest.HttpEchoHandler(), \"\/http1\/echo\");\n-        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/echo\";\n-\n-        httpsTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n-        httpsTestServer.addHandler(\n-                new FilePublisherPermsTest.HttpEchoHandler(), \"\/https1\/echo\");\n-        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/echo\";\n-\n-        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n-        http2TestServer.addHandler(\n-                new FilePublisherPermsTest.HttpEchoHandler(), \"\/http2\/echo\");\n-        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/echo\";\n-\n-        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n-        https2TestServer.addHandler(\n-                new FilePublisherPermsTest.HttpEchoHandler(), \"\/https2\/echo\");\n-        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/echo\";\n-\n-        httpTestServer.start();\n-        httpsTestServer.start();\n-        http2TestServer.start();\n-        https2TestServer.start();\n-    }\n-\n-    @AfterTest\n-    public void teardown() throws Exception {\n-            httpTestServer.stop();\n-            httpsTestServer.stop();\n-            http2TestServer.stop();\n-            https2TestServer.stop();\n-            zipFs.close();\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisher\/FilePublisherPermsTest.java","additions":0,"deletions":255,"binary":false,"changes":255,"status":"deleted"},{"patch":"@@ -1,446 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.net.URI;\n-import java.nio.channels.FileChannel;\n-import java.nio.channels.SeekableByteChannel;\n-import java.nio.file.AccessMode;\n-import java.nio.file.CopyOption;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.FileStore;\n-import java.nio.file.FileSystem;\n-import java.nio.file.LinkOption;\n-import java.nio.file.OpenOption;\n-import java.nio.file.Path;\n-import java.nio.file.PathMatcher;\n-import java.nio.file.ProviderMismatchException;\n-import java.nio.file.WatchEvent;\n-import java.nio.file.WatchKey;\n-import java.nio.file.WatchService;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileAttribute;\n-import java.nio.file.attribute.FileAttributeView;\n-import java.nio.file.attribute.UserPrincipalLookupService;\n-import java.nio.file.spi.FileSystemProvider;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-public class SecureZipFSProvider extends FileSystemProvider {\n-    private final ConcurrentHashMap<FileSystem, SecureZipFS> map =\n-            new ConcurrentHashMap<>();\n-    private final FileSystemProvider defaultProvider;\n-\n-    public SecureZipFSProvider(FileSystemProvider provider) {\n-        defaultProvider = provider;\n-    }\n-\n-    @Override\n-    public String getScheme() {\n-        return \"jar\";\n-    }\n-\n-    public FileSystem newFileSystem(FileSystem fs) {\n-        return map.computeIfAbsent(fs, (sfs) ->\n-                new SecureZipFS(this, fs));\n-    }\n-\n-    @Override\n-    public FileSystem newFileSystem(URI uri, Map<String, ?> env)\n-            throws IOException {\n-        FileSystem fs = defaultProvider.newFileSystem(uri, env);\n-        return map.computeIfAbsent(fs, (sfs) ->\n-                new SecureZipFS(this, fs)\n-        );\n-    }\n-\n-    @Override\n-    public FileSystem getFileSystem(URI uri) {\n-        return map.get(defaultProvider.getFileSystem(uri));\n-    }\n-\n-    @Override\n-    public Path getPath(URI uri) {\n-        Path p = defaultProvider.getPath(uri);\n-        return map.get(defaultProvider.getFileSystem(uri)).wrap(p);\n-    }\n-\n-    @Override\n-    public InputStream newInputStream(Path path, OpenOption... options)\n-            throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.newInputStream(p, options);\n-    }\n-\n-    @Override\n-    public SeekableByteChannel newByteChannel(Path path,\n-                                              Set<? extends OpenOption> options,\n-                                              FileAttribute<?>... attrs)\n-            throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.newByteChannel(p, options, attrs);\n-    }\n-\n-    @Override\n-    public FileChannel newFileChannel(Path path,\n-                                      Set<? extends OpenOption> options,\n-                                      FileAttribute<?>... attrs)\n-            throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.newFileChannel(p, options, attrs);\n-    }\n-\n-\n-    @Override\n-    public DirectoryStream<Path> newDirectoryStream(Path dir,\n-                                                    DirectoryStream.Filter<? super Path> filter) {\n-        throw new RuntimeException(\"not implemented\");\n-    }\n-\n-    @Override\n-    public void createDirectory(Path dir, FileAttribute<?>... attrs)\n-            throws IOException {\n-        Path p = toTestPath(dir).unwrap();\n-        defaultProvider.createDirectory(p, attrs);\n-    }\n-\n-    @Override\n-    public void delete(Path path) throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        defaultProvider.delete(p);\n-    }\n-\n-    @Override\n-    public void copy(Path source, Path target, CopyOption... options)\n-            throws IOException {\n-        Path sp = toTestPath(source).unwrap();\n-        Path tp = toTestPath(target).unwrap();\n-        defaultProvider.copy(sp, tp, options);\n-    }\n-\n-    @Override\n-    public void move(Path source, Path target, CopyOption... options)\n-            throws IOException {\n-        Path sp = toTestPath(source).unwrap();\n-        Path tp = toTestPath(target).unwrap();\n-        defaultProvider.move(sp, tp, options);\n-    }\n-\n-    @Override\n-    public boolean isSameFile(Path path, Path path2)\n-            throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        Path p2 = toTestPath(path2).unwrap();\n-        return defaultProvider.isSameFile(p, p2);\n-    }\n-\n-    @Override\n-    public boolean isHidden(Path path) throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.isHidden(p);\n-    }\n-\n-    @Override\n-    public FileStore getFileStore(Path path) throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.getFileStore(p);\n-    }\n-\n-    @Override\n-    public void checkAccess(Path path, AccessMode... modes) throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        defaultProvider.checkAccess(p, modes);\n-    }\n-\n-    @Override\n-    public <V extends FileAttributeView> V getFileAttributeView(Path path,\n-                                                                Class<V> type,\n-                                                                LinkOption... options) {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.getFileAttributeView(p, type, options);\n-    }\n-\n-    @Override\n-    public <A extends BasicFileAttributes> A readAttributes(Path path,\n-                                                            Class<A> type,\n-                                                            LinkOption... options)\n-            throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.readAttributes(p, type, options);\n-    }\n-\n-    @Override\n-    public Map<String, Object> readAttributes(Path path,\n-                                              String attributes,\n-                                              LinkOption... options)\n-            throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        return defaultProvider.readAttributes(p, attributes, options);\n-    }\n-\n-    @Override\n-    public void setAttribute(Path path, String attribute,\n-                             Object value, LinkOption... options)\n-            throws IOException {\n-        Path p = toTestPath(path).unwrap();\n-        defaultProvider.setAttribute(p, attribute, options);\n-    }\n-\n-    \/\/ Checks that the given file is a TestPath\n-    static TestPath toTestPath(Path obj) {\n-        if (obj == null)\n-            throw new NullPointerException();\n-        if (!(obj instanceof TestPath))\n-            throw new ProviderMismatchException();\n-        return (TestPath) obj;\n-    }\n-\n-    static class SecureZipFS extends FileSystem {\n-        private final SecureZipFSProvider provider;\n-        private final FileSystem delegate;\n-\n-        public SecureZipFS(SecureZipFSProvider provider, FileSystem delegate) {\n-            this.provider = provider;\n-            this.delegate = delegate;\n-        }\n-\n-        Path wrap(Path path) {\n-            return (path != null) ? new TestPath(this, path) : null;\n-        }\n-\n-        Path unwrap(Path wrapper) {\n-            if (wrapper == null)\n-                throw new NullPointerException();\n-            if (!(wrapper instanceof TestPath))\n-                throw new ProviderMismatchException();\n-            return ((TestPath) wrapper).unwrap();\n-        }\n-\n-        @Override\n-        public FileSystemProvider provider() {\n-            return provider;\n-        }\n-\n-        @Override\n-        public void close() throws IOException {\n-            delegate.close();\n-        }\n-\n-        @Override\n-        public boolean isOpen() {\n-            return delegate.isOpen();\n-        }\n-\n-        @Override\n-        public boolean isReadOnly() {\n-            return delegate.isReadOnly();\n-        }\n-\n-        @Override\n-        public String getSeparator() {\n-            return delegate.getSeparator();\n-        }\n-\n-        @Override\n-        public Iterable<Path> getRootDirectories() {\n-            return delegate.getRootDirectories();\n-        }\n-\n-        @Override\n-        public Iterable<FileStore> getFileStores() {\n-            return delegate.getFileStores();\n-        }\n-\n-        @Override\n-        public Set<String> supportedFileAttributeViews() {\n-            return delegate.supportedFileAttributeViews();\n-        }\n-\n-        @Override\n-        public Path getPath(String first, String... more) {\n-            return wrap(delegate.getPath(first, more));\n-        }\n-\n-        @Override\n-        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n-            return delegate.getPathMatcher(syntaxAndPattern);\n-        }\n-\n-        @Override\n-        public UserPrincipalLookupService getUserPrincipalLookupService() {\n-            return delegate.getUserPrincipalLookupService();\n-        }\n-\n-        @Override\n-        public WatchService newWatchService() throws IOException {\n-            return delegate.newWatchService();\n-        }\n-    }\n-\n-    static class TestPath implements Path {\n-        private final SecureZipFS fs;\n-        private final Path delegate;\n-\n-        TestPath(SecureZipFS fs, Path delegate) {\n-            this.fs = fs;\n-            this.delegate = delegate;\n-        }\n-\n-        Path unwrap() {\n-            return delegate;\n-        }\n-\n-        @Override\n-        public SecureZipFS getFileSystem() {\n-            return fs;\n-        }\n-\n-        @Override\n-        public boolean isAbsolute() {\n-            return delegate.isAbsolute();\n-        }\n-\n-        @Override\n-        public Path getRoot() {\n-            return fs.wrap(delegate.getRoot());\n-        }\n-\n-        @Override\n-        public Path getFileName() {\n-            return fs.wrap(delegate.getFileName());\n-        }\n-\n-        @Override\n-        public Path getParent() {\n-            return fs.wrap(delegate.getParent());\n-        }\n-\n-        @Override\n-        public int getNameCount() {\n-            return delegate.getNameCount();\n-        }\n-\n-        @Override\n-        public Path getName(int index) {\n-            return fs.wrap(delegate.getName(index));\n-        }\n-\n-        @Override\n-        public Path subpath(int beginIndex, int endIndex) {\n-            return fs.wrap(delegate.subpath(beginIndex, endIndex));\n-        }\n-\n-        @Override\n-        public boolean startsWith(Path other) {\n-            return delegate.startsWith(other);\n-        }\n-\n-        @Override\n-        public boolean endsWith(Path other) {\n-            return delegate.endsWith(other);\n-        }\n-\n-        @Override\n-        public Path normalize() {\n-            return fs.wrap(delegate.normalize());\n-        }\n-\n-        @Override\n-        public Path resolve(Path other) {\n-            return fs.wrap(delegate.resolve(fs.wrap(other)));\n-        }\n-\n-        @Override\n-        public Path relativize(Path other) {\n-            return fs.wrap(delegate.relativize(fs.wrap(other)));\n-        }\n-\n-        @Override\n-        public URI toUri() {\n-            String ssp = delegate.toUri().getSchemeSpecificPart();\n-            return URI.create(fs.provider().getScheme() + \":\" + ssp);\n-        }\n-\n-        @Override\n-        public Path toAbsolutePath() {\n-            return fs.wrap(delegate.toAbsolutePath());\n-        }\n-\n-        @Override\n-        public Path toRealPath(LinkOption... options) throws IOException {\n-            return fs.wrap(delegate.toRealPath(options));\n-        }\n-\n-        @Override\n-        public WatchKey register(WatchService watcher,\n-                                 WatchEvent.Kind<?>[] events,\n-                                 WatchEvent.Modifier... modifiers)\n-                throws IOException {\n-            return delegate.register(watcher, events, modifiers);\n-        }\n-\n-        @Override\n-        public Iterator<Path> iterator() {\n-            final Iterator<Path> itr = delegate.iterator();\n-            return new Iterator<>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return itr.hasNext();\n-                }\n-\n-                @Override\n-                public Path next() {\n-                    return fs.wrap(itr.next());\n-                }\n-\n-                @Override\n-                public void remove() {\n-                    itr.remove();\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public int compareTo(Path other) {\n-            return delegate.compareTo(fs.unwrap(other));\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return delegate.hashCode();\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            return other instanceof TestPath && delegate.equals(fs.unwrap((TestPath) other));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return delegate.toString();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisher\/SecureZipFSProvider.java","additions":0,"deletions":446,"binary":false,"changes":446,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,3 @@\n- * @bug 8235459\n- * @summary Confirm that HttpRequest.BodyPublishers#ofFile(Path)\n- *          assumes the default file system\n+ * @bug 8235459 8358688\n+ * @summary Verifies `HttpRequest.BodyPublishers#ofFile(Path)` against file\n+ *          systems that support `Path#toFile()` and also those that don't\n@@ -42,0 +42,1 @@\n+import java.io.FileNotFoundException;\n@@ -45,2 +46,0 @@\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n@@ -64,0 +63,1 @@\n+import static org.testng.Assert.fail;\n@@ -159,0 +159,20 @@\n+    @Test\n+    public void testFileNotFound() throws Exception {\n+        out.printf(\"\\n\\n--- testFileNotFound(): starting\\n\");\n+        try (FileSystem fs = newZipFs()) {\n+            Path fileInZip = fs.getPath(\"non-existent.txt\");\n+            BodyPublishers.ofFile(fileInZip);\n+            fail();\n+        } catch (FileNotFoundException e) {\n+            out.println(\"Caught expected: \" + e);\n+        }\n+        var path = Path.of(\"fileNotFound.txt\");\n+        try {\n+            Files.deleteIfExists(path);\n+            BodyPublishers.ofFile(path);\n+            fail();\n+        } catch (FileNotFoundException e) {\n+            out.println(\"Caught expected: \" + e);\n+        }\n+    }\n+\n@@ -196,3 +216,0 @@\n-        InetSocketAddress sa =\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisherTest.java","additions":26,"deletions":9,"binary":false,"changes":35,"previous_filename":"test\/jdk\/java\/net\/httpclient\/FilePublisher\/FilePublisherTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8340182\n+ * @summary Auth retry limit system property\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run junit HttpClientAuthRetryLimitTest\n+ * @run junit\/othervm -Djdk.httpclient.auth.retrylimit=1 HttpClientAuthRetryLimitTest\n+ * @run junit\/othervm -Djdk.httpclient.auth.retrylimit=0 HttpClientAuthRetryLimitTest\n+ * @run junit\/othervm -Djdk.httpclient.auth.retrylimit=-1 HttpClientAuthRetryLimitTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.net.Authenticator;\n+import java.net.PasswordAuthentication;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class HttpClientAuthRetryLimitTest implements HttpServerAdapters {\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    \/\/ This is the system default value for jdk.httpclient.auth.retrylimit\n+    private static final int DEFAULT_RETRY_LIMIT = 3;\n+    private static final int RETRY_LIMIT = Integer.getInteger(\n+            \"jdk.httpclient.auth.retrylimit\", DEFAULT_RETRY_LIMIT);\n+\n+    private static Stream<Object> args() {\n+        return Stream.of(\n+                HttpClient.Version.HTTP_1_1,\n+                HttpClient.Version.HTTP_2)\n+                .flatMap(version -> Stream\n+                        .of(false, true)\n+                        .map(secure -> Arguments.of(version, secure)));\n+    }\n+\n+    private static HttpClient.Builder createClient(boolean secure) {\n+        HttpClient.Builder builder = HttpClient.newBuilder();\n+        if (secure) {\n+            builder.sslContext(SSL_CONTEXT);\n+        }\n+        return builder;\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"args\")\n+    void testDefaultSystemProperty(HttpClient.Version version, boolean secure) throws Exception {\n+\n+        AtomicInteger requestCount = new AtomicInteger(0);\n+\n+        try (HttpTestServer httpTestServer = ((secure)? HttpTestServer.create(\n+                version, SSL_CONTEXT): HttpTestServer.create(version))) {\n+            final String requestUriScheme = secure ? \"https\" : \"http\";\n+            final String requestPath = \"\/\" + this.getClass().getSimpleName() + \"\/\";\n+            final String uriString = \":\/\/\" + httpTestServer.serverAuthority() + requestPath;\n+            final URI requestUri = URI.create(requestUriScheme + uriString);\n+\n+            HttpTestHandler httpTestHandler = t -> {\n+                t.getResponseHeaders()\n+                        .addHeader(\"WWW-Authenticate\", \"Basic realm=\\\"Test\\\"\");\n+                t.sendResponseHeaders(401,0);\n+            };\n+\n+            httpTestServer.addHandler(httpTestHandler, requestPath);\n+            httpTestServer.start();\n+            try (\n+                HttpClient client = createClient(secure)\n+                        .authenticator(new Authenticator() {\n+                            @Override\n+                            protected PasswordAuthentication getPasswordAuthentication() {\n+                                requestCount.incrementAndGet();\n+                                return new PasswordAuthentication(\"username\", \"password\".toCharArray());\n+                            }\n+                        })\n+                        .build()) {\n+                HttpRequest request = HttpRequest.newBuilder().version(version)\n+                        .GET()\n+                        .uri(requestUri)\n+                        .build();\n+                IOException exception = assertThrows(IOException.class, () -> client.send(\n+                        request, HttpResponse.BodyHandlers.discarding()));\n+                assertEquals(\"too many authentication attempts. Limit: \" + RETRY_LIMIT, exception.getMessage());\n+                int totalRequestCount = requestCount.get();\n+                assertEquals(totalRequestCount, Math.max(RETRY_LIMIT, 0) + 1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientAuthRetryLimitTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @bug 8226303\n+ * @bug 8226303 8358688\n","filename":"test\/jdk\/java\/net\/httpclient\/RelayingPublishers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n- * @bug 4490253 6535542\n+ * @bug 4490253 6535542 8357959\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -28,0 +31,1 @@\n+ * @run main\/othervm AllocateDirectInit\n@@ -31,0 +35,3 @@\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n@@ -33,0 +40,6 @@\n+    private static final int MAX_BIN_LIMIT = 16 * 1024 * 1024;\n+    private static final int MAX_DEC_LIMIT = 10 * 1000 * 1000;\n+    private static final int TRIES_PER_LIMIT = 1024;\n+\n+    private static final Random RND = RandomFactory.getRandom();\n+\n@@ -34,7 +47,18 @@\n-        for (int i = 0; i < 1024; i++) {\n-            ByteBuffer bb = ByteBuffer.allocateDirect(1024);\n-\/\/          printByteBuffer(bb);\n-            for (bb.position(0); bb.position() < bb.limit(); ) {\n-                if ((bb.get() & 0xff) != 0)\n-                    throw new RuntimeException(\"uninitialized buffer, position = \"\n-                                               + bb.position());\n+        \/\/ Try power of two limits\n+        for (int limit = 1; limit < MAX_BIN_LIMIT; limit *= 2) {\n+            check(ByteBuffer.allocateDirect(limit - 1));\n+            check(ByteBuffer.allocateDirect(limit));\n+            check(ByteBuffer.allocateDirect(limit + 1));\n+        }\n+\n+        \/\/ Try power of ten limits\n+        for (int limit = 1; limit < MAX_DEC_LIMIT; limit *= 10) {\n+            check(ByteBuffer.allocateDirect(limit - 1));\n+            check(ByteBuffer.allocateDirect(limit));\n+            check(ByteBuffer.allocateDirect(limit + 1));\n+        }\n+\n+        \/\/ Try random sizes within power of two limits\n+        for (int limit = 1; limit < MAX_BIN_LIMIT; limit *= 2) {\n+            for (int t = 0; t < TRIES_PER_LIMIT; t++) {\n+                check(ByteBuffer.allocateDirect(RND.nextInt(limit)));\n@@ -45,5 +69,12 @@\n-    private static void printByteBuffer(ByteBuffer bb) {\n-        System.out.print(\"byte [\");\n-        for (bb.position(0); bb.position() < bb.limit(); )\n-            System.out.print(\" \" + Integer.toHexString(bb.get() & 0xff));\n-        System.out.println(\" ]\");\n+    private static void check(ByteBuffer bb) {\n+        while (bb.hasRemaining()) {\n+            if (bb.get() != 0) {\n+                int mismatchPos = bb.position();\n+                System.out.print(\"byte [\");\n+                for (bb.position(0); bb.position() < bb.limit(); ) {\n+                    System.out.print(\" \" + Integer.toHexString(bb.get() & 0xff));\n+                }\n+                System.out.println(\" ]\");\n+                throw new RuntimeException(\"uninitialized buffer, position = \" + mismatchPos);\n+            }\n+        }\n","filename":"test\/jdk\/java\/nio\/Buffer\/AllocateDirectInit.java","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run main\/othervm Basic\n@@ -568,1 +569,2 @@\n-        return switch (rand.nextInt(3)) {\n+        rand.nextBytes(buf);\n+        return switch (rand.nextInt(5)) {\n@@ -573,1 +575,7 @@\n-            case 2 -> Arena.ofAuto().allocate(buf.length).asByteBuffer()\n+            case 2 -> Arena.global().allocate(buf.length).asByteBuffer()\n+                    .put(buf)\n+                    .flip();\n+            case 3 -> Arena.ofAuto().allocate(buf.length).asByteBuffer()\n+                    .put(buf)\n+                    .flip();\n+            case 4 -> Arena.ofShared().allocate(buf.length).asByteBuffer()\n@@ -609,1 +617,1 @@\n-                       long position)\n+                        long position)\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousFileChannel\/Basic.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,1 +330,1 @@\n-     * Test getTimeToLive\/setTimeToLive\/getTTL\/getTTL and IP_MULTICAST_TTL socket\n+     * Test getTimeToLive\/setTimeToLive and IP_MULTICAST_TTL socket\n@@ -336,1 +336,0 @@\n-        assertTrue(s.getTTL() == 1);\n@@ -343,1 +342,0 @@\n-            assertTrue(s.getTTL() == ttl);\n@@ -348,9 +346,0 @@\n-        \/\/ setTTL\n-        for (byte ttl = (byte) -2; ttl <= 2; ttl++) {\n-            s.setTTL(ttl);\n-            assertTrue(s.getTTL() == ttl);\n-            int intValue = Byte.toUnsignedInt(ttl);\n-            assertTrue(s.getTimeToLive() == intValue);\n-            assertTrue(s.getOption(IP_MULTICAST_TTL) == intValue);\n-        }\n-\n@@ -362,1 +351,0 @@\n-            assertTrue(s.getTTL() == ttl);\n@@ -422,1 +410,1 @@\n-        s.send(p, (byte) 1);\n+        s.send(p);\n@@ -466,1 +454,1 @@\n-        s.send(p, (byte) 1);\n+        s.send(p);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n@@ -204,7 +205,0 @@\n-    \/*\n-     * returns true if platform allows an IPv6 socket join an IPv4 multicast group\n-     *\/\n-    private static boolean supportedByPlatform() {\n-        return Platform.isOSX() || Platform.isLinux();\n-    }\n-\n@@ -215,9 +209,5 @@\n-        if (!supportedByPlatform()) {\n-            throw new SkippedException(\"This test should not be run on this platform\");\n-        } else {\n-            int major = Platform.getOsVersionMajor();\n-            int minor = Platform.getOsVersionMinor();\n-            hasIPV6MulticastAll =\n-                Platform.isOSX() ||\n-                (Platform.isLinux() && ((major > 4) || ((major == 4 && minor >= 20))));\n-        }\n+        int major = Platform.getOsVersionMajor();\n+        int minor = Platform.getOsVersionMinor();\n+        hasIPV6MulticastAll =\n+            Platform.isOSX() ||\n+            (Platform.isLinux() && ((major > 4) || ((major == 4 && minor >= 20))));\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/PromiscuousIPv6.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,4 @@\n- * @bug 8333849\n- * @summary Test ByteChannel implementations of read and write with ByteBuffers that are\n- *    backed by MemorySegments allocated from an Arena\n- * @run junit MemorySegments\n+ * @bug 8333849 8358958\n+ * @summary Test ByteChannel and AsycnhronousByteChannel implementations with ByteBuffers\n+ *    that are views of a MemorySegment\n+ * @run junit\/othervm MemorySegments\n@@ -38,0 +38,4 @@\n+import java.nio.channels.AsynchronousFileChannel;\n+import java.nio.channels.AsynchronousServerSocketChannel;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.CompletionHandler;\n@@ -45,0 +49,4 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n@@ -49,0 +57,1 @@\n+import org.junit.jupiter.api.RepeatedTest;\n@@ -328,0 +337,171 @@\n+    \/**\n+     * AsynchronousSocketChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncSocketChannelReadWrite(Supplier<Arena> arenaSupplier) throws Exception {\n+        boolean shared = isShared(arenaSupplier);\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        try (var listener = AsynchronousServerSocketChannel.open();\n+             AsynchronousSocketChannel ch1 = AsynchronousSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            ch1.connect(listener.getLocalAddress()).get();\n+            try (AsynchronousSocketChannel ch2 = listener.accept().get()) {\n+                ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+\n+                if (confined) {\n+                    \/\/ read and write should fail with IAE\n+                    assertThrows(IllegalArgumentException.class, () -> ch1.read(dst));\n+                    assertThrows(IllegalArgumentException.class, () -> ch2.write(src));\n+                } else {\n+                    \/\/ async read\n+                    Future<Integer> readTask = ch1.read(dst);\n+\n+                    \/\/ shared arena cannot be closed while read in progress\n+                    if (shared) {\n+                        assertThrows(IllegalStateException.class, arena::close);\n+                    }\n+\n+                    \/\/ async write\n+                    Future<Integer> writeTask = ch2.write(src);\n+\n+                    \/\/ finish write\n+                    int nwritten = writeTask.get();\n+                    assertTrue(nwritten > 0);\n+                    assertTrue(nwritten <= SIZE);\n+                    assertEquals(nwritten, src.position());\n+\n+                    \/\/ finish read\n+                    int nread = readTask.get();\n+                    assertTrue(nread > 0);\n+                    assertTrue(nread <= nwritten);\n+                    assertEquals(nread, dst.position());\n+\n+                    \/\/ check contents\n+                    dst.flip();\n+                    assertEquals(src.slice(0, nread), dst);\n+                }\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * AsynchronousSocketChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncSocketChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws Throwable {\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        try (var listener = AsynchronousServerSocketChannel.open();\n+             AsynchronousSocketChannel ch1 = AsynchronousSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            ch1.connect(listener.getLocalAddress()).get();\n+            try (AsynchronousSocketChannel ch2 = listener.accept().get()) {\n+\n+                ByteBuffer src = arena.allocate(SIZE * 2).asByteBuffer();\n+                fillRandom(src);\n+                ByteBuffer src1 = src.slice(0, SIZE);\n+                ByteBuffer src2 = src.slice(SIZE, SIZE);\n+                var srcs = new ByteBuffer[] { src1, src2 };\n+\n+                var writeHandler = new Handler<Long>();\n+                if (confined) {\n+                    assertThrows(IllegalArgumentException.class,\n+                            () -> ch1.write(srcs, 0, 2, 0, TimeUnit.SECONDS, null, writeHandler));\n+                } else {\n+                    \/\/ async gathering write\n+                    ch1.write(srcs, 0, 2, 0, TimeUnit.SECONDS, null, writeHandler);\n+\n+                    \/\/ finish gathering write\n+                    int nwritten = (int) (long) writeHandler.join();\n+                    assertTrue(nwritten > 0);\n+                    assertEquals(Math.min(nwritten, SIZE), src1.position());\n+                    assertEquals(nwritten, src1.position() + src2.position());\n+\n+                    \/\/ async read + finish read\n+                    ByteBuffer dst = arena.allocate(SIZE * 2 + 50).asByteBuffer();\n+                    int nread = ch2.read(dst).get();\n+                    assertTrue(nread > 0);\n+                    assertTrue(nread <= nwritten);\n+                    assertEquals(nread, dst.position());\n+\n+                    \/\/ check contents\n+                    dst.flip();\n+                    assertEquals(src.slice(0, nread), dst);\n+                }\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * AsynchronousSocketChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncSocketChannelScatteringRead(Supplier<Arena> arenaSupplier) throws Throwable {\n+        boolean shared = isShared(arenaSupplier);\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        try (var listener = AsynchronousServerSocketChannel.open();\n+             AsynchronousSocketChannel ch1 = AsynchronousSocketChannel.open()) {\n+            listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            ch1.connect(listener.getLocalAddress()).get();\n+            try (AsynchronousSocketChannel ch2 = listener.accept().get()) {\n+\n+                ByteBuffer dst = arena.allocate(SIZE + 50).asByteBuffer();\n+                ByteBuffer dst1 = dst.slice(0, 50);\n+                ByteBuffer dst2 = dst.slice(50, dst.capacity() - 50);\n+                var dsts = new ByteBuffer[]{dst1, dst2};\n+                var readHandler = new Handler<Long>();\n+\n+                if (confined) {\n+                    assertThrows(IllegalArgumentException.class,\n+                            () -> ch1.read(dsts, 0, 2, 0, TimeUnit.SECONDS, null, readHandler));\n+                } else {\n+                    \/\/ async scattering read\n+                    ch1.read(dsts, 0, 2, 0, TimeUnit.SECONDS, null, readHandler);\n+\n+                    \/\/ shared arena cannot be closed while read in progress\n+                    if (shared) {\n+                        assertThrows(IllegalStateException.class, arena::close);\n+                    }\n+\n+                    \/\/ async write + finish write\n+                    ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                    fillRandom(src);\n+                    int nwritten = ch2.write(src).get();\n+                    assertTrue(nwritten > 0);\n+                    assertTrue(nwritten <= SIZE);\n+                    assertEquals(nwritten, src.position());\n+\n+                    \/\/ finish scattering read\n+                    int nread = (int) (long) readHandler.join();\n+                    assertTrue(nread > 0);\n+                    assertTrue(nread <= nwritten);\n+                    assertTrue(dst1.position() > 0);\n+                    assertEquals(nread, dst1.position() + dst2.position());\n+\n+                    \/\/ check contents\n+                    src.flip();\n+                    assertEquals(src, dst.slice(0, nread));\n+                }\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n@@ -470,0 +650,121 @@\n+    \/**\n+     * AsynchronousFileChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testAsyncFileChannelReadWrite(Supplier<Arena> arenaSupplier) throws Throwable {\n+        boolean confined = isConfined(arenaSupplier);\n+        Arena arena = arenaSupplier.get();\n+\n+        Path file = Files.createTempFile(Path.of(\"\"), \"foo\", \".dat\");\n+        try (AsynchronousFileChannel ch = AsynchronousFileChannel.open(file, READ, WRITE)) {\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+\n+            if (confined) {\n+                \/\/ read and write should fail with IAE\n+                assertThrows(IllegalArgumentException.class, () -> ch.read(dst, 0L));\n+                assertThrows(IllegalArgumentException.class, () -> ch.write(src, 0L));\n+            } else {\n+                \/\/ async write\n+                Future<Integer> writeTask = ch.write(src, 0L);\n+\n+                \/\/ finish write\n+                int nwritten = writeTask.get();\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+                assertEquals(nwritten, src.position());\n+\n+                \/\/ async read\n+                Future<Integer> readTask = ch.read(dst, 0L);\n+\n+                \/\/ finish read\n+                int nread = readTask.get();\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertEquals(nread, dst.position());\n+\n+                \/\/ check contents\n+                dst.flip();\n+                assertEquals(src.slice(0, nread), dst);\n+            }\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a shared arena while AsynchronousFileChannel.write in progress.\n+     *\/\n+    @RepeatedTest(20)\n+    void testAsyncFileChannelWriteRacingArenaClose() throws Exception {\n+        Path file = Files.createTempFile(Path.of(\"\"), \"foo\", \".dat\");\n+\n+        \/\/ use SYNC option to cause write operation to be slow\n+        try (AsynchronousFileChannel ch = AsynchronousFileChannel.open(file, READ, WRITE, SYNC)) {\n+            Arena arena = Arena.ofShared();\n+            boolean closed = false;\n+            try {\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+\n+                \/\/ need copy of source buffer so that writing can be tested after arena is closed\n+                ByteBuffer srcCopy = copyOf(src);\n+\n+                \/\/ async write\n+                Future<Integer> writeTask = ch.write(src, 0L);\n+\n+                \/\/ attempt to close arena, races with write operation\n+                try {\n+                    arena.close();\n+                    closed = true;\n+                } catch (IllegalStateException e) {\n+                    \/\/ in use\n+                }\n+\n+                \/\/ finish write\n+                int nwritten = writeTask.get();\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+\n+                \/\/ read and check contents\n+                ByteBuffer dst = ByteBuffer.allocate(SIZE + 100);\n+                int nread = ch.read(dst, 0L).get();\n+                dst.flip();\n+                assertEquals(srcCopy.slice(0, nread), dst);\n+            } finally {\n+                if (!closed) {\n+                    arena.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * CompletionHandler with a join method to wait for operation to complete.\n+     *\/\n+    private static class Handler<V> implements CompletionHandler<V, Void> {\n+        volatile V result;\n+        volatile Throwable ex;\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        @Override\n+        public void completed(V result, Void att) {\n+            this.result = result;\n+            latch.countDown();\n+        }\n+        @Override\n+        public void failed(Throwable ex, Void att) {\n+            this.ex = ex;\n+            latch.countDown();\n+        }\n+        V join() throws ExecutionException, InterruptedException {\n+            latch.await();\n+            Throwable ex = this.ex;\n+            if (ex != null) {\n+                throw new ExecutionException(ex);\n+            }\n+            return result;\n+        }\n+    }\n+\n@@ -482,0 +783,36 @@\n+    \/**\n+     * Return a copy of a buffer.\n+     *\/\n+    private ByteBuffer copyOf(ByteBuffer buf) {\n+        ByteBuffer copy = ByteBuffer.allocate(buf.capacity());\n+        buf.put(copy);\n+        buf.flip();\n+        copy.flip();\n+        assertEquals(buf, copy);\n+        return copy;\n+    }\n+\n+    \/**\n+     * Returns true if the supplier produces shared arenas.\n+     *\/\n+    private boolean isShared(Supplier<Arena> arenaSupplier) {\n+        if (!isConfined(arenaSupplier)) {\n+            try {\n+                arenaSupplier.get().close();\n+                return true;\n+            } catch (UnsupportedOperationException e) { }\n+        }\n+        \/\/ confined or non-closeable\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns true if the supplier produces thread-confined arenas.\n+     *\/\n+    private boolean isConfined(Supplier<Arena> arenaSupplier) {\n+        Arena arena = arenaSupplier.get();\n+        boolean confined = !arena.allocate(0).isAccessibleBy(new Thread());\n+        tryClose(arena);\n+        return confined;\n+    }\n+\n@@ -493,1 +830,0 @@\n-\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/MemorySegments.java","additions":342,"deletions":6,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.io.ByteArrayInputStream;\n@@ -75,2 +76,4 @@\n-        out.println(\"Default: \"\n-                    + new InputStreamReader(System.in).getEncoding());\n+        for (String property : new String[]{\"stdin.encoding\", \"stdout.encoding\", \"stderr.encoding\"}) {\n+            String name = System.getProperty(property);\n+            out.printf(\"%s: %s (%s)%n\", property, name, Charset.forName(name));\n+        }\n","filename":"test\/jdk\/java\/nio\/charset\/spi\/CharsetTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8202088 8207152 8217609 8219890 8358819\n+ * @summary Test the localized Japanese calendar names, such as\n+ *      the Reiwa Era names (May 1st. 2019-), or the Gan-nen text\n+ * @modules jdk.localedata\n+ * @run junit JapaneseCalendarNameTest\n+ *\/\n+\n+import static java.util.Calendar.*;\n+import static java.util.Locale.*;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.util.Calendar;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class JapaneseCalendarNameTest {\n+    private static final Calendar c = new Calendar.Builder()\n+            .setCalendarType(\"japanese\")\n+            .setFields(ERA, 5, YEAR, 1, MONTH, MAY, DAY_OF_MONTH, 1)\n+            .build();\n+    private static final Locale JAJPJP = Locale.of(\"ja\", \"JP\", \"JP\");\n+    private static final Locale JCAL = Locale.forLanguageTag(\"ja-u-ca-japanese\");\n+\n+    private static Stream<Arguments> reiwaEraNames() {\n+        return Stream.of(\n+            \/\/ type, locale, name\n+            Arguments.of(LONG, JAPAN, \"\"),\n+            Arguments.of(LONG, US, \"Reiwa\"),\n+            Arguments.of(LONG, CHINA, \"\"),\n+            Arguments.of(SHORT, JAPAN, \"\"),\n+            Arguments.of(SHORT, US, \"Reiwa\"),\n+            Arguments.of(SHORT, CHINA, \"\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"reiwaEraNames\")\n+    void testReiwaEraName(int type, Locale locale, String expected) {\n+        assertEquals(expected, c.getDisplayName(ERA, type, locale));\n+    }\n+\n+    private static Stream<Arguments> gannen() {\n+        return Stream.of(\n+            \/\/ format,\n+            \/\/ formatted text\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.FULL, JAJPJP),\n+                \"51\"),\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.FULL, JCAL),\n+                \"51\"),\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.LONG, JAJPJP),\n+                \"51\"),\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.LONG, JCAL),\n+                \"51\"),\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.MEDIUM, JAJPJP),\n+                \"151\"),\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.MEDIUM, JCAL),\n+                \"151\"),\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.SHORT, JAJPJP),\n+                \"1\/5\/1\"),\n+            Arguments.of(DateFormat.getDateInstance(DateFormat.SHORT, JCAL),\n+                \"1\/5\/1\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"gannen\")\n+    void testGannenFormat(DateFormat df, String expected) {\n+        assertEquals(expected, df.format(c.getTime()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"gannen\")\n+    void testGannenParse(DateFormat df, String formatted) throws ParseException {\n+        assertEquals(c.getTime(), df.parse(formatted));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/JapaneseCalendarNameTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8202088 8207152 8217609 8219890\n- * @summary Test the localized Japanese new era name (May 1st. 2019-)\n- *      is retrieved no matter CLDR provider contains the name or not.\n- * @modules jdk.localedata\n- * @run testng JapaneseEraNameTest\n- *\/\n-\n-import static java.util.Calendar.*;\n-import static java.util.Locale.*;\n-import java.util.Calendar;\n-import java.util.Locale;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class JapaneseEraNameTest {\n-    static final Calendar c = new Calendar.Builder()\n-            .setCalendarType(\"japanese\")\n-            .setFields(ERA, 5, YEAR, 1, MONTH, MAY, DAY_OF_MONTH, 1)\n-            .build();\n-\n-    @DataProvider(name=\"names\")\n-    Object[][] names() {\n-        return new Object[][] {\n-            \/\/ type,    locale,  name\n-            { LONG,     JAPAN,   \"\\u4ee4\\u548c\" },\n-            { LONG,     US,      \"Reiwa\" },\n-            { LONG,     CHINA,   \"\\u4ee4\\u548c\" },\n-            { SHORT,    JAPAN,   \"\\u4ee4\\u548c\" },\n-            { SHORT,    US,      \"Reiwa\" },\n-            { SHORT,    CHINA,   \"\\u4ee4\\u548c\" },\n-        };\n-    }\n-\n-    @Test(dataProvider=\"names\")\n-    public void testJapaneseNewEraName(int type, Locale locale, String expected) {\n-        assertEquals(c.getDisplayName(ERA, type, locale), expected);\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Calendar\/JapaneseEraNameTest.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.concurrent.ExecutionException;\n@@ -48,0 +49,1 @@\n+import java.util.concurrent.Future;\n@@ -1889,0 +1891,108 @@\n+    public void testInterruptedExceptionThrownInBlockingMethods() throws InterruptedException {\n+        \/\/ Ensure that putFirst(), putLast(), takeFirst(), and takeLast()\n+        \/\/ immediately throw an InterruptedException if the thread is\n+        \/\/ interrupted, to be consistent with other blocking queues such as\n+        \/\/ ArrayBlockingQueue and LinkedBlockingQueue\n+        try (var pool = Executors.newSingleThreadExecutor()) {\n+            Future<Void> success = pool.submit(() -> {\n+                var queue = new LinkedBlockingDeque<>();\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.putFirst(42);\n+                    fail(\"Expected InterruptedException in putFirst()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                    assertFalse(Thread.currentThread().isInterrupted());\n+                }\n+\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.putLast(42);\n+                    fail(\"Expected InterruptedException in putLast()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                    assertFalse(Thread.currentThread().isInterrupted());\n+                }\n+\n+                queue.add(42);\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.takeFirst();\n+                    fail(\"Expected InterruptedException in takeFirst()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                    assertFalse(Thread.currentThread().isInterrupted());\n+                }\n+\n+                queue.add(42);\n+                Thread.currentThread().interrupt();\n+                try {\n+                    queue.takeLast();\n+                    fail(\"Expected InterruptedException in takeLast()\");\n+                } catch (InterruptedException expected) {\n+                    \/\/ good that's what we want\n+                    assertFalse(Thread.currentThread().isInterrupted());\n+                }\n+                return null;\n+            });\n+            try {\n+                success.get();\n+            } catch (ExecutionException e) {\n+                try {\n+                    throw e.getCause();\n+                } catch (Error | RuntimeException unchecked) {\n+                    throw unchecked;\n+                } catch (Throwable cause) {\n+                    throw new AssertionError(cause);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testWeaklyConsistentIterationWithClear() {\n+        final LinkedBlockingDeque<Item> q = new LinkedBlockingDeque<>();\n+        q.add(one);\n+        q.add(two);\n+        q.add(three);\n+        final Iterator<Item> it = q.iterator();\n+        mustEqual(one, it.next());\n+        q.clear();\n+        q.add(four);\n+        q.add(five);\n+        q.add(six);\n+        mustEqual(two, it.next());\n+        mustEqual(four, it.next());\n+        mustEqual(five, it.next());\n+        mustEqual(six, it.next());\n+        mustEqual(3, q.size());\n+    }\n+\n+    public void testWeaklyConsistentIterationWithIteratorRemove() {\n+        final LinkedBlockingDeque<Item> q = new LinkedBlockingDeque<>();\n+        q.add(one);\n+        q.add(two);\n+        q.add(three);\n+        q.add(four);\n+        q.add(five);\n+        final Iterator<Item> it1 = q.iterator();\n+        final Iterator<Item> it2 = q.iterator();\n+        final Iterator<Item> it3 = q.iterator();\n+        mustEqual(one, it1.next());\n+        mustEqual(two, it1.next());\n+        it1.remove(); \/\/ removing \"two\"\n+        mustEqual(one, it2.next());\n+        it2.remove(); \/\/ removing \"one\"\n+        mustEqual(three, it2.next());\n+        mustEqual(four, it2.next());\n+        it2.remove(); \/\/ removing \"four\"\n+        mustEqual(one, it3.next());\n+        mustEqual(three, it3.next());\n+        mustEqual(five, it3.next());\n+        assertFalse(it3.hasNext());\n+        mustEqual(three, it1.next());\n+        mustEqual(five, it1.next());\n+        assertFalse(it1.hasNext());\n+        mustEqual(five, it2.next());\n+        assertFalse(it2.hasNext());\n+        mustEqual(2, q.size());\n+    }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/LinkedBlockingDequeTest.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347114\n+ * @summary Test JMXServiceURL does not accept a null protocol\n+ *\n+ * @run main JMXServiceURLProtocol\n+ *\/\n+\n+import java.net.MalformedURLException;\n+import javax.management.remote.JMXServiceURL;\n+\n+public class JMXServiceURLProtocol {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        try {\n+            JMXServiceURL u = new JMXServiceURL(\"service:jmx::\/\/\");\n+            String proto = u.getProtocol();\n+            System.out.println(\"JMXServiceURL(String) with null protocol gets: \" + u + \" protocol: \" + proto);\n+            throw new RuntimeException(\"JMXServiceURL created using null protocol: \" + u);\n+        } catch (MalformedURLException e) {\n+            System.out.println(\"JMXServiceURL with null protocol causes expected: \" + e);\n+        }\n+\n+        try {\n+            JMXServiceURL u = new JMXServiceURL(null, \"localhost\", 1234);\n+            String proto = u.getProtocol();\n+            System.out.println(\"JMXServiceURL(params) with null protocol gets: \" + u + \" protocol: \" + proto);\n+            throw new RuntimeException(\"JMXServiceURL created using null protocol: \" + u);\n+        } catch (MalformedURLException e) {\n+            System.out.println(\"JMXServiceURL with null protocol causes expected: \" + e);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/JMXServiceURLProtocol.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -1,222 +0,0 @@\n-\/*\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * This is pluggable context used by test for 6398614\n- *\/\n-\n-import javax.script.*;\n-import java.util.*;\n-import java.io.*;\n-\n-public class MyContext  implements ScriptContext {\n-\n-    public static final int APP_SCOPE = 125;\n-\n-    protected Writer writer;\n-\n-    protected Writer errorWriter;\n-\n-    protected Reader reader;\n-\n-\n-    protected Bindings appScope;\n-    protected Bindings engineScope;\n-    protected Bindings globalScope;\n-\n-\n-    public MyContext() {\n-        appScope = new SimpleBindings();\n-        engineScope = new SimpleBindings();\n-        globalScope = null;\n-        reader = new InputStreamReader(System.in);\n-        writer = new PrintWriter(System.out , true);\n-        errorWriter = new PrintWriter(System.err, true);\n-    }\n-\n-    public void setBindings(Bindings bindings, int scope) {\n-\n-        switch (scope) {\n-            case APP_SCOPE:\n-                if (bindings == null) {\n-                    throw new NullPointerException(\"App scope cannot be null.\");\n-                }\n-                appScope = bindings;\n-                break;\n-\n-            case ENGINE_SCOPE:\n-                if (bindings == null) {\n-                    throw new NullPointerException(\"Engine scope cannot be null.\");\n-                }\n-                engineScope = bindings;\n-                break;\n-            case GLOBAL_SCOPE:\n-                globalScope = bindings;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid scope value.\");\n-        }\n-    }\n-\n-    public Object getAttribute(String name) {\n-        if (engineScope.containsKey(name)) {\n-            return getAttribute(name, ENGINE_SCOPE);\n-        } else if (appScope.containsKey(name)) {\n-            return getAttribute(name, APP_SCOPE);\n-        } else if (globalScope != null && globalScope.containsKey(name)) {\n-            return getAttribute(name, GLOBAL_SCOPE);\n-        }\n-\n-        return null;\n-    }\n-\n-    public Object getAttribute(String name, int scope) {\n-\n-        switch (scope) {\n-            case APP_SCOPE:\n-                return appScope.get(name);\n-\n-            case ENGINE_SCOPE:\n-                return engineScope.get(name);\n-\n-            case GLOBAL_SCOPE:\n-                if (globalScope != null) {\n-                    return globalScope.get(name);\n-                }\n-                return null;\n-\n-            default:\n-                throw new IllegalArgumentException(\"Illegal scope value.\");\n-        }\n-    }\n-\n-    public Object removeAttribute(String name, int scope) {\n-\n-        switch (scope) {\n-            case APP_SCOPE:\n-                if (getBindings(APP_SCOPE) != null) {\n-                    return getBindings(APP_SCOPE).remove(name);\n-                }\n-                return null;\n-\n-\n-            case ENGINE_SCOPE:\n-                if (getBindings(ENGINE_SCOPE) != null) {\n-                    return getBindings(ENGINE_SCOPE).remove(name);\n-                }\n-                return null;\n-\n-            case GLOBAL_SCOPE:\n-                if (getBindings(GLOBAL_SCOPE) != null) {\n-                    return getBindings(GLOBAL_SCOPE).remove(name);\n-                }\n-                return null;\n-\n-            default:\n-                throw new IllegalArgumentException(\"Illegal scope value.\");\n-        }\n-    }\n-\n-    public void setAttribute(String name, Object value, int scope) {\n-\n-        switch (scope) {\n-            case APP_SCOPE:\n-                appScope.put(name, value);\n-                return;\n-\n-            case ENGINE_SCOPE:\n-                engineScope.put(name, value);\n-                return;\n-\n-            case GLOBAL_SCOPE:\n-                if (globalScope != null) {\n-                    globalScope.put(name, value);\n-                }\n-                return;\n-\n-            default:\n-                throw new IllegalArgumentException(\"Illegal scope value.\");\n-        }\n-    }\n-\n-    public Writer getWriter() {\n-        return writer;\n-    }\n-\n-    public Reader getReader() {\n-        return reader;\n-    }\n-\n-    public void setReader(Reader reader) {\n-        this.reader = reader;\n-    }\n-\n-    public void setWriter(Writer writer) {\n-        this.writer = writer;\n-    }\n-\n-    public Writer getErrorWriter() {\n-        return errorWriter;\n-    }\n-\n-    public void setErrorWriter(Writer writer) {\n-        this.errorWriter = writer;\n-    }\n-\n-    public int getAttributesScope(String name) {\n-        if (engineScope.containsKey(name)) {\n-            return ENGINE_SCOPE;\n-        } else if (appScope.containsKey(name)) {\n-            return APP_SCOPE;\n-        } else if (globalScope != null && globalScope.containsKey(name)) {\n-            return GLOBAL_SCOPE;\n-        } else {\n-            return -1;\n-        }\n-    }\n-\n-    public Bindings getBindings(int scope) {\n-        if (scope == ENGINE_SCOPE) {\n-            return engineScope;\n-        } else if (scope == APP_SCOPE) {\n-            return appScope;\n-        } else if (scope == GLOBAL_SCOPE) {\n-            return globalScope;\n-        } else {\n-            throw new IllegalArgumentException(\"Illegal scope value.\");\n-        }\n-    }\n-\n-    public List<Integer> getScopes() {\n-        return scopes;\n-    }\n-\n-    private static List<Integer> scopes;\n-    static {\n-        scopes = new ArrayList<Integer>(3);\n-        scopes.add(ENGINE_SCOPE);\n-        scopes.add(APP_SCOPE);\n-        scopes.add(GLOBAL_SCOPE);\n-        scopes = Collections.unmodifiableList(scopes);\n-    }\n-}\n","filename":"test\/jdk\/javax\/script\/MyContext.java","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -44,1 +44,1 @@\n- * @bug 8139228\n+ * @bug 8139228 8358532\n@@ -55,3 +55,7 @@\n-            <li>FileChooser shows up a virtual directory and file with name\n-               <html><h1 color=#ff00ff><font face=\"Comic Sans MS\">Swing Rocks!.\n-            <li>On \"HTML disabled\" frame :\n+            <li><code>JFileChooser<\/code> shows a virtual directory.\n+                The first file in the list has the following name:\n+                <code>&lt;html&gt;&lt;h1 color=#ff00ff&gt;&lt;font\n+                face=\"Serif\"&gt;Swing Rocks!<\/code>\n+                <br>\n+                <br>\n+            <li>In <b>HTML disabled<\/b> frame:\n@@ -59,5 +63,7 @@\n-                  <li>Verify that the folder and file name must be plain text.\n-                  <li>If the name in file pane window and also in directory\n-                     ComboBox remains in plain text, then press <b>Pass<\/b>.\n-                     If it appears to be in HTML format with Pink color as\n-                     shown, then press <b>Fail<\/b>.\n+                  <li>Verify that the first file name displays\n+                      as <em>plain text<\/em>,\n+                      that is you see the HTML tags in the file name.\n+                  <li>If the file name in the file pane and\n+                      in the navigation combo box above is displayed\n+                      as HTML, that is in large font and magenta color,\n+                      then press <b>Fail<\/b>.\n@@ -66,1 +72,1 @@\n-            <li>On \"HTML enabled\" frame :\n+            <li>In <b>HTML enabled<\/b> frame:\n@@ -68,5 +74,10 @@\n-                  <li>Verify that the folder and file name remains in HTML\n-                     format with name \"Swing Rocks!\" pink in color as shown.\n-                  <li>If the name in file pane window and also in directory\n-                     ComboBox remains in HTML format string, then press <b>Pass<\/b>.\n-                     If it appears to be in plain text, then press <b>Fail<\/b>.\n+                  <li>Verify that the first file name displays as <em>HTML<\/em>,\n+                      that is <code><font face=\"Serif\"\n+                      color=#ff00ff>Swing Rocks!<\/code> in large font\n+                      and magenta color.<br>\n+                      <b>Note:<\/b> On macOS in Aqua L&amp;F, the file name with\n+                      HTML displays as an empty file name. It is not an error.\n+                  <li>If the file name in the file pane and\n+                      in the navigation combo box above is displayed\n+                      as HTML, then press <b>Pass<\/b>.<br>\n+                      If it is in plain text, then press <b>Fail<\/b>.\n@@ -102,0 +113,1 @@\n+                .rows(20)\n@@ -113,1 +125,1 @@\n-    private static JFrame createFileChooser(boolean htmlEnabled) {\n+    private static JFrame createFileChooser(boolean htmlDisabled) {\n@@ -115,1 +127,1 @@\n-        jfc.putClientProperty(\"html.disable\", htmlEnabled);\n+        jfc.putClientProperty(\"html.disable\", htmlDisabled);\n@@ -118,1 +130,1 @@\n-        JFrame frame = new JFrame((htmlEnabled) ? \"HTML enabled\" : \"HTML disabled\");\n+        JFrame frame = new JFrame(htmlDisabled ? \"HTML disabled\" : \"HTML enabled\");\n@@ -125,0 +137,7 @@\n+        private final File[] files = {\n+                new File(\"\/\", \"<html><h1 color=#ff00ff><font \" +\n+                         \"face=\\\"Serif\\\">Swing Rocks!\"),\n+                new File(\"\/\", \"virtualFile1.txt\"),\n+                new File(\"\/\", \"virtualFile2.log\")\n+        };\n+\n@@ -132,6 +151,1 @@\n-            return new File[]{\n-                    new File(\"\/\", \"<html><h1 color=#ff00ff><font \" +\n-                            \"face=\\\"Comic Sans MS\\\">Swing Rocks!\"),\n-                    new File(\"\/\", \"virtualFile2.txt\"),\n-                    new File(\"\/\", \"virtualFolder\")\n-            };\n+            return files;\n@@ -153,6 +167,1 @@\n-            return new File[]{\n-                    new File(\"\/\", \"<html><h1 color=#ff00ff><font \" +\n-                            \"face=\\\"Comic Sans MS\\\">Swing Rocks!\"),\n-                    new File(dir, \"virtualFile2.txt\"),\n-                    new File(dir, \"virtualFolder\")\n-            };\n+            return files;\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/HTMLFileName.java","additions":39,"deletions":30,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    static volatile JFrame frame;\n@@ -94,1 +95,1 @@\n-        JFrame frame = new JFrame(\"bug4499556\");\n+        frame = new JFrame(\"bug4499556\");\n@@ -265,1 +266,1 @@\n-        SwingUtilities.updateComponentTreeUI(pane);\n+        SwingUtilities.updateComponentTreeUI(frame);\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/bug4499556.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 4231444 8354646\n+ * @summary Password fields' ActionMap needs to replace\n+ *          DefaultEditorKit.selectWordAction with\n+ *          DefaultEditorKit.selectLineAction.\n+ *\n+ * @run main PasswordSelectionWordTest\n+ *\/\n+\n+import javax.swing.Action;\n+import javax.swing.JPasswordField;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.plaf.basic.BasicTextUI;\n+import javax.swing.text.DefaultEditorKit;\n+import java.awt.event.ActionEvent;\n+\n+public class PasswordSelectionWordTest {\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing LAF: \" + laf.getClassName());\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (setLookAndFeel(laf)) {\n+                    runTest();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static boolean setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+            return true;\n+        } catch (UnsupportedLookAndFeelException  e) {\n+            System.err.println(\"Skipping unsupported look and feel:\");\n+            e.printStackTrace();\n+            return false;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void runTest() {\n+        String str = \"one two three\";\n+        JPasswordField field = new JPasswordField(str);\n+        if (!(field.getUI() instanceof BasicTextUI)) {\n+            throw new RuntimeException(\"Unexpected condition: JPasswordField UI was \" + field.getUI());\n+        }\n+        System.out.println(\"Testing \" + field.getUI());\n+\n+        \/\/ do something (anything) to initialize the Views:\n+        field.setSize(100, 100);\n+        field.addNotify();\n+\n+        Action action = field.getActionMap().get(\n+                DefaultEditorKit.selectWordAction);\n+        action.actionPerformed(new ActionEvent(field, 0, \"\"));\n+        int selectionStart = field.getSelectionStart();\n+        int selectionEnd = field.getSelectionEnd();\n+        System.out.println(\"selectionStart = \" + selectionStart);\n+        System.out.println(\"selectionEnd = \" + selectionEnd);\n+        if (selectionStart != 0 || selectionEnd != str.length()) {\n+            throw new RuntimeException(\"selectionStart = \" + selectionStart +\n+                    \" and selectionEnd = \" + selectionEnd);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicTextUI\/PasswordSelectionWordTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-        nwp.setText(\"the\\tslow\\tbrown\\tfox\\tjumps\\tover\\tthe\\tlazy\\tdog!\");\n+        nwp.setText(\"the\\tquick\\tbrown\\tfox\\tjumps\\tover\\tthe\\tlazy\\tdog!\");\n","filename":"test\/jdk\/javax\/swing\/text\/GlyphView\/bug4188841.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -289,2 +289,2 @@\n-        \/\/ Re-enable sha1 algs\n-        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\");\n+        \/\/ Re-enable sha1 and xpath algs\n+        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\", \"xpath\");\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,2 @@\n-        \/\/ Re-enable sha1 algs\n-        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\");\n+        \/\/ Re-enable sha1 and xpath algs\n+        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\", \"xpath\");\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/HereFunction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8151893 8259709\n+ * @bug 8151893 8259709 8314180\n@@ -50,1 +50,2 @@\n-            \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#ecdsa-sha1\");\n+            \"http:\/\/www.w3.org\/2001\/04\/xmldsig-more#ecdsa-sha1\",\n+            \"http:\/\/www.w3.org\/TR\/1999\/REC-xpath-19991116\");\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/SecureValidationPolicy.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,2 +144,2 @@\n-        \/\/ Re-enable sha1 algs\n-        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\");\n+        \/\/ Re-enable sha1 and xpath algs\n+        SecurityUtils.removeAlgsFromDSigPolicy(\"sha1\", \"xpath\");\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/ValidationTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    private static final long CodeCacheExpectedSize = WhiteBox.getWhiteBox().getUintxVMFlag(\"ReservedCodeCacheSize\");\n+    private static final long CodeCacheExpectedSize = WhiteBox.getWhiteBox().getSizeTVMFlag(\"ReservedCodeCacheSize\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeCacheConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-    public static final long SEGMENT_SIZE = WhiteBox.getWhiteBox().getUintxVMFlag(\"CodeCacheSegmentSize\");\n-    public static final long MIN_BLOCK_LENGTH = WhiteBox.getWhiteBox().getUintxVMFlag(\"CodeCacheMinBlockLength\");\n+    public static final long SEGMENT_SIZE = WhiteBox.getWhiteBox().getSizeTVMFlag(\"CodeCacheSegmentSize\");\n+    public static final long MIN_BLOCK_LENGTH = WhiteBox.getWhiteBox().getSizeTVMFlag(\"CodeCacheMinBlockLength\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeSweeper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        Asserts.assertTrue(rate > 90 && rate < 110, \"Expected around 100 events per second, got \" + rate);\n+        Asserts.assertTrue(rate > 75 && rate < 110, \"Expected around 100 events per second, got \" + rate);\n@@ -67,1 +67,1 @@\n-    private record EventCount(long count, float time) {\n+    private record EventCount(long count, float cpuTime) {\n@@ -69,1 +69,1 @@\n-            return count \/ time;\n+            return count \/ cpuTime;\n@@ -73,2 +73,10 @@\n-    private static EventCount countEvents(int timeMs, String rate) throws Exception {\n-        try(Recording recording = new Recording()) {\n+    \/**\n+     * Counting the events that are emitted for a given throttle in a given time.\n+     * <p>\n+     * The result is wall-clock independent; it only records the CPU-time and the number of\n+     * emitted events. The result, therefore, does not depend on the load of the machine.\n+     * And because failed events are counted too, the result is not affected by the thread\n+     * doing other in-JVM work (like garbage collection).\n+     *\/\n+    private static EventCount countEvents(int timeMs, String throttle) throws Exception {\n+        try (Recording recording = new Recording()) {\n@@ -76,1 +84,1 @@\n-                    .with(\"throttle\", rate);\n+                    .with(\"throttle\", throttle);\n@@ -95,2 +103,0 @@\n-            System.out.println(\"Event count: \" + eventCount + \", CPU time: \" + spendCPUTime \/ 1_000_000_000f + \"s\");\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleThrottling.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.nio.file.Path;\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test\n+ * @summary Tests that java.lang.String can be traced.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.tracing.TestTracedString\n+ **\/\n+public class TestTracedString {\n+    private static long SEED = System.currentTimeMillis();\n+\n+    @Name(\"Message\")\n+    static class MessageEvent extends jdk.jfr.Event {\n+        String message;\n+        long checkSum;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Configuration c = Configuration.getConfiguration(\"default\");\n+        Path file = Path.of(\"recording.jfr\");\n+        try (Recording r = new Recording(c)) {\n+            r.enable(\"jdk.MethodTrace\").with(\"filter\", \"java.lang.String\");\n+            r.start();\n+            emit(100, \"\");\n+            emit(100, \"short\");\n+            emit(100, \"medium medium medium medium medium medium 1\");\n+            emit(100, \"medium medium medium medium medium medium 2\");\n+            emit(100, \"long\".repeat(100));\n+            r.stop();\n+            r.dump(file);\n+            int count = 0;\n+            for (RecordedEvent e : RecordingFile.readAllEvents(file)) {\n+                if (e.getEventType().getName().equals(\"Message\")) {\n+                    String text = e.getString(\"message\");\n+                    long checkSum = e.getLong(\"checkSum\");\n+                    if (checkSum(text) != checkSum) {\n+                        throw new Exception(\"Incorrect checksum for text \" + text);\n+                    }\n+                    count++;\n+                }\n+            }\n+            if (count != 500) {\n+                throw new Exception(\"Expected 500 Message events. Got \" + count);\n+            }\n+        }\n+    }\n+\n+    private static void emit(int count, String text) {\n+        long checkSum = checkSum(text);\n+        for (int i = 0; i < count; i++) {\n+            MessageEvent m = new MessageEvent();\n+            m.message = text;\n+            m.checkSum = checkSum;\n+            m.commit();\n+        }\n+    }\n+\n+    private static long checkSum(String text) {\n+        long checkSum = SEED;\n+        for (int i = 0; i < text.length(); i++) {\n+            checkSum += 17 * text.charAt(i);\n+        }\n+        return checkSum;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestTracedString.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -83,1 +83,1 @@\n-    private static final String NSS_BUNDLE_VERSION = \"3.107\";\n+    private static final String NSS_BUNDLE_VERSION = \"3.111\";\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,1 +26,1 @@\n- * @bug 8027634 8210810 8240629\n+ * @bug 8027634 8210810 8240629 8357862\n@@ -175,0 +175,9 @@\n+        },\n+        { \/\/ multiple args in one line and comments without preceding whitespace\n+            { \"-Xmx32m -XshowSettings#COMMENT 1\",\n+              \"-version#COMMENT 2\"\n+            },\n+            { \"-Xmx32m\",\n+              \"-XshowSettings\",\n+              \"-version\"\n+            }\n","filename":"test\/jdk\/tools\/launcher\/ArgFileSyntax.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -48,1 +48,10 @@\n-}\n\\ No newline at end of file\n+\n+    \/** Dangling comment X *\/\n+\n+    \/**\n+     * The {@code @SuppressWarnings} annotation below retroactively\n+     * silences the warning about \"Dangling comment X\".\n+     *\/\n+    @SuppressWarnings(\"dangling-doc-comments\")\n+    public void m5() { }\n+}\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    private static final String FLAG_DEBUG_NAME = \"CodeCacheMinimumUseSpace\";\n+    private static final String FLAG_DEBUG_NAME = \"StopInterpreterAt\";\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/UintxTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-        return WhiteBox.getWhiteBox().getUintxVMFlag(sizeOptionName);\n+        return WhiteBox.getWhiteBox().getSizeTVMFlag(sizeOptionName);\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/BlobType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class DirectByteBufferAlloc {\n+\n+    @Param({\n+            \"128\", \/\/ 128 bytes\n+            \"1024\", \/\/ 1KB\n+            \"1048576\", \/\/ 1 MB\n+            \"16777216\" \/\/ 16MB\n+    })\n+    public int bytes;\n+\n+    @Benchmark\n+    public ByteBuffer allocateDirectBuffer() {\n+        return ByteBuffer.allocateDirect(bytes);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/DirectByteBufferAlloc.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}