{"files":[{"patch":"@@ -1853,1 +1853,1 @@\n-    __ safepoint_poll(*code_stub, true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, false \/* acquire *\/, true \/* in_nmethod *\/);\n+  __ safepoint_poll(*code_stub->entry(), true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64);\n+define_pd_global(size_t, CodeCacheSegmentSize,   64);\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -663,1 +663,1 @@\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -561,7 +561,2 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp) {\n-  if (acquire) {\n-    lea(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-    ldar(tmp, tmp);\n-  } else {\n-    ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n-  }\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp) {\n+  ldr(tmp, Address(rthread, JavaThread::polling_word_offset()));\n@@ -997,2 +992,6 @@\n-  movptr(rscratch1, 0);\n-  br(rscratch1);\n+  if (codestub_branch_needs_far_jump()) {\n+    movptr(rscratch1, 0);\n+    br(rscratch1);\n+  } else {\n+    b(pc());\n+  }\n@@ -1002,0 +1001,4 @@\n+  if (!codestub_branch_needs_far_jump()) {\n+    \/\/ isb; movk; movz; movz; b\n+    return 5 * NativeInstruction::instruction_size;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp = rscratch1);\n+  void safepoint_poll(Label& slow_path, bool at_return, bool in_nmethod, Register tmp = rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2159,1 +2159,1 @@\n-    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11806,0 +11806,4 @@\n+  void generate_preuniverse_stubs() {\n+    \/\/ preuniverse stubs are not needed for aarch64\n+  }\n+\n@@ -12059,0 +12063,3 @@\n+    case preuniverse_id:\n+      generate_preuniverse_stubs();\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1027,1 +1027,1 @@\n-  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1074,1 +1074,1 @@\n-  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1464,1 +1464,1 @@\n-    __ safepoint_poll(L, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ safepoint_poll(L, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1617,1 +1617,1 @@\n-  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,4 +62,4 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,  128);\n-define_pd_global(intx,  CodeEntryAlignment,    64);\n-define_pd_global(intx,  OptoLoopAlignment,     16);\n-define_pd_global(intx,  InlineSmallCode,       1500);\n+define_pd_global(size_t, CodeCacheSegmentSize,  128);\n+define_pd_global(intx,   CodeEntryAlignment,    64);\n+define_pd_global(intx,   OptoLoopAlignment,     16);\n+define_pd_global(intx,   InlineSmallCode,       1500);\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,5 +45,5 @@\n-define_pd_global(uintx,  InitialCodeCacheSize,         160*K);\n-define_pd_global(uintx,  ReservedCodeCacheSize,        32*M );\n-define_pd_global(uintx,  NonProfiledCodeHeapSize,      13*M );\n-define_pd_global(uintx,  ProfiledCodeHeapSize,         14*M );\n-define_pd_global(uintx,  NonNMethodCodeHeapSize,       5*M  );\n+define_pd_global(size_t, InitialCodeCacheSize,         160*K);\n+define_pd_global(size_t, ReservedCodeCacheSize,        32*M );\n+define_pd_global(size_t, NonProfiledCodeHeapSize,      13*M );\n+define_pd_global(size_t, ProfiledCodeHeapSize,         14*M );\n+define_pd_global(size_t, NonNMethodCodeHeapSize,       5*M  );\n@@ -51,3 +51,3 @@\n-define_pd_global(uintx,  CodeCacheExpansionSize,       32*K );\n-define_pd_global(uintx,  CodeCacheMinBlockLength,      1    );\n-define_pd_global(uintx,  CodeCacheMinimumUseSpace,     400*K);\n+define_pd_global(size_t, CodeCacheExpansionSize,       32*K );\n+define_pd_global(size_t, CodeCacheMinBlockLength,      1    );\n+define_pd_global(size_t, CodeCacheMinimumUseSpace,     400*K);\n","filename":"src\/hotspot\/cpu\/x86\/c1_globals_x86.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4687,0 +4687,1 @@\n+  \/\/ APX REX2 encoding for pop(dst) increases the stub size by 1 byte.\n@@ -4719,1 +4720,3 @@\n-  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, 23, convertF2I_slowpath);\n+  \/\/ Using the APX extended general purpose registers increases the instruction encoding size by 1 byte.\n+  int max_size = 23 + (UseAPX ? 1 : 0);\n+  auto stub = C2CodeStub::make<Register, XMMRegister, address>(dst, src, slowpath_target, max_size, convertF2I_slowpath);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(size_t, CodeCacheSegmentSize,   64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4068,0 +4068,5 @@\n+void StubGenerator::generate_preuniverse_stubs() {\n+  \/\/ atomic calls\n+  StubRoutines::_fence_entry                = generate_orderaccess_fence();\n+}\n+\n@@ -4103,3 +4108,0 @@\n-  \/\/ atomic calls\n-  StubRoutines::_fence_entry                = generate_orderaccess_fence();\n-\n@@ -4517,0 +4519,3 @@\n+  case preuniverse_id:\n+    generate_preuniverse_stubs();\n+    break;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -640,0 +640,1 @@\n+  void generate_preuniverse_stubs();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2114,1 +2114,1 @@\n-  return (is_intel_family_core() &&\n+  return (is_intel_server_family() &&\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,4 +41,4 @@\n-define_pd_global(uintx, CodeCacheSegmentSize, 64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n-define_pd_global(intx,  CodeEntryAlignment,   32);\n-define_pd_global(intx,  OptoLoopAlignment,    16);\n-define_pd_global(intx,  InlineSmallCode,      1000);\n+define_pd_global(size_t, CodeCacheSegmentSize, 64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(intx,   CodeEntryAlignment,   32);\n+define_pd_global(intx,   OptoLoopAlignment,    16);\n+define_pd_global(intx,   InlineSmallCode,      1000);\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,7 @@\n-  void do_NewInstance    (NewInstance*     x) { \/* nothing to do *\/ }\n+  void do_NewInstance    (NewInstance*     x) {\n+    ciInstanceKlass* c = x->klass();\n+    if (c != nullptr && !c->is_initialized() &&\n+        (!c->is_loaded() || c->has_class_initializer())) {\n+      kill_memory();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"c1\/c1_globals_pd.hpp\"\n@@ -31,0 +30,1 @@\n+#include CPU_HEADER(c1_globals)\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -729,2 +730,2 @@\n-  \/\/ AOT profiles are supported only in the JEP 483 workflow.\n-  bool can_dump_profiles = AOTClassLinking && new_aot_flags_used();\n+  \/\/ AOT profiles and AOT-compiled code are supported only in the JEP 483 workflow.\n+  bool can_dump_profile_and_compiled_code = AOTClassLinking && new_aot_flags_used();\n@@ -732,1 +733,1 @@\n-  if (is_dumping_preimage_static_archive() && can_dump_profiles) {\n+  if (is_dumping_preimage_static_archive() && can_dump_profile_and_compiled_code) {\n@@ -736,1 +737,2 @@\n-  } else if (is_dumping_final_static_archive() && can_dump_profiles) {\n+    AOTCodeCache::disable_caching(); \/\/ No AOT code generation during training run\n+  } else if (is_dumping_final_static_archive() && can_dump_profile_and_compiled_code) {\n@@ -740,0 +742,2 @@\n+    AOTCodeCache::enable_caching(); \/\/ Generate AOT code during assembly phase.\n+    disable_dumping_aot_code();     \/\/ Don't dump AOT code until metadata and heap are dumped.\n@@ -744,0 +748,1 @@\n+    AOTCodeCache::enable_caching();\n@@ -747,0 +752,1 @@\n+    AOTCodeCache::disable_caching();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"cds\/lambdaProxyClassDictionary.hpp\"\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -300,0 +301,2 @@\n+  \/\/ Which JIT compier is used\n+  _compiler_type = (u1)CompilerConfig::compiler_type();\n@@ -996,1 +999,1 @@\n-     aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n+    aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n@@ -2011,0 +2014,17 @@\n+  bool jvmci_compiler_is_enabled = CompilerConfig::is_jvmci_compiler_enabled();\n+  CompilerType compiler_type = CompilerConfig::compiler_type();\n+  CompilerType archive_compiler_type = CompilerType(_compiler_type);\n+  \/\/ JVMCI compiler does different type profiling settigns and generate\n+  \/\/ different code. We can't use archive which was produced\n+  \/\/ without it and reverse.\n+  \/\/ Only allow mix when JIT compilation is disabled.\n+  \/\/ Interpreter is used by default when dumping archive.\n+  bool intepreter_is_used = (archive_compiler_type == CompilerType::compiler_none) ||\n+                            (compiler_type == CompilerType::compiler_none);\n+  if (!intepreter_is_used &&\n+      jvmci_compiler_is_enabled != (archive_compiler_type == CompilerType::compiler_jvmci)) {\n+    MetaspaceShared::report_loading_error(\"The %s's JIT compiler setting (%s)\"\n+                                          \" does not equal the current setting (%s).\", file_type,\n+                                          compilertype2name(archive_compiler_type), compilertype2name(compiler_type));\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+  u1      _compiler_type;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2024,4 +2024,1 @@\n-    if (AOTCodeCache::is_on_for_use()) {\n-      tty->print_cr(\"\\n\\nAOT Code\");\n-      AOTCodeCache::print_on(tty);\n-    }\n+    AOTCodeCache::print_on(tty);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -632,0 +632,5 @@\n+bool ciInstanceKlass::has_class_initializer() {\n+  VM_ENTRY_MARK;\n+  return get_instanceKlass()->class_initializer() != nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -262,0 +262,2 @@\n+  bool has_class_initializer();\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3905,0 +3905,1 @@\n+  this_klass->set_fieldinfo_search_table(_fieldinfo_search_table);\n@@ -3916,0 +3917,2 @@\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_cp, _fieldinfo_stream, _fieldinfo_search_table));\n+\n@@ -5325,0 +5328,1 @@\n+  assert(nullptr == _fieldinfo_search_table, \"invariant\");\n@@ -5562,0 +5566,1 @@\n+  _fieldinfo_search_table(nullptr),\n@@ -5646,0 +5651,1 @@\n+  _fieldinfo_search_table = nullptr;\n@@ -5670,0 +5676,1 @@\n+  MetadataFactory::free_array<u1>(_loader_data, _fieldinfo_search_table);\n@@ -6262,1 +6269,1 @@\n-\n+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,0 +139,1 @@\n+  Array<u1>* _fieldinfo_search_table;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -685,1 +685,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -972,0 +972,7 @@\n+\n+      Array<u1>* old_table = ik->fieldinfo_search_table();\n+      Array<u1>* search_table = FieldInfoStream::create_search_table(ik->constants(), new_fis, k->class_loader_data(), CHECK);\n+      ik->set_fieldinfo_search_table(search_table);\n+      MetadataFactory::free_array<u1>(k->class_loader_data(), old_table);\n+\n+      DEBUG_ONLY(FieldInfoStream::validate_search_table(ik->constants(), new_fis, search_table));\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -87,2 +86,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  AOTCodeCache::disable_caching();\n@@ -91,0 +89,21 @@\n+\/\/ The sequence of AOT code caching flags and parametters settings.\n+\/\/\n+\/\/ 1. The initial AOT code caching flags setting is done\n+\/\/ during call to CDSConfig::check_vm_args_consistency().\n+\/\/\n+\/\/ 2. The earliest AOT code state check done in compilationPolicy_init()\n+\/\/ where we set number of compiler threads for AOT assembly phase.\n+\/\/\n+\/\/ 3. We determine presence of AOT code in AOT Cache in\n+\/\/ MetaspaceShared::open_static_archive() which is calles\n+\/\/ after compilationPolicy_init() but before codeCache_init().\n+\/\/\n+\/\/ 4. AOTCodeCache::initialize() is called during universe_init()\n+\/\/ and does final AOT state and flags settings.\n+\/\/\n+\/\/ 5. Finally AOTCodeCache::init2() is called after universe_init()\n+\/\/ when all GC settings are finalized.\n+\n+\/\/ Next methods determine which action we do with AOT code depending\n+\/\/ on phase of AOT process: assembly or production.\n+\n@@ -107,0 +126,17 @@\n+\/\/ Next methods could be called regardless AOT code cache status.\n+\/\/ Initially they are called during flags parsing and finilized\n+\/\/ in AOTCodeCache::initialize().\n+void AOTCodeCache::enable_caching() {\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+  FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+}\n+\n+void AOTCodeCache::disable_caching() {\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+  FLAG_SET_ERGO(AOTAdapterCaching, false);\n+}\n+\n+bool AOTCodeCache::is_caching_enabled() {\n+  return AOTStubCaching || AOTAdapterCaching;\n+}\n+\n@@ -128,2 +164,4 @@\n-\/\/ This method is called during universe_init()\n-\/\/ and does final AOT state and flags settings.\n+\/\/ It is called from MetaspaceShared::initialize_shared_spaces()\n+\/\/ which is called from universe_init().\n+\/\/ At this point all AOT class linking seetings are finilized\n+\/\/ and AOT cache is open so we can map AOT code region.\n@@ -133,2 +171,1 @@\n-  AOTAdapterCaching = false;\n-  AOTStubCaching = false;\n+  disable_caching();\n@@ -139,2 +176,1 @@\n-    AOTAdapterCaching = false;\n-    AOTStubCaching = false;\n+    disable_caching();\n@@ -161,2 +197,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+    enable_caching();\n+    is_dumping = is_caching_enabled();\n@@ -165,3 +201,2 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n-    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n-    is_using = true;\n+    enable_caching();\n+    is_using = is_caching_enabled();\n@@ -170,0 +205,1 @@\n+    disable_caching();\n@@ -172,1 +208,2 @@\n-  if (!AOTAdapterCaching && !AOTStubCaching) {\n+  if (!(is_dumping || is_using)) {\n+    disable_caching();\n@@ -185,0 +222,1 @@\n+    disable_caching();\n@@ -204,0 +242,1 @@\n+DEBUG_ONLY( bool AOTCodeCache::_passed_init2 = false; )\n@@ -205,2 +244,1 @@\n-\/\/ This method is called after universe_init()\n-\/\/ when all GC settings are finalized.\n+\/\/ It is called after universe_init() when all GC settings are finalized.\n@@ -208,0 +246,1 @@\n+  DEBUG_ONLY( _passed_init2 = true; )\n@@ -223,1 +262,0 @@\n-  table->init_early_stubs();\n@@ -315,0 +353,7 @@\n+void AOTCodeCache::init_early_stubs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_stubs();\n+  }\n+}\n+\n@@ -347,0 +392,1 @@\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -777,0 +823,3 @@\n+  if (!is_on()) {\n+    return false; \/\/ AOT code cache was already dumped and closed.\n+  }\n@@ -1503,0 +1552,1 @@\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -1528,1 +1578,5 @@\n-    return _cache->_table->add_C_string(str);\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n+    AOTCodeAddressTable* table = addr_table();\n+    if (table != nullptr) {\n+      return table->add_C_string(str);\n+    }\n@@ -1535,2 +1589,0 @@\n-    LogStreamHandle(Trace, aot, codecache, stringtable) log; \/\/ ctor outside lock\n-    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n@@ -1553,3 +1605,1 @@\n-      if (log.is_enabled()) {\n-        log.print_cr(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n-      }\n+      log_trace(aot, codecache, stringtable)(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n@@ -1709,0 +1759,2 @@\n+\/\/ This is called after initialize() but before init2()\n+\/\/ and _cache is not set yet.\n@@ -1710,4 +1762,4 @@\n-  AOTCodeCache* cache = open_for_use();\n-  if (cache != nullptr) {\n-    uint count = cache->_load_header->entries_count();\n-    uint* search_entries = (uint*)cache->addr(cache->_load_header->entries_offset()); \/\/ [id, index]\n+  if (opened_cache != nullptr && opened_cache->for_use()) {\n+    st->print_cr(\"\\nAOT Code Cache\");\n+    uint count = opened_cache->_load_header->entries_count();\n+    uint* search_entries = (uint*)opened_cache->addr(opened_cache->_load_header->entries_offset()); \/\/ [id, index]\n@@ -1723,1 +1775,1 @@\n-      const char* saved_name = cache->addr(name_offset);\n+      const char* saved_name = opened_cache->addr(name_offset);\n@@ -1725,2 +1777,2 @@\n-      st->print_cr(\"%4u: entry_idx:%4u Kind:%u Id:%u size=%u '%s'\",\n-                   i, index, entry->kind(), entry->id(), entry->size(), saved_name);\n+      st->print_cr(\"%4u: %10s idx:%4u Id:%u size=%u '%s'\",\n+                   i, aot_code_entry_kind_name[entry->kind()], index, entry->id(), entry->size(), saved_name);\n@@ -1728,2 +1780,0 @@\n-  } else {\n-    st->print_cr(\"failed to map code cache\");\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":85,"deletions":35,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -628,0 +628,28 @@\n+bool ShenandoahBarrierC2Support::is_anti_dependent_load_at_control(PhaseIdealLoop* phase, Node* maybe_load, Node* store,\n+                                                                   Node* control) {\n+  return maybe_load->is_Load() && phase->C->can_alias(store->adr_type(), phase->C->get_alias_index(maybe_load->adr_type())) &&\n+         phase->ctrl_or_self(maybe_load) == control;\n+}\n+\n+void ShenandoahBarrierC2Support::maybe_push_anti_dependent_loads(PhaseIdealLoop* phase, Node* maybe_store, Node* control, Unique_Node_List &wq) {\n+  if (!maybe_store->is_Store() && !maybe_store->is_LoadStore()) {\n+    return;\n+  }\n+  Node* mem = maybe_store->in(MemNode::Memory);\n+  for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n+    Node* u = mem->fast_out(i);\n+    if (is_anti_dependent_load_at_control(phase, u, maybe_store, control)) {\n+      wq.push(u);\n+    }\n+  }\n+}\n+\n+void ShenandoahBarrierC2Support::push_data_inputs_at_control(PhaseIdealLoop* phase, Node* n, Node* ctrl, Unique_Node_List &wq) {\n+  for (uint i = 0; i < n->req(); i++) {\n+    Node* in = n->in(i);\n+    if (in != nullptr && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n+      wq.push(in);\n+    }\n+  }\n+}\n+\n@@ -642,16 +670,3 @@\n-      if (m->is_Store() || m->is_LoadStore()) {\n-        \/\/ Take anti-dependencies into account\n-        Node* mem = m->in(MemNode::Memory);\n-        for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n-          Node* u = mem->fast_out(i);\n-          if (u->is_Load() && phase->C->can_alias(m->adr_type(), phase->C->get_alias_index(u->adr_type())) &&\n-              phase->ctrl_or_self(u) == c) {\n-            wq.push(u);\n-          }\n-        }\n-      }\n-      for (uint i = 0; i < m->req(); i++) {\n-        if (m->in(i) != nullptr && phase->ctrl_or_self(m->in(i)) == c) {\n-          wq.push(m->in(i));\n-        }\n-      }\n+      \/\/ Take anti-dependencies into account\n+      maybe_push_anti_dependent_loads(phase, m, c, wq);\n+      push_data_inputs_at_control(phase, m, c, wq);\n@@ -1008,1 +1023,14 @@\n-void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& uses_to_ignore, uint last, PhaseIdealLoop* phase) {\n+void ShenandoahBarrierC2Support::collect_nodes_above_barrier(Unique_Node_List &nodes_above_barrier, PhaseIdealLoop* phase, Node* ctrl, Node* init_raw_mem) {\n+  nodes_above_barrier.clear();\n+  if (phase->has_ctrl(init_raw_mem) && phase->get_ctrl(init_raw_mem) == ctrl && !init_raw_mem->is_Phi()) {\n+    nodes_above_barrier.push(init_raw_mem);\n+  }\n+  for (uint next = 0; next < nodes_above_barrier.size(); next++) {\n+    Node* n = nodes_above_barrier.at(next);\n+    \/\/ Take anti-dependencies into account\n+    maybe_push_anti_dependent_loads(phase, n, ctrl, nodes_above_barrier);\n+    push_data_inputs_at_control(phase, n, ctrl, nodes_above_barrier);\n+  }\n+}\n+\n+void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& nodes_above_barrier, uint last, PhaseIdealLoop* phase) {\n@@ -1019,13 +1047,1 @@\n-  uses_to_ignore.clear();\n-  if (phase->has_ctrl(init_raw_mem) && phase->get_ctrl(init_raw_mem) == ctrl && !init_raw_mem->is_Phi()) {\n-    uses_to_ignore.push(init_raw_mem);\n-  }\n-  for (uint next = 0; next < uses_to_ignore.size(); next++) {\n-    Node *n = uses_to_ignore.at(next);\n-    for (uint i = 0; i < n->req(); i++) {\n-      Node* in = n->in(i);\n-      if (in != nullptr && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n-        uses_to_ignore.push(in);\n-      }\n-    }\n-  }\n+  collect_nodes_above_barrier(nodes_above_barrier, phase, ctrl, init_raw_mem);\n@@ -1037,1 +1053,1 @@\n-        !uses_to_ignore.member(u) &&\n+        !nodes_above_barrier.member(u) &&\n@@ -1041,2 +1057,1 @@\n-      Node* c = old_c;\n-      if (c != ctrl ||\n+      if (old_c != ctrl ||\n@@ -1316,1 +1331,1 @@\n-  Unique_Node_List uses_to_ignore;\n+  Unique_Node_List nodes_above_barriers;\n@@ -1411,1 +1426,1 @@\n-    fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);\n+    fix_ctrl(lrb, region, fixer, uses, nodes_above_barriers, last, phase);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":50,"deletions":35,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  LOG_TAG(vmatree) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n@@ -27,0 +29,1 @@\n+#include \"utilities\/packedTable.hpp\"\n@@ -40,2 +43,4 @@\n-                _field_flags.is_injected() ? lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8(),\n-                contended_group());\n+                _field_flags.is_generic() ? (_field_flags.is_injected() ?\n+                  lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8()\n+                  ) : \"\",\n+                is_contended() ? contended_group() : 0);\n@@ -65,0 +70,2 @@\n+  assert(fields->length() == java_fields + injected_fields, \"must be\");\n+\n@@ -71,1 +78,3 @@\n-  int storage_size = sizer.consumer()->position() + 1;\n+  \/\/ Originally there was an extra byte with 0 terminating the reading;\n+  \/\/ now we check limits instead.\n+  int storage_size = sizer.consumer()->position();\n@@ -82,2 +91,1 @@\n-    FieldInfo* fi = fields->adr_at(i);\n-    writer.map_field_info(*fi);\n+    writer.map_field_info(fields->at(i));\n@@ -88,1 +96,2 @@\n-  int jfc = r.next_uint();\n+  int jfc, ifc;\n+  r.read_field_counts(&jfc, &ifc);\n@@ -90,1 +99,0 @@\n-  int ifc = r.next_uint();\n@@ -122,0 +130,78 @@\n+int FieldInfoStream::compare_name_and_sig(const Symbol* n1, const Symbol* s1, const Symbol* n2, const Symbol* s2) {\n+  int cmp = n1->fast_compare(n2);\n+  return cmp != 0 ? cmp : s1->fast_compare(s2);\n+}\n+\n+\n+\/\/ We use both name and signature during the comparison; while JLS require unique\n+\/\/ names for fields, JVMS requires only unique name + signature combination.\n+struct field_pos {\n+  Symbol* _name;\n+  Symbol* _signature;\n+  int _index;\n+  int _position;\n+};\n+\n+class FieldInfoSupplier: public PackedTableBuilder::Supplier {\n+  const field_pos* _positions;\n+  size_t _elements;\n+\n+public:\n+  FieldInfoSupplier(const field_pos* positions, size_t elements): _positions(positions), _elements(elements) {}\n+\n+  bool next(uint32_t* key, uint32_t* value) override {\n+    if (_elements == 0) {\n+      return false;\n+    }\n+    *key = _positions->_position;\n+    *value = _positions->_index;\n+    ++_positions;\n+    --_elements;\n+    return true;\n+  }\n+};\n+\n+Array<u1>* FieldInfoStream::create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS) {\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    \/\/ We cannot use search table; in case of dynamic archives it should be sorted by \"requested\" addresses,\n+    \/\/ but Symbol* addresses are coming from _constants, which has \"buffered\" addresses.\n+    \/\/ For background, see new comments inside allocate_node_impl in symbolTable.cpp\n+    return nullptr;\n+  }\n+\n+  FieldInfoReader r(fis);\n+  int java_fields;\n+  int injected_fields;\n+  r.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields >= 0, \"must be\");\n+  if (java_fields == 0 || fis->length() == 0 || static_cast<uint>(java_fields) < BinarySearchThreshold) {\n+    return nullptr;\n+  }\n+\n+  ResourceMark rm;\n+  field_pos* positions = NEW_RESOURCE_ARRAY(field_pos, java_fields);\n+  for (int i = 0; i < java_fields; ++i) {\n+    assert(r.has_next(), \"number of fields must match\");\n+\n+    positions[i]._position = r.position();\n+    FieldInfo fi;\n+    r.read_field_info(fi);\n+\n+    positions[i]._name = fi.name(cp);\n+    positions[i]._signature = fi.signature(cp);\n+    positions[i]._index = i;\n+  }\n+  auto compare_pair = [](const void* v1, const void* v2) {\n+    const field_pos* p1 = reinterpret_cast<const field_pos*>(v1);\n+    const field_pos* p2 = reinterpret_cast<const field_pos*>(v2);\n+    return compare_name_and_sig(p1->_name, p1->_signature, p2->_name, p2->_signature);\n+  };\n+  qsort(positions, java_fields, sizeof(field_pos), compare_pair);\n+\n+  PackedTableBuilder builder(fis->length() - 1, java_fields - 1);\n+  Array<u1>* table = MetadataFactory::new_array<u1>(loader_data, java_fields * builder.element_bytes(), CHECK_NULL);\n+  FieldInfoSupplier supplier(positions, java_fields);\n+  builder.fill(table->data(), static_cast<size_t>(table->length()), supplier);\n+  return table;\n+}\n+\n@@ -123,4 +209,4 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n-  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n-  *java_fields_count = r.next_uint();\n-  *injected_fields_count = r.next_uint();\n+  r.read_field_counts(java_fields_count, injected_fields_count);\n+  int length = *java_fields_count + *injected_fields_count;\n+\n+  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -134,1 +220,0 @@\n-  assert(array->length() == *java_fields_count + *injected_fields_count, \"Must be\");\n@@ -139,3 +224,3 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n-  int java_field_count = r.next_uint();\n-  int injected_fields_count = r.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  r.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -149,0 +234,114 @@\n+\n+class FieldInfoComparator: public PackedTableLookup::Comparator {\n+  const FieldInfoReader* _reader;\n+  ConstantPool* _cp;\n+  const Symbol* _name;\n+  const Symbol* _signature;\n+\n+public:\n+  FieldInfoComparator(const FieldInfoReader* reader, ConstantPool* cp, const Symbol* name, const Symbol* signature):\n+    _reader(reader), _cp(cp), _name(name), _signature(signature) {}\n+\n+  int compare_to(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    r2.read_name_and_signature(&name_index, &sig_index);\n+    Symbol* mid_name = _cp->symbol_at(name_index);\n+    Symbol* mid_sig = _cp->symbol_at(sig_index);\n+\n+    return FieldInfoStream::compare_name_and_sig(_name, _signature, mid_name, mid_sig);\n+  }\n+\n+#ifdef ASSERT\n+  void reset(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, signature_index;\n+    r2.read_name_and_signature(&name_index, &signature_index);\n+    _name = _cp->symbol_at(name_index);\n+    _signature = _cp->symbol_at(signature_index);\n+  }\n+#endif \/\/ ASSERT\n+};\n+\n+#ifdef ASSERT\n+void FieldInfoStream::validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n+  if (search_table == nullptr) {\n+    return;\n+  }\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields > 0, \"must be\");\n+\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n+  assert(lookup.element_bytes() * java_fields == static_cast<unsigned int>(search_table->length()), \"size does not match\");\n+\n+  FieldInfoComparator comparator(&reader, cp, nullptr, nullptr);\n+  \/\/ Check 1: assert that elements have the correct order based on the comparison function\n+  lookup.validate_order(comparator);\n+\n+  \/\/ Check 2: Iterate through the original stream (not just search_table) and try if lookup works as expected\n+  reader.set_position_and_next_index(0, 0);\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  while (reader.has_next()) {\n+    int field_start = reader.position();\n+    FieldInfo fi;\n+    reader.read_field_info(fi);\n+    if (fi.field_flags().is_injected()) {\n+      \/\/ checking only java fields that precede injected ones\n+      break;\n+    }\n+\n+    FieldInfoReader r2(fis);\n+    int index = r2.search_table_lookup(search_table, fi.name(cp), fi.signature(cp), cp, java_fields);\n+    assert(index == static_cast<int>(fi.index()), \"wrong index: %d != %u\", index, fi.index());\n+    assert(index == r2.next_index(), \"index should match\");\n+    assert(field_start == r2.position(), \"must find the same position\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+void FieldInfoStream::print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n+  if (search_table == nullptr) {\n+    return;\n+  }\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields > 0, \"must be\");\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n+  auto printer = [&] (size_t offset, uint32_t position, uint32_t index) {\n+    reader.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    reader.read_name_and_signature(&name_index, &sig_index);\n+    Symbol* name = cp->symbol_at(name_index);\n+    Symbol* sig = cp->symbol_at(sig_index);\n+    st->print(\"   [%zu] #%d,#%d = \", offset, name_index, sig_index);\n+    name->print_symbol_on(st);\n+    st->print(\":\");\n+    sig->print_symbol_on(st);\n+    st->print(\" @ %p,%p\", name, sig);\n+    st->cr();\n+  };\n+\n+  lookup.iterate(printer);\n+}\n+\n+int FieldInfoReader::search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields) {\n+  assert(java_fields >= 0, \"must be\");\n+  if (java_fields == 0) {\n+    return -1;\n+  }\n+  FieldInfoComparator comp(this, cp, name, signature);\n+  PackedTableLookup lookup(_r.limit() - 1, java_fields - 1, search_table);\n+  uint32_t position;\n+  static_assert(sizeof(uint32_t) == sizeof(_next_index), \"field size assert\");\n+  if (lookup.search(comp, &position, reinterpret_cast<uint32_t*>(&_next_index))) {\n+    _r.set_position(static_cast<int>(position));\n+    return _next_index;\n+  } else {\n+    return -1;\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":214,"deletions":15,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -253,1 +253,0 @@\n-\n@@ -256,5 +255,0 @@\n-  friend class FieldInfoStream;\n-  friend class ClassFileParser;\n-  friend class FieldStreamBase;\n-  friend class FieldInfo;\n-\n@@ -264,1 +258,1 @@\n-  public:\n+public:\n@@ -267,2 +261,2 @@\n-  private:\n-  uint32_t next_uint() { return _r.next_uint(); }\n+private:\n+  inline uint32_t next_uint() { return _r.next_uint(); }\n@@ -272,3 +266,5 @@\n-  int has_next() { return _r.has_next(); }\n-  int position() { return _r.position(); }\n-  int next_index() { return _next_index; }\n+  void read_field_counts(int* java_fields, int* injected_fields);\n+  int has_next() const { return _r.position() < _r.limit(); }\n+  int position() const { return _r.position(); }\n+  int next_index() const { return _next_index; }\n+  void read_name_and_signature(u2* name_index, u2* signature_index);\n@@ -276,0 +272,3 @@\n+\n+  int search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields);\n+\n@@ -302,0 +301,5 @@\n+  friend class FieldInfoReader;\n+  friend class FieldInfoComparator;\n+\n+ private:\n+  static int compare_name_and_sig(const Symbol* n1, const Symbol* s1, const Symbol* n2, const Symbol* s2);\n@@ -309,1 +313,2 @@\n-                                                          ClassLoaderData* loader_data, TRAPS);\n+                                           ClassLoaderData* loader_data, TRAPS);\n+  static Array<u1>* create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS);\n@@ -312,0 +317,4 @@\n+\n+  DEBUG_ONLY(static void validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);)\n+\n+  static void print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -60,2 +60,4 @@\n-  fir.skip(1);\n-  return fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return injected_fields_count;\n@@ -66,1 +68,4 @@\n-  return fir.next_uint() + fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count + injected_fields_count;\n@@ -69,1 +74,7 @@\n-inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) { return FieldInfoReader(fis).next_uint(); }\n+inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count;\n+}\n@@ -106,1 +117,1 @@\n-  : _r(fi->data(), 0),\n+  : _r(fi->data(), fi->length()),\n@@ -109,0 +120,10 @@\n+inline void FieldInfoReader::read_field_counts(int* java_fields, int* injected_fields) {\n+  *java_fields = next_uint();\n+  *injected_fields = next_uint();\n+}\n+\n+inline void FieldInfoReader::read_name_and_signature(u2* name_index, u2* signature_index) {\n+  *name_index = checked_cast<u2>(next_uint());\n+  *signature_index = checked_cast<u2>(next_uint());\n+}\n+\n@@ -111,2 +132,1 @@\n-  fi._name_index = checked_cast<u2>(next_uint());\n-  fi._signature_index = checked_cast<u2>(next_uint());\n+  read_name_and_signature(&fi._name_index, &fi._signature_index);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -62,1 +62,1 @@\n-  private:\n+ private:\n@@ -64,3 +64,8 @@\n-    int java_fields_count = _reader.next_uint();\n-    int injected_fields_count = _reader.next_uint();\n-    assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    int java_fields_count;\n+    int injected_fields_count;\n+    _reader.read_field_counts(&java_fields_count, &injected_fields_count);\n+    if (_limit < _index) {\n+      _limit = java_fields_count + injected_fields_count;\n+    } else {\n+      assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    }\n@@ -71,0 +76,1 @@\n+\n@@ -154,0 +160,2 @@\n+  Array<u1>* _search_table;\n+\n@@ -155,1 +163,2 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()),\n+    _search_table(k->fieldinfo_search_table()) {}\n@@ -165,1 +174,0 @@\n-    return -1;\n@@ -180,0 +188,4 @@\n+\n+  \/\/ Performs either a linear search or binary search through the stream\n+  \/\/ looking for a matching name\/signature combo\n+  bool lookup(const Symbol* name, const Symbol* signature);\n@@ -192,1 +204,0 @@\n-  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -749,0 +749,5 @@\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+    MetadataFactory::free_array<u1>(loader_data, fieldinfo_search_table());\n+  }\n+  set_fieldinfo_search_table(nullptr);\n+\n@@ -2072,7 +2077,6 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n-    Symbol* f_name = fs.name();\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n-      return true;\n-    }\n+  JavaFieldStream fs(this);\n+  if (fs.lookup(name, sig)) {\n+    assert(fs.name() == name, \"name must match\");\n+    assert(fs.signature() == sig, \"signature must match\");\n+    fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n+    return true;\n@@ -2908,0 +2912,1 @@\n+  it->push(&_fieldinfo_search_table);\n@@ -3010,0 +3015,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -3126,0 +3133,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -4119,0 +4128,5 @@\n+\n+  if (fieldinfo_search_table() != nullptr) {\n+    st->print_cr(BULLET\"---- field info search table:\");\n+    FieldInfoStream::print_search_table(st, _constants, _fieldinfo_stream, _fieldinfo_search_table);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+  Array<u1>*          _fieldinfo_search_table;\n@@ -488,0 +489,3 @@\n+  Array<u1>* fieldinfo_search_table() const { return _fieldinfo_search_table; }\n+  void set_fieldinfo_search_table(Array<u1>* table) { _fieldinfo_search_table = table; }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"opto\/c2_globals_pd.hpp\"\n@@ -31,0 +30,1 @@\n+#include CPU_HEADER(c2_globals)\n@@ -681,4 +681,6 @@\n-          \"Verify Iterative Global Value Numbering\"                         \\\n-          \"=XY, with Y: verify Def-Use modifications during IGVN\"           \\\n-          \"          X: verify that type(n) == n->Value() after IGVN\"       \\\n-          \"X and Y in 0=off; 1=on\")                                         \\\n+          \"Verify Iterative Global Value Numbering =DCBA, with:\"            \\\n+          \"  D: verify Node::Identity did not miss opportunities\"           \\\n+          \"  C: verify Node::Ideal did not miss opportunities\"              \\\n+          \"  B: verify that type(n) == n->Value() after IGVN\"               \\\n+          \"  A: verify Def-Use modifications during IGVN\"                   \\\n+          \"Each can be 0=off or 1=on\")                                      \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -555,1 +555,5 @@\n-  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  const TypeInteger* this_type = this->type()->isa_integer(bt);\n+  if (this_type == nullptr) {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5047,1 +5047,3 @@\n-  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr && sizetype->_hi > 0) {\n+    index_max = sizetype->_hi - 1;\n+  }\n@@ -5075,1 +5077,1 @@\n-    log()->head(\"late_inline method='%d'  inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n+    log()->head(\"late_inline method='%d' inline_id='\" JLONG_FORMAT \"'\", log()->identify(cg->method()),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -957,2 +957,2 @@\n-  inline Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n-                                       int idx, bool can_grow = false);\n+  Node_Notes* locate_node_notes(GrowableArray<Node_Notes*>* arr,\n+                                int idx, bool can_grow = false);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4405,1 +4405,3 @@\n-      if (size_max > tilen->_hi)  size_max = tilen->_hi;\n+      if (size_max > tilen->_hi && tilen->_hi >= 0) {\n+        size_max = tilen->_hi;\n+      }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1049,2 +1049,1 @@\n-        failtype = failtype->join(type2)->is_int();\n-        if (failtype->empty()) {\n+        if (failtype->filter(type2) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7258,0 +7258,4 @@\n+  record_for_igvn(exit_block);\n+  record_for_igvn(memory_phi);\n+  record_for_igvn(result_phi);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,7 +68,2 @@\n-      ++_inode_top;\n-      if ((_inode_top + 1) >= _inode_max) grow();\n-      _inode_top->node = parent;\n-      _inode_top->indx = (uint)indx;\n-      ++_inode_top;\n-      _inode_top->node = n;\n-      _inode_top->indx = (uint)ns;\n+      Node_Stack::push(parent, (uint)indx);\n+      Node_Stack::push(n, (uint)ns);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2808,1 +2808,0 @@\n-  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n@@ -3048,4 +3047,0 @@\n-  _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n-  if (_inode_top < _inode_max) {\n-    return; \/\/ No need to grow\n-  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1650,0 +1650,1 @@\n+    _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n@@ -1901,0 +1902,7 @@\n+\n+  void maybe_grow() {\n+    _nesting.check(_a); \/\/ Check if a potential reallocation in the arena is safe\n+    if (_inode_top >= _inode_max) {\n+      grow();\n+    }\n+  }\n@@ -1902,0 +1910,1 @@\n+\n@@ -1924,1 +1933,1 @@\n-    grow();\n+    maybe_grow();\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1075,1 +1075,5 @@\n-  if (is_verify_Value()) {\n+  assert(_worklist.size() == 0, \"igvn worklist must be empty before verify\");\n+\n+  if (is_verify_Value() ||\n+      is_verify_Ideal() ||\n+      is_verify_Identity()) {\n@@ -1083,1 +1087,4 @@\n-      failure |= verify_node_value(n);\n+      if (is_verify_Value())    { failure |= verify_Value_for(n); }\n+      if (is_verify_Ideal())    { failure |= verify_Ideal_for(n, false); }\n+      if (is_verify_Ideal())    { failure |= verify_Ideal_for(n, true); }\n+      if (is_verify_Identity()) { failure |= verify_Identity_for(n); }\n@@ -1100,0 +1107,21 @@\n+\n+  verify_empty_worklist(nullptr);\n+}\n+\n+void PhaseIterGVN::verify_empty_worklist(Node* node) {\n+  \/\/ Verify that the igvn worklist is empty. If no optimization happened, then\n+  \/\/ nothing needs to be on the worklist.\n+  if (_worklist.size() == 0) { return; }\n+\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  for (uint j = 0; j < _worklist.size(); j++) {\n+    Node* n = _worklist.at(j);\n+    ss.print(\"igvn.worklist[%d] \", j);\n+    n->dump(\"\\n\", false, &ss);\n+  }\n+  if (_worklist.size() != 0 && node != nullptr) {\n+    ss.print_cr(\"Previously optimized:\");\n+    node->dump(\"\\n\", false, &ss);\n+  }\n+  tty->print_cr(\"%s\", ss.as_string());\n+  assert(false, \"igvn worklist must still be empty after verify\");\n@@ -1107,1 +1135,1 @@\n-bool PhaseIterGVN::verify_node_value(Node* n) {\n+bool PhaseIterGVN::verify_Value_for(Node* n) {\n@@ -1152,9 +1180,867 @@\n-  tty->cr();\n-  tty->print_cr(\"Missed Value optimization:\");\n-  n->dump_bfs(3, nullptr, \"\");\n-  tty->print_cr(\"Current type:\");\n-  told->dump_on(tty);\n-  tty->cr();\n-  tty->print_cr(\"Optimized type:\");\n-  tnew->dump_on(tty);\n-  tty->cr();\n+\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Value optimization:\");\n+  n->dump_bfs(3, nullptr, \"\", &ss);\n+  ss.print_cr(\"Current type:\");\n+  told->dump_on(&ss);\n+  ss.cr();\n+  ss.print_cr(\"Optimized type:\");\n+  tnew->dump_on(&ss);\n+  ss.cr();\n+  tty->print_cr(\"%s\", ss.as_string());\n+  return true;\n+}\n+\n+\/\/ Check that all Ideal optimizations that could be done were done.\n+\/\/ Returns true if it found missed optimization opportunities and\n+\/\/         false otherwise (no missed optimization, or skipped verification).\n+bool PhaseIterGVN::verify_Ideal_for(Node* n, bool can_reshape) {\n+  \/\/ First, we check a list of exceptions, where we skip verification,\n+  \/\/ because there are known cases where Ideal can optimize after IGVN.\n+  \/\/ Some may be expected and cannot be fixed, and others should be fixed.\n+  switch (n->Opcode()) {\n+    \/\/ RangeCheckNode::Ideal looks up the chain for about 999 nodes\n+    \/\/ (see \"Range-Check scan limit\"). So, it is possible that something\n+    \/\/ is optimized in that input subgraph, and the RangeCheck was not\n+    \/\/ added to the worklist because it would be too expensive to walk\n+    \/\/ down the graph for 1000 nodes and put all on the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    case Op_RangeCheck:\n+      return false;\n+\n+    \/\/ IfNode::Ideal does:\n+    \/\/   Node* prev_dom = search_identical(dist, igvn);\n+    \/\/ which means we seach up the CFG, traversing at most up to a distance.\n+    \/\/ If anything happens rather far away from the If, we may not put the If\n+    \/\/ back on the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_If:\n+      return false;\n+\n+    \/\/ IfNode::simple_subsuming\n+    \/\/ Looks for dominating test that subsumes the current test.\n+    \/\/ Notification could be difficult because of larger distance.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   runtime\/exceptionMsgs\/ArrayIndexOutOfBoundsException\/ArrayIndexOutOfBoundsExceptionTest.java#id1\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CountedLoopEnd:\n+      return false;\n+\n+    \/\/ LongCountedLoopEndNode::Ideal\n+    \/\/ Probably same issue as above.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/predicates\/assertion\/TestAssertionPredicates.java#NoLoopPredicationXbatch\n+    \/\/   -XX:StressLongCountedLoop=2000000 -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LongCountedLoopEnd:\n+      return false;\n+\n+    \/\/ RegionNode::Ideal does \"Skip around the useless IF diamond\".\n+    \/\/   245  IfTrue  === 244\n+    \/\/   258  If  === 245 257\n+    \/\/   259  IfTrue  === 258  [[ 263 ]]\n+    \/\/   260  IfFalse  === 258  [[ 263 ]]\n+    \/\/   263  Region  === 263 260 259  [[ 263 268 ]]\n+    \/\/ to\n+    \/\/   245  IfTrue  === 244\n+    \/\/   263  Region  === 263 245 _  [[ 263 268 ]]\n+    \/\/\n+    \/\/ \"Useless\" means that there is no code in either branch of the If.\n+    \/\/ I found a case where this was not done yet during IGVN.\n+    \/\/ Why does the Region not get added to IGVN worklist when the If diamond becomes useless?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_Region:\n+      return false;\n+\n+    \/\/ In AddNode::Ideal, we call \"commute\", which swaps the inputs so\n+    \/\/ that smaller idx are first. Tracking it back, it led me to\n+    \/\/ PhaseIdealLoop::remix_address_expressions which swapped the edges.\n+    \/\/\n+    \/\/ Example:\n+    \/\/   Before PhaseIdealLoop::remix_address_expressions\n+    \/\/     154  AddI  === _ 12 144\n+    \/\/   After PhaseIdealLoop::remix_address_expressions\n+    \/\/     154  AddI  === _ 144 12\n+    \/\/   After AddNode::Ideal\n+    \/\/     154  AddI  === _ 12 144\n+    \/\/\n+    \/\/ I suspect that the node should be added to the IGVN worklist after\n+    \/\/ PhaseIdealLoop::remix_address_expressions\n+    \/\/\n+    \/\/ This is the only case I looked at, there may be others. Found like this:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    \/\/\n+    \/\/ The following hit the same logic in PhaseIdealLoop::remix_address_expressions.\n+    \/\/\n+    \/\/ Note: currently all of these fail also for other reasons, for example\n+    \/\/ because of \"commute\" doing the reordering with the phi below. Once\n+    \/\/ that is resolved, we can come back to this issue here.\n+    \/\/\n+    \/\/ case Op_AddD:\n+    \/\/ case Op_AddI:\n+    \/\/ case Op_AddL:\n+    \/\/ case Op_AddF:\n+    \/\/ case Op_MulI:\n+    \/\/ case Op_MulL:\n+    \/\/ case Op_MulF:\n+    \/\/ case Op_MulD:\n+    \/\/   if (n->in(1)->_idx > n->in(2)->_idx) {\n+    \/\/     \/\/ Expect \"commute\" to revert this case.\n+    \/\/     return false;\n+    \/\/   }\n+    \/\/   break; \/\/ keep verifying\n+\n+    \/\/ AddFNode::Ideal calls \"commute\", which can reorder the inputs for this:\n+    \/\/   Check for tight loop increments: Loop-phi of Add of loop-phi\n+    \/\/ It wants to take the phi into in(1):\n+    \/\/    471  Phi  === 435 38 390\n+    \/\/    390  AddF  === _ 471 391\n+    \/\/\n+    \/\/ Other Associative operators are also affected equally.\n+    \/\/\n+    \/\/ Investigate why this does not happen earlier during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddD:\n+    \/\/case Op_AddI: \/\/ Also affected for other reasons, see case further down.\n+    \/\/case Op_AddL: \/\/ Also affected for other reasons, see case further down.\n+    case Op_AddF:\n+    case Op_MulI:\n+    case Op_MulL:\n+    case Op_MulF:\n+    case Op_MulD:\n+    case Op_MinF:\n+    case Op_MinD:\n+    case Op_MaxF:\n+    case Op_MaxD:\n+    \/\/ XorINode::Ideal\n+    \/\/ Found with:\n+    \/\/   compiler\/intrinsics\/chacha\/TestChaCha20.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_XorI:\n+    case Op_XorL:\n+    \/\/ It seems we may have similar issues with the HF cases.\n+    \/\/ Found with aarch64:\n+    \/\/   compiler\/vectorization\/TestFloat16VectorOperations.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddHF:\n+    case Op_MulHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      return false;\n+\n+    \/\/ In MulNode::Ideal the edges can be swapped to help value numbering:\n+    \/\/\n+    \/\/    \/\/ We are OK if right is a constant, or right is a load and\n+    \/\/    \/\/ left is a non-constant.\n+    \/\/    if( !(t2->singleton() ||\n+    \/\/          (in(2)->is_Load() && !(t1->singleton() || in(1)->is_Load())) ) ) {\n+    \/\/      if( t1->singleton() ||       \/\/ Left input is a constant?\n+    \/\/          \/\/ Otherwise, sort inputs (commutativity) to help value numbering.\n+    \/\/          (in(1)->_idx > in(2)->_idx) ) {\n+    \/\/        swap_edges(1, 2);\n+    \/\/\n+    \/\/ Why was this not done earlier during IGVN?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/    test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithG1.java\n+    \/\/    -XX:VerifyIterativeGVN=1110\n+    case Op_AndI:\n+    \/\/ Same for AndL.\n+    \/\/ Found with:\n+    \/\/   compiler\/intrinsics\/bigInteger\/MontgomeryMultiplyTest.java\n+    \/\/    -XX:VerifyIterativeGVN=1110\n+    case Op_AndL:\n+      return false;\n+\n+    \/\/ SubLNode::Ideal does transform like:\n+    \/\/   Convert \"c1 - (y+c0)\" into \"(c1-c0) - y\"\n+    \/\/\n+    \/\/ In IGVN before verification:\n+    \/\/   8423  ConvI2L  === _ 3519  [[ 8424 ]]  #long:-2\n+    \/\/   8422  ConvI2L  === _ 8399  [[ 8424 ]]  #long:3..256:www\n+    \/\/   8424  AddL  === _ 8422 8423  [[ 8383 ]]  !orig=[8382]\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8016 8424  [[ 8156 ]]  !orig=[8154]\n+    \/\/\n+    \/\/ And then in verification:\n+    \/\/   8338  ConL  === 0  [[ 8339 8424 ]]  #long:-2     <----- Was constant folded.\n+    \/\/   8422  ConvI2L  === _ 8399  [[ 8424 ]]  #long:3..256:www\n+    \/\/   8424  AddL  === _ 8422 8338  [[ 8383 ]]  !orig=[8382]\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8016 8424  [[ 8156 ]]  !orig=[8154]\n+    \/\/\n+    \/\/ So the form changed from:\n+    \/\/   c1 - (y + [8423  ConvI2L])\n+    \/\/ to\n+    \/\/   c1 - (y + -2)\n+    \/\/ but the SubL was not added to the IGVN worklist. Investigate why.\n+    \/\/ There could be other issues too.\n+    \/\/\n+    \/\/ There seems to be a related AddL IGVN optimization that triggers\n+    \/\/ the same SubL optimization, so investigate that too.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_SubL:\n+      return false;\n+\n+    \/\/ SubINode::Ideal does\n+    \/\/ Convert \"x - (y+c0)\" into \"(x-y) - c0\" AND\n+    \/\/ Convert \"c1 - (y+c0)\" into \"(c1-c0) - y\"\n+    \/\/\n+    \/\/ Investigate why this does not yet happen during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/c2\/IVTest.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_SubI:\n+      return false;\n+\n+    \/\/ AddNode::IdealIL does transform like:\n+    \/\/   Convert x + (con - y) into \"(x - y) + con\"\n+    \/\/\n+    \/\/ In IGVN before verification:\n+    \/\/   8382  ConvI2L\n+    \/\/   8381  ConvI2L  === _ 791  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8381 8382\n+    \/\/   8168  ConvI2L\n+    \/\/   8156  AddL  === _ 8168 8383  [[ 8158 ]]\n+    \/\/\n+    \/\/ And then in verification:\n+    \/\/   8424  AddL\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0  <--- Was constant folded.\n+    \/\/   8383  SubL  === _ 8016 8424\n+    \/\/   8168  ConvI2L\n+    \/\/   8156  AddL  === _ 8168 8383  [[ 8158 ]]\n+    \/\/\n+    \/\/ So the form changed from:\n+    \/\/   x + (ConvI2L(0) - [8382  ConvI2L])\n+    \/\/ to\n+    \/\/   x + (0 - [8424  AddL])\n+    \/\/ but the AddL was not added to the IGVN worklist. Investigate why.\n+    \/\/ There could be other issues, too. For example with \"commute\", see above.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_AddL:\n+      return false;\n+\n+    \/\/ SubTypeCheckNode::Ideal calls SubTypeCheckNode::verify_helper, which does\n+    \/\/   Node* cmp = phase->transform(new CmpPNode(subklass, in(SuperKlass)));\n+    \/\/   record_for_cleanup(cmp, phase);\n+    \/\/ This verification code in the Ideal code creates new nodes, and checks\n+    \/\/ if they fold in unexpected ways. This means some nodes are created and\n+    \/\/ added to the worklist, even if the SubTypeCheck is not optimized. This\n+    \/\/ goes agains the assumption of the verification here, which assumes that\n+    \/\/ if the node is not optimized, then no new nodes should be created, and\n+    \/\/ also no nodes should be added to the worklist.\n+    \/\/ I see two options:\n+    \/\/  1) forbid what verify_helper does, because for each Ideal call it\n+    \/\/     uses memory and that is suboptimal. But it is not clear how that\n+    \/\/     verification can be done otherwise.\n+    \/\/  2) Special case the verification here. Probably the new nodes that\n+    \/\/     were just created are dead, i.e. they are not connected down to\n+    \/\/     root. We could verify that, and remove those nodes from the graph\n+    \/\/     by setting all their inputs to nullptr. And of course we would\n+    \/\/     have to remove those nodes from the worklist.\n+    \/\/ Maybe there are other options too, I did not dig much deeper yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    case Op_SubTypeCheck:\n+      return false;\n+\n+    \/\/ LoopLimitNode::Ideal when stride is constant power-of-2, we can do a lowering\n+    \/\/ to other nodes: Conv, Add, Sub, Mul, And ...\n+    \/\/\n+    \/\/  107  ConI  === 0  [[ ... ]]  #int:2\n+    \/\/   84  LoadRange  === _ 7 83\n+    \/\/   50  ConI  === 0  [[ ... ]]  #int:0\n+    \/\/  549  LoopLimit  === _ 50 84 107\n+    \/\/\n+    \/\/ I stepped backward, to see how the node was generated, and I found that it was\n+    \/\/ created in PhaseIdealLoop::exact_limit and not changed since. It is added to the\n+    \/\/ IGVN worklist. I quickly checked when it goes into LoopLimitNode::Ideal after\n+    \/\/ that, and it seems we want to skip lowering it until after loop-opts, but never\n+    \/\/ add call record_for_post_loop_opts_igvn. This would be an easy fix, but there\n+    \/\/ could be other issues too.\n+    \/\/\n+    \/\/ Fond with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_LoopLimit:\n+      return false;\n+\n+    \/\/ PhiNode::Ideal calls split_flow_path, which tries to do this:\n+    \/\/ \"This optimization tries to find two or more inputs of phi with the same constant\n+    \/\/ value. It then splits them into a separate Phi, and according Region.\"\n+    \/\/\n+    \/\/ Example:\n+    \/\/   130  DecodeN  === _ 129\n+    \/\/    50  ConP  === 0  [[ 18 91 99 18 ]]  #null\n+    \/\/    18  Phi  === 14 50 130 50  [[ 133 ]]  #java\/lang\/Object *  Oop:java\/lang\/Object *\n+    \/\/\n+    \/\/  turns into:\n+    \/\/\n+    \/\/    50  ConP  === 0  [[ 99 91 18 ]]  #null\n+    \/\/   130  DecodeN  === _ 129  [[ 18 ]]\n+    \/\/    18  Phi  === 14 130 50  [[ 133 ]]  #java\/lang\/Object *  Oop:java\/lang\/Object *\n+    \/\/\n+    \/\/ We would have to investigate why this optimization does not happen during IGVN.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_Phi:\n+      return false;\n+\n+    \/\/ MemBarNode::Ideal does \"Eliminate volatile MemBars for scalar replaced objects\".\n+    \/\/ For examle \"The allocated object does not escape\".\n+    \/\/\n+    \/\/ It seems the difference to earlier calls to MemBarNode::Ideal, is that there\n+    \/\/ alloc->as_Allocate()->does_not_escape_thread() returned false, but in verification\n+    \/\/ it returned true. Why does the MemBarStoreStore not get added to the IGVN\n+    \/\/ worklist when this change happens?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_MemBarStoreStore:\n+      return false;\n+\n+    \/\/ ConvI2LNode::Ideal converts\n+    \/\/   648  AddI  === _ 583 645  [[ 661 ]]\n+    \/\/   661  ConvI2L  === _ 648  [[ 664 ]]  #long:0..maxint-1:www\n+    \/\/ into\n+    \/\/   772  ConvI2L  === _ 645  [[ 773 ]]  #long:-120..maxint-61:www\n+    \/\/   771  ConvI2L  === _ 583  [[ 773 ]]  #long:60..120:www\n+    \/\/   773  AddL  === _ 771 772  [[ ]]\n+    \/\/\n+    \/\/ We have to investigate why this does not happen during IGVN in this case.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_ConvI2L:\n+      return false;\n+\n+    \/\/ AddNode::IdealIL can do this transform (and similar other ones):\n+    \/\/   Convert \"a*b+a*c into a*(b+c)\n+    \/\/ The example had AddI(MulI(a, b), MulI(a, c)). Why did this not happen\n+    \/\/ during IGVN? There was a mutation for one of the MulI, and only\n+    \/\/ after that the pattern was as needed for the optimization. The MulI\n+    \/\/ was added to the IGVN worklist, but not the AddI. This probably\n+    \/\/ can be fixed by adding the correct pattern in add_users_of_use_to_worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddI:\n+      return false;\n+\n+    \/\/ ArrayCopyNode::Ideal\n+    \/\/    calls ArrayCopyNode::prepare_array_copy\n+    \/\/    calls Compile::conv_I2X_index        -> is called with sizetype = intcon(0), I think that\n+    \/\/                                            is not expected, and we create a range int:0..-1\n+    \/\/    calls Compile::constrained_convI2L   -> creates ConvI2L(intcon(1), int:0..-1)\n+    \/\/                                            note: the type is already empty!\n+    \/\/    calls PhaseIterGVN::transform\n+    \/\/    calls PhaseIterGVN::transform_old\n+    \/\/    calls PhaseIterGVN::subsume_node     -> subsume ConvI2L with TOP\n+    \/\/    calls Unique_Node_List::push         -> pushes TOP to worklist\n+    \/\/\n+    \/\/ Once we get back to ArrayCopyNode::prepare_array_copy, we get back TOP, and\n+    \/\/ return false. This means we eventually return nullptr from ArrayCopyNode::Ideal.\n+    \/\/\n+    \/\/ Question: is it ok to push anything to the worklist during ::Ideal, if we will\n+    \/\/           return nullptr, indicating nothing happened?\n+    \/\/           Is it smart to do transform in Compile::constrained_convI2L, and then\n+    \/\/           check for TOP in calls ArrayCopyNode::prepare_array_copy?\n+    \/\/           Should we just allow TOP to land on the worklist, as an exception?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/arraycopy\/TestArrayCopyAsLoadsStores.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_ArrayCopy:\n+      return false;\n+\n+    \/\/ CastLLNode::Ideal\n+    \/\/    calls ConstraintCastNode::optimize_integer_cast -> pushes CastLL through SubL\n+    \/\/\n+    \/\/ Could be a notification issue, where updates inputs of CastLL do not notify\n+    \/\/ down through SubL to CastLL.\n+    \/\/\n+    \/\/ Found With:\n+    \/\/   compiler\/c2\/TestMergeStoresMemorySegment.java#byte-array\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CastLL:\n+      return false;\n+\n+    \/\/ Similar case happens to CastII\n+    \/\/\n+    \/\/ Found With:\n+    \/\/   compiler\/c2\/TestScalarReplacementMaxLiveNodes.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CastII:\n+      return false;\n+\n+    \/\/ MaxLNode::Ideal\n+    \/\/   calls AddNode::Ideal\n+    \/\/   calls commute -> decides to swap edges\n+    \/\/\n+    \/\/ Another notification issue, because we check inputs of inputs?\n+    \/\/ MaxL -> Phi -> Loop\n+    \/\/ MaxL -> Phi -> MaxL\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestIfMinMax.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_MaxL:\n+    case Op_MinL:\n+      return false;\n+\n+    \/\/ OrINode::Ideal\n+    \/\/   calls AddNode::Ideal\n+    \/\/   calls commute -> left is Load, right not -> commute.\n+    \/\/\n+    \/\/ Not sure why notification does not work here, seems like\n+    \/\/ the depth is only 1, so it should work. Needs investigation.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/codegen\/TestCharVect2.java#id0\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_OrI:\n+    case Op_OrL:\n+      return false;\n+\n+    \/\/ Bool -> constant folded to 1.\n+    \/\/ Issue with notification?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_Bool:\n+      return false;\n+\n+    \/\/ LShiftLNode::Ideal\n+    \/\/ Looks at pattern: \"(x + x) << c0\", converts it to \"x << (c0 + 1)\"\n+    \/\/ Probably a notification issue.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/conversions\/TestMoveConvI2LOrCastIIThruAddIs.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LShiftL:\n+      return false;\n+\n+    \/\/ LShiftINode::Ideal\n+    \/\/ pattern: ((x + con1) << con2) -> x << con2 + con1 << con2\n+    \/\/ Could be issue with notification of inputs of inputs\n+    \/\/\n+    \/\/ Side-note: should cases like these not be shared between\n+    \/\/            LShiftI and LShiftL?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/escapeAnalysis\/Test6689060.java\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110 -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LShiftI:\n+      return false;\n+\n+    \/\/ AddPNode::Ideal seems to do set_req without removing lock first.\n+    \/\/ Found with various vector tests tier1-tier3.\n+    case Op_AddP:\n+      return false;\n+\n+    \/\/ StrIndexOfNode::Ideal\n+    \/\/ Found in tier1-3.\n+    case Op_StrIndexOf:\n+    case Op_StrIndexOfChar:\n+      return false;\n+\n+    \/\/ StrEqualsNode::Identity\n+    \/\/\n+    \/\/ Found (linux x64 only?) with:\n+    \/\/   serviceability\/sa\/ClhsdbThreadContext.java\n+    \/\/   -XX:+UnlockExperimentalVMOptions -XX:LockingMode=1 -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_StrEquals:\n+      return false;\n+\n+    \/\/ AryEqNode::Ideal\n+    \/\/ Not investigated. Reshapes itself and adds lots of nodes to the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java\n+    \/\/   -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -XX:+StressUnstableIfTraps -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_AryEq:\n+      return false;\n+\n+    \/\/ MergeMemNode::Ideal\n+    \/\/ Found in tier1-3. Did not investigate further yet.\n+    case Op_MergeMem:\n+      return false;\n+\n+    \/\/ URShiftINode::Ideal\n+    \/\/ Found in tier1-3. Did not investigate further yet.\n+    case Op_URShiftI:\n+      return false;\n+\n+    \/\/ CMoveINode::Ideal\n+    \/\/ Found in tier1-3. Did not investigate further yet.\n+    case Op_CMoveI:\n+      return false;\n+\n+    \/\/ CmpPNode::Ideal calls isa_const_java_mirror\n+    \/\/ and generates new constant nodes, even if no progress is made.\n+    \/\/ We can probably rewrite this so that only types are generated.\n+    \/\/ It seems that object types are not hashed, we could investigate\n+    \/\/ if that is an option as well.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1110 -Xcomp --version\n+    case Op_CmpP:\n+      return false;\n+\n+    \/\/ MinINode::Ideal\n+    \/\/ Did not investigate, but there are some patterns that might\n+    \/\/ need more notification.\n+    case Op_MinI:\n+    case Op_MaxI: \/\/ preemptively removed it as well.\n+      return false;\n+  }\n+\n+  if (n->is_Load()) {\n+    \/\/ LoadNode::Ideal uses tries to find an earlier memory state, and\n+    \/\/ checks can_see_stored_value for it.\n+    \/\/\n+    \/\/ Investigate why this was not already done during IGVN.\n+    \/\/ A similar issue happens with Identity.\n+    \/\/\n+    \/\/ There seem to be other cases where loads go up some steps, like\n+    \/\/ LoadNode::Ideal going up 10x steps to find dominating load.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccess.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_Store()) {\n+    \/\/ StoreNode::Ideal can do this:\n+    \/\/  \/\/ Capture an unaliased, unconditional, simple store into an initializer.\n+    \/\/  \/\/ Or, if it is independent of the allocation, hoist it above the allocation.\n+    \/\/ That replaces the Store with a MergeMem.\n+    \/\/\n+    \/\/ We have to investigate why this does not happen during IGVN in this case.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    return false;\n+  }\n+\n+  if (n->is_Vector()) {\n+    \/\/ VectorNode::Ideal swaps edges, but only for ops\n+    \/\/ that are deemed commutable. But swap_edges\n+    \/\/ requires the hash to be invariant when the edges\n+    \/\/ are swapped, which is not implemented for these\n+    \/\/ vector nodes. This seems not to create any trouble\n+    \/\/ usually, but we can also get graphs where in the\n+    \/\/ end the nodes are not all commuted, so there is\n+    \/\/ definitively an issue here.\n+    \/\/\n+    \/\/ Probably we have two options: kill the hash, or\n+    \/\/ properly make the hash commutation friendly.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/vectorapi\/TestMaskedMacroLogicVector.java\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110 -XX:+UseParallelGC -XX:+UseNUMA\n+    return false;\n+  }\n+\n+  if (n->is_Region()) {\n+    \/\/ LoopNode::Ideal calls RegionNode::Ideal.\n+    \/\/ CountedLoopNode::Ideal calls RegionNode::Ideal too.\n+    \/\/ But I got an issue because RegionNode::optimize_trichotomy\n+    \/\/ then modifies another node, and pushes nodes to the worklist\n+    \/\/ Not sure if this is ok, modifying another node like that.\n+    \/\/ Maybe it is, then we need to look into what to do with\n+    \/\/ the nodes that are now on the worklist, maybe just clear\n+    \/\/ them out again. But maybe modifying other nodes like that\n+    \/\/ is also bad design. In the end, we return nullptr for\n+    \/\/ the current CountedLoop. But the extra nodes on the worklist\n+    \/\/ trip the asserts later on.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/eliminateAutobox\/TestShortBoxing.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_CallJava()) {\n+    \/\/ CallStaticJavaNode::Ideal\n+    \/\/ Led to a crash:\n+    \/\/   assert((is_CallStaticJava() && cg->is_mh_late_inline()) || (is_CallDynamicJava() && cg->is_virtual_late_inline())) failed: mismatch\n+    \/\/\n+    \/\/ Did not investigate yet, could be a bug.\n+    \/\/ Or maybe it does not expect to be called during verification.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/jdk\/jdk\/incubator\/vector\/VectorRuns.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+\n+    \/\/ CallDynamicJavaNode::Ideal, and I think also for CallStaticJavaNode::Ideal\n+    \/\/  and possibly their subclasses.\n+    \/\/ During late inlining it can call CallJavaNode::register_for_late_inline\n+    \/\/ That means we do more rounds of late inlining, but might fail.\n+    \/\/ Then we do IGVN again, and register the node again for late inlining.\n+    \/\/ This creates an endless cycle. Everytime we try late inlining, we\n+    \/\/ are also creating more nodes, especially SafePoint and MergeMem.\n+    \/\/ These nodes are immediately rejected when the inlining fails in the\n+    \/\/ do_late_inline_check, but they still grow the memory, until we hit\n+    \/\/ the MemLimit and crash.\n+    \/\/ The assumption here seems that CallDynamicJavaNode::Ideal does not get\n+    \/\/ called repeatedly, and eventually we terminate. I fear this is not\n+    \/\/ a great assumption to make. We should investigate more.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-U\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  \/\/ The number of nodes shoud not increase.\n+  uint old_unique = C->unique();\n+\n+  Node* i = n->Ideal(this, can_reshape);\n+  \/\/ If there was no new Idealization, we are probably happy.\n+  if (i == nullptr) {\n+    if (old_unique < C->unique()) {\n+      stringStream ss; \/\/ Print as a block without tty lock.\n+      ss.cr();\n+      ss.print_cr(\"Ideal optimization did not make progress but created new unused nodes.\");\n+      ss.print_cr(\"  old_unique = %d, unique = %d\", old_unique, C->unique());\n+      n->dump_bfs(1, nullptr, \"\", &ss);\n+      tty->print_cr(\"%s\", ss.as_string());\n+      return true;\n+    }\n+\n+    verify_empty_worklist(n);\n+\n+    \/\/ Everything is good.\n+    return false;\n+  }\n+\n+  \/\/ We just saw a new Idealization which was not done during IGVN.\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Ideal optimization (can_reshape=%s):\", can_reshape ? \"true\": \"false\");\n+  if (i == n) {\n+    ss.print_cr(\"The node was reshaped by Ideal.\");\n+  } else {\n+    ss.print_cr(\"The node was replaced by Ideal.\");\n+    ss.print_cr(\"Old node:\");\n+    n->dump_bfs(1, nullptr, \"\", &ss);\n+  }\n+  ss.print_cr(\"The result after Ideal:\");\n+  i->dump_bfs(1, nullptr, \"\", &ss);\n+  tty->print_cr(\"%s\", ss.as_string());\n+  return true;\n+}\n+\n+\/\/ Check that all Identity optimizations that could be done were done.\n+\/\/ Returns true if it found missed optimization opportunities and\n+\/\/         false otherwise (no missed optimization, or skipped verification).\n+bool PhaseIterGVN::verify_Identity_for(Node* n) {\n+  \/\/ First, we check a list of exceptions, where we skip verification,\n+  \/\/ because there are known cases where Ideal can optimize after IGVN.\n+  \/\/ Some may be expected and cannot be fixed, and others should be fixed.\n+  switch (n->Opcode()) {\n+    \/\/ SafePointNode::Identity can remove SafePoints, but wants to wait until\n+    \/\/ after loopopts:\n+    \/\/   \/\/ Transforming long counted loops requires a safepoint node. Do not\n+    \/\/   \/\/ eliminate a safepoint until loop opts are over.\n+    \/\/   if (in(0)->is_Proj() && !phase->C->major_progress()) {\n+    \/\/\n+    \/\/ I think the check for major_progress does delay it until after loopopts\n+    \/\/ but it does not ensure that the node is on the IGVN worklist after\n+    \/\/ loopopts. I think we should try to instead check for\n+    \/\/ phase->C->post_loop_opts_phase() and call record_for_post_loop_opts_igvn.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_SafePoint:\n+      return false;\n+\n+    \/\/ MergeMemNode::Identity replaces the MergeMem with its base_memory if it\n+    \/\/ does not record any other memory splits.\n+    \/\/\n+    \/\/ I did not deeply investigate, but it looks like MergeMemNode::Identity\n+    \/\/ never got called during IGVN for this node, investigate why.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_MergeMem:\n+      return false;\n+\n+    \/\/ ConstraintCastNode::Identity finds casts that are the same, except that\n+    \/\/ the control is \"higher up\", i.e. dominates. The call goes via\n+    \/\/ ConstraintCastNode::dominating_cast to PhaseGVN::is_dominator_helper,\n+    \/\/ which traverses up to 100 idom steps. If anything gets optimized somewhere\n+    \/\/ away from the cast, but within 100 idom steps, the cast may not be\n+    \/\/ put on the IGVN worklist any more.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_CastPP:\n+    case Op_CastII:\n+    case Op_CastLL:\n+      return false;\n+\n+    \/\/ Same issue for CheckCastPP, uses ConstraintCastNode::Identity and\n+    \/\/ checks dominator, which may be changed, but too far up for notification\n+    \/\/ to work.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestSkeletonPredicates.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CheckCastPP:\n+      return false;\n+\n+    \/\/ In SubNode::Identity, we do:\n+    \/\/   Convert \"(X+Y) - Y\" into X and \"(X+Y) - X\" into Y\n+    \/\/ In the example, the AddI had an input replaced, the AddI is\n+    \/\/ added to the IGVN worklist, but the SubI is one link further\n+    \/\/ down and is not added. I checked add_users_of_use_to_worklist\n+    \/\/ where I would expect the SubI would be added, and I cannot\n+    \/\/ find the pattern, only this one:\n+    \/\/   If changed AddI\/SubI inputs, check CmpU for range check optimization.\n+    \/\/\n+    \/\/ Fix this \"notification\" issue and check if there are any other\n+    \/\/ issues.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_SubI:\n+    case Op_SubL:\n+      return false;\n+\n+    \/\/ PhiNode::Identity checks for patterns like:\n+    \/\/   r = (x != con) ? x : con;\n+    \/\/ that can be constant folded to \"x\".\n+    \/\/\n+    \/\/ Call goes through PhiNode::is_cmove_id and CMoveNode::is_cmove_id.\n+    \/\/ I suspect there was some earlier change to one of the inputs, but\n+    \/\/ not all relevant outputs were put on the IGVN worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithG1.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_Phi:\n+      return false;\n+\n+    \/\/ ConvI2LNode::Identity does\n+    \/\/ convert I2L(L2I(x)) => x\n+    \/\/\n+    \/\/ Investigate why this did not already happen during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-A\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_ConvI2L:\n+      return false;\n+\n+    \/\/ MaxNode::find_identity_operation\n+    \/\/  Finds patterns like Max(A, Max(A, B)) -> Max(A, B)\n+    \/\/  This can be a 2-hop search, so maybe notification is not\n+    \/\/  good enough.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/codegen\/TestBooleanVect.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_MaxL:\n+    case Op_MinL:\n+    case Op_MaxI:\n+    case Op_MinI:\n+    case Op_MaxF:\n+    case Op_MinF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MaxD:\n+    case Op_MinD:\n+      return false;\n+\n+\n+    \/\/ AddINode::Identity\n+    \/\/ Converts (x-y)+y to x\n+    \/\/ Could be issue with notification\n+    \/\/\n+    \/\/ Turns out AddL does the same.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/  compiler\/c2\/Test6792161.java\n+    \/\/  -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_AddI:\n+    case Op_AddL:\n+      return false;\n+\n+    \/\/ AbsINode::Identity\n+    \/\/ Not investigated yet.\n+    case Op_AbsI:\n+      return false;\n+  }\n+\n+  if (n->is_Load()) {\n+    \/\/ LoadNode::Identity tries to look for an earlier store value via\n+    \/\/ can_see_stored_value. I found an example where this led to\n+    \/\/ an Allocation, where we could assume the value was still zero.\n+    \/\/ So the LoadN can be replaced with a zerocon.\n+    \/\/\n+    \/\/ Investigate why this was not already done during IGVN.\n+    \/\/ A similar issue happens with Ideal.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    return false;\n+  }\n+\n+  if (n->is_Store()) {\n+    \/\/ StoreNode::Identity\n+    \/\/ Not investigated, but found missing optimization for StoreI.\n+    \/\/ Looks like a StoreI is replaced with an InitializeNode.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   applications\/ctw\/modules\/java_base_2.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -Djava.awt.headless=true -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_Vector()) {\n+    \/\/ Found with tier1-3. Not investigated yet.\n+    \/\/ The observed issue was with AndVNode::Identity\n+    return false;\n+  }\n+\n+  Node* i = n->Identity(this);\n+  \/\/ If we cannot find any other Identity, we are happy.\n+  if (i == n) {\n+    verify_empty_worklist(n);\n+    return false;\n+  }\n+\n+  \/\/ The verification just found a new Identity that was not found during IGVN.\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Identity optimization:\");\n+  ss.print_cr(\"Old node:\");\n+  n->dump_bfs(1, nullptr, \"\", &ss);\n+  ss.print_cr(\"New node:\");\n+  i->dump_bfs(1, nullptr, \"\", &ss);\n+  tty->print_cr(\"%s\", ss.as_string());\n@@ -1943,1 +2829,1 @@\n-\/\/ We have a list of exceptions, see comments in verify_node_value.\n+\/\/ We have a list of exceptions, see comments in verify_Value_for.\n@@ -1948,1 +2834,1 @@\n-    failure |= verify_node_value(n);\n+    failure |= verify_Value_for(n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":900,"deletions":14,"binary":false,"changes":914,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,1 +497,4 @@\n-  bool verify_node_value(Node* n);\n+  bool verify_Value_for(Node* n);\n+  bool verify_Ideal_for(Node* n, bool can_reshape);\n+  bool verify_Identity_for(Node* n);\n+  void verify_empty_worklist(Node* n);\n@@ -598,0 +601,8 @@\n+  static bool is_verify_Ideal() {\n+    \/\/ '-XX:VerifyIterativeGVN=100'\n+    return ((VerifyIterativeGVN % 1000) \/ 100) == 1;\n+  }\n+  static bool is_verify_Identity() {\n+    \/\/ '-XX:VerifyIterativeGVN=1000'\n+    return ((VerifyIterativeGVN % 10000) \/ 1000) == 1;\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  flags(ITER_GVN_AFTER_VECTOR,          \"Iter GVN after vector box elimination\") \\\n+  flags(ITER_GVN_AFTER_VECTOR,          \"Iter GVN after Vector Box Elimination\") \\\n@@ -52,4 +52,7 @@\n-  flags(BEFORE_BEAUTIFY_LOOPS,          \"Before beautify loops\") \\\n-  flags(AFTER_BEAUTIFY_LOOPS,           \"After beautify loops\") \\\n-  flags(BEFORE_LOOP_UNROLLING,          \"Before Loop Unrolling\") \\\n-  flags(AFTER_LOOP_UNROLLING,           \"After Loop Unrolling\") \\\n+  flags(PHASEIDEAL_BEFORE_EA,           \"PhaseIdealLoop before EA\") \\\n+  flags(AFTER_EA,                       \"After Escape Analysis\") \\\n+  flags(ITER_GVN_AFTER_EA,              \"Iter GVN after EA\") \\\n+  flags(BEFORE_BEAUTIFY_LOOPS,          \"Before Beautify Loops\") \\\n+  flags(AFTER_BEAUTIFY_LOOPS,           \"After Beautify Loops\") \\\n+  flags(BEFORE_CLOOPS,                  \"Before CountedLoop\") \\\n+  flags(AFTER_CLOOPS,                   \"After CountedLoop\") \\\n@@ -72,0 +75,1 @@\n+  flags(ITER_GVN_AFTER_ELIMINATION,     \"Iter GVN after Eliminating Allocations and Locks\") \\\n@@ -74,11 +78,2 @@\n-  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,                     \"AutoVectorization 1, Before Apply\") \\\n-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, After Apply Memop Reordering\") \\\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, After Adjusting Pre-Loop Limit\") \\\n-  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, After Adding Speculative Runtime Checks\") \\\n-  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, After Apply\") \\\n-  flags(BEFORE_CLOOPS,                  \"Before CountedLoop\") \\\n-  flags(AFTER_CLOOPS,                   \"After CountedLoop\") \\\n-  flags(PHASEIDEAL_BEFORE_EA,           \"PhaseIdealLoop before EA\") \\\n-  flags(AFTER_EA,                       \"After Escape Analysis\") \\\n-  flags(ITER_GVN_AFTER_EA,              \"Iter GVN after EA\") \\\n-  flags(ITER_GVN_AFTER_ELIMINATION,     \"Iter GVN after eliminating allocations and locks\") \\\n+  flags(BEFORE_LOOP_UNROLLING,          \"Before Loop Unrolling\") \\\n+  flags(AFTER_LOOP_UNROLLING,           \"After Loop Unrolling\") \\\n@@ -88,0 +83,5 @@\n+  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,                     \"AutoVectorization 1, before Apply\") \\\n+  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, after Apply Memop Reordering\") \\\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, after Adjusting Pre-loop Limit\") \\\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, after Adding Speculative Runtime Checks\") \\\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, after Apply\") \\\n@@ -97,15 +97,15 @@\n-  flags(BARRIER_EXPANSION,              \"Barrier expand\") \\\n-  flags(OPTIMIZE_FINISHED,              \"Optimize finished\") \\\n-  flags(BEFORE_MATCHING,                \"Before matching\") \\\n-  flags(MATCHING,                       \"After matching\") \\\n-  flags(GLOBAL_CODE_MOTION,             \"Global code motion\") \\\n-  flags(INITIAL_LIVENESS,               \"Initial liveness\") \\\n-  flags(LIVE_RANGE_STRETCHING,          \"Live range stretching\") \\\n-  flags(AGGRESSIVE_COALESCING,          \"Aggressive coalescing\") \\\n-  flags(INITIAL_SPILLING,               \"Initial spilling\") \\\n-  flags(CONSERVATIVE_COALESCING,        \"Conservative coalescing\") \\\n-  flags(ITERATIVE_SPILLING,             \"Iterative spilling\") \\\n-  flags(AFTER_ITERATIVE_SPILLING,       \"After iterative spilling\") \\\n-  flags(POST_ALLOCATION_COPY_REMOVAL,   \"Post-allocation copy removal\") \\\n-  flags(MERGE_MULTI_DEFS,               \"Merge multiple definitions\") \\\n-  flags(FIX_UP_SPILLS,                  \"Fix up spills\") \\\n+  flags(BARRIER_EXPANSION,              \"Barrier Expand\") \\\n+  flags(OPTIMIZE_FINISHED,              \"Optimize Finished\") \\\n+  flags(BEFORE_MATCHING,                \"Before Matching\") \\\n+  flags(MATCHING,                       \"After Matching\") \\\n+  flags(GLOBAL_CODE_MOTION,             \"Global Code Motion\") \\\n+  flags(INITIAL_LIVENESS,               \"Initial Liveness\") \\\n+  flags(LIVE_RANGE_STRETCHING,          \"Live Range Stretching\") \\\n+  flags(AGGRESSIVE_COALESCING,          \"Aggressive Coalescing\") \\\n+  flags(INITIAL_SPILLING,               \"Initial Spilling\") \\\n+  flags(CONSERVATIVE_COALESCING,        \"Conservative Coalescing\") \\\n+  flags(ITERATIVE_SPILLING,             \"Iterative Spilling\") \\\n+  flags(AFTER_ITERATIVE_SPILLING,       \"After Iterative Spilling\") \\\n+  flags(POST_ALLOCATION_COPY_REMOVAL,   \"Post-allocation Copy Removal\") \\\n+  flags(MERGE_MULTI_DEFS,               \"Merge Multiple Definitions\") \\\n+  flags(FIX_UP_SPILLS,                  \"Fix up Spills\") \\\n@@ -115,2 +115,2 @@\n-  flags(POSTALLOC_EXPAND,               \"Post-Allocation Expand\") \\\n-  flags(MACH_ANALYSIS,                  \"After mach analysis\") \\\n+  flags(POSTALLOC_EXPAND,               \"Post-allocation Expand\") \\\n+  flags(MACH_ANALYSIS,                  \"After Mach Analysis\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -483,1 +484,0 @@\n-#define SMALLINT ((juint)3)  \/\/ a value too insignificant to consider widening\n@@ -542,19 +542,21 @@\n-  TypeInt::MINUS_1 = TypeInt::make(-1);  \/\/ -1\n-  TypeInt::ZERO    = TypeInt::make( 0);  \/\/  0\n-  TypeInt::ONE     = TypeInt::make( 1);  \/\/  1\n-  TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n-  TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n-  TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n-  TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n-  TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n-  TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);\n-  TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n-  TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); \/\/ Bytes\n-  TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); \/\/ Unsigned Bytes\n-  TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); \/\/ Java chars\n-  TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); \/\/ Java shorts\n-  TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); \/\/ Non-neg values\n-  TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); \/\/ Positive values\n-  TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); \/\/ 32-bit integers\n-  TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); \/\/ symmetric range\n-  TypeInt::TYPE_DOMAIN  = TypeInt::INT;\n+  TypeInt::MINUS_1  = TypeInt::make(-1);  \/\/ -1\n+  TypeInt::ZERO     = TypeInt::make( 0);  \/\/  0\n+  TypeInt::ONE      = TypeInt::make( 1);  \/\/  1\n+  TypeInt::BOOL     = TypeInt::make( 0, 1, WidenMin);  \/\/ 0 or 1, FALSE or TRUE.\n+  TypeInt::CC       = TypeInt::make(-1, 1, WidenMin);  \/\/ -1, 0 or 1, condition codes\n+  TypeInt::CC_LT    = TypeInt::make(-1,-1, WidenMin);  \/\/ == TypeInt::MINUS_1\n+  TypeInt::CC_GT    = TypeInt::make( 1, 1, WidenMin);  \/\/ == TypeInt::ONE\n+  TypeInt::CC_EQ    = TypeInt::make( 0, 0, WidenMin);  \/\/ == TypeInt::ZERO\n+  TypeInt::CC_NE    = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{-1, 1}, {1, max_juint}, {0, 1}}, WidenMin)->is_int();\n+  TypeInt::CC_LE    = TypeInt::make(-1, 0, WidenMin);\n+  TypeInt::CC_GE    = TypeInt::make( 0, 1, WidenMin);  \/\/ == TypeInt::BOOL\n+  TypeInt::BYTE     = TypeInt::make(-128, 127,     WidenMin); \/\/ Bytes\n+  TypeInt::UBYTE    = TypeInt::make(0, 255,        WidenMin); \/\/ Unsigned Bytes\n+  TypeInt::CHAR     = TypeInt::make(0, 65535,      WidenMin); \/\/ Java chars\n+  TypeInt::SHORT    = TypeInt::make(-32768, 32767, WidenMin); \/\/ Java shorts\n+  TypeInt::NON_ZERO = TypeInt::make_or_top(TypeIntPrototype<jint, juint>{{min_jint, max_jint}, {1, max_juint}, {0, 0}}, WidenMin)->is_int();\n+  TypeInt::POS      = TypeInt::make(0, max_jint,   WidenMin); \/\/ Non-neg values\n+  TypeInt::POS1     = TypeInt::make(1, max_jint,   WidenMin); \/\/ Positive values\n+  TypeInt::INT      = TypeInt::make(min_jint, max_jint, WidenMax); \/\/ 32-bit integers\n+  TypeInt::SYMINT   = TypeInt::make(-max_jint, max_jint, WidenMin); \/\/ symmetric range\n+  TypeInt::TYPE_DOMAIN = TypeInt::INT;\n@@ -562,1 +564,1 @@\n-  \/\/ a trinary (-1,0,+1) integer result AND as an efficient long\n+  \/\/ a trinary (-1, 0, +1) integer result AND as an efficient long\n@@ -564,16 +566,17 @@\n-  assert( TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n-  assert( TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n-  assert( (juint)(TypeInt::CC->_hi - TypeInt::CC->_lo) <= SMALLINT, \"CC is truly small\");\n-\n-  TypeLong::MAX = TypeLong::make(max_jlong);  \/\/ Long MAX\n-  TypeLong::MIN = TypeLong::make(min_jlong);  \/\/ Long MIN\n-  TypeLong::MINUS_1 = TypeLong::make(-1);        \/\/ -1\n-  TypeLong::ZERO    = TypeLong::make( 0);        \/\/  0\n-  TypeLong::ONE     = TypeLong::make( 1);        \/\/  1\n-  TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); \/\/ Non-neg values\n-  TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); \/\/ 64-bit integers\n-  TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);\n-  TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);\n-  TypeLong::TYPE_DOMAIN  = TypeLong::LONG;\n+  assert(TypeInt::CC_LT == TypeInt::MINUS_1, \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GT == TypeInt::ONE,     \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_EQ == TypeInt::ZERO,    \"types must match for CmpL to work\" );\n+  assert(TypeInt::CC_GE == TypeInt::BOOL,    \"types must match for CmpL to work\" );\n+\n+  TypeLong::MAX = TypeLong::make(max_jlong); \/\/ Long MAX\n+  TypeLong::MIN = TypeLong::make(min_jlong); \/\/ Long MIN\n+  TypeLong::MINUS_1  = TypeLong::make(-1);   \/\/ -1\n+  TypeLong::ZERO     = TypeLong::make( 0);   \/\/  0\n+  TypeLong::ONE      = TypeLong::make( 1);   \/\/  1\n+  TypeLong::NON_ZERO = TypeLong::make_or_top(TypeIntPrototype<jlong, julong>{{min_jlong, max_jlong}, {1, max_julong}, {0, 0}}, WidenMin)->is_long();\n+  TypeLong::POS      = TypeLong::make(0, max_jlong, WidenMin); \/\/ Non-neg values\n+  TypeLong::NEG      = TypeLong::make(min_jlong, -1, WidenMin);\n+  TypeLong::LONG     = TypeLong::make(min_jlong, max_jlong, WidenMax); \/\/ 64-bit integers\n+  TypeLong::INT      = TypeLong::make((jlong)min_jint, (jlong)max_jint,WidenMin);\n+  TypeLong::UINT     = TypeLong::make(0, (jlong)max_juint, WidenMin);\n+  TypeLong::TYPE_DOMAIN = TypeLong::LONG;\n@@ -1821,25 +1824,23 @@\n-const TypeInt *TypeInt::MAX;    \/\/ INT_MAX\n-const TypeInt *TypeInt::MIN;    \/\/ INT_MIN\n-const TypeInt *TypeInt::MINUS_1;\/\/ -1\n-const TypeInt *TypeInt::ZERO;   \/\/ 0\n-const TypeInt *TypeInt::ONE;    \/\/ 1\n-const TypeInt *TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n-const TypeInt *TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n-const TypeInt *TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n-const TypeInt *TypeInt::CC_GT;  \/\/ [1]   == ONE\n-const TypeInt *TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n-const TypeInt *TypeInt::CC_LE;  \/\/ [-1,0]\n-const TypeInt *TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n-const TypeInt *TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n-const TypeInt *TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n-const TypeInt *TypeInt::CHAR;   \/\/ Java chars, 0-65535\n-const TypeInt *TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n-const TypeInt *TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n-const TypeInt *TypeInt::POS1;   \/\/ Positive 32-bit integers\n-const TypeInt *TypeInt::INT;    \/\/ 32-bit integers\n-const TypeInt *TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-const TypeInt *TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-\/\/------------------------------TypeInt----------------------------------------\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n-}\n+const TypeInt* TypeInt::MAX;    \/\/ INT_MAX\n+const TypeInt* TypeInt::MIN;    \/\/ INT_MIN\n+const TypeInt* TypeInt::MINUS_1;\/\/ -1\n+const TypeInt* TypeInt::ZERO;   \/\/ 0\n+const TypeInt* TypeInt::ONE;    \/\/ 1\n+const TypeInt* TypeInt::BOOL;   \/\/ 0 or 1, FALSE or TRUE.\n+const TypeInt* TypeInt::CC;     \/\/ -1,0 or 1, condition codes\n+const TypeInt* TypeInt::CC_LT;  \/\/ [-1]  == MINUS_1\n+const TypeInt* TypeInt::CC_GT;  \/\/ [1]   == ONE\n+const TypeInt* TypeInt::CC_EQ;  \/\/ [0]   == ZERO\n+const TypeInt* TypeInt::CC_NE;\n+const TypeInt* TypeInt::CC_LE;  \/\/ [-1,0]\n+const TypeInt* TypeInt::CC_GE;  \/\/ [0,1] == BOOL (!)\n+const TypeInt* TypeInt::BYTE;   \/\/ Bytes, -128 to 127\n+const TypeInt* TypeInt::UBYTE;  \/\/ Unsigned Bytes, 0 to 255\n+const TypeInt* TypeInt::CHAR;   \/\/ Java chars, 0-65535\n+const TypeInt* TypeInt::SHORT;  \/\/ Java shorts, -32768-32767\n+const TypeInt* TypeInt::NON_ZERO;\n+const TypeInt* TypeInt::POS;    \/\/ Positive 32-bit integers or zero\n+const TypeInt* TypeInt::POS1;   \/\/ Positive 32-bit integers\n+const TypeInt* TypeInt::INT;    \/\/ 32-bit integers\n+const TypeInt* TypeInt::SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+const TypeInt* TypeInt::TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n@@ -1847,3 +1848,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeInt *TypeInt::make( jint lo ) {\n-  return (TypeInt*)(new TypeInt(lo,lo,WidenMin))->hashcons();\n+TypeInt::TypeInt(const TypeIntPrototype<jint, juint>& t, int widen, bool dual)\n+  : TypeInteger(Int, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -1852,9 +1854,4 @@\n-static int normalize_int_widen( jint lo, jint hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants and also CC and its relatives.\n-  if (lo <= hi) {\n-    if (((juint)hi - lo) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)hi - lo) >= max_juint) w = Type::WidenMax; \/\/ TypeInt::INT\n-  } else {\n-    if (((juint)lo - hi) <= SMALLINT)  w = Type::WidenMin;\n-    if (((juint)lo - hi) >= max_juint) w = Type::WidenMin; \/\/ dual TypeInt::INT\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -1862,1 +1859,1 @@\n-  return w;\n+  return (new TypeInt(canonicalized_t._data, widen, dual))->hashcons()->is_int();\n@@ -1865,3 +1862,4 @@\n-const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {\n-  w = normalize_int_widen(lo, hi, w);\n-  return (TypeInt*)(new TypeInt(lo,hi,w))->hashcons();\n+const TypeInt* TypeInt::make(jint con) {\n+  juint ucon = con;\n+  return (new TypeInt(TypeIntPrototype<jint, juint>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                      WidenMin, false))->hashcons()->is_int();\n@@ -1870,44 +1868,3 @@\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeInt::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeInt\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Long:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Int:                     \/\/ Int vs Int?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeInt *r = t->is_int();\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeInt* TypeInt::make(jint lo, jint hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jint, juint>{{lo, hi}, {0, max_juint}, {0, 0}}, widen)->is_int();\n@@ -1916,55 +1873,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeInt::xdual() const {\n-  int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeInt(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeInt::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Int ) return this;\n-  const TypeInt *ot = old->is_int();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      int max = max_jint;\n-      int min = min_jint;\n-      if (limit->isa_int()) {\n-        max = limit->is_int()->_hi;\n-        min = limit->is_int()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((juint)_lo - min) >= ((juint)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 31 bits:\n-          return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeInt::INT;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeInt::make_or_top(const TypeIntPrototype<jint, juint>& t, int widen) {\n+  return make_or_top(t, widen, false);\n+}\n@@ -1972,3 +1877,6 @@\n-  \/\/fatal(\"Integer value range is not subset\");\n-  \/\/return this;\n-  return TypeInt::INT;\n+bool TypeInt::contains(jint i) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  juint u = i;\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -1977,9 +1885,4 @@\n-\/\/------------------------------narrow---------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeInt::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeInt* ot = old->isa_int();\n-  if (ot == nullptr)  return this;\n-  jint olo = ot->_lo;\n-  jint ohi = ot->_hi;\n+bool TypeInt::contains(const TypeInt* t) const {\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -1987,2 +1890,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeInt::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t);\n+}\n@@ -1990,2 +1894,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jint && ohi == max_jint)  return this;\n+const Type* TypeInt::xdual() const {\n+  return new TypeInt(TypeIntPrototype<jint, juint>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                     _widen, !_is_dual);\n+}\n@@ -1993,2 +1899,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeInt::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_int(), limit->isa_int());\n+}\n@@ -1996,8 +1904,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  juint nrange = (juint)_hi - _lo;\n-  juint orange = (juint)ohi - olo;\n-  if (nrange < max_juint - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeInt::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2006,1 +1910,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_int());\n@@ -2010,1 +1914,2 @@\n-const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeInt::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -2012,1 +1917,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2014,0 +1919,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -2017,1 +1924,2 @@\n-    ft = TypeInt::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeInt(TypeIntPrototype<jint, juint>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                        this->_widen, false))->hashcons();\n@@ -2024,3 +1932,3 @@\n-bool TypeInt::eq( const Type *t ) const {\n-  const TypeInt *r = t->is_int(); \/\/ Handy access\n-  return r->_lo == _lo && r->_hi == _hi && r->_widen == _widen;\n+bool TypeInt::eq(const Type* t) const {\n+  const TypeInt* r = t->is_int();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -2032,1 +1940,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Int;\n@@ -2041,43 +1950,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeInt\n-#ifndef PRODUCT\n-static const char* intname(char* buf, size_t buf_size, jint n) {\n-  if (n == min_jint)\n-    return \"min\";\n-  else if (n < min_jint + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n-  else if (n == max_jint)\n-    return \"max\";\n-  else if (n > max_jint - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n-  else\n-    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeInt::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[40], buf2[40];\n-  if (_lo == min_jint && _hi == max_jint)\n-    st->print(\"int\");\n-  else if (is_con())\n-    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n-  else if (_lo == BOOL->_lo && _hi == BOOL->_hi)\n-    st->print(\"bool\");\n-  else if (_lo == BYTE->_lo && _hi == BYTE->_hi)\n-    st->print(\"byte\");\n-  else if (_lo == CHAR->_lo && _hi == CHAR->_hi)\n-    st->print(\"char\");\n-  else if (_lo == SHORT->_lo && _hi == SHORT->_hi)\n-    st->print(\"short\");\n-  else if (_hi == max_jint)\n-    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jint)\n-    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n-\n-  if (_widen != 0 && this != TypeInt::INT)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2088,1 +1954,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2092,1 +1958,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2097,14 +1963,12 @@\n-const TypeLong *TypeLong::MAX;\n-const TypeLong *TypeLong::MIN;\n-const TypeLong *TypeLong::MINUS_1;\/\/ -1\n-const TypeLong *TypeLong::ZERO; \/\/ 0\n-const TypeLong *TypeLong::ONE;  \/\/ 1\n-const TypeLong *TypeLong::POS;  \/\/ >=0\n-const TypeLong *TypeLong::LONG; \/\/ 64-bit integers\n-const TypeLong *TypeLong::INT;  \/\/ 32-bit subrange\n-const TypeLong *TypeLong::UINT; \/\/ 32-bit unsigned subrange\n-const TypeLong *TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n-}\n+const TypeLong* TypeLong::MAX;\n+const TypeLong* TypeLong::MIN;\n+const TypeLong* TypeLong::MINUS_1;\/\/ -1\n+const TypeLong* TypeLong::ZERO; \/\/ 0\n+const TypeLong* TypeLong::ONE;  \/\/ 1\n+const TypeLong* TypeLong::NON_ZERO;\n+const TypeLong* TypeLong::POS;  \/\/ >=0\n+const TypeLong* TypeLong::NEG;\n+const TypeLong* TypeLong::LONG; \/\/ 64-bit integers\n+const TypeLong* TypeLong::INT;  \/\/ 32-bit subrange\n+const TypeLong* TypeLong::UINT; \/\/ 32-bit unsigned subrange\n+const TypeLong* TypeLong::TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -2112,3 +1976,4 @@\n-\/\/------------------------------make-------------------------------------------\n-const TypeLong *TypeLong::make( jlong lo ) {\n-  return (TypeLong*)(new TypeLong(lo,lo,WidenMin))->hashcons();\n+TypeLong::TypeLong(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual)\n+  : TypeInteger(Long, t.normalize_widen(widen), dual), _lo(t._srange._lo), _hi(t._srange._hi),\n+    _ulo(t._urange._lo), _uhi(t._urange._hi), _bits(t._bits) {\n+  DEBUG_ONLY(t.verify_constraints());\n@@ -2117,9 +1982,4 @@\n-static int normalize_long_widen( jlong lo, jlong hi, int w ) {\n-  \/\/ Certain normalizations keep us sane when comparing types.\n-  \/\/ The 'SMALLINT' covers constants.\n-  if (lo <= hi) {\n-    if (((julong)hi - lo) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)hi - lo) >= max_julong) w = Type::WidenMax; \/\/ TypeLong::LONG\n-  } else {\n-    if (((julong)lo - hi) <= SMALLINT)   w = Type::WidenMin;\n-    if (((julong)lo - hi) >= max_julong) w = Type::WidenMin; \/\/ dual TypeLong::LONG\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual) {\n+  auto canonicalized_t = t.canonicalize_constraints();\n+  if (canonicalized_t.empty()) {\n+    return dual ? Type::BOTTOM : Type::TOP;\n@@ -2127,1 +1987,1 @@\n-  return w;\n+  return (new TypeLong(canonicalized_t._data, widen, dual))->hashcons()->is_long();\n@@ -2130,3 +1990,4 @@\n-const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {\n-  w = normalize_long_widen(lo, hi, w);\n-  return (TypeLong*)(new TypeLong(lo,hi,w))->hashcons();\n+const TypeLong* TypeLong::make(jlong con) {\n+  julong ucon = con;\n+  return (new TypeLong(TypeIntPrototype<jlong, julong>{{con, con}, {ucon, ucon}, {~ucon, ucon}},\n+                       WidenMin, false))->hashcons()->is_long();\n@@ -2135,45 +1996,3 @@\n-\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type representation object\n-\/\/ with reference count equal to the number of Types pointing at it.\n-\/\/ Caller should wrap a Types around it.\n-const Type *TypeLong::xmeet( const Type *t ) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if( this == t ) return this;  \/\/ Meeting same type?\n-\n-  \/\/ Currently \"this->_base\" is a TypeLong\n-  switch (t->base()) {          \/\/ Switch on original type\n-  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n-  case RawPtr:                  \/\/ reuses local variables\n-  case OopPtr:\n-  case InstPtr:\n-  case AryPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case NarrowOop:\n-  case NarrowKlass:\n-  case Int:\n-  case HalfFloatTop:\n-  case HalfFloatCon:\n-  case HalfFloatBot:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case Bottom:                  \/\/ Ye Olde Default\n-    return Type::BOTTOM;\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-  case Top:                     \/\/ No change\n-    return this;\n-  case Long:                    \/\/ Long vs Long?\n-    break;\n-  }\n-\n-  \/\/ Expand covered set\n-  const TypeLong *r = t->is_long(); \/\/ Turn into a TypeLong\n-  return make( MIN2(_lo,r->_lo), MAX2(_hi,r->_hi), MAX2(_widen,r->_widen) );\n+const TypeLong* TypeLong::make(jlong lo, jlong hi, int widen) {\n+  assert(lo <= hi, \"must be legal bounds\");\n+  return make_or_top(TypeIntPrototype<jlong, julong>{{lo, hi}, {0, max_julong}, {0, 0}}, widen)->is_long();\n@@ -2182,58 +2001,3 @@\n-\/\/------------------------------xdual------------------------------------------\n-\/\/ Dual: reverse hi & lo; flip widen\n-const Type *TypeLong::xdual() const {\n-  int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);\n-  return new TypeLong(_hi,_lo,w);\n-}\n-\n-\/\/------------------------------widen------------------------------------------\n-\/\/ Only happens for optimistic top-down optimizations.\n-const Type *TypeLong::widen( const Type *old, const Type* limit ) const {\n-  \/\/ Coming from TOP or such; no widening\n-  if( old->base() != Long ) return this;\n-  const TypeLong *ot = old->is_long();\n-\n-  \/\/ If new guy is equal to old guy, no widening\n-  if( _lo == ot->_lo && _hi == ot->_hi )\n-    return old;\n-\n-  \/\/ If new guy contains old, then we widened\n-  if( _lo <= ot->_lo && _hi >= ot->_hi ) {\n-    \/\/ New contains old\n-    \/\/ If new guy is already wider than old, no widening\n-    if( _widen > ot->_widen ) return this;\n-    \/\/ If old guy was a constant, do not bother\n-    if (ot->_lo == ot->_hi)  return this;\n-    \/\/ Now widen new guy.\n-    \/\/ Check for widening too far\n-    if (_widen == WidenMax) {\n-      jlong max = max_jlong;\n-      jlong min = min_jlong;\n-      if (limit->isa_long()) {\n-        max = limit->is_long()->_hi;\n-        min = limit->is_long()->_lo;\n-      }\n-      if (min < _lo && _hi < max) {\n-        \/\/ If neither endpoint is extremal yet, push out the endpoint\n-        \/\/ which is closer to its respective limit.\n-        if (_lo >= 0 ||                 \/\/ easy common case\n-            ((julong)_lo - min) >= ((julong)max - _hi)) {\n-          \/\/ Try to widen to an unsigned range type of 32\/63 bits:\n-          if (max >= max_juint && _hi < max_juint)\n-            return make(_lo, max_juint, WidenMax);\n-          else\n-            return make(_lo, max, WidenMax);\n-        } else {\n-          return make(min, _hi, WidenMax);\n-        }\n-      }\n-      return TypeLong::LONG;\n-    }\n-    \/\/ Returned widened new guy\n-    return make(_lo,_hi,_widen+1);\n-  }\n-\n-  \/\/ If old guy contains new, then we probably widened too far & dropped to\n-  \/\/ bottom.  Return the wider fellow.\n-  if ( ot->_lo <= _lo && ot->_hi >= _hi )\n-    return old;\n+const Type* TypeLong::make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen) {\n+  return make_or_top(t, widen, false);\n+}\n@@ -2241,3 +2005,6 @@\n-  \/\/  fatal(\"Long value range is not subset\");\n-  \/\/ return this;\n-  return TypeLong::LONG;\n+bool TypeLong::contains(jlong i) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  julong u = i;\n+  return i >= _lo && i <= _hi &&\n+         u >= _ulo && u <= _uhi &&\n+         _bits.is_satisfied_by(u);\n@@ -2246,9 +2013,4 @@\n-\/\/------------------------------narrow----------------------------------------\n-\/\/ Only happens for pessimistic optimizations.\n-const Type *TypeLong::narrow( const Type *old ) const {\n-  if (_lo >= _hi)  return this;   \/\/ already narrow enough\n-  if (old == nullptr)  return this;\n-  const TypeLong* ot = old->isa_long();\n-  if (ot == nullptr)  return this;\n-  jlong olo = ot->_lo;\n-  jlong ohi = ot->_hi;\n+bool TypeLong::contains(const TypeLong* t) const {\n+  assert(!_is_dual && !t->_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_is_subset(this, t);\n+}\n@@ -2256,2 +2018,3 @@\n-  \/\/ If new guy is equal to old guy, no narrowing\n-  if (_lo == olo && _hi == ohi)  return old;\n+const Type* TypeLong::xmeet(const Type* t) const {\n+  return TypeIntHelper::int_type_xmeet(this, t);\n+}\n@@ -2259,2 +2022,4 @@\n-  \/\/ If old guy was maximum range, allow the narrowing\n-  if (olo == min_jlong && ohi == max_jlong)  return this;\n+const Type* TypeLong::xdual() const {\n+  return new TypeLong(TypeIntPrototype<jlong, julong>{{_lo, _hi}, {_ulo, _uhi}, _bits},\n+                      _widen, !_is_dual);\n+}\n@@ -2262,2 +2027,4 @@\n-  if (_lo < olo || _hi > ohi)\n-    return this;                \/\/ doesn't narrow; pretty weird\n+const Type* TypeLong::widen(const Type* old, const Type* limit) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  return TypeIntHelper::int_type_widen(this, old->isa_long(), limit->isa_long());\n+}\n@@ -2265,8 +2032,4 @@\n-  \/\/ The new type narrows the old type, so look for a \"death march\".\n-  \/\/ See comments on PhaseTransform::saturate.\n-  julong nrange = (julong)_hi - _lo;\n-  julong orange = (julong)ohi - olo;\n-  if (nrange < max_julong - 1 && nrange > (orange >> 1) + (SMALLINT*2)) {\n-    \/\/ Use the new type only if the range shrinks a lot.\n-    \/\/ We do not want the optimizer computing 2^31 point by point.\n-    return old;\n+const Type* TypeLong::narrow(const Type* old) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n+  if (old == nullptr) {\n+    return this;\n@@ -2275,1 +2038,1 @@\n-  return this;\n+  return TypeIntHelper::int_type_narrow(this, old->isa_long());\n@@ -2279,1 +2042,2 @@\n-const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {\n+const Type* TypeLong::filter_helper(const Type* kills, bool include_speculative) const {\n+  assert(!_is_dual, \"dual types should only be used for join calculation\");\n@@ -2281,1 +2045,1 @@\n-  if (ft == nullptr || ft->empty())\n+  if (ft == nullptr) {\n@@ -2283,0 +2047,2 @@\n+  }\n+  assert(!ft->_is_dual, \"dual types should only be used for join calculation\");\n@@ -2286,1 +2052,2 @@\n-    ft = TypeLong::make(ft->_lo, ft->_hi, this->_widen);\n+    return (new TypeLong(TypeIntPrototype<jlong, julong>{{ft->_lo, ft->_hi}, {ft->_ulo, ft->_uhi}, ft->_bits},\n+                         this->_widen, false))->hashcons();\n@@ -2293,3 +2060,3 @@\n-bool TypeLong::eq( const Type *t ) const {\n-  const TypeLong *r = t->is_long(); \/\/ Handy access\n-  return r->_lo == _lo &&  r->_hi == _hi  && r->_widen == _widen;\n+bool TypeLong::eq(const Type* t) const {\n+  const TypeLong* r = t->is_long();\n+  return TypeIntHelper::int_type_is_equal(this, r) && _widen == r->_widen && _is_dual == r->_is_dual;\n@@ -2301,1 +2068,2 @@\n-  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n+  return (uint)_lo + (uint)_hi + (uint)_ulo + (uint)_uhi +\n+         (uint)_bits._zeros + (uint)_bits._ones + (uint)_widen + (uint)_is_dual + (uint)Type::Long;\n@@ -2310,55 +2078,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump TypeLong\n-#ifndef PRODUCT\n-static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n-  if (n > x) {\n-    if (n >= x + 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n-  } else if (n < x) {\n-    if (n <= x - 10000)  return nullptr;\n-    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n-  } else {\n-    return xname;\n-  }\n-  return buf;\n-}\n-\n-static const char* longname(char* buf, size_t buf_size, jlong n) {\n-  const char* str;\n-  if (n == min_jlong)\n-    return \"min\";\n-  else if (n < min_jlong + 10000)\n-    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n-  else if (n == max_jlong)\n-    return \"max\";\n-  else if (n > max_jlong - 10000)\n-    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n-    return str;\n-  else\n-    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n-  return buf;\n-}\n-\n-void TypeLong::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  char buf[80], buf2[80];\n-  if (_lo == min_jlong && _hi == max_jlong)\n-    st->print(\"long\");\n-  else if (is_con())\n-    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n-  else if (_hi == max_jlong)\n-    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n-  else if (_lo == min_jlong)\n-    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n-  else\n-    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n-\n-  if (_widen != 0 && this != TypeLong::LONG)\n-    st->print(\":%.*s\", _widen, \"wwww\");\n-}\n-#endif\n-\n@@ -2369,1 +2082,1 @@\n-  return _lo >= _hi;\n+  return _lo == _hi;\n@@ -2373,1 +2086,1 @@\n-  return _lo > _hi;\n+  return false;\n@@ -2376,0 +2089,19 @@\n+\/\/------------------------------dump2------------------------------------------\n+#ifndef PRODUCT\n+void TypeInt::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeInt::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n+}\n+\n+void TypeLong::dump2(Dict& d, uint depth, outputStream* st) const {\n+  TypeIntHelper::int_type_dump(this, st, false);\n+}\n+\n+void TypeLong::dump_verbose() const {\n+  TypeIntHelper::int_type_dump(this, tty, true);\n+}\n+#endif\n+\n@@ -2684,1 +2416,7 @@\n-    const TypeAry *a = t->is_ary();\n+    const TypeAry* a = t->is_ary();\n+    const Type* size = _size->xmeet(a->_size);\n+    const TypeInt* isize = size->isa_int();\n+    if (isize == nullptr) {\n+      assert(size == Type::TOP || size == Type::BOTTOM, \"\");\n+      return size;\n+    }\n@@ -2686,2 +2424,1 @@\n-                         _size->xmeet(a->_size)->is_int(),\n-                         _stable && a->_stable,\n+                         isize, _stable && a->_stable,\n@@ -5299,1 +5036,1 @@\n-  if (lo > hi)\n+  if (lo > hi) {\n@@ -5301,1 +5038,2 @@\n-  if (!chg)\n+  }\n+  if (!chg) {\n@@ -5303,0 +5041,1 @@\n+  }\n@@ -5532,1 +5271,6 @@\n-    const TypeAry *tary = _ary->meet_speculative(tap->_ary)->is_ary();\n+    const Type* tm = _ary->meet_speculative(tap->_ary);\n+    const TypeAry* tary = tm->isa_ary();\n+    if (tary == nullptr) {\n+      assert(tm == Type::TOP || tm == Type::BOTTOM, \"\");\n+      return tm;\n+    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":230,"deletions":486,"binary":false,"changes":716,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/rangeinference.hpp\"\n@@ -78,0 +80,3 @@\n+template <class T, class U>\n+class TypeIntPrototype;\n+\n@@ -313,0 +318,4 @@\n+  \/\/ This has the same semantics as std::dynamic_cast<TypeClass*>(this)\n+  template <typename TypeClass>\n+  const TypeClass* try_cast() const;\n+\n@@ -626,1 +635,6 @@\n-  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n+  TypeInteger(TYPES t, int w, bool dual) : Type(t), _is_dual(dual), _widen(w) {}\n+\n+  \/\/ Denote that a set is a dual set.\n+  \/\/ Dual sets are only used to compute the join of 2 sets, and not used\n+  \/\/ outside.\n+  const bool _is_dual;\n@@ -646,0 +660,148 @@\n+\/**\n+ * Definition:\n+ *\n+ * A TypeInt represents a set of non-empty jint values. A jint v is an element\n+ * of a TypeInt iff:\n+ *\n+ *   v >= _lo && v <= _hi &&\n+ *   juint(v) >= _ulo && juint(v) <= _uhi &&\n+ *   _bits.is_satisfied_by(v)\n+ *\n+ * Multiple sets of parameters can represent the same set.\n+ * E.g: consider 2 TypeInt t1, t2\n+ *\n+ * t1._lo = 2, t1._hi = 7, t1._ulo = 0, t1._uhi = 5, t1._bits._zeros = 0x00000000, t1._bits._ones = 0x1\n+ * t2._lo = 3, t2._hi = 5, t2._ulo = 3, t2._uhi = 5, t2._bits._zeros = 0xFFFFFFF8, t2._bits._ones = 0x1\n+ *\n+ * Then, t1 and t2 both represent the set {3, 5}. We can also see that the\n+ * constraints of t2 are the tightest possible. I.e there exists no TypeInt t3\n+ * which also represents {3, 5} such that any of these would be true:\n+ *\n+ *  1)  t3._lo  > t2._lo\n+ *  2)  t3._hi  < t2._hi\n+ *  3)  t3._ulo > t2._ulo\n+ *  4)  t3._uhi < t2._uhi\n+ *  5)  (t3._bits._zeros &~ t2._bis._zeros) != 0\n+ *  6)  (t3._bits._ones  &~ t2._bits._ones) != 0\n+ *\n+ * The 5-th condition mean that the subtraction of the bitsets represented by\n+ * t3._bits._zeros and t2._bits._zeros is not empty, which means that the\n+ * bits in t3._bits._zeros is not a subset of those in t2._bits._zeros, the\n+ * same applies to _bits._ones\n+ *\n+ * To simplify reasoning about the types in optimizations, we canonicalize\n+ * every TypeInt to its tightest form, already at construction. E.g a TypeInt\n+ * t with t._lo < 0 will definitely contain negative values. It also makes it\n+ * trivial to determine if a TypeInt instance is a subset of another.\n+ *\n+ * Lemmas:\n+ *\n+ * 1. Since every TypeInt instance is non-empty and canonicalized, all the\n+ *   bounds must also be elements of such TypeInt. Or else, we can tighten the\n+ *   bounds by narrowing it by one, which contradicts the assumption of the\n+ *   TypeInt being canonical.\n+ *\n+ * 2.\n+ *   2.1.  _lo <= jint(_ulo)\n+ *   2.2.  _lo <= _hi\n+ *   2.3.  _lo <= jint(_uhi)\n+ *   2.4.  _ulo <= juint(_lo)\n+ *   2.5.  _ulo <= juint(_hi)\n+ *   2.6.  _ulo <= _uhi\n+ *   2.7.  _hi >= _lo\n+ *   2.8.  _hi >= jint(_ulo)\n+ *   2.9.  _hi >= jint(_uhi)\n+ *   2.10. _uhi >= juint(_lo)\n+ *   2.11. _uhi >= _ulo\n+ *   2.12. _uhi >= juint(_hi)\n+ *\n+ *   Proof of lemma 2:\n+ *\n+ *   2.1. _lo <= jint(_ulo):\n+ *     According the lemma 1, _ulo is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _ulo in the signed\n+ *     domain, or in a more programmatical way, _lo <= jint(_ulo).\n+ *   2.2. _lo <= _hi:\n+ *     According the lemma 1, _hi is an element of the TypeInt, so in the\n+ *     signed domain, it must not be less than the smallest element of that\n+ *     TypeInt, which is _lo. Which means that _lo <= _hi.\n+ *\n+ *   The other inequalities can be proved in a similar manner.\n+ *\n+ * 3. Given 2 jint values x, y where either both >= 0 or both < 0. Then:\n+ *\n+ *   x <= y iff juint(x) <= juint(y)\n+ *   I.e. x <= y in the signed domain iff x <= y in the unsigned domain\n+ *\n+ * 4. Either _lo == jint(_ulo) and _hi == jint(_uhi), or each element of a\n+ *   TypeInt lies in either interval [_lo, jint(_uhi)] or [jint(_ulo), _hi]\n+ *   (note that these intervals are disjoint in this case).\n+ *\n+ *   Proof of lemma 4:\n+ *\n+ *   For a TypeInt t, there are 3 possible cases:\n+ *\n+ *   a. t._lo >= 0, we have:\n+ *\n+ *     0 <= t_lo <= jint(t._ulo)           (lemma 2.1)\n+ *     juint(t._lo) <= juint(jint(t._ulo)) (lemma 3)\n+ *                  == t._ulo              (juint(jint(v)) == v with juint v)\n+ *                  <= juint(t._lo)        (lemma 2.4)\n+ *\n+ *     Which means that t._lo == jint(t._ulo).\n+ *\n+ *     Furthermore,\n+ *\n+ *     0 <= t._lo <= t._hi                 (lemma 2.2)\n+ *     0 <= t._lo <= jint(t._uhi)          (lemma 2.3)\n+ *     t._hi >= jint(t._uhi)               (lemma 2.9)\n+ *\n+ *     juint(t._hi) >= juint(jint(t._uhi)) (lemma 3)\n+ *                  == t._uhi              (juint(jint(v)) == v with juint v)\n+ *                  >= juint(t._hi)        (lemma 2.12)\n+ *\n+ *     Which means that t._hi == jint(t._uhi).\n+ *     In this case, t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ *   b. t._hi < 0. Similarly, we can conclude that:\n+ *     t._lo == jint(t._ulo) and t._hi == jint(t._uhi)\n+ *\n+ *   c. t._lo < 0, t._hi >= 0.\n+ *\n+ *     Since t._ulo <= juint(t._hi) (lemma 2.5), we must have jint(t._ulo) >= 0\n+ *     because all negative values is larger than all non-negative values in the\n+ *     unsigned domain.\n+ *\n+ *     Since t._uhi >= juint(t._lo) (lemma 2.10), we must have jint(t._uhi) < 0\n+ *     similar to the reasoning above.\n+ *\n+ *     In this case, each element of t belongs to either [t._lo, jint(t._uhi)] or\n+ *     [jint(t._ulo), t._hi].\n+ *\n+ *     Below is an illustration of the TypeInt in this case, the intervals that\n+ *     the elements can be in are marked using the = symbol. Note how the\n+ *     negative range in the signed domain wrap around in the unsigned domain.\n+ *\n+ *     Signed:\n+ *     -----lo=========uhi---------0--------ulo==========hi-----\n+ *     Unsigned:\n+ *                                 0--------ulo==========hi----------lo=========uhi---------\n+ *\n+ *   This property is useful for our analysis of TypeInt values. Additionally,\n+ *   it can be seen that _lo and jint(_uhi) are both < 0 or both >= 0, and the\n+ *   same applies to jint(_ulo) and _hi.\n+ *\n+ *   We call [_lo, jint(_uhi)] and [jint(_ulo), _hi] \"simple intervals\". Then,\n+ *   a TypeInt consists of 2 simple intervals, each of which has its bounds\n+ *   being both >= 0 or both < 0. If both simple intervals lie in the same half\n+ *   of the integer domain, they must be the same (i.e _lo == jint(_ulo) and\n+ *   _hi == jint(_uhi)). Otherwise, [_lo, jint(_uhi)] must lie in the negative\n+ *   half and [jint(_ulo), _hi] must lie in the non-negative half of the signed\n+ *   domain (equivalently, [_lo, jint(_uhi)] must lie in the upper half and\n+ *   [jint(_ulo), _hi] must lie in the lower half of the unsigned domain).\n+ *\/\n+class TypeInt : public TypeInteger {\n+private:\n+  TypeInt(const TypeIntPrototype<jint, juint>& t, int w, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen, bool dual);\n@@ -647,0 +809,1 @@\n+  friend class TypeIntHelper;\n@@ -648,6 +811,1 @@\n-\/\/------------------------------TypeInt----------------------------------------\n-\/\/ Class of integer ranges, the set of integers between a lower bound and an\n-\/\/ upper bound, inclusive.\n-class TypeInt : public TypeInteger {\n-  TypeInt( jint lo, jint hi, int w );\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -658,1 +816,1 @@\n-  virtual bool eq( const Type *t ) const;\n+  virtual bool eq(const Type* t) const;\n@@ -662,1 +820,5 @@\n-  const jint _lo, _hi;          \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeInt if it satisfies all\n+  \/\/ the below constraints, see contains(jint)\n+  const jint _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const juint _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<juint> _bits;\n@@ -664,1 +826,1 @@\n-  static const TypeInt *make(jint lo);\n+  static const TypeInt* make(jint con);\n@@ -666,1 +828,2 @@\n-  static const TypeInt *make(jint lo, jint hi, int w);\n+  static const TypeInt* make(jint lo, jint hi, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jint, juint>& t, int widen);\n@@ -669,1 +832,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -671,1 +834,5 @@\n-  jint get_con() const { assert(is_con(), \"\" );  return _lo; }\n+  jint get_con() const { assert(is_con(), \"\");  return _lo; }\n+  \/\/ Check if a jint\/TypeInt is a subset of this TypeInt (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jint i) const;\n+  bool contains(const TypeInt* t) const;\n@@ -673,1 +840,1 @@\n-  virtual bool        is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n@@ -675,4 +842,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -685,23 +852,25 @@\n-  static const TypeInt *MAX;\n-  static const TypeInt *MIN;\n-  static const TypeInt *MINUS_1;\n-  static const TypeInt *ZERO;\n-  static const TypeInt *ONE;\n-  static const TypeInt *BOOL;\n-  static const TypeInt *CC;\n-  static const TypeInt *CC_LT;  \/\/ [-1]  == MINUS_1\n-  static const TypeInt *CC_GT;  \/\/ [1]   == ONE\n-  static const TypeInt *CC_EQ;  \/\/ [0]   == ZERO\n-  static const TypeInt *CC_LE;  \/\/ [-1,0]\n-  static const TypeInt *CC_GE;  \/\/ [0,1] == BOOL (!)\n-  static const TypeInt *BYTE;\n-  static const TypeInt *UBYTE;\n-  static const TypeInt *CHAR;\n-  static const TypeInt *SHORT;\n-  static const TypeInt *POS;\n-  static const TypeInt *POS1;\n-  static const TypeInt *INT;\n-  static const TypeInt *SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n-  static const TypeInt *TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n-\n-  static const TypeInt *as_self(const Type *t) { return t->is_int(); }\n+  static const TypeInt* MAX;\n+  static const TypeInt* MIN;\n+  static const TypeInt* MINUS_1;\n+  static const TypeInt* ZERO;\n+  static const TypeInt* ONE;\n+  static const TypeInt* BOOL;\n+  static const TypeInt* CC;\n+  static const TypeInt* CC_LT;  \/\/ [-1]  == MINUS_1\n+  static const TypeInt* CC_GT;  \/\/ [1]   == ONE\n+  static const TypeInt* CC_EQ;  \/\/ [0]   == ZERO\n+  static const TypeInt* CC_NE;  \/\/ [-1, 1]\n+  static const TypeInt* CC_LE;  \/\/ [-1,0]\n+  static const TypeInt* CC_GE;  \/\/ [0,1] == BOOL (!)\n+  static const TypeInt* BYTE;\n+  static const TypeInt* UBYTE;\n+  static const TypeInt* CHAR;\n+  static const TypeInt* SHORT;\n+  static const TypeInt* NON_ZERO;\n+  static const TypeInt* POS;\n+  static const TypeInt* POS1;\n+  static const TypeInt* INT;\n+  static const TypeInt* SYMINT; \/\/ symmetric range [-max_jint..max_jint]\n+  static const TypeInt* TYPE_DOMAIN; \/\/ alias for TypeInt::INT\n+\n+  static const TypeInt* as_self(const Type* t) { return t->is_int(); }\n@@ -709,1 +878,2 @@\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const;\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+  void dump_verbose() const;\n@@ -713,4 +883,1 @@\n-\n-\/\/------------------------------TypeLong---------------------------------------\n-\/\/ Class of long integer ranges, the set of integers between a lower bound and\n-\/\/ an upper bound, inclusive.\n+\/\/ Similar to TypeInt\n@@ -718,1 +885,6 @@\n-  TypeLong( jlong lo, jlong hi, int w );\n+private:\n+  TypeLong(const TypeIntPrototype<jlong, julong>& t, int w, bool dual);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen, bool dual);\n+\n+  friend class TypeIntHelper;\n+\n@@ -721,1 +893,1 @@\n-  virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;\n+  virtual const Type* filter_helper(const Type* kills, bool include_speculative) const;\n@@ -729,1 +901,5 @@\n-  const jlong _lo, _hi;         \/\/ Lower bound, upper bound\n+  \/\/ A value is in the set represented by this TypeLong if it satisfies all\n+  \/\/ the below constraints, see contains(jlong)\n+  const jlong _lo, _hi;       \/\/ Lower bound, upper bound in the signed domain\n+  const julong _ulo, _uhi;    \/\/ Lower bound, upper bound in the unsigned domain\n+  const KnownBits<julong> _bits;\n@@ -731,1 +907,1 @@\n-  static const TypeLong *make(jlong lo);\n+  static const TypeLong* make(jlong con);\n@@ -733,1 +909,2 @@\n-  static const TypeLong *make(jlong lo, jlong hi, int w);\n+  static const TypeLong* make(jlong lo, jlong hi, int widen);\n+  static const Type* make_or_top(const TypeIntPrototype<jlong, julong>& t, int widen);\n@@ -736,1 +913,1 @@\n-  bool is_con() const { return _lo==_hi; }\n+  bool is_con() const { return _lo == _hi; }\n@@ -739,0 +916,4 @@\n+  \/\/ Check if a jlong\/TypeLong is a subset of this TypeLong (i.e. all elements of the\n+  \/\/ argument are also elements of this type)\n+  bool contains(jlong i) const;\n+  bool contains(const TypeLong* t) const;\n@@ -748,4 +929,4 @@\n-  virtual const Type *xmeet( const Type *t ) const;\n-  virtual const Type *xdual() const;    \/\/ Compute dual right now.\n-  virtual const Type *widen( const Type *t, const Type* limit_type ) const;\n-  virtual const Type *narrow( const Type *t ) const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  virtual const Type* widen(const Type* t, const Type* limit_type) const;\n+  virtual const Type* narrow(const Type* t) const;\n@@ -753,10 +934,12 @@\n-  static const TypeLong *MAX;\n-  static const TypeLong *MIN;\n-  static const TypeLong *MINUS_1;\n-  static const TypeLong *ZERO;\n-  static const TypeLong *ONE;\n-  static const TypeLong *POS;\n-  static const TypeLong *LONG;\n-  static const TypeLong *INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n-  static const TypeLong *UINT;   \/\/ 32-bit unsigned [0..max_juint]\n-  static const TypeLong *TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n+  static const TypeLong* MAX;\n+  static const TypeLong* MIN;\n+  static const TypeLong* MINUS_1;\n+  static const TypeLong* ZERO;\n+  static const TypeLong* ONE;\n+  static const TypeLong* NON_ZERO;\n+  static const TypeLong* POS;\n+  static const TypeLong* NEG;\n+  static const TypeLong* LONG;\n+  static const TypeLong* INT;    \/\/ 32-bit subrange [min_jint..max_jint]\n+  static const TypeLong* UINT;   \/\/ 32-bit unsigned [0..max_juint]\n+  static const TypeLong* TYPE_DOMAIN; \/\/ alias for TypeLong::LONG\n@@ -765,1 +948,1 @@\n-  static const TypeLong *as_self(const Type *t) { return t->is_long(); }\n+  static const TypeLong* as_self(const Type* t) { return t->is_long(); }\n@@ -768,1 +951,2 @@\n-  virtual void dump2( Dict &d, uint, outputStream *st  ) const;\/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const;\/\/ Specialized per-Type dumping\n+  void dump_verbose() const;\n@@ -2445,0 +2629,10 @@\n+template <>\n+inline const TypeInt* Type::try_cast<TypeInt>() const {\n+  return isa_int();\n+}\n+\n+template <>\n+inline const TypeLong* Type::try_cast<TypeLong>() const {\n+  return isa_long();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":262,"deletions":68,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -3603,0 +3603,7 @@\n+\n+    Array<u1>* old_table = scratch_class->fieldinfo_search_table();\n+    Array<u1>* search_table = FieldInfoStream::create_search_table(scratch_class->constants(), new_fis, scratch_class->class_loader_data(), CHECK);\n+    scratch_class->set_fieldinfo_search_table(search_table);\n+    MetadataFactory::free_array<u1>(scratch_class->class_loader_data(), old_table);\n+\n+    DEBUG_ONLY(FieldInfoStream::validate_search_table(scratch_class->constants(), new_fis, search_table));\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2528,1 +2528,1 @@\n-      if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {\n+      if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (size_t)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1531,1 +1531,1 @@\n-  product_pd(uintx, CodeCacheSegmentSize, EXPERIMENTAL,                     \\\n+  product_pd(size_t, CodeCacheSegmentSize, EXPERIMENTAL,                    \\\n@@ -1546,1 +1546,1 @@\n-  product_pd(uintx, InitialCodeCacheSize,                                   \\\n+  product_pd(size_t, InitialCodeCacheSize,                                  \\\n@@ -1550,1 +1550,1 @@\n-  develop_pd(uintx, CodeCacheMinimumUseSpace,                               \\\n+  develop_pd(size_t, CodeCacheMinimumUseSpace,                              \\\n@@ -1552,1 +1552,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1557,1 +1557,1 @@\n-  product_pd(uintx, ReservedCodeCacheSize,                                  \\\n+  product_pd(size_t, ReservedCodeCacheSize,                                 \\\n@@ -1561,1 +1561,1 @@\n-  product_pd(uintx, NonProfiledCodeHeapSize,                                \\\n+  product_pd(size_t, NonProfiledCodeHeapSize,                               \\\n@@ -1563,1 +1563,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1565,1 +1565,1 @@\n-  product_pd(uintx, ProfiledCodeHeapSize,                                   \\\n+  product_pd(size_t, ProfiledCodeHeapSize,                                  \\\n@@ -1567,1 +1567,1 @@\n-          range(0, max_uintx)                                               \\\n+          range(0, SIZE_MAX)                                                \\\n@@ -1569,1 +1569,1 @@\n-  product_pd(uintx, NonNMethodCodeHeapSize,                                 \\\n+  product_pd(size_t, NonNMethodCodeHeapSize,                                \\\n@@ -1573,1 +1573,1 @@\n-  product_pd(uintx, CodeCacheExpansionSize,                                 \\\n+  product_pd(size_t, CodeCacheExpansionSize,                                \\\n@@ -1575,1 +1575,1 @@\n-          range(32*K, max_uintx)                                            \\\n+          range(32*K, SIZE_MAX)                                             \\\n@@ -1577,1 +1577,1 @@\n-  product_pd(uintx, CodeCacheMinBlockLength, DIAGNOSTIC,                    \\\n+  product_pd(size_t, CodeCacheMinBlockLength, DIAGNOSTIC,                   \\\n@@ -2058,0 +2058,4 @@\n+                                                                            \\\n+  develop(uint, BinarySearchThreshold, 16,                                  \\\n+          \"Minimal number of elements in a sorted collection to prefer\"     \\\n+          \"binary search over simple linear search.\" )                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+void preuniverse_stubs_init();\n@@ -73,1 +74,1 @@\n-jint universe_init();           \/\/ depends on codeCache_init and initial_stubs_init\n+jint universe_init();           \/\/ depends on codeCache_init and preuniverse_stubs_init\n@@ -133,7 +134,4 @@\n-  \/\/ stub routines in initial blob are referenced by later generated code\n-  initial_stubs_init();\n-  \/\/ stack overflow exception blob is referenced by the interpreter\n-  SharedRuntime::generate_initial_stubs();\n-  jint status = universe_init();  \/\/ dependent on codeCache_init and\n-                                  \/\/ initial_stubs_init and metaspace_init.\n-  if (status != JNI_OK)\n+  \/\/ initialize stubs needed before we can init the universe\n+  preuniverse_stubs_init();\n+  jint status = universe_init();  \/\/ dependent on codeCache_init and preuniverse_stubs_init\n+  if (status != JNI_OK) {\n@@ -141,1 +139,1 @@\n-\n+  }\n@@ -149,1 +147,1 @@\n-  AOTCodeCache::init2();     \/\/ depends on universe_init\n+  AOTCodeCache::init2();     \/\/ depends on universe_init, must be before initial_stubs_init\n@@ -151,0 +149,5 @@\n+\n+  initial_stubs_init();      \/\/ initial stub routines\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n+  AOTCodeCache::init_early_stubs_table();  \/\/ need this after initial_stubs\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -578,0 +578,1 @@\n+    assert (StubRoutines::catch_exception_entry() != nullptr, \"must be generated before\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -294,5 +294,20 @@\n-  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n-  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n-  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n-  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n-  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+  static address throw_AbstractMethodError_entry()          {\n+    assert(_throw_AbstractMethodError_blob != nullptr, \"\");\n+    return _throw_AbstractMethodError_blob->entry_point();\n+  }\n+  static address throw_IncompatibleClassChangeError_entry() {\n+    assert(_throw_IncompatibleClassChangeError_blob != nullptr, \"\");\n+    return  _throw_IncompatibleClassChangeError_blob->entry_point();\n+  }\n+  static address throw_NullPointerException_at_call_entry() {\n+    assert(_throw_NullPointerException_at_call_blob != nullptr, \"\");\n+    return  _throw_NullPointerException_at_call_blob->entry_point();\n+  }\n+  static address throw_StackOverflowError_entry()           {\n+    assert(_throw_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_StackOverflowError_blob->entry_point();\n+  }\n+  static address throw_delayed_StackOverflowError_entry()   {\n+    assert(_throw_delayed_StackOverflowError_blob != nullptr, \"\");\n+    return _throw_delayed_StackOverflowError_blob->entry_point();\n+  }\n@@ -301,2 +316,8 @@\n-  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n-  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+  static address jfr_write_checkpoint() {\n+    assert(_jfr_write_checkpoint_blob != nullptr, \"\");\n+    return _jfr_write_checkpoint_blob->entry_point();\n+  }\n+  static address jfr_return_lease()     {\n+    assert(_jfr_return_lease_blob != nullptr, \"\");\n+    return _jfr_return_lease_blob->entry_point();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-\/\/ are generated in batches into one of four distinct BufferBlobs:\n+\/\/ are generated in batches into one of five distinct BufferBlobs:\n@@ -190,4 +190,5 @@\n-\/\/ 1) Initial stubs\n-\/\/ 2) Continuation stubs\n-\/\/ 3) Compiler stubs\n-\/\/ 4) Final stubs\n+\/\/ 1) PreUniverse stubs\n+\/\/ 2) Initial stubs\n+\/\/ 3) Continuation stubs\n+\/\/ 4) Compiler stubs\n+\/\/ 5) Final stubs\n@@ -281,0 +282,1 @@\n+\/\/   _preuniverse_stubs_code_size  =   500,\n@@ -514,0 +516,4 @@\n+#ifndef STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO\n+#error \"Arch-specific directory failed to declare required initial stubs and entries\"\n+#endif\n+\n@@ -546,1 +552,15 @@\n-#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                     \\\n+#define STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                 \\\n+                                     do_stub,                           \\\n+                                     do_entry, do_entry_init,           \\\n+                                     do_entry_array,                    \\\n+                                     do_arch_blob,                      \\\n+                                     do_arch_entry, do_arch_entry_init) \\\n+  do_blob(preuniverse)                                                  \\\n+  do_stub(preuniverse, fence)                                           \\\n+  do_entry(preuniverse, fence, fence_entry, fence_entry)                \\\n+  \/* merge in stubs and entries declared in arch header *\/              \\\n+  STUBGEN_PREUNIVERSE_BLOBS_ARCH_DO(do_stub, do_arch_blob,              \\\n+                                    do_arch_entry, do_arch_entry_init)  \\\n+  end_blob(preuniverse)                                                 \\\n+\n+#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                      \\\n@@ -563,2 +583,0 @@\n-  do_stub(initial, fence)                                               \\\n-  do_entry(initial, fence, fence_entry, fence_entry)                    \\\n@@ -1025,0 +1043,6 @@\n+  STUBGEN_PREUNIVERSE_BLOBS_DO(do_blob, end_blob,                       \\\n+                               do_stub,                                 \\\n+                               do_entry, do_entry_init,                 \\\n+                               do_entry_array,                          \\\n+                               do_arch_blob,                            \\\n+                               do_arch_entry, do_arch_entry_init)       \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -189,4 +189,0 @@\n-\/\/\n-\/\/ Note: to break cycle with universe initialization, stubs are generated in two phases.\n-\/\/ The first one generates stubs needed during universe init (e.g., _handle_must_compile_first_entry).\n-\/\/ The second phase includes all other stubs (which may depend on universe being initialized.)\n@@ -202,0 +198,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n@@ -212,0 +209,1 @@\n+  assert(UnsafeMemoryAccess::_table != nullptr, \"\");\n@@ -228,0 +226,8 @@\n+  if (code_size == 0) {\n+    LogTarget(Info, stubs) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"%s\\t not generated\", buffer_name);\n+      return nullptr;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-  static CallStub call_stub()                              { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n+  static CallStub call_stub()                              { assert(_call_stub_entry != nullptr, \"\"); return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -775,1 +775,1 @@\n-    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n+    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -322,0 +322,1 @@\n+        java.security.sasl,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-compiler\/startup\/StartupOutput.java 8358129 windows-all\n+compiler\/c2\/aarch64\/TestStaticCallStub.java 8359963 linux-aarch64,macosx-aarch64\n@@ -302,1 +302,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/TestDescription.java 8358094 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-        Process[] pr = new Process[200];\n@@ -68,6 +67,1 @@\n-            pr[i] = pb.start();\n-        }\n-        for (int i = 0; i < 200; i++) {\n-            out = new OutputAnalyzer(pr[i]);\n-            \/\/ The VM should not crash but will probably fail with a \"CodeCache is full. Compiler has been disabled.\" message\n-            out.stdoutShouldNotContain(\"# A fatal error\");\n+            out = new OutputAnalyzer(pb.start());\n@@ -78,0 +72,2 @@\n+            \/\/ The VM should not crash but will probably fail with a \"CodeCache is full. Compiler has been disabled.\" message\n+            out.stdoutShouldNotContain(\"# A fatal error\");\n","filename":"test\/hotspot\/jtreg\/compiler\/startup\/StartupOutput.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"}]}