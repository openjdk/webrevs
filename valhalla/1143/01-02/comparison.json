{"files":[{"patch":"@@ -49,0 +49,1 @@\n+        checkValueOfDouble();\n@@ -377,0 +378,38 @@\n+\n+\n+    private static void checkValueOfDouble() {\n+        \/*\n+         * Check that double -> Float16 conversion rounds propertly\n+         * around the widway point for each finite Float16 value.\n+         *\/\n+        for(int i = 0; i <= Short.MAX_VALUE; i++ ) {\n+            \/\/ Start by just checking positive values...\n+            boolean isEven = ((i & 0x1) == 0);\n+\n+            Float16 f16 = Float16.shortBitsToFloat16((short)i);\n+\n+            if (!isFinite(f16))\n+                continue;\n+\n+            \/\/ System.out.println(\"\\t\" + toHexString(f16));\n+\n+            Float16 ulp = ulp(f16);\n+            double halfWay = f16.doubleValue() + ulp.doubleValue() * 0.5;\n+            \/\/ Under the round to nearest even rounding policy, the\n+            \/\/ half-way case should round down to the starting value\n+            \/\/ if the starting value is even; otherwise, it should round up.\n+            float roundedBack = valueOf(halfWay).floatValue();\n+\n+            \/\/ While we're here, check negations\n+            float roundedBackNeg = valueOf(-halfWay).floatValue();\n+            String roundUpMsg   = \"Didn't get half-way case rounding down\";\n+            String roundDownMsg = \"Didn't get half-way case rounding up\";\n+            if (isEven) {\n+                checkFloat16(f16,         roundedBack,    roundUpMsg);\n+                checkFloat16(negate(f16), roundedBackNeg, roundUpMsg);\n+            } else {\n+                checkFloat16(add(f16, ulp), roundedBack,                roundDownMsg);\n+                checkFloat16(subtract(negate(f16), ulp),roundedBackNeg, roundDownMsg);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/Float16\/BasicFloat16ArithTests.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"}]}