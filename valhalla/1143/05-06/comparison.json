{"files":[{"patch":"@@ -910,1 +910,1 @@\n-         * goes from -14 to 15. Therefore, the bit positions\n+         * goes from -14 to 15. Therefore, the individual powers of 2\n@@ -915,4 +915,0 @@\n-         * Consequently, a double can hold the exact sum of any two\n-         * Float16 values as the maximum difference in exponents of\n-         * Float16 values less than the precision width of double.\n-         *\n@@ -921,1 +917,1 @@\n-         * Float16, the result is of necessity correct since the one\n+         * Float16, the result is necessarily correct since the one\n@@ -937,1 +933,1 @@\n-         * exponents for nonzero finite results goes from 2^(-28)\n+         * exponents for nonzero finite results goes from 2^(-48)\n@@ -940,1 +936,1 @@\n-         * (31 -(-28) + 1 ) = 60 exceeds the precision of\n+         * (31 -(-48) + 1 ) = 80 exceeds the precision of\n@@ -951,4 +947,5 @@\n-         * Therefore, any product greater than 0x1.ffep15 + MAX_VALUE\n-         * = 0x1.ffdp16 will certainly overflow (under round to\n-         * nearest) since adding in c = -MAX_VALUE will still be above\n-         * the overflow threshold.\n+         * Therefore, for any product greater than or equal in\n+         * magnitude to (0x1.ffep15 + MAX_VALUE) = 0x1.ffdp16, the\n+         * final fma result will certainly overflow to infinity (under\n+         * round to nearest) since adding in c = -MAX_VALUE will still\n+         * be at or above the overflow threshold.\n@@ -964,11 +961,11 @@\n-         * logical significand. The third number being added in has\n-         * at most 11 contiguous bits in its significand and the\n-         * lowest bit position that could be set is\n-         * 2^(-24). Therefore, when the product has the maximum\n-         * in-range exponent, 2^15, a single double has enough\n-         * precision to hold down to the smallest subnormal bit\n-         * position, 15 - (-24) + 1 = 40 < 53. If the product was\n-         * large and overflowed when the third operand was added, this\n-         * would cause the exponent to increase to 16, which is within\n-         * the range of double, so the product-sum is exact and will\n-         * be correct when rounded to Float16.\n+         * logical significand. The third number being added in has at\n+         * most 11 contiguous bits in its significand and the lowest\n+         * bit position that could be set is 2^(-24). Therefore, when\n+         * the product has the maximum in-range exponent, 2^15, a\n+         * single double has enough precision to hold down to the\n+         * smallest subnormal bit position, 15 - (-24) + 1 = 40 <\n+         * 53. If the product was large and rounded up, increasing the\n+         * exponent, when the third operand was added, this would\n+         * cause the exponent to go up to 16, which is within the\n+         * range of double, so the product-sum is exact and will be\n+         * correct when rounded to Float16.\n@@ -981,1 +978,1 @@\n-         * with a leading exponent of about 4, the sum will not be\n+         * with an exponent of about 4, the sum will not be\n@@ -984,1 +981,1 @@\n-         * final Float16 result. Double rounding an lead to a\n+         * final Float16 result. Double rounding can lead to a\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -379,1 +379,0 @@\n-\n@@ -382,2 +381,4 @@\n-         * Check that double -> Float16 conversion rounds propertly\n-         * around the widway point for each finite Float16 value.\n+         * Check that double -> Float16 conversion rounds properly\n+         * around the midway point for each finite Float16 value by\n+         * looping over the positive values and checking the negations\n+         * along the way.\n@@ -385,0 +386,4 @@\n+\n+        String roundUpMsg   = \"Didn't get half-way case rounding down\";\n+        String roundDownMsg = \"Didn't get half-way case rounding up\";\n+\n@@ -386,1 +391,0 @@\n-            \/\/ Start by just checking positive values...\n@@ -388,1 +392,0 @@\n-\n@@ -390,0 +393,1 @@\n+            Float16 f16Neg = negate(f16);\n@@ -403,2 +407,0 @@\n-\n-            \/\/ While we're here, check negations\n@@ -406,2 +408,1 @@\n-            String roundUpMsg   = \"Didn't get half-way case rounding down\";\n-            String roundDownMsg = \"Didn't get half-way case rounding up\";\n+\n@@ -409,2 +410,2 @@\n-                checkFloat16(f16,         roundedBack,    roundDownMsg);\n-                checkFloat16(negate(f16), roundedBackNeg, roundDownMsg);\n+                checkFloat16(f16,    roundedBack,    roundDownMsg);\n+                checkFloat16(f16Neg, roundedBackNeg, roundDownMsg);\n@@ -412,2 +413,2 @@\n-                checkFloat16(add(f16, ulp), roundedBack,                roundUpMsg);\n-                checkFloat16(subtract(negate(f16), ulp),roundedBackNeg, roundUpMsg);\n+                checkFloat16(add(f16,         ulp), roundedBack,    roundUpMsg);\n+                checkFloat16(subtract(f16Neg, ulp), roundedBackNeg, roundUpMsg);\n@@ -418,1 +419,2 @@\n-            checkFloat16(f16,           valueOf(halfWayNextDown).floatValue(), roundDownMsg);\n+            checkFloat16(f16,    valueOf(halfWayNextDown).floatValue(),  roundDownMsg);\n+            checkFloat16(f16Neg, valueOf(-halfWayNextDown).floatValue(), roundDownMsg);\n@@ -422,1 +424,2 @@\n-            checkFloat16(add(f16, ulp), valueOf(halfWayNextUp).floatValue(),   roundUpMsg);\n+            checkFloat16(add(f16, ulp),         valueOf( halfWayNextUp).floatValue(), roundUpMsg);\n+            checkFloat16(subtract(f16Neg, ulp), valueOf(-halfWayNextUp).floatValue(), roundUpMsg);\n","filename":"test\/jdk\/java\/lang\/Float16\/BasicFloat16ArithTests.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"}]}