{"files":[{"patch":"@@ -773,1 +773,1 @@\n-        return valueOf(Math.sqrt(radicand.doubleValue());\n+        return valueOf(Math.sqrt(radicand.doubleValue()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329817\n+ * @summary Basic tests of Float16 arithmetic and similar operations\n+ *\/\n+\n+import static java.lang.Float16.*;\n+\n+public class BasicFloat16ArithTests {\n+    public static void main(String... args) {\n+        checkConstants();\n+        checkNegate();\n+        checkAbs();\n+        checkIsNaN();\n+        checkFiniteness();\n+        checkMinMax();\n+        checkArith();\n+        checkSqrt();\n+    }\n+\n+    \/*\n+     * The software implementation of Float16 delegates to float or\n+     * double operations for most of the actual computation. This\n+     * regression test takes that into account as it generally only\n+     * has limited tested to probe whether or not the proper\n+     * functionality is being delegated to.\n+     *\n+     * To make the test easier to read, float literals that are exact\n+     * upon conversion to Float16 are used for the test data.\n+     *\n+     * The float <-> Float16 conversions are well-tested from prior\n+     * work and are assumed to be correct by this regression test.\n+     *\/\n+\n+    private static void checkConstants() {\n+        checkInt(BYTES,          2, \"Float16.BYTES\");\n+        checkInt(MAX_EXPONENT,  15, \"Float16.MAX_EXPONENT\");\n+        checkInt(MIN_EXPONENT, -14, \"Float16.MIN_EXPONENT\");\n+        checkInt(PRECISION,     11, \"Float16.PRECISION\");\n+        checkInt(SIZE,          16, \"Float16.SIZE\");\n+\n+        checkFloat16(MIN_VALUE,  0x1.0p-24f, \"Float16.MIN_VALUE\");\n+        checkFloat16(MIN_NORMAL, 0x1.0p-14f, \"Float16.MIN_NORMAL\");\n+        checkFloat16(MAX_VALUE,  65504.0f,  \"Float16.MAX_VALUE\");\n+\n+        checkFloat16(POSITIVE_INFINITY,  Float.POSITIVE_INFINITY,  \"+infinity\");\n+        checkFloat16(NEGATIVE_INFINITY,  Float.NEGATIVE_INFINITY,  \"-infinity\");\n+        checkFloat16(NaN,                Float.NaN,            \"NaN\");\n+    }\n+    \n+    private static void checkInt(int value, int expected, String message) {\n+        if (value != expected) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %d, got %d\",\n+                                  message, expected, value));\n+        }\n+    }\n+\n+    private static void checkFloat16(Float16 value16, float expected, String message) {\n+        float value = value16.floatValue();\n+        if (Float.compare(value, expected) != 0) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %g (%a), got %g (%a)\",\n+                                  message, expected, expected, value, value));\n+        }\n+    }\n+\n+    private static void checkNegate() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,  -0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,  -1.0f},\n+\n+            {Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY},\n+            {Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+\n+            {Float.NaN, Float.NaN},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  negate(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"negate(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkAbs() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,   0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,   1.0f},\n+\n+            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+\n+            {Float.NaN, Float.NaN},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  abs(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"abs(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkIsNaN() {\n+        if (!isNaN(NaN)) {\n+            throwRE(\"Float16.isNaN() returns false for a NaN\");\n+        }\n+\n+        float[] testCases = {\n+            Float.NEGATIVE_INFINITY,\n+            Float.POSITIVE_INFINITY,\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var testCase : testCases) {\n+            boolean result = isNaN(valueOf(testCase));\n+            if (result) {\n+                throwRE(\"isNaN returned true for \" + testCase);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkFiniteness() {\n+        float[] infinities = {\n+            Float.NEGATIVE_INFINITY,\n+            Float.POSITIVE_INFINITY,\n+        };\n+\n+        for(var infinity : infinities) {\n+            boolean result1 = isFinite(valueOf(infinity));\n+            boolean result2 = isInfinite(valueOf(infinity));\n+\n+            if (result1) {\n+                throw new RuntimeException(\"Float16.isFinite returned true for \" + infinity);\n+            }\n+\n+            if (!result2) {\n+                throwRE(\"Float16.isInfinite returned false for \" + infinity);\n+            }\n+        }\n+\n+        if (isFinite(NaN)) {\n+            throwRE(\"Float16.isFinite() returns true for a NaN\");\n+        }\n+\n+        if (isInfinite(NaN)) {\n+            throwRE(\"Float16.isInfinite() returns true for a NaN\");\n+        }\n+\n+        float[] finities = {\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var finity : finities) {\n+            boolean result1 = isFinite(valueOf(finity));\n+            boolean result2 = isInfinite(valueOf(finity));\n+\n+            if (!result1) {\n+                throwRE(\"Float16.isFinite returned true for \" + finity);\n+            }\n+\n+            if (result2) {\n+                throwRE(\"Float16.isInfinite returned true for \" + finity);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkMinMax() {\n+        float small = 1.0f;\n+        float large = 2.0f;\n+\n+        if (min(valueOf(small), valueOf(large)).floatValue() != small) {\n+            throwRE(String.format(\"min(%g, %g) not equal to %g)\",\n+                                  small, large, small));\n+        }\n+\n+        if (max(valueOf(small), valueOf(large)).floatValue() != large) {\n+            throwRE(String.format(\"max(%g, %g) not equal to %g)\",\n+                                  small, large, large));\n+        }\n+    }\n+\n+    \/*\n+     * Cursory checks to make sure correct operation is being called\n+     * with arguments in proper order.\n+     *\/\n+    private static void checkArith() {\n+        float   a   = 1.0f;\n+        Float16 a16 = valueOf(a);\n+\n+        float   b   = 2.0f;\n+        Float16 b16 = valueOf(b);\n+\n+        if (add(a16, b16).floatValue() != (a + b)) {\n+            throwRE(\"failure with \" + a16 + \" + \" + b16);\n+        }\n+        if (add(b16, a16).floatValue() != (b + a)) {\n+            throwRE(\"failure with \" + b16 + \" + \" + a16);\n+        }\n+\n+        if (subtract(a16, b16).floatValue() != (a - b)) {\n+            throwRE(\"failure with \" + a16 + \" - \" + b16);\n+        }\n+        if (subtract(b16, a16).floatValue() != (b - a)) {\n+            throwRE(\"failure with \" + b16 + \" - \" + a16);\n+        }\n+\n+        if (multiply(a16, b16).floatValue() != (a * b)) {\n+            throwRE(\"failure with \" + a16 + \" * \" + b16);\n+        }\n+        if (multiply(b16, a16).floatValue() != (b * a)) {\n+            throwRE(\"failure with \" + b16 + \" * \" + a16);\n+        }\n+\n+        if (divide(a16, b16).floatValue() != (a \/ b)) {\n+            throwRE(\"failure with \" + a16 + \" \/ \" + b16);\n+        }\n+        if (divide(b16, a16).floatValue() != (b \/ a)) {\n+            throwRE(\"failure with \" + b16 + \" \/ \" + a16);\n+        }\n+        return;\n+    }\n+\n+    private static void checkSqrt() {\n+        float[][] testCases = {\n+            {-0.0f,   -0.0f},\n+            { 0.0f,    0.0f},\n+\n+            {1.0f,   1.0f},\n+            {4.0f,   2.0f},\n+            {9.0f,   3.0f},\n+\n+            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.NEGATIVE_INFINITY, Float.NaN},\n+\n+            {Float.NaN, Float.NaN},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  sqrt(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"sqrt(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void throwRE(String message) {\n+        throw new RuntimeException(message);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float16\/BasicFloat16ArithTests.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"}]}