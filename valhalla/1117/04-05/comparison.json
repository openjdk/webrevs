{"files":[{"patch":"@@ -91,2 +91,2 @@\n-     * A constant holding the positive infinity of type\n-     * {@code Float16}.\n+     * A constant holding the positive infinity of type {@code\n+     * Float16}.\n@@ -98,2 +98,2 @@\n-     * A constant holding the negative infinity of type\n-     * {@code Float16}.\n+     * A constant holding the negative infinity of type {@code\n+     * Float16}.\n@@ -104,2 +104,2 @@\n-     * A constant holding a Not-a-Number (NaN) value of type\n-     * {@code Float16}.\n+     * A constant holding a Not-a-Number (NaN) value of type {@code\n+     * Float16}.\n@@ -112,1 +112,1 @@\n-     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>, equal to 65504.0.\n+     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>, numerically equal to 65504.0.\n@@ -174,2 +174,2 @@\n-     * Returns a hexadecimal string representation of the\n-     * {@code Float16} argument.\n+     * Returns a hexadecimal string representation of the {@code\n+     * Float16} argument.\n@@ -205,1 +205,2 @@\n-    * {@return the value of a {@code short} converted to {@code Float16}}\n+    * {@return the value of an {@code int} converted to {@code\n+    * Float16}}\n@@ -207,1 +208,5 @@\n-    * @param  value a short value.\n+    * @param  value an {@code int} value.\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n@@ -209,3 +214,3 @@\n-    public static Float16 valueOf(short value) {\n-        \/\/ The conversion of a short to a float is numerically exact.\n-        return shortBitsToFloat16(floatToFloat16((float)value));\n+    public static Float16 valueOf(int value) {\n+        \/\/ int -> double conversion is exact\n+        return valueOf((double)value);\n@@ -214,0 +219,22 @@\n+   \/**\n+    * {@return the value of a {@code long} converted to {@code Float16}}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  value a {@code long} value.\n+    *\/\n+    public static Float16 valueOf(long value) {\n+        if (value < -65_504) {\n+            return Float16.NEGATIVE_INFINITY;\n+        } else {\n+            if (value > 65_504L) {\n+                return Float16.NEGATIVE_INFINITY;\n+            }\n+            \/\/ Remaining range of long, the integers in approx. +\/-\n+            \/\/ 2^16, all fit in a float so the correct conversion can\n+            \/\/ be done via an intermediate float conversion.\n+            return valueOf((float)value);\n+        }\n+    }\n@@ -216,1 +243,2 @@\n-    * {@return a {@code Float16} value rounded from the {@code float} argument}\n+    * {@return a {@code Float16} value rounded from the {@code float}\n+    * argument}\n@@ -225,1 +253,2 @@\n-    * {@return a {@code Float16} value rounded from the {@code double} argument}\n+    * {@return a {@code Float16} value rounded from the {@code double}\n+    * argument}\n@@ -305,10 +334,0 @@\n-    \/\/    \/**\n-    \/\/     * ...\n-    \/\/     * @apiNote\n-    \/\/     * This method corresponds to the convertFromInt operation defined\n-    \/\/     * in IEEE 754.\n-    \/\/     *\/\n-    \/\/    public static Float16 valueOf(long ell) \/\/ Is this needed for correctness?\n-    \/\/    public static Float16 valueOf(BigDecimal bd)\n-\n-\n@@ -316,2 +335,4 @@\n-     * Returns a {@code Float16} equal to the value\n-     * represented by the specified {@code String}.\n+     * Returns a {@code Float16} equal to the value represented by the\n+     * specified {@code String}.\n+     *\n+     * TODO: add note about rounding, etc.\n@@ -327,1 +348,1 @@\n-    public static Float16 parseFloat(String s) throws NumberFormatException {\n+    public static Float16 valueOf(String s) throws NumberFormatException {\n@@ -332,0 +353,8 @@\n+    \/\/    \/**\n+    \/\/     * ...\n+    \/\/     * @see BigDecimal#floatValue()\n+    \/\/     * @see BigDecimal#doubleValue()\n+    \/\/     *\/\n+    \/\/    public static Float16 valueOf(BigDecimal bd)\n+\n+\n@@ -586,0 +615,2 @@\n+     * @see Math.max(float, float)\n+     * @see Math.max(double, double)\n@@ -603,0 +634,2 @@\n+     * @see Math.min(float, float)\n+     * @see Math.min(double, double)\n@@ -613,1 +646,27 @@\n-    \/\/ TODO: add comment explaining 2p + 2 property and implementation.\n+    \/*\n+     * Note: for the basic arithmetic operations {+, -, *, \/} and\n+     * square root, among binary interchange formats (binary16,\n+     * binary32 a.k.a. float, binary64 a.k.a double, etc.) the \"2p + 2\"\n+     * property holds. That is, if one format has p bits of precision,\n+     * if the next larger format has at least 2p + 2 bits of\n+     * precision, arithmetic on the smaller format can be implemented by:\n+     *\n+     * 1) converting each argument to the wider format\n+     * 2) performing the operation in the wider format\n+     * 3) converting the result from 2) to the narrower format\n+     *\n+     * For example, this property hold between the formats used for the\n+     * float and double types. Therefore, the following is a valid\n+     * implementation of a float addition:\n+     *\n+     * float add(float addend, float augend) {\n+     *     return (float)((double)addend + (double)augend);\n+     * }\n+     *\n+     * The same property holds between the float16 format and\n+     * float. Therefore, the software implementations of Float16 {+,\n+     * -, *, \/} and square root below use the technique of widening\n+     * the Float16 arguments to float, performing the operation in\n+     * float arithmetic, and then rounding the float result to\n+     * Float16.\n+     *\/\n@@ -616,1 +675,2 @@\n-     * Adds two {@code Float16} values together as per the + operator semantics.\n+     * Adds two {@code Float16} values together as per the {@code +}\n+     * operator semantics.\n@@ -634,2 +694,3 @@\n-\/**\n-     * Subtracts two {@code Float16} values as per the - operator semantics.\n+    \/**\n+     * Subtracts two {@code Float16} values as per the {@code +}\n+     * operator semantics.\n@@ -654,1 +715,2 @@\n-     * Multiplies two {@code Float16} values as per the * operator semantics.\n+     * Multiplies two {@code Float16} values as per the {@code *}\n+     * operator semantics.\n@@ -673,1 +735,2 @@\n-     * Divides two {@code Float16} values as per the \/ operator semantics.\n+     * Divides two {@code Float16} values as per the {@code \/}\n+     * operator semantics.\n@@ -744,1 +807,15 @@\n-        \/\/ will be an exact double value. The number of significand\n+        \/\/ will be an exact double value.\n+        \/\/\n+        \/\/ Note: the above conclusion is *incorrect*. The exponent of\n+        \/\/ the product of a*b can be so large that Float16.MIN_VALUE\n+        \/\/ cannot be held in a single double.\n+        \/\/\n+        \/\/ However, Float16 values with the smallest and largest\n+        \/\/ exponents can be held in a single double with precision to\n+        \/\/ spare. Therefore, all the hard rounding cases should be\n+        \/\/ covered, but some more analysis is needed to verify the\n+        \/\/ correctness of that approach.\n+        \/\/\n+        \/\/ Case analysis is needed with c is large compared to a*b.\n+        \/\/\n+        \/\/ The number of significand\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":113,"deletions":36,"binary":false,"changes":149,"status":"modified"}]}