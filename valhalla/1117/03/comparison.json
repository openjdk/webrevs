{"files":[{"patch":"@@ -1033,1 +1033,0 @@\n-        int bin16ExpBits     = 0x7c00 & bin16arg;\n@@ -1038,1 +1037,1 @@\n-        final int SIGNIF_SHIFT = (FloatConsts.SIGNIFICAND_WIDTH - 11);\n+        final int SIGNIF_SHIFT = (Float.PRECISION - Float16.PRECISION);\n@@ -1042,1 +1041,1 @@\n-        \/\/ Extract binary16 exponent, remove its bias, add in the bias\n+        \/\/ Get unbiased binary16 exponent, add in the bias\n@@ -1046,1 +1045,1 @@\n-        int bin16Exp = (bin16ExpBits >> 10) - 15;\n+        int bin16Exp = Float16.getExponent0(floatBinary16);\n@@ -1064,1 +1063,1 @@\n-            << (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+            << (PRECISION - 1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import static java.lang.Float.float16ToFloat;\n+import static java.lang.Float.floatToFloat16;\n+\n@@ -51,0 +54,10 @@\n+ * @apiNote\n+ * The methods in this class generally have analogous methods in\n+ * either {@link Float}\/{@link Double} or {@link Math}\/{@link\n+ * StrictMath}. Unless otherwise specified, the handling of special\n+ * floating-point values such as {@linkplain #isNaN(Float16) NaN}\n+ * values, {@linkplain #isInfinite(Float16) infinities}, and signed\n+ * zeros of methods in this class is wholly analogous to the handling\n+ * of equivalent cases by methods in {@code Float}, {@code Double},\n+ * {@code Math}, etc.\n+ *\n@@ -59,1 +72,3 @@\n-public final class Float16 extends Number {\n+public final class Float16\n+    extends Number\n+    implements Comparable<Float16> {\n@@ -61,0 +76,1 @@\n+    private static final long serialVersionUID = 16; \/\/ Not needed for a value class?\n@@ -66,2 +82,1 @@\n-    * @param  value a short value.\n-    * @since  20\n+    * @param  bits a short value.\n@@ -69,2 +84,2 @@\n-    private Float16 (short value ) {\n-        this.value = value;\n+    private Float16 (short bits ) {\n+        this.value = bits;\n@@ -73,0 +88,116 @@\n+    \/\/ Do *not* define any public constructors\n+\n+    \/**\n+     * A constant holding the positive infinity of type\n+     * {@code Float16}.\n+     *\/\n+    public static final Float16 POSITIVE_INFINITY =\n+        shortBitsToFloat16(floatToFloat16(Float.POSITIVE_INFINITY));\n+\n+    \/**\n+     * A constant holding the negative infinity of type\n+     * {@code Float16}.\n+     *\/\n+    public static final Float16 NEGATIVE_INFINITY = valueOf(Float.NEGATIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding a Not-a-Number (NaN) value of type\n+     * {@code Float16}.\n+     *\/\n+    public static final Float16 NaN = valueOf(Float.NaN);\n+\n+    \/**\n+     * A constant holding the largest positive finite value of type\n+     * {@code Float16},\n+     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>, equal to 65504.0.\n+     *\/\n+    public static final Float16 MAX_VALUE = valueOf(0x1.ffcp15f);\n+\n+    \/**\n+     * A constant holding the smallest positive normal value of type\n+     * {@code Float16}, 2<sup>-14<\/sup>.\n+     *\/\n+    public static final Float16 MIN_NORMAL = valueOf(0x1.0p-14f);\n+\n+    \/**\n+     * A constant holding the smallest positive nonzero value of type\n+     * {@code Float16}, 2<sup>-24<\/sup>.\n+     *\/\n+    public static final Float16 MIN_VALUE = valueOf(0x1.0p-24f);\n+\n+    \/**\n+     * The number of bits used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\/\n+    public static final int SIZE = 16;\n+\n+    \/**\n+     * The number of bits in the significand of a {@code Float16}\n+     * value, {@value}.  This corresponds to parameter N in section\n+     * {@jls 4.2.3} of <cite>The Java Language Specification<\/cite>.\n+     *\/\n+    public static final int PRECISION = 11;\n+\n+    \/**\n+     * Maximum exponent a finite {@code Float16} variable may have,\n+     * {@value}.\n+     *\/\n+    public static final int MAX_EXPONENT = (1 << (SIZE - PRECISION - 1)) - 1; \/\/ 15\n+\n+    \/**\n+     * Minimum exponent a normalized {@code Float16} variable may\n+     * have, {@value}.\n+     *\/\n+    public static final int MIN_EXPONENT = 1 - MAX_EXPONENT; \/\/ -14\n+\n+    \/**\n+     * The number of bytes used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\/\n+    public static final int BYTES = SIZE \/ Byte.SIZE;\n+\n+    \/**\n+     * Returns a string representation of the {@code float16}\n+     * argument. All characters mentioned below are ASCII characters.\n+     *\n+     * TODO: elaborate on more detailed behavior\n+     *\n+     * @param   f16   the {@code float} to be converted.\n+     * @return a string representation of the argument.\n+     *\/\n+    public static String toString(Float16 f16) {\n+        \/\/ FIXME -- update for Float16 precision\n+        return FloatToDecimal.toString(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string representation of the\n+     * {@code Float16} argument.\n+     *\n+     * TODO: elaborate on more detailed behavior\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a hex string representation of the argument.\n+     *\n+     * @see Float#toHexString(float)\n+     * @see Double#toHexString(double)\n+     *\/\n+    public static String toHexString(Float16 f16) {\n+        float f = f16.floatValue();\n+        if (Math.abs(f) < float16ToFloat(Float16.MIN_NORMAL.value)\n+            &&  f != 0.0f ) {\/\/ Float16 subnormal\n+            \/\/ Adjust exponent to create subnormal double, then\n+            \/\/ replace subnormal double exponent with subnormal Float16\n+            \/\/ exponent\n+            String s = Double.toHexString(Math.scalb((double)f,\n+                                                     \/* -1022+14 *\/\n+                                                     Double.MIN_EXPONENT-\n+                                                     Float16.MIN_EXPONENT));\n+            return s.replaceFirst(\"p-1022$\", \"p-14\");\n+        } else {\/\/ double string will be the same as Float16 string\n+            return Double.toHexString(f);\n+        }\n+    }\n+\n+    \/\/ -----------------------\n+\n@@ -74,2 +205,1 @@\n-    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n-    * encoded {@code short} value.\n+    * {@return the value of a {@code short} converted to {@code Float16}}\n@@ -78,2 +208,0 @@\n-    * @return a {@code Float16} instance representing {@code value}.\n-    * @since  20\n@@ -82,1 +210,12 @@\n-       return new Float16(value);\n+        \/\/ The conversion of a short to a float is numerically exact.\n+        return shortBitsToFloat16(floatToFloat16((float)value));\n+    }\n+\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code float} argument}\n+    *\n+    * @param  f a {@code float}\n+    *\/\n+    public static Float16 valueOf(float f) {\n+        return new Float16(Float.floatToFloat16(f));\n@@ -85,0 +224,161 @@\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code double} argument}\n+    *\n+    * @param  d a {@code double}\n+    *\/\n+    public static Float16 valueOf(double d) {\n+        long doppel = Double.doubleToRawLongBits(d);\n+\n+        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> 48);\n+\n+        if (Double.isNaN(d)) {\n+            \/\/ Have existing float code handle any attempts to\n+            \/\/ preserve NaN bits.\n+            return valueOf((float)d);\n+        }\n+\n+        double abs_d = Math.abs(d);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_d >= (0x1.ffcp15 + 0x0.002p15) ) {\n+             \/\/ correctly signed infinity\n+            return new Float16((short)(sign_bit | 0x7c00));\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_d <= 0x1.0p-24d * 0.5d) { \/\/ Covers double zeros and subnormals.\n+            return new Float16(sign_bit); \/\/ Positive or negative zero\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of binary16\n+        \/\/ (when rounding is done, could still round up)\n+        int exp = Math.getExponent(d);\n+        assert -25 <= exp && exp <= 15;\n+\n+        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+        \/\/ the difference expdelta = E_min - exp.  This is the excess\n+        \/\/ shift value, in addition to 42, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in d must be involved as well.\n+        int expdelta = 0;\n+        long msb = 0x0000_0000_0000_0000L;\n+        if (exp < -14) {\n+            expdelta = -14 - exp; \/\/ FIXME?\n+            exp = -15;\n+            msb = 0x0010_0000_0000_0000L; \/\/ should be 0x0020_... ?\n+        }\n+        long f_signif_bits = doppel & 0x000f_ffff_ffff_ffffL | msb;\n+\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (42 + expdelta));\n+\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+        long lsb    = f_signif_bits & (1L << 42 + expdelta);\n+        long round  = f_signif_bits & (1L << 41 + expdelta);\n+        long sticky = f_signif_bits & ((1L << 41 + expdelta) - 1);\n+\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the significand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n+\n+        return new Float16((short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) ));\n+    }\n+\n+    \/\/    \/**\n+    \/\/     * ...\n+    \/\/     * @apiNote\n+    \/\/     * This method corresponds to the convertFromInt operation defined\n+    \/\/     * in IEEE 754.\n+    \/\/     *\/\n+    \/\/    public static Float16 valueOf(long ell) \/\/ Is this needed for correctness?\n+    \/\/    public static Float16 valueOf(BigDecimal bd)\n+\n+\n+    \/**\n+     * Returns a {@code Float16} equal to the value\n+     * represented by the specified {@code String}.\n+     *\n+     * @param  s the string to be parsed.\n+     * @return the {@code Float16} value represented by the string\n+     *         argument.\n+     * @throws NullPointerException  if the string is null\n+     * @throws NumberFormatException if the string does not contain a\n+     *               parsable {@code Float16}.\n+     * @see    java.lang.Float#valueOf(String)\n+     *\/\n+    public static Float16 parseFloat(String s) throws NumberFormatException {\n+        \/\/ TOOD: adjust precision of parsing if needed\n+        return shortBitsToFloat16(floatToFloat16(Float.parseFloat(s)));\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is a\n+     * Not-a-Number (NaN) value, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isNaN operation defined in IEEE\n+     * 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is NaN;\n+     *          {@code false} otherwise.\n+     *\/\n+    public static boolean isNaN(Float16 f16) {\n+        return Float.isNaN(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is infinitely\n+     * large in magnitude, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isInfinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is positive infinity or\n+     *          negative infinity; {@code false} otherwise.\n+     *\/\n+    public static boolean isInfinite(Float16 f16) {\n+        return Float.isInfinite(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the argument is a finite floating-point\n+     * value; returns {@code false} otherwise (for NaN and infinity\n+     * arguments).\n+     *\n+     * @apiNote\n+     * This method corresponds to the isFinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param f16 the {@code float} value to be tested\n+     * @return {@code true} if the argument is a finite\n+     * floating-point value, {@code false} otherwise.\n+     *\/\n+    public static boolean isFinite(Float16 f16) {\n+        return Float.isFinite(f16.floatValue());\n+     }\n+\n+    \/\/ Skipping for now\n+    \/\/ public boolean isNaN()\n+    \/\/ public boolean isInfinite() {\n+\n@@ -93,0 +393,1 @@\n+    @Override\n@@ -94,1 +395,11 @@\n-        return (byte)Float.float16ToFloat(value);\n+        return (byte)floatValue();\n+    }\n+\n+    \/**\n+     * {@return a string representation of this {@code Float16}}\n+     *\n+     * @see java.lang.Float#toString(float)\n+     *\/\n+    public String toString() {\n+        \/\/ Is this idiomatic?\n+        return Float16.toString(this);\n@@ -104,1 +415,0 @@\n-     * @since 1.1\n@@ -106,0 +416,1 @@\n+    @Override\n@@ -107,1 +418,1 @@\n-        return (short)Float.float16ToFloat(value);\n+        return (short)floatValue();\n@@ -112,1 +423,1 @@\n-     * a widening primitive conversion.\n+     * a narrowing primitive conversion.\n@@ -116,1 +427,1 @@\n-     * @jls 5.1.3 Widening Primitive Conversion\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n@@ -118,0 +429,1 @@\n+    @Override\n@@ -119,1 +431,1 @@\n-        return (int)Float.float16ToFloat(value);\n+        return (int)floatValue();\n@@ -124,1 +436,1 @@\n-     * widening conversion.\n+     * narrowing primitive conversion.\n@@ -128,1 +440,1 @@\n-     * @jls 5.1.3 Widening Primitive Conversion\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n@@ -130,0 +442,1 @@\n+    @Override\n@@ -131,1 +444,1 @@\n-        return (long)Float.float16ToFloat(value);\n+        return (long)floatValue();\n@@ -139,0 +452,1 @@\n+     * @jls 5.1.2 Widening Primitive Conversion\n@@ -140,0 +454,1 @@\n+    @Override\n@@ -141,1 +456,1 @@\n-        return Float.float16ToFloat(value);\n+        return float16ToFloat(value);\n@@ -156,0 +471,1 @@\n+    @Override\n@@ -157,1 +473,1 @@\n-        return (double)Float.float16ToFloat(value);\n+        return (double)floatValue();\n@@ -160,0 +476,5 @@\n+    \/\/ Skipping for now:\n+    \/\/ public int hashCode()\n+    \/\/ public static int hashCode(Float16 value)\n+    \/\/ public boolean equals(Object obj)\n+\n@@ -163,3 +484,0 @@\n-     * @apiNote This method corresponds to the addition operation\n-     * defined in IEEE 754.\n-     *\n@@ -169,1 +487,0 @@\n-     * @since 20\n@@ -173,1 +490,1 @@\n-       return Float16.valueOf(Float.floatToFloat16(Float.float16ToFloat(a.float16ToRawShortBits()) + Float.float16ToFloat(b.float16ToRawShortBits())));\n+        return add(a, b);\n@@ -177,3 +494,189 @@\n-     * Return raw short value.\n-     * @return raw binary16 encoded {@code short} value represented by this object.\n-     * @since 20\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     *\n+     * @param   f16   a {@code Float16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n+     *\/\n+    public static short float16ToRawShortBits(Float16 f16) {\n+        return f16.value;\n+    }\n+\n+    \/**\n+     * Returns the {@code Float16} value corresponding to a given bit\n+     * representation.\n+     *\n+     * @param   bits   any {@code short} integer.\n+     * @return  the {@code Float16} floating-point value with the same\n+     *          bit pattern.\n+     *\n+     * @see Float#intBitsToFloat(int)\n+     * @see Double#longBitsToDouble(long)\n+     *\/\n+    public static Float16 shortBitsToFloat16(short bits) {\n+        return new Float16(bits);\n+    }\n+\n+    \/**\n+     * Compares two {@code Float16} objects numerically.\n+     *\n+     * This method imposes a total order on {@code Float16} objects\n+     * with two differences compared to the incomplete order defined by\n+     * the Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code double} values.\n+     *\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Double.NaN} to be equal to itself and greater than all\n+     *          other {@code double} values (including {@code\n+     *          Double.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero ({@code +0.0d}),\n+     *      to be greater than negative zero ({@code -0.0d}).\n+     * <\/ul>\n+     *\n+     * @param   anotherFloat16   the {@code Float16} to be compared.\n+     * @return  the value {@code 0} if {@code anotherFloat16} is\n+     *          numerically equal to this {@code Float16}; a value\n+     *          less than {@code 0} if this {@code Float16}\n+     *          is numerically less than {@code anotherFloat16};\n+     *          and a value greater than {@code 0} if this\n+     *          {@code Float16} is numerically greater than\n+     *          {@code anotherFloat16}.\n+     *\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+     *\/\n+    @Override\n+    public int compareTo(Float16 anotherFloat16) {\n+        return Float16.compare(this, anotherFloat16);\n+    }\n+\n+    \/**\n+     * Compares the two specified {@code Float16} values.\n+     *\n+     * @param   f1        the first {@code Float16} to compare\n+     * @param   f2        the second {@code Float16} to compare\n+     * @return  the value {@code 0} if {@code f1} is\n+     *          numerically equal to {@code f2}; a value less than\n+     *          {@code 0} if {@code f1} is numerically less than\n+     *          {@code f2}; and a value greater than {@code 0}\n+     *          if {@code f1} is numerically greater than\n+     *          {@code f2}.\n+     *\/\n+    public static int compare(Float16 f1, Float16 f2) {\n+        return Float.compare(f1.floatValue(), f2.floatValue());\n+    }\n+\n+    \/**\n+     * Returns the greater of two {@code Floa16t} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the maximum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     *\/\n+    public static Float16 max(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.max(a.floatValue(),\n+                                                          b.floatValue() )));\n+    }\n+\n+    \/**\n+     * Returns the smaller of two {@code float} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the minimum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     *\/\n+    public static Float16 min(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.min(a.floatValue(),\n+                                                          b.floatValue()) ));\n+    }\n+\n+    \/\/ Skipping for now\n+    \/\/ public Optional<Float16> describeConstable()\n+    \/\/ public Float16 resolveConstantDesc(MethodHandles.Lookup lookup)\n+\n+    \/\/ TODO: add comment explaining 2p + 2 property and implementation.\n+\n+    \/**\n+     * Adds two {@code Float16} values together as per the + operator semantics.\n+     *\n+     * @apiNote This method corresponds to the addition operation\n+     * defined in IEEE 754.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\n+     * @jls 15.18.2 Additive Operators ({@code +} and {@code -}) for Numeric Types\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 add(Float16 addend, Float16 augend) {\n+        return shortBitsToFloat16(floatToFloat16(addend.floatValue()\n+                                                 +\n+                                                 augend.floatValue() ));\n+    }\n+\n+\/**\n+     * Subtracts two {@code Float16} values as per the - operator semantics.\n+     *\n+     * @apiNote This method corresponds to the subtraction operation\n+     * defined in IEEE 754.\n+     *\n+     * @param minuend the first operand\n+     * @param  subtrahend the second operand\n+     * @return the difference of the operands\n+     *\n+     * @jls 15.18.2 Additive Operators (+ and -) for Numeric Types\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 subtract(Float16 minuend, Float16 subtrahend) {\n+        return shortBitsToFloat16(floatToFloat16(minuend.floatValue()\n+                                                 -\n+                                                 subtrahend.floatValue() ));\n+    }\n+\n+    \/**\n+     * Multiplies two {@code Float16} values as per the * operator semantics.\n+     *\n+     * @apiNote This method corresponds to the multiplication\n+     * operation defined in IEEE 754.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\n+     * @jls 15.17.1 Multiplication Operator {@code *}\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 multiply(Float16 multiplier, Float16 multiplicand) {\n+       return shortBitsToFloat16(floatToFloat16(float16ToFloat(multiplier.value)\n+                                                *\n+                                                float16ToFloat(multiplicand.value) ));\n+    }\n+\n+    \/**\n+     * Divides two {@code Float16} values as per the \/ operator semantics.\n+     *\n+     * @apiNote This method corresponds to the division\n+     * operation defined in IEEE 754.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\n+     * @jls 15.17.2 Division Operator {@code \/}\n@@ -181,1 +684,158 @@\n-    public short float16ToRawShortBits() { return value; }\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 divide(Float16 dividend, Float16 divisor) {\n+       return shortBitsToFloat16(floatToFloat16(float16ToFloat(dividend.value)\n+                                                \/\n+                                                float16ToFloat(divisor.value) ));\n+    }\n+\n+    \/**\n+     * {@return the square root of the operand}\n+     *\n+     * @apiNote\n+     * This method corresponds to the squareRoot operation defined in\n+     * IEEE 754.\n+     *\n+     * @param radicand the argument to have its square root taken\n+     *\n+     * @see Math#sqrt(float)\n+     * @see Math#sqrt(double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 sqrt(Float16 radicand) {\n+        \/\/ Rounding path of sqrt(Float16 -> float -> double) -> float\n+        \/\/ -> Float16 is fine for preserving the correct final\n+        \/\/ value. The sequence of conversions Float16 -> float ->\n+        \/\/ double preserves the exact numerical value. Each of the\n+        \/\/ double -> float and float -> Float16 conversions benefits\n+        \/\/ from the 2p+2 property of IEEE 754 arithmetic.\n+        return shortBitsToFloat16(floatToFloat16((float)Math.sqrt(radicand.floatValue())));\n+    }\n+\n+    \/**\n+     * Returns the fused multiply add of the three arguments; that is,\n+     * returns the exact product of the first two arguments summed\n+     * with the third argument and then rounded once to the nearest\n+     * {@code Float16}.\n+     *\n+     * @apiNote This method corresponds to the fusedMultiplyAdd\n+     * operation defined in IEEE 754.\n+     *\n+     * @param a a value\n+     * @param b a value\n+     * @param c a value\n+     *\n+     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n+     * computed, as if with unlimited range and precision, and rounded\n+     * once to the nearest {@code Float16} value\n+     *\n+     * @see Math#fma(float, float, float)\n+     * @see Math#fma(double, double, double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 fma(Float16 a, Float16 b, Float16 c) {\n+        \/\/ A simple scaling up to call a float or double fma doesn't\n+        \/\/ always work as double-rounding can occur and the sticky bit\n+        \/\/ information can be lost for rounding to a Float16 position.\n+        \/\/\n+        \/\/ The quantity:\n+        \/\/\n+        \/\/ convertToDouble(a)*convertToDouble(b) + convertToDouble(c)\n+        \/\/\n+        \/\/ will be an exact double value. The number of significand\n+        \/\/ bits in double, 53, is greater than the, maximum difference\n+        \/\/ in exponent values between bit positions of minimum and\n+        \/\/ maximum magnitude for Float16. Therefore, performing a*b+c\n+        \/\/ in double and then doing a single rounding of that value to\n+        \/\/ Float16 will implement this operation.\n+\n+        return valueOf( ( ((double)a.floatValue()) * (double)b.floatValue() )\n+                        +\n+                        ((double)c.floatValue()) );\n+    }\n+\n+    \/**\n+     * {@return the negation root of the argument}\n+     * @param f16 the value to be negated\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 negate(Float16 f16) {\n+        \/\/ Negate sign bit only. Per IEE 754-2019 section 5.5.1,\n+        \/\/ negate is a bit-level operation and not a logical\n+        \/\/ operation.\n+        return shortBitsToFloat16((short)(f16.value ^ (short)0x0000_8000));\n+    }\n+\n+    \/**\n+     * {@return the absolute value of the argument}\n+     * @param f16 the argument whose absolute value is to be determined\n+     *\n+     * @see Math#abs(float)\n+     * @see Math#abs(double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 abs(Float16 f16) {\n+        \/\/ Zero out sign bit. Per IEE 754-2019 section 5.5.1, abs is a\n+        \/\/ bit-level operation and not a logical operation.\n+        return shortBitsToFloat16((short)(f16.value & (short)0x0000_7FFF));\n+    }\n+\n+    \/**\n+     * Returns the unbiased exponent used in the representation of a\n+     * {@code Float16}.\n+     *\n+     * @param f16 a {@code Floa16t} value\n+     * @return the unbiased exponent of the argument\n+     *\n+     * @see Math#getExponent(float)\n+     * @see Math#getExponent(double)\n+     *\/\n+    public static int getExponent(Float16 f16) {\n+        return getExponent0(f16.value);\n+    }\n+\n+    \/**\n+     * From the bitwise representation of a float16, mask out exponent\n+     * bits, shift to the right and then subtract out float16's bias\n+     * adjust, 15, to get true exponent value.\n+     *\/\n+    \/*package*\/ static int getExponent0(short bits) {\n+        \/\/ package private to be usable in java.lang.Float.\n+        int bin16ExpBits     = 0x0000_7c00 & bits;     \/\/ Five exponent bits.\n+        return (bin16ExpBits >> (PRECISION - 1)) - 15;\n+    }\n+\n+    \/**\n+     * Returns the size of an ulp of the argument.  An ulp, unit in\n+     * the last place, of a {@code Float16} value is the positive\n+     * distance between this floating-point value and the {@code\n+     * double} value next larger in magnitude.  Note that for non-NaN\n+     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive or negative infinity, then the\n+     * result is positive infinity.\n+     * <li> If the argument is positive or negative zero, then the result is\n+     * {@code Float16.MIN_VALUE}.\n+     * <li> If the argument is &plusmn;{@code Float16.MAX_VALUE}, then\n+     * the result is equal to 2<sup>5<\/sup>, 32.0.\n+     * <\/ul>\n+     *\n+     * @param f16 the floating-point value whose ulp is to be returned\n+     * @return the size of an ulp of the argument\n+     *\/\n+    public static Float16 ulp(Float16 f16) {\n+        int exp = getExponent(f16);\n+\n+        return switch(exp) {\n+        case Float16.MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n+        case Float16.MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        default -> {\n+            assert exp <= Float16.MAX_EXPONENT && exp >= Float16.MIN_EXPONENT;\n+            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+            \/\/ Let float -> float16 conversion handle encoding issues.\n+            yield valueOf(Math.scalb(1.0f, exp - (PRECISION - 1)));\n+        }\n+        };\n+    }\n@@ -183,1 +843,6 @@\n-    private static final long serialVersionUID = 16; \/\/ Not needed for a primitive class?\n+    \/\/ To be considered:\n+    \/\/ copysign\n+    \/\/ scalb\n+    \/\/ nextUp \/ nextDown\n+    \/\/ IEEEremainder\n+    \/\/ signum\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":697,"deletions":32,"binary":false,"changes":729,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @compile -XDenablePrimitiveClasses FP16ReductionOperations.java\n- * @run main\/othervm -XX:+EnablePrimitiveClasses -XX:-TieredCompilation -Xbatch FP16ReductionOperations\n+ * @compile FP16ReductionOperations.java\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch FP16ReductionOperations\n@@ -34,0 +34,2 @@\n+import static java.lang.Float16.*;\n+\n@@ -39,6 +41,6 @@\n-        Float16 hf0 = Float16.valueOf((short)0);\n-        Float16 hf1 = Float16.valueOf((short)15360);\n-        Float16 hf2 = Float16.valueOf((short)16384);\n-        Float16 hf3 = Float16.valueOf((short)16896);\n-        Float16 hf4 = Float16.valueOf((short)17408);\n-        return Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4).float16ToRawShortBits();\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        return float16ToRawShortBits(Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4));\n@@ -48,10 +50,10 @@\n-        Float16 hf0 = Float16.valueOf((short)0);\n-        Float16 hf1 = Float16.valueOf((short)15360);\n-        Float16 hf2 = Float16.valueOf((short)16384);\n-        Float16 hf3 = Float16.valueOf((short)16896);\n-        Float16 hf4 = Float16.valueOf((short)17408);\n-        return Float.floatToFloat16(Float.float16ToFloat(hf0.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf1.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf2.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf3.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf4.float16ToRawShortBits()));\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        return Float.floatToFloat16(Float.float16ToFloat(float16ToRawShortBits(hf0)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf1)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf2)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf3)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf4)));\n@@ -80,1 +82,1 @@\n-        Float16 res = Float16.valueOf((short)0);\n+        Float16 res = shortBitsToFloat16((short)0);\n@@ -82,1 +84,1 @@\n-            res = Float16.sum(res, Float16.valueOf(arr[i]));\n+            res = Float16.sum(res, shortBitsToFloat16(arr[i]));\n@@ -84,1 +86,1 @@\n-        return res.float16ToRawShortBits();\n+        return float16ToRawShortBits(res);\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ReductionOperations.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @compile -XDenablePrimitiveClasses FP16ScalarOperations.java\n- * @run main\/othervm -XX:+EnablePrimitiveClasses -XX:-TieredCompilation -Xbatch FP16ScalarOperations\n+ * @compile FP16ScalarOperations.java\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch FP16ScalarOperations\n@@ -34,0 +34,2 @@\n+import static java.lang.Float16.*;\n+\n@@ -39,2 +41,2 @@\n-        Float16 obj1 = Float16.valueOf(val1);\n-        Float16 obj2 = Float16.valueOf(val2);\n+        Float16 obj1 = shortBitsToFloat16(val1);\n+        Float16 obj2 = shortBitsToFloat16(val2);\n@@ -42,1 +44,1 @@\n-            case '+' : return Float16.sum(obj1, obj2).float16ToRawShortBits();\n+            case '+' : return float16ToRawShortBits(Float16.sum(obj1, obj2));\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}