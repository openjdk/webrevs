{"files":[{"patch":"@@ -42,2 +42,2 @@\n- * The {@code Float16} is a primitive value class holding 16-bit data in IEEE 754 binary16 format\n- * {@code Float16} contains a single field whose type is {@code short}.\n+ * The {@code Float16} is a primitive value class holding 16-bit data\n+ * in IEEE 754 binary16 format.\n@@ -45,5 +45,5 @@\n- * Binary16 Format:\n- *   S EEEEE  MMMMMMMMMM\n- *   Sign        - 1 bit\n- *   Exponent    - 5 bits\n- *   Significand - 10 bits\n+ * <p>Binary16 Format:<br>\n+ *   S EEEEE  MMMMMMMMMM<br>\n+ *   Sign        - 1 bit<br>\n+ *   Exponent    - 5 bits<br>\n+ *   Significand - 10 bits (does not include the <i>implicit bit<\/i> inferred from the exponent, see {@link #PRECISION})<br>\n@@ -54,0 +54,4 @@\n+ * <p>Unless otherwise specified, the methods in this class use a\n+ * <em>rounding policy<\/em> (JLS {@jls 15.4}) of {@linkplain\n+ * java.math.RoundingMode#HALF_EVEN round to nearest}.\n+ *\n@@ -78,0 +82,8 @@\n+    \/\/ Functionality for future consideration:\n+    \/\/ float16ToShortBits that normalizes NaNs\n+    \/\/ copysign\n+    \/\/ scalb\n+    \/\/ nextUp \/ nextDown\n+    \/\/ IEEEremainder \/ remainder operator remainder\n+    \/\/ signum\n+\n@@ -94,2 +106,1 @@\n-    public static final Float16 POSITIVE_INFINITY =\n-        shortBitsToFloat16(floatToFloat16(Float.POSITIVE_INFINITY));\n+    public static final Float16 POSITIVE_INFINITY = valueOf(Float.POSITIVE_INFINITY);\n@@ -160,2 +171,2 @@\n-     * Returns a string representation of the {@code float16}\n-     * argument. All characters mentioned below are ASCII characters.\n+     * Returns a string representation of the {@code Float16}\n+     * argument.\n@@ -163,1 +174,6 @@\n-     * TODO: elaborate on more detailed behavior\n+     * @implSpec\n+     * The current implementation acts as this {@code Float16} were\n+     * {@linkplain #floatValue() converted} to {@code float} and then\n+     * the string for that {@code float} returned. This behavior is\n+     * expected to change to accommodate the precision of {@code\n+     * Float16}.\n@@ -167,0 +183,1 @@\n+     * @see java.lang.Float#toString(float)\n@@ -177,1 +194,3 @@\n-     * TODO: elaborate on more detailed behavior\n+     * The behavior of this class is analogous to {@link\n+     * Float#toHexString(float)} except that an exponent value of\n+     * {@code \"p14\"} is used for subnormal {@code Float16} values.\n@@ -187,1 +206,1 @@\n-        if (Math.abs(f) < float16ToFloat(Float16.MIN_NORMAL.value)\n+        if (Math.abs(f) < float16ToFloat(MIN_NORMAL.value)\n@@ -195,1 +214,1 @@\n-                                                     Float16.MIN_EXPONENT));\n+                                                     MIN_EXPONENT));\n@@ -229,2 +248,2 @@\n-        if (value < -65_504) {\n-            return Float16.NEGATIVE_INFINITY;\n+        if (value < -65_504L) {\n+            return NEGATIVE_INFINITY;\n@@ -233,1 +252,1 @@\n-                return Float16.NEGATIVE_INFINITY;\n+                return NEGATIVE_INFINITY;\n@@ -244,1 +263,5 @@\n-    * argument}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n@@ -254,1 +277,5 @@\n-    * argument}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n@@ -335,2 +362,2 @@\n-     * Returns a {@code Float16} equal to the value represented by the\n-     * specified {@code String}.\n+     * Returns a {@code Float16} holding the floating-point value\n+     * represented by the argument string.\n@@ -338,1 +365,6 @@\n-     * TODO: add note about rounding, etc.\n+     * @implSpec\n+     * The current implementation acts as if the string were\n+     * {@linkplain Double#parseDouble(String) parsed} as a {@code\n+     * double} and then {@linkplain #valueOf(double) converted} to\n+     * {@code Float16}. This behavior is expected to change to\n+     * accommodate the precision of {@code Float16}.\n@@ -350,1 +382,1 @@\n-        return shortBitsToFloat16(floatToFloat16(Float.parseFloat(s)));\n+        return valueOf(Double.parseDouble(s));\n@@ -372,0 +404,3 @@\n+     *\n+     * @see Float#isNaN(float)\n+     * @see Double#isNaN(double)\n@@ -388,0 +423,3 @@\n+     *\n+     * @see Float#isInfinite(float)\n+     * @see Double#isInfinite(double)\n@@ -405,0 +443,3 @@\n+     *\n+     * @see Float#isFinite(float)\n+     * @see Double#isFinite(double)\n@@ -415,2 +456,2 @@\n-     * Returns the value of this {@code Float16} as a {@code byte} after\n-     * a narrowing primitive conversion.\n+     * {@return the value of this {@code Float16} as a {@code byte} after\n+     * a narrowing primitive conversion}\n@@ -418,2 +459,0 @@\n-     * @return  the binary16 encoded {@code short} value represented by this object\n-     *          converted to type {@code byte}\n@@ -430,1 +469,2 @@\n-     * @see java.lang.Float#toString(float)\n+     * @implSpec\n+     * This method returns the result of {@code Float16.toString(this)}.\n@@ -433,2 +473,1 @@\n-        \/\/ Is this idiomatic?\n-        return Float16.toString(this);\n+        return toString(this);\n@@ -438,2 +477,2 @@\n-     * Returns the value of this {@code Float16} as a {@code short}\n-     * after a narrowing primitive conversion.\n+     * {@return the value of this {@code Float16} as a {@code short}\n+     * after a narrowing primitive conversion}\n@@ -441,2 +480,0 @@\n-     * @return  the binary16 encoded {@code short} value represented by this object\n-     *          converted to type {@code short}\n@@ -451,2 +488,2 @@\n-     * Returns the value of this {@code Float16} as an {@code int} after\n-     * a narrowing primitive conversion.\n+     * {@return the value of this {@code Float16} as an {@code int} after\n+     * a narrowing primitive conversion}\n@@ -454,2 +491,0 @@\n-     * @return  the binary16 encoded {@code short} value represented by this object\n-     *          converted to type {@code int}\n@@ -464,2 +499,2 @@\n-     * Returns value of this {@code Float16} as a {@code long} after a\n-     * narrowing primitive conversion.\n+     * {@return value of this {@code Float16} as a {@code long} after a\n+     * narrowing primitive conversion}\n@@ -467,2 +502,0 @@\n-     * @return  the binary16 encoded {@code short} value represented by this object\n-     *          converted to type {@code long}\n@@ -477,1 +510,6 @@\n-     * Returns the {@code float} value of this {@code Float16} object.\n+     * {@return the value of this {@code Float16} as a {@code float}\n+     * after a widening primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n@@ -479,2 +517,0 @@\n-     * @return the binary16 encoded {@code short} value represented by this object\n-     *         converted to type {@code float}\n@@ -489,2 +525,2 @@\n-     * Returns the value of this {@code Float16} as a {@code double}\n-     * after a widening primitive conversion.\n+     * {@return the value of this {@code Float16} as a {@code double}\n+     * after a widening primitive conversion}\n@@ -496,2 +532,0 @@\n-     * @return the binary16 encoded {@code short} value represented by this\n-     *         object converted to type {@code double}\n@@ -511,1 +545,5 @@\n-     * Adds two {@code Float16} values together as per the + operator semantics.\n+     * Adds two {@code Float16} values together as per the {@code +}\n+     * operator semantics.\n+     *\n+     * @implSpec\n+     * This method is operationally equivalent to {@link #add(Float16, Float16)}.\n@@ -557,1 +595,1 @@\n-     * ==, >=, >}) on {@code double} values.\n+     * ==, >=, >}) on {@code float} and {@code double} values.\n@@ -562,3 +600,3 @@\n-     *          Double.NaN} to be equal to itself and greater than all\n-     *          other {@code double} values (including {@code\n-     *          Double.POSITIVE_INFINITY}).\n+     *          Float16.NaN} to be equal to itself and greater than all\n+     *          other {@code Float16} values (including {@code\n+     *          Float16.POSITIVE_INFINITY}).\n@@ -568,2 +606,2 @@\n-     *      This method chooses to define positive zero ({@code +0.0d}),\n-     *      to be greater than negative zero ({@code -0.0d}).\n+     *      This method chooses to define positive zero\n+     *      to be greater than negative zero.\n@@ -581,0 +619,2 @@\n+     * @see Float#compareTo(Float)\n+     * @see Double#compareTo(Double)\n@@ -585,1 +625,1 @@\n-        return Float16.compare(this, anotherFloat16);\n+        return compare(this, anotherFloat16);\n@@ -599,0 +639,3 @@\n+     *\n+     * @see Float#compare(float, float)\n+     * @see Double#compare(double, double)\n@@ -676,1 +719,6 @@\n-     * operator semantics.\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code +} operator for\n+     * floating-point addition (JLS {@jls 15.18.2}).\n@@ -685,1 +733,1 @@\n-     * @jls 15.18.2 Additive Operators ({@code +} and {@code -}) for Numeric Types\n+     * @jls 15.4 Floating-point Expressions\n@@ -689,3 +737,1 @@\n-        return shortBitsToFloat16(floatToFloat16(addend.floatValue()\n-                                                 +\n-                                                 augend.floatValue() ));\n+        return valueOf(addend.floatValue() + augend.floatValue());\n@@ -696,1 +742,6 @@\n-     * operator semantics.\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code -} operator for\n+     * floating-point subtraction (JLS {@jls 15.18.2}).\n@@ -705,1 +756,1 @@\n-     * @jls 15.18.2 Additive Operators (+ and -) for Numeric Types\n+     * @jls 15.4 Floating-point Expressions\n@@ -709,3 +760,1 @@\n-        return shortBitsToFloat16(floatToFloat16(minuend.floatValue()\n-                                                 -\n-                                                 subtrahend.floatValue() ));\n+        return valueOf(minuend.floatValue() - subtrahend.floatValue());\n@@ -716,1 +765,6 @@\n-     * operator semantics.\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code *} operator for\n+     * floating-point multiplication (JLS {@jls 15.17.1}).\n@@ -725,1 +779,1 @@\n-     * @jls 15.17.1 Multiplication Operator {@code *}\n+     * @jls 15.4 Floating-point Expressions\n@@ -729,3 +783,1 @@\n-       return shortBitsToFloat16(floatToFloat16(float16ToFloat(multiplier.value)\n-                                                *\n-                                                float16ToFloat(multiplicand.value) ));\n+        return valueOf(multiplier.floatValue() * multiplicand.floatValue());\n@@ -736,1 +788,6 @@\n-     * operator semantics.\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code \/} operator for\n+     * floating-point division (JLS {@jls 15.17.2}).\n@@ -745,1 +802,1 @@\n-     * @jls 15.17.2 Division Operator {@code \/}\n+     * @jls 15.4 Floating-point Expressions\n@@ -749,3 +806,1 @@\n-       return shortBitsToFloat16(floatToFloat16(float16ToFloat(dividend.value)\n-                                                \/\n-                                                float16ToFloat(divisor.value) ));\n+        return valueOf(dividend.floatValue() \/ divisor.floatValue());\n@@ -755,1 +810,6 @@\n-     * {@return the square root of the operand}\n+     * {@return the square root of the operand} The square root is\n+     * computed using the round to nearest rounding policy.\n+     *\n+     * The handling of zeros, NaN, infinities, and negative arguments\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#sqrt(double)}.\n@@ -782,0 +842,4 @@\n+     * The handling of zeros, NaN, infinities, and other special cases\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#fma(float, float, float)}.\n+     *\n@@ -827,3 +891,1 @@\n-        return valueOf( ( ((double)a.floatValue()) * (double)b.floatValue() )\n-                        +\n-                        ((double)c.floatValue()) );\n+        return valueOf( (a.doubleValue() * b.doubleValue()) +  c.doubleValue());\n@@ -833,1 +895,15 @@\n-     * {@return the negation root of the argument}\n+     * {@return the negation of the argument}\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * opposite sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the opposite sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method corresponds to the negate operation defined in IEEE\n+     * 754.\n+     *\n@@ -835,0 +911,1 @@\n+     * @jls 15.15.4 Unary Minus Operator {@code -}\n@@ -838,1 +915,1 @@\n-        \/\/ Negate sign bit only. Per IEE 754-2019 section 5.5.1,\n+        \/\/ Negate sign bit only. Per IEEE 754-2019 section 5.5.1,\n@@ -840,1 +917,3 @@\n-        \/\/ operation.\n+        \/\/ operation. Therefore, in this case do _not_ use the float\n+        \/\/ unary minus as an implementation as that is not guaranteed\n+        \/\/ to flip the sign bit of a NaN.\n@@ -846,0 +925,5 @@\n+     *\n+     * The handling of zeros, NaN, and infinities by this method is\n+     * analogous to the handling of those cases by {@link\n+     * Math#abs(float)}.\n+     *\n@@ -862,1 +946,12 @@\n-     * @param f16 a {@code Floa16t} value\n+     * <ul>\n+     * <li>If the argument is NaN or infinite, then the result is\n+     * {@link Float16#MAX_EXPONENT} + 1.\n+     * <li>If the argument is zero or subnormal, then the result is\n+     * {@link Float16#MIN_EXPONENT} - 1.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method is analogous to the logB operation defined in IEEE\n+     * 754, but returns a different value on subnormal arguments.\n+     *\n+     * @param f16 a {@code Float16} value\n@@ -887,1 +982,1 @@\n-     * double} value next larger in magnitude.  Note that for non-NaN\n+     * Float16} value next larger in magnitude.  Note that for non-NaN\n@@ -908,2 +1003,2 @@\n-        case Float16.MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n-        case Float16.MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        case MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n+        case MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n@@ -911,1 +1006,1 @@\n-            assert exp <= Float16.MAX_EXPONENT && exp >= Float16.MIN_EXPONENT;\n+            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT;\n@@ -918,7 +1013,0 @@\n-\n-    \/\/ To be considered:\n-    \/\/ copysign\n-    \/\/ scalb\n-    \/\/ nextUp \/ nextDown\n-    \/\/ IEEEremainder\n-    \/\/ signum\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":185,"deletions":97,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+        checkGetExponent();\n+        checkUlp();\n@@ -301,0 +303,65 @@\n+    private static void checkGetExponent() {\n+        float[][] testCases = {\n+            {Float.POSITIVE_INFINITY, MAX_EXPONENT + 1},\n+            {Float.POSITIVE_INFINITY, MAX_EXPONENT + 1},\n+            {Float.NaN,               MAX_EXPONENT + 1},\n+\n+            {-0.0f,      MIN_EXPONENT - 1},\n+            {+0.0f,      MIN_EXPONENT - 1},\n+            {0x1.0p-24f, MIN_EXPONENT - 1}, \/\/ Float16.MIN_VALUE\n+            {0x1.0p-14f, MIN_EXPONENT},     \/\/ Float16.MIN_NORMAL\n+            {1.0f,       0},\n+            {2.0f,       1},\n+            {4.0f,       2},\n+\n+            {0x1.ffcp14f,  MAX_EXPONENT - 1},  \/\/ Float16.MAX_VALUE * 0.5\n+            {0x1.ffcp15f,  MAX_EXPONENT},      \/\/ Float16.MAX_VALUE\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            \/\/ Exponents are in-range for Float16\n+            Float16 result =  valueOf(getExponent(valueOf(arg)));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"getExponent(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    private static void checkUlp() {\n+        float[][] testCases = {\n+            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.NaN,               Float.NaN},\n+\n+            \/\/ Zeros, subnormals, and MIN_VALUE all have MIN_VALUE as an ulp.\n+            {-0.0f,      0x1.0p-24f},\n+            {+0.0f,      0x1.0p-24f},\n+            {0x1.0p-24f, 0x1.0p-24f},\n+            {0x1.0p-14f, 0x1.0p-24f},\n+\n+            \/\/ ulp is 10 bits away\n+            {0x1.0p0f,       0x0.004p0f}, \/\/ 1.0f\n+            {0x1.0p1f,       0x0.004p1f}, \/\/ 2.0f\n+            {0x1.0p2f,       0x0.004p2f}, \/\/ 4.0f\n+\n+            {0x1.ffcp14f,  0x0.004p14f},  \/\/ Test Float16.MAX_VALUE * 0.5\n+            {0x1.ffcp15f,  0x0.004p15f},  \/\/ Test Float16.MAX_VALUE\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            \/\/ Exponents are in-range for Float16\n+            Float16 result =  ulp(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"ulp(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Float16\/BasicFloat16ArithTests.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"}]}