{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import static java.lang.Float.float16ToFloat;\n+import static java.lang.Float.floatToFloat16;\n+\n@@ -57,1 +60,2 @@\n-public primitive class Float16 extends Number {\n+public \/*primitive*\/ class Float16 extends Number\n+ \/* implements Comparable<Float16>*\/ { \/\/ Not supported\n@@ -59,0 +63,117 @@\n+    private static final long serialVersionUID = 16; \/\/ Not needed for a primitive class?\n+\n+    \/**\n+     * A constant holding the positive infinity of type\n+     * {@code Float16}.\n+     *\/\n+    public static final Float16 POSITIVE_INFINITY =\n+        shortBitsToFloat16(floatToFloat16(Float.POSITIVE_INFINITY));\n+\n+    \/**\n+     * A constant holding the negative infinity of type\n+     * {@code Float16}.\n+     *\/\n+    public static final Float16 NEGATIVE_INFINITY =\n+        shortBitsToFloat16(floatToFloat16(Float.NEGATIVE_INFINITY));\n+\n+    \/**\n+     * A constant holding a Not-a-Number (NaN) value of type\n+     * {@code Float16}.\n+     *\/\n+    public static final Float16 NaN =\n+        shortBitsToFloat16(floatToFloat16(Float.NaN));\n+\n+    \/**\n+     * A constant holding the largest positive finite value of type\n+     * {@code Float16},\n+     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>.\n+     *\/\n+    public static final Float16 MAX_VALUE =\n+        shortBitsToFloat16(floatToFloat16(0x1.ffcp15f));\n+\n+    \/**\n+     * A constant holding the smallest positive normal value of type\n+     * {@code Float16}, 2<sup>-14<\/sup>.\n+     *\/\n+    public static final Float16 MIN_NORMAL =\n+        shortBitsToFloat16(floatToFloat16(0x1.0p-14f));\n+\n+    \/**\n+     * A constant holding the smallest positive nonzero value of type\n+     * {@code Float16}, 2<sup>-24<\/sup>.\n+     *\/\n+    public static final Float16 MIN_VALUE =\n+        shortBitsToFloat16(floatToFloat16(0x1.0p-24f));\n+\n+    \/**\n+     * The number of bits used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\/\n+    public static final int SIZE = 16;\n+\n+    \/**\n+     * The number of bits in the significand of a {@code Float16}\n+     * value, {@value}.  This corresponds to parameter N in section\n+     * {@jls 4.2.3} of <cite>The Java Language Specification<\/cite>.\n+     *\/\n+    public static final int PRECISION = 11;\n+\n+    \/**\n+     * Maximum exponent a finite {@code Float16} variable may have,\n+     * {@value}.\n+     *\/\n+    public static final int MAX_EXPONENT = (1 << (SIZE - PRECISION - 1)) - 1; \/\/ 15\n+\n+    \/**\n+     * Minimum exponent a normalized {@code Float16} variable may\n+     * have, {@value}.\n+     *\/\n+    public static final int MIN_EXPONENT = 1 - MAX_EXPONENT; \/\/ -14\n+\n+    \/**\n+     * The number of bytes used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\/\n+    public static final int BYTES = SIZE \/ Byte.SIZE;\n+\n+    \/**\n+     * Returns a string representation of the {@code float16}\n+     * argument. All characters mentioned below are ASCII characters.\n+     *\n+     * TODO: elaborate on more detailed behavior\n+     *\n+     * @param   f16   the {@code float} to be converted.\n+     * @return a string representation of the argument.\n+     *\/\n+    public static String toString(Float16 f16) {\n+        \/\/ FIXME -- update for Float16 precision\n+        return FloatToDecimal.toString(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string representation of the\n+     * {@code Float16} argument.\n+     *\n+     * TODO: elaborate on more detailed behavior\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a hex string representation of the argument.\n+     *\/\n+    public static String toHexString(Float16 f16) {\n+        float f = f16.floatValue();\n+        if (Math.abs(f) < float16ToFloat(Float16.MIN_NORMAL.value)\n+            &&  f != 0.0f ) {\/\/ Float16 subnormal\n+            \/\/ Adjust exponent to create subnormal double, then\n+            \/\/ replace subnormal double exponent with subnormal Float16\n+            \/\/ exponent\n+            String s = Double.toHexString(Math.scalb((double)f,\n+                                                     \/* -1022+14 *\/\n+                                                     Double.MIN_EXPONENT-\n+                                                     Float16.MIN_EXPONENT));\n+            return s.replaceFirst(\"p-1022$\", \"p-14\");\n+        } else {\/\/ double string will be the same as Float16 string\n+            return Double.toHexString(f);\n+        }\n+    }\n+\n+    \/\/ -----------------------\n@@ -72,2 +193,1 @@\n-    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n-    * encoded {@code short} value.\n+    * {@return the value of a {@code short} converted to {@code Float16}}\n@@ -76,2 +196,0 @@\n-    * @return a {@code Float16} instance representing {@code value}.\n-    * @since  20\n@@ -80,1 +198,57 @@\n-       return new Float16(value);\n+        \/\/ The conversion of a short to a float is numerically exact.\n+        return shortBitsToFloat16(floatToFloat16((float)value));\n+    }\n+\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code double} argument}\n+    *\n+    * @param  d a {@code double}\n+    *\/\n+    public static Float16 valueOf(double d) {\n+        \/\/ Adapt logic from float to float16 conversion.\n+        throw new UnsupportedOperationException(\"TBD\");\n+    }\n+\n+    \/\/    \/**\n+    \/\/     * ...\n+    \/\/     * @apiNote\n+    \/\/     * This method corresponds to the convertFromInt operation defined\n+    \/\/     * in IEEE 754.\n+    \/\/     *\/\n+    \/\/    public static Float16 valueOf(long ell) \/\/ Is this needed for correctness?\n+    \/\/    public static Float16 valueOf(float f)\n+    \/\/    public static Float16 valueOf(BigDecimal bd)\n+\n+\n+    \/**\n+     * Returns a new {@code Float16} initialized to the value\n+     * represented by the specified {@code String}.\n+     *\n+     * @param  s the string to be parsed.\n+     * @return the {@code Float16} value represented by the string\n+     *         argument.\n+     * @throws NullPointerException  if the string is null\n+     * @throws NumberFormatException if the string does not contain a\n+     *               parsable {@code float}.\n+     * @see    java.lang.Float#valueOf(String)\n+     *\/\n+    public static Float16 parseFloat(String s) throws NumberFormatException {\n+        \/\/ TOOD: adjust precision of parsing if needed\n+        return shortBitsToFloat16(floatToFloat16(Float.parseFloat(s)));\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is a\n+     * Not-a-Number (NaN) value, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isNaN operation defined in IEEE\n+     * 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is NaN;\n+     *          {@code false} otherwise.\n+     *\/\n+    public static boolean isNaN(Float16 f16) {\n+        return Float.isNaN(f16.floatValue());\n@@ -83,0 +257,40 @@\n+    \/**\n+     * Returns {@code true} if the specified number is infinitely\n+     * large in magnitude, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isInfinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is positive infinity or\n+     *          negative infinity; {@code false} otherwise.\n+     *\/\n+    public static boolean isInfinite(Float16 f16) {\n+        return Float.isInfinite(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the argument is a finite floating-point\n+     * value; returns {@code false} otherwise (for NaN and infinity\n+     * arguments).\n+     *\n+     * @apiNote\n+     * This method corresponds to the isFinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param f16 the {@code float} value to be tested\n+     * @return {@code true} if the argument is a finite\n+     * floating-point value, {@code false} otherwise.\n+     *\/\n+    public static boolean isFinite(Float16 f16) {\n+        return Float.isFinite(f16.floatValue());\n+     }\n+\n+    \/\/ Do not define any public constructors\n+\n+    \/\/ Skipping for now\n+    \/\/ public boolean isNaN()\n+    \/\/ public boolean isInfinite() {\n+\n+\n@@ -91,0 +305,1 @@\n+    @Override\n@@ -92,1 +307,11 @@\n-        return (byte)Float.float16ToFloat(value);\n+        return (byte)float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * {@return a string representation of this {@code Float16}}\n+     *\n+     * @see java.lang.Float#toString(float)\n+     *\/\n+    public String toString() {\n+        \/\/ Is this idiomatic?\n+        return Float16.toString(this);\n@@ -104,0 +329,1 @@\n+    @Override\n@@ -105,1 +331,1 @@\n-        return (short)Float.float16ToFloat(value);\n+        return (short)float16ToFloat(value);\n@@ -116,0 +342,1 @@\n+    @Override\n@@ -117,1 +344,1 @@\n-        return (int)Float.float16ToFloat(value);\n+        return (int)floatValue();\n@@ -128,0 +355,1 @@\n+    @Override\n@@ -129,1 +357,1 @@\n-        return (long)Float.float16ToFloat(value);\n+        return (long)floatValue();\n@@ -138,0 +366,1 @@\n+    @Override\n@@ -139,1 +368,1 @@\n-        return Float.float16ToFloat(value);\n+        return float16ToFloat(value);\n@@ -154,0 +383,1 @@\n+    @Override\n@@ -155,1 +385,1 @@\n-        return (double)Float.float16ToFloat(value);\n+        return (double)floatValue();\n@@ -158,0 +388,5 @@\n+    \/\/ Skipping for now:\n+    \/\/ public int hashCode()\n+    \/\/ public static int hashCode(Float16 value)\n+    \/\/ public boolean equals(Object obj)\n+\n@@ -161,3 +396,0 @@\n-     * @apiNote This method corresponds to the addition operation\n-     * defined in IEEE 754.\n-     *\n@@ -171,1 +403,1 @@\n-       return Float16.valueOf(Float.floatToFloat16(Float.float16ToFloat(a.float16ToRawShortBits()) + Float.float16ToFloat(b.float16ToRawShortBits())));\n+        return add(a, b);\n@@ -175,3 +407,160 @@\n-     * Return raw short value.\n-     * @return raw binary16 encoded {@code short} value represented by this object.\n-     * @since 20\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     *\n+     * @param   f16   a {@code Float16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\/\n+    public static short float16ToRawShortBits(Float16 f16) {\n+        return f16.value;\n+    }\n+\n+    \/**\n+     * Returns the {@code Float16} value corresponding to a given\n+     *\n+     * @param   bits   any {@code short} integer.\n+     * @return  the {@code Float16} floating-point value with the same\n+     *          bit pattern.\n+     *\/\n+    public static Float16 shortBitsToFloat16(short bits) {\n+        return new Float16(bits);\n+    }\n+\n+\n+    \/**\n+     * Compares two {@code Float16} objects numerically.\n+     *\n+     * This method imposes a total order on {@code Float16} objects\n+     * with two differences compared to the incomplete order defined by\n+     * the Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code double} values.\n+     *\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Double.NaN} to be equal to itself and greater than all\n+     *          other {@code double} values (including {@code\n+     *          Double.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero ({@code +0.0d}),\n+     *      to be greater than negative zero ({@code -0.0d}).\n+     * <\/ul>\n+     *\n+     * @param   anotherFloat16   the {@code Float16} to be compared.\n+     * @return  the value {@code 0} if {@code anotherFloat16} is\n+     *          numerically equal to this {@code Float16}; a value\n+     *          less than {@code 0} if this {@code Float16}\n+     *          is numerically less than {@code anotherFloat16};\n+     *          and a value greater than {@code 0} if this\n+     *          {@code Float16} is numerically greater than\n+     *          {@code anotherFloat16}.\n+     *\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+     *\/\n+    \/\/ @Override\n+    public int compareTo(Float16 anotherFloat16) {\n+        return Float16.compare(this, anotherFloat16);\n+    }\n+\n+    \/**\n+     * Compares the two specified {@code Float16} values.\n+     *\n+     * @param   f1        the first {@code Float16} to compare\n+     * @param   f2        the second {@code Float16} to compare\n+     * @return  the value {@code 0} if {@code f1} is\n+     *          numerically equal to {@code f2}; a value less than\n+     *          {@code 0} if {@code f1} is numerically less than\n+     *          {@code f2}; and a value greater than {@code 0}\n+     *          if {@code f1} is numerically greater than\n+     *          {@code f2}.\n+     *\/\n+    public static int compare(Float16 f1, Float16 f2) {\n+        return Float.compare(f1.floatValue(), f2.floatValue());\n+    }\n+\n+    \/**\n+     * Returns the greater of two {@code Floa16t} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the maximum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     *\/\n+    public static Float16 max(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.max(a.floatValue(),\n+                                                          b.floatValue() )));\n+    }\n+\n+    \/**\n+     * Returns the smaller of two {@code float} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the minimum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     *\/\n+    public static Float16 min(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.min(a.floatValue(),\n+                                                          b.floatValue()) ));\n+    }\n+\n+    \/\/ Skipping for now\n+    \/\/ public Optional<Float16> describeConstable()\n+    \/\/ public Float16 resolveConstantDesc(MethodHandles.Lookup lookup)\n+\n+    \/\/ To add:\n+\n+    \/\/ Add comment explaining 2p + 2 property and implementation\n+\n+    \/**\n+     * Adds two {@code Float16} values together as per the + operator semantics.\n+     *\n+     * @apiNote This method corresponds to the addition operation\n+     * defined in IEEE 754.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 add(Float16 addend, Float16 augend) {\n+        return shortBitsToFloat16(floatToFloat16(addend.floatValue()\n+                                                 +\n+                                                 augend.floatValue() ));\n+    }\n+\n+\/**\n+     * Subtracts two {@code Float16} values as per the - operator semantics.\n+     *\n+     * @apiNote This method corresponds to the subtraction operation\n+     * defined in IEEE 754.\n+     *\n+     * @param minuend the first operand\n+     * @param  subtrahend the second operand\n+     * @return the difference of the operands\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 subtract(Float16 minuend, Float16 subtrahend) {\n+        return shortBitsToFloat16(floatToFloat16(minuend.floatValue()\n+                                                 -\n+                                                 subtrahend.floatValue() ));\n+    }\n+\n+    \/**\n+     * Multiplies two {@code Float16} values as per the * operator semantics.\n+     *\n+     * @apiNote This method corresponds to the multiplication\n+     * operation defined in IEEE 754.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n@@ -179,1 +568,104 @@\n-    public short float16ToRawShortBits() { return value; }\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 multiply(Float16 multiplier, Float16 multiplicand) {\n+       return shortBitsToFloat16(floatToFloat16(float16ToFloat(multiplier.value)\n+                                                *\n+                                                float16ToFloat(multiplicand.value) ));\n+    }\n+\n+\n+    \/**\n+     * Divides two {@code Float16} values as per the \/ operator semantics.\n+     *\n+     * @apiNote This method corresponds to the division\n+     * operation defined in IEEE 754.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 divide(Float16 dividend, Float16 divisor) {\n+       return shortBitsToFloat16(floatToFloat16(float16ToFloat(dividend.value)\n+                                                \/\n+                                                float16ToFloat(divisor.value) ));\n+    }\n+\n+    \/**\n+     * {@return the square root of the operand}\n+     *\n+     * @apiNote\n+     * This method corresponds to the squareRoot operation defined in\n+     * IEEE 754.\n+     *\n+     * @param radicand the argument to have its square root taken\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 sqrt(Float16 radicand) {\n+        \/\/ Rounding path of sqrt(Float16 -> float -> double) -> float\n+        \/\/ -> Float16 is fine for preserving the correct final\n+        \/\/ value. The sequence of conversions Float16 -> float ->\n+        \/\/ double preserves the exact numerical value. Each of the\n+        \/\/ double -> float and float -> Float16 conversions benefits\n+        \/\/ from the 2p+2 property of IEEE 754 arithmetic.\n+        return shortBitsToFloat16(floatToFloat16((float)Math.sqrt(radicand.floatValue())));\n+    }\n+\n+    \/**\n+     * Returns the fused multiply add of the three arguments; that is,\n+     * returns the exact product of the first two arguments summed\n+     * with the third argument and then rounded once to the nearest\n+     * {@code Float16}.\n+     *\n+     * @apiNote This method corresponds to the fusedMultiplyAdd\n+     * operation defined in IEEE 754.\n+     *\n+     * @param a a value\n+     * @param b a value\n+     * @param c a value\n+     *\n+     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n+     * computed, as if with unlimited range and precision, and rounded\n+     * once to the nearest {@code Float16} value\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 fma(Float16 a, Float16 b, Float16 c) {\n+        \/\/ A simple scaling up to call a float or double fma doesn't\n+        \/\/ always work as double-rounding can occur and the sticky bit\n+        \/\/ information can be lost for rounding to a Float16 position.\n+        \/\/\n+        \/\/ The quantity:\n+        \/\/\n+        \/\/ convertToDouble(a)*convertToDouble(b) + convertToDouble(c)\n+        \/\/\n+        \/\/ will be an exact double value. The number of significand\n+        \/\/ bits in double, 53, is greater than the, maximum difference\n+        \/\/ in exponent values between bit positions of minimum and\n+        \/\/ maximum magnitude for Float16. Therefore, performing a*b+c\n+        \/\/ in double and then doing a single rounding of that value to\n+        \/\/ Float16 will implement this operation.\n+\n+        return valueOf( ( ((double)a.floatValue()) * (double)b.floatValue() )  +\n+                        ((double)c.floatValue()) );\n+    }\n+\n+    \/**\n+     * {@return the negation root of the argument}\n+     * @param f16 the value to be negated\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 negate(Float16 f16) {\n+        \/\/ Negate sign bit only. Per IEE 754-2019 section 5.5.1,\n+        \/\/ negate is a bit-level operation and not a logical\n+        \/\/ operation.\n+        return shortBitsToFloat16((short)(f16.value ^ (short)0x0000_8000));\n+    }\n+\n+    \/\/ To be considered:\n+    \/\/ abs \/\/ bit-level per section 5.5.1\n+    \/\/ copysign\n+    \/\/ scalb\n+    \/\/ nextUp \/ nextDown\n+    \/\/ getExponent\n+    \/\/ IEEEremainder\n+    \/\/ signum\n+    \/\/ ulp\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":513,"deletions":21,"binary":false,"changes":534,"status":"modified"}]}