{"files":[{"patch":"@@ -78,0 +78,12 @@\n+   \/**\n+    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n+    * encoded {@code short} value.\n+    *\n+    * @param  bits a short value.\n+    *\/\n+    private Float16 (short bits ) {\n+        this.value = bits;\n+    }\n+\n+    \/\/ Do *not* define any public constructors\n+\n@@ -89,2 +101,1 @@\n-    public static final Float16 NEGATIVE_INFINITY =\n-        shortBitsToFloat16(floatToFloat16(Float.NEGATIVE_INFINITY));\n+    public static final Float16 NEGATIVE_INFINITY = valueOf(Float.NEGATIVE_INFINITY);\n@@ -96,2 +107,1 @@\n-    public static final Float16 NaN =\n-        shortBitsToFloat16(floatToFloat16(Float.NaN));\n+    public static final Float16 NaN = valueOf(Float.NaN);\n@@ -102,1 +112,1 @@\n-     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>.\n+     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>, equal to 65504.0.\n@@ -104,2 +114,1 @@\n-    public static final Float16 MAX_VALUE =\n-        shortBitsToFloat16(floatToFloat16(0x1.ffcp15f));\n+    public static final Float16 MAX_VALUE = valueOf(0x1.ffcp15f);\n@@ -111,2 +120,1 @@\n-    public static final Float16 MIN_NORMAL =\n-        shortBitsToFloat16(floatToFloat16(0x1.0p-14f));\n+    public static final Float16 MIN_NORMAL = valueOf(0x1.0p-14f);\n@@ -118,2 +126,1 @@\n-    public static final Float16 MIN_VALUE =\n-        shortBitsToFloat16(floatToFloat16(0x1.0p-24f));\n+    public static final Float16 MIN_VALUE = valueOf(0x1.0p-24f);\n@@ -197,11 +204,0 @@\n-   \/**\n-    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n-    * encoded {@code short} value.\n-    *\n-    * @param  value a short value.\n-    * @since  20\n-    *\/\n-    private Float16 (short value ) {\n-        this.value = value;\n-    }\n-\n@@ -219,0 +215,9 @@\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code float} argument}\n+    *\n+    * @param  f a {@code float}\n+    *\/\n+    public static Float16 valueOf(float f) {\n+        return new Float16(Float.floatToFloat16(f));\n+    }\n+\n@@ -225,2 +230,73 @@\n-        \/\/ Adapt logic from float to float16 conversion.\n-        throw new UnsupportedOperationException(\"TBD\");\n+        long doppel = Double.doubleToRawLongBits(d);\n+\n+        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> 48);\n+\n+        if (Double.isNaN(d)) {\n+            \/\/ Have existing float code handle any attempts to\n+            \/\/ preserve NaN bits.\n+            return valueOf((float)d);\n+        }\n+\n+        double abs_d = Math.abs(d);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_d >= (0x1.ffcp15 + 0x0.002p15) ) {\n+             \/\/ correctly signed infinity\n+            return new Float16((short)(sign_bit | 0x7c00));\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_d <= 0x1.0p-24d * 0.5d) { \/\/ Covers double zeros and subnormals.\n+            return new Float16(sign_bit); \/\/ Positive or negative zero\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of binary16\n+        \/\/ (when rounding is done, could still round up)\n+        int exp = Math.getExponent(d);\n+        assert -25 <= exp && exp <= 15;\n+\n+        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+        \/\/ the difference expdelta = E_min - exp.  This is the excess\n+        \/\/ shift value, in addition to 42, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in d must be involved as well.\n+        int expdelta = 0;\n+        long msb = 0x0000_0000_0000_0000L;\n+        if (exp < -14) {\n+            expdelta = -14 - exp; \/\/ FIXME?\n+            exp = -15;\n+            msb = 0x0010_0000_0000_0000L; \/\/ should be 0x0020_... ?\n+        }\n+        long f_signif_bits = doppel & 0x000f_ffff_ffff_ffffL | msb;\n+\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (42 + expdelta));\n+\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+        long lsb    = f_signif_bits & (1L << 42 + expdelta);\n+        long round  = f_signif_bits & (1L << 41 + expdelta);\n+        long sticky = f_signif_bits & ((1L << 41 + expdelta) - 1);\n+\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the significand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n+\n+        return new Float16((short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) ));\n@@ -236,1 +312,0 @@\n-    \/\/    public static Float16 valueOf(float f)\n@@ -241,1 +316,1 @@\n-     * Returns a new {@code Float16} initialized to the value\n+     * Returns a {@code Float16} equal to the value\n@@ -249,1 +324,1 @@\n-     *               parsable {@code float}.\n+     *               parsable {@code Float16}.\n@@ -306,2 +381,0 @@\n-    \/\/ Do not define any public constructors\n-\n@@ -312,1 +385,0 @@\n-\n@@ -323,1 +395,1 @@\n-        return (byte)float16ToFloat(value);\n+        return (byte)floatValue();\n@@ -346,1 +418,1 @@\n-        return (short)float16ToFloat(value);\n+        return (short)floatValue();\n@@ -351,1 +423,1 @@\n-     * a widening primitive conversion.\n+     * a narrowing primitive conversion.\n@@ -355,1 +427,1 @@\n-     * @jls 5.1.3 Widening Primitive Conversion\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n@@ -364,1 +436,1 @@\n-     * widening conversion.\n+     * narrowing primitive conversion.\n@@ -368,1 +440,1 @@\n-     * @jls 5.1.3 Widening Primitive Conversion\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n@@ -380,0 +452,1 @@\n+     * @jls 5.1.2 Widening Primitive Conversion\n@@ -414,1 +487,0 @@\n-     * @since 20\n@@ -436,1 +508,2 @@\n-     * Returns the {@code Float16} value corresponding to a given\n+     * Returns the {@code Float16} value corresponding to a given bit\n+     * representation.\n@@ -449,1 +522,0 @@\n-\n@@ -541,3 +613,1 @@\n-    \/\/ To add:\n-\n-    \/\/ Add comment explaining 2p + 2 property and implementation\n+    \/\/ TODO: add comment explaining 2p + 2 property and implementation.\n@@ -602,1 +672,0 @@\n-\n@@ -738,0 +807,36 @@\n+    \/**\n+     * Returns the size of an ulp of the argument.  An ulp, unit in\n+     * the last place, of a {@code Float16} value is the positive\n+     * distance between this floating-point value and the {@code\n+     * double} value next larger in magnitude.  Note that for non-NaN\n+     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive or negative infinity, then the\n+     * result is positive infinity.\n+     * <li> If the argument is positive or negative zero, then the result is\n+     * {@code Float16.MIN_VALUE}.\n+     * <li> If the argument is &plusmn;{@code Float16.MAX_VALUE}, then\n+     * the result is equal to 2<sup>5<\/sup>, 32.0.\n+     * <\/ul>\n+     *\n+     * @param f16 the floating-point value whose ulp is to be returned\n+     * @return the size of an ulp of the argument\n+     *\/\n+    public static Float16 ulp(Float16 f16) {\n+        int exp = getExponent(f16);\n+\n+        return switch(exp) {\n+        case Float16.MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n+        case Float16.MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        default -> {\n+            assert exp <= Float16.MAX_EXPONENT && exp >= Float16.MIN_EXPONENT;\n+            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+            \/\/ Let float -> float16 conversion handle encoding issues.\n+            yield valueOf(Math.scalb(1.0f, exp - (PRECISION - 1)));\n+        }\n+        };\n+    }\n+\n@@ -744,1 +849,0 @@\n-    \/\/ ulp\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":148,"deletions":44,"binary":false,"changes":192,"status":"modified"}]}