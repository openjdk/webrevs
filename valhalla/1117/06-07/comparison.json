{"files":[{"patch":"@@ -165,1 +165,1 @@\n-     * @param   f16   the {@code float} to be converted.\n+     * @param   f16   the {@code Float16} to be converted.\n@@ -402,1 +402,1 @@\n-     * @param f16 the {@code float} value to be tested\n+     * @param f16 the {@code Float16} value to be tested\n@@ -605,1 +605,1 @@\n-     * Returns the greater of two {@code Floa16t} values.\n+     * Returns the larger of two {@code Float16} values.\n@@ -624,1 +624,1 @@\n-     * Returns the smaller of two {@code float} values.\n+     * Returns the smaller of two {@code Float16} values.\n@@ -768,7 +768,6 @@\n-        \/\/ Rounding path of sqrt(Float16 -> float -> double) -> float\n-        \/\/ -> Float16 is fine for preserving the correct final\n-        \/\/ value. The sequence of conversions Float16 -> float ->\n-        \/\/ double preserves the exact numerical value. Each of the\n-        \/\/ double -> float and float -> Float16 conversions benefits\n-        \/\/ from the 2p+2 property of IEEE 754 arithmetic.\n-        return shortBitsToFloat16(floatToFloat16((float)Math.sqrt(radicand.floatValue())));\n+        \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n+        \/\/ for preserving the correct final value. The conversion\n+        \/\/ Float16 -> double preserves the exact numerical value. The\n+        \/\/ of the double -> Float16 conversion also benefits from the\n+        \/\/ 2p+2 property of IEEE 754 arithmetic.\n+        return valueOf(Math.sqrt(radicand.doubleValue());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"}]}