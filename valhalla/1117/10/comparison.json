{"files":[{"patch":"@@ -1033,1 +1033,0 @@\n-        int bin16ExpBits     = 0x7c00 & bin16arg;\n@@ -1038,1 +1037,1 @@\n-        final int SIGNIF_SHIFT = (FloatConsts.SIGNIFICAND_WIDTH - 11);\n+        final int SIGNIF_SHIFT = (Float.PRECISION - Float16.PRECISION);\n@@ -1042,1 +1041,1 @@\n-        \/\/ Extract binary16 exponent, remove its bias, add in the bias\n+        \/\/ Get unbiased binary16 exponent, add in the bias\n@@ -1046,1 +1045,1 @@\n-        int bin16Exp = (bin16ExpBits >> 10) - 15;\n+        int bin16Exp = Float16.getExponent0(floatBinary16);\n@@ -1064,1 +1063,1 @@\n-            << (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+            << (PRECISION - 1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import static java.lang.Float.float16ToFloat;\n+import static java.lang.Float.floatToFloat16;\n+\n@@ -51,0 +54,10 @@\n+ * @apiNote\n+ * The methods in this class generally have analogous methods in\n+ * either {@link Float}\/{@link Double} or {@link Math}\/{@link\n+ * StrictMath}. Unless otherwise specified, the handling of special\n+ * floating-point values such as {@linkplain #isNaN(Float16) NaN}\n+ * values, {@linkplain #isInfinite(Float16) infinities}, and signed\n+ * zeros of methods in this class is wholly analogous to the handling\n+ * of equivalent cases by methods in {@code Float}, {@code Double},\n+ * {@code Math}, etc.\n+ *\n@@ -59,1 +72,3 @@\n-public final class Float16 extends Number {\n+public final class Float16\n+    extends Number\n+    implements Comparable<Float16> {\n@@ -61,0 +76,1 @@\n+    private static final long serialVersionUID = 16; \/\/ Not needed for a value class?\n@@ -66,2 +82,131 @@\n-    * @param  value a short value.\n-    * @since  20\n+    * @param  bits a short value.\n+    *\/\n+    private Float16 (short bits ) {\n+        this.value = bits;\n+    }\n+\n+    \/\/ Do *not* define any public constructors\n+\n+    \/**\n+     * A constant holding the positive infinity of type {@code\n+     * Float16}.\n+     *\/\n+    public static final Float16 POSITIVE_INFINITY =\n+        shortBitsToFloat16(floatToFloat16(Float.POSITIVE_INFINITY));\n+\n+    \/**\n+     * A constant holding the negative infinity of type {@code\n+     * Float16}.\n+     *\/\n+    public static final Float16 NEGATIVE_INFINITY = valueOf(Float.NEGATIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding a Not-a-Number (NaN) value of type {@code\n+     * Float16}.\n+     *\/\n+    public static final Float16 NaN = valueOf(Float.NaN);\n+\n+    \/**\n+     * A constant holding the largest positive finite value of type\n+     * {@code Float16},\n+     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>, numerically equal to 65504.0.\n+     *\/\n+    public static final Float16 MAX_VALUE = valueOf(0x1.ffcp15f);\n+\n+    \/**\n+     * A constant holding the smallest positive normal value of type\n+     * {@code Float16}, 2<sup>-14<\/sup>.\n+     *\/\n+    public static final Float16 MIN_NORMAL = valueOf(0x1.0p-14f);\n+\n+    \/**\n+     * A constant holding the smallest positive nonzero value of type\n+     * {@code Float16}, 2<sup>-24<\/sup>.\n+     *\/\n+    public static final Float16 MIN_VALUE = valueOf(0x1.0p-24f);\n+\n+    \/**\n+     * The number of bits used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\/\n+    public static final int SIZE = 16;\n+\n+    \/**\n+     * The number of bits in the significand of a {@code Float16}\n+     * value, {@value}.  This corresponds to parameter N in section\n+     * {@jls 4.2.3} of <cite>The Java Language Specification<\/cite>.\n+     *\/\n+    public static final int PRECISION = 11;\n+\n+    \/**\n+     * Maximum exponent a finite {@code Float16} variable may have,\n+     * {@value}.\n+     *\/\n+    public static final int MAX_EXPONENT = (1 << (SIZE - PRECISION - 1)) - 1; \/\/ 15\n+\n+    \/**\n+     * Minimum exponent a normalized {@code Float16} variable may\n+     * have, {@value}.\n+     *\/\n+    public static final int MIN_EXPONENT = 1 - MAX_EXPONENT; \/\/ -14\n+\n+    \/**\n+     * The number of bytes used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\/\n+    public static final int BYTES = SIZE \/ Byte.SIZE;\n+\n+    \/**\n+     * Returns a string representation of the {@code float16}\n+     * argument. All characters mentioned below are ASCII characters.\n+     *\n+     * TODO: elaborate on more detailed behavior\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a string representation of the argument.\n+     *\/\n+    public static String toString(Float16 f16) {\n+        \/\/ FIXME -- update for Float16 precision\n+        return FloatToDecimal.toString(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string representation of the {@code\n+     * Float16} argument.\n+     *\n+     * TODO: elaborate on more detailed behavior\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a hex string representation of the argument.\n+     *\n+     * @see Float#toHexString(float)\n+     * @see Double#toHexString(double)\n+     *\/\n+    public static String toHexString(Float16 f16) {\n+        float f = f16.floatValue();\n+        if (Math.abs(f) < float16ToFloat(Float16.MIN_NORMAL.value)\n+            &&  f != 0.0f ) {\/\/ Float16 subnormal\n+            \/\/ Adjust exponent to create subnormal double, then\n+            \/\/ replace subnormal double exponent with subnormal Float16\n+            \/\/ exponent\n+            String s = Double.toHexString(Math.scalb((double)f,\n+                                                     \/* -1022+14 *\/\n+                                                     Double.MIN_EXPONENT-\n+                                                     Float16.MIN_EXPONENT));\n+            return s.replaceFirst(\"p-1022$\", \"p-14\");\n+        } else {\/\/ double string will be the same as Float16 string\n+            return Double.toHexString(f);\n+        }\n+    }\n+\n+    \/\/ -----------------------\n+\n+   \/**\n+    * {@return the value of an {@code int} converted to {@code\n+    * Float16}}\n+    *\n+    * @param  value an {@code int} value.\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n@@ -69,2 +214,3 @@\n-    private Float16 (short value ) {\n-        this.value = value;\n+    public static Float16 valueOf(int value) {\n+        \/\/ int -> double conversion is exact\n+        return valueOf((double)value);\n@@ -74,2 +220,5 @@\n-    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n-    * encoded {@code short} value.\n+    * {@return the value of a {@code long} converted to {@code Float16}}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n@@ -77,3 +226,1 @@\n-    * @param  value a short value.\n-    * @return a {@code Float16} instance representing {@code value}.\n-    * @since  20\n+    * @param  value a {@code long} value.\n@@ -81,2 +228,104 @@\n-    public static Float16 valueOf(short value) {\n-       return new Float16(value);\n+    public static Float16 valueOf(long value) {\n+        if (value < -65_504) {\n+            return Float16.NEGATIVE_INFINITY;\n+        } else {\n+            if (value > 65_504L) {\n+                return Float16.NEGATIVE_INFINITY;\n+            }\n+            \/\/ Remaining range of long, the integers in approx. +\/-\n+            \/\/ 2^16, all fit in a float so the correct conversion can\n+            \/\/ be done via an intermediate float conversion.\n+            return valueOf((float)value);\n+        }\n+    }\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code float}\n+    * argument}\n+    *\n+    * @param  f a {@code float}\n+    *\/\n+    public static Float16 valueOf(float f) {\n+        return new Float16(Float.floatToFloat16(f));\n+    }\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code double}\n+    * argument}\n+    *\n+    * @param  d a {@code double}\n+    *\/\n+    public static Float16 valueOf(double d) {\n+        long doppel = Double.doubleToRawLongBits(d);\n+\n+        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> 48);\n+\n+        if (Double.isNaN(d)) {\n+            \/\/ Have existing float code handle any attempts to\n+            \/\/ preserve NaN bits.\n+            return valueOf((float)d);\n+        }\n+\n+        double abs_d = Math.abs(d);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_d >= (0x1.ffcp15 + 0x0.002p15) ) {\n+             \/\/ correctly signed infinity\n+            return new Float16((short)(sign_bit | 0x7c00));\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_d <= 0x1.0p-24d * 0.5d) { \/\/ Covers double zeros and subnormals.\n+            return new Float16(sign_bit); \/\/ Positive or negative zero\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of binary16\n+        \/\/ (when rounding is done, could still round up)\n+        int exp = Math.getExponent(d);\n+        assert -25 <= exp && exp <= 15;\n+\n+        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+        \/\/ the difference expdelta = E_min - exp.  This is the excess\n+        \/\/ shift value, in addition to 42, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in d must be involved as well.\n+        int expdelta = 0;\n+        long msb = 0x0000_0000_0000_0000L;\n+        if (exp < -14) {\n+            expdelta = -14 - exp; \/\/ FIXME?\n+            exp = -15;\n+            msb = 0x0010_0000_0000_0000L; \/\/ should be 0x0020_... ?\n+        }\n+        long f_signif_bits = doppel & 0x000f_ffff_ffff_ffffL | msb;\n+\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (42 + expdelta));\n+\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+        long lsb    = f_signif_bits & (1L << 42 + expdelta);\n+        long round  = f_signif_bits & (1L << 41 + expdelta);\n+        long sticky = f_signif_bits & ((1L << 41 + expdelta) - 1);\n+\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the significand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n+\n+        return new Float16((short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) ));\n@@ -85,0 +334,80 @@\n+    \/**\n+     * Returns a {@code Float16} equal to the value represented by the\n+     * specified {@code String}.\n+     *\n+     * TODO: add note about rounding, etc.\n+     *\n+     * @param  s the string to be parsed.\n+     * @return the {@code Float16} value represented by the string\n+     *         argument.\n+     * @throws NullPointerException  if the string is null\n+     * @throws NumberFormatException if the string does not contain a\n+     *               parsable {@code Float16}.\n+     * @see    java.lang.Float#valueOf(String)\n+     *\/\n+    public static Float16 valueOf(String s) throws NumberFormatException {\n+        \/\/ TOOD: adjust precision of parsing if needed\n+        return shortBitsToFloat16(floatToFloat16(Float.parseFloat(s)));\n+    }\n+\n+    \/\/    \/**\n+    \/\/     * ...\n+    \/\/     * @see BigDecimal#floatValue()\n+    \/\/     * @see BigDecimal#doubleValue()\n+    \/\/     *\/\n+    \/\/    public static Float16 valueOf(BigDecimal bd)\n+\n+\n+    \/**\n+     * Returns {@code true} if the specified number is a\n+     * Not-a-Number (NaN) value, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isNaN operation defined in IEEE\n+     * 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is NaN;\n+     *          {@code false} otherwise.\n+     *\/\n+    public static boolean isNaN(Float16 f16) {\n+        return Float.isNaN(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is infinitely\n+     * large in magnitude, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isInfinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is positive infinity or\n+     *          negative infinity; {@code false} otherwise.\n+     *\/\n+    public static boolean isInfinite(Float16 f16) {\n+        return Float.isInfinite(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the argument is a finite floating-point\n+     * value; returns {@code false} otherwise (for NaN and infinity\n+     * arguments).\n+     *\n+     * @apiNote\n+     * This method corresponds to the isFinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param f16 the {@code Float16} value to be tested\n+     * @return {@code true} if the argument is a finite\n+     * floating-point value, {@code false} otherwise.\n+     *\/\n+    public static boolean isFinite(Float16 f16) {\n+        return Float.isFinite(f16.floatValue());\n+     }\n+\n+    \/\/ Skipping for now\n+    \/\/ public boolean isNaN()\n+    \/\/ public boolean isInfinite() {\n+\n@@ -93,0 +422,1 @@\n+    @Override\n@@ -94,1 +424,11 @@\n-        return (byte)Float.float16ToFloat(value);\n+        return (byte)floatValue();\n+    }\n+\n+    \/**\n+     * {@return a string representation of this {@code Float16}}\n+     *\n+     * @see java.lang.Float#toString(float)\n+     *\/\n+    public String toString() {\n+        \/\/ Is this idiomatic?\n+        return Float16.toString(this);\n@@ -104,1 +444,0 @@\n-     * @since 1.1\n@@ -106,0 +445,1 @@\n+    @Override\n@@ -107,1 +447,1 @@\n-        return (short)Float.float16ToFloat(value);\n+        return (short)floatValue();\n@@ -112,1 +452,1 @@\n-     * a widening primitive conversion.\n+     * a narrowing primitive conversion.\n@@ -116,1 +456,1 @@\n-     * @jls 5.1.3 Widening Primitive Conversion\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n@@ -118,0 +458,1 @@\n+    @Override\n@@ -119,1 +460,1 @@\n-        return (int)Float.float16ToFloat(value);\n+        return (int)floatValue();\n@@ -124,1 +465,1 @@\n-     * widening conversion.\n+     * narrowing primitive conversion.\n@@ -128,1 +469,1 @@\n-     * @jls 5.1.3 Widening Primitive Conversion\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n@@ -130,0 +471,1 @@\n+    @Override\n@@ -131,1 +473,1 @@\n-        return (long)Float.float16ToFloat(value);\n+        return (long)floatValue();\n@@ -139,0 +481,1 @@\n+     * @jls 5.1.2 Widening Primitive Conversion\n@@ -140,0 +483,1 @@\n+    @Override\n@@ -141,1 +485,1 @@\n-        return Float.float16ToFloat(value);\n+        return float16ToFloat(value);\n@@ -156,0 +500,1 @@\n+    @Override\n@@ -157,1 +502,1 @@\n-        return (double)Float.float16ToFloat(value);\n+        return (double)floatValue();\n@@ -160,0 +505,5 @@\n+    \/\/ Skipping for now:\n+    \/\/ public int hashCode()\n+    \/\/ public static int hashCode(Float16 value)\n+    \/\/ public boolean equals(Object obj)\n+\n@@ -163,3 +513,0 @@\n-     * @apiNote This method corresponds to the addition operation\n-     * defined in IEEE 754.\n-     *\n@@ -169,1 +516,0 @@\n-     * @since 20\n@@ -173,1 +519,102 @@\n-       return Float16.valueOf(Float.floatToFloat16(Float.float16ToFloat(a.float16ToRawShortBits()) + Float.float16ToFloat(b.float16ToRawShortBits())));\n+        return add(a, b);\n+    }\n+\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     *\n+     * @param   f16   a {@code Float16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n+     *\/\n+    public static short float16ToRawShortBits(Float16 f16) {\n+        return f16.value;\n+    }\n+\n+    \/**\n+     * Returns the {@code Float16} value corresponding to a given bit\n+     * representation.\n+     *\n+     * @param   bits   any {@code short} integer.\n+     * @return  the {@code Float16} floating-point value with the same\n+     *          bit pattern.\n+     *\n+     * @see Float#intBitsToFloat(int)\n+     * @see Double#longBitsToDouble(long)\n+     *\/\n+    public static Float16 shortBitsToFloat16(short bits) {\n+        return new Float16(bits);\n+    }\n+\n+    \/**\n+     * Compares two {@code Float16} objects numerically.\n+     *\n+     * This method imposes a total order on {@code Float16} objects\n+     * with two differences compared to the incomplete order defined by\n+     * the Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code double} values.\n+     *\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Double.NaN} to be equal to itself and greater than all\n+     *          other {@code double} values (including {@code\n+     *          Double.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero ({@code +0.0d}),\n+     *      to be greater than negative zero ({@code -0.0d}).\n+     * <\/ul>\n+     *\n+     * @param   anotherFloat16   the {@code Float16} to be compared.\n+     * @return  the value {@code 0} if {@code anotherFloat16} is\n+     *          numerically equal to this {@code Float16}; a value\n+     *          less than {@code 0} if this {@code Float16}\n+     *          is numerically less than {@code anotherFloat16};\n+     *          and a value greater than {@code 0} if this\n+     *          {@code Float16} is numerically greater than\n+     *          {@code anotherFloat16}.\n+     *\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+     *\/\n+    @Override\n+    public int compareTo(Float16 anotherFloat16) {\n+        return Float16.compare(this, anotherFloat16);\n+    }\n+\n+    \/**\n+     * Compares the two specified {@code Float16} values.\n+     *\n+     * @param   f1        the first {@code Float16} to compare\n+     * @param   f2        the second {@code Float16} to compare\n+     * @return  the value {@code 0} if {@code f1} is\n+     *          numerically equal to {@code f2}; a value less than\n+     *          {@code 0} if {@code f1} is numerically less than\n+     *          {@code f2}; and a value greater than {@code 0}\n+     *          if {@code f1} is numerically greater than\n+     *          {@code f2}.\n+     *\/\n+    public static int compare(Float16 f1, Float16 f2) {\n+        return Float.compare(f1.floatValue(), f2.floatValue());\n+    }\n+\n+    \/**\n+     * Returns the larger of two {@code Float16} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the maximum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#max(float, float)\n+     * @see Math#max(double, double)\n+     *\/\n+    public static Float16 max(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.max(a.floatValue(),\n+                                                          b.floatValue() )));\n@@ -177,3 +624,12 @@\n-     * Return raw short value.\n-     * @return raw binary16 encoded {@code short} value represented by this object.\n-     * @since 20\n+     * Returns the smaller of two {@code Float16} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the minimum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#min(float, float)\n+     * @see Math#min(double, double)\n@@ -181,1 +637,281 @@\n-    public short float16ToRawShortBits() { return value; }\n+    public static Float16 min(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.min(a.floatValue(),\n+                                                          b.floatValue()) ));\n+    }\n+\n+    \/\/ Skipping for now\n+    \/\/ public Optional<Float16> describeConstable()\n+    \/\/ public Float16 resolveConstantDesc(MethodHandles.Lookup lookup)\n+\n+    \/*\n+     * Note: for the basic arithmetic operations {+, -, *, \/} and\n+     * square root, among binary interchange formats (binary16,\n+     * binary32 a.k.a. float, binary64 a.k.a double, etc.) the \"2p + 2\"\n+     * property holds. That is, if one format has p bits of precision,\n+     * if the next larger format has at least 2p + 2 bits of\n+     * precision, arithmetic on the smaller format can be implemented by:\n+     *\n+     * 1) converting each argument to the wider format\n+     * 2) performing the operation in the wider format\n+     * 3) converting the result from 2) to the narrower format\n+     *\n+     * For example, this property hold between the formats used for the\n+     * float and double types. Therefore, the following is a valid\n+     * implementation of a float addition:\n+     *\n+     * float add(float addend, float augend) {\n+     *     return (float)((double)addend + (double)augend);\n+     * }\n+     *\n+     * The same property holds between the float16 format and\n+     * float. Therefore, the software implementations of Float16 {+,\n+     * -, *, \/} and square root below use the technique of widening\n+     * the Float16 arguments to float, performing the operation in\n+     * float arithmetic, and then rounding the float result to\n+     * Float16.\n+     *\/\n+\n+    \/**\n+     * Adds two {@code Float16} values together as per the {@code +}\n+     * operator semantics.\n+     *\n+     * @apiNote This method corresponds to the addition operation\n+     * defined in IEEE 754.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\n+     * @jls 15.18.2 Additive Operators ({@code +} and {@code -}) for Numeric Types\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 add(Float16 addend, Float16 augend) {\n+        return shortBitsToFloat16(floatToFloat16(addend.floatValue()\n+                                                 +\n+                                                 augend.floatValue() ));\n+    }\n+\n+    \/**\n+     * Subtracts two {@code Float16} values as per the {@code -}\n+     * operator semantics.\n+     *\n+     * @apiNote This method corresponds to the subtraction operation\n+     * defined in IEEE 754.\n+     *\n+     * @param minuend the first operand\n+     * @param  subtrahend the second operand\n+     * @return the difference of the operands\n+     *\n+     * @jls 15.18.2 Additive Operators (+ and -) for Numeric Types\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 subtract(Float16 minuend, Float16 subtrahend) {\n+        return shortBitsToFloat16(floatToFloat16(minuend.floatValue()\n+                                                 -\n+                                                 subtrahend.floatValue() ));\n+    }\n+\n+    \/**\n+     * Multiplies two {@code Float16} values as per the {@code *}\n+     * operator semantics.\n+     *\n+     * @apiNote This method corresponds to the multiplication\n+     * operation defined in IEEE 754.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\n+     * @jls 15.17.1 Multiplication Operator {@code *}\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 multiply(Float16 multiplier, Float16 multiplicand) {\n+       return shortBitsToFloat16(floatToFloat16(float16ToFloat(multiplier.value)\n+                                                *\n+                                                float16ToFloat(multiplicand.value) ));\n+    }\n+\n+    \/**\n+     * Divides two {@code Float16} values as per the {@code \/}\n+     * operator semantics.\n+     *\n+     * @apiNote This method corresponds to the division\n+     * operation defined in IEEE 754.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\n+     * @jls 15.17.2 Division Operator {@code \/}\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 divide(Float16 dividend, Float16 divisor) {\n+       return shortBitsToFloat16(floatToFloat16(float16ToFloat(dividend.value)\n+                                                \/\n+                                                float16ToFloat(divisor.value) ));\n+    }\n+\n+    \/**\n+     * {@return the square root of the operand}\n+     *\n+     * @apiNote\n+     * This method corresponds to the squareRoot operation defined in\n+     * IEEE 754.\n+     *\n+     * @param radicand the argument to have its square root taken\n+     *\n+     * @see Math#sqrt(float)\n+     * @see Math#sqrt(double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 sqrt(Float16 radicand) {\n+        \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n+        \/\/ for preserving the correct final value. The conversion\n+        \/\/ Float16 -> double preserves the exact numerical value. The\n+        \/\/ of the double -> Float16 conversion also benefits from the\n+        \/\/ 2p+2 property of IEEE 754 arithmetic.\n+        return valueOf(Math.sqrt(radicand.doubleValue()));\n+    }\n+\n+    \/**\n+     * Returns the fused multiply add of the three arguments; that is,\n+     * returns the exact product of the first two arguments summed\n+     * with the third argument and then rounded once to the nearest\n+     * {@code Float16}.\n+     *\n+     * @apiNote This method corresponds to the fusedMultiplyAdd\n+     * operation defined in IEEE 754.\n+     *\n+     * @param a a value\n+     * @param b a value\n+     * @param c a value\n+     *\n+     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n+     * computed, as if with unlimited range and precision, and rounded\n+     * once to the nearest {@code Float16} value\n+     *\n+     * @see Math#fma(float, float, float)\n+     * @see Math#fma(double, double, double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 fma(Float16 a, Float16 b, Float16 c) {\n+        \/\/ A simple scaling up to call a float or double fma doesn't\n+        \/\/ always work as double-rounding can occur and the sticky bit\n+        \/\/ information can be lost for rounding to a Float16 position.\n+        \/\/\n+        \/\/ The quantity:\n+        \/\/\n+        \/\/ convertToDouble(a)*convertToDouble(b) + convertToDouble(c)\n+        \/\/\n+        \/\/ will be an exact double value.\n+        \/\/\n+        \/\/ Note: the above conclusion is *incorrect*. The exponent of\n+        \/\/ the product of a*b can be so large that Float16.MIN_VALUE\n+        \/\/ cannot be held in a single double.\n+        \/\/\n+        \/\/ However, Float16 values with the smallest and largest\n+        \/\/ exponents can be held in a single double with precision to\n+        \/\/ spare. Therefore, all the hard rounding cases should be\n+        \/\/ covered, but some more analysis is needed to verify the\n+        \/\/ correctness of that approach.\n+        \/\/\n+        \/\/ Case analysis is needed with c is large compared to a*b.\n+        \/\/\n+        \/\/ The number of significand\n+        \/\/ bits in double, 53, is greater than the, maximum difference\n+        \/\/ in exponent values between bit positions of minimum and\n+        \/\/ maximum magnitude for Float16. Therefore, performing a*b+c\n+        \/\/ in double and then doing a single rounding of that value to\n+        \/\/ Float16 will implement this operation.\n+\n+        return valueOf( ( ((double)a.floatValue()) * (double)b.floatValue() )\n+                        +\n+                        ((double)c.floatValue()) );\n+    }\n+\n+    \/**\n+     * {@return the negation root of the argument}\n+     * @param f16 the value to be negated\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 negate(Float16 f16) {\n+        \/\/ Negate sign bit only. Per IEE 754-2019 section 5.5.1,\n+        \/\/ negate is a bit-level operation and not a logical\n+        \/\/ operation.\n+        return shortBitsToFloat16((short)(f16.value ^ (short)0x0000_8000));\n+    }\n+\n+    \/**\n+     * {@return the absolute value of the argument}\n+     * @param f16 the argument whose absolute value is to be determined\n+     *\n+     * @see Math#abs(float)\n+     * @see Math#abs(double)\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static Float16 abs(Float16 f16) {\n+        \/\/ Zero out sign bit. Per IEE 754-2019 section 5.5.1, abs is a\n+        \/\/ bit-level operation and not a logical operation.\n+        return shortBitsToFloat16((short)(f16.value & (short)0x0000_7FFF));\n+    }\n+\n+    \/**\n+     * Returns the unbiased exponent used in the representation of a\n+     * {@code Float16}.\n+     *\n+     * @param f16 a {@code Floa16t} value\n+     * @return the unbiased exponent of the argument\n+     *\n+     * @see Math#getExponent(float)\n+     * @see Math#getExponent(double)\n+     *\/\n+    public static int getExponent(Float16 f16) {\n+        return getExponent0(f16.value);\n+    }\n+\n+    \/**\n+     * From the bitwise representation of a float16, mask out exponent\n+     * bits, shift to the right and then subtract out float16's bias\n+     * adjust, 15, to get true exponent value.\n+     *\/\n+    \/*package*\/ static int getExponent0(short bits) {\n+        \/\/ package private to be usable in java.lang.Float.\n+        int bin16ExpBits     = 0x0000_7c00 & bits;     \/\/ Five exponent bits.\n+        return (bin16ExpBits >> (PRECISION - 1)) - 15;\n+    }\n+\n+    \/**\n+     * Returns the size of an ulp of the argument.  An ulp, unit in\n+     * the last place, of a {@code Float16} value is the positive\n+     * distance between this floating-point value and the {@code\n+     * double} value next larger in magnitude.  Note that for non-NaN\n+     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive or negative infinity, then the\n+     * result is positive infinity.\n+     * <li> If the argument is positive or negative zero, then the result is\n+     * {@code Float16.MIN_VALUE}.\n+     * <li> If the argument is &plusmn;{@code Float16.MAX_VALUE}, then\n+     * the result is equal to 2<sup>5<\/sup>, 32.0.\n+     * <\/ul>\n+     *\n+     * @param f16 the floating-point value whose ulp is to be returned\n+     * @return the size of an ulp of the argument\n+     *\/\n+    public static Float16 ulp(Float16 f16) {\n+        int exp = getExponent(f16);\n+\n+        return switch(exp) {\n+        case Float16.MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n+        case Float16.MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        default -> {\n+            assert exp <= Float16.MAX_EXPONENT && exp >= Float16.MIN_EXPONENT;\n+            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+            \/\/ Let float -> float16 conversion handle encoding issues.\n+            yield valueOf(Math.scalb(1.0f, exp - (PRECISION - 1)));\n+        }\n+        };\n+    }\n@@ -183,1 +919,6 @@\n-    private static final long serialVersionUID = 16; \/\/ Not needed for a primitive class?\n+    \/\/ To be considered:\n+    \/\/ copysign\n+    \/\/ scalb\n+    \/\/ nextUp \/ nextDown\n+    \/\/ IEEEremainder\n+    \/\/ signum\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":775,"deletions":34,"binary":false,"changes":809,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import static java.lang.Float16.*;\n@@ -60,1 +61,1 @@\n-        Float16 res = Float16.valueOf((short)0);\n+        Float16 res = shortBitsToFloat16((short)0);\n@@ -62,2 +63,2 @@\n-            res = Float16.sum(res, Float16.valueOf(src[i]));\n-            dst[i] = res.float16ToRawShortBits();\n+            res = Float16.sum(res, shortBitsToFloat16(src[i]));\n+            dst[i] = float16ToRawShortBits(res);\n@@ -70,6 +71,6 @@\n-        Float16 hf0 = Float16.valueOf((short)0);\n-        Float16 hf1 = Float16.valueOf((short)15360);\n-        Float16 hf2 = Float16.valueOf((short)16384);\n-        Float16 hf3 = Float16.valueOf((short)16896);\n-        Float16 hf4 = Float16.valueOf((short)17408);\n-        res = Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4).float16ToRawShortBits();\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        res = float16ToRawShortBits(Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4));\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFP16ScalarAdd.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-\n+import static java.lang.Float16.*;\n@@ -53,1 +53,1 @@\n-            input[i] = Float16.valueOf(Float.floatToFloat16(rng.nextFloat()));\n+            input[i] = shortBitsToFloat16(Float.floatToFloat16(rng.nextFloat()));\n@@ -70,2 +70,4 @@\n-            if (output[i].float16ToRawShortBits() != expected.float16ToRawShortBits()) {\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i].float16ToRawShortBits() + \" != \" + expected.float16ToRawShortBits());\n+            if (float16ToRawShortBits(output[i]) != float16ToRawShortBits(expected)) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" +\n+                                           float16ToRawShortBits(output[i]) + \" != \" +\n+                                           float16ToRawShortBits(expected));\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorSum.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329817\n+ * @summary Basic tests of Float16 arithmetic and similar operations\n+ *\/\n+\n+import static java.lang.Float16.*;\n+\n+public class BasicFloat16ArithTests {\n+    public static void main(String... args) {\n+        checkConstants();\n+        checkNegate();\n+        checkAbs();\n+        checkIsNaN();\n+        checkFiniteness();\n+        checkMinMax();\n+        checkArith();\n+        checkSqrt();\n+    }\n+\n+    \/*\n+     * The software implementation of Float16 delegates to float or\n+     * double operations for most of the actual computation. This\n+     * regression test takes that into account as it generally only\n+     * has limited tested to probe whether or not the proper\n+     * functionality is being delegated to.\n+     *\n+     * To make the test easier to read, float literals that are exact\n+     * upon conversion to Float16 are used for the test data.\n+     *\n+     * The float <-> Float16 conversions are well-tested from prior\n+     * work and are assumed to be correct by this regression test.\n+     *\/\n+\n+    private static void checkConstants() {\n+        checkInt(BYTES,          2, \"Float16.BYTES\");\n+        checkInt(MAX_EXPONENT,  15, \"Float16.MAX_EXPONENT\");\n+        checkInt(MIN_EXPONENT, -14, \"Float16.MIN_EXPONENT\");\n+        checkInt(PRECISION,     11, \"Float16.PRECISION\");\n+        checkInt(SIZE,          16, \"Float16.SIZE\");\n+\n+        checkFloat16(MIN_VALUE,  0x1.0p-24f, \"Float16.MIN_VALUE\");\n+        checkFloat16(MIN_NORMAL, 0x1.0p-14f, \"Float16.MIN_NORMAL\");\n+        checkFloat16(MAX_VALUE,  65504.0f,  \"Float16.MAX_VALUE\");\n+\n+        checkFloat16(POSITIVE_INFINITY,  Float.POSITIVE_INFINITY,  \"+infinity\");\n+        checkFloat16(NEGATIVE_INFINITY,  Float.NEGATIVE_INFINITY,  \"-infinity\");\n+        checkFloat16(NaN,                Float.NaN,            \"NaN\");\n+    }\n+\n+    private static void checkInt(int value, int expected, String message) {\n+        if (value != expected) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %d, got %d\",\n+                                  message, expected, value));\n+        }\n+    }\n+\n+    private static void checkFloat16(Float16 value16, float expected, String message) {\n+        float value = value16.floatValue();\n+        if (Float.compare(value, expected) != 0) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %g (%a), got %g (%a)\",\n+                                  message, expected, expected, value, value));\n+        }\n+    }\n+\n+    private static void checkNegate() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,  -0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,  -1.0f},\n+\n+            {Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY},\n+            {Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+\n+            {Float.NaN, Float.NaN},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  negate(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"negate(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkAbs() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,   0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,   1.0f},\n+\n+            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+\n+            {Float.NaN, Float.NaN},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  abs(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"abs(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkIsNaN() {\n+        if (!isNaN(NaN)) {\n+            throwRE(\"Float16.isNaN() returns false for a NaN\");\n+        }\n+\n+        float[] testCases = {\n+            Float.NEGATIVE_INFINITY,\n+            Float.POSITIVE_INFINITY,\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var testCase : testCases) {\n+            boolean result = isNaN(valueOf(testCase));\n+            if (result) {\n+                throwRE(\"isNaN returned true for \" + testCase);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkFiniteness() {\n+        float[] infinities = {\n+            Float.NEGATIVE_INFINITY,\n+            Float.POSITIVE_INFINITY,\n+        };\n+\n+        for(var infinity : infinities) {\n+            boolean result1 = isFinite(valueOf(infinity));\n+            boolean result2 = isInfinite(valueOf(infinity));\n+\n+            if (result1) {\n+                throw new RuntimeException(\"Float16.isFinite returned true for \" + infinity);\n+            }\n+\n+            if (!result2) {\n+                throwRE(\"Float16.isInfinite returned false for \" + infinity);\n+            }\n+        }\n+\n+        if (isFinite(NaN)) {\n+            throwRE(\"Float16.isFinite() returns true for a NaN\");\n+        }\n+\n+        if (isInfinite(NaN)) {\n+            throwRE(\"Float16.isInfinite() returns true for a NaN\");\n+        }\n+\n+        float[] finities = {\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var finity : finities) {\n+            boolean result1 = isFinite(valueOf(finity));\n+            boolean result2 = isInfinite(valueOf(finity));\n+\n+            if (!result1) {\n+                throwRE(\"Float16.isFinite returned true for \" + finity);\n+            }\n+\n+            if (result2) {\n+                throwRE(\"Float16.isInfinite returned true for \" + finity);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkMinMax() {\n+        float small = 1.0f;\n+        float large = 2.0f;\n+\n+        if (min(valueOf(small), valueOf(large)).floatValue() != small) {\n+            throwRE(String.format(\"min(%g, %g) not equal to %g)\",\n+                                  small, large, small));\n+        }\n+\n+        if (max(valueOf(small), valueOf(large)).floatValue() != large) {\n+            throwRE(String.format(\"max(%g, %g) not equal to %g)\",\n+                                  small, large, large));\n+        }\n+    }\n+\n+    \/*\n+     * Cursory checks to make sure correct operation is being called\n+     * with arguments in proper order.\n+     *\/\n+    private static void checkArith() {\n+        float   a   = 1.0f;\n+        Float16 a16 = valueOf(a);\n+\n+        float   b   = 2.0f;\n+        Float16 b16 = valueOf(b);\n+\n+        if (add(a16, b16).floatValue() != (a + b)) {\n+            throwRE(\"failure with \" + a16 + \" + \" + b16);\n+        }\n+        if (add(b16, a16).floatValue() != (b + a)) {\n+            throwRE(\"failure with \" + b16 + \" + \" + a16);\n+        }\n+\n+        if (subtract(a16, b16).floatValue() != (a - b)) {\n+            throwRE(\"failure with \" + a16 + \" - \" + b16);\n+        }\n+        if (subtract(b16, a16).floatValue() != (b - a)) {\n+            throwRE(\"failure with \" + b16 + \" - \" + a16);\n+        }\n+\n+        if (multiply(a16, b16).floatValue() != (a * b)) {\n+            throwRE(\"failure with \" + a16 + \" * \" + b16);\n+        }\n+        if (multiply(b16, a16).floatValue() != (b * a)) {\n+            throwRE(\"failure with \" + b16 + \" * \" + a16);\n+        }\n+\n+        if (divide(a16, b16).floatValue() != (a \/ b)) {\n+            throwRE(\"failure with \" + a16 + \" \/ \" + b16);\n+        }\n+        if (divide(b16, a16).floatValue() != (b \/ a)) {\n+            throwRE(\"failure with \" + b16 + \" \/ \" + a16);\n+        }\n+        return;\n+    }\n+\n+    private static void checkSqrt() {\n+        float[][] testCases = {\n+            {-0.0f,   -0.0f},\n+            { 0.0f,    0.0f},\n+\n+            {1.0f,   1.0f},\n+            {4.0f,   2.0f},\n+            {9.0f,   3.0f},\n+\n+            {Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            {Float.NEGATIVE_INFINITY, Float.NaN},\n+\n+            {Float.NaN, Float.NaN},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  sqrt(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"sqrt(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void throwRE(String message) {\n+        throw new RuntimeException(message);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float16\/BasicFloat16ArithTests.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @compile -XDenablePrimitiveClasses FP16ReductionOperations.java\n- * @run main\/othervm -XX:+EnablePrimitiveClasses -XX:-TieredCompilation -Xbatch FP16ReductionOperations\n+ * @compile FP16ReductionOperations.java\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch FP16ReductionOperations\n@@ -34,0 +34,2 @@\n+import static java.lang.Float16.*;\n+\n@@ -39,6 +41,6 @@\n-        Float16 hf0 = Float16.valueOf((short)0);\n-        Float16 hf1 = Float16.valueOf((short)15360);\n-        Float16 hf2 = Float16.valueOf((short)16384);\n-        Float16 hf3 = Float16.valueOf((short)16896);\n-        Float16 hf4 = Float16.valueOf((short)17408);\n-        return Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4).float16ToRawShortBits();\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        return float16ToRawShortBits(Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4));\n@@ -48,10 +50,10 @@\n-        Float16 hf0 = Float16.valueOf((short)0);\n-        Float16 hf1 = Float16.valueOf((short)15360);\n-        Float16 hf2 = Float16.valueOf((short)16384);\n-        Float16 hf3 = Float16.valueOf((short)16896);\n-        Float16 hf4 = Float16.valueOf((short)17408);\n-        return Float.floatToFloat16(Float.float16ToFloat(hf0.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf1.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf2.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf3.float16ToRawShortBits()) +\n-                                    Float.float16ToFloat(hf4.float16ToRawShortBits()));\n+        Float16 hf0 = shortBitsToFloat16((short)0);\n+        Float16 hf1 = shortBitsToFloat16((short)15360);\n+        Float16 hf2 = shortBitsToFloat16((short)16384);\n+        Float16 hf3 = shortBitsToFloat16((short)16896);\n+        Float16 hf4 = shortBitsToFloat16((short)17408);\n+        return Float.floatToFloat16(Float.float16ToFloat(float16ToRawShortBits(hf0)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf1)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf2)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf3)) +\n+                                    Float.float16ToFloat(float16ToRawShortBits(hf4)));\n@@ -80,1 +82,1 @@\n-        Float16 res = Float16.valueOf((short)0);\n+        Float16 res = shortBitsToFloat16((short)0);\n@@ -82,1 +84,1 @@\n-            res = Float16.sum(res, Float16.valueOf(arr[i]));\n+            res = Float16.sum(res, shortBitsToFloat16(arr[i]));\n@@ -84,1 +86,1 @@\n-        return res.float16ToRawShortBits();\n+        return float16ToRawShortBits(res);\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ReductionOperations.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @compile -XDenablePrimitiveClasses FP16ScalarOperations.java\n- * @run main\/othervm -XX:+EnablePrimitiveClasses -XX:-TieredCompilation -Xbatch FP16ScalarOperations\n+ * @compile FP16ScalarOperations.java\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch FP16ScalarOperations\n@@ -34,0 +34,2 @@\n+import static java.lang.Float16.*;\n+\n@@ -39,2 +41,2 @@\n-        Float16 obj1 = Float16.valueOf(val1);\n-        Float16 obj2 = Float16.valueOf(val2);\n+        Float16 obj1 = shortBitsToFloat16(val1);\n+        Float16 obj2 = shortBitsToFloat16(val2);\n@@ -42,1 +44,1 @@\n-            case '+' : return Float16.sum(obj1, obj2).float16ToRawShortBits();\n+            case '+' : return float16ToRawShortBits(Float16.sum(obj1, obj2));\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}