{"files":[{"patch":"@@ -228,1 +228,1 @@\n-  Label alloc_failed, done;\n+  Label failed_alloc, slow_path, done;\n@@ -233,1 +233,5 @@\n-  assert_different_registers(obj, entry, field_index, field_offset, temp, alloc_temp);\n+  assert_different_registers(obj, entry, field_index, field_offset, temp, alloc_temp, rscratch1);\n+\n+  load_unsigned_byte(temp, Address(entry, in_bytes(ResolvedFieldEntry::flags_offset())));\n+  \/\/ If the field is nullable, jump to slow path\n+  tbz(temp, ResolvedFieldEntry::is_null_free_inline_type_shift, slow_path);\n@@ -244,1 +248,1 @@\n-  allocate_instance(field_klass, obj, alloc_temp, rscratch2, false, alloc_failed);\n+  allocate_instance(field_klass, obj, alloc_temp, rscratch2, false, failed_alloc);\n@@ -256,1 +260,1 @@\n-  bind(alloc_failed);\n+  bind(failed_alloc);\n@@ -258,0 +262,1 @@\n+  bind(slow_path);\n@@ -265,0 +270,29 @@\n+void InterpreterMacroAssembler::write_flat_field(Register entry, Register field_offset,\n+                                                 Register tmp1, Register tmp2,\n+                                                 Register obj) {\n+  assert_different_registers(entry, field_offset, tmp1, tmp2, obj);\n+  Label slow_path, done;\n+\n+  load_unsigned_byte(tmp1, Address(entry, in_bytes(ResolvedFieldEntry::flags_offset())));\n+  test_field_is_not_null_free_inline_type(tmp1, noreg \/* temp *\/, slow_path);\n+\n+  null_check(r0); \/\/ FIXME JDK-8341120\n+\n+  add(obj, obj, field_offset);\n+\n+  load_klass(tmp1, r0);\n+  payload_address(r0, r0, tmp1);\n+\n+  Register layout_info = field_offset;\n+  load_unsigned_short(tmp1, Address(entry, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+  ldr(tmp2, Address(entry, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n+  inline_layout_info(tmp2, tmp1, layout_info);\n+\n+  flat_field_copy(IN_HEAP, r0, obj, layout_info);\n+  b(done);\n+\n+  bind(slow_path);\n+  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_flat_field), obj, r0, entry);\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -159,1 +159,5 @@\n-                       Register temp, Register obj = r0);\n+                       Register temp, Register obj);\n+\n+  void write_flat_field(Register entry, Register field_offset,\n+                        Register tmp1, Register tmp2,\n+                        Register obj);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2778,13 +2778,2 @@\n-      Label is_null_free_inline_type, uninitialized;\n-      \/\/ Issue below if the static field has not been initialized yet\n-      __ test_field_is_null_free_inline_type(flags, noreg \/*temp*\/, is_null_free_inline_type);\n-        \/\/ field is not a null free inline type\n-        __ push(atos);\n-        __ b(Done);\n-      \/\/ field is a null free inline type, must not return null even if uninitialized\n-      __ bind(is_null_free_inline_type);\n-        __ cbz(r0, uninitialized);\n-          __ push(atos);\n-          __ b(Done);\n-        __ bind(uninitialized);\n-          __ b(ExternalAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n+      __ push(atos);\n+      __ b(Done);\n@@ -2792,5 +2781,13 @@\n-      Label is_flat, nonnull, is_inline_type, has_null_marker, rewrite_inline;\n-      __ test_field_is_null_free_inline_type(flags, noreg \/*temp*\/, is_inline_type);\n-      __ test_field_has_null_marker(flags, noreg \/*temp*\/, has_null_marker);\n-        \/\/ Non-inline field case\n-        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+      Label is_flat, rewrite_inline;\n+      __ test_field_is_flat(flags, noreg \/*temp*\/, is_flat);\n+      __ load_heap_oop(r0, field, rscratch1, rscratch2);\n+      __ push(atos);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n+      }\n+      __ b(Done);\n+      __ bind(is_flat);\n+        \/\/ field is flat (null-free or nullable with a null-marker)\n+        __ mov(r0, obj);\n+        __ read_flat_field(cache, field_index, off, inline_klass \/* temp *\/, r0);\n+        __ verify_oop(r0);\n@@ -2798,25 +2795,0 @@\n-        if (rc == may_rewrite) {\n-          patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);\n-        }\n-        __ b(Done);\n-      __ bind(is_inline_type);\n-        __ test_field_is_flat(flags, noreg \/* temp *\/, is_flat);\n-         \/\/ field is not flat\n-          __ load_heap_oop(r0, field, rscratch1, rscratch2);\n-          __ cbnz(r0, nonnull);\n-            __ b(ExternalAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n-          __ bind(nonnull);\n-          __ verify_oop(r0);\n-          __ push(atos);\n-          __ b(rewrite_inline);\n-        __ bind(is_flat);\n-        \/\/ field is flat\n-          __ mov(r0, obj);\n-          __ read_flat_field(cache, field_index, off, inline_klass \/* temp *\/, r0);\n-          __ verify_oop(r0);\n-          __ push(atos);\n-          __ b(rewrite_inline);\n-        __ bind(has_null_marker);\n-          call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), obj, cache);\n-          __ verify_oop(r0);\n-          __ push(atos);\n@@ -3063,4 +3035,4 @@\n-        Label is_inline_type;\n-         __ test_field_is_not_null_free_inline_type(flags, noreg \/* temp *\/, is_inline_type);\n-         __ null_check(r0);\n-         __ bind(is_inline_type);\n+        Label is_nullable;\n+         __ test_field_is_not_null_free_inline_type(flags, noreg \/* temp *\/, is_nullable);\n+         __ null_check(r0);  \/\/ FIXME JDK-8341120\n+         __ bind(is_nullable);\n@@ -3070,4 +3042,3 @@\n-        Label is_inline_type, is_flat, has_null_marker, rewrite_not_inline, rewrite_inline;\n-        __ test_field_is_null_free_inline_type(flags, noreg \/*temp*\/, is_inline_type);\n-        __ test_field_has_null_marker(flags, noreg \/*temp*\/, has_null_marker);\n-        \/\/ Not an inline type\n+        Label null_free_reference, is_flat, rewrite_inline;\n+        __ test_field_is_flat(flags, noreg \/*temp*\/, is_flat);\n+        __ test_field_is_null_free_inline_type(flags, noreg \/*temp*\/, null_free_reference);\n@@ -3078,1 +3049,0 @@\n-        __ bind(rewrite_not_inline);\n@@ -3084,4 +3054,2 @@\n-        __ bind(is_inline_type);\n-        __ null_check(r0);\n-        __ test_field_is_flat(flags, noreg \/*temp*\/, is_flat);\n-        \/\/ field is not flat\n+        __ bind(null_free_reference);\n+        __ null_check(r0);  \/\/ FIXME JDK-8341120\n@@ -3094,15 +3062,2 @@\n-        __ load_field_entry(cache, index); \/\/ reload field entry (cache) because it was erased by tos_state\n-        __ load_unsigned_short(index, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-        __ ldr(r2, Address(cache, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n-        __ inline_layout_info(r2, index, r6);\n-        pop_and_check_object(obj);\n-        __ load_klass(inline_klass, r0);\n-        __ payload_address(r0, r0, inline_klass);\n-        __ add(obj, obj, off);\n-        \/\/ because we use InlineLayoutInfo, we need special value access code specialized for fields (arrays will need a different API)\n-        __ flat_field_copy(IN_HEAP, r0, obj, r6);\n-        __ b(rewrite_inline);\n-        __ bind(has_null_marker);\n-        assert_different_registers(r0, cache, r19);\n-        pop_and_check_object(r19);\n-        __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), r19, r0, cache);\n+        pop_and_check_object(r7);\n+        __ write_flat_field(cache, off, r3, r6, r7);\n@@ -3329,1 +3284,1 @@\n-   {\n+    {\n@@ -3331,2 +3286,0 @@\n-      __ test_field_has_null_marker(r5, noreg \/* temp *\/, has_null_marker);\n-      __ null_check(r0);\n@@ -3334,1 +3287,1 @@\n-      \/\/ field is not flat\n+      __ null_check(r0);\n@@ -3338,1 +3291,0 @@\n-      \/\/ field is flat\n@@ -3340,12 +3292,4 @@\n-      __ load_unsigned_short(r5, Address(r4, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-      __ ldr(r4, Address(r4, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n-      __ inline_layout_info(r4, r5, r6);\n-      __ load_klass(r4, r0);\n-      __ payload_address(r0, r0, r4);\n-      __ lea(rscratch1, field);\n-      __ flat_field_copy(IN_HEAP, r0, rscratch1, r6);\n-      __ b(done);\n-      __ bind(has_null_marker);\n-      __ load_field_entry(r4, r1);\n-      __ mov(r1, r2);\n-      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), r1, r0, r4);\n+      \/\/ Re-shuffle registers because of VM calls calling convention\n+      __ mov(r19, r1);\n+      __ mov(r7, r2);\n+      __ write_flat_field(r4, r19, r6, r8, r7);\n@@ -3450,12 +3394,1 @@\n-      Register index = r4, klass = r5, inline_klass = r6, tmp = r7;\n-      Label is_flat, has_null_marker, nonnull, Done;\n-      __ test_field_has_null_marker(r3, noreg \/*temp*\/, has_null_marker);\n-      __ test_field_is_flat(r3, noreg \/* temp *\/, is_flat);\n-        \/\/ field is not flat\n-        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n-        __ cbnz(r0, nonnull);\n-          __ b(ExternalAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n-        __ bind(nonnull);\n-        __ verify_oop(r0);\n-        __ b(Done);\n-      __ bind(is_flat);\n+      Register index = r4, tmp = r7;\n@@ -3463,8 +3396,3 @@\n-        __ load_unsigned_short(index, Address(r2, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-        __ read_flat_field(r2, index, r1, tmp \/* temp *\/, r0);\n-        __ verify_oop(r0);\n-        __ b(Done);\n-      __ bind(has_null_marker);\n-        call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), r0, r2);\n-        __ verify_oop(r0);\n-      __ bind(Done);\n+      __ load_unsigned_short(index, Address(r2, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+      __ read_flat_field(r2, index, r1, tmp \/* temp *\/, r0);\n+      __ verify_oop(r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":36,"deletions":108,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -1084,1 +1084,1 @@\n-  Label alloc_failed, done;\n+  Label alloc_failed, slow_path, done;\n@@ -1089,2 +1089,4 @@\n-  \/\/ FIXME: code below could be re-written to better use InlineLayoutInfo data structure\n-  \/\/ see aarch64 version\n+  \/\/ If the field is nullable, jump to slow path\n+  load_unsigned_byte(tmp1, Address(entry, in_bytes(ResolvedFieldEntry::flags_offset())));\n+  testl(tmp1, 1 << ResolvedFieldEntry::is_null_free_inline_type_shift);\n+  jcc(Assembler::equal, slow_path);\n@@ -1095,0 +1097,1 @@\n+\n@@ -1099,1 +1102,1 @@\n-  push(obj);  \/\/ push object being read from     \/\/ FIXME spilling on stack could probably be avoided by using tmp2\n+  push(obj);  \/\/ push object being read from\n@@ -1113,1 +1116,0 @@\n-  \/\/ access_value_copy(IS_DEST_UNINITIALIZED, tmp2, dst_temp, field_klass);\n@@ -1120,0 +1122,1 @@\n+  bind(slow_path);\n@@ -1126,0 +1129,32 @@\n+void InterpreterMacroAssembler::write_flat_field(Register entry, Register tmp1, Register tmp2,\n+                                                 Register obj, Register off, Register value) {\n+  assert_different_registers(entry, tmp1, tmp2, obj, off, value);\n+\n+  Label slow_path, done;\n+\n+  load_unsigned_byte(tmp2, Address(entry, in_bytes(ResolvedFieldEntry::flags_offset())));\n+  test_field_is_not_null_free_inline_type(tmp2, tmp1, slow_path);\n+\n+  null_check(value); \/\/ FIXME JDK-8341120\n+\n+  lea(obj, Address(obj, off, Address::times_1));\n+\n+  load_klass(tmp2, value, tmp1);\n+  payload_addr(value, value, tmp2);\n+\n+  Register idx = tmp1;\n+  load_unsigned_short(idx, Address(entry, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+  movptr(tmp2, Address(entry, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n+\n+  Register layout_info = off;\n+  inline_layout_info(tmp2, idx, layout_info);\n+\n+  flat_field_copy(IN_HEAP, value, obj, layout_info);\n+  jmp(done);\n+\n+  bind(slow_path);\n+  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_flat_field), obj, value, entry);\n+\n+  bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -218,0 +218,3 @@\n+  void write_flat_field(Register entry,\n+                        Register tmp1, Register tmp2,\n+                        Register obj, Register off, Register value);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2681,14 +2681,2 @@\n-      Label is_null_free_inline_type, uninitialized;\n-      \/\/ Issue below if the static field has not been initialized yet\n-      __ test_field_is_null_free_inline_type(flags, rscratch1, is_null_free_inline_type);\n-        \/\/ field is not a null free inline type\n-        __ push(atos);\n-        __ jmp(Done);\n-      \/\/ field is a null free inline type, must not return null even if uninitialized\n-      __ bind(is_null_free_inline_type);\n-          __ testptr(rax, rax);\n-        __ jcc(Assembler::zero, uninitialized);\n-          __ push(atos);\n-          __ jmp(Done);\n-        __ bind(uninitialized);\n-          __ jump(RuntimeAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n+      __ push(atos);\n+      __ jmp(Done);\n@@ -2696,4 +2684,2 @@\n-      Label is_flat, nonnull, is_null_free_inline_type, rewrite_inline, has_null_marker;\n-      __ test_field_is_null_free_inline_type(flags, rscratch1, is_null_free_inline_type);\n-      __ test_field_has_null_marker(flags, rscratch1, has_null_marker);\n-      \/\/ field is not a null free inline type\n+      Label is_flat, rewrite_inline;\n+      __ test_field_is_flat(flags, rscratch1, is_flat);\n@@ -2707,24 +2693,6 @@\n-      __ bind(is_null_free_inline_type);\n-      __ test_field_is_flat(flags, rscratch1, is_flat);\n-          \/\/ field is not flat\n-          pop_and_check_object(obj);\n-          __ load_heap_oop(rax, field);\n-          __ testptr(rax, rax);\n-          __ jcc(Assembler::notZero, nonnull);\n-          __ jump(RuntimeAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n-          __ bind(nonnull);\n-          __ verify_oop(rax);\n-          __ push(atos);\n-          __ jmp(rewrite_inline);\n-        __ bind(is_flat);\n-          pop_and_check_object(rax);\n-          __ read_flat_field(rcx, rdx, rbx, rax);\n-          __ verify_oop(rax);\n-          __ push(atos);\n-          __ jmp(rewrite_inline);\n-      __ bind(has_null_marker);\n-        pop_and_check_object(rax);\n-        __ load_field_entry(rcx, rbx);\n-        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), rax, rcx);\n-        __ get_vm_result_oop(rax);\n-        __ push(atos);\n+      __ bind(is_flat);\n+      \/\/ field is flat (null-free or nullable with a null-marker)\n+      pop_and_check_object(rax);\n+      __ read_flat_field(rcx, rdx, rbx, rax);\n+      __ verify_oop(rax);\n+      __ push(atos);\n@@ -2735,1 +2703,1 @@\n-        __ jmp(Done);\n+      __ jmp(Done);\n@@ -2992,4 +2960,4 @@\n-        Label is_inline_type;\n-        __ test_field_is_not_null_free_inline_type(flags, rscratch1, is_inline_type);\n-        __ null_check(rax);\n-        __ bind(is_inline_type);\n+        Label is_nullable;\n+        __ test_field_is_not_null_free_inline_type(flags, rscratch1, is_nullable);\n+        __ null_check(rax);  \/\/ FIXME JDK-8341120\n+        __ bind(is_nullable);\n@@ -2999,38 +2967,19 @@\n-        Label is_null_free_inline_type, is_flat, has_null_marker,\n-              write_null, rewrite_not_inline, rewrite_inline;\n-        __ test_field_is_null_free_inline_type(flags, rscratch1, is_null_free_inline_type);\n-        __ test_field_has_null_marker(flags, rscratch1, has_null_marker);\n-          \/\/ Not an inline type\n-          pop_and_check_object(obj);\n-          \/\/ Store into the field\n-          do_oop_store(_masm, field, rax);\n-          __ bind(rewrite_not_inline);\n-          if (rc == may_rewrite) {\n-            patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n-          }\n-          __ jmp(Done);\n-        \/\/ Implementation of the inline type semantic\n-        __ bind(is_null_free_inline_type);\n-          __ null_check(rax);\n-          __ test_field_is_flat(flags, rscratch1, is_flat);\n-            \/\/ field is not flat\n-            pop_and_check_object(obj);\n-            \/\/ Store into the field\n-            do_oop_store(_masm, field, rax);\n-          __ jmp(rewrite_inline);\n-          __ bind(is_flat);\n-            \/\/ field is flat\n-            __ load_unsigned_short(rdx, Address(rcx, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-            __ movptr(r9, Address(rcx, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n-            pop_and_check_object(obj);  \/\/ obj = rcx\n-            __ load_klass(r8, rax, rscratch1);\n-            __ payload_addr(rax, rax, r8);\n-            __ addptr(obj, off);\n-            __ inline_layout_info(r9, rdx, rbx);\n-            \/\/ because we use InlineLayoutInfo, we need special value access code specialized for fields (arrays will need a different API)\n-            __ flat_field_copy(IN_HEAP, rax, obj, rbx);\n-            __ jmp(rewrite_inline);\n-        __ bind(has_null_marker); \/\/ has null marker means the field is flat with a null marker\n-          pop_and_check_object(rbx);\n-          __ load_field_entry(rcx, rdx);\n-          call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), rbx, rax, rcx);\n+        Label is_flat, null_free_reference, rewrite_inline;\n+        __ test_field_is_flat(flags, rscratch1, is_flat);\n+        __ test_field_is_null_free_inline_type(flags, rscratch1, null_free_reference);\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, rax);\n+        if (rc == may_rewrite) {\n+          patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+        }\n+        __ jmp(Done);\n+        __ bind(null_free_reference);\n+        __ null_check(rax);  \/\/ FIXME JDK-8341120\n+        pop_and_check_object(obj);\n+        \/\/ Store into the field\n+        do_oop_store(_masm, field, rax);\n+        __ jmp(rewrite_inline);\n+        __ bind(is_flat);\n+        pop_and_check_object(r8);\n+        __ write_flat_field(rcx, r9, rscratch2, r8, rbx, rax);\n@@ -3264,4 +3213,2 @@\n-      Label is_flat, has_null_marker, write_null, done;\n-      __ test_field_has_null_marker(flags, rscratch1, has_null_marker);\n-      \/\/ Null free field cases: flat or not flat\n-      __ null_check(rax);\n+      \/\/ Field is either flat (nullable or not) or non-flat and null-free\n+      Label is_flat, done;\n@@ -3269,3 +3216,3 @@\n-        \/\/ field is not flat\n-        do_oop_store(_masm, field, rax);\n-        __ jmp(done);\n+      __ null_check(rax);  \/\/ FIXME JDK-8341120\n+      do_oop_store(_masm, field, rax);\n+      __ jmp(done);\n@@ -3273,13 +3220,3 @@\n-        __ load_field_entry(r8, r9);\n-        __ load_unsigned_short(r9, Address(r8, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-        __ movptr(r8, Address(r8, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n-        __ inline_layout_info(r8, r9, r8);\n-        __ load_klass(rdx, rax, rscratch1);\n-        __ payload_addr(rax, rax, rdx);\n-        __ lea(rcx, field);\n-        __ flat_field_copy(IN_HEAP, rax, rcx, r8);\n-        __ jmp(done);\n-      __ bind(has_null_marker); \/\/ has null marker means the field is flat with a null marker\n-        __ movptr(rbx, rcx);\n-        __ load_field_entry(rcx, rdx);\n-        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), rbx, rax, rcx);\n+      __ load_field_entry(r8, r9);\n+      __ movptr(r9, rcx);  \/\/ re-shuffle registers because of VM call calling convention\n+      __ write_flat_field(r8, rscratch1, rscratch2, r9, rbx, rax);\n@@ -3358,24 +3295,2 @@\n-    {\n-      Label is_flat, nonnull, Done, has_null_marker;\n-      __ load_unsigned_byte(rscratch1, Address(rcx, in_bytes(ResolvedFieldEntry::flags_offset())));\n-      __ test_field_has_null_marker(rscratch1, rscratch2, has_null_marker);\n-      __ test_field_is_flat(rscratch1, rscratch2, is_flat);\n-        \/\/ field is not flat\n-        __ load_heap_oop(rax, field);\n-        __ testptr(rax, rax);\n-        __ jcc(Assembler::notZero, nonnull);\n-          __ jump(RuntimeAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n-        __ bind(nonnull);\n-        __ verify_oop(rax);\n-        __ jmp(Done);\n-      __ bind(is_flat);\n-      \/\/ field is flat\n-        __ read_flat_field(rcx, rdx, rbx, rax);\n-        __ jmp(Done);\n-      __ bind(has_null_marker);\n-        \/\/ rax = instance, rcx = resolved entry\n-        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), rax, rcx);\n-        __ get_vm_result_oop(rax);\n-      __ bind(Done);\n-      __ verify_oop(rax);\n-    }\n+    __ read_flat_field(rcx, rdx, rbx, rax);\n+    __ verify_oop(rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":44,"deletions":129,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -254,23 +254,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::read_nullable_flat_field(JavaThread* current, oopDesc* obj, ResolvedFieldEntry* entry))\n-  assert(oopDesc::is_oop(obj), \"Sanity check\");\n-  assert(entry->has_null_marker(), \"Otherwise should not get there\");\n-  Handle obj_h(THREAD, obj);\n-\n-  InstanceKlass* holder = entry->field_holder();\n-  int field_index = entry->field_index();\n-  InlineLayoutInfo* li= holder->inline_layout_info_adr(field_index);\n-\n-#ifdef ASSERT\n-  fieldDescriptor fd;\n-  bool found = holder->find_field_from_offset(entry->field_offset(), false, &fd);\n-  assert(found, \"Field not found\");\n-  assert(fd.is_flat(), \"Field must be flat\");\n-#endif \/\/ ASSERT\n-\n-  InlineKlass* field_vklass = InlineKlass::cast(li->klass());\n-  oop res = field_vklass->read_payload_from_addr(obj_h(), entry->field_offset(), li->kind(), CHECK);\n-  current->set_vm_result_oop(res);\n-\n-JRT_END\n-\n-JRT_ENTRY(void, InterpreterRuntime::write_nullable_flat_field(JavaThread* current, oopDesc* obj, oopDesc* value, ResolvedFieldEntry* entry))\n+JRT_ENTRY(void, InterpreterRuntime::write_flat_field(JavaThread* current, oopDesc* obj, oopDesc* value, ResolvedFieldEntry* entry))\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -66,2 +66,1 @@\n-  static void    read_nullable_flat_field(JavaThread* current, oopDesc* object, ResolvedFieldEntry* entry);\n-  static void    write_nullable_flat_field(JavaThread* current, oopDesc* object, oopDesc* value, ResolvedFieldEntry* entry);\n+  static void    write_flat_field(JavaThread* current, oopDesc* object, oopDesc* value, ResolvedFieldEntry* entry);\n@@ -94,1 +93,0 @@\n-  static void    throw_NPE_UninitializedField_entry(JavaThread* current);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,1 +212,0 @@\n-address    TemplateInterpreter::_throw_NPE_UninitializedField_entry         = nullptr;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-  static address    _throw_NPE_UninitializedField_entry;\n@@ -157,1 +156,0 @@\n-  static address    throw_NPE_UninitializedField_entry()        { return _throw_NPE_UninitializedField_entry; }\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,1 +174,0 @@\n-    Interpreter::_throw_NPE_UninitializedField_entry         = generate_exception_handler(\"java\/lang\/NullPointerException\", \"Uninitialized null-restricted field\");\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}