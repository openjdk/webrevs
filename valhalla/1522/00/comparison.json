{"files":[{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record AddNameToken(Name name) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/AddNameToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class collects code, i.e. {@link String}s or {@link List}s of {@link String}s.\n+ * All the {@link String}s are later collected in a {@link StringBuilder}. If we used a {@link StringBuilder}\n+ * directly to collect the {@link String}s, we could not as easily insert code at an \"earlier\" position, i.e.\n+ * reaching out to a {@link Hook#anchor}.\n+ *\/\n+sealed interface Code permits Code.Token, Code.CodeList {\n+\n+    record Token(String s) implements Code {\n+        @Override\n+        public void renderTo(StringBuilder builder) {\n+            builder.append(s);\n+        }\n+    }\n+\n+    record CodeList(List<Code> list) implements Code {\n+        @Override\n+        public void renderTo(StringBuilder builder) {\n+            list.forEach(code -> code.renderTo(builder));\n+        }\n+    }\n+\n+    void renderTo(StringBuilder builder);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Code.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The {@link CodeFrame} represents a frame (i.e. scope) of code, appending {@link Code} to the {@code 'codeList'}\n+ * as {@link Token}s are rendered, and adding names to the {@link NameSet}s with {@link Template#addStructuralName}\/\n+ * {@link Template#addDataName}. {@link Hook}s can be added to a frame, which allows code to be inserted at that\n+ * location later. When a {@link Hook} is {@link Hook#anchor}ed, it separates the Template into an outer and inner\n+ * {@link CodeFrame}, ensuring that names that are added inside the inner frame are only available inside that frame.\n+ *\n+ * <p>\n+ * On the other hand, each {@link TemplateFrame} represents the frame (or scope) of exactly one use of a\n+ * Template.\n+ *\n+ * <p>\n+ * For simple Template nesting, the {@link CodeFrame}s and {@link TemplateFrame}s overlap exactly.\n+ * However, when using {@link Hook#insert}, we simply nest {@link TemplateFrame}s, going further \"in\",\n+ * but we jump to an outer {@link CodeFrame}, ensuring that we insert {@link Code} at the outer frame,\n+ * and operating on the names of the outer frame. Once the {@link Hook#insert}ion is complete, we jump\n+ * back to the caller {@link TemplateFrame} and {@link CodeFrame}.\n+ *\/\n+class CodeFrame {\n+    public final CodeFrame parent;\n+    private final List<Code> codeList = new ArrayList<>();\n+    private final Map<Hook, Code.CodeList> hookCodeLists = new HashMap<>();\n+\n+    \/**\n+     * The {@link NameSet} is used for variable and fields etc.\n+     *\/\n+    private final NameSet names;\n+\n+    private CodeFrame(CodeFrame parent, boolean isTransparentForNames) {\n+        this.parent = parent;\n+        if (parent == null) {\n+            \/\/ NameSet without any parent.\n+            this.names = new NameSet(null);\n+        } else if (isTransparentForNames) {\n+            \/\/ We use the same NameSet as the parent - makes it transparent.\n+            this.names = parent.names;\n+        } else {\n+            \/\/ New NameSet, to make sure we have a nested scope for the names.\n+            this.names = new NameSet(parent.names);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a base frame, which has no {@link #parent}.\n+     *\/\n+    public static CodeFrame makeBase() {\n+        return new CodeFrame(null, false);\n+    }\n+\n+    \/**\n+     * Creates a normal frame, which has a {@link #parent} and which defines an inner\n+     * {@link NameSet}, for the names that are generated inside this frame. Once this\n+     * frame is exited, the name from inside this frame are not available anymore.\n+     *\/\n+    public static CodeFrame make(CodeFrame parent) {\n+        return new CodeFrame(parent, false);\n+    }\n+\n+    \/**\n+     * Creates a special frame, which has a {@link #parent} but uses the {@link NameSet}\n+     * from the parent frame, allowing {@link Template#addDataName}\/\n+     * {@link Template#addStructuralName} to persist in the outer frame when the current frame\n+     * is exited. This is necessary for {@link Hook#insert},  where we would possibly want to\n+     * make field or variable definitions during the insertion that are not just local to the\n+     * insertion but affect the {@link CodeFrame} that we {@link Hook#anchor} earlier and are\n+     * now {@link Hook#insert}ing into.\n+     *\/\n+    public static CodeFrame makeTransparentForNames(CodeFrame parent) {\n+        return new CodeFrame(parent, true);\n+    }\n+\n+    void addString(String s) {\n+        codeList.add(new Code.Token(s));\n+    }\n+\n+    void addCode(Code code) {\n+        codeList.add(code);\n+    }\n+\n+    void addHook(Hook hook) {\n+        if (hasHook(hook)) {\n+            \/\/ This should never happen, as we add a dedicated CodeFrame for each hook.\n+            throw new RuntimeException(\"Internal error: Duplicate Hook in CodeFrame: \" + hook.name());\n+        }\n+        hookCodeLists.put(hook, new Code.CodeList(new ArrayList<>()));\n+    }\n+\n+    private boolean hasHook(Hook hook) {\n+        return hookCodeLists.containsKey(hook);\n+    }\n+\n+    CodeFrame codeFrameForHook(Hook hook) {\n+        CodeFrame current = this;\n+        while (current != null) {\n+            if (current.hasHook(hook)) {\n+                return current;\n+            }\n+            current = current.parent;\n+        }\n+        return null;\n+    }\n+\n+    void addName(Name name) {\n+        names.add(name);\n+    }\n+\n+    Name sampleName(NameSet.Predicate predicate) {\n+        return names.sample(predicate);\n+    }\n+\n+    int countNames(NameSet.Predicate predicate) {\n+        return names.count(predicate);\n+    }\n+\n+    boolean hasAnyNames(NameSet.Predicate predicate) {\n+        return names.hasAny(predicate);\n+    }\n+\n+    List<Name> listNames(NameSet.Predicate predicate) {\n+        return names.toList(predicate);\n+    }\n+\n+    Code getCode() {\n+        return new Code.CodeList(codeList);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/CodeFrame.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@link DataName}s represent things like fields and local variables, and can be added to the local\n+ * scope with {@link Template#addDataName}, and accessed with {@link Template#dataNames}, to\n+ * count, list or even sample random {@link DataName}s. Every {@link DataName} has a {@link DataName.Type},\n+ * so that sampling can be restricted to these types.\n+ *\n+ * <p>\n+ * For method and class names and alike, there are the analogous {@link StructuralName}s.\n+ *\n+ * @param name The {@link String} name used in code.\n+ * @param type The type of the {@link DataName}.\n+ * @param mutable Defines if the {@link DataName} is considered mutable or immutable.\n+ * @param weight The weight of the {@link DataName}, it corresponds to the probability of choosing this\n+ *               {@link DataName} when sampling later on.\n+ *\/\n+public record DataName(String name, DataName.Type type, boolean mutable, int weight) implements Name {\n+\n+    \/**\n+     * {@link Mutability} defines the possible states of {@link DataName}s, or the\n+     * desired state when filtering.\n+     *\/\n+    public enum Mutability {\n+        \/**\n+         * Used for mutable fields and variables, i.e. writing is allowed.\n+         *\/\n+        MUTABLE,\n+        \/**\n+         * Used for immutable fields and variables, i.e. writing is not allowed,\n+         * for example because the field or variable is final.\n+         *\/\n+        IMMUTABLE,\n+        \/**\n+         * When filtering, we sometimes want to indicate that we accept\n+         * mutable and immutable fields and variables, for example when\n+         * we are only reading, the mutability state does not matter.\n+         *\/\n+        MUTABLE_OR_IMMUTABLE\n+    }\n+\n+    \/**\n+     * Creates a new {@link DataName}.\n+     *\/\n+    public DataName {\n+    }\n+\n+    \/**\n+     * The interface for the type of a {@link DataName}.\n+     *\/\n+    public interface Type extends Name.Type {\n+        \/**\n+         * The name of the type, that can be used in code.\n+         *\n+         * @return The {@link String} representation of the type, that can be used in code.\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Defines the subtype relationship with other types, which is used to filter {@link DataName}s\n+         * in {@link FilteredSet#exactOf}, {@link FilteredSet#subtypeOf}, and {@link FilteredSet#supertypeOf}.\n+         *\n+         * @param other The other type, where we check if it is the supertype of {@code 'this'}.\n+         * @return If {@code 'this'} is a subtype of {@code 'other'}.\n+         *\/\n+        boolean isSubtypeOf(DataName.Type other);\n+    }\n+\n+    \/**\n+     * The {@link FilteredSet} represents a filtered set of {@link DataName}s in the current scope.\n+     * It can be obtained with {@link Template#dataNames}. It can be used to count the\n+     * available {@link DataName}s, or sample a random {@link DataName} according to the\n+     * weights of the {@link DataName}s in the filtered set.\n+     * Note: The {@link FilteredSet} is only a filtered view on the set of {@link DataName}s,\n+     * and may return different results in different contexts.\n+     *\/\n+    public static final class FilteredSet {\n+        private final Mutability mutability;\n+        private final DataName.Type subtype;\n+        private final DataName.Type supertype;\n+\n+        FilteredSet(Mutability mutability, DataName.Type subtype, DataName.Type supertype) {\n+            this.mutability = mutability;\n+            this.subtype = subtype;\n+            this.supertype = supertype;\n+        }\n+\n+        FilteredSet(Mutability mutability) {\n+            this(mutability, null, null);\n+        }\n+\n+        NameSet.Predicate predicate() {\n+            if (subtype == null && supertype == null) {\n+                throw new UnsupportedOperationException(\"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+            }\n+            return (Name name) -> {\n+                if (!(name instanceof DataName dataName)) { return false; }\n+                if (mutability == Mutability.MUTABLE && !dataName.mutable()) { return false; }\n+                if (mutability == Mutability.IMMUTABLE && dataName.mutable()) { return false; }\n+                if (subtype != null && !dataName.type().isSubtypeOf(subtype)) { return false; }\n+                if (supertype != null && !supertype.isSubtypeOf(dataName.type())) { return false; }\n+                return true;\n+            };\n+        }\n+\n+        \/**\n+         * Create a {@link FilteredSet}, where all {@link DataName}s must be subtypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link DataName}s must be subtypes of.\n+         * @return The updated filtered set.\n+         * @throws UnsupportedOperationException If this {@link FilteredSet} was already filtered with\n+         *                                       {@link #subtypeOf} or {@link #exactOf}.\n+         *\/\n+        public FilteredSet subtypeOf(DataName.Type type) {\n+            if (subtype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to subtype \" + type + \", is already constrained: \" + subtype);\n+            }\n+            return new FilteredSet(mutability, type, supertype);\n+        }\n+\n+        \/**\n+         * Create a {@link FilteredSet}, where all {@link DataName}s must be supertypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link DataName}s must be supertype of.\n+         * @return The updated filtered set.\n+         * @throws UnsupportedOperationException If this {@link FilteredSet} was already filtered with\n+         *                                       {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public FilteredSet supertypeOf(DataName.Type type) {\n+            if (supertype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to supertype \" + type + \", is already constrained: \" + supertype);\n+            }\n+            return new FilteredSet(mutability, subtype, type);\n+        }\n+\n+        \/**\n+         * Create a {@link FilteredSet}, where all {@link DataName}s must be of exact {@code type},\n+         * hence it must be both subtype and supertype thereof.\n+         *\n+         * @param type The type of which all {@link DataName}s must be.\n+         * @return The updated filtered set.\n+         * @throws UnsupportedOperationException If this {@link FilteredSet} was already filtered with\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public FilteredSet exactOf(DataName.Type type) {\n+            return subtypeOf(type).supertypeOf(type);\n+        }\n+\n+        \/**\n+         * Samples a random {@link DataName} from the filtered set, according to the weights\n+         * of the contained {@link DataName}s.\n+         *\n+         * @return The sampled {@link DataName}.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         * @throws RendererException If the set was empty.\n+         *\/\n+        public DataName sample() {\n+            DataName n = (DataName)Renderer.getCurrent().sampleName(predicate());\n+            if (n == null) {\n+                String msg1 = (subtype == null) ? \"\" : \", subtypeOf(\" + subtype + \")\";\n+                String msg2 = (supertype == null) ? \"\" : \", supertypeOf(\" + supertype + \")\";\n+                throw new RendererException(\"No variable: \" + mutability + msg1 + msg2 + \".\");\n+            }\n+            return n;\n+        }\n+\n+        \/**\n+         * Counts the number of {@link DataName}s in the filtered set.\n+         *\n+         * @return The number of {@link DataName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public int count() {\n+            return Renderer.getCurrent().countNames(predicate());\n+        }\n+\n+        \/**\n+         * Checks if there are any {@link DataName}s in the filtered set.\n+         *\n+         * @return Returns {@code true} iff there is at least one {@link DataName} in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public boolean hasAny() {\n+            return Renderer.getCurrent().hasAnyNames(predicate());\n+        }\n+\n+        \/**\n+         * Collects all {@link DataName}s in the filtered set.\n+         *\n+         * @return A {@link List} of all {@link DataName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public List<DataName> toList() {\n+            List<Name> list = Renderer.getCurrent().listNames(predicate());\n+            return list.stream().map(n -> (DataName)n).toList();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/DataName.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * {@link Hook}s can be {@link #anchor}ed for a certain scope in a Template, and all nested\n+ * Templates in this scope, and then from within this scope, any Template can\n+ * {@link #insert} code to where the {@link Hook} was {@link #anchor}ed. This can be useful to reach\n+ * \"back\" or to some outer scope, e.g. while generating code for a method, one can reach out\n+ * to the class scope to insert fields.\n+ *\n+ * <p>\n+ * Example:\n+ * {@snippet lang=java :\n+ * var myHook = new Hook(\"MyHook\");\n+ *\n+ * var template1 = Template.make(\"name\", (String name) -> body(\n+ *     \"\"\"\n+ *     public static int #name = 42;\n+ *     \"\"\"\n+ * ));\n+ *\n+ * var template2 = Template.make(() -> body(\n+ *     \"\"\"\n+ *     public class Test {\n+ *     \"\"\",\n+ *     \/\/ Anchor the hook here.\n+ *     myHook.anchor(\n+ *         \"\"\"\n+ *         public static void main(String[] args) {\n+ *         System.out.println(\"$field: \" + $field)\n+ *         \"\"\",\n+ *         \/\/ Reach out to where the hook was anchored, and insert the code of template1.\n+ *         myHook.insert(template1.asToken($(\"field\"))),\n+ *         \"\"\"\n+ *         }\n+ *         \"\"\"\n+ *     ),\n+ *     \"\"\"\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * @param name The name of the Hook, for debugging purposes only.\n+ *\/\n+public record Hook(String name) {\n+    \/**\n+     * Anchor this {@link Hook} for the scope of the provided {@code 'tokens'}.\n+     * From anywhere inside this scope, even in nested Templates, code can be\n+     * {@link #insert}ed back to the location where this {@link Hook} was {@link #anchor}ed.\n+     *\n+     * @param tokens A list of tokens, which have the same restrictions as {@link Template#body}.\n+     * @return A {@link Token} that captures the anchoring of the scope and the list of validated {@link Token}s.\n+     *\/\n+    public Token anchor(Object... tokens) {\n+        return new HookAnchorToken(this, TokenParser.parse(tokens));\n+    }\n+\n+    \/**\n+     * Inserts a {@link TemplateToken} to the innermost location where this {@link Hook} was {@link #anchor}ed.\n+     * This could be in the same Template, or one nested further out.\n+     *\n+     * @param templateToken The Template with applied arguments to be inserted at the {@link Hook}.\n+     * @return The {@link Token} which when used inside a {@link Template#body} performs the code insertion into the {@link Hook}.\n+     *\/\n+    public Token insert(TemplateToken templateToken) {\n+        return new HookInsertToken(this, templateToken);\n+    }\n+\n+    \/**\n+     * Checks if the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope.\n+     *\n+     * @return If the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope.\n+     *\/\n+    public boolean isAnchored() {\n+        return Renderer.getCurrent().isAnchored(this);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+record HookAnchorToken(Hook hook, List<Token> tokens) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookAnchorToken.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record HookInsertToken(Hook hook, TemplateToken templateToken) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookInsertToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+sealed interface Name permits DataName, StructuralName {\n+    \/**\n+     * The name of the name, that can be used in code.\n+     *\n+     * @return The {@link String} name of the name, that can be used in code.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * The type of the name, allowing for filtering by type.\n+     *\n+     * @return The type of the name.\n+     *\/\n+    Type type();\n+\n+    \/**\n+     * The weight of the name, corresponds to the probability of\n+     * choosing this name when sampling.\n+     *\n+     * @return The weight of the name.\n+     *\/\n+    int weight();\n+\n+    interface Type {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Name.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Optional;\n+\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * The {@link NameSet} defines a set of {@link Name}s (e.g. fields or variable names). They extend the\n+ * set of the {@code 'parent'} set.\n+ *\/\n+class NameSet {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private final NameSet parent;\n+    private final List<NameSet> children = new ArrayList<>();\n+    private final List<Name> names = new ArrayList<>();\n+\n+    interface Predicate {\n+        boolean check(Name type);\n+    }\n+\n+    NameSet(NameSet parent) {\n+        this.parent = parent;\n+        if (parent != null) { parent.registerChild(this); }\n+    }\n+\n+    void registerChild(NameSet child) {\n+        children.add(child);\n+    }\n+\n+    private long weight(Predicate predicate) {\n+        long w = names.stream().filter(predicate::check).mapToInt(Name::weight).sum();\n+        if (parent != null) { w += parent.weight(predicate); }\n+        return w;\n+    }\n+\n+    public int count(Predicate predicate) {\n+        int c = (int)names.stream().filter(predicate::check).count();\n+        if (parent != null) { c += parent.count(predicate); }\n+        return c;\n+    }\n+\n+    public boolean hasAny(Predicate predicate) {\n+        return names.stream().anyMatch(predicate::check) ||\n+               (parent != null && parent.hasAny(predicate));\n+    }\n+\n+    public List<Name> toList(Predicate predicate) {\n+        List<Name> list = (parent != null) ? parent.toList(predicate)\n+                                           : new ArrayList<>();\n+        list.addAll(names.stream().filter(predicate::check).toList());\n+        return list;\n+    }\n+\n+    \/**\n+     * Randomly sample a name from this set or a parent set, restricted to the predicate.\n+     *\/\n+    public Name sample(Predicate predicate) {\n+        long w = weight(predicate);\n+        if (w <= 0) {\n+            \/\/ Negative weight should never happen, as all names have positive weight.\n+            if (w < 0) {\n+                throw new RuntimeException(\"Negative weight not allowed: \" + w);\n+            }\n+            \/\/ If the weight is zero, there is no matching Name available.\n+            \/\/ Return null, and let the caller handle the situation, e.g.\n+            \/\/ throw an exception.\n+            return null;\n+        }\n+\n+        long r = RANDOM.nextLong(w);\n+        return sample(predicate, r);\n+    }\n+\n+    private Name sample(Predicate predicate, long r) {\n+        for (var name : names) {\n+            if (predicate.check(name)) {\n+                r -= name.weight();\n+                if (r < 0) { return name; }\n+            }\n+        }\n+        return parent.sample(predicate, r);\n+    }\n+\n+    private Name findLocal(String name) {\n+        Optional<Name> opt = names.stream().filter(n -> n.name().equals(name)).findAny();\n+        return opt.orElse(null);\n+    }\n+\n+    private Name findParents(String name) {\n+        if (parent == null) { return null; }\n+        Name n = parent.findLocal(name);\n+        if (n != null) { return n; }\n+        return parent.findParents(name);\n+    }\n+\n+    private Name findChildren(String name) {\n+        for (NameSet child : children) {\n+            Name n1 = child.findLocal(name);\n+            if (n1 != null) { return n1; }\n+            Name n2 = child.findChildren(name);\n+            if (n2 != null) { return n2; }\n+        }\n+        return null;\n+    }\n+\n+    private Name find(String name) {\n+        Name n1 = findLocal(name);\n+        if (n1 != null) { return n1; }\n+        Name n2 = findParents(name);\n+        if (n2 != null) { return n2; }\n+        return findChildren(name);\n+    }\n+\n+    \/**\n+     * Add a variable of a specified type to the set.\n+     *\/\n+    public void add(Name name) {\n+        Name other = find(name.name());\n+        if (other != null) {\n+            throw new RendererException(\"Duplicate name: \" + name + \", previously: \" + other);\n+        }\n+        names.add(name);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSet.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record NothingToken() implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NothingToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+# Template Framework\n+The Template Framework allows the generation of code with Templates. The goal is that these Templates are easy to write, and allow regression tests to cover a larger scope, and to make template based fuzzing easy to extend.\n+\n+We want to make it easy to generate variants of tests. Often, we would like to have a set of tests, corresponding to a set of types, a set of operators, a set of constants, etc. Writing all the tests by hand is cumbersome or even impossible. When generating such tests with scripts, it would be preferable if the code generation happens automatically, and the generator script was checked into the code base. Code generation can go beyond simple regression tests, and one might want to generate random code from a list of possible templates, to fuzz individual Java features and compiler optimizations.\n+\n+The Template Framework provides a facility to generate code with Templates. Templates are essentially a list of tokens that are concatenated (i.e. rendered) to a String. The Templates can have \"holes\", which are filled (replaced) by different values at each Template instantiation. For example, these \"holes\" can be filled with different types, operators or constants. Templates can also be nested, allowing a modular use of Templates.\n+\n+Detailed documentation can be found in [Template.java](.\/Template.java).\n+\n+The Template Framework only generates code in the form of a String. This code can then be compiled and executed, for example with the help of the [Compile Framework](..\/compile_framework\/README.md).\n+\n+The basic functionalities of the Template Framework are described in the [Template Interface](.\/Template.java), together with some examples. More examples can be found in [TestSimple.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestSimple.java), [TestAdvanced.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java) and [TestTutorial.java](..\/..\/..\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/README.md","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * The {@link Renderer} class renders a tokenized {@link Template} in the form of a {@link TemplateToken}.\n+ * It also keeps track of the states during a nested Template rendering. There can only be a single\n+ * {@link Renderer} active at any point, since there are static methods that reference\n+ * {@link Renderer#getCurrent}.\n+ *\n+ * <p>\n+ * The {@link Renderer} instance keeps track of the current frames.\n+ *\n+ * @see TemplateFrame\n+ * @see CodeFrame\n+ *\/\n+final class Renderer {\n+    private static final String NAME_CHARACTERS = \"[a-zA-Z_][a-zA-Z0-9_]*\";\n+    private static final Pattern NAME_PATTERN = Pattern.compile(\n+        \/\/ We are parsing patterns:\n+        \/\/   #name\n+        \/\/   #{name}\n+        \/\/   $name\n+        \/\/   ${name}\n+        \/\/ But the \"#\" or \"$\" have already been removed, and the String\n+        \/\/ starts at the character after that.\n+        \/\/ The pattern must be at the beginning of the String part.\n+        \"^\" +\n+        \/\/ We either have \"name\" or \"{name}\"\n+        \"(?:\" + \/\/ non-capturing group for the OR\n+            \/\/ capturing group for \"name\"\n+            \"(\" + NAME_CHARACTERS + \")\" +\n+        \"|\" + \/\/ OR\n+            \/\/ We want to trim off the brackets, so have\n+            \/\/ another non-capturing group.\n+            \"(?:\\\\{\" +\n+                \/\/ capturing group for \"name\" inside \"{name}\"\n+                \"(\" + NAME_CHARACTERS + \")\" +\n+            \"\\\\})\" +\n+        \")\");\n+    private static final Pattern NAME_CHARACTERS_PATTERN = Pattern.compile(\"^\" + NAME_CHARACTERS + \"$\");\n+\n+    static boolean isValidHashtagOrDollarName(String name) {\n+        return NAME_CHARACTERS_PATTERN.matcher(name).find();\n+    }\n+\n+    \/**\n+     * There can be at most one Renderer instance at any time.\n+     *\n+     * <p>\n+     * When using nested templates, the user of the Template Framework may be tempted to first render\n+     * the nested template to a {@link String}, and then use this {@link String} as a token in an outer\n+     * {@link Template#body}. This would be a bad pattern: the outer and nested {@link Template} would\n+     * be rendered separately, and could not interact. For example, the nested {@link Template} would\n+     * not have access to the scopes of the outer {@link Template}. The inner {@link Template} could\n+     * not access {@link Name}s and {@link Hook}s from the outer {@link Template}. The user might assume\n+     * that the inner {@link Template} has access to the outer {@link Template}, but they would actually\n+     * be separated. This could lead to unexpected behavior or even bugs.\n+     *\n+     * <p>\n+     * Instead, the user should create a {@link TemplateToken} from the inner {@link Template}, and\n+     * use that {@link TemplateToken} in the {@link Template#body} of the outer {@link Template}.\n+     * This way, the inner and outer {@link Template}s get rendered together, and the inner {@link Template}\n+     * has access to the {@link Name}s and {@link Hook}s of the outer {@link Template}.\n+     *\n+     * <p>\n+     * The {@link Renderer} instance exists during the whole rendering process. Should the user ever\n+     * attempt to render a nested {@link Template} to a {@link String}, we would detect that there is\n+     * already a {@link Renderer} instance for the outer {@link Template}, and throw a {@link RendererException}.\n+     *\/\n+    private static Renderer renderer = null;\n+\n+    private int nextTemplateFrameId;\n+    private final TemplateFrame baseTemplateFrame;\n+    private TemplateFrame currentTemplateFrame;\n+    private final CodeFrame baseCodeFrame;\n+    private CodeFrame currentCodeFrame;\n+\n+    \/\/ We do not want any other instances, so we keep it private.\n+    private Renderer(float fuel) {\n+        nextTemplateFrameId = 0;\n+        baseTemplateFrame = TemplateFrame.makeBase(nextTemplateFrameId++, fuel);\n+        currentTemplateFrame = baseTemplateFrame;\n+        baseCodeFrame = CodeFrame.makeBase();\n+        currentCodeFrame = baseCodeFrame;\n+    }\n+\n+    static Renderer getCurrent() {\n+        if (renderer == null) {\n+            throw new RendererException(\"A Template method such as '$', 'let', 'sample', 'count' etc. was called outside a template rendering.\");\n+        }\n+        return renderer;\n+    }\n+\n+    static String render(TemplateToken templateToken) {\n+        return render(templateToken, Template.DEFAULT_FUEL);\n+    }\n+\n+    static String render(TemplateToken templateToken, float fuel) {\n+        \/\/ Check nobody else is using the Renderer.\n+        if (renderer != null) {\n+            throw new RendererException(\"Nested render not allowed. Please only use 'asToken' inside Templates, and call 'render' only once at the end.\");\n+        }\n+        try {\n+            renderer = new Renderer(fuel);\n+            renderer.renderTemplateToken(templateToken);\n+            renderer.checkFrameConsistencyAfterRendering();\n+            return renderer.collectCode();\n+        } finally {\n+            \/\/ Release the Renderer.\n+            renderer = null;\n+        }\n+    }\n+\n+    private void checkFrameConsistencyAfterRendering() {\n+        \/\/ Ensure CodeFrame consistency.\n+        if (baseCodeFrame != currentCodeFrame) {\n+            throw new RuntimeException(\"Internal error: Renderer did not end up at base CodeFrame.\");\n+        }\n+        \/\/ Ensure TemplateFrame consistency.\n+        if (baseTemplateFrame != currentTemplateFrame) {\n+            throw new RuntimeException(\"Internal error: Renderer did not end up at base TemplateFrame.\");\n+        }\n+    }\n+\n+    private String collectCode() {\n+        StringBuilder builder = new StringBuilder();\n+        baseCodeFrame.getCode().renderTo(builder);\n+        return builder.toString();\n+    }\n+\n+    String $(String name) {\n+        return currentTemplateFrame.$(name);\n+    }\n+\n+    void addHashtagReplacement(String key, Object value) {\n+        currentTemplateFrame.addHashtagReplacement(key, format(value));\n+    }\n+\n+    private String getHashtagReplacement(String key) {\n+        return currentTemplateFrame.getHashtagReplacement(key);\n+    }\n+\n+    float fuel() {\n+        return currentTemplateFrame.fuel;\n+    }\n+\n+    void setFuelCost(float fuelCost) {\n+        currentTemplateFrame.setFuelCost(fuelCost);\n+    }\n+\n+    Name sampleName(NameSet.Predicate predicate) {\n+        return currentCodeFrame.sampleName(predicate);\n+    }\n+\n+    int countNames(NameSet.Predicate predicate) {\n+        return currentCodeFrame.countNames(predicate);\n+    }\n+\n+    boolean hasAnyNames(NameSet.Predicate predicate) {\n+        return currentCodeFrame.hasAnyNames(predicate);\n+    }\n+\n+    List<Name> listNames(NameSet.Predicate predicate) {\n+        return currentCodeFrame.listNames(predicate);\n+    }\n+\n+    \/**\n+     * Formats values to {@link String} with the goal of using them in Java code.\n+     * By default, we use the overrides of {@link Object#toString}.\n+     * But for some boxed primitives we need to create a special formatting.\n+     *\/\n+    static String format(Object value) {\n+        return switch (value) {\n+            case String s -> s;\n+            case Integer i -> i.toString();\n+            \/\/ We need to append the \"L\" so that the values are not interpreted as ints,\n+            \/\/ and then javac might complain that the values are too large for an int.\n+            case Long l -> l.toString() + \"L\";\n+            \/\/ Some Float and Double values like Infinity and NaN need a special representation.\n+            case Float f -> formatFloat(f);\n+            case Double d -> formatDouble(d);\n+            default -> value.toString();\n+        };\n+    }\n+\n+    private static String formatFloat(Float f) {\n+        if (Float.isFinite(f)) {\n+            return f.toString() + \"f\";\n+        } else if (f.isNaN()) {\n+            return \"Float.intBitsToFloat(\" + Float.floatToRawIntBits(f) + \" \/* NaN *\/)\";\n+        } else if (f.isInfinite()) {\n+            if (f > 0) {\n+                return \"Float.POSITIVE_INFINITY\";\n+            } else {\n+                return \"Float.NEGATIVE_INFINITY\";\n+            }\n+        } else {\n+            throw new RuntimeException(\"Not handled: \" + f);\n+        }\n+    }\n+\n+    private static String formatDouble(Double d) {\n+        if (Double.isFinite(d)) {\n+            return d.toString();\n+        } else if (d.isNaN()) {\n+            return \"Double.longBitsToDouble(\" + Double.doubleToRawLongBits(d) + \"L \/* NaN *\/)\";\n+        } else if (d.isInfinite()) {\n+            if (d > 0) {\n+                return \"Double.POSITIVE_INFINITY\";\n+            } else {\n+                return \"Double.NEGATIVE_INFINITY\";\n+            }\n+        } else {\n+            throw new RuntimeException(\"Not handled: \" + d);\n+        }\n+    }\n+\n+    private void renderTemplateToken(TemplateToken templateToken) {\n+        TemplateFrame templateFrame = TemplateFrame.make(currentTemplateFrame, nextTemplateFrameId++);\n+        currentTemplateFrame = templateFrame;\n+\n+        templateToken.visitArguments((name, value) -> addHashtagReplacement(name, format(value)));\n+        TemplateBody body = templateToken.instantiate();\n+        renderTokenList(body.tokens());\n+\n+        if (currentTemplateFrame != templateFrame) {\n+            throw new RuntimeException(\"Internal error: TemplateFrame mismatch!\");\n+        }\n+        currentTemplateFrame = currentTemplateFrame.parent;\n+    }\n+\n+    private void renderToken(Token token) {\n+        switch (token) {\n+            case StringToken(String s) -> {\n+                renderStringWithDollarAndHashtagReplacements(s);\n+            }\n+            case NothingToken() -> {\n+                \/\/ Nothing.\n+            }\n+            case HookAnchorToken(Hook hook, List<Token> tokens) -> {\n+                CodeFrame outerCodeFrame = currentCodeFrame;\n+\n+                \/\/ We need a CodeFrame to which the hook can insert code. That way, name\n+                \/\/ definitions at the hook cannot escape the hookCodeFrame.\n+                CodeFrame hookCodeFrame = CodeFrame.make(outerCodeFrame);\n+                hookCodeFrame.addHook(hook);\n+\n+                \/\/ We need a CodeFrame where the tokens can be rendered. That way, name\n+                \/\/ definitions from the tokens cannot escape the innerCodeFrame to the\n+                \/\/ hookCodeFrame.\n+                CodeFrame innerCodeFrame = CodeFrame.make(hookCodeFrame);\n+                currentCodeFrame = innerCodeFrame;\n+\n+                renderTokenList(tokens);\n+\n+                \/\/ Close the hookCodeFrame and innerCodeFrame. hookCodeFrame code comes before the\n+                \/\/ innerCodeFrame code from the tokens.\n+                currentCodeFrame = outerCodeFrame;\n+                currentCodeFrame.addCode(hookCodeFrame.getCode());\n+                currentCodeFrame.addCode(innerCodeFrame.getCode());\n+            }\n+            case HookInsertToken(Hook hook, TemplateToken templateToken) -> {\n+                \/\/ Switch to hook CodeFrame.\n+                CodeFrame callerCodeFrame = currentCodeFrame;\n+                CodeFrame hookCodeFrame = codeFrameForHook(hook);\n+\n+                \/\/ Use a transparent nested CodeFrame. We need a CodeFrame so that the code generated\n+                \/\/ by the TemplateToken can be collected, and hook insertions from it can still\n+                \/\/ be made to the hookCodeFrame before the code from the TemplateToken is added to\n+                \/\/ the hookCodeFrame.\n+                \/\/ But the CodeFrame must be transparent, so that its name definitions go out to\n+                \/\/ the hookCodeFrame, and are not limited to the CodeFrame for the TemplateToken.\n+                currentCodeFrame = CodeFrame.makeTransparentForNames(hookCodeFrame);\n+\n+                renderTemplateToken(templateToken);\n+\n+                hookCodeFrame.addCode(currentCodeFrame.getCode());\n+\n+                \/\/ Switch back from hook CodeFrame to caller CodeFrame.\n+                currentCodeFrame = callerCodeFrame;\n+            }\n+            case TemplateToken templateToken -> {\n+                \/\/ Use a nested CodeFrame.\n+                CodeFrame callerCodeFrame = currentCodeFrame;\n+                currentCodeFrame = CodeFrame.make(currentCodeFrame);\n+\n+                renderTemplateToken(templateToken);\n+\n+                callerCodeFrame.addCode(currentCodeFrame.getCode());\n+                currentCodeFrame = callerCodeFrame;\n+            }\n+            case AddNameToken(Name name) -> {\n+                currentCodeFrame.addName(name);\n+            }\n+        }\n+    }\n+\n+    private void renderTokenList(List<Token> tokens) {\n+        CodeFrame codeFrame = currentCodeFrame;\n+        for (Token t : tokens) {\n+            renderToken(t);\n+        }\n+        if (codeFrame != currentCodeFrame) {\n+            throw new RuntimeException(\"Internal error: CodeFrame mismatch.\");\n+        }\n+    }\n+\n+    \/**\n+     * We split a {@link String} by \"#\" and \"$\", and then look at each part.\n+     * Example:\n+     *\n+     *  s:    \"abcdefghijklmnop #name abcdefgh${var_name} 12345#{name2}_con $field_name something\"\n+     *  parts: --------0-------- ------1------ --------2------- ------3----- ----------4---------\n+     *  start: ^                 ^             ^                ^            ^\n+     *  next:                   ^             ^                ^            ^                    ^\n+     *         none             hashtag       dollar           hashtag      dollar               done\n+     *\/\n+    private void renderStringWithDollarAndHashtagReplacements(final String s) {\n+        int count = 0; \/\/ First part needs special handling\n+        int start = 0;\n+        boolean startIsAfterDollar = false;\n+        do {\n+            \/\/ Find the next \"$\" or \"#\", after start.\n+            int dollar  = s.indexOf(\"$\", start);\n+            int hashtag = s.indexOf(\"#\", start);\n+            \/\/ If the character was not found, we want to have the rest of the\n+            \/\/ String s, so instead of \"-1\" take the end\/length of the String.\n+            dollar  = (dollar == -1)  ? s.length() : dollar;\n+            hashtag = (hashtag == -1) ? s.length() : hashtag;\n+            \/\/ Take the first one.\n+            int next = Math.min(dollar, hashtag);\n+            String part = s.substring(start, next);\n+\n+            if (count == 0) {\n+                \/\/ First part has no \"#\" or \"$\" before it.\n+                currentCodeFrame.addString(part);\n+            } else {\n+                \/\/ All others must do the replacement.\n+                renderStringWithDollarAndHashtagReplacementsPart(s, part, startIsAfterDollar);\n+            }\n+\n+            if (next == s.length()) {\n+                \/\/ No new \"#\" or \"$\" was found, we just processed the rest of the String,\n+                \/\/ terminate now.\n+                return;\n+            }\n+            start = next + 1; \/\/ skip over the \"#\" or \"$\"\n+            startIsAfterDollar = next == dollar; \/\/ remember which character we just split with\n+            count++;\n+        } while (true);\n+    }\n+\n+    \/**\n+     * We are parsing a part now. Before the part, there was either a \"#\" or \"$\":\n+     * isDollar = false:\n+     *   \"#part\"\n+     *   \"#name abcdefgh\"\n+     *     ----\n+     *   \"#{name2}_con \"\n+     *     -------\n+     *\n+     * isDollar = true:\n+     *   \"$part\"\n+     *   \"${var_name} 12345\"\n+     *     ----------\n+     *   \"$field_name something\"\n+     *     ----------\n+     *\n+     * We now want to find the name pattern at the beginning of the part, and replace\n+     * it according to the hashtag or dollar replacement strategy.\n+     *\/\n+    private void renderStringWithDollarAndHashtagReplacementsPart(final String s, final String part, final boolean isDollar) {\n+        Matcher matcher = NAME_PATTERN.matcher(part);\n+        \/\/ If the string has a \"#\" or \"$\" that is not followed by a correct name\n+        \/\/ pattern, then the matcher will not match. These can be cases like:\n+        \/\/   \"##name\" -> the first hashtag leads to an empty part, and an empty name.\n+        \/\/   \"#1name\" -> the name pattern does not allow a digit as the first character.\n+        \/\/   \"anything#\" -> a hashtag at the end of the string leads to an empty name.\n+        if (!matcher.find()) {\n+            String replacement = isDollar ? \"$\" : \"#\";\n+            throw new RendererException(\"Is not a valid '\" + replacement + \"' replacement pattern: '\" +\n+                                        replacement + part + \"' in '\" + s + \"'.\");\n+        }\n+        \/\/ We know that there is a correct pattern, and now we replace it.\n+        currentCodeFrame.addString(matcher.replaceFirst(\n+            (MatchResult result) -> {\n+                \/\/ There are two groups: (1) for \"name\" and (2) for \"{name}\"\n+                String name = result.group(1) != null ? result.group(1) : result.group(2);\n+                if (isDollar) {\n+                    return $(name);\n+                } else {\n+                    \/\/ replaceFirst needs some special escaping of backslashes and ollar signs.\n+                    return getHashtagReplacement(name).replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\");\n+                }\n+            }\n+        ));\n+    }\n+\n+    boolean isAnchored(Hook hook) {\n+        return currentCodeFrame.codeFrameForHook(hook) != null;\n+    }\n+\n+    private CodeFrame codeFrameForHook(Hook hook) {\n+        CodeFrame codeFrame = currentCodeFrame.codeFrameForHook(hook);\n+        if (codeFrame == null) {\n+            throw new RendererException(\"Hook '\" + hook.name() + \"' was referenced but not found!\");\n+        }\n+        return codeFrame;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * This exception is thrown when something goes wrong during Template\n+ * rendering, or in the use of any of its static methods.\n+ * It most likely indicates a wrong use of the Templates.\n+ *\/\n+public class RendererException extends RuntimeException {\n+    RendererException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/RendererException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+record StringToken(String value) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/StringToken.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * {@link StructuralName}s represent things like method and class names, and can be added to the local\n+ * scope with {@link Template#addStructuralName}, and accessed with {@link Template#structuralNames}, from where\n+ * count, list or even sample random {@link StructuralName}s. Every {@link StructuralName} has a {@link StructuralName.Type},\n+ * so that sampling can be restricted to these types.\n+ *\n+ * <p>\n+ * For field and variable names and alike, there are the analogous {@link DataName}s.\n+ *\n+ * @param name The {@link String} name used in code.\n+ * @param type The type of the {@link StructuralName}.\n+ * @param weight The weight of the {@link StructuralName}, it corresponds to the probability of choosing this\n+ *               {@link StructuralName} when sampling later on.\n+ *\/\n+public record StructuralName(String name, StructuralName.Type type, int weight) implements Name {\n+\n+    \/**\n+     * Creates a new {@link StructuralName}.\n+     *\/\n+    public StructuralName {\n+    }\n+\n+    \/**\n+     * The interface for the type of a {@link StructuralName}.\n+     *\/\n+    public interface Type extends Name.Type {\n+        \/**\n+         * The name of the type, that can be used in code.\n+         *\n+         * @return The {@link String} representation of the type, that can be used in code.\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Defines the subtype relationship with other types, which is used to filter {@link StructuralName}s\n+         * in {@link FilteredSet#exactOf}, {@link FilteredSet#subtypeOf}, and {@link FilteredSet#supertypeOf}.\n+         *\n+         * @param other The other type, where we check if it is the supertype of {@code 'this'}.\n+         * @return If {@code 'this'} is a subtype of {@code 'other'}.\n+         *\/\n+        boolean isSubtypeOf(StructuralName.Type other);\n+    }\n+\n+    \/**\n+     * The {@link FilteredSet} represents a filtered set of {@link StructuralName}s in the current scope.\n+     * It can be obtained with {@link Template#structuralNames}. It can be used to count the\n+     * available {@link StructuralName}s, or sample a random {@link StructuralName} according to the\n+     * weights of the {@link StructuralName}s in the filtered set.\n+     * Note: The {@link FilteredSet} is only a filtered view on the set of {@link StructuralName}s,\n+     * and may return different results in different contexts.\n+     *\/\n+    public static final class FilteredSet {\n+        private final StructuralName.Type subtype;\n+        private final StructuralName.Type supertype;\n+\n+        FilteredSet(StructuralName.Type subtype, StructuralName.Type supertype) {\n+            this.subtype = subtype;\n+            this.supertype = supertype;\n+        }\n+\n+        FilteredSet() {\n+            this(null, null);\n+        }\n+\n+        NameSet.Predicate predicate() {\n+            if (subtype == null && supertype == null) {\n+                throw new UnsupportedOperationException(\"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+            }\n+            return (Name name) -> {\n+                if (!(name instanceof StructuralName structuralName)) { return false; }\n+                if (subtype != null && !structuralName.type().isSubtypeOf(subtype)) { return false; }\n+                if (supertype != null && !supertype.isSubtypeOf(structuralName.type())) { return false; }\n+                return true;\n+            };\n+        }\n+\n+        \/**\n+         * Create a {@link FilteredSet}, where all {@link StructuralName}s must be subtypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link StructuralName}s must be subtypes of.\n+         * @return The updated filtered set.\n+         * @throws UnsupportedOperationException If this {@link FilteredSet} was already filtered with\n+         *                                       {@link #subtypeOf} or {@link #exactOf}.\n+         *\/\n+        public FilteredSet subtypeOf(StructuralName.Type type) {\n+            if (subtype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to subtype \" + type + \", is already constrained: \" + subtype);\n+            }\n+            return new FilteredSet(type, supertype);\n+        }\n+\n+        \/**\n+         * Create a {@link FilteredSet}, where all {@link StructuralName}s must be supertypes of {@code type}.\n+         *\n+         * @param type The type of which all {@link StructuralName}s must be supertype of.\n+         * @return The updated filtered set.\n+         * @throws UnsupportedOperationException If this {@link FilteredSet} was already filtered with\n+         *                                       {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public FilteredSet supertypeOf(StructuralName.Type type) {\n+            if (supertype != null) {\n+                throw new UnsupportedOperationException(\"Cannot constrain to supertype \" + type + \", is already constrained: \" + supertype);\n+            }\n+            return new FilteredSet(subtype, type);\n+        }\n+\n+        \/**\n+         * Create a {@link FilteredSet}, where all {@link StructuralName}s must be of exact {@code type},\n+         * hence it must be both subtype and supertype thereof.\n+         *\n+         * @param type The type of which all {@link StructuralName}s must be.\n+         * @return The updated filtered set.\n+         * @throws UnsupportedOperationException If this {@link FilteredSet} was already filtered with\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public FilteredSet exactOf(StructuralName.Type type) {\n+            return subtypeOf(type).supertypeOf(type);\n+        }\n+\n+        \/**\n+         * Samples a random {@link StructuralName} from the filtered set, according to the weights\n+         * of the contained {@link StructuralName}s.\n+         *\n+         * @return The sampled {@link StructuralName}.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         * @throws RendererException If the set was empty.\n+         *\/\n+        public StructuralName sample() {\n+            StructuralName n = (StructuralName)Renderer.getCurrent().sampleName(predicate());\n+            if (n == null) {\n+                String msg1 = (subtype == null) ? \"\" : \" subtypeOf(\" + subtype + \")\";\n+                String msg2 = (supertype == null) ? \"\" : \" supertypeOf(\" + supertype + \")\";\n+                throw new RendererException(\"No variable:\" + msg1 + msg2 + \".\");\n+            }\n+            return n;\n+        }\n+\n+        \/**\n+         * Counts the number of {@link StructuralName}s in the filtered set.\n+         *\n+         * @return The number of {@link StructuralName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public int count() {\n+            return Renderer.getCurrent().countNames(predicate());\n+        }\n+\n+        \/**\n+         * Checks if there are any {@link StructuralName}s in the filtered set.\n+         *\n+         * @return Returns {@code true} iff there is at least one {@link StructuralName} in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public boolean hasAny() {\n+            return Renderer.getCurrent().hasAnyNames(predicate());\n+        }\n+\n+        \/**\n+         * Collects all {@link StructuralName}s in the filtered set.\n+         *\n+         * @return A {@link List} of all {@link StructuralName}s in the filtered set.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public List<StructuralName> toList() {\n+            List<Name> list = Renderer.getCurrent().listNames(predicate());\n+            return list.stream().map(n -> (StructuralName)n).toList();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/StructuralName.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,844 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import java.util.List;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/**\n+ * The Template Framework allows the generation of code with Templates. The goal is that these Templates are\n+ * easy to write, and allow regression tests to cover a larger scope, and to make template based fuzzing easy\n+ * to extend.\n+ *\n+ * <p>\n+ * <strong>Motivation:<\/strong> We want to make it easy to generate variants of tests. Often, we would like to\n+ * have a set of tests, corresponding to a set of types, a set of operators, a set of constants, etc. Writing all\n+ * the tests by hand is cumbersome or even impossible. When generating such tests with scripts, it would be\n+ * preferable if the code generation happens automatically, and the generator script was checked into the code\n+ * base. Code generation can go beyond simple regression tests, and one might want to generate random code from\n+ * a list of possible templates, to fuzz individual Java features and compiler optimizations.\n+ *\n+ * <p>\n+ * The Template Framework provides a facility to generate code with Templates. A Template is essentially a list\n+ * of tokens that are concatenated (i.e. rendered) to a {@link String}. The Templates can have \"holes\", which are\n+ * filled (replaced) by different values at each Template instantiation. For example, these \"holes\" can\n+ * be filled with different types, operators or constants. Templates can also be nested, allowing a modular\n+ * use of Templates.\n+ *\n+ * <p>\n+ * Once we rendered the source code to a {@link String}, we can compile it with the {@link CompileFramework}.\n+ *\n+ * <p>\n+ * <strong>Example:<\/strong>\n+ * The following snippets are from the example test {@code TestAdvanced.java}.\n+ * First, we define a template that generates a {@code @Test} method for a given type, operator and\n+ * constant generator. We define two constants {@code con1} and {@code con2}, and then use a multiline\n+ * string with hashtags {@code #} (i.e. \"holes\")  that are then replaced by the template arguments and the\n+ * {@link #let} definitions.\n+ *\n+ * <p>\n+ * {@snippet lang=java :\n+ * var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+ *     let(\"con1\", generator.next()),\n+ *     let(\"con2\", generator.next()),\n+ *     \"\"\"\n+ *     \/\/ #typeName #operator #con1 #con2\n+ *     public static #typeName $GOLD = $test();\n+ *\n+ *     @Test\n+ *     public static #typeName $test() {\n+ *         return (#typeName)(#con1 #operator #con2);\n+ *     }\n+ *\n+ *     @Check(test = \"$test\")\n+ *     public static void $check(#typeName result) {\n+ *         Verify.checkEQ(result, $GOLD);\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * <p>\n+ * To get an executable test, we define a {@link Template} that produces a class body with a main method. The Template\n+ * takes a list of types, and calls the {@code testTemplate} defined above for each type and operator. We use\n+ * the {@link TestFramework} to call our {@code @Test} methods.\n+ *\n+ * <p>\n+ * {@snippet lang=java :\n+ * var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+ *     let(\"classpath\", comp.getEscapedClassPathOfCompiledClasses()),\n+ *     \"\"\"\n+ *     package p.xyz;\n+ *\n+ *     import compiler.lib.ir_framework.*;\n+ *     import compiler.lib.verify.*;\n+ *\n+ *     public class InnerTest {\n+ *         public static void main() {\n+ *             \/\/ Set the classpath, so that the TestFramework test VM knows where\n+ *             \/\/ the CompileFramework put the class files of the compiled source code.\n+ *             TestFramework framework = new TestFramework(InnerTest.class);\n+ *             framework.addFlags(\"-classpath\", \"#classpath\");\n+ *             framework.start();\n+ *         }\n+ *\n+ *     \"\"\",\n+ *     \/\/ Call the testTemplate for each type and operator, generating a\n+ *     \/\/ list of lists of TemplateToken:\n+ *     types.stream().map((Type type) ->\n+ *         type.operators().stream().map((String operator) ->\n+ *             testTemplate.asToken(type.name(), operator, type.generator())).toList()\n+ *     ).toList(),\n+ *     \"\"\"\n+ *     }\n+ *     \"\"\"\n+ * ));\n+ * }\n+ *\n+ * <p>\n+ * Finally, we generate the list of types, and pass it to the class template:\n+ *\n+ * <p>\n+ * {@snippet lang=java :\n+ * List<Type> types = List.of(\n+ *     new Type(\"byte\",   GEN_BYTE::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"char\",   GEN_CHAR::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"short\",  GEN_SHORT::next,  List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"int\",    GEN_INT::next,    List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"long\",   GEN_LONG::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+ *     new Type(\"float\",  GEN_FLOAT::next,  List.of(\"+\", \"-\", \"*\", \"\/\")),\n+ *     new Type(\"double\", GEN_DOUBLE::next, List.of(\"+\", \"-\", \"*\", \"\/\"))\n+ * );\n+ *\n+ * \/\/ Use the template with one argument, and render it to a String.\n+ * return classTemplate.render(types);\n+ * }\n+ *\n+ * <p>\n+ * <strong>Details:<\/strong>\n+ * <p>\n+ * A {@link Template} can have zero or more arguments. A template can be created with {@code make} methods like\n+ * {@link Template#make(String, Function)}. For each number of arguments there is an implementation\n+ * (e.g. {@link Template.TwoArgs} for two arguments). This allows the use of generics for the\n+ * {@link Template} argument types which enables type checking of the {@link Template} arguments.\n+ *  It is currently only allowed to use up to three arguments.\n+ *\n+ * <p>\n+ * A {@link Template} can be rendered to a {@link String} (e.g. {@link Template.ZeroArgs#render()}).\n+ * Alternatively, we can generate a {@link Token} (more specifically, a {@link TemplateToken}) with {@code asToken()}\n+ * (e.g. {@link Template.ZeroArgs#asToken()}), and use the {@link Token} inside another {@link Template#body}.\n+ *\n+ * <p>\n+ * Ideally, we would have used <a href=\"https:\/\/openjdk.org\/jeps\/430\">string templates<\/a> to inject these Template\n+ * arguments into the strings. But since string templates are not (yet) available, the Templates provide\n+ * <strong>hashtag replacements<\/strong> in the {@link String}s: the Template argument names are captured, and\n+ * the argument values automatically replace any {@code \"#name\"} in the {@link String}s. See the different overloads\n+ * of {@link #make} for examples. Additional hashtag replacements can be defined with {@link #let}.\n+ *\n+ * <p>\n+ * When using nested Templates, there can be collisions with identifiers (e.g. variable names and method names).\n+ * For this, Templates provide <strong>dollar replacements<\/strong>, which automatically rename any\n+ * {@code \"$name\"} in the {@link String} with a {@code \"name_ID\"}, where the {@code \"ID\"} is unique for every use of\n+ * a Template. The dollar replacement can also be captured with {@link #$}, and passed to nested\n+ * Templates, which allows sharing of these identifier names between Templates.\n+ *\n+ * <p>\n+ * The dollar and hashtag names must have at least one character. The first character must be a letter\n+ * or underscore (i.e. {@code a-zA-Z_}), the other characters can also be digits (i.e. {@code a-zA-Z0-9_}).\n+ * One can use them with or without curly braces, e.g. {@code #name}, {@code #{name}}, {@code $name}, or\n+ * {@code #{name}}.\n+ *\n+ * <p>\n+ * A {@link TemplateToken} cannot just be used in {@link Template#body}, but it can also be\n+ * {@link Hook#insert}ed to where a {@link Hook} was {@link Hook#anchor}ed earlier (in some outer scope of the code).\n+ * For example, while generating code in a method, one can reach out to the scope of the class, and insert a\n+ * new field, or define a utility method.\n+ *\n+ * <p>\n+ * A {@link TemplateBinding} allows the recursive use of Templates. With the indirection of such a binding,\n+ * a Template can reference itself.\n+ *\n+ * <p>\n+ * The writer of recursive {@link Template}s must ensure that this recursion terminates. To unify the\n+ * approach across {@link Template}s, we introduce the concept of {@link #fuel}. Templates are rendered starting\n+ * with a limited amount of {@link #fuel} (default: 100, see {@link #DEFAULT_FUEL}), which is decreased at each\n+ * Template nesting by a certain amount (default: 10, see {@link #DEFAULT_FUEL_COST}). The default fuel for a\n+ * template can be changed when we {@code render()} it (e.g. {@link ZeroArgs#render(float)}) and the default\n+ * fuel cost with {@link #setFuelCost}) when defining the {@link #body(Object...)}. Recursive templates are\n+ * supposed to terminate once the {@link #fuel} is depleted (i.e. reaches zero).\n+ *\n+ * <p>\n+ * Code generation can involve keeping track of fields and variables, as well as the scopes in which they\n+ * are available, and if they are mutable or immutable. We model fields and variables with {@link DataName}s,\n+ * which we can add to the current scope with {@link #addDataName}. We can access the {@link DataName}s with\n+ * {@link #dataNames}. We can filter for {@link DataName}s of specific {@link DataName.Type}s, and then\n+ * we can call {@link DataName.FilteredSet#count}, {@link DataName.FilteredSet#sample},\n+ * {@link DataName.FilteredSet#toList}, etc. There are many use-cases for this mechanism, especially\n+ * facilitating communication between the code of outer and inner {@link Template}s. Especially for fuzzing,\n+ * it may be useful to be able to add fields and variables, and sample them randomly, to create a random data\n+ * flow graph.\n+ *\n+ * <p>\n+ * Similarly, we may want to model method and class names, and possibly other structural names. We model\n+ * these names with {@link StructuralName}, which works analogously to {@link DataName}, except that they\n+ * are not concerned about mutability.\n+ *\n+ * <p>\n+ * When working with {@link DataName}s and {@link StructuralName}s, it is important to be aware of the\n+ * relevant scopes, as well as the execution order of the {@link Template} lambdas and the evaluation\n+ * of the {@link Template#body} tokens. When a {@link Template} is rendered, its lambda is invoked. In the\n+ * lambda, we generate the tokens, and create the {@link Template#body}. Once the lambda returns, the\n+ * tokens are evaluated one by one. While evaluating the tokens, the {@link Renderer} might encounter a nested\n+ * {@link TemplateToken}, which in turn triggers the evaluation of that nested {@link Template}, i.e.\n+ * the evaluation of its lambda and later the evaluation of its tokens. It is important to keep in mind\n+ * that the lambda is always executed first, and the tokens are evaluated afterwards. A method like\n+ * {@code dataNames(MUTABLE).exactOf(type).count()} is a method that is executed during the evaluation\n+ * of the lambda. But a method like {@link #addDataName} returns a token, and does not immediately add\n+ * the {@link DataName}. This ensures that the {@link DataName} is only inserted when the tokens are\n+ * evaluated, so that it is inserted at the exact scope where we would expect it.\n+ *\n+ * <p>\n+ * Let us look at the following example to better understand the execution order.\n+ *\n+ * <p>\n+ * {@snippet lang=java :\n+ * var testTemplate = Template.make(() -> body(\n+ *     \/\/ The lambda has just been invoked.\n+ *     \/\/ We count the DataNames and assign the count to the hashtag replacement \"c1\".\n+ *     let(\"c1\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *     \/\/ We want to define a DataName \"v1\", and create a token for it.\n+ *     addDataName($(\"v1\"), someType, MUTABLE),\n+ *     \/\/ We count the DataNames again, but the count does NOT change compared to \"c1\".\n+ *     \/\/ This is because the token for \"v1\" is only evaluated later.\n+ *     let(\"c2\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *     \/\/ Create a nested scope.\n+ *     METHOD_HOOK.anchor(\n+ *         \/\/ We want to define a DataName \"v2\", which is only valid inside this\n+ *         \/\/ nested scope.\n+ *         addDataName($(\"v2\"), someType, MUTABLE),\n+ *         \/\/ The count is still not different to \"c1\".\n+ *         let(\"c3\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *         \/\/ We nest a Template. This creates a TemplateToken, which is later evaluated.\n+ *         \/\/ By the time the TemplateToken is evaluated, the tokens from above will\n+ *         \/\/ be already evaluated. Hence, \"v1\" and \"v2\" are added by then, and if the\n+ *         \/\/ \"otherTemplate\" were to count the DataNames, the count would be increased\n+ *         \/\/ by 2 compared to \"c1\".\n+ *         otherTemplate.asToken()\n+ *     ),\n+ *     \/\/ After closing the scope, \"v2\" is no longer available.\n+ *     \/\/ The count is still the same as \"c1\", since \"v1\" is still only a token.\n+ *     let(\"c4\", dataNames(MUTABLE).exactOf(someType).count()),\n+ *     \/\/ We nest another Template. Again, this creates a TemplateToken, which is only\n+ *     \/\/ evaluated later. By that time, the token for \"v1\" is evaluated, and so the\n+ *     \/\/ nested Template would observe an increment in the count.\n+ *     anotherTemplate.asToken()\n+ *     \/\/ By this point, all methods are called, and the tokens generated.\n+ *     \/\/ The lambda returns the \"body\", which is all of the tokens that we just\n+ *     \/\/ generated. After returning from the lambda, the tokens will be evaluated\n+ *     \/\/ one by one.\n+ * ));\n+ * }\n+\n+ * <p>\n+ * More examples for these functionalities can be found in {@code TestTutorial.java}, {@code TestSimple.java},\n+ * and {@code TestAdvanced.java}, which all produce compilable Java code. Additional examples can be found in\n+ * the tests, such as {@code TestTemplate.java} and {@code TestFormat.java}, which do not necessarily generate\n+ * valid Java code, but generate deterministic Strings which are easier to verify, and may also serve as a\n+ * reference when learning about these functionalities.\n+ *\/\n+public sealed interface Template permits Template.ZeroArgs,\n+                                         Template.OneArg,\n+                                         Template.TwoArgs,\n+                                         Template.ThreeArgs {\n+\n+    \/**\n+     * A {@link Template} with no arguments.\n+     *\n+     * @param function The {@link Supplier} that creates the {@link TemplateBody}.\n+     *\/\n+    record ZeroArgs(Supplier<TemplateBody> function) implements Template {\n+        TemplateBody instantiate() {\n+            return function.get();\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateToken} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation.\n+         *\n+         * @return The {@link TemplateToken} to use the {@link Template} inside another\n+         *         {@link Template}.\n+         *\/\n+        public TemplateToken asToken() {\n+            return new TemplateToken.ZeroArgs(this);\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render() {\n+            return new TemplateToken.ZeroArgs(this).render();\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @param fuel The amount of fuel provided for recursive Template instantiations.\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render(float fuel) {\n+            return new TemplateToken.ZeroArgs(this).render(fuel);\n+        }\n+    }\n+\n+    \/**\n+     * A {@link Template} with one argument.\n+     *\n+     * @param arg1Name The name of the (first) argument, used for hashtag replacements in the {@link Template}.\n+     * @param <T1> The type of the (first) argument.\n+     * @param function The {@link Function} that creates the {@link TemplateBody} given the template argument.\n+     *\/\n+    record OneArg<T1>(String arg1Name, Function<T1, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(T1 arg1) {\n+            return function.apply(arg1);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateToken} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation.\n+         *\n+         * @param arg1 The value for the (first) argument.\n+         * @return The {@link TemplateToken} to use the {@link Template} inside another\n+         *         {@link Template}.\n+         *\/\n+        public TemplateToken asToken(T1 arg1) {\n+            return new TemplateToken.OneArg<>(this, arg1);\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render(T1 arg1) {\n+            return new TemplateToken.OneArg<>(this, arg1).render();\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @param fuel The amount of fuel provided for recursive Template instantiations.\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render(float fuel, T1 arg1) {\n+            return new TemplateToken.OneArg<>(this, arg1).render(fuel);\n+        }\n+    }\n+\n+    \/**\n+     * A {@link Template} with two arguments.\n+     *\n+     * @param arg1Name The name of the first argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg2Name The name of the second argument, used for hashtag replacements in the {@link Template}.\n+     * @param <T1> The type of the first argument.\n+     * @param <T2> The type of the second argument.\n+     * @param function The {@link BiFunction} that creates the {@link TemplateBody} given the template arguments.\n+     *\/\n+    record TwoArgs<T1, T2>(String arg1Name, String arg2Name, BiFunction<T1, T2, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(T1 arg1, T2 arg2) {\n+            return function.apply(arg1, arg2);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateToken} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @param arg2 The value for the second argument.\n+         * @return The {@link TemplateToken} to use the {@link Template} inside another\n+         *         {@link Template}.\n+         *\/\n+        public TemplateToken asToken(T1 arg1, T2 arg2) {\n+            return new TemplateToken.TwoArgs<>(this, arg1, arg2);\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @param arg2 The value for the second argument.\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render(T1 arg1, T2 arg2) {\n+            return new TemplateToken.TwoArgs<>(this, arg1, arg2).render();\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @param arg2 The value for the second argument.\n+         * @param fuel The amount of fuel provided for recursive Template instantiations.\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render(float fuel, T1 arg1, T2 arg2) {\n+            return new TemplateToken.TwoArgs<>(this, arg1, arg2).render(fuel);\n+        }\n+    }\n+\n+    \/**\n+     * Interface for function with three arguments.\n+     *\n+     * @param <T> Type of the first argument.\n+     * @param <U> Type of the second argument.\n+     * @param <V> Type of the third argument.\n+     * @param <R> Type of the return value.\n+     *\/\n+    @FunctionalInterface\n+    interface TriFunction<T, U, V, R> {\n+\n+        \/**\n+         * Function definition for the three argument functions.\n+         *\n+         * @param t The first argument.\n+         * @param u The second argument.\n+         * @param v The third argument.\n+         * @return Return value of the three argument function.\n+         *\/\n+        R apply(T t, U u, V v);\n+    }\n+\n+    \/**\n+     * A {@link Template} with three arguments.\n+     *\n+     * @param arg1Name The name of the first argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg2Name The name of the second argument, used for hashtag replacements in the {@link Template}.\n+     * @param arg3Name The name of the third argument, used for hashtag replacements in the {@link Template}.\n+     * @param <T1> The type of the first argument.\n+     * @param <T2> The type of the second argument.\n+     * @param <T3> The type of the third argument.\n+     * @param function The function with three arguments that creates the {@link TemplateBody} given the template arguments.\n+     *\/\n+    record ThreeArgs<T1, T2, T3>(String arg1Name, String arg2Name, String arg3Name, TriFunction<T1, T2, T3, TemplateBody> function) implements Template {\n+        TemplateBody instantiate(T1 arg1, T2 arg2, T3 arg3) {\n+            return function.apply(arg1, arg2, arg3);\n+        }\n+\n+        \/**\n+         * Creates a {@link TemplateToken} which can be used as a {@link Token} inside\n+         * a {@link Template} for nested code generation.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @param arg2 The value for the second argument.\n+         * @param arg3 The value for the third argument.\n+         * @return The {@link TemplateToken} to use the {@link Template} inside another\n+         *         {@link Template}.\n+         *\/\n+        public TemplateToken asToken(T1 arg1, T2 arg2, T3 arg3) {\n+            return new TemplateToken.ThreeArgs<>(this, arg1, arg2, arg3);\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @param arg2 The value for the second argument.\n+         * @param arg3 The value for the third argument.\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render(T1 arg1, T2 arg2, T3 arg3) {\n+            return new TemplateToken.ThreeArgs<>(this, arg1, arg2, arg3).render();\n+        }\n+\n+        \/**\n+         * Renders the {@link Template} to a {@link String}.\n+         *\n+         * @param arg1 The value for the first argument.\n+         * @param arg2 The value for the second argument.\n+         * @param arg3 The value for the third argument.\n+         * @param fuel The amount of fuel provided for recursive Template instantiations.\n+         * @return The {@link String}, resulting from rendering the {@link Template}.\n+         *\/\n+        public String render(float fuel, T1 arg1, T2 arg2, T3 arg3) {\n+            return new TemplateToken.ThreeArgs<>(this, arg1, arg2, arg3).render(fuel);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with no arguments.\n+     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     *\n+     * <p>\n+     * Example:\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     \"\"\"\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @return A {@link Template} with zero arguments.\n+     *\/\n+    static Template.ZeroArgs make(Supplier<TemplateBody> body) {\n+        return new Template.ZeroArgs(body);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with one argument.\n+     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * Good practice but not enforced but not enforced: {@code arg1Name} should match the lambda argument name.\n+     *\n+     * <p>\n+     * Here is an example with template argument {@code 'a'}, captured once as string name\n+     * for use in hashtag replacements, and captured once as lambda argument with the corresponding type\n+     * of the generic argument.\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     We can use the hashtag replacement #a to directly insert the String value of a.\n+     *     \"\"\",\n+     *     \"We can also use the captured parameter of a: \" + a\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <T1> Type of the (first) argument.\n+     * @param arg1Name The name of the (first) argument for hashtag replacement.\n+     * @return A {@link Template} with one argument.\n+     *\/\n+    static <T1> Template.OneArg<T1> make(String arg1Name, Function<T1, TemplateBody> body) {\n+        return new Template.OneArg<>(arg1Name, body);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with two arguments.\n+     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * Good practice but not enforced: {@code arg1Name} and {@code arg2Name} should match the lambda argument names.\n+     *\n+     * <p>\n+     * Here is an example with template arguments {@code 'a'} and {@code 'b'}, captured once as string names\n+     * for use in hashtag replacements, and captured once as lambda arguments with the corresponding types\n+     * of the generic arguments.\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", \"b\", (Integer a, String b) -> body(\n+     *     \"\"\"\n+     *     Multi-line string or other tokens.\n+     *     We can use the hashtag replacement #a and #b to directly insert the String value of a and b.\n+     *     \"\"\",\n+     *     \"We can also use the captured parameter of a and b: \" + a + \" and \" + b\n+     * ));\n+     * }\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <T1> Type of the first argument.\n+     * @param arg1Name The name of the first argument for hashtag replacement.\n+     * @param <T2> Type of the second argument.\n+     * @param arg2Name The name of the second argument for hashtag replacement.\n+     * @return A {@link Template} with two arguments.\n+     *\/\n+    static <T1, T2> Template.TwoArgs<T1, T2> make(String arg1Name, String arg2Name, BiFunction<T1, T2, TemplateBody> body) {\n+        return new Template.TwoArgs<>(arg1Name, arg2Name, body);\n+    }\n+\n+    \/**\n+     * Creates a {@link Template} with three arguments.\n+     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * Good practice but not enforced: {@code arg1Name}, {@code arg2Name}, and {@code arg3Name} should match the lambda argument names.\n+     *\n+     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param <T1> Type of the first argument.\n+     * @param arg1Name The name of the first argument for hashtag replacement.\n+     * @param <T2> Type of the second argument.\n+     * @param arg2Name The name of the second argument for hashtag replacement.\n+     * @param <T3> Type of the third argument.\n+     * @param arg3Name The name of the third argument for hashtag replacement.\n+     * @return A {@link Template} with three arguments.\n+     *\/\n+    static <T1, T2, T3> Template.ThreeArgs<T1, T2, T3> make(String arg1Name, String arg2Name, String arg3Name, Template.TriFunction<T1, T2, T3, TemplateBody> body) {\n+        return new Template.ThreeArgs<>(arg1Name, arg2Name, arg3Name, body);\n+    }\n+\n+    \/**\n+     * Creates a {@link TemplateBody} from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}), any {@link Token},\n+     * or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     Multi-line string\n+     *     \"\"\",\n+     *     \"normal string \", Integer.valueOf(3), 3, Float.valueOf(1.5f), 1.5f,\n+     *     List.of(\"abc\", \"def\"),\n+     *     nestedTemplate.asToken(42)\n+     * ));\n+     * }\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link TemplateBody} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static TemplateBody body(Object... tokens) {\n+        return new TemplateBody(TokenParser.parse(tokens));\n+    }\n+\n+    \/**\n+     * Retrieves the dollar replacement of the {@code 'name'} for the\n+     * current Template that is being instantiated. It returns the same\n+     * dollar replacement as the string use {@code \"$name\"}.\n+     *\n+     * <p>\n+     * Here is an example where a Template creates a local variable {@code 'var'},\n+     * with an implicit dollar replacement, and then captures that dollar replacement\n+     * using {@link #$} for the use inside a nested template.\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> body(\n+     *     \"\"\"\n+     *     int $var = 42;\n+     *     \"\"\",\n+     *     otherTemplate.asToken($(\"var\"))\n+     * ));\n+     * }\n+     *\n+     * @param name The {@link String} name of the name.\n+     * @return The dollar replacement for the {@code 'name'}.\n+     *\/\n+    static String $(String name) {\n+        return Renderer.getCurrent().$(name);\n+    }\n+\n+    \/**\n+     * Define a hashtag replacement for {@code \"#key\"}, with a specific value.\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> body(\n+     *     let(\"b\", a * 5),\n+     *     \"\"\"\n+     *     System.out.println(\"Use a and b with hashtag replacement: #a and #b\");\n+     *     \"\"\"\n+     * ));\n+     * }\n+     *\n+     * @param key Name for the hashtag replacement.\n+     * @param value The value that the hashtag is replaced with.\n+     * @return A token that does nothing, so that the {@link #let} can easily be put in a list of tokens\n+     *         inside a {@link Template#body}.\n+     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     *\/\n+    static Token let(String key, Object value) {\n+        Renderer.getCurrent().addHashtagReplacement(key, value);\n+        return new NothingToken();\n+    }\n+\n+    \/**\n+     * Define a hashtag replacement for {@code \"#key\"}, with a specific value, which is also captured\n+     * by the provided {@code function} with type {@code <T>}.\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(\"a\", (Integer a) -> let(\"b\", a * 2, (Integer b) -> body(\n+     *     \"\"\"\n+     *     System.out.println(\"Use a and b with hashtag replacement: #a and #b\");\n+     *     \"\"\",\n+     *     \"System.out.println(\\\"Use a and b as capture variables:\\\"\" + a + \" and \" + b + \");\\n\"\n+     * )));\n+     * }\n+     *\n+     * @param key Name for the hashtag replacement.\n+     * @param value The value that the hashtag is replaced with.\n+     * @param <T> The type of the value.\n+     * @param function The function that is applied with the provided {@code value}.\n+     * @return A {@link TemplateBody}.\n+     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     *\/\n+    static <T> TemplateBody let(String key, T value, Function<T, TemplateBody> function) {\n+        Renderer.getCurrent().addHashtagReplacement(key, value);\n+        return function.apply(value);\n+    }\n+\n+    \/**\n+     * Default amount of fuel for Template rendering. It guides the nesting depth of Templates. Can be changed when\n+     * rendering a template with {@code render(fuel)} (e.g. {@link ZeroArgs#render(float)}).\n+     *\/\n+    float DEFAULT_FUEL = 100.0f;\n+\n+    \/**\n+     * The default amount of fuel spent per Template. It is subtracted from the current {@link #fuel} at every\n+     * nesting level, and once the {@link #fuel} reaches zero, the nesting is supposed to terminate. Can be changed\n+     * with {@link #setFuelCost(float)} inside {@link #body(Object...)}.\n+     *\/\n+    float DEFAULT_FUEL_COST = 10.0f;\n+\n+    \/**\n+     * The current remaining fuel for nested Templates. Every level of Template nesting\n+     * subtracts a certain amount of fuel, and when it reaches zero, Templates are supposed to\n+     * stop nesting, if possible. This is not a hard rule, but a guide, and a mechanism to ensure\n+     * termination in recursive Template instantiations.\n+     *\n+     * <p>\n+     * Example of a recursive Template, which checks the remaining {@link #fuel} at every level,\n+     * and terminates if it reaches zero. It also demonstrates the use of {@link TemplateBinding} for\n+     * the recursive use of Templates. We {@link Template.OneArg#render} with {@code 30} total fuel,\n+     * and spend {@code 5} fuel at each recursion level.\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var binding = new TemplateBinding<Template.OneArg<Integer>>();\n+     * var template = Template.make(\"depth\", (Integer depth) -> body(\n+     *     setFuelCost(5.0f),\n+     *     let(\"fuel\", fuel()),\n+     *     \"\"\"\n+     *     System.out.println(\"Currently at depth #depth with fuel #fuel\");\n+     *     \"\"\",\n+     *     (fuel() > 0) ? binding.get().asToken(depth + 1) :\n+     *                    \"\/\/ terminate\\n\"\n+     * ));\n+     * binding.bind(template);\n+     * String code = template.render(30.0f, 0);\n+     * }\n+     *\n+     * @return The amount of fuel left for nested Template use.\n+     *\/\n+    static float fuel() {\n+        return Renderer.getCurrent().fuel();\n+    }\n+\n+    \/**\n+     * Changes the amount of fuel used for the current Template, where the default is\n+     * {@link Template#DEFAULT_FUEL_COST}.\n+     *\n+     * @param fuelCost The amount of fuel used for the current Template.\n+     * @return A token for convenient use in {@link Template#body}.\n+     *\/\n+    static Token setFuelCost(float fuelCost) {\n+        Renderer.getCurrent().setFuelCost(fuelCost);\n+        return new NothingToken();\n+    }\n+\n+    \/**\n+     * Add a {@link DataName} in the current scope, that is the innermost of either\n+     * {@link Template#body} or {@link Hook#anchor}.\n+     *\n+     * @param name The name of the {@link DataName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link DataName}.\n+     * @param mutability Indicates if the {@link DataName} is to be mutable or immutable,\n+     *                   i.e. if we intend to use the {@link DataName} only for reading\n+     *                   or if we also allow it to be mutated.\n+     * @param weight The weight of the {@link DataName}, which correlates to the probability\n+     *               of this {@link DataName} being chosen when we sample.\n+     *               Must be a value from 1 to 1000.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addDataName(String name, DataName.Type type, DataName.Mutability mutability, int weight) {\n+        if (mutability != DataName.Mutability.MUTABLE &&\n+            mutability != DataName.Mutability.IMMUTABLE) {\n+            throw new IllegalArgumentException(\"Unexpected mutability: \" + mutability);\n+        }\n+        boolean mutable = mutability == DataName.Mutability.MUTABLE;\n+        if (weight <= 0 || 1000 < weight) {\n+            throw new IllegalArgumentException(\"Unexpected weight: \" + weight);\n+        }\n+        return new AddNameToken(new DataName(name, type, mutable, weight));\n+    }\n+\n+    \/**\n+     * Add a {@link DataName} in the current scope, that is the innermost of either\n+     * {@link Template#body} or {@link Hook#anchor}, with a {@code weight} of 1.\n+     *\n+     * @param name The name of the {@link DataName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link DataName}.\n+     * @param mutability Indicates if the {@link DataName} is to be mutable or immutable,\n+     *                   i.e. if we intend to use the {@link DataName} only for reading\n+     *                   or if we also allow it to be mutated.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addDataName(String name, DataName.Type type, DataName.Mutability mutability) {\n+        return addDataName(name, type, mutability, 1);\n+    }\n+\n+    \/**\n+     * Access the set of {@link DataName}s, for sampling, counting, etc.\n+     *\n+     * @param mutability Indicates if we only sample from mutable, immutable or either {@link DataName}s.\n+     * @return A view on the {@link DataName}s, on which we can sample, count, etc.\n+     *\/\n+    static DataName.FilteredSet dataNames(DataName.Mutability mutability) {\n+        return new DataName.FilteredSet(mutability);\n+    }\n+\n+    \/**\n+     * Add a {@link StructuralName} in the current scope, that is the innermost of either\n+     * {@link Template#body} or {@link Hook#anchor}.\n+     *\n+     * @param name The name of the {@link StructuralName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link StructuralName}.\n+     * @param weight The weight of the {@link StructuralName}, which correlates to the probability\n+     *               of this {@link StructuralName} being chosen when we sample.\n+     *               Must be a value from 1 to 1000.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addStructuralName(String name, StructuralName.Type type, int weight) {\n+        if (weight <= 0 || 1000 < weight) {\n+            throw new IllegalArgumentException(\"Unexpected weight: \" + weight);\n+        }\n+        return new AddNameToken(new StructuralName(name, type, weight));\n+    }\n+\n+    \/**\n+     * Add a {@link StructuralName} in the current scope, that is the innermost of either\n+     * {@link Template#body} or {@link Hook#anchor}, with a {@code weight} of 1.\n+     *\n+     * @param name The name of the {@link StructuralName}, i.e. the {@link String} used in code.\n+     * @param type The type of the {@link StructuralName}.\n+     * @return The token that performs the defining action.\n+     *\/\n+    static Token addStructuralName(String name, StructuralName.Type type) {\n+        return addStructuralName(name, type, 1);\n+    }\n+\n+    \/**\n+     * Access the set of {@link StructuralName}s, for sampling, counting, etc.\n+     *\n+     * @return A view on the {@link StructuralName}s, on which we can sample, count, etc.\n+     *\/\n+    static StructuralName.FilteredSet structuralNames() {\n+        return new StructuralName.FilteredSet();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":844,"deletions":0,"binary":false,"changes":844,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * To facilitate recursive uses of Templates, for example where a template uses\n+ * itself and needs to be referenced before it is fully defined,\n+ * one can use the indirection of a {@link TemplateBinding}. The {@link TemplateBinding}\n+ * is allocated first without any Template bound to it yet. At this stage,\n+ * it can be used with {@link #get} inside a Template. Later, we can {@link #bind}\n+ * a Template to the binding, such that {@link #get} returns that bound\n+ * Template.\n+ *\n+ * @param <T> Type of the template.\n+ *\/\n+public class TemplateBinding<T extends Template> {\n+    private T template = null;\n+\n+    \/**\n+     * Creates a new {@link TemplateBinding} that has no Template bound to it yet.\n+     *\/\n+    public TemplateBinding() {}\n+\n+    \/**\n+     * Retrieve the Template that was previously bound to the binding.\n+     *\n+     * @return The Template that was previously bound with {@link #bind}.\n+     * @throws RendererException if no Template was bound yet.\n+     *\/\n+    public T get() {\n+        if (template == null) {\n+            throw new RendererException(\"Cannot 'get' before 'bind'.\");\n+        }\n+        return template;\n+    }\n+\n+    \/**\n+     * Binds a Template for future reference using {@link #get}.\n+     *\n+     * @param template The Template to be bound.\n+     * @throws RendererException if a Template was already bound.\n+     *\/\n+    public void bind(T template) {\n+         if (this.template != null) {\n+            throw new RendererException(\"Duplicate 'bind' not allowed.\");\n+        }\n+        this.template = template;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBinding.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * A Template generates a {@link TemplateBody}, which is a list of {@link Token}s,\n+ * which are then later rendered to {@link String}s.\n+ *\n+ * @param tokens The list of {@link Token}s that are later rendered to {@link String}s.\n+ *\/\n+public record TemplateBody(List<Token> tokens) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBody.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * The {@link TemplateFrame} is the frame for a {@link Template}, i.e. the corresponding\n+ * {@link TemplateToken}. It ensures that each template use has its own unique {@link #id}\n+ * used to deconflict names using {@link Template#$}. It also has a set of hashtag\n+ * replacements, which combine the key-value pairs from the template argument and the\n+ * {@link Template#let} definitions. The {@link #parent} relationship provides a trace\n+ * for the use chain of templates. The {@link #fuel} is reduced over this chain, to give\n+ * a heuristic on how much time is spent on the code from the template corresponding to\n+ * the frame, and to give a termination criterion to avoid nesting templates too deeply.\n+ *\n+ * <p>\n+ * See also {@link CodeFrame} for more explanations about the frames.\n+ *\/\n+class TemplateFrame {\n+    final TemplateFrame parent;\n+    private final int id;\n+    private final Map<String, String> hashtagReplacements = new HashMap<>();\n+    final float fuel;\n+    private float fuelCost;\n+\n+    public static TemplateFrame makeBase(int id, float fuel) {\n+        return new TemplateFrame(null, id, fuel, 0.0f);\n+    }\n+\n+    public static TemplateFrame make(TemplateFrame parent, int id) {\n+        return new TemplateFrame(parent, id, parent.fuel - parent.fuelCost, Template.DEFAULT_FUEL_COST);\n+    }\n+\n+    private TemplateFrame(TemplateFrame parent, int id, float fuel, float fuelCost) {\n+        this.parent = parent;\n+        this.id = id;\n+        this.fuel = fuel;\n+        this.fuelCost = fuelCost;\n+    }\n+\n+    public String $(String name) {\n+        if (name == null) {\n+            throw new RendererException(\"A '$' name should not be null.\");\n+        }\n+        if (!Renderer.isValidHashtagOrDollarName(name)) {\n+            throw new RendererException(\"Is not a valid '$' name: '\" + name + \"'.\");\n+        }\n+        return name + \"_\" + id;\n+    }\n+\n+    void addHashtagReplacement(String key, String value) {\n+        if (key == null) {\n+            throw new RendererException(\"A hashtag replacement should not be null.\");\n+        }\n+        if (!Renderer.isValidHashtagOrDollarName(key)) {\n+            throw new RendererException(\"Is not a valid hashtag replacement name: '\" + key + \"'.\");\n+        }\n+        if (hashtagReplacements.putIfAbsent(key, value) != null) {\n+            throw new RendererException(\"Duplicate hashtag replacement for #\" + key);\n+        }\n+    }\n+\n+    String getHashtagReplacement(String key) {\n+        if (!Renderer.isValidHashtagOrDollarName(key)) {\n+            throw new RendererException(\"Is not a valid hashtag replacement name: '\" + key + \"'.\");\n+        }\n+        if (hashtagReplacements.containsKey(key)) {\n+            return hashtagReplacements.get(key);\n+        }\n+        throw new RendererException(\"Missing hashtag replacement for #\" + key);\n+    }\n+\n+    void setFuelCost(float fuelCost) {\n+        this.fuelCost = fuelCost;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateFrame.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * Represents a tokenized {@link Template} (after calling {@code asToken()}) ready for\n+ * instantiation either as a {@link Token} inside another {@link Template} or as\n+ * a {@link String} with {@link #render}.\n+ *\/\n+public sealed abstract class TemplateToken implements Token\n+                                           permits TemplateToken.ZeroArgs,\n+                                                   TemplateToken.OneArg,\n+                                                   TemplateToken.TwoArgs,\n+                                                   TemplateToken.ThreeArgs\n+{\n+    private TemplateToken() {}\n+\n+    \/**\n+     * Represents a tokenized zero-argument {@link Template} ready for instantiation\n+     * either as a {@link Token} inside another {@link Template} or as a {@link String}\n+     * with {@link #render}.\n+     *\/\n+    static final class ZeroArgs extends TemplateToken implements Token {\n+        private final Template.ZeroArgs zeroArgs;\n+\n+        ZeroArgs(Template.ZeroArgs zeroArgs) {\n+            this.zeroArgs = zeroArgs;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return zeroArgs.instantiate();\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {}\n+    }\n+\n+    \/**\n+     * Represents a tokenized one-argument {@link Template}, already filled with arguments, ready for\n+     * instantiation either as a {@link Token} inside another {@link Template} or as a {@link String}\n+     * with {@link #render}.\n+     *\n+     * @param <T1> The type of the (first) argument.\n+     *\/\n+    static final class OneArg<T1> extends TemplateToken implements Token {\n+        private final Template.OneArg<T1> oneArgs;\n+        private final T1 arg1;\n+\n+        OneArg(Template.OneArg<T1> oneArgs, T1 arg1) {\n+            this.oneArgs = oneArgs;\n+            this.arg1 = arg1;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return oneArgs.instantiate(arg1);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(oneArgs.arg1Name(), arg1);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a tokenized two-argument {@link Template}, already filled with arguments, ready for\n+     * instantiation either as a {@link Token} inside another {@link Template} or as a {@link String}\n+     * with {@link #render}.\n+     *\n+     * @param <T1> The type of the first argument.\n+     * @param <T2> The type of the second argument.\n+     *\/\n+    static final class TwoArgs<T1, T2> extends TemplateToken implements Token {\n+        private final Template.TwoArgs<T1, T2> twoArgs;\n+        private final T1 arg1;\n+        private final T2 arg2;\n+\n+        TwoArgs(Template.TwoArgs<T1, T2> twoArgs, T1 arg1, T2 arg2) {\n+            this.twoArgs = twoArgs;\n+            this.arg1 = arg1;\n+            this.arg2 = arg2;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return twoArgs.instantiate(arg1, arg2);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(twoArgs.arg1Name(), arg1);\n+            visitor.visit(twoArgs.arg2Name(), arg2);\n+        }\n+    }\n+\n+    \/**\n+     * Represents a tokenized three-argument {@link TemplateToken}, already filled with arguments, ready for\n+     * instantiation either as a {@link Token} inside another {@link Template} or as a {@link String}\n+     * with {@link #render}.\n+     *\n+     * @param <T1> The type of the first argument.\n+     * @param <T2> The type of the second argument.\n+     * @param <T3> The type of the second argument.\n+     *\/\n+    static final class ThreeArgs<T1, T2, T3> extends TemplateToken implements Token {\n+        private final Template.ThreeArgs<T1, T2, T3> threeArgs;\n+        private final T1 arg1;\n+        private final T2 arg2;\n+        private final T3 arg3;\n+\n+        ThreeArgs(Template.ThreeArgs<T1, T2, T3> threeArgs, T1 arg1, T2 arg2, T3 arg3) {\n+            this.threeArgs = threeArgs;\n+            this.arg1 = arg1;\n+            this.arg2 = arg2;\n+            this.arg3 = arg3;\n+        }\n+\n+        @Override\n+        public TemplateBody instantiate() {\n+            return threeArgs.instantiate(arg1, arg2, arg3);\n+        }\n+\n+        @Override\n+        public void visitArguments(ArgumentVisitor visitor) {\n+            visitor.visit(threeArgs.arg1Name(), arg1);\n+            visitor.visit(threeArgs.arg2Name(), arg2);\n+            visitor.visit(threeArgs.arg3Name(), arg3);\n+        }\n+    }\n+\n+    abstract TemplateBody instantiate();\n+\n+    @FunctionalInterface\n+    interface ArgumentVisitor {\n+        void visit(String name, Object value);\n+    }\n+\n+    abstract void visitArguments(ArgumentVisitor visitor);\n+\n+    final String render() {\n+        return Renderer.render(this);\n+    }\n+\n+    final String render(float fuel) {\n+        return Renderer.render(this, fuel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateToken.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives.\n+ *\/\n+public sealed interface Token permits StringToken,\n+                               TemplateToken,\n+                               TemplateToken.ZeroArgs,\n+                               TemplateToken.OneArg,\n+                               TemplateToken.TwoArgs,\n+                               TemplateToken.ThreeArgs,\n+                               HookAnchorToken,\n+                               HookInsertToken,\n+                               AddNameToken,\n+                               NothingToken {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Token.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Helper class for {@link Token}, to keep the parsing methods package private.\n+ *\n+ * <p>\n+ * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * {@link Token}s or {@link String}s or some permitted boxed primitives. These are then parsed\n+ * and all non-{@link Token}s are converted to {@link StringToken}s. The parsing also flattens\n+ * {@link List}s.\n+ *\/\n+final class TokenParser {\n+    static List<Token> parse(Object[] objects) {\n+        if (objects == null) {\n+            throw new IllegalArgumentException(\"Unexpected tokens: null\");\n+        }\n+        List<Token> outputList = new ArrayList<>();\n+        parseToken(Arrays.asList(objects), outputList);\n+        return outputList;\n+    }\n+\n+    private static void parseList(List<?> inputList, List<Token> outputList) {\n+        for (Object o : inputList) {\n+            parseToken(o, outputList);\n+        }\n+    }\n+\n+    private static void parseToken(Object o, List<Token> outputList) {\n+        if (o == null) {\n+            throw new IllegalArgumentException(\"Unexpected token: null\");\n+        }\n+        switch (o) {\n+            case Token t   -> outputList.add(t);\n+            case String s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Integer s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Long s    -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Double s  -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Float s   -> outputList.add(new StringToken(Renderer.format(s)));\n+            case Boolean s -> outputList.add(new StringToken(Renderer.format(s)));\n+            case List<?> l -> parseList(l, outputList);\n+            default -> throw new IllegalArgumentException(\"Unexpected token: \" + o);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TokenParser.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.Template;\n+\n+\/**\n+ * The {@link CodeGenerationDataNameType} extends the {@link DataName.Type} with\n+ * additional functionality for code generation. These types with their extended\n+ * functionality can be used with many other code generation facilities in the\n+ * library, such as generating random {@code Expression}s.\n+ *\/\n+public interface CodeGenerationDataNameType extends DataName.Type {\n+\n+    \/**\n+     * This method provides a random constant value for the type, which can\n+     * be used as a token inside a {@link Template}.\n+     *\n+     * @return A random constant value.\n+     *\/\n+    Object con();\n+\n+    \/**\n+     * The byte {@link PrimitiveType}.\n+     *\n+     * @return The byte {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType bytes()    { return PrimitiveType.BYTES; }\n+\n+    \/**\n+     * The short {@link PrimitiveType}.\n+     *\n+     * @return The short {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType shorts()   { return PrimitiveType.SHORTS; }\n+\n+    \/**\n+     * The char {@link PrimitiveType}.\n+     *\n+     * @return The char {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType chars()    { return PrimitiveType.CHARS; }\n+\n+    \/**\n+     * The int {@link PrimitiveType}.\n+     *\n+     * @return The int {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType ints()     { return PrimitiveType.INTS; }\n+\n+    \/**\n+     * The long {@link PrimitiveType}.\n+     *\n+     * @return The long {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType longs()    { return PrimitiveType.LONGS; }\n+\n+    \/**\n+     * The float {@link PrimitiveType}.\n+     *\n+     * @return The float {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType floats()   { return PrimitiveType.FLOATS; }\n+\n+    \/**\n+     * The double {@link PrimitiveType}.\n+     *\n+     * @return The double {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType doubles()  { return PrimitiveType.DOUBLES; }\n+\n+    \/**\n+     * The boolean {@link PrimitiveType}.\n+     *\n+     * @return The boolean {@link PrimitiveType}.\n+     *\/\n+    static PrimitiveType booleans() { return PrimitiveType.BOOLEANS; }\n+\n+    \/**\n+     * List of all {@link PrimitiveType}s.\n+     *\/\n+    List<PrimitiveType> PRIMITIVE_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs(),\n+        floats(),\n+        doubles(),\n+        booleans()\n+    );\n+\n+    \/**\n+     * List of all integral {@link PrimitiveType}s (byte, char, short, int, long).\n+     *\/\n+    List<PrimitiveType> INTEGRAL_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs()\n+    );\n+\n+    \/**\n+     * List of all subword {@link PrimitiveType}s (byte, char, short).\n+     *\/\n+    List<PrimitiveType> SUBWORD_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts()\n+    );\n+\n+    \/**\n+     * List of all floating {@link PrimitiveType}s (float, double).\n+     *\/\n+    List<PrimitiveType> FLOATING_TYPES = List.of(\n+        floats(),\n+        doubles()\n+    );\n+\n+    \/**\n+     * List of all integral and floating {@link PrimitiveType}s.\n+     *\/\n+    List<PrimitiveType> INTEGRAL_AND_FLOATING_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs(),\n+        floats(),\n+        doubles()\n+    );\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/CodeGenerationDataNameType.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import compiler.lib.template_framework.Hook;\n+\n+\/**\n+ * Provides a hook for class and method scopes, to be used in Templates.\n+ *\/\n+public final class Hooks {\n+    private Hooks() {} \/\/ Avoid instantiation and need for documentation.\n+\n+    \/**\n+     * Template {@link Hook} used by the Template Library for class scopes, to insert\n+     * fields and methods.\n+     *\/\n+    public static final Hook CLASS_HOOK = new Hook(\"Class\");\n+\n+    \/**\n+     * Template {@link Hook} used by the Template Library for method scopes, to insert\n+     * local variables, and computations for local variables at the beginning of a\n+     * method.\n+     *\/\n+    public static final Hook METHOD_HOOK = new Hook(\"Method\");\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Hooks.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.RestrictableGenerator;\n+\n+import compiler.lib.template_framework.DataName;\n+\n+\/**\n+ * The {@link PrimitiveType} models Java's primitive types, and provides a set\n+ * of useful methods for code generation, such as the {@link #byteSize} and\n+ * {@link #boxedTypeName}.\n+ *\/\n+public final class PrimitiveType implements CodeGenerationDataNameType {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final RestrictableGenerator<Integer> GEN_BYTE = Generators.G.safeRestrict(Generators.G.ints(), Byte.MIN_VALUE, Byte.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    private static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    private static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+    private static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+\n+    private static enum Kind { BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE, BOOLEAN };\n+\n+    \/\/ We have one static instance each, so we do not have duplicated instances.\n+    static final PrimitiveType BYTES    = new PrimitiveType(Kind.BYTE   );\n+    static final PrimitiveType SHORTS   = new PrimitiveType(Kind.SHORT  );\n+    static final PrimitiveType CHARS    = new PrimitiveType(Kind.CHAR   );\n+    static final PrimitiveType INTS     = new PrimitiveType(Kind.INT    );\n+    static final PrimitiveType LONGS    = new PrimitiveType(Kind.LONG   );\n+    static final PrimitiveType FLOATS   = new PrimitiveType(Kind.FLOAT  );\n+    static final PrimitiveType DOUBLES  = new PrimitiveType(Kind.DOUBLE );\n+    static final PrimitiveType BOOLEANS = new PrimitiveType(Kind.BOOLEAN);\n+\n+    final Kind kind;\n+\n+    \/\/ Private constructor so nobody can create duplicate instances.\n+    private PrimitiveType(Kind kind) {\n+        this.kind = kind;\n+    }\n+\n+    @Override\n+    public boolean isSubtypeOf(DataName.Type other) {\n+        return (other instanceof PrimitiveType pt) && pt.kind == kind;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return switch (kind) {\n+            case BYTE    -> \"byte\";\n+            case SHORT   -> \"short\";\n+            case CHAR    -> \"char\";\n+            case INT     -> \"int\";\n+            case LONG    -> \"long\";\n+            case FLOAT   -> \"float\";\n+            case DOUBLE  -> \"double\";\n+            case BOOLEAN -> \"boolean\";\n+        };\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name();\n+    }\n+\n+    public Object con() {\n+        return switch (kind) {\n+            case BYTE    -> \"(byte)\" + GEN_BYTE.next();\n+            case SHORT   -> \"(short)\" + GEN_SHORT.next();\n+            case CHAR    -> \"(char)\" + GEN_CHAR.next();\n+            case INT     -> GEN_INT.next();\n+            case LONG    -> GEN_LONG.next();\n+            case FLOAT   -> GEN_FLOAT.next();\n+            case DOUBLE  -> GEN_DOUBLE.next();\n+            case BOOLEAN -> RANDOM.nextBoolean();\n+        };\n+    }\n+\n+    \/**\n+     * Provides the size of the type in bytes.\n+     *\n+     * @return Size of the type in bytes.\n+     * @throws UnsupportedOperationException for boolean which has no defined size.\n+     *\/\n+    public int byteSize() {\n+        return switch (kind) {\n+            case BYTE    -> 1;\n+            case SHORT, CHAR -> 2;\n+            case INT, FLOAT -> 4;\n+            case LONG, DOUBLE -> 8;\n+            case BOOLEAN -> { throw new UnsupportedOperationException(\"boolean does not have a defined 'size'\"); }\n+        };\n+    }\n+\n+    \/**\n+     * Provides the name of the boxed type.\n+     *\n+     * @return the name of the boxed type.\n+     *\/\n+    public String boxedTypeName() {\n+        return switch (kind) {\n+            case BYTE    -> \"Byte\";\n+            case SHORT   -> \"Short\";\n+            case CHAR    -> \"Character\";\n+            case INT     -> \"Integer\";\n+            case LONG    -> \"Long\";\n+            case FLOAT   -> \"Float\";\n+            case DOUBLE  -> \"Double\";\n+            case BOOLEAN -> \"Boolean\";\n+        };\n+    }\n+\n+    \/**\n+     * Indicates if the type is a floating point type.\n+     *\n+     * @return true iff the type is a floating point type.\n+     *\/\n+    public boolean isFloating() {\n+        return switch (kind) {\n+            case BYTE, SHORT, CHAR, INT, LONG, BOOLEAN -> false;\n+            case FLOAT, DOUBLE -> true;\n+        };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+\/**\n+ * This class provides a {@link #render} method that can be used to simplify generating\n+ * source code when using the {@link TestFramework} (also known as IR Framework) to run\n+ * a list of tests.\n+ *\n+ * <p>\n+ * The idea is that the user only has to generate the code for the individual tests,\n+ * and can then pass the corresponding list of {@link TemplateToken}s to this\n+ * provided {@link #render} method which generates the surrounding class and the main\n+ * method that invokes the {@link TestFramework}, so that all the generated tests\n+ * are run.\n+ *\/\n+public final class TestFrameworkClass {\n+\n+    \/\/ Ensure there can be no instance, and we do not have to document the constructor.\n+    private TestFrameworkClass() {}\n+\n+    \/**\n+     * This method renders a list of {@code testTemplateTokens} into the body of a class\n+     * and generates a {@code main} method which launches the {@link TestFramework}\n+     * to run the generated tests.\n+     *\n+     * <p>\n+     * The generated {@code main} method is to be invoked with a {@code vmFlags} argument,\n+     * which must be a {@link String[]}, specifying the VM flags for the Test VM, in which\n+     * the tests will be run. Thus, one can generate the test class once, and invoke its\n+     * {@code main} method multiple times, each time with a different set of VM flags.\n+     *\n+     * <p>\n+     * The internal {@link Template} sets the {@link Hooks#CLASS_HOOK} for the scope of\n+     * all test methods.\n+     *\n+     * @param packageName The package name of the test class.\n+     * @param className The name of the test class.\n+     * @param imports A set of imports.\n+     * @param classpath The classpath from {@link CompileFramework#getEscapedClassPathOfCompiledClasses},\n+     *                  so that the Test VM has access to the class files that are compiled from the\n+     *                  generated source code.\n+     * @param testTemplateTokens The list of tests to be generated into the test class.\n+     *                           Every test must be annotated with {@code @Test}, so that\n+     *                           the {@link TestFramework} can later find and run them.\n+     * @return The generated source code of the test class as a {@link String}.\n+     *\/\n+    public static String render(final String packageName,\n+                                final String className,\n+                                final Set<String> imports,\n+                                final String classpath,\n+                                final List<TemplateToken> testTemplateTokens) {\n+        var template = Template.make(() -> body(\n+            let(\"packageName\", packageName),\n+            let(\"className\", className),\n+            let(\"classpath\", classpath),\n+            \"\"\"\n+            package #packageName;\n+            \/\/ --- IMPORTS start ---\n+            import compiler.lib.ir_framework.*;\n+            \"\"\",\n+            imports.stream().map(i -> \"import \" + i + \";\\n\").toList(),\n+            \"\"\"\n+            \/\/ --- IMPORTS end   ---\n+            public class #className {\n+            \/\/ --- CLASS_HOOK insertions start ---\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+            \/\/ --- CLASS_HOOK insertions end   ---\n+                public static void main(String[] vmFlags) {\n+                    TestFramework framework = new TestFramework(#className.class);\n+                    framework.addFlags(\"-classpath\", \"#classpath\");\n+                    framework.addFlags(vmFlags);\n+                    framework.start();\n+                }\n+            \/\/ --- LIST OF TESTS start ---\n+            \"\"\",\n+            testTemplateTokens\n+            ),\n+            \"\"\"\n+            \/\/ --- LIST OF TESTS end   ---\n+            }\n+            \"\"\"\n+        ));\n+        return template.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/TestFrameworkClass.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.HashMap;\n+\n@@ -30,3 +35,12 @@\n- * The {@link Verify} class provides a single {@link Verify#checkEQ} static method, which recursively\n- * compares the two {@link Object}s by value. It deconstructs {@link Object[]}, compares boxed primitive\n- * types, and compares the content of arrays and {@link MemorySegment}s.\n+ * The {@link Verify} class provides {@link Verify#checkEQ} and {@link Verify#checkEQWithRawBits},\n+ * which recursively compare the two {@link Object}s by value. They deconstruct an array of objects,\n+ * compare boxed primitive types, compare the content of arrays and {@link MemorySegment}s, and check\n+ * that the messages of two {@link Exception}s are equal. They also check for the equivalent content\n+ * in {@code Vector}s from the Vector API.\n+ *\n+ * <p>\n+ * Further, they compare Objects from arbitrary classes, using reflection. We check the fields of the\n+ * Objects, and compare their recursive structure. Since we use reflection, this can be slow.\n+ *\n+ * <p>\n+ * When a comparison fails, then methods print helpful messages, before throwing a {@link VerifyException}.\n@@ -34,1 +48,7 @@\n- * When a comparison fail, then methods print helpful messages, before throwing a {@link VerifyException}.\n+ * <p>\n+ * We have to take special care of {@link Float}s and {@link Double}s, since they both have various\n+ * encodings for NaN values while the Java specification regards them as equal. Hence, we\n+ * have two modes of comparison. With {@link Verify#checkEQ} different NaN values are regarded as equal.\n+ * This applies to the boxed floating types, as well as arrays of floating arrays. With\n+ * {@link Verify#checkEQWithRawBits} we compare the raw bits, and so different NaN encodings are not equal.\n+ * Note: {@link MemorySegment} data is always compared with raw bits.\n@@ -37,0 +57,12 @@\n+    private final boolean isFloatCheckWithRawBits;\n+\n+    \/**\n+     * When comparing arbitrary classes recursively, we need to remember which\n+     * pairs of objects {@code (a, b)} we have already visited. The maps\n+     * {@code a2b} and {@code b2a} track these edges. Caching which pairs\n+     * we have already visited means the traversal only needs to visit every\n+     * pair once. And should we ever find a pair {@code (a, b')} or {@code (a', b)},\n+     * then we know that the two structures are not structurally equivalent.\n+     *\/\n+    private final HashMap<Object, Object> a2b = new HashMap<>();\n+    private final HashMap<Object, Object> b2a = new HashMap<>();\n@@ -38,1 +70,3 @@\n-    private Verify() {}\n+    private Verify(boolean isFloatCheckWithRawBits) {\n+        this.isFloatCheckWithRawBits = isFloatCheckWithRawBits;\n+    }\n@@ -41,1 +75,3 @@\n-     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     * Verify the contents of two Objects on a raw bit level, possibly recursively.\n+     * Different NaN encodings are considered non-equal, since we compare\n+     * floating numbers by their raw bits.\n@@ -47,2 +83,3 @@\n-    public static void checkEQ(Object a, Object b) {\n-        checkEQ(a, b, \"\");\n+    public static void checkEQWithRawBits(Object a, Object b) {\n+        Verify v = new Verify(true);\n+        v.checkEQdispatch(a, b, \"<root>\", null, null);\n@@ -52,1 +89,6 @@\n-     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     * Verify the contents of two Objects, possibly recursively.\n+     * Different NaN encodings are considered equal.\n+     *\n+     * @param a First object to be recursively compared with the second.\n+     * @param b Second object to be recursively compared with the first.\n+     * @throws VerifyException If the comparison fails.\n@@ -54,1 +96,6 @@\n-    private static void checkEQ(Object a, Object b, String context) {\n+    public static void checkEQ(Object a, Object b) {\n+        Verify v = new Verify(false);\n+        v.checkEQdispatch(a, b, \"<root>\", null, null);\n+    }\n+\n+    private void checkEQdispatch(Object a, Object b, String field, Object aParent, Object bParent) {\n@@ -62,3 +109,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: null mismatch\");\n-            print(a, \"a \" + context);\n-            print(b, \"b \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: null mismatch\");\n+            print(a, b, field, aParent, bParent);\n@@ -69,2 +115,2 @@\n-        Class ca = a.getClass();\n-        Class cb = b.getClass();\n+        Class<?> ca = a.getClass();\n+        Class<?> cb = b.getClass();\n@@ -72,1 +118,1 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: class mismatch.\");\n+            System.err.println(\"ERROR: Equality matching failed: class mismatch.\");\n@@ -74,2 +120,1 @@\n-            print(a, \"a \" + context);\n-            print(b, \"b \" + context);\n+            print(a, b, field, aParent, bParent);\n@@ -79,0 +124,6 @@\n+        \/\/ Already visited? This makes sure that we are not stuck in cycles, and that we have\n+        \/\/ a mapping of pairs (a, b) for structurally equivalent Objects.\n+        if (checkAlreadyVisited(a, b, field, aParent, bParent)) {\n+            return;\n+        }\n+\n@@ -80,16 +131,19 @@\n-            case Object[]  x -> checkEQimpl(x, (Object[])b,                context);\n-            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),      context);\n-            case Character x -> checkEQimpl(x, ((Character)b).charValue(), context);\n-            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),    context);\n-            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),    context);\n-            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),      context);\n-            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),    context);\n-            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),  context);\n-            case byte[]    x -> checkEQimpl(x, (byte[])b,                  context);\n-            case char[]    x -> checkEQimpl(x, (char[])b,                  context);\n-            case short[]   x -> checkEQimpl(x, (short[])b,                 context);\n-            case int[]     x -> checkEQimpl(x, (int[])b,                   context);\n-            case long[]    x -> checkEQimpl(x, (long[])b,                  context);\n-            case float[]   x -> checkEQimpl(x, (float[])b,                 context);\n-            case double[]  x -> checkEQimpl(x, (double[])b,                context);\n-            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,      context);\n+            case Object[]  x -> checkEQimpl(x, (Object[])b,                 field, aParent, bParent);\n+            case Byte      x -> checkEQimpl(x, (Byte)b,                     field, aParent, bParent);\n+            case Character x -> checkEQimpl(x, (Character)b,                field, aParent, bParent);\n+            case Short     x -> checkEQimpl(x, (Short)b,                    field, aParent, bParent);\n+            case Integer   x -> checkEQimpl(x, (Integer)b,                  field, aParent, bParent);\n+            case Long      x -> checkEQimpl(x, (Long)b,                     field, aParent, bParent);\n+            case Float     x -> checkEQimpl(x, (Float)b,                    field, aParent, bParent);\n+            case Double    x -> checkEQimpl(x, (Double)b,                   field, aParent, bParent);\n+            case Boolean   x -> checkEQimpl(x, (Boolean)b,                  field, aParent, bParent);\n+            case byte[]    x -> checkEQimpl(x, (byte[])b,                   field, aParent, bParent);\n+            case char[]    x -> checkEQimpl(x, (char[])b,                   field, aParent, bParent);\n+            case short[]   x -> checkEQimpl(x, (short[])b,                  field, aParent, bParent);\n+            case int[]     x -> checkEQimpl(x, (int[])b,                    field, aParent, bParent);\n+            case long[]    x -> checkEQimpl(x, (long[])b,                   field, aParent, bParent);\n+            case float[]   x -> checkEQimpl(x, (float[])b,                  field, aParent, bParent);\n+            case double[]  x -> checkEQimpl(x, (double[])b,                 field, aParent, bParent);\n+            case boolean[] x -> checkEQimpl(x, (boolean[])b,                field, aParent, bParent);\n+            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,       field, aParent, bParent);\n+            case Exception x -> checkEQimpl(x, (Exception) b,               field, aParent, bParent);\n@@ -97,4 +151,5 @@\n-                System.err.println(\"ERROR: Verify.checkEQ failed: type not supported: \" + ca.getName());\n-                print(a, \"a \" + context);\n-                print(b, \"b \" + context);\n-                throw new VerifyException(\"Object array type not supported: \" + ca.getName());\n+                if (isVectorAPIClass(ca)) {\n+                    checkEQForVectorAPIClass(a, b, field, aParent, bParent);\n+                } else {\n+                    checkEQArbitraryClasses(a, b);\n+                }\n@@ -108,1 +163,1 @@\n-    private static void checkEQimpl(byte a, byte b, String context) {\n+    private void checkEQimpl(byte a, byte b, String field, Object aParent, Object bParent) {\n@@ -110,1 +165,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -118,1 +174,1 @@\n-    private static void checkEQimpl(char a, char b, String context) {\n+    private void checkEQimpl(char a, char b, String field, Object aParent, Object bParent) {\n@@ -120,1 +176,4 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            \/\/ Note: we need to cast \"(int)a\", otherwise a char of numerical value \"66\" is\n+            \/\/       formatted as character \"B\".\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            print(a, b, field, aParent, bParent);\n@@ -128,1 +187,1 @@\n-    private static void checkEQimpl(short a, short b, String context) {\n+    private void checkEQimpl(short a, short b, String field, Object aParent, Object bParent) {\n@@ -130,2 +189,3 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n-            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n@@ -138,1 +198,1 @@\n-    private static void checkEQimpl(int a, int b, String context) {\n+    private void checkEQimpl(int a, int b, String field, Object aParent, Object bParent) {\n@@ -140,1 +200,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -148,1 +209,1 @@\n-    private static void checkEQimpl(long a, long b, String context) {\n+    private void checkEQimpl(long a, long b, String field, Object aParent, Object bParent) {\n@@ -150,1 +211,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -156,1 +218,8 @@\n-     * Verify that two floats have identical bits.\n+     * There are two comparison modes: one where we compare the raw bits, which sees different NaN\n+     * encodings as different values, and one where we see all NaN encodings as identical.\n+     * Ideally, we would want to assert that the Float.floatToRawIntBits are identical.\n+     * But the Java spec allows us to return different bits for a NaN, which allows swapping the inputs\n+     * of an add or mul (NaN1 * NaN2 does not have same bits as NaN2 * NaN1, because the multiplication\n+     * of two NaN values should always return the first of the two).\n+     * Hence, by default, we pick the non-raw comparison: we verify that we have the same bit\n+     * pattern in all cases, except for NaN we project to the canonical NaN, using Float.floatToIntBits.\n@@ -158,5 +227,22 @@\n-    private static void checkEQimpl(float a, float b, String context) {\n-        if (Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)) {\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n-            System.err.println(\"       Values: \" + a + \" vs \" + b);\n-            System.err.println(\"       Values: \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+    private boolean isFloatEQ(float a, float b) {\n+        return isFloatCheckWithRawBits ? Float.floatToRawIntBits(a) == Float.floatToRawIntBits(b)\n+                                       : Float.floatToIntBits(a) == Float.floatToIntBits(b);\n+    }\n+\n+    \/**\n+     * See comments for {@link #isFloatEQ}.\n+     *\/\n+    private boolean isDoubleEQ(double a, double b) {\n+        return isFloatCheckWithRawBits ? Double.doubleToRawLongBits(a) == Double.doubleToRawLongBits(b)\n+                                       : Double.doubleToLongBits(a) == Double.doubleToLongBits(b);\n+    }\n+\n+    \/**\n+     * Check that two floats are equal according to {@link #isFloatEQ}.\n+     *\/\n+    private void checkEQimpl(float a, float b, String field, Object aParent, Object bParent) {\n+        if (!isFloatEQ(a, b)) {\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch. check raw: \" + isFloatCheckWithRawBits);\n+            System.err.println(\"  Values: \" + a + \" vs \" + b);\n+            System.err.println(\"  Raw:    \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+            print(a, b, field, aParent, bParent);\n@@ -168,1 +254,1 @@\n-     * Verify that two doubles have identical bits.\n+     * Check that two doubles are equal according to {@link #isDoubleEQ}.\n@@ -170,3 +256,3 @@\n-    private static void checkEQimpl(double a, double b, String context) {\n-        if (Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)) {\n-            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+    private void checkEQimpl(double a, double b, String field, Object aParent, Object bParent) {\n+        if (!isDoubleEQ(a, b)) {\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch. check raw: \" + isFloatCheckWithRawBits);\n@@ -174,1 +260,13 @@\n-            System.err.println(\"       Values: \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            System.err.println(\"       Raw:    \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two booleans are identical.\n+     *\/\n+    private void checkEQimpl(boolean a, boolean b, String field, Object aParent, Object bParent) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch: \" + a + \" vs \" + b);\n+            print(a, b, field, aParent, bParent);\n@@ -180,1 +278,1 @@\n-     * Verify that the content of two MemorySegments is identical. Note: we do not check the\n+     * Verify that the contents of two MemorySegments are identical. Note: we do not check the\n@@ -183,1 +281,1 @@\n-    private static void checkEQimpl(MemorySegment a, MemorySegment b, String context) {\n+    private void checkEQimpl(MemorySegment a, MemorySegment b, String field, Object aParent, Object bParent) {\n@@ -188,1 +286,1 @@\n-        System.err.println(\"ERROR: Verify.checkEQ failed for: \" + context);\n+        System.err.println(\"ERROR: Equality matching failed\");\n@@ -190,2 +288,3 @@\n-        printMemorySegment(a, \"a \" + context);\n-        printMemorySegment(b, \"b \" + context);\n+        print(a, b, field, aParent, bParent);\n+        printMemorySegment(a, \"a\");\n+        printMemorySegment(b, \"b\");\n@@ -206,1 +305,21 @@\n-     * Verify that the content of two byte arrays is identical.\n+     * Verify that two Exceptions have the same message. Messages are not always carried,\n+     * they are often dropped for performance reasons, and that is okay. But if both Exceptions\n+     * have the message, we should compare them.\n+     *\/\n+    private void checkEQimpl(Exception a, Exception b, String field, Object aParent, Object bParent) {\n+        String am = a.getMessage();\n+        String bm = b.getMessage();\n+\n+        \/\/ Missing messages is expected, but if they both have one, they must agree.\n+        if (am == null || bm == null) { return; }\n+        if (am.equals(bm)) { return; }\n+\n+        System.err.println(\"ERROR: Equality matching failed:\");\n+        System.err.println(\"a: \" + a.getMessage());\n+        System.err.println(\"b: \" + b.getMessage());\n+        print(a, b, field, aParent, bParent);\n+        throw new VerifyException(\"Exception message mismatch: \" + a + \" vs \" + b);\n+    }\n+\n+    \/**\n+     * Verify that the contents of two byte arrays are identical.\n@@ -208,2 +327,2 @@\n-    private static void checkEQimpl(byte[] a, byte[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(byte[] a, byte[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -213,1 +332,1 @@\n-     * Verify that the content of two char arrays is identical.\n+     * Verify that the contents of two char arrays are identical.\n@@ -215,2 +334,2 @@\n-    private static void checkEQimpl(char[] a, char[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(char[] a, char[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -220,1 +339,1 @@\n-     * Verify that the content of two short arrays is identical.\n+     * Verify that the contents of two short arrays are identical.\n@@ -222,2 +341,2 @@\n-    private static void checkEQimpl(short[] a, short[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(short[] a, short[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -227,1 +346,1 @@\n-     * Verify that the content of two int arrays is identical.\n+     * Verify that the contents of two int arrays are identical.\n@@ -229,2 +348,2 @@\n-    private static void checkEQimpl(int[] a, int[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(int[] a, int[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -234,1 +353,1 @@\n-     * Verify that the content of two long arrays is identical.\n+     * Verify that the contents of two long arrays are identical.\n@@ -236,2 +355,2 @@\n-    private static void checkEQimpl(long[] a, long[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(long[] a, long[] b, String field, Object aParent, Object bParent) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), field + \" -> to MemorySegment\", aParent, bParent);\n@@ -241,1 +360,1 @@\n-     * Verify that the content of two float arrays is identical.\n+     * Check that two float arrays are equal according to {@link #isFloatEQ}.\n@@ -243,2 +362,33 @@\n-    private static void checkEQimpl(float[] a, float[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(float[] a, float[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Float array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (!isFloatEQ(a[i], b[i])) {\n+                System.err.println(\"ERROR: Equality matching failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i] + \". check raw: \" + isFloatCheckWithRawBits);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Float array value mismatch \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Check that two double arrays are equal according to {@link #isDoubleEQ}.\n+     *\/\n+    private void checkEQimpl(double[] a, double[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Double array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (!isDoubleEQ(a[i], b[i])) {\n+                System.err.println(\"ERROR: Equality matching failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i] + \". check raw: \" + isFloatCheckWithRawBits);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Double array value mismatch \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n@@ -248,1 +398,1 @@\n-     * Verify that the content of two double arrays is identical.\n+     * Verify that the contents of two boolean arrays are identical.\n@@ -250,2 +400,14 @@\n-    private static void checkEQimpl(double[] a, double[] b, String context) {\n-        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    private void checkEQimpl(boolean[] a, boolean[] b, String field, Object aParent, Object bParent) {\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Boolean array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] != b[i]) {\n+                System.err.println(\"ERROR: Equality matching failed: value mismatch at \" + i + \": \" + a[i] + \" vs \" + b[i]);\n+                print(a, b, field, aParent, bParent);\n+                throw new VerifyException(\"Boolean array value mismatch.\");\n+            }\n+        }\n@@ -255,1 +417,1 @@\n-     * Verify that the content of two Object arrays is identical, recursively:\n+     * Verify that the contents of two Object arrays are identical, recursively:\n@@ -258,1 +420,1 @@\n-    private static void checkEQimpl(Object[] a, Object[] b, String context) {\n+    private void checkEQimpl(Object[] a, Object[] b, String field, Object aParent, Object bParent) {\n@@ -261,1 +423,2 @@\n-            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            System.err.println(\"ERROR: Equality matching failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            print(a, b, field, aParent, bParent);\n@@ -267,1 +430,45 @@\n-            checkEQ(a[i], b[i], \"[\" + i + \"]\" + context);\n+            checkEQdispatch(a[i], b[i], \"[\" + i + \"]\", a, b);\n+        }\n+    }\n+\n+    private static boolean isVectorAPIClass(Class<?> c) {\n+        return c.getName().startsWith(\"jdk.incubator.vector\") &&\n+               c.getName().contains(\"Vector\");\n+    }\n+\n+    \/**\n+     * We do not want to import jdk.incubator.vector explicitly, because it would mean we would also have\n+     * to add \"--add-modules=jdk.incubator.vector\" to the command-line of every test that uses the Verify\n+     * class. So we hack this via reflection.\n+     *\/\n+    private void checkEQForVectorAPIClass(Object a, Object b, String field, Object aParent, Object bParent) {\n+        Class<?> ca = a.getClass();\n+        Object va;\n+        Object vb;\n+        try {\n+            Method m = ca.getMethod(\"toArray\");\n+            m.setAccessible(true);\n+            va = m.invoke(a);\n+            vb = m.invoke(b);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(\"Could not invoke toArray on \" + ca.getName(), e);\n+        }\n+        checkEQdispatch(va, vb, field + \".toArray\", aParent, bParent);\n+    }\n+\n+    private void checkEQArbitraryClasses(Object a, Object b) {\n+        Class<?> c = a.getClass();\n+        while (c != Object.class) {\n+            for (Field field : c.getDeclaredFields()) {\n+                Object va;\n+                Object vb;\n+                try {\n+                    field.setAccessible(true);\n+                    va = field.get(a);\n+                    vb = field.get(b);\n+                } catch (IllegalAccessException e) {\n+                    throw new VerifyException(\"Failure to access field: \" + field + \" of \" + a);\n+                }\n+                checkEQdispatch(va, vb, field.getName(), a, b);\n+            }\n+            c = c.getSuperclass();\n@@ -271,3 +478,38 @@\n-    private static void print(Object a, String context) {\n-        if (a == null) {\n-            System.err.println(\"  \" + context + \": null\");\n+    private void print(Object a, Object b, String field, Object aParent, Object bParent) {\n+        System.err.println(\"  aParent: \" + (aParent != null ? aParent : \"<none>\"));\n+        System.err.println(\"  bParent: \" + (bParent != null ? bParent : \"<none>\"));\n+        System.err.println(\"  field:   \" + field);\n+        System.err.println(\"  a:       \" + a);\n+        System.err.println(\"  b:       \" + b);\n+    }\n+    \/**\n+     * When comparing arbitrary classes recursively, we need to remember which\n+     * pairs of objects {@code (a, b)} we have already visited. The maps\n+     * {@link #a2b} and {@link #b2a} track these edges. Caching which pairs\n+     * we have already visited means the traversal only needs to visit every\n+     * pair once. And should we ever find a pair {@code (a, b')} or {@code (a', b)},\n+     * then we know that the two structures are not structurally equivalent.\n+     *\/\n+    private boolean checkAlreadyVisited(Object a, Object b, String field, Object aParent, Object bParent) {\n+        \/\/ Boxed primitives are not guaranteed to be the same Object for the same primitive value.\n+        \/\/ Hence, we cannot use the mapping below. We test these boxed primitive types by value anyway,\n+        \/\/ and they are no recursive structures, so there is no point in optimizing here anyway.\n+        switch (a) {\n+            case Boolean _,\n+                 Byte _,\n+                 Short _,\n+                 Character _,\n+                 Integer _,\n+                 Long _,\n+                 Float _,\n+                 Double _ -> { return false; }\n+            default -> {}\n+        }\n+\n+        Object bPrevious = a2b.get(a);\n+        Object aPrevious = b2a.get(b);\n+        if (aPrevious == null && bPrevious == null) {\n+            \/\/ Record for next time.\n+            a2b.put(a, b);\n+            b2a.put(b, a);\n+            return false;\n@@ -275,1 +517,8 @@\n-            System.err.println(\"  \" + context + \": \" + a);\n+            if (a != aPrevious || b != bPrevious) {\n+                System.err.println(\"ERROR: Equality matching failed:\");\n+                print(a, b, field, aParent, bParent);\n+                System.err.println(\"  aPrevious: \" + aPrevious);\n+                System.err.println(\"  bPrevious: \" + bPrevious);\n+                throw new VerifyException(\"Mismatch with previous pair.\");\n+            }\n+            return true;\n@@ -279,1 +528,1 @@\n-    private static void printMemorySegment(MemorySegment a, String context) {\n+    private void printMemorySegment(MemorySegment a, String name) {\n@@ -281,1 +530,1 @@\n-        System.err.println(\"  \" + context + \" via MemorySegment:\");\n+        System.err.println(\"  MemorySegment \" + name + \":\");\n@@ -292,1 +541,1 @@\n-    private static void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n+    private void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n@@ -299,1 +548,1 @@\n-        System.err.println(\"\");\n+        System.err.println();\n@@ -307,1 +556,1 @@\n-        System.err.println(\"\");\n+        System.err.println();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":349,"deletions":100,"binary":false,"changes":449,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-    private static final String POSTFIX = \"#I_\";\n+    public static final String POSTFIX = \"#I_\";\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeIRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * @test\n+ * @summary tbd\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @compile ..\/..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main\/othervm --enable-preview\n+ *                   compiler.valhalla.inlinetypes.templating.TestOne\n+ *\/\n+\n+package compiler.valhalla.inlinetypes.templating;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.library.CodeGenerationDataNameType.booleans;\n+\n+public class TestOne {\n+\n+    public static String generate(CompileFramework compiler) {\n+        final List<CodeGenerationDataNameType> types = new ArrayList<>();\n+        types.addAll(CodeGenerationDataNameType.PRIMITIVE_TYPES);\n+        types.add(new IntArrayType());\n+\n+        var irNodesTemplate = Template.make(() -> body(\n+            \"\"\"\n+            static final String BOX_KLASS = \"compiler\/valhalla\/inlinetypes\/templating\/generated\/.*Box\\\\\\\\w*\";\n+            static final String ANY_KLASS = \"compiler\/valhalla\/inlinetypes\/templating\/generated\/[\\\\\\\\w\/]*\";\n+\n+            static final String ALLOC_OF_BOX_KLASS = IRNode.PREFIX + \"ALLOC_OF_BOX_KLASS\" + InlineTypeIRNode.POSTFIX;\n+            static {\n+                 IRNode.allocateOfNodes(ALLOC_OF_BOX_KLASS, BOX_KLASS);\n+            }\n+\n+            static final String STORE_OF_ANY_KLASS = IRNode.PREFIX + \"STORE_OF_ANY_KLASS\" + InlineTypeIRNode.POSTFIX;\n+            static {\n+                IRNode.anyStoreOfNodes(STORE_OF_ANY_KLASS, ANY_KLASS);\n+            }\n+            \"\"\"\n+        ));\n+\n+        final List<TemplateToken> testTokens = new ArrayList<>();\n+        testTokens.add(irNodesTemplate.asToken());\n+        types.forEach(type -> testTokens.add(uniFieldTest(type)));\n+\n+        \/\/ Basic multi-field test but there's a limit to which types and contents it can have\n+        testTokens.add(multiFieldType(List.of(booleans(), booleans())));\n+\n+        return TestFrameworkClass.render(\n+            \"compiler.valhalla.inlinetypes.templating.generated\",\n+            \"TestBox\",\n+            Set.of(\"compiler.lib.ir_framework.ForceInline\",\n+                \"compiler.lib.verify.Verify\",\n+                \"compiler.valhalla.inlinetypes.InlineTypeIRNode\"),\n+            compiler.getEscapedClassPathOfCompiledClasses(),\n+            testTokens\n+        );\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        final CompileFramework compiler = new CompileFramework();\n+\n+        final String code = generate(compiler);\n+        System.out.println(\"Code: \" + System.lineSeparator() + code);\n+\n+        compiler.addJavaSourceCode(\"TestBox\", code);\n+\n+        compiler.compile(\n+            \"--enable-preview\",\n+            \"--release\",\n+            System.getProperty(\"java.specification.version\")\n+        );\n+\n+        compiler.invoke(\n+            \"compiler.valhalla.inlinetypes.templating.generated.TestBox\",\n+            \"main\",\n+            new Object[] {new String[] {\n+                \"--enable-preview\", \"-XX:-DoEscapeAnalysis\"\n+                \/\/ , \"-XX:+PrintFieldLayout\"\n+                \/\/ , \"-XX:+PrintInlining\"\n+            }}\n+        );\n+    }\n+\n+    record FieldConstant(Object value, int id, PrimitiveType type) {\n+        String name() {\n+            return \"v\" + id;\n+        }\n+\n+        static FieldConstant of(int id, PrimitiveType type) {\n+            return new FieldConstant(type.con(), id, type);\n+        }\n+    }\n+\n+    static TemplateToken fields(List<FieldConstant> constants) {\n+        return Template.make(() -> body(\n+            constants.stream()\n+                .map(TestOne::field)\n+                .toList()\n+        )).asToken();\n+    }\n+\n+    static TemplateToken field(FieldConstant field) {\n+        return Template.make(\"FIELD\", (FieldConstant f) -> body(\n+            let(\"FIELD_TYPE\", f.type),\n+            let(\"FIELD_VALUE\", f.value),\n+            let(\"FIELD_NAME\", f.name()),\n+            \"\"\"\n+            final #FIELD_TYPE #FIELD_NAME = #FIELD_VALUE;\n+            \"\"\"\n+        )).asToken(field);\n+    }\n+\n+    \/\/ todo works with:\n+    \/\/     var value = #VALUE;\n+    \/\/     var box = new $Box(value);\n+    static TemplateToken uniFieldTest(CodeGenerationDataNameType type) {\n+        return Template.make(\"TYPE\", (CodeGenerationDataNameType t) -> body(\n+            let(\"BOXED\", getCheckEQTypeName(type)),\n+            let(\"VALUE\", t.con()),\n+            \"\"\"\n+            static value class $Box {\n+                final #TYPE $v;\n+\n+                @ForceInline\n+                $Box(#TYPE $v) {\n+                    this.$v = $v;\n+                }\n+            }\n+\n+            @Test\n+            @IR(failOn = {ALLOC_OF_BOX_KLASS, STORE_OF_ANY_KLASS, IRNode.UNSTABLE_IF_TRAP, IRNode.PREDICATE_TRAP})\n+            public static #TYPE $test() {\n+                var box = new $Box(#VALUE);\n+                return box.$v;\n+            }\n+\n+            @Check(test = \"$test\")\n+            public void $checkTest(#TYPE result) {\n+                Verify.checkEQ(#VALUE, (#BOXED) result);\n+            }\n+            \"\"\"\n+        )).asToken(type);\n+    }\n+\n+    private static String getCheckEQTypeName(CodeGenerationDataNameType type) {\n+        return type instanceof PrimitiveType pt\n+            ? pt.boxedTypeName()\n+            : type.name();\n+    }\n+\n+    static TemplateToken multiFieldType(List<PrimitiveType> fieldTypes) {\n+        final AtomicInteger fieldId = new AtomicInteger();\n+        final List<FieldConstant> fields = fieldTypes.stream()\n+            .map(fieldType -> FieldConstant.of(fieldId.getAndIncrement(), fieldType))\n+            .toList();\n+\n+        return Template.make(() -> body(\n+            \"\"\"\n+            static value class $Box {\n+            \"\"\",\n+            fields(fields),\n+            hashMethod(fields),\n+            \"\"\"\n+            }\n+            \"\"\",\n+            \"\"\"\n+            static int $expected = $test();\n+\n+            @Test\n+            @IR(failOn = {ALLOC_OF_BOX_KLASS, STORE_OF_ANY_KLASS, IRNode.UNSTABLE_IF_TRAP, IRNode.PREDICATE_TRAP})\n+            public static int $test() {\n+                var box = new $Box();\n+                return box.hash();\n+            }\n+\n+            @Check(test = \"$test\")\n+            public void $checkTest(int result) {\n+                Verify.checkEQ($expected, result);\n+            }\n+            \"\"\"\n+        )).asToken();\n+    }\n+\n+    static TemplateToken hashMethod(List<FieldConstant> fields) {\n+        return Template.make(() -> body(\n+            \"\"\"\n+            int hash() {\n+                return\n+            \"\"\",\n+            fields.stream().map(TestOne::hashField).toList(),\n+            \"\"\"\n+                0;\n+            }\n+            \"\"\"\n+        )).asToken();\n+    }\n+\n+    static TemplateToken hashField(FieldConstant field) {\n+        return Template.make(\"FIELD\", (FieldConstant f) -> body(\n+            let(\"BOXED\", f.type.boxedTypeName()),\n+            let(\"FIELD_NAME\", f.name()),\n+            \"\"\"\n+            #BOXED.hashCode(#FIELD_NAME) +\n+            \"\"\"\n+        )).asToken(field);\n+    }\n+\n+    static final class IntArrayType implements CodeGenerationDataNameType {\n+        @Override\n+        public Object con() {\n+            return \"new int[]{%s}\".formatted(\n+                CodeGenerationDataNameType.ints().con()\n+            );\n+        }\n+\n+        @Override\n+        public String name() {\n+            return \"int[]\";\n+        }\n+\n+        @Override\n+        public boolean isSubtypeOf(DataName.Type other) {\n+            return other instanceof IntArrayType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/templating\/TestOne.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test simple use of Templates with the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main template_framework.examples.TestAdvanced\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+\/**\n+ * This is a basic example for Templates, using them to cover a list of test variants.\n+ * <p>\n+ * The \"@compile\" command for JTREG is required so that the frameworks used in the Template code\n+ * are compiled and available for the Test-VM.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test-VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class TestAdvanced {\n+    public static final RestrictableGenerator<Integer> GEN_BYTE = Generators.G.safeRestrict(Generators.G.ints(), Byte.MIN_VALUE, Byte.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n+    public static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n+    public static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n+    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnerTest.main();\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {});\n+    }\n+\n+    interface MyGenerator {\n+        Object next();\n+    }\n+\n+    record Type(String name, MyGenerator generator, List<String> operators) {}\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+\n+        \/\/ The test template:\n+        \/\/ - For a chosen type, operator, and generator.\n+        \/\/ - The variable name \"GOLD\" and the test name \"test\" would get conflicts\n+        \/\/   if we instantiate the template multiple times. Thus, we use the $ prefix\n+        \/\/   so that the Template Framework can replace the names and make them unique\n+        \/\/   for each Template instantiation.\n+        \/\/ - The GOLD value is computed at the beginning, hopefully by the interpreter.\n+        \/\/ - The test method is eventually compiled, and the values are verified by the\n+        \/\/   check method.\n+        var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+            let(\"con1\", generator.next()),\n+            let(\"con2\", generator.next()),\n+            \"\"\"\n+            \/\/ #typeName #operator #con1 #con2\n+            public static #typeName $GOLD = $test();\n+\n+            @Test\n+            public static #typeName $test() {\n+                return (#typeName)(#con1 #operator #con2);\n+            }\n+\n+            @Check(test = \"$test\")\n+            public static void $check(#typeName result) {\n+                Verify.checkEQ(result, $GOLD);\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Template for the Class.\n+        var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+            let(\"classpath\", comp.getEscapedClassPathOfCompiledClasses()),\n+            \"\"\"\n+            package p.xyz;\n+\n+            import compiler.lib.ir_framework.*;\n+            import compiler.lib.verify.*;\n+\n+            public class InnerTest {\n+                public static void main() {\n+                    TestFramework framework = new TestFramework(InnerTest.class);\n+                    \/\/ Set the classpath, so that the TestFramework test VM knows where\n+                    \/\/ the CompileFramework put the class files of the compiled source code.\n+                    framework.addFlags(\"-classpath\", \"#classpath\");\n+                    framework.start();\n+                }\n+\n+            \"\"\",\n+            \/\/ Call the testTemplate for each type and operator, generating a\n+            \/\/ list of lists of TemplateToken:\n+            types.stream().map((Type type) ->\n+                type.operators().stream().map((String operator) ->\n+                    testTemplate.asToken(type.name(), operator, type.generator())).toList()\n+            ).toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ For each type, we choose a list of operators that do not throw exceptions.\n+        List<Type> types = List.of(\n+            new Type(\"byte\",   GEN_BYTE::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"char\",   GEN_CHAR::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"short\",  GEN_SHORT::next,  List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"int\",    GEN_INT::next,    List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"long\",   GEN_LONG::next,   List.of(\"+\", \"-\", \"*\", \"&\", \"|\", \"^\")),\n+            new Type(\"float\",  GEN_FLOAT::next,  List.of(\"+\", \"-\", \"*\", \"\/\")),\n+            new Type(\"double\", GEN_DOUBLE::next, List.of(\"+\", \"-\", \"*\", \"\/\"))\n+        );\n+\n+        \/\/ Use the template with one argument and render it to a String.\n+        return classTemplate.render(types);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8358772\n+ * @summary Demonstrate the use of PrimitiveTypes form the Template Library.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run main template_framework.examples.TestPrimitiveTypes\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Collections;\n+import java.util.HashMap;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.dataNames;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+\n+\/**\n+ * This test shows the use of {@link PrimitiveType}.\n+ *\/\n+public class TestPrimitiveTypes {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnerTest.main();\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {});\n+    }\n+\n+    \/\/ Generate a Java source file as String\n+    public static String generate() {\n+        \/\/ Generate a list of test methods.\n+        Map<String, TemplateToken> tests = new HashMap<>();\n+\n+        \/\/ The boxing tests check if we can autobox with \"boxedTypeName\".\n+        var boxingTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+            let(\"CON1\", type.con()),\n+            let(\"CON2\", type.con()),\n+            let(\"Boxed\", type.boxedTypeName()),\n+            \"\"\"\n+            public static void #name() {\n+                #type c1 = #CON1;\n+                #type c2 = #CON2;\n+                #Boxed b1 = c1;\n+                #Boxed b2 = c2;\n+                Verify.checkEQ(c1, b1);\n+                Verify.checkEQ(c2, b2);\n+            }\n+            \"\"\"\n+        ));\n+\n+        for (PrimitiveType type : CodeGenerationDataNameType.PRIMITIVE_TYPES) {\n+            String name = \"test_boxing_\" + type.name();\n+            tests.put(name, boxingTemplate.asToken(name, type));\n+        }\n+\n+        \/\/ Integral and Float types have a size. Also test if \"isFloating\" is correct.\n+        var integralFloatTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+            let(\"size\", type.byteSize()),\n+            let(\"isFloating\", type.isFloating()),\n+            \"\"\"\n+            public static void #name() {\n+                \/\/ Test byteSize via creation of array.\n+                #type[] array = new #type[1];\n+                MemorySegment ms = MemorySegment.ofArray(array);\n+                if (#size != ms.byteSize()) {\n+                    throw new RuntimeException(\"byteSize mismatch #type\");\n+                }\n+\n+                \/\/ Test isFloating via rounding.\n+                double value = 1.5;\n+                #type rounded = (#type)value;\n+                boolean isFloating = value != rounded;\n+                if (isFloating == #isFloating) {\n+                    throw new RuntimeException(\"isFloating mismatch #type\");\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        for (PrimitiveType type : CodeGenerationDataNameType.INTEGRAL_AND_FLOATING_TYPES) {\n+            String name = \"test_integral_floating_\" + type.name();\n+            tests.put(name, integralFloatTemplate.asToken(name, type));\n+        }\n+\n+        \/\/ Finally, test the type by creating some DataNames (variables), and sampling\n+        \/\/ from them. There should be no cross-over between the types.\n+        var variableTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+            let(\"CON\", type.con()),\n+            addDataName($(\"var\"), type, MUTABLE),\n+            \"\"\"\n+            #type $var = #CON;\n+            \"\"\"\n+        ));\n+\n+        var sampleTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+            let(\"var\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+            let(\"CON\", type.con()),\n+            \"\"\"\n+            #var = #CON;\n+            \"\"\"\n+        ));\n+\n+        var namesTemplate = Template.make(() -> body(\n+            \"\"\"\n+            public static void test_names() {\n+            \"\"\",\n+            Hooks.METHOD_HOOK.anchor(\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(type ->\n+                        Hooks.METHOD_HOOK.insert(variableTemplate.asToken(type))\n+                    ).toList()\n+                ),\n+                \"\"\"\n+                \/\/ Now sample:\n+                \"\"\",\n+                Collections.nCopies(10,\n+                    CodeGenerationDataNameType.PRIMITIVE_TYPES.stream().map(sampleTemplate::asToken).toList()\n+                )\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        tests.put(\"test_names\", namesTemplate.asToken());\n+\n+        \/\/ Finally, put all the tests together in a class, and invoke all\n+        \/\/ tests from the main method.\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            import compiler.lib.verify.*;\n+            import java.lang.foreign.MemorySegment;\n+\n+            public class InnerTest {\n+                public static void main() {\n+            \"\"\",\n+            \/\/ Call all test methods from main.\n+            tests.keySet().stream().map(\n+                n -> List.of(n, \"();\\n\")\n+            ).toList(),\n+            \"\"\"\n+                }\n+            \"\"\",\n+            \/\/ Now add all the test methods.\n+            tests.values().stream().toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render the template to a String.\n+        return template.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test simple use of Templates with the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.examples.TestSimple\n+ *\/\n+\n+package template_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+\n+public class TestSimple {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = p.xyz.InnerTest.test();\n+        Object ret = comp.invoke(\"p.xyz.InnerTest\", \"test\", new Object[] {});\n+        System.out.println(\"res: \" + ret);\n+\n+        \/\/ Check that the return value is the sum of the two arguments.\n+        if ((42 + 7) != (int)ret) {\n+            throw new RuntimeException(\"Unexpected result\");\n+        }\n+    }\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate() {\n+        \/\/ Create a Template with two arguments.\n+        var template = Template.make(\"arg1\", \"arg2\", (Integer arg1, String arg2) -> body(\n+            \"\"\"\n+            package p.xyz;\n+            public class InnerTest {\n+                public static int test() {\n+                    return #arg1 + #arg2;\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Use the template with two arguments, and render it to a String.\n+        return template.render(42, \"7\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestSimple.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,1227 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Demonstrate the use of Templates with the Compile Framework.\n+ *          It displays the use of most features in the Template Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.examples.TestTutorial\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import compiler.lib.compile_framework.*;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.Hook;\n+import compiler.lib.template_framework.TemplateBinding;\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.StructuralName;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.fuel;\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.Template.dataNames;\n+import static compiler.lib.template_framework.Template.addStructuralName;\n+import static compiler.lib.template_framework.Template.structuralNames;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.IMMUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE_OR_IMMUTABLE;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+\n+public class TestTutorial {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add Java source files.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest1\",  generateWithListOfTokens());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest2\",  generateWithTemplateArguments());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3\",  generateWithHashtagAndDollarReplacements());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3b\", generateWithHashtagAndDollarReplacements2());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest4\",  generateWithCustomHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest5\",  generateWithLibraryHooks());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest6\",  generateWithRecursionAndBindingsAndFuel());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest7\",  generateWithDataNamesSimple());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest8\",  generateWithDataNamesForFieldsAndVariables());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9a\", generateWithDataNamesAndScopes1());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9b\", generateWithDataNamesAndScopes2());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest10\", generateWithDataNamesForFuzzing());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest11\", generateWithStructuralNamesForMethods());\n+\n+        \/\/ Compile the source files.\n+        \/\/ Hint: if you want to see the generated source code, you can enable\n+        \/\/       printing of the source code that the CompileFramework receives,\n+        \/\/       with -DCompileFrameworkVerbose=true\n+        \/\/       The code may not be nicely formatted, especially regarding\n+        \/\/       indentation. You might consider dumping the generated code\n+        \/\/       into an IDE or other auto-formatting tool.\n+        comp.compile();\n+\n+        comp.invoke(\"p.xyz.InnerTest1\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest2\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest3\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest3b\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest4\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest5\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest6\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest7\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest8\",  \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest9a\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest9b\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest10\", \"main\", new Object[] {});\n+        comp.invoke(\"p.xyz.InnerTest11\", \"main\", new Object[] {});\n+    }\n+\n+    \/\/ This example shows the use of various Tokens.\n+    public static String generateWithListOfTokens() {\n+        \/\/ A Template is essentially a function \/ lambda that produces a\n+        \/\/ token body, which is a list of Tokens that are concatenated.\n+        var templateClass = Template.make(() -> body(\n+            \/\/ The \"body\" method is filled by a sequence of \"Tokens\".\n+            \/\/ These can be Strings and multi-line Strings, but also\n+            \/\/ boxed primitives.\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest1 {\n+                public static void main() {\n+                    System.out.println(\"Hello World!\");\n+            \"\"\",\n+            \"int a = \", 1, \";\\n\",\n+            \"float b = \", 1.5f, \";\\n\",\n+            \/\/ Special Float values are \"smartly\" formatted!\n+            \"float nan = \", Float.POSITIVE_INFINITY, \";\\n\",\n+            \"boolean c = \", true, \";\\n\",\n+            \/\/ Lists of Tokens are also allowed:\n+            List.of(\"int \", \"d = 5\", \";\\n\"),\n+            \/\/ We can also stream \/ map over an existing list, or one created on\n+            \/\/ the fly:\n+            List.of(3, 5, 7, 11).stream().map(i -> \"System.out.println(\" + i + \");\\n\").toList(),\n+            \"\"\"\n+                    System.out.println(a + \" \" + b + \" \" + nan + \" \" + c + \" \" + d);\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ This example shows the use of Templates, with and without arguments.\n+    public static String generateWithTemplateArguments() {\n+        \/\/ A Template with no arguments.\n+        var templateHello = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Hello\");\n+            \"\"\"\n+        ));\n+\n+        \/\/ A Template with a single Integer argument.\n+        var templateCompare = Template.make(\"arg\", (Integer arg) -> body(\n+            \"System.out.println(\", arg, \");\\n\",  \/\/ capture arg via lambda argument\n+            \"System.out.println(#arg);\\n\",       \/\/ capture arg via hashtag replacement\n+            \"System.out.println(#{arg});\\n\",     \/\/ capture arg via hashtag replacement with brackets\n+            \/\/ It would have been optimal to use Java String Templates to format\n+            \/\/ argument values into Strings. However, since these are not (yet)\n+            \/\/ available, the Template Framework provides two alternative ways of\n+            \/\/ formatting Strings:\n+            \/\/ 1) By appending to the comma-separated list of Tokens passed to body().\n+            \/\/    Appending as a Token works whenever one has a reference to the Object\n+            \/\/    in Java code. But often, this is rather cumbersome and looks awkward,\n+            \/\/    given all the additional quotes and commands required. Hence, it\n+            \/\/    is encouraged to only use this method when necessary.\n+            \/\/ 2) By hashtag replacements inside a single string. One can either\n+            \/\/    use \"#arg\" directly, or use brackets \"#{arg}\". When possible, one\n+            \/\/    should prefer avoiding the brackets, as they create additional\n+            \/\/    noise. However, there are cases where they are useful, for\n+            \/\/    example \"#TYPE_CON\" would be parsed as a hashtag replacement\n+            \/\/    for the hashtag name \"TYPE_CON\", whereas \"#{TYPE}_CON\" is\n+            \/\/    parsed as hashtag name \"TYPE\", followed by literal string \"_CON\".\n+            \/\/    See also: generateWithHashtagAndDollarReplacements2\n+            \/\/    There are two ways to define the value of a hashtag replacement:\n+            \/\/    a) Capturing Template arguments as Strings.\n+            \/\/    b) Using a \"let\" definition (see examples further down).\n+            \/\/ Which one should be preferred is a code style question. Generally, we\n+            \/\/ prefer the use of hashtag replacements because that allows easy use of\n+            \/\/ multiline strings (i.e. text blocks).\n+            \"if (#arg != \", arg, \") { throw new RuntimeException(\\\"mismatch\\\"); }\\n\"\n+        ));\n+\n+        \/\/ A Template that creates the body of the Class and main method, and then\n+        \/\/ uses the two Templates above inside it.\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest2 {\n+                public static void main() {\n+            \"\"\",\n+                    templateHello.asToken(),\n+                    templateCompare.asToken(7),\n+                    templateCompare.asToken(42),\n+            \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ Example with hashtag replacements (arguments and let), and $-name renamings.\n+    \/\/ Note: hashtag replacements are a workaround for the missing string templates.\n+    \/\/       If we had string templates, we could just capture the typed lambda\n+    \/\/       arguments, and use them directly in the String via string templating.\n+    public static String generateWithHashtagAndDollarReplacements() {\n+        var template1 = Template.make(\"x\", (Integer x) -> body(\n+            \/\/ We have the \"#x\" hashtag replacement from the argument capture above.\n+            \/\/ Additionally, we can define \"#con\" as a hashtag replacement from let:\n+            let(\"con\", 3 * x),\n+            \/\/ In the code below, we use \"var\" as a local variable. But if we were\n+            \/\/ to instantiate this template twice, the names could conflict. Hence,\n+            \/\/ we automatically rename the names that have a $ prepended with\n+            \/\/ var_1, var_2, etc.\n+            \"\"\"\n+            int $var = #con;\n+            System.out.println(\"T1: #x, #con, \" + $var);\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) ->\n+            \/\/ Sometimes it can be helpful to not just create a hashtag replacement\n+            \/\/ with let, but also to capture the variable to use it as lambda parameter.\n+            let(\"y\", 11 * x, y ->\n+                body(\n+                    \"\"\"\n+                    System.out.println(\"T2: #x, #y\");\n+                    \"\"\",\n+                    template1.asToken(y)\n+                )\n+            )\n+        );\n+\n+        \/\/ This template generates an int variable and assigns it a value.\n+        \/\/ Together with template4, we see that each template has a unique renaming\n+        \/\/ for a $-name replacement.\n+        var template3 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            int #name = #value; \/\/ Note: $var is not #name\n+            \"\"\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ We will define the variable $var:\n+            \"\"\",\n+            \/\/ We can capture the $-name programmatically, and pass it to other templates:\n+            template3.asToken($(\"var\"), 42),\n+            \"\"\"\n+            if ($var != 42) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \/\/ The Template Framework API only guarantees that every Template use\n+            \/\/ has a unique ID. When using the Templates, all we need is that\n+            \/\/ variables from different Template uses do not conflict. But it can\n+            \/\/ be helpful to understand how the IDs are produced. The implementation\n+            \/\/ simply gives the first Template use the ID=1, and increments from there.\n+            \/\/\n+            \/\/ In this example, the templateClass is the first Template use, and\n+            \/\/ has ID=1. We never use a dollar replacement here, so the code will\n+            \/\/ not show any \"_1\".\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest3 {\n+                public static void main() {\n+            \"\"\",\n+                    \/\/ Second Template use: ID=2 -> var_2\n+                    template1.asToken(1),\n+                    \/\/ Third Template use: ID=3 -> var_3\n+                    template1.asToken(7),\n+                    \/\/ Fourth Template use with template2, no use of dollar, so\n+                    \/\/ no \"_4\" shows up in the generated code. Internally, it\n+                    \/\/ calls template1, which is the fifth Template use, with\n+                    \/\/ ID = 5 -> var_5\n+                    template2.asToken(2),\n+                    \/\/ Sixth and Seventh Template use -> var_7\n+                    template2.asToken(5),\n+                    \/\/ Eighth Template use with template4 -> var_8.\n+                    \/\/ Ninth Template use with internal call to template3,\n+                    \/\/ The local \"$var\" turns to \"var_9\", but the Template\n+                    \/\/ argument captured value = \"var_8\" from the outer\n+                    \/\/ template use of $(\"var\").\n+                    template4.asToken(),\n+            \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ In some cases, you may want to transform string arguments. You may\n+    \/\/ be working with types \"int\" and \"long\", and want to create names like\n+    \/\/ \"INT_CON\" and \"LONG_CON\".\n+    public static String generateWithHashtagAndDollarReplacements2() {\n+        \/\/ Let us define some final static variables of a specific type.\n+        var template1 = Template.make(\"type\", (String type) -> body(\n+            \/\/ The type (e.g. \"int\") is lower case, let us create the upper case \"INT_CON\" from it.\n+            let(\"TYPE\", type.toUpperCase()),\n+            \"\"\"\n+            static final #type #{TYPE}_CON = 42;\n+            \"\"\"\n+        ));\n+\n+        \/\/ Let's write a simple class to demonstrate that this works, i.e. produces compilable code.\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest3b {\n+            \"\"\",\n+            template1.asToken(\"int\"),\n+            template1.asToken(\"long\"),\n+            \"\"\"\n+                public static void main() {\n+                    if (INT_CON != 42 || LONG_CON != 42) {\n+                        throw new RuntimeException(\"Wrong result!\");\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ In this example, we look at the use of Hooks. They allow us to reach back, to outer\n+    \/\/ scopes. For example, we can reach out from inside a method body to a hook anchored at\n+    \/\/ the top of the class, and insert a field.\n+    public static String generateWithCustomHooks() {\n+        \/\/ We can define a custom hook.\n+        \/\/ Note: generally we prefer using the pre-defined CLASS_HOOK and METHOD_HOOK from the library,\n+        \/\/       whenever possible. See also the example after this one.\n+        var myHook = new Hook(\"MyHook\");\n+\n+        var template1 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            public static int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) -> body(\n+            \"\"\"\n+            \/\/ Let us go back to where we anchored the hook with anchor() and define a field named $field there.\n+            \/\/ Note that in the Java code we have not defined anchor() on the hook, yet. But since it's a lambda\n+            \/\/ expression, it is not evaluated, yet! Eventually, anchor() will be evaluated before insert() in\n+            \/\/ this example.\n+            \"\"\",\n+            myHook.insert(template1.asToken($(\"field\"), x)),\n+            \"\"\"\n+            System.out.println(\"$field: \" + $field);\n+            if ($field != #x) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest4 {\n+            \"\"\",\n+            \/\/ We anchor a Hook outside the main method, but inside the Class.\n+            \/\/ Anchoring a Hook creates a scope, spanning the braces of the\n+            \/\/ \"anchor\" call. Any Hook.insert that happens inside this scope\n+            \/\/ goes to the top of that scope.\n+            myHook.anchor(\n+                \/\/ Any Hook.insert goes here.\n+                \/\/\n+                \/\/ <-------- field_X = 5 ------------------+\n+                \/\/ <-------- field_Y = 7 -------------+    |\n+                \/\/                                    |    |\n+                \"\"\"\n+                public static void main() {\n+                \"\"\", \/\/                               ^    ^\n+                    template2.asToken(5), \/\/ -------- | ---+\n+                    template2.asToken(7), \/\/ ---------+\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ), \/\/ The Hook scope ends here.\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ We saw the use of custom hooks above, but now we look at the use of CLASS_HOOK and METHOD_HOOK.\n+    \/\/ By convention, we use the CLASS_HOOK for class scopes, and METHOD_HOOK for method scopes.\n+    \/\/ Whenever we open a class scope, we should anchor a CLASS_HOOK for that scope, and whenever we\n+    \/\/ open a method, we should anchor a METHOD_HOOK. Conversely, this allows us to check if we are\n+    \/\/ inside a class or method scope by querying \"isAnchored\". This convention helps us when building\n+    \/\/ a large library of Templates. But if you are writing your own self-contained set of Templates,\n+    \/\/ you do not have to follow this convention.\n+    \/\/\n+    \/\/ Hooks are \"re-entrant\", that is we can anchor the same hook inside a scope that we already\n+    \/\/ anchored it previously. The \"Hook.insert\" always goes to the innermost anchoring of that\n+    \/\/ hook. There are cases where \"re-entrant\" Hooks are helpful such as nested classes, where\n+    \/\/ there is a class scope inside another class scope. Similarly, we can nest lambda bodies\n+    \/\/ inside method bodies, so also METHOD_HOOK can be used in such a \"re-entrant\" way.\n+    public static String generateWithLibraryHooks() {\n+        var templateStaticField = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            static { System.out.println(\"Defining static field #name\"); }\n+            public static int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var templateLocalVariable = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+            \"\"\"\n+            System.out.println(\"Defining local variable #name\");\n+            int #name = #value;\n+            \"\"\"\n+        ));\n+\n+        var templateMethodBody = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ Let's define a local variable $var and a static field $field.\n+            \"\"\",\n+            Hooks.CLASS_HOOK.insert(templateStaticField.asToken($(\"field\"), 5)),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.asToken($(\"var\"), 11)),\n+            \"\"\"\n+            System.out.println(\"$field: \" + $field);\n+            System.out.println(\"$var: \" + $var);\n+            if ($field * $var != 55) { throw new RuntimeException(\"Wrong value!\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest5 {\n+            \"\"\",\n+            \/\/ Class Hook for fields.\n+            Hooks.CLASS_HOOK.anchor(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                \/\/ Method Hook for local variables, and earlier computations.\n+                Hooks.METHOD_HOOK.anchor(\n+                    \"\"\"\n+                    \/\/ This is the beginning of the \"main\" method body.\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    templateMethodBody.asToken(),\n+                    \"\"\"\n+                    System.out.println(\"Going to call other...\");\n+                    other();\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+\n+                private static void other() {\n+                \"\"\",\n+                \/\/ Have a separate method hook for other, so that it can insert\n+                \/\/ its own local variables.\n+                Hooks.METHOD_HOOK.anchor(\n+                    \"\"\"\n+                    System.out.println(\"Welcome to other!\");\n+                    \"\"\",\n+                    templateMethodBody.asToken(),\n+                    \"\"\"\n+                    System.out.println(\"Done with other.\");\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ This example shows the use of bindings to allow cyclic references of Templates,\n+    \/\/ allowing recursive template generation. We also show the use of fuel to limit\n+    \/\/ recursion.\n+    public static String generateWithRecursionAndBindingsAndFuel() {\n+        \/\/ Binding allows the use of template1 inside of template1, via the binding indirection.\n+        var binding1 = new TemplateBinding<Template.OneArg<Integer>>();\n+        var template1 = Template.make(\"depth\", (Integer depth) -> body(\n+            let(\"fuel\", fuel()),\n+            \"\"\"\n+            System.out.println(\"At depth #depth with fuel #fuel.\");\n+            \"\"\",\n+            \/\/ We cannot yet use template1 directly, as it is being defined.\n+            \/\/ So we use binding1 instead.\n+            \/\/ For every recursion depth, some fuel is automatically subtracted\n+            \/\/ so that the fuel slowly depletes with the depth.\n+            \/\/ We keep the recursion going until the fuel is depleted.\n+            \/\/\n+            \/\/ Note: if we forget to check the fuel(), the renderer causes a\n+            \/\/       StackOverflowException, because the recursion never ends.\n+            (fuel() > 0) ? binding1.get().asToken(depth + 1)\n+                        : \"System.out.println(\\\"Fuel depleted.\\\");\\n\",\n+            \"\"\"\n+            System.out.println(\"Exit depth #depth.\");\n+            \"\"\"\n+        ));\n+        binding1.bind(template1);\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest6 {\n+                public static void main() {\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    template1.asToken(0),\n+                    \"\"\"\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ Below, we introduce the concept of \"DataNames\". Code generation often involves defining\n+    \/\/ fields and variables, which are then available inside a defined scope. \"DataNames\" can\n+    \/\/ be registered at a certain scope with addDataName. This \"DataName\" is then available\n+    \/\/ in this scope, and in any nested scope, including nested Templates. This allows us to\n+    \/\/ add some fields and variables in one Template, and later on, in another Template, we\n+    \/\/ can access these fields and variables again with \"dataNames()\".\n+    \/\/\n+    \/\/ Here are a few use-cases:\n+    \/\/ - You are writing some inner Template, and would like to access a random field or\n+    \/\/   variable from an outer Template. Luckily, the outer Templates have added their\n+    \/\/   fields and variables, and you can now access them with \"dataNames()\". You can\n+    \/\/   count them, get a list of them, or sample a random one.\n+    \/\/ - You are writing some outer Template, and would like to generate a variable that\n+    \/\/   an inner Template could read from or even write to. You can \"addDataName\" the\n+    \/\/   variable, and the inner Template can then find that variable in \"dataNames()\".\n+    \/\/   If the inner Template wants to find a random field or variable, it may sample\n+    \/\/   from \"dataNodes()\", and with some probability, it would sample your variable.\n+    \/\/\n+    \/\/ A \"DataName\" captures the name of the field or variable in a String. It also\n+    \/\/ stores the type of the field or variable, as well as its \"mutability\", i.e.\n+    \/\/ an indication if the field or variable is only for reading, or if writing to\n+    \/\/ it is also allowed. If a field or variable is final, we must make sure that the\n+    \/\/ \"DataName\" is immutable, otherwise we risk that some Template attempts to generate\n+    \/\/ code that writes to the final field or variable, and then we get a compilation\n+    \/\/ error from \"javac\" later on.\n+    \/\/\n+    \/\/ To get started, we show an example where all DataNames have the same type, and where\n+    \/\/ all Names are mutable. For simplicity, our type represents the primitive int type.\n+    private record MySimpleInt() implements DataName.Type {\n+        \/\/ The type is only subtype of itself. This is relevant when sampling or weighing\n+        \/\/ DataNames, because we do not just sample from the given type, but also its subtypes.\n+        @Override\n+        public boolean isSubtypeOf(DataName.Type other) {\n+            return other instanceof MySimpleInt();\n+        }\n+\n+        \/\/ The name of the type can later be accessed, and used in code. We are working\n+        \/\/ with ints, so that is what we return.\n+        @Override\n+        public String name() { return \"int\"; }\n+    }\n+    private static final MySimpleInt mySimpleInt = new MySimpleInt();\n+\n+    \/\/ In this example, we generate 3 fields, and add their names to the\n+    \/\/ current scope. In a nested Template, we can then sample one of these\n+    \/\/ DataNames, which gives us one of the fields. We increment that randomly\n+    \/\/ chosen field. At the end, we print all three fields.\n+    public static String generateWithDataNamesSimple() {\n+        var templateMain = Template.make(() -> body(\n+            \/\/ Sample a random DataName, i.e. field, and assign its name to\n+            \/\/ the hashtag replacement \"#f\".\n+            \/\/ We are picking a mutable DataName, because we are not just\n+            \/\/ reading but also writing to the field.\n+            let(\"f\", dataNames(MUTABLE).exactOf(mySimpleInt).sample().name()),\n+            \"\"\"\n+            \/\/ Let us now sample a random field #f, and increment it.\n+            #f += 42;\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \/\/ Let us define the names for the three fields.\n+            \/\/ We can then sample from these names in a nested Template.\n+            \/\/ We make all DataNames mutable, and with the same weight of 1,\n+            \/\/ so that they have equal probability of being sampled.\n+            \/\/ Note: the default weight is 1, so we can also omit the weight.\n+            addDataName($(\"f1\"), mySimpleInt, MUTABLE, 1),\n+            addDataName($(\"f2\"), mySimpleInt, MUTABLE, 1),\n+            addDataName($(\"f3\"), mySimpleInt, MUTABLE), \/\/ omit weight, default is 1.\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest7 {\n+                \/\/ Let us define some fields.\n+                public static int $f1 = 0;\n+                public static int $f2 = 0;\n+                public static int $f3 = 0;\n+\n+                public static void main() {\n+                    \/\/ Let us now call the nested template that samples\n+                    \/\/ a random field and increments it.\n+                    \"\"\",\n+                    templateMain.asToken(),\n+                    \"\"\"\n+                    \/\/ Now, we can print all three fields, and see which\n+                    \/\/ one was incremented.\n+                    System.out.println(\"f1: \" + $f1);\n+                    System.out.println(\"f2: \" + $f2);\n+                    System.out.println(\"f3: \" + $f3);\n+                    \/\/ We have two zeros, and one 42.\n+                    if ($f1 + $f2 + $f3 != 42) { throw new RuntimeException(\"wrong result!\"); }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ In the example above, we could have easily kept track of the three fields ourselves,\n+    \/\/ and would not have had to rely on the Template Framework's DataNames for this. However,\n+    \/\/ with more complicated examples, this gets more and more difficult, if not impossible.\n+    \/\/\n+    \/\/ In the example below, we make the scenario a little more realistic. We work with an\n+    \/\/ int and a long type. In the main method, we add some fields and local variables, and\n+    \/\/ register their DataNames. When sampling from the main method, we should be able to see\n+    \/\/ both fields and variables that we just registered. But from another method, we should\n+    \/\/ only see the fields, but the local variables from main should not be sampled.\n+    \/\/\n+    \/\/ Let us now define the wrapper for primitive types such as int and long.\n+    private record MyPrimitive(String name) implements DataName.Type {\n+        @Override\n+        public boolean isSubtypeOf(DataName.Type other) {\n+            return other instanceof MyPrimitive(String n) && n.equals(name());\n+        }\n+\n+        \/\/ Note: the name method is automatically overridden by the record\n+        \/\/       field accessor.\n+        \/\/ But we would like to also directly use the type in the templates,\n+        \/\/ hence we let \"toString\" return \"int\" or \"long\".\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyPrimitive myInt = new MyPrimitive(\"int\");\n+    private static final MyPrimitive myLong = new MyPrimitive(\"long\");\n+\n+    public static String generateWithDataNamesForFieldsAndVariables() {\n+        \/\/ Define a static field.\n+        var templateStaticField = Template.make(\"type\", (DataName.Type type) -> body(\n+            addDataName($(\"field\"), type, MUTABLE),\n+            \/\/ Note: since we have overridden MyPrimitive::toString, we can use\n+            \/\/       the type directly as \"#type\" in the template, which then\n+            \/\/       gets hashtag replaced with \"int\" or \"long\".\n+            \"\"\"\n+            public static #type $field = 0;\n+            \"\"\"\n+        ));\n+\n+        \/\/ Define a local variable.\n+        var templateLocalVariable = Template.make(\"type\", (DataName.Type type) -> body(\n+            addDataName($(\"var\"), type, MUTABLE),\n+            \"\"\"\n+            #type $var = 0;\n+            \"\"\"\n+        ));\n+\n+        \/\/ Sample a random field or variable, from those that are available at\n+        \/\/ the current scope.\n+        var templateSample = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"name\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+            \/\/ Note: we could also sample from MUTABLE_OR_IMMUTABLE, we will\n+            \/\/       cover the concept of mutability in an example further down.\n+            \"\"\"\n+            System.out.println(\"Sampling type #type: #name = \" + #name);\n+            \"\"\"\n+        ));\n+\n+        \/\/ Check how many fields and variables are available at the current scope.\n+        var templateStatus = Template.make(() -> body(\n+            let(\"ints\", dataNames(MUTABLE).exactOf(myInt).count()),\n+            let(\"longs\", dataNames(MUTABLE).exactOf(myLong).count()),\n+            \/\/ Note: we could also count the MUTABLE_OR_IMMUTABLE, we will\n+            \/\/       cover the concept of mutability in an example further down.\n+            \"\"\"\n+            System.out.println(\"Status: #ints ints, #longs longs.\");\n+            \"\"\"\n+        ));\n+\n+        \/\/ Definition of the main method body.\n+        var templateMain = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Starting inside main...\");\n+            \"\"\",\n+            \/\/ Check the initial status, there should be nothing available.\n+            templateStatus.asToken(),\n+            \/\/ Define some local variables. We place them at the beginning of\n+            \/\/ the method, by using the METHOD_HOOK.\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.asToken(myInt)),\n+            Hooks.METHOD_HOOK.insert(templateLocalVariable.asToken(myLong)),\n+            \/\/ Define some static fields. We place them at the top of the class,\n+            \/\/ by using the CLASS_HOOK.\n+            Hooks.CLASS_HOOK.insert(templateStaticField.asToken(myInt)),\n+            Hooks.CLASS_HOOK.insert(templateStaticField.asToken(myLong)),\n+            \/\/ If we check the status now, we should see two int and two\n+            \/\/ long names, corresponding to our two fields and variables.\n+            templateStatus.asToken(),\n+            \/\/ Now, we sample 5 int and 5 long names. We should get a mix\n+            \/\/ of fields and variables. We have access to the fields because\n+            \/\/ we inserted them to the class scope. We have access to the\n+            \/\/ variables because we inserted them to the current method\n+            \/\/ body.\n+            Collections.nCopies(5, templateSample.asToken(myInt)),\n+            Collections.nCopies(5, templateSample.asToken(myLong)),\n+            \/\/ The status should not have changed since we last checked.\n+            templateStatus.asToken(),\n+            \"\"\"\n+            System.out.println(\"Finishing inside main.\");\n+            \"\"\"\n+        ));\n+\n+        \/\/ Definition of another method's body. It is in the same class\n+        \/\/ as the main method, so it has access to the same static fields.\n+        var templateOther = Template.make(() -> body(\n+            \"\"\"\n+            System.out.println(\"Starting inside other...\");\n+            \"\"\",\n+            \/\/ We should see the fields defined in the main body,\n+            \/\/ one int and one long field.\n+            templateStatus.asToken(),\n+            \/\/ Sampling 5 random int and 5 random long DataNames. We should\n+            \/\/ only see the fields, and not the local variables from main.\n+            Collections.nCopies(5, templateSample.asToken(myInt)),\n+            Collections.nCopies(5, templateSample.asToken(myLong)),\n+            \/\/ The status should not have changed since we last checked.\n+            templateStatus.asToken(),\n+            \"\"\"\n+            System.out.println(\"Finishing inside other.\");\n+            \"\"\"\n+        ));\n+\n+        \/\/ Finally, we put it all together in a class.\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest8 {\n+            \"\"\",\n+            \/\/ Class Hook for fields.\n+            Hooks.CLASS_HOOK.anchor(\n+                \"\"\"\n+                public static void main() {\n+                \"\"\",\n+                \/\/ Method Hook for local variables.\n+                Hooks.METHOD_HOOK.anchor(\n+                    \"\"\"\n+                    \/\/ This is the beginning of the \"main\" method body.\n+                    System.out.println(\"Welcome to main!\");\n+                    \"\"\",\n+                    templateMain.asToken(),\n+                    \"\"\"\n+                    System.out.println(\"Going to call other...\");\n+                    other();\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+\n+                private static void other() {\n+                \"\"\",\n+                \/\/ Have a separate method hook for other, where it could insert\n+                \/\/ its own local variables (but happens not to).\n+                Hooks.METHOD_HOOK.anchor(\n+                    \"\"\"\n+                    System.out.println(\"Welcome to other!\");\n+                    \"\"\",\n+                    templateOther.asToken(),\n+                    \"\"\"\n+                    System.out.println(\"Done with other.\");\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                }\n+                \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ Let us have a closer look at how DataNames interact with scopes created by\n+    \/\/ Templates and Hooks. Additionally, we see how the execution order of the\n+    \/\/ lambdas and token evaluation affects the availability of DataNames.\n+    \/\/\n+    \/\/ We inject the results directly into verification inside the code, so it\n+    \/\/ is relatively simple to see what the expected results are.\n+    \/\/\n+    \/\/ For simplicity, we define a simple \"list\" function. It collects all\n+    \/\/ field and variable names, and immediately returns the comma separated\n+    \/\/ list of the names. We can use that to visualize the available names\n+    \/\/ at any point.\n+    public static String listNames() {\n+        return \"{\" + String.join(\", \", dataNames(MUTABLE).exactOf(myInt).toList()\n+                                       .stream().map(DataName::name).toList()) + \"}\";\n+    }\n+\n+    \/\/ Even simpler: count the available variables and return the count immediately.\n+    public static int countNames() {\n+        return dataNames(MUTABLE).exactOf(myInt).count();\n+    }\n+\n+    \/\/ Having defined these helper methods, let us start with the first example.\n+    \/\/ You should start reading this example bottom-up, starting at\n+    \/\/ templateClass, then going to templateMain and last to templateInner.\n+    public static String generateWithDataNamesAndScopes1() {\n+\n+        var templateInner = Template.make(() -> body(\n+            \/\/ We just got called from the templateMain. All tokens from there\n+            \/\/ are already evaluated, so \"v1\" is now available:\n+            let(\"l1\", listNames()),\n+            \"\"\"\n+            if (!\"{v1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{v1}' but was '#l1'\"); }\n+            \"\"\"\n+        ));\n+\n+        var templateMain = Template.make(() -> body(\n+            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n+            let(\"c1\", countNames()),\n+            \"\"\"\n+            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n+            \"\"\",\n+            \/\/ We now add a local variable \"v1\" to the scope of this templateMain.\n+            \/\/ This only generates a token, and does not immediately add the name.\n+            \/\/ The name is only added once we evaluate the tokens, and arrive at\n+            \/\/ this particular token.\n+            addDataName(\"v1\", myInt, MUTABLE),\n+            \/\/ We count again with \"c2\". The variable \"v1\" is at this point still\n+            \/\/ in token form, hence it is not yet made available while executing\n+            \/\/ the template lambda of templateMain.\n+            let(\"c2\", countNames()),\n+            \"\"\"\n+            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n+            \"\"\",\n+            \/\/ But now we call an inner Template. This is added as a TemplateToken.\n+            \/\/ This means it is not evaluated immediately, but only once we evaluate\n+            \/\/ the tokens. By that time, all tokens from above are already evaluated\n+            \/\/ and we see that \"v1\" is available.\n+            templateInner.asToken()\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest9a {\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+                public static void main() {\n+            \"\"\",\n+                Hooks.METHOD_HOOK.anchor(\n+                    templateMain.asToken()\n+                ),\n+            \"\"\"\n+                }\n+            \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+    \/\/ Now that we understand this simple example, we go to a more complicated one\n+    \/\/ where we use Hook.insert. Just as above, you should read this example\n+    \/\/ bottom-up, starting at templateClass.\n+    public static String generateWithDataNamesAndScopes2() {\n+\n+        var templateFields = Template.make(() -> body(\n+            \/\/ We were just called from templateMain. But the code is not\n+            \/\/ generated into the main scope, rather into the class scope\n+            \/\/ out in templateClass.\n+            \/\/ Let us now add a field \"f1\".\n+            addDataName(\"f1\", myInt, MUTABLE),\n+            \/\/ And let's also generate the code for it.\n+            \"\"\"\n+            public static int f1 = 42;\n+            \"\"\",\n+            \/\/ But why is this DataName now available inside the scope of\n+            \/\/ templateInner? Does that not mean that \"f1\" escapes this\n+            \/\/ templateFields here? Yes it does!\n+            \/\/ For normal template nesting, the names do not escape the\n+            \/\/ scope of the nested template. But this here is no normal\n+            \/\/ template nesting, rather it is an insertion into a Hook,\n+            \/\/ and we treat those differently. We make the scope of the\n+            \/\/ inserted templateFields transparent, so that any added\n+            \/\/ DataNames are added to the scope of the Hook we just\n+            \/\/ inserted into, i.e. the CLASS_HOOK. This is very important,\n+            \/\/ if we did not make that scope transparent, we could not\n+            \/\/ add any DataNames to the class scope anymore, and we could\n+            \/\/ not add any fields that would be available in the class\n+            \/\/ scope.\n+            Hooks.METHOD_HOOK.anchor(\n+                \/\/ We now create a separate scope. This one is not the\n+                \/\/ template scope from above, and it is not transparent.\n+                \/\/ Hence, \"f2\" will not be available outside of this\n+                \/\/ scope.\n+                addDataName(\"f2\", myInt, MUTABLE),\n+                \/\/ And let's also generate the code for it.\n+                \"\"\"\n+                public static int f2 = 666;\n+                \"\"\"\n+                \/\/ Similarly, if we called any nested Template here,\n+                \/\/ and added DataNames inside, this would happen inside\n+                \/\/ nested scopes that are not transparent. If one wanted\n+                \/\/ to add names to the CLASS_HOOK from there, one would\n+                \/\/ have to do another Hook.insert, and make sure that\n+                \/\/ the names are added from the outermost scope of that\n+                \/\/ inserted Template, because only that outermost scope\n+                \/\/ is transparent to the CLASS_HOOK.\n+            )\n+        ));\n+\n+        var templateInner = Template.make(() -> body(\n+            \/\/ We just got called from the templateMain. All tokens from there\n+            \/\/ are already evaluated, so there should be some fields available.\n+            \/\/ We can see field \"f1\".\n+            let(\"l1\", listNames()),\n+            \"\"\"\n+            if (!\"{f1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{f1}' but was '#l1'\"); }\n+            \"\"\"\n+            \/\/ Now go and have a look at templateFields, to understand how that\n+            \/\/ field was added, and why not any others.\n+        ));\n+\n+        var templateMain = Template.make(() -> body(\n+            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n+            let(\"c1\", countNames()),\n+            \"\"\"\n+            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n+            \"\"\",\n+            \/\/ We would now like to add some fields to the class scope, out in the\n+            \/\/ templateClass. This creates a token, which is only evaluated after\n+            \/\/ the completion of the templateMain lambda. Before you go and look\n+            \/\/ at templateFields, just assume that it does add some fields, and\n+            \/\/ continue reading in templateMain.\n+            Hooks.CLASS_HOOK.insert(templateFields.asToken()),\n+            \/\/ We count again with \"c2\". The fields we wanted to add above are not\n+            \/\/ yet available, because the token is not yet evaluated. Hence, we\n+            \/\/ still only count zero names.\n+            let(\"c2\", countNames()),\n+            \"\"\"\n+            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n+            \"\"\",\n+            \/\/ Now we call an inner Template. This also creates a token, and so it\n+            \/\/ is not evaluated immediately. And by the time this token is evaluated\n+            \/\/ the tokens from above are already evaluated, and so the fields should\n+            \/\/ be available. Go have a look at templateInner now.\n+            templateInner.asToken()\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest9b {\n+            \"\"\",\n+            Hooks.CLASS_HOOK.anchor(\n+            \"\"\"\n+                public static void main() {\n+            \"\"\",\n+                Hooks.METHOD_HOOK.anchor(\n+                    templateMain.asToken()\n+                ),\n+            \"\"\"\n+                }\n+            \"\"\"\n+            ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n+\n+    \/\/ There are two more concepts to understand more deeply with DataNames.\n+    \/\/\n+    \/\/ One is the use of mutable and immutable DataNames.\n+    \/\/ In some cases, we only want to sample DataNames that are mutable, because\n+    \/\/ we want to store to a field or variable. We have to make sure that we\n+    \/\/ do not generate code that tries to store to a final field or variable.\n+    \/\/ In other cases, we only want to load, and we do not care if the\n+    \/\/ fields or variables are final or non-final.\n+    \/\/\n+    \/\/ Another concept is subtyping of DataName Types. With primitive types, this\n+    \/\/ is irrelevant, but with instances of Objects, this becomes relevant.\n+    \/\/ We may want to load an object of any field or variable of a certain\n+    \/\/ class, or any subclass. When a value is of a given class, we can only\n+    \/\/ store it to fields and variables of that class or any superclass.\n+    \/\/\n+    \/\/ Let us look at an example that demonstrates these two concepts.\n+    \/\/\n+    \/\/ First, we define a DataName Type that represents different classes, that\n+    \/\/ may or may not be in a subtype relation. Subtypes start with the name\n+    \/\/ of the super type.\n+    private record MyClass(String name) implements DataName.Type {\n+        @Override\n+        public boolean isSubtypeOf(DataName.Type other) {\n+            return other instanceof MyClass(String n) && name().startsWith(n);\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyClass myClassA   = new MyClass(\"MyClassA\");\n+    private static final MyClass myClassA1  = new MyClass(\"MyClassA1\");\n+    private static final MyClass myClassA2  = new MyClass(\"MyClassA2\");\n+    private static final MyClass myClassA11 = new MyClass(\"MyClassA11\");\n+    private static final MyClass myClassB   = new MyClass(\"MyClassB\");\n+    private static final List<MyClass> myClassList = List.of(myClassA, myClassA1, myClassA2, myClassA11, myClassB);\n+\n+    public static String generateWithDataNamesForFuzzing() {\n+        var templateStaticField = Template.make(\"type\", \"mutable\", (DataName.Type type, Boolean mutable) -> body(\n+            addDataName($(\"field\"), type, mutable ? MUTABLE : IMMUTABLE),\n+            let(\"isFinal\", mutable ? \"\" : \"final\"),\n+            \"\"\"\n+            public static #isFinal #type $field = new #type();\n+            \"\"\"\n+        ));\n+\n+        var templateLoad = Template.make(\"type\", (DataName.Type type) -> body(\n+            \/\/ We only load from the field, so we do not need a mutable one,\n+            \/\/ we can load from final and non-final fields.\n+            \/\/ We want to find any field from which we can read the value and store\n+            \/\/ it in our variable v of our given type. Hence, we can take a field\n+            \/\/ of the given type or any subtype thereof.\n+            let(\"field\", dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(type).sample().name()),\n+            \"\"\"\n+            #type $v = #field;\n+            System.out.println(\"#field: \" + $v);\n+            \"\"\"\n+        ));\n+\n+        var templateStore = Template.make(\"type\", (DataName.Type type) -> body(\n+            \/\/ We are storing to a field, so it better be non-final, i.e. mutable.\n+            \/\/ We want to store a new instance of our given type to a field. This\n+            \/\/ field must be of the given type or any supertype.\n+            let(\"field\", dataNames(MUTABLE).supertypeOf(type).sample().name()),\n+            \"\"\"\n+            #field = new #type();\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest10 {\n+                \/\/ First, we define our classes.\n+                public static class MyClassA {}\n+                public static class MyClassA1 extends MyClassA {}\n+                public static class MyClassA2 extends MyClassA {}\n+                public static class MyClassA11 extends MyClassA1 {}\n+                public static class MyClassB {}\n+\n+                \/\/ Now, we define a list of static fields. Some of them are final, others not.\n+                \"\"\",\n+                \/\/ We must create a CLASS_HOOK and insert the fields to it. Otherwise,\n+                \/\/ addDataName is restricted to the scope of the templateStaticField. But\n+                \/\/ with the insertion to CLASS_HOOK, the addDataName goes through the scope\n+                \/\/ of the templateStaticField out to the scope of the CLASS_HOOK.\n+                Hooks.CLASS_HOOK.anchor(\n+                    myClassList.stream().map(c ->\n+                        (Object)Hooks.CLASS_HOOK.insert(templateStaticField.asToken(c, true))\n+                    ).toList(),\n+                    myClassList.stream().map(c ->\n+                        (Object)Hooks.CLASS_HOOK.insert(templateStaticField.asToken(c, false))\n+                    ).toList(),\n+                    \"\"\"\n+\n+                    public static void main() {\n+                        \/\/ All fields are still in their initial state.\n+                        \"\"\",\n+                        myClassList.stream().map(templateLoad::asToken).toList(),\n+                        \"\"\"\n+                        \/\/ Now let us mutate some fields.\n+                        \"\"\",\n+                        myClassList.stream().map(templateStore::asToken).toList(),\n+                        \"\"\"\n+                        \/\/ And now some fields are different than before.\n+                        \"\"\",\n+                        myClassList.stream().map(templateLoad::asToken).toList(),\n+                        \"\"\"\n+                    }\n+                    \"\"\"\n+                ),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+\n+    }\n+\n+    \/\/ \"DataNames\" are useful for modeling fields and variables. They hold data,\n+    \/\/ and we can read and write to them, they may be mutable or immutable.\n+    \/\/ We now introduce another set of \"Names\", the \"StructuralNames\". They are\n+    \/\/ useful for modeling method names and class names, and possibly more. Anything\n+    \/\/ that has a fixed name in the Java code, for which mutability is inapplicable.\n+    \/\/ Some use-cases for \"StructuralNames\":\n+    \/\/ - Method names. The Type could represent the signature of the static method\n+    \/\/                 or the class of the non-static method.\n+    \/\/ - Class names. Type could represent the signature of the constructor, so\n+    \/\/                that we could instantiate random instances.\n+    \/\/ - try\/catch blocks. If a specific Exception is caught in the scope, we could\n+    \/\/                     register that Exception, and in the inner scope we can\n+    \/\/                     check if there is any \"StructuralName\" for an Exception\n+    \/\/                     and its subtypes - if so, we know the exception would be\n+    \/\/                     caught.\n+    \/\/\n+    \/\/ Let us look at an example with Method names. But for simplicity, we assume they\n+    \/\/ all have the same signature: they take two int arguments and return an int.\n+    \/\/\n+    \/\/ Should you ever work on a test where there are methods with different signatures,\n+    \/\/ then you would have to very carefully study and design the subtype relation between\n+    \/\/ methods. You may want to read up about covariance and contravariance. This\n+    \/\/ example ignores all of that, because we only have \"(II)I\" methods.\n+    private record MyMethodType() implements StructuralName.Type {\n+        @Override\n+        public boolean isSubtypeOf(StructuralName.Type other) {\n+            return other instanceof MyMethodType();\n+        }\n+\n+        @Override\n+        public String name() { return \"<not used, don't worry>\"; }\n+    }\n+    private static final MyMethodType myMethodType = new MyMethodType();\n+\n+    public static String generateWithStructuralNamesForMethods() {\n+        \/\/ Define a method, which takes two ints, returns the result of op.\n+        var templateMethod = Template.make(\"op\", (String op) -> body(\n+            \/\/ Register the method name, so we can later sample.\n+            addStructuralName($(\"methodName\"), myMethodType),\n+            \"\"\"\n+            public static int $methodName(int a, int b) {\n+                return a #op b;\n+            }\n+            \"\"\"\n+        ));\n+\n+        var templateSample = Template.make(() -> body(\n+            \/\/ Sample a random method, and retrieve its name.\n+            let(\"methodName\", structuralNames().exactOf(myMethodType).sample().name()),\n+            \"\"\"\n+            System.out.println(\"Calling #methodName with inputs 7 and 11\");\n+            System.out.println(\"  result: \" + #methodName(7, 11));\n+            \"\"\"\n+        ));\n+\n+        var templateClass = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest11 {\n+                \/\/ Let us define some methods that we can sample from later.\n+            \"\"\",\n+            \/\/ We must anchor a CLASS_HOOK here, and insert the method definitions to that hook.\n+            Hooks.CLASS_HOOK.anchor(\n+                \/\/ If we directly nest the templateMethod, then the addStructuralName goes to the nested\n+                \/\/ scope, and is not available at the class scope, i.e. it is not visible\n+                \/\/ for sampleStructuralName outside of the templateMethod.\n+                \/\/ DO NOT DO THIS, the nested addStructuralName will not be visible:\n+                \"\/\/ We cannot sample from the following methods:\\n\",\n+                templateMethod.asToken(\"+\"),\n+                templateMethod.asToken(\"-\"),\n+                \/\/ However, if we insert to the CLASS_HOOK, then the Renderer makes the\n+                \/\/ scope of the inserted templateMethod transparent, and the addStructuralName\n+                \/\/ goes out to the scope of the CLASS_HOOK (but no further than that).\n+                \/\/ RATHER, DO THIS to ensure the addStructuralName is visible:\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"*\")),\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"|\")),\n+                Hooks.CLASS_HOOK.insert(templateMethod.asToken(\"&\")),\n+                \"\"\"\n+\n+                    public static void main() {\n+                        \/\/ Now, we call some random methods, but only those that were inserted\n+                        \/\/ to the CLASS_HOOK.\n+                        \"\"\",\n+                        Collections.nCopies(10, templateSample.asToken()),\n+                        \"\"\"\n+                    }\n+                }\n+                \"\"\"\n+            )\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":1227,"deletions":0,"binary":false,"changes":1227,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestFrameworkClass.TEMPLATE which allows generating many tests and running them with the IR TestFramework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver template_framework.examples.TestWithTestFrameworkClass\n+ *\/\n+\n+package template_framework.examples;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+\n+import compiler.lib.generators.Generators;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+import compiler.lib.template_framework.library.Hooks;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+\/**\n+ * This is a basic IR verification test, in combination with Generators for random input generation\n+ * and Verify for output verification.\n+ * <p>\n+ * The \"@compile\" command for JTREG is required so that the frameworks used in the Template code\n+ * are compiled and available for the Test-VM.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class TestWithTestFrameworkClass {\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ p.xyz.InnterTest.main(new String[] {});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {}});\n+\n+        \/\/ We can also pass VM flags for the Test VM.\n+        \/\/ p.xyz.InnterTest.main(new String[] {\"-Xbatch\"});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {\"-Xbatch\"}});\n+    }\n+\n+    \/\/ Generate a source Java file as String\n+    public static String generate(CompileFramework comp) {\n+        \/\/ A simple template that adds a comment.\n+        var commentTemplate = Template.make(() -> body(\n+            \"\"\"\n+            \/\/ Comment inserted from test method to class hook.\n+            \"\"\"\n+        ));\n+\n+        \/\/ We define a Test-Template:\n+        \/\/ - static fields for inputs: INPUT_A and INPUT_B\n+        \/\/   - Data generated with Generators and hashtag replacement #con1.\n+        \/\/ - GOLD value precomputed with dedicated call to test.\n+        \/\/   - This ensures that the GOLD value is computed in the interpreter\n+        \/\/     most likely, since the test method is not yet compiled.\n+        \/\/     This allows us later to compare to the results of the compiled\n+        \/\/     code.\n+        \/\/     The input data is cloned, so that the original INPUT_A is never\n+        \/\/     modified and can serve as identical input in later calls to test.\n+        \/\/ - In the Setup method, we clone the input data, since the input data\n+        \/\/   could be modified inside the test method.\n+        \/\/ - The test method makes use of hashtag replacements (#con2 and #op).\n+        \/\/ - The Check method verifies the results of the test method with the\n+        \/\/   GOLD value.\n+        var testTemplate = Template.make(\"op\", (String op) -> body(\n+            let(\"size\", Generators.G.safeRestrict(Generators.G.ints(), 10_000, 20_000).next()),\n+            let(\"con1\", Generators.G.ints().next()),\n+            let(\"con2\", Generators.G.safeRestrict(Generators.G.ints(), 1, Integer.MAX_VALUE).next()),\n+            \"\"\"\n+            \/\/ --- $test start ---\n+            \/\/ $test with size=#size and op=#op\n+            private static int[] $INPUT_A = new int[#size];\n+            static {\n+                Generators.G.fill(Generators.G.ints(), $INPUT_A);\n+            }\n+            private static int $INPUT_B = #con1;\n+            private static Object $GOLD = $test($INPUT_A.clone(), $INPUT_B);\n+\n+            @Setup\n+            public static Object[] $setup() {\n+                \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+                return new Object[] {$INPUT_A.clone(), $INPUT_B};\n+            }\n+\n+            @Test\n+            @Arguments(setup = \"$setup\")\n+            public static Object $test(int[] a, int b) {\n+                for (int i = 0; i < a.length; i++) {\n+                    int con = #con2;\n+                    a[i] = (a[i] * con) #op b;\n+                }\n+                return a;\n+            }\n+\n+            @Check(test = \"$test\")\n+            public static void $check(Object result) {\n+                Verify.checkEQ(result, $GOLD);\n+            }\n+            \/\/ --- $test end   ---\n+            \"\"\",\n+            \/\/ Good to know: we can insert to the class hook, which is set for the\n+            \/\/ TestFrameworkClass scope:\n+            Hooks.CLASS_HOOK.insert(commentTemplate.asToken())\n+        ));\n+\n+        \/\/ Create a test for each operator.\n+        List<String> ops = List.of(\"+\", \"-\", \"*\", \"&\", \"|\");\n+        List<TemplateToken> testTemplateTokens = ops.stream().map(testTemplate::asToken).toList();\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"p.xyz\", \"InnerTest\",\n+            \/\/ Set of imports.\n+            Set.of(\"compiler.lib.generators.*\",\n+                   \"compiler.lib.verify.*\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestWithTestFrameworkClass.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test formatting of Integer, Long, Float and Double.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.tests.TestFormat\n+ *\/\n+\n+package template_framework.tests;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.template_framework.Template;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+\n+public class TestFormat {\n+    record FormatInfo(int id, String type, Object value) {}\n+\n+    public static void main(String[] args) {\n+        List<FormatInfo> list = new ArrayList<>();\n+\n+        for (int i = 0; i < 1000; i++) {\n+            int v = Generators.G.ints().next();\n+            list.add(new FormatInfo(i, \"int\", v));\n+        }\n+\n+        for (int i = 1000; i < 2000; i++) {\n+            long v = Generators.G.longs().next();\n+            list.add(new FormatInfo(i, \"long\", v));\n+        }\n+\n+        for (int i = 2000; i < 3000; i++) {\n+            float v = Generators.G.floats().next();\n+            list.add(new FormatInfo(i, \"float\", v));\n+        }\n+\n+        for (int i = 3000; i < 4000; i++) {\n+            double v = Generators.G.doubles().next();\n+            list.add(new FormatInfo(i, \"double\", v));\n+        }\n+\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest\", generate(list));\n+        comp.compile();\n+\n+        \/\/ Run each of the \"get\" methods, and check the result.\n+        for (FormatInfo info : list) {\n+            Object ret1 = comp.invoke(\"p.xyz.InnerTest\", \"get_let_\" + info.id, new Object[] {});\n+            Object ret2 = comp.invoke(\"p.xyz.InnerTest\", \"get_token_\" + info.id, new Object[] {});\n+            System.out.println(\"id: \" + info.id + \" -> \" + info.value + \" == \" + ret1 + \" == \" + ret2);\n+            Verify.checkEQ(ret1, info.value);\n+            Verify.checkEQ(ret2, info.value);\n+        }\n+    }\n+\n+    private static String generate(List<FormatInfo> list) {\n+        \/\/ Generate 2 \"get\" methods, one that formats via \"let\" (hashtag), the other via direct token.\n+        var template1 = Template.make(\"info\", (FormatInfo info) -> body(\n+            let(\"id\", info.id()),\n+            let(\"type\", info.type()),\n+            let(\"value\", info.value()),\n+            \"\"\"\n+            public static #type get_let_#id() { return #value; }\n+            \"\"\",\n+            \"public static #type get_token_#id() { return \", info.value(), \"; }\\n\"\n+        ));\n+\n+        \/\/ For each FormatInfo in list, generate the \"get\" methods inside InnerTest class.\n+        var template2 = Template.make(() -> body(\n+            \"\"\"\n+            package p.xyz;\n+            public class InnerTest {\n+            \"\"\",\n+            list.stream().map(info -> template1.asToken(info)).toList(),\n+            \"\"\"\n+            }\n+            \"\"\"\n+        ));\n+\n+        return template2.render();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestFormat.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,2253 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344942\n+ * @summary Test some basic Template instantiations. We do not necessarily generate correct\n+ *          java code, we just test that the code generation deterministically creates the\n+ *          expected String.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main template_framework.tests.TestTemplate\n+ *\/\n+\n+package template_framework.tests;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.HashSet;\n+\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.DataName;\n+import compiler.lib.template_framework.StructuralName;\n+import compiler.lib.template_framework.Hook;\n+import compiler.lib.template_framework.TemplateBinding;\n+import compiler.lib.template_framework.RendererException;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.$;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.fuel;\n+import static compiler.lib.template_framework.Template.setFuelCost;\n+import static compiler.lib.template_framework.Template.addDataName;\n+import static compiler.lib.template_framework.Template.dataNames;\n+import static compiler.lib.template_framework.Template.addStructuralName;\n+import static compiler.lib.template_framework.Template.structuralNames;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.IMMUTABLE;\n+import static compiler.lib.template_framework.DataName.Mutability.MUTABLE_OR_IMMUTABLE;\n+\n+\/**\n+ * The tests in this file are mostly there to ensure that the Template Rendering\n+ * works correctly, and not that we produce compilable Java code. Rather, we\n+ * produce deterministic output, and compare it to the expected String.\n+ * Still, this file may be helpful for learning more about how Templates\n+ * work and can be used.\n+ *\n+ * We assume that you have already studied {@code TestTutorial.java}.\n+ *\/\n+public class TestTemplate {\n+    \/\/ Interface for failing tests.\n+    interface FailingTest {\n+        void run();\n+    }\n+\n+    \/\/ Define a simple type to model primitive types.\n+    private record MyPrimitive(String name) implements DataName.Type {\n+        @Override\n+        public boolean isSubtypeOf(DataName.Type other) {\n+            return other instanceof MyPrimitive(String n) && n.equals(name());\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyPrimitive myInt = new MyPrimitive(\"int\");\n+    private static final MyPrimitive myLong = new MyPrimitive(\"long\");\n+\n+    \/\/ Simulate classes. Subtypes start with the name of the super type.\n+    private record MyClass(String name) implements DataName.Type {\n+        @Override\n+        public boolean isSubtypeOf(DataName.Type other) {\n+            return other instanceof MyClass(String n) && name().startsWith(n);\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyClass myClassA   = new MyClass(\"myClassA\");\n+    private static final MyClass myClassA1  = new MyClass(\"myClassA1\");\n+    private static final MyClass myClassA2  = new MyClass(\"myClassA2\");\n+    private static final MyClass myClassA11 = new MyClass(\"myClassA11\");\n+    private static final MyClass myClassB   = new MyClass(\"myClassB\");\n+\n+    \/\/ Simulate some structural types.\n+    private record MyStructuralType(String name) implements StructuralName.Type {\n+        @Override\n+        public boolean isSubtypeOf(StructuralName.Type other) {\n+            return other instanceof MyStructuralType(String n) && name().startsWith(n);\n+        }\n+\n+        @Override\n+        public String toString() { return name(); }\n+    }\n+    private static final MyStructuralType myStructuralTypeA = new MyStructuralType(\"StructuralA\");\n+    private static final MyStructuralType myStructuralTypeA1 = new MyStructuralType(\"StructuralA1\");\n+    private static final MyStructuralType myStructuralTypeA2 = new MyStructuralType(\"StructuralA2\");\n+    private static final MyStructuralType myStructuralTypeA11 = new MyStructuralType(\"StructuralA11\");\n+    private static final MyStructuralType myStructuralTypeB = new MyStructuralType(\"StructuralB\");\n+\n+    public static void main(String[] args) {\n+        \/\/ The following tests all pass, i.e. have no errors during rendering.\n+        testSingleLine();\n+        testMultiLine();\n+        testBodyTokens();\n+        testWithOneArgument();\n+        testWithTwoArguments();\n+        testWithThreeArguments();\n+        testNested();\n+        testHookSimple();\n+        testHookIsAnchored();\n+        testHookNested();\n+        testHookWithNestedTemplates();\n+        testHookRecursion();\n+        testDollar();\n+        testLet();\n+        testDollarAndHashtagBrackets();\n+        testSelector();\n+        testRecursion();\n+        testFuel();\n+        testFuelCustom();\n+        testDataNames1();\n+        testDataNames2();\n+        testDataNames3();\n+        testDataNames4();\n+        testDataNames5();\n+        testStructuralNames1();\n+        testStructuralNames2();\n+        testListArgument();\n+\n+        \/\/ The following tests should all fail, with an expected exception and message.\n+        expectRendererException(() -> testFailingNestedRendering(), \"Nested render not allowed.\");\n+        expectRendererException(() -> $(\"name\"),                          \"A Template method such as\");\n+        expectRendererException(() -> let(\"x\",\"y\"),                       \"A Template method such as\");\n+        expectRendererException(() -> fuel(),                             \"A Template method such as\");\n+        expectRendererException(() -> setFuelCost(1.0f),                  \"A Template method such as\");\n+        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),  \"A Template method such as\");\n+        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).sample(), \"A Template method such as\");\n+        expectRendererException(() -> (new Hook(\"abc\")).isAnchored(),     \"A Template method such as\");\n+        expectRendererException(() -> testFailingDollarName1(), \"Is not a valid '$' name: ''.\");\n+        expectRendererException(() -> testFailingDollarName2(), \"Is not a valid '$' name: '#abc'.\");\n+        expectRendererException(() -> testFailingDollarName3(), \"Is not a valid '$' name: 'abc#'.\");\n+        expectRendererException(() -> testFailingDollarName4(), \"A '$' name should not be null.\");\n+        expectRendererException(() -> testFailingDollarName5(), \"Is not a valid '$' replacement pattern: '$' in '$'.\");\n+        expectRendererException(() -> testFailingDollarName6(), \"Is not a valid '$' replacement pattern: '$' in 'asdf$'.\");\n+        expectRendererException(() -> testFailingDollarName7(), \"Is not a valid '$' replacement pattern: '$1' in 'asdf$1'.\");\n+        expectRendererException(() -> testFailingDollarName8(), \"Is not a valid '$' replacement pattern: '$' in 'abc$$abc'.\");\n+        expectRendererException(() -> testFailingLetName1(), \"A hashtag replacement should not be null.\");\n+        expectRendererException(() -> testFailingHashtagName1(), \"Is not a valid hashtag replacement name: ''.\");\n+        expectRendererException(() -> testFailingHashtagName2(), \"Is not a valid hashtag replacement name: 'abc#abc'.\");\n+        expectRendererException(() -> testFailingHashtagName3(), \"Is not a valid hashtag replacement name: ''.\");\n+        expectRendererException(() -> testFailingHashtagName4(), \"Is not a valid hashtag replacement name: 'xyz#xyz'.\");\n+        expectRendererException(() -> testFailingHashtagName5(), \"Is not a valid '#' replacement pattern: '#' in '#'.\");\n+        expectRendererException(() -> testFailingHashtagName6(), \"Is not a valid '#' replacement pattern: '#' in 'asdf#'.\");\n+        expectRendererException(() -> testFailingHashtagName7(), \"Is not a valid '#' replacement pattern: '#1' in 'asdf#1'.\");\n+        expectRendererException(() -> testFailingHashtagName8(), \"Is not a valid '#' replacement pattern: '#' in 'abc##abc'.\");\n+        expectRendererException(() -> testFailingDollarHashtagName1(), \"Is not a valid '#' replacement pattern: '#' in '#$'.\");\n+        expectRendererException(() -> testFailingDollarHashtagName2(), \"Is not a valid '$' replacement pattern: '$' in '$#'.\");\n+        expectRendererException(() -> testFailingDollarHashtagName3(), \"Is not a valid '#' replacement pattern: '#' in '#$name'.\");\n+        expectRendererException(() -> testFailingDollarHashtagName4(), \"Is not a valid '$' replacement pattern: '$' in '$#name'.\");\n+        expectRendererException(() -> testFailingHook(), \"Hook 'Hook1' was referenced but not found!\");\n+        expectRendererException(() -> testFailingSample1(),  \"No variable: MUTABLE, subtypeOf(int), supertypeOf(int).\");\n+        expectRendererException(() -> testFailingHashtag1(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag2(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag3(), \"Duplicate hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingHashtag4(), \"Missing hashtag replacement for #a\");\n+        expectRendererException(() -> testFailingBinding1(), \"Duplicate 'bind' not allowed.\");\n+        expectRendererException(() -> testFailingBinding2(), \"Cannot 'get' before 'bind'.\");\n+        expectIllegalArgumentException(() -> body(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> body(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> body(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        Hook hook1 = new Hook(\"Hook1\");\n+        expectIllegalArgumentException(() -> hook1.anchor(null),      \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> hook1.anchor(\"x\", null), \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> hook1.anchor(hook1),     \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> testFailingAddDataName1(), \"Unexpected mutability: MUTABLE_OR_IMMUTABLE\");\n+        expectIllegalArgumentException(() -> testFailingAddDataName2(), \"Unexpected weight: \");\n+        expectIllegalArgumentException(() -> testFailingAddDataName3(), \"Unexpected weight: \");\n+        expectIllegalArgumentException(() -> testFailingAddDataName4(), \"Unexpected weight: \");\n+        expectIllegalArgumentException(() -> testFailingAddStructuralName1(), \"Unexpected weight: \");\n+        expectIllegalArgumentException(() -> testFailingAddStructuralName2(), \"Unexpected weight: \");\n+        expectIllegalArgumentException(() -> testFailingAddStructuralName3(), \"Unexpected weight: \");\n+        expectUnsupportedOperationException(() -> testFailingSample2(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+        expectRendererException(() -> testFailingAddNameDuplication1(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingAddNameDuplication2(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingAddNameDuplication3(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingAddNameDuplication4(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingAddNameDuplication5(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingAddNameDuplication6(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingAddNameDuplication7(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingAddNameDuplication8(), \"Duplicate name:\");\n+    }\n+\n+    public static void testSingleLine() {\n+        var template = Template.make(() -> body(\"Hello World!\"));\n+        String code = template.render();\n+        checkEQ(code, \"Hello World!\");\n+    }\n+\n+    public static void testMultiLine() {\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            Code on more\n+            than a single line\n+            \"\"\"\n+        ));\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            Code on more\n+            than a single line\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testBodyTokens() {\n+        \/\/ We can fill the body with Objects of different types, and they get concatenated.\n+        \/\/ Lists get flattened into the body.\n+        var template = Template.make(() -> body(\n+            \"start \",\n+            Integer.valueOf(1), 1,\n+            Long.valueOf(2), 2L,\n+            Double.valueOf(3.4), 3.4,\n+            Float.valueOf(5.6f), 5.6f,\n+            List.of(\" \", 1, \" and \", 2),\n+            \" end\"\n+        ));\n+        String code = template.render();\n+        checkEQ(code, \"start 112L2L3.43.45.6f5.6f 1 and 2 end\");\n+    }\n+\n+    public static void testWithOneArgument() {\n+        \/\/ Capture String argument via String name.\n+        var template1 = Template.make(\"a\", (String a) -> body(\"start #a end\"));\n+        checkEQ(template1.render(\"x\"), \"start x end\");\n+        checkEQ(template1.render(\"a\"), \"start a end\");\n+        checkEQ(template1.render(\"\" ), \"start  end\");\n+\n+        \/\/ Capture String argument via typed lambda argument.\n+        var template2 = Template.make(\"a\", (String a) -> body(\"start \", a, \" end\"));\n+        checkEQ(template2.render(\"x\"), \"start x end\");\n+        checkEQ(template2.render(\"a\"), \"start a end\");\n+        checkEQ(template2.render(\"\" ), \"start  end\");\n+\n+        \/\/ Capture Integer argument via String name.\n+        var template3 = Template.make(\"a\", (Integer a) -> body(\"start #a end\"));\n+        checkEQ(template3.render(0  ), \"start 0 end\");\n+        checkEQ(template3.render(22 ), \"start 22 end\");\n+        checkEQ(template3.render(444), \"start 444 end\");\n+\n+        \/\/ Capture Integer argument via templated lambda argument.\n+        var template4 = Template.make(\"a\", (Integer a) -> body(\"start \", a, \" end\"));\n+        checkEQ(template4.render(0  ), \"start 0 end\");\n+        checkEQ(template4.render(22 ), \"start 22 end\");\n+        checkEQ(template4.render(444), \"start 444 end\");\n+\n+        \/\/ Test Strings with backslashes:\n+        var template5 = Template.make(\"a\", (String a) -> body(\"start #a \" + a + \" end\"));\n+        checkEQ(template5.render(\"\/\"), \"start \/ \/ end\");\n+        checkEQ(template5.render(\"\\\\\"), \"start \\\\ \\\\ end\");\n+        checkEQ(template5.render(\"\\\\\\\\\"), \"start \\\\\\\\ \\\\\\\\ end\");\n+    }\n+\n+    public static void testWithTwoArguments() {\n+        \/\/ Capture 2 String arguments via String names.\n+        var template1 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start #a1 #a2 end\"));\n+        checkEQ(template1.render(\"x\", \"y\"), \"start x y end\");\n+        checkEQ(template1.render(\"a\", \"b\"), \"start a b end\");\n+        checkEQ(template1.render(\"\",  \"\" ), \"start   end\");\n+\n+        \/\/ Capture 2 String arguments via typed lambda arguments.\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        checkEQ(template2.render(\"x\", \"y\"), \"start x y end\");\n+        checkEQ(template2.render(\"a\", \"b\"), \"start a b end\");\n+        checkEQ(template2.render(\"\",  \"\" ), \"start   end\");\n+\n+        \/\/ Capture 2 Integer arguments via String names.\n+        var template3 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start #a1 #a2 end\"));\n+        checkEQ(template3.render(0,   1  ), \"start 0 1 end\");\n+        checkEQ(template3.render(22,  33 ), \"start 22 33 end\");\n+        checkEQ(template3.render(444, 555), \"start 444 555 end\");\n+\n+        \/\/ Capture 2 Integer arguments via templated lambda arguments.\n+        var template4 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        checkEQ(template4.render(0,   1  ), \"start 0 1 end\");\n+        checkEQ(template4.render(22,  33 ), \"start 22 33 end\");\n+        checkEQ(template4.render(444, 555), \"start 444 555 end\");\n+    }\n+\n+    public static void testWithThreeArguments() {\n+        \/\/ Capture 3 String arguments via String names.\n+        var template1 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        checkEQ(template1.render(\"x\", \"y\", \"z\"), \"start x y z end\");\n+        checkEQ(template1.render(\"a\", \"b\", \"c\"), \"start a b c end\");\n+        checkEQ(template1.render(\"\",  \"\", \"\" ),  \"start    end\");\n+\n+        \/\/ Capture 3 String arguments via typed lambda arguments.\n+        var template2 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        checkEQ(template1.render(\"x\", \"y\", \"z\"), \"start x y z end\");\n+        checkEQ(template1.render(\"a\", \"b\", \"c\"), \"start a b c end\");\n+        checkEQ(template1.render(\"\",  \"\", \"\" ),  \"start    end\");\n+\n+        \/\/ Capture 3 Integer arguments via String names.\n+        var template3 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        checkEQ(template3.render(0,   1  , 2  ), \"start 0 1 2 end\");\n+        checkEQ(template3.render(22,  33 , 44 ), \"start 22 33 44 end\");\n+        checkEQ(template3.render(444, 555, 666), \"start 444 555 666 end\");\n+\n+        \/\/ Capture 2 Integer arguments via templated lambda arguments.\n+        var template4 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        checkEQ(template3.render(0,   1  , 2  ), \"start 0 1 2 end\");\n+        checkEQ(template3.render(22,  33 , 44 ), \"start 22 33 44 end\");\n+        checkEQ(template3.render(444, 555, 666), \"start 444 555 666 end\");\n+    }\n+\n+    public static void testNested() {\n+        var template1 = Template.make(() -> body(\"proton\"));\n+\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+            \"electron #a1\\n\",\n+            \"neutron #a2\\n\"\n+        ));\n+\n+        var template3 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+            \"Universe \", template1.asToken(), \" {\\n\",\n+                template2.asToken(\"up\", \"down\"),\n+                template2.asToken(a1, a2),\n+            \"}\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            template3.asToken(\"low\", \"high\"),\n+            \"{\\n\",\n+                template3.asToken(\"42\", \"24\"),\n+            \"}\"\n+        ));\n+\n+        String code = template4.render();\n+        String expected =\n+            \"\"\"\n+            Universe proton {\n+            electron up\n+            neutron down\n+            electron low\n+            neutron high\n+            }\n+            {\n+            Universe proton {\n+            electron up\n+            neutron down\n+            electron 42\n+            neutron 24\n+            }\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookSimple() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\"Hello\\n\"));\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            hook1.anchor(\n+                \"World\\n\",\n+                \/\/ Note: \"Hello\" from the template below will be inserted\n+                \/\/ above \"World\" above.\n+                hook1.insert(template1.asToken())\n+            ),\n+            \"}\"\n+        ));\n+\n+        String code = template2.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            Hello\n+            World\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookIsAnchored() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template0 = Template.make(() -> body(\"isAnchored: \", hook1.isAnchored(), \"\\n\"));\n+\n+        var template1 = Template.make(() -> body(\"Hello\\n\", template0.asToken()));\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            template0.asToken(),\n+            hook1.anchor(\n+                \"World\\n\",\n+                template0.asToken(),\n+                hook1.insert(template1.asToken())\n+            ),\n+            template0.asToken(),\n+            \"}\"\n+        ));\n+\n+        String code = template2.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            isAnchored: false\n+            Hello\n+            isAnchored: true\n+            World\n+            isAnchored: true\n+            isAnchored: false\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookNested() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        \/\/ Test nested use of hooks in the same template.\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            hook1.anchor(), \/\/ empty\n+            \"zero\\n\",\n+            hook1.anchor(\n+                template1.asToken(\"one\"),\n+                template1.asToken(\"two\"),\n+                hook1.insert(template1.asToken(\"intoHook1a\")),\n+                hook1.insert(template1.asToken(\"intoHook1b\")),\n+                template1.asToken(\"three\"),\n+                hook1.anchor(\n+                    template1.asToken(\"four\"),\n+                    hook1.insert(template1.asToken(\"intoHook1c\")),\n+                    template1.asToken(\"five\")\n+                ),\n+                template1.asToken(\"six\"),\n+                hook1.anchor(), \/\/ empty\n+                template1.asToken(\"seven\"),\n+                hook1.insert(template1.asToken(\"intoHook1d\")),\n+                template1.asToken(\"eight\"),\n+                hook1.anchor(\n+                    template1.asToken(\"nine\"),\n+                    hook1.insert(template1.asToken(\"intoHook1e\")),\n+                    template1.asToken(\"ten\")\n+                ),\n+                template1.asToken(\"eleven\")\n+            ),\n+            \"}\"\n+        ));\n+\n+        String code = template2.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            zero\n+            x intoHook1a x\n+            x intoHook1b x\n+            x intoHook1d x\n+            x one x\n+            x two x\n+            x three x\n+            x intoHook1c x\n+            x four x\n+            x five x\n+            x six x\n+            x seven x\n+            x eight x\n+            x intoHook1e x\n+            x nine x\n+            x ten x\n+            x eleven x\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookWithNestedTemplates() {\n+        var hook1 = new Hook(\"Hook1\");\n+        var hook2 = new Hook(\"Hook2\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        var template2 = Template.make(\"b\", (String b) -> body(\n+            \"{\\n\",\n+            template1.asToken(b + \"A\"),\n+            hook1.insert(template1.asToken(b + \"B\")),\n+            hook2.insert(template1.asToken(b + \"C\")),\n+            template1.asToken(b + \"D\"),\n+            hook1.anchor(\n+                template1.asToken(b + \"E\"),\n+                hook1.insert(template1.asToken(b + \"F\")),\n+                hook2.insert(template1.asToken(b + \"G\")),\n+                template1.asToken(b + \"H\"),\n+                hook2.anchor(\n+                    template1.asToken(b + \"I\"),\n+                    hook1.insert(template1.asToken(b + \"J\")),\n+                    hook2.insert(template1.asToken(b + \"K\")),\n+                    template1.asToken(b + \"L\")\n+                ),\n+                template1.asToken(b + \"M\"),\n+                hook1.insert(template1.asToken(b + \"N\")),\n+                hook2.insert(template1.asToken(b + \"O\")),\n+                template1.asToken(b + \"O\")\n+            ),\n+            template1.asToken(b + \"P\"),\n+            hook1.insert(template1.asToken(b + \"Q\")),\n+            hook2.insert(template1.asToken(b + \"R\")),\n+            template1.asToken(b + \"S\"),\n+            \"}\\n\"\n+        ));\n+\n+        \/\/ Test use of hooks across templates.\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"base-A\\n\",\n+            hook1.anchor(\n+                \"base-B\\n\",\n+                hook2.anchor(\n+                    \"base-C\\n\",\n+                    template2.asToken(\"sub-\"),\n+                    \"base-D\\n\"\n+                ),\n+                \"base-E\\n\"\n+            ),\n+            \"base-F\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            base-A\n+            x sub-B x\n+            x sub-Q x\n+            base-B\n+            x sub-C x\n+            x sub-G x\n+            x sub-O x\n+            x sub-R x\n+            base-C\n+            {\n+            x sub-A x\n+            x sub-D x\n+            x sub-F x\n+            x sub-J x\n+            x sub-N x\n+            x sub-E x\n+            x sub-H x\n+            x sub-K x\n+            x sub-I x\n+            x sub-L x\n+            x sub-M x\n+            x sub-O x\n+            x sub-P x\n+            x sub-S x\n+            }\n+            base-D\n+            base-E\n+            base-F\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookRecursion() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+\n+        var template2 = Template.make(\"b\", (String b) -> body(\n+            \"<\\n\",\n+            template1.asToken(b + \"A\"),\n+            hook1.insert(template1.asToken(b + \"B\")), \/\/ sub-B is rendered before template2.\n+            template1.asToken(b + \"C\"),\n+            \"inner-hook-start\\n\",\n+            hook1.anchor(\n+                \"inner-hook-end\\n\",\n+                template1.asToken(b + \"E\"),\n+                hook1.insert(template1.asToken(b + \"E\")),\n+                template1.asToken(b + \"F\")\n+            ),\n+            \">\\n\"\n+        ));\n+\n+        \/\/ Test use of hooks across templates.\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"hook-start\\n\",\n+            hook1.anchor(\n+                \"hook-end\\n\",\n+                hook1.insert(template2.asToken(\"sub-\")),\n+                \"base-C\\n\"\n+            ),\n+            \"base-D\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            hook-start\n+            x sub-B x\n+            <\n+            x sub-A x\n+            x sub-C x\n+            inner-hook-start\n+            x sub-E x\n+            inner-hook-end\n+            x sub-E x\n+            x sub-F x\n+            >\n+            hook-end\n+            base-C\n+            base-D\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDollar() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\"x $name #a x\\n\"));\n+\n+        var template2 = Template.make(\"a\", (String a) -> body(\n+            \"{\\n\",\n+            \"y $name #a y\\n\",\n+            template1.asToken($(\"name\")),\n+            \"}\\n\"\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            \"$name\\n\",\n+            \"$name\", \"\\n\",\n+            \"z $name z\\n\",\n+            \"z$name z\\n\",\n+            template1.asToken(\"name\"),     \/\/ does not capture -> literal \"$name\"\n+            template1.asToken(\"$name\"),    \/\/ does not capture -> literal \"$name\"\n+            template1.asToken($(\"name\")),  \/\/ capture replacement name \"name_1\"\n+            hook1.anchor(\n+                \"$name\\n\"\n+            ),\n+            \"break\\n\",\n+            hook1.anchor(\n+                \"one\\n\",\n+                hook1.insert(template1.asToken($(\"name\"))),\n+                \"two\\n\",\n+                template1.asToken($(\"name\")),\n+                \"three\\n\",\n+                hook1.insert(template2.asToken($(\"name\"))),\n+                \"four\\n\"\n+            ),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            name_1\n+            name_1\n+            z name_1 z\n+            zname_1 z\n+            x name_2 name x\n+            x name_3 $name x\n+            x name_4 name_1 x\n+            name_1\n+            break\n+            x name_5 name_1 x\n+            {\n+            y name_7 name_1 y\n+            x name_8 name_7 x\n+            }\n+            one\n+            two\n+            x name_6 name_1 x\n+            three\n+            four\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testLet() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"a\", (String a) -> body(\n+            \"{\\n\",\n+            \"y #a y\\n\",\n+            let(\"b\", \"<\" + a + \">\"),\n+            \"y #b y\\n\",\n+            \"}\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"a\", (Integer a) -> let(\"b\", a * 10, b ->\n+            body(\n+                let(\"c\", b * 3),\n+                \"abc = #a #b #c\\n\"\n+            )\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            let(\"x\", \"abc\"),\n+            template1.asToken(\"alpha\"),\n+            \"break\\n\",\n+            \"x1 = #x\\n\",\n+            hook1.anchor(\n+                \"x2 = #x\\n\", \/\/ leaks inside\n+                template1.asToken(\"beta\"),\n+                let(\"y\", \"one\"),\n+                \"y1 = #y\\n\"\n+            ),\n+            \"break\\n\",\n+            \"y2 = #y\\n\", \/\/ leaks outside\n+            \"break\\n\",\n+            template2.asToken(5),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            {\n+            y alpha y\n+            y <alpha> y\n+            }\n+            break\n+            x1 = abc\n+            x2 = abc\n+            {\n+            y beta y\n+            y <beta> y\n+            }\n+            y1 = one\n+            break\n+            y2 = one\n+            break\n+            abc = 5 50 150\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDollarAndHashtagBrackets() {\n+        var template1 = Template.make(() -> body(\n+            let(\"xyz\", \"abc\"),\n+            let(\"xyz_\", \"def\"),\n+            let(\"xyz_klm\", \"ghi\"),\n+            let(\"klm\", \"jkl\"),\n+            \"\"\"\n+            no bracket: #xyz #xyz_klm #xyz_#klm\n+            no bracket: $var $var_two $var_$two\n+            with bracket: #{xyz} #{xyz_klm} #{xyz}_#{klm}\n+            with bracket: ${var} ${var_two} ${var}_${two}\n+            \"\"\"\n+        ));\n+\n+        String code = template1.render();\n+        String expected =\n+            \"\"\"\n+            no bracket: abc ghi defjkl\n+            no bracket: var_1 var_two_1 var__1two_1\n+            with bracket: abc ghi abc_jkl\n+            with bracket: var_1 var_two_1 var_1_two_1\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testSelector() {\n+        var template1 = Template.make(\"a\", (String a) -> body(\n+            \"<\\n\",\n+            \"x #a x\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"a\", (String a) -> body(\n+            \"<\\n\",\n+            \"y #a y\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template3 = Template.make(\"a\", (Integer a) -> body(\n+            \"[\\n\",\n+            \"z #a z\\n\",\n+            \/\/ Select which template should be used:\n+            a > 0 ? template1.asToken(\"A_\" + a)\n+                  : template2.asToken(\"B_\" + a),\n+            \"]\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"{\\n\",\n+            template3.asToken(-1),\n+            \"break\\n\",\n+            template3.asToken(0),\n+            \"break\\n\",\n+            template3.asToken(1),\n+            \"break\\n\",\n+            template3.asToken(2),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [\n+            z -1 z\n+            <\n+            y B_-1 y\n+            >\n+            ]\n+            break\n+            [\n+            z 0 z\n+            <\n+            y B_0 y\n+            >\n+            ]\n+            break\n+            [\n+            z 1 z\n+            <\n+            x A_1 x\n+            >\n+            ]\n+            break\n+            [\n+            z 2 z\n+            <\n+            x A_2 x\n+            >\n+            ]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testRecursion() {\n+        \/\/ Binding allows use of template1 inside template1, via the Binding indirection.\n+        var binding1 = new TemplateBinding<Template.OneArg<Integer>>();\n+\n+        var template1 = Template.make(\"i\", (Integer i) -> body(\n+            \"[ #i\\n\",\n+            \/\/ We cannot yet use the template1 directly, as it is being defined.\n+            \/\/ So we use binding1 instead.\n+            i < 0 ? \"done\\n\" : binding1.get().asToken(i - 1),\n+            \"] #i\\n\"\n+        ));\n+        binding1.bind(template1);\n+\n+        var template2 = Template.make(() -> body(\n+            \"{\\n\",\n+            \/\/ Now, we can use template1 normally, as it is already defined.\n+            template1.asToken(3),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template2.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [ 3\n+            [ 2\n+            [ 1\n+            [ 0\n+            [ -1\n+            done\n+            ] -1\n+            ] 0\n+            ] 1\n+            ] 2\n+            ] 3\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFuel() {\n+        var template1 = Template.make(() -> body(\n+            let(\"f\", fuel()),\n+\n+            \"<#f>\\n\"\n+        ));\n+\n+        \/\/ Binding allows use of template2 inside template2, via the Binding indirection.\n+        var binding2 = new TemplateBinding<Template.OneArg<Integer>>();\n+        var template2 = Template.make(\"i\", (Integer i) -> body(\n+            let(\"f\", fuel()),\n+\n+            \"[ #i #f\\n\",\n+            template1.asToken(),\n+            fuel() <= 60.f ? \"done\" : binding2.get().asToken(i - 1),\n+            \"] #i #f\\n\"\n+        ));\n+        binding2.bind(template2);\n+\n+        var template3 = Template.make(() -> body(\n+            \"{\\n\",\n+            template2.asToken(3),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template3.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [ 3 90.0f\n+            <80.0f>\n+            [ 2 80.0f\n+            <70.0f>\n+            [ 1 70.0f\n+            <60.0f>\n+            [ 0 60.0f\n+            <50.0f>\n+            done] 0 60.0f\n+            ] 1 70.0f\n+            ] 2 80.0f\n+            ] 3 90.0f\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFuelCustom() {\n+        var template1 = Template.make(() -> body(\n+            setFuelCost(2.0f),\n+            let(\"f\", fuel()),\n+\n+            \"<#f>\\n\"\n+        ));\n+\n+        \/\/ Binding allows use of template2 inside template2, via the Binding indirection.\n+        var binding2 = new TemplateBinding<Template.OneArg<Integer>>();\n+        var template2 = Template.make(\"i\", (Integer i) -> body(\n+            setFuelCost(3.0f),\n+            let(\"f\", fuel()),\n+\n+            \"[ #i #f\\n\",\n+            template1.asToken(),\n+            fuel() <= 5.f ? \"done\\n\" : binding2.get().asToken(i - 1),\n+            \"] #i #f\\n\"\n+        ));\n+        binding2.bind(template2);\n+\n+        var template3 = Template.make(() -> body(\n+            setFuelCost(5.0f),\n+            let(\"f\", fuel()),\n+\n+            \"{ #f\\n\",\n+            template2.asToken(3),\n+            \"} #f\\n\"\n+        ));\n+\n+        String code = template3.render(20.0f);\n+        String expected =\n+            \"\"\"\n+            { 20.0f\n+            [ 3 15.0f\n+            <12.0f>\n+            [ 2 12.0f\n+            <9.0f>\n+            [ 1 9.0f\n+            <6.0f>\n+            [ 0 6.0f\n+            <3.0f>\n+            [ -1 3.0f\n+            <0.0f>\n+            done\n+            ] -1 3.0f\n+            ] 0 6.0f\n+            ] 1 9.0f\n+            ] 2 12.0f\n+            ] 3 15.0f\n+            } 20.0f\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames1() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            \"[\",\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),\n+            \", names: {\",\n+            String.join(\", \", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            \"}]\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n+            addDataName(name, type, MUTABLE),\n+            \"define #type #name\\n\",\n+            template1.asToken()\n+        ));\n+\n+        var template3 = Template.make(() -> body(\n+            \"<\\n\",\n+            hook1.insert(template2.asToken($(\"name\"), myInt)),\n+            \"$name = 5\\n\",\n+            \">\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"{\\n\",\n+            template1.asToken(),\n+            hook1.anchor(\n+                template1.asToken(),\n+                \"something\\n\",\n+                template3.asToken(),\n+                \"more\\n\",\n+                template1.asToken(),\n+                \"more\\n\",\n+                template2.asToken($(\"name\"), myInt),\n+                \"more\\n\",\n+                template1.asToken()\n+            ),\n+            template1.asToken(),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            [false, 0, names: {}]\n+            define int name_4\n+            [true, 1, names: {name_4}]\n+            [false, 0, names: {}]\n+            something\n+            <\n+            name_4 = 5\n+            >\n+            more\n+            [true, 1, names: {name_4}]\n+            more\n+            define int name_1\n+            [true, 2, names: {name_4, name_1}]\n+            more\n+            [true, 1, names: {name_4}]\n+            [false, 0, names: {}]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames2() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+            \"  #mutability: [\",\n+            dataNames(mutability).exactOf(myInt).hasAny(),\n+            \", \",\n+            dataNames(mutability).exactOf(myInt).count(),\n+            \", names: {\",\n+            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            \"}]\\n\"\n+        ));\n+\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"[#type:\\n\",\n+            template0.asToken(type, MUTABLE),\n+            template0.asToken(type, IMMUTABLE),\n+            template0.asToken(type, MUTABLE_OR_IMMUTABLE),\n+            \"]\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n+            addDataName(name, type, MUTABLE),\n+            \"define mutable #type #name\\n\",\n+            template1.asToken(type)\n+        ));\n+\n+        var template3 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n+            addDataName(name, type, IMMUTABLE),\n+            \"define immutable #type #name\\n\",\n+            template1.asToken(type)\n+        ));\n+\n+        var template4 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"{ $store\\n\",\n+            hook1.insert(template2.asToken($(\"name\"), type)),\n+            \"$name = 5\\n\",\n+            \"} $store\\n\"\n+        ));\n+\n+        var template5 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"{ $load\\n\",\n+            hook1.insert(template3.asToken($(\"name\"), type)),\n+            \"blackhole($name)\\n\",\n+            \"} $load\\n\"\n+        ));\n+\n+        var template6 = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"v\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+            \"{ $sample\\n\",\n+            \"#v = 7\\n\",\n+            \"} $sample\\n\"\n+        ));\n+\n+        var template7 = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"v\", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(type).sample().name()),\n+            \"{ $sample\\n\",\n+            \"blackhole(#v)\\n\",\n+            \"} $sample\\n\"\n+        ));\n+\n+        var template8 = Template.make(() -> body(\n+            \"class $X {\\n\",\n+            template1.asToken(myInt),\n+            hook1.anchor(\n+                \"begin $body\\n\",\n+                template1.asToken(myInt),\n+                \"start with immutable\\n\",\n+                template5.asToken(myInt),\n+                \"then load from it\\n\",\n+                template7.asToken(myInt),\n+                template1.asToken(myInt),\n+                \"now make something mutable\\n\",\n+                template4.asToken(myInt),\n+                \"then store to it\\n\",\n+                template6.asToken(myInt),\n+                template1.asToken(myInt)\n+            ),\n+            template1.asToken(myInt),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template8.render();\n+        String expected =\n+            \"\"\"\n+            class X_1 {\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            define immutable int name_10\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 1, names: {name_10}]\n+            ]\n+            define mutable int name_21\n+            [int:\n+              MUTABLE: [true, 1, names: {name_21}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 2, names: {name_10, name_21}]\n+            ]\n+            begin body_1\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            start with immutable\n+            { load_10\n+            blackhole(name_10)\n+            } load_10\n+            then load from it\n+            { sample_16\n+            blackhole(name_10)\n+            } sample_16\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 1, names: {name_10}]\n+            ]\n+            now make something mutable\n+            { store_21\n+            name_21 = 5\n+            } store_21\n+            then store to it\n+            { sample_27\n+            name_21 = 7\n+            } sample_27\n+            [int:\n+              MUTABLE: [true, 1, names: {name_21}]\n+              IMMUTABLE: [true, 1, names: {name_10}]\n+              MUTABLE_OR_IMMUTABLE: [true, 2, names: {name_10, name_21}]\n+            ]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames3() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+            \"  #mutability: [\",\n+            dataNames(mutability).exactOf(myInt).hasAny(),\n+            \", \",\n+            dataNames(mutability).exactOf(myInt).count(),\n+            \", names: {\",\n+            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            \"}]\\n\"\n+        ));\n+\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"[#type:\\n\",\n+            template0.asToken(type, MUTABLE),\n+            template0.asToken(type, IMMUTABLE),\n+            template0.asToken(type, MUTABLE_OR_IMMUTABLE),\n+            \"]\\n\"\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            \"class $Y {\\n\",\n+            template1.asToken(myInt),\n+            hook1.anchor(\n+                \"begin $body\\n\",\n+                template1.asToken(myInt),\n+                \"define mutable $v1\\n\",\n+                addDataName($(\"v1\"), myInt, MUTABLE),\n+                template1.asToken(myInt),\n+                \"define immutable $v2\\n\",\n+                addDataName($(\"v2\"), myInt, IMMUTABLE),\n+                template1.asToken(myInt)\n+            ),\n+            template1.asToken(myInt),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template2.render();\n+        String expected =\n+            \"\"\"\n+            class Y_1 {\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            begin body_1\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            define mutable v1_1\n+            [int:\n+              MUTABLE: [true, 1, names: {v1_1}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [true, 1, names: {v1_1}]\n+            ]\n+            define immutable v2_1\n+            [int:\n+              MUTABLE: [true, 1, names: {v1_1}]\n+              IMMUTABLE: [true, 1, names: {v2_1}]\n+              MUTABLE_OR_IMMUTABLE: [true, 2, names: {v1_1, v2_1}]\n+            ]\n+            [int:\n+              MUTABLE: [false, 0, names: {}]\n+              IMMUTABLE: [false, 0, names: {}]\n+              MUTABLE_OR_IMMUTABLE: [false, 0, names: {}]\n+            ]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames4() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+            \"[#type:\\n\",\n+            \"  exact: \",\n+            dataNames(MUTABLE).exactOf(type).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE).exactOf(type).count(),\n+            \", {\",\n+            String.join(\", \", dataNames(MUTABLE).exactOf(type).toList().stream().map(DataName::name).toList()),\n+            \"}\\n\",\n+            \"  subtype: \",\n+            dataNames(MUTABLE).subtypeOf(type).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE).subtypeOf(type).count(),\n+            \", {\",\n+            String.join(\", \", dataNames(MUTABLE).subtypeOf(type).toList().stream().map(DataName::name).toList()),\n+            \"}\\n\",\n+            \"  supertype: \",\n+            dataNames(MUTABLE).supertypeOf(type).hasAny(),\n+            \", \",\n+            dataNames(MUTABLE).supertypeOf(type).count(),\n+            \", {\",\n+            String.join(\", \", dataNames(MUTABLE).supertypeOf(type).toList().stream().map(DataName::name).toList()),\n+            \"}\\n\",\n+            \"]\\n\"\n+        ));\n+\n+        List<DataName.Type> types = List.of(myClassA, myClassA1, myClassA2, myClassA11, myClassB);\n+        var template2 = Template.make(() -> body(\n+            \"DataNames:\\n\",\n+            types.stream().map(t -> template1.asToken(t)).toList()\n+        ));\n+\n+        var template3 = Template.make(\"type\", (DataName.Type type) -> body(\n+            let(\"name\", dataNames(MUTABLE).subtypeOf(type).sample()),\n+            \"Sample #type: #name\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"class $W {\\n\",\n+            template2.asToken(),\n+            hook1.anchor(\n+                \"Create name for myClassA11, should be visible for the super classes\\n\",\n+                addDataName($(\"v1\"), myClassA11, MUTABLE),\n+                template3.asToken(myClassA11),\n+                template3.asToken(myClassA1),\n+                template3.asToken(myClassA),\n+                \"Create name for myClassA, should never be visible for the sub classes\\n\",\n+                addDataName($(\"v2\"), myClassA, MUTABLE),\n+                template3.asToken(myClassA11),\n+                template3.asToken(myClassA1),\n+                template2.asToken()\n+            ),\n+            template2.asToken(),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.render();\n+        String expected =\n+            \"\"\"\n+            class W_1 {\n+            DataNames:\n+            [myClassA:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA1:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA11:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            Create name for myClassA11, should be visible for the super classes\n+            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Create name for myClassA, should never be visible for the sub classes\n+            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            DataNames:\n+            [myClassA:\n+              exact: true, 1, {v2_1}\n+              subtype: true, 2, {v1_1, v2_1}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [myClassA1:\n+              exact: false, 0, {}\n+              subtype: true, 1, {v1_1}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [myClassA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [myClassA11:\n+              exact: true, 1, {v1_1}\n+              subtype: true, 1, {v1_1}\n+              supertype: true, 2, {v1_1, v2_1}\n+            ]\n+            [myClassB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            DataNames:\n+            [myClassA:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA1:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassA11:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [myClassB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    \/\/ Test duplicate names in safe cases.\n+    public static void testDataNames5() {\n+        var hook1 = new Hook(\"Hook1\");\n+        var hook2 = new Hook(\"Hook2\");\n+\n+        \/\/ It is safe in separate Hook scopes.\n+        var template1 = Template.make(() -> body(\n+            hook1.anchor(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ),\n+            hook1.anchor(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            )\n+        ));\n+\n+        \/\/ It is safe in separate Template scopes.\n+        var template2 = Template.make(() -> body(\n+            addDataName(\"name2\", myInt, MUTABLE)\n+        ));\n+        var template3 = Template.make(() -> body(\n+            template2.asToken(),\n+            template2.asToken()\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \/\/ The following is not safe, it would collide\n+            \/\/ with (1), because it would be inserted to the\n+            \/\/ hook1.anchor in template5, and hence be available\n+            \/\/ inside the scope where (1) is available.\n+            \/\/ See: testFailingAddNameDuplication8\n+            \/\/ addDataName(\"name\", myInt, MUTABLE),\n+            hook2.anchor(\n+                \/\/ (2) This one is added second. Since it is\n+                \/\/     inside the hook2.anchor, it does not go\n+                \/\/     out to the hook1.anchor, and is not\n+                \/\/     available inside the scope of (1).\n+                addDataName(\"name3\", myInt, MUTABLE)\n+            )\n+        ));\n+        var template5 = Template.make(() -> body(\n+            hook1.anchor(\n+                \/\/ (1) this is the first one we add.\n+                addDataName(\"name3\", myInt, MUTABLE)\n+            )\n+        ));\n+\n+        \/\/ Put it all together into a single test.\n+        var template6 = Template.make(() -> body(\n+            template1.asToken(),\n+            template3.asToken(),\n+            template5.asToken()\n+        ));\n+\n+        String code = template1.render();\n+        String expected = \"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames1() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+            \"[#type:\\n\",\n+            \"  exact: \",\n+            structuralNames().exactOf(type).hasAny(),\n+            \", \",\n+            structuralNames().exactOf(type).count(),\n+            \", {\",\n+            String.join(\", \", structuralNames().exactOf(type).toList().stream().map(StructuralName::name).toList()),\n+            \"}\\n\",\n+            \"  subtype: \",\n+            structuralNames().subtypeOf(type).hasAny(),\n+            \", \",\n+            structuralNames().subtypeOf(type).count(),\n+            \", {\",\n+            String.join(\", \", structuralNames().subtypeOf(type).toList().stream().map(StructuralName::name).toList()),\n+            \"}\\n\",\n+            \"  supertype: \",\n+            structuralNames().supertypeOf(type).hasAny(),\n+            \", \",\n+            structuralNames().supertypeOf(type).count(),\n+            \", {\",\n+            String.join(\", \", structuralNames().supertypeOf(type).toList().stream().map(StructuralName::name).toList()),\n+            \"}\\n\",\n+            \"]\\n\"\n+        ));\n+\n+        List<StructuralName.Type> types = List.of(myStructuralTypeA,\n+                                                  myStructuralTypeA1,\n+                                                  myStructuralTypeA2,\n+                                                  myStructuralTypeA11,\n+                                                  myStructuralTypeB);\n+        var template2 = Template.make(() -> body(\n+            \"StructuralNames:\\n\",\n+            types.stream().map(t -> template1.asToken(t)).toList()\n+        ));\n+\n+        var template3 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+            let(\"name\", structuralNames().subtypeOf(type).sample()),\n+            \"Sample #type: #name\\n\"\n+        ));\n+\n+        var template4 = Template.make(() -> body(\n+            \"class $Q {\\n\",\n+            template2.asToken(),\n+            hook1.anchor(\n+                \"Create name for myStructuralTypeA11, should be visible for the supertypes\\n\",\n+                addStructuralName($(\"v1\"), myStructuralTypeA11),\n+                template3.asToken(myStructuralTypeA11),\n+                template3.asToken(myStructuralTypeA1),\n+                template3.asToken(myStructuralTypeA),\n+                \"Create name for myStructuralTypeA, should never be visible for the subtypes\\n\",\n+                addStructuralName($(\"v2\"), myStructuralTypeA),\n+                template3.asToken(myStructuralTypeA11),\n+                template3.asToken(myStructuralTypeA1),\n+                template2.asToken()\n+            ),\n+            template2.asToken(),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template4.render();\n+        String expected =\n+            \"\"\"\n+            class Q_1 {\n+            StructuralNames:\n+            [StructuralA:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralA1:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralA11:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            Create name for myStructuralTypeA11, should be visible for the supertypes\n+            Sample StructuralA11: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA1: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Create name for myStructuralTypeA, should never be visible for the subtypes\n+            Sample StructuralA11: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA1: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            StructuralNames:\n+            [StructuralA:\n+              exact: true, 1, {v2_1}\n+              subtype: true, 2, {v1_1, v2_1}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [StructuralA1:\n+              exact: false, 0, {}\n+              subtype: true, 1, {v1_1}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [StructuralA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: true, 1, {v2_1}\n+            ]\n+            [StructuralA11:\n+              exact: true, 1, {v1_1}\n+              subtype: true, 1, {v1_1}\n+              supertype: true, 2, {v1_1, v2_1}\n+            ]\n+            [StructuralB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            StructuralNames:\n+            [StructuralA:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralA1:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralA2:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralA11:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            [StructuralB:\n+              exact: false, 0, {}\n+              subtype: false, 0, {}\n+              supertype: false, 0, {}\n+            ]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames2() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+            \"[#type: \",\n+            structuralNames().exactOf(type).hasAny(),\n+            \", \",\n+            structuralNames().exactOf(type).count(),\n+            \", names: {\",\n+            String.join(\", \", structuralNames().exactOf(type).toList().stream().map(StructuralName::name).toList()),\n+            \"}]\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"name\", \"type\", (String name, StructuralName.Type type) -> body(\n+            addStructuralName(name, type),\n+            \"define #type #name\\n\"\n+        ));\n+\n+        var template3 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+            \"{ $access\\n\",\n+            hook1.insert(template2.asToken($(\"name\"), type)),\n+            \"$name = 5\\n\",\n+            \"} $access\\n\"\n+        ));\n+\n+        var template4 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+            let(\"v\", structuralNames().exactOf(type).sample().name()),\n+            \"{ $sample\\n\",\n+            \"blackhole(#v)\\n\",\n+            \"} $sample\\n\"\n+        ));\n+\n+        var template8 = Template.make(() -> body(\n+            \"class $X {\\n\",\n+            template1.asToken(myStructuralTypeA),\n+            template1.asToken(myStructuralTypeB),\n+            hook1.anchor(\n+                \"begin $body\\n\",\n+                template1.asToken(myStructuralTypeA),\n+                template1.asToken(myStructuralTypeB),\n+                \"start with A\\n\",\n+                template3.asToken(myStructuralTypeA),\n+                \"then access it\\n\",\n+                template4.asToken(myStructuralTypeA),\n+                template1.asToken(myStructuralTypeA),\n+                template1.asToken(myStructuralTypeB),\n+                \"now make a B\\n\",\n+                template3.asToken(myStructuralTypeB),\n+                \"then access to it\\n\",\n+                template4.asToken(myStructuralTypeB),\n+                template1.asToken(myStructuralTypeA),\n+                template1.asToken(myStructuralTypeB)\n+            ),\n+            template1.asToken(myStructuralTypeA),\n+            template1.asToken(myStructuralTypeB),\n+            \"}\\n\"\n+        ));\n+\n+        String code = template8.render();\n+        String expected =\n+            \"\"\"\n+            class X_1 {\n+            [StructuralA: false, 0, names: {}]\n+            [StructuralB: false, 0, names: {}]\n+            define StructuralA name_6\n+            define StructuralB name_11\n+            begin body_1\n+            [StructuralA: false, 0, names: {}]\n+            [StructuralB: false, 0, names: {}]\n+            start with A\n+            { access_6\n+            name_6 = 5\n+            } access_6\n+            then access it\n+            { sample_8\n+            blackhole(name_6)\n+            } sample_8\n+            [StructuralA: true, 1, names: {name_6}]\n+            [StructuralB: false, 0, names: {}]\n+            now make a B\n+            { access_11\n+            name_11 = 5\n+            } access_11\n+            then access to it\n+            { sample_13\n+            blackhole(name_11)\n+            } sample_13\n+            [StructuralA: true, 1, names: {name_6}]\n+            [StructuralB: true, 1, names: {name_11}]\n+            [StructuralA: false, 0, names: {}]\n+            [StructuralB: false, 0, names: {}]\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    record MyItem(DataName.Type type, String op) {}\n+\n+    public static void testListArgument() {\n+        var template1 = Template.make(\"item\", (MyItem item) -> body(\n+            let(\"type\", item.type()),\n+            let(\"op\", item.op()),\n+            \"#type apply #op\\n\"\n+        ));\n+\n+        var template2 = Template.make(\"list\", (List<MyItem> list) -> body(\n+            \"class $Z {\\n\",\n+            \/\/ Use template1 for every item in the list.\n+            list.stream().map(item -> template1.asToken(item)).toList(),\n+            \"}\\n\"\n+        ));\n+\n+        List<MyItem> list = List.of(new MyItem(myInt, \"+\"),\n+                                    new MyItem(myInt, \"-\"),\n+                                    new MyItem(myInt, \"*\"),\n+                                    new MyItem(myInt, \"\/\"),\n+                                    new MyItem(myLong, \"+\"),\n+                                    new MyItem(myLong, \"-\"),\n+                                    new MyItem(myLong, \"*\"),\n+                                    new MyItem(myLong, \"\/\"));\n+\n+        String code = template2.render(list);\n+        String expected =\n+            \"\"\"\n+            class Z_1 {\n+            int apply +\n+            int apply -\n+            int apply *\n+            int apply \/\n+            long apply +\n+            long apply -\n+            long apply *\n+            long apply \/\n+            }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testFailingNestedRendering() {\n+        var template1 = Template.make(() -> body(\n+            \"alpha\\n\"\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            \"beta\\n\",\n+            \/\/ Nested \"render\" call not allowed!\n+            template1.render(),\n+            \"gamma\\n\"\n+        ));\n+\n+        String code = template2.render();\n+    }\n+\n+    public static void testFailingDollarName1() {\n+        var template1 = Template.make(() -> body(\n+            let(\"x\", $(\"\")) \/\/ empty string not allowed\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarName2() {\n+        var template1 = Template.make(() -> body(\n+            let(\"x\", $(\"#abc\")) \/\/ \"#\" character not allowed\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarName3() {\n+        var template1 = Template.make(() -> body(\n+            let(\"x\", $(\"abc#\")) \/\/ \"#\" character not allowed\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarName4() {\n+        var template1 = Template.make(() -> body(\n+            let(\"x\", $(null)) \/\/ Null input to dollar\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarName5() {\n+        var template1 = Template.make(() -> body(\n+            \"$\" \/\/ empty dollar name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarName6() {\n+        var template1 = Template.make(() -> body(\n+            \"asdf$\" \/\/ empty dollar name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarName7() {\n+        var template1 = Template.make(() -> body(\n+            \"asdf$1\" \/\/ Bad pattern after dollar\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarName8() {\n+        var template1 = Template.make(() -> body(\n+            \"abc$$abc\" \/\/ empty dollar name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingLetName1() {\n+        var template1 = Template.make(() -> body(\n+            let(null, $(\"abc\")) \/\/ Null input for hashtag name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtagName1() {\n+        \/\/ Empty Template argument\n+        var template1 = Template.make(\"\", (String x) -> body(\n+        ));\n+        String code = template1.render(\"abc\");\n+    }\n+\n+    public static void testFailingHashtagName2() {\n+        \/\/ \"#\" character not allowed in template argument\n+        var template1 = Template.make(\"abc#abc\", (String x) -> body(\n+        ));\n+        String code = template1.render(\"abc\");\n+    }\n+\n+    public static void testFailingHashtagName3() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ Empty let hashtag name not allowed\n+            let(\"\", \"abc\")\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtagName4() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ \"#\" character not allowed in let hashtag name\n+            let(\"xyz#xyz\", \"abc\")\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtagName5() {\n+        var template1 = Template.make(() -> body(\n+            \"#\" \/\/ empty hashtag name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtagName6() {\n+        var template1 = Template.make(() -> body(\n+            \"asdf#\" \/\/ empty hashtag name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtagName7() {\n+        var template1 = Template.make(() -> body(\n+            \"asdf#1\" \/\/ Bad pattern after hashtag\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtagName8() {\n+        var template1 = Template.make(() -> body(\n+            \"abc##abc\" \/\/ empty hashtag name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarHashtagName1() {\n+        var template1 = Template.make(() -> body(\n+            \"#$\" \/\/ empty hashtag name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarHashtagName2() {\n+        var template1 = Template.make(() -> body(\n+            \"$#\" \/\/ empty dollar name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarHashtagName3() {\n+        var template1 = Template.make(() -> body(\n+            \"#$name\" \/\/ empty hashtag name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingDollarHashtagName4() {\n+        var template1 = Template.make(() -> body(\n+            \"$#name\" \/\/ empty dollar name\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHook() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            \"alpha\\n\"\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            \"beta\\n\",\n+            \/\/ Use hook without hook1.anchor\n+            hook1.insert(template1.asToken()),\n+            \"gamma\\n\"\n+        ));\n+\n+        String code = template2.render();\n+    }\n+\n+    public static void testFailingSample1() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ No variable added yet.\n+            let(\"v\", dataNames(MUTABLE).exactOf(myInt).sample().name()),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingSample2() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ no type restriction\n+            let(\"v\", dataNames(MUTABLE).sample().name()),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtag1() {\n+        \/\/ Duplicate hashtag definition from arguments.\n+        var template1 = Template.make(\"a\", \"a\", (String _, String _) -> body(\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.render(\"x\", \"y\");\n+    }\n+\n+    public static void testFailingHashtag2() {\n+        var template1 = Template.make(\"a\", (String _) -> body(\n+            \/\/ Duplicate hashtag name\n+            let(\"a\", \"x\"),\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.render(\"y\");\n+    }\n+\n+    public static void testFailingHashtag3() {\n+        var template1 = Template.make(() -> body(\n+            let(\"a\", \"x\"),\n+            \/\/ Duplicate hashtag name\n+            let(\"a\", \"y\"),\n+            \"nothing\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingHashtag4() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ Missing hashtag name definition\n+            \"#a\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingBinding1() {\n+        var binding = new TemplateBinding<Template.ZeroArgs>();\n+        var template1 = Template.make(() -> body(\n+            \"nothing\\n\"\n+        ));\n+        binding.bind(template1);\n+        \/\/ Duplicate bind\n+        binding.bind(template1);\n+    }\n+\n+    public static void testFailingBinding2() {\n+        var binding = new TemplateBinding<Template.ZeroArgs>();\n+        var template1 = Template.make(() -> body(\n+            \"nothing\\n\",\n+            \/\/ binding was never bound.\n+            binding.get()\n+        ));\n+        \/\/ Should have bound the binding here.\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingAddDataName1() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ Must pick either MUTABLE or IMMUTABLE.\n+            addDataName(\"name\", myInt, MUTABLE_OR_IMMUTABLE)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingAddDataName2() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ weight out of bounds [0..1000]\n+            addDataName(\"name\", myInt, MUTABLE, 0)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingAddDataName3() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ weight out of bounds [0..1000]\n+            addDataName(\"name\", myInt, MUTABLE, -1)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingAddDataName4() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ weight out of bounds [0..1000]\n+            addDataName(\"name\", myInt, MUTABLE, 1001)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingAddStructuralName1() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ weight out of bounds [0..1000]\n+            addStructuralName(\"name\", myStructuralTypeA, 0)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingAddStructuralName2() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ weight out of bounds [0..1000]\n+            addStructuralName(\"name\", myStructuralTypeA, -1)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingAddStructuralName3() {\n+        var template1 = Template.make(() -> body(\n+            \/\/ weight out of bounds [0..1000]\n+            addStructuralName(\"name\", myStructuralTypeA, 1001)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    \/\/ Duplicate name in the same scope, name identical -> expect RendererException.\n+    public static void testFailingAddNameDuplication1() {\n+        var template1 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE),\n+            addDataName(\"name\", myInt, MUTABLE)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    \/\/ Duplicate name in the same scope, names have different mutability -> expect RendererException.\n+    public static void testFailingAddNameDuplication2() {\n+        var template1 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE),\n+            addDataName(\"name\", myInt, IMMUTABLE)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    \/\/ Duplicate name in the same scope, names have different type -> expect RendererException.\n+    public static void testFailingAddNameDuplication3() {\n+        var template1 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE),\n+            addDataName(\"name\", myLong, MUTABLE)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    \/\/ Duplicate name in the same scope, name identical -> expect RendererException.\n+    public static void testFailingAddNameDuplication4() {\n+        var template1 = Template.make(() -> body(\n+            addStructuralName(\"name\", myStructuralTypeA),\n+            addStructuralName(\"name\", myStructuralTypeA)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    \/\/ Duplicate name in the same scope, names have different type -> expect RendererException.\n+    public static void testFailingAddNameDuplication5() {\n+        var template1 = Template.make(() -> body(\n+            addStructuralName(\"name\", myStructuralTypeA),\n+            addStructuralName(\"name\", myStructuralTypeB)\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    \/\/ Duplicate name in inner Template, name identical -> expect RendererException.\n+    public static void testFailingAddNameDuplication6() {\n+        var template1 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE)\n+        ));\n+        var template2 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE),\n+            template1.asToken()\n+        ));\n+        String code = template2.render();\n+    }\n+\n+    \/\/ Duplicate name in Hook scope, name identical -> expect RendererException.\n+    public static void testFailingAddNameDuplication7() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE),\n+            hook1.anchor(\n+                addDataName(\"name\", myInt, MUTABLE)\n+            )\n+        ));\n+        String code = template1.render();\n+    }\n+\n+    \/\/ Duplicate name in Hook.insert, name identical -> expect RendererException.\n+    public static void testFailingAddNameDuplication8() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template1 = Template.make(() -> body(\n+            addDataName(\"name\", myInt, MUTABLE)\n+        ));\n+\n+        var template2 = Template.make(() -> body(\n+            hook1.anchor(\n+                addDataName(\"name\", myInt, MUTABLE),\n+                hook1.insert(template1.asToken())\n+            )\n+        ));\n+        String code = template2.render();\n+    }\n+\n+    public static void expectRendererException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown RendererException with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(RendererException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n+    public static void expectIllegalArgumentException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown IllegalArgumentException with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(IllegalArgumentException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n+    public static void expectUnsupportedOperationException(FailingTest test, String errorPrefix) {\n+        try {\n+            test.run();\n+            System.out.println(\"Should have thrown UnsupportedOperationException with prefix: \" + errorPrefix);\n+            throw new RuntimeException(\"Should have thrown!\");\n+        } catch(UnsupportedOperationException e) {\n+            if (!e.getMessage().startsWith(errorPrefix)) {\n+                System.out.println(\"Should have thrown with prefix: \" + errorPrefix);\n+                System.out.println(\"got: \" + e.getMessage());\n+                throw new RuntimeException(\"Prefix mismatch\", e);\n+            }\n+        }\n+    }\n+\n+    public static void checkEQ(String code, String expected) {\n+        if (!code.equals(expected)) {\n+            System.out.println(\"\\\"\" + code + \"\\\"\");\n+            System.out.println(\"\\\"\" + expected + \"\\\"\");\n+            throw new RuntimeException(\"Template rendering mismatch!\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestTemplate.java","additions":2253,"deletions":0,"binary":false,"changes":2253,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to show Verify.checkEQ with the VectorAPI.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run main verify.examples.TestWithVectorAPI\n+ *\/\n+\n+package verify.examples;\n+\n+import jdk.incubator.vector.*;\n+\n+import compiler.lib.verify.*;\n+\n+\/**\n+ * Example to show the use of Verify.checkEQ with the VectorAPI.\n+ *\/\n+public class TestWithVectorAPI {\n+    public static void main(String[] args) {\n+        IntVector iv1 = IntVector.broadcast(IntVector.SPECIES_64, 7);\n+        IntVector iv2 = IntVector.broadcast(IntVector.SPECIES_64, 35);\n+        IntVector iv3 = IntVector.broadcast(IntVector.SPECIES_64, 42);\n+        IntVector iv4 = iv1.add(iv2);\n+        Verify.checkEQ(iv3, iv4);\n+\n+        FloatVector fv1 = FloatVector.broadcast(FloatVector.SPECIES_64, 7);\n+        FloatVector fv2 = FloatVector.broadcast(FloatVector.SPECIES_64, 35);\n+        FloatVector fv3 = FloatVector.broadcast(FloatVector.SPECIES_64, 42);\n+        FloatVector fv4 = fv1.add(fv2);\n+        Verify.checkEQ(fv3, fv4);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/examples\/TestWithVectorAPI.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -53,0 +53,3 @@\n+        testException();\n+\n+        testRawFloat();\n@@ -56,0 +59,2 @@\n+\n+        testArbitraryClasses();\n@@ -293,0 +298,57 @@\n+    public static void testException() {\n+        Exception e1 = new ArithmeticException(\"abc\");\n+        Exception e2 = new ArithmeticException(\"abc\");\n+        Exception e3 = new ArithmeticException();\n+        Exception e4 = new ArithmeticException(\"xyz\");\n+        Exception e5 = new RuntimeException(\"abc\");\n+\n+        Verify.checkEQ(e1, e1);\n+        Verify.checkEQ(e1, e2);\n+        Verify.checkEQ(e3, e3);\n+        Verify.checkEQ(e1, e3); \/\/ one has no message\n+\n+        checkNE(e1, e4);\n+        checkNE(e2, e4);\n+        Verify.checkEQ(e3, e4);\n+\n+        Verify.checkEQ(e5, e5);\n+        checkNE(e1, e5);\n+        checkNE(e2, e5);\n+        checkNE(e3, e5);\n+        checkNE(e4, e5);\n+    }\n+\n+    public static void testRawFloat() {\n+        float nanF1 = Float.intBitsToFloat(0x7f800001);\n+        float nanF2 = Float.intBitsToFloat(0x7fffffff);\n+        double nanD1 = Double.longBitsToDouble(0x7ff0000000000001L);\n+        double nanD2 = Double.longBitsToDouble(0x7fffffffffffffffL);\n+\n+        float[] arrF1 = new float[]{nanF1};\n+        float[] arrF2 = new float[]{nanF2};\n+        double[] arrD1 = new double[]{nanD1};\n+        double[] arrD2 = new double[]{nanD2};\n+\n+        Verify.checkEQ(nanF1, Float.NaN);\n+        Verify.checkEQ(nanF1, nanF1);\n+        Verify.checkEQWithRawBits(nanF1, nanF1);\n+        Verify.checkEQ(nanF1, nanF2);\n+        Verify.checkEQ(nanD1, Double.NaN);\n+        Verify.checkEQ(nanD1, nanD1);\n+        Verify.checkEQWithRawBits(nanD1, nanD1);\n+        Verify.checkEQ(nanD1, nanD2);\n+\n+        Verify.checkEQ(arrF1, arrF1);\n+        Verify.checkEQWithRawBits(arrF1, arrF1);\n+        Verify.checkEQ(arrF1, arrF2);\n+        Verify.checkEQ(arrD1, arrD1);\n+        Verify.checkEQWithRawBits(arrD1, arrD1);\n+        Verify.checkEQ(arrD1, arrD2);\n+\n+        checkNEWithRawBits(nanF1, nanF2);\n+        checkNEWithRawBits(nanD1, nanD2);\n+\n+        checkNEWithRawBits(arrF1, arrF2);\n+        checkNEWithRawBits(arrD1, arrD2);\n+    }\n+\n@@ -403,1 +465,1 @@\n-            checkNE(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n+            checkNEWithRawBits(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n@@ -409,1 +471,23 @@\n-            checkNE(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+            checkNEWithRawBits(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+        }\n+    }\n+\n+    static class A {}\n+\n+    static class B {}\n+\n+    static class C extends B {}\n+\n+    static class D {\n+        D(int x) {\n+            this.x = x;\n+        }\n+\n+        private int x;\n+    }\n+\n+    static class E {\n+        E(D d, E e1, E e2) {\n+            this.d = d;\n+            this.e1 = e1;\n+            this.e2 = e2;\n@@ -411,0 +495,184 @@\n+\n+        private D d;\n+        public E e1;\n+        public E e2;\n+    }\n+\n+    static class F {\n+        private int x;\n+\n+        public F(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static class F2 extends F {\n+        private int y;\n+\n+        F2(int x, int y) {\n+            super(x);\n+            this.y = y;\n+        }\n+    }\n+\n+    static class G {\n+        private float x;\n+        private float y;\n+\n+        public G(float x, float y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    public static class H1 {\n+        public boolean bool = true;\n+        public byte b = (byte)242;\n+        public short s = (short)24242;\n+        public char c = (char)24242;\n+        public int i = 1335836768;\n+        public long l = 4242424242L;\n+        public float f = 42.0f;\n+        public double d = 42.0;\n+        public H1() {}\n+    }\n+\n+    public static class H2 extends H1 {\n+        public H1 h1 = new H1();\n+        public H2() {}\n+    }\n+\n+    static record R1() {}\n+    static record R2() {}\n+    static record R3(int x, int y) {}\n+    static record R4(R4 x, R4 y) {}\n+\n+    public static void testArbitraryClasses() {\n+        A a1 = new A();\n+        A a2 = new A();\n+        B b1 = new B();\n+        B b2 = new B();\n+        C c1 = new C();\n+        C c2 = new C();\n+\n+        \/\/ Structurally equivalent.\n+        Verify.checkEQ(a1, a1);\n+        Verify.checkEQ(a1, a2);\n+        Verify.checkEQ(b1, b1);\n+        Verify.checkEQ(b1, b2);\n+        Verify.checkEQ(c1, c1);\n+        Verify.checkEQ(c1, c2);\n+\n+        \/\/ Must fail because of different classes.\n+        checkNE(a1, b1);\n+        checkNE(b1, a1);\n+        checkNE(a1, c1);\n+        checkNE(c1, a1);\n+        checkNE(b1, c1);\n+        checkNE(c1, b1);\n+\n+        \/\/ Objects with primitive values.\n+        D d1 = new D(1);\n+        D d2 = new D(1);\n+        D d3 = new D(2);\n+        Verify.checkEQ(d1, d1);\n+        Verify.checkEQ(d1, d2);\n+        Verify.checkEQ(d2, d1);\n+        checkNE(d1, d3);\n+        checkNE(d3, d1);\n+\n+        \/\/ Object fields, including cycles.\n+        E e1 = new E(d1, null, null);\n+        E e2 = new E(d1, null, null);\n+        E e3 = new E(d3, null, null);\n+        E e4 = new E(d1, e1, null);\n+        E e5 = new E(d1, e2, null);\n+        E e6 = new E(d1, null, null);\n+        e6.e1 = e6;\n+        E e7 = new E(d1, null, null);\n+        e7.e1 = e7;\n+        E e8 = new E(d1, e1, e1);\n+        E e9 = new E(d1, e1, e2);\n+\n+        Verify.checkEQ(e1, e1);\n+        Verify.checkEQ(e1, e2);\n+        Verify.checkEQ(e2, e1);\n+        checkNE(e1, e3);\n+        checkNE(e3, e1);\n+        Verify.checkEQ(e6, e6);\n+        Verify.checkEQ(e6, e7);\n+        Verify.checkEQ(e7, e6);\n+        Verify.checkEQ(e8, e8);\n+        checkNE(e8, e9);\n+        checkNE(e9, e8);\n+\n+        \/\/ Fields from superclass.\n+        F2 f1 = new F2(1, 1);\n+        F2 f2 = new F2(1, 1);\n+        F2 f3 = new F2(2, 1);\n+        F2 f4 = new F2(1, 2);\n+\n+        Verify.checkEQ(f1, f1);\n+        Verify.checkEQ(f1, f2);\n+        Verify.checkEQ(f2, f1);\n+        checkNE(f1, f3);\n+        checkNE(f1, f4);\n+        checkNE(f3, f1);\n+        checkNE(f4, f1);\n+        checkNE(f3, f4);\n+        checkNE(f4, f3);\n+\n+        G g1 = new G(1.0f, 1.0f);\n+        G g2 = new G(1.0f, 1.0f);\n+        G g3 = new G(Float.NaN, Float.NaN);\n+        G g4 = new G(Float.NaN, Float.NaN);\n+\n+        Verify.checkEQ(g1, g1);\n+        Verify.checkEQ(g2, g1);\n+        Verify.checkEQ(g1, g2);\n+        Verify.checkEQ(g3, g3);\n+        Verify.checkEQ(g3, g4);\n+        Verify.checkEQ(g4, g3);\n+        checkNE(g1, g3);\n+        checkNE(g3, g1);\n+\n+        \/\/ Nested class with primitive types, where the boxed types may not be cached,\n+        \/\/ and so they would create different boxed objects.\n+        Verify.checkEQ(new H2(), new H2());\n+\n+        \/\/ Records.\n+        R1 r11 = new R1();\n+        R1 r12 = new R1();\n+        R2 r21 = new R2();\n+        R3 r31 = new R3(1, 1);\n+        R3 r32 = new R3(1, 1);\n+        R3 r33 = new R3(1, 2);\n+        R3 r34 = new R3(2, 1);\n+\n+        Verify.checkEQ(r11, r11);\n+        Verify.checkEQ(r11, r12);\n+        Verify.checkEQ(r12, r11);\n+        checkNE(r11, r21);\n+        Verify.checkEQ(r31, r31);\n+        Verify.checkEQ(r31, r32);\n+        Verify.checkEQ(r32, r31);\n+        checkNE(r31, r33);\n+        checkNE(r33, r31);\n+        checkNE(r31, r34);\n+        checkNE(r34, r31);\n+        checkNE(r33, r34);\n+\n+        R4 r41 = new R4(null, null);\n+        R4 r42 = new R4(null, null);\n+        R4 r43 = new R4(r41, null);\n+        R4 r44 = new R4(r42, null);\n+        R4 r45 = new R4(r43, r41);\n+        R4 r46 = new R4(r44, r42);\n+        R4 r47 = new R4(r44, r41);\n+\n+        Verify.checkEQ(r45, r46);\n+        Verify.checkEQ(r46, r45);\n+        checkNE(r45, r47);\n+        checkNE(r47, r45);\n+        checkNE(r46, r47);\n+        checkNE(r47, r46);\n@@ -416,1 +684,8 @@\n-            throw new RuntimeException(\"Should have thrown\");\n+            throw new RuntimeException(\"Should have thrown: \" + a + \" vs \" + b);\n+        } catch (VerifyException e) {}\n+    }\n+\n+    public static void checkNEWithRawBits(Object a, Object b) {\n+         try {\n+            Verify.checkEQWithRawBits(a, b);\n+            throw new RuntimeException(\"Should have thrown: \" + a + \" vs \" + b);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerify.java","additions":278,"deletions":3,"binary":false,"changes":281,"status":"modified"}]}