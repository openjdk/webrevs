{"files":[{"patch":"@@ -279,5 +279,0 @@\n-        \/**\n-         * Warn about operations on null-restricted and nullable types.\n-         *\/\n-        NULL(\"null\"),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -1037,1 +1036,0 @@\n-                boolean result;\n@@ -1039,1 +1037,1 @@\n-                    result = isSameType(elemtype(t), elemtype(s));\n+                    return isSameType(elemtype(t), elemtype(s));\n@@ -1041,1 +1039,1 @@\n-                    result = isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n@@ -1043,5 +1041,1 @@\n-                if (result && allowNullRestrictedTypes && hasNarrowerNullability(s, t)) {\n-                    warn.warn(LintCategory.NULL);\n-                }\n-                return result;\n-            } else if (isSubtype(t, s, capture, warn)) {\n+            } else if (isSubtype(t, s, capture)) {\n@@ -1097,8 +1091,0 @@\n-    public boolean isSubtype(Type t, Type s, boolean capture, Warner warner) {\n-        try {\n-            pushWarner(warner);\n-            return isSubtype(t, s, capture);\n-        } finally {\n-            popWarner();\n-        }\n-    }\n@@ -1106,4 +1092,1 @@\n-        if (t.equalsIgnoreMetadata(s)) {\n-            if (allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n-                warnStack.head.warn(LintCategory.NULL);\n-            }\n+        if (t.equalsIgnoreMetadata(s))\n@@ -1111,1 +1094,0 @@\n-        }\n@@ -1224,1 +1206,1 @@\n-                boolean result = sup.tsym == s.tsym\n+                return sup.tsym == s.tsym\n@@ -1229,4 +1211,0 @@\n-                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n-                    warnStack.head.warn(LintCategory.NULL);\n-                }\n-                return result;\n@@ -1237,1 +1215,0 @@\n-                boolean result = false;\n@@ -1240,1 +1217,1 @@\n-                        result = isSameType(t.elemtype, elemtype(s));\n+                        return isSameType(t.elemtype, elemtype(s));\n@@ -1242,1 +1219,1 @@\n-                        result = isSubtypeNoCapture(t.elemtype, elemtype(s));\n+                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n@@ -1245,1 +1222,1 @@\n-                if (!result && s.hasTag(CLASS)) {\n+                if (s.hasTag(CLASS)) {\n@@ -1247,1 +1224,1 @@\n-                    result = sname == names.java_lang_Object\n+                    return sname == names.java_lang_Object\n@@ -1252,5 +1229,1 @@\n-                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n-                    warnStack.head.warn(LintCategory.NULL);\n-                }\n-\n-                return result;\n+                return false;\n@@ -1397,4 +1370,1 @@\n-                if (t.equalsIgnoreMetadata(s)) {\n-                    if (allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n-                        warnStack.head.warn(LintCategory.NULL);\n-                    }\n+                if (t.equalsIgnoreMetadata(s))\n@@ -1402,1 +1372,0 @@\n-                }\n@@ -1471,1 +1440,1 @@\n-                boolean equal = t.tsym == s.tsym\n+                return t.tsym == s.tsym\n@@ -1474,4 +1443,0 @@\n-                if (equal && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n-                    warnStack.head.warn(LintCategory.NULL);\n-                }\n-                return equal;\n@@ -1484,13 +1449,8 @@\n-                boolean result;\n-                if (t == s) {\n-                    result = true;\n-                } else if (s.isPartial()) {\n-                    result = visit(s, t);\n-                } else {\n-                    result = s.hasTag(ARRAY) &&\n-                            containsTypeEquivalent(t.elemtype, elemtype(s));\n-                }\n-                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n-                    warnStack.head.warn(LintCategory.NULL);\n-                }\n-                return result;\n+                if (t == s)\n+                    return true;\n+\n+                if (s.isPartial())\n+                    return visit(s, t);\n+\n+                return s.hasTag(ARRAY)\n+                    && containsTypeEquivalent(t.elemtype, elemtype(s));\n@@ -2230,10 +2190,0 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n-    public void pushWarner(Warner warner) {\n-        warnStack = warnStack.prepend(warner);\n-    }\n-\n-    public void popWarner() {\n-        warnStack = warnStack.tail;\n-    }\n-    \/\/ <\/editor-fold>\n-\n@@ -2429,4 +2379,0 @@\n-                            } else if (baseParams.length() != ownerParams.length()) {\n-                                \/\/ rare type, recovery\n-                                return subst(sym.type, ownerParams,\n-                                        baseParams.map(ta -> ta.asNullMarked(NullMarker.UNSPECIFIED)));\n@@ -2434,7 +2380,1 @@\n-                                ListBuffer<Type> newBaseParams = new ListBuffer<>();\n-                                for (Type tvar : ownerParams) {\n-                                    Type baseParam = baseParams.head.asNullMarked(NullMarker.UNSPECIFIED);\n-                                    newBaseParams.add(baseParam);\n-                                    baseParams = baseParams.tail;\n-                                }\n-                                return subst(sym.type, ownerParams, newBaseParams.toList());\n+                                return subst(sym.type, ownerParams, baseParams);\n@@ -2583,5 +2523,5 @@\n-        @Override\n-        public Type visitArrayType(ArrayType t, Boolean aBoolean) {\n-            Type erased = super.visitArrayType(t, aBoolean);\n-            return combineMetadata(erased, t);\n-        }\n+            @Override\n+            public Type visitArrayType(ArrayType t, Boolean aBoolean) {\n+                Type erased = super.visitArrayType(t, aBoolean);\n+                return combineMetadata(erased, t);\n+            }\n@@ -2931,10 +2871,1 @@\n-        return isSubSignature(t, s, noWarnings);\n-    }\n-\n-    public boolean isSubSignature(Type t, Type s, Warner warn) {\n-        try {\n-            warnStack = warnStack.prepend(warn);\n-            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n-        } finally {\n-            warnStack = warnStack.tail;\n-        }\n+        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":27,"deletions":96,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import javax.lang.model.type.TypeKind;\n@@ -271,10 +270,0 @@\n-    \/** Warn about operation with bang types.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param warnKey    A warning key.\n-     *\/\n-    public void warnNullableTypes(DiagnosticPosition pos, LintWarning warnKey) {\n-        if (allowNullRestrictedTypes) {\n-            log.warning(pos, warnKey);\n-        }\n-    }\n-\n@@ -613,4 +602,3 @@\n-                && !is292targetTypeCast(tree)) {\n-            if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n-                log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n-            }\n+                && !is292targetTypeCast(tree)\n+                && !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n+            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n@@ -642,1 +630,1 @@\n-    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n+    private boolean checkExtends(Type a, Type bound) {\n@@ -647,11 +635,1 @@\n-             try {\n-                 if (pos != null) {\n-                     types.pushWarner(new NullnessWarner(pos));\n-                 }\n-                 return types.isSubtype(a, bound, true);\n-             } finally {\n-                 if (pos != null) {\n-                     types.popWarner();\n-                 }\n-             }\n-\n+             return types.isSubtype(a, bound);\n@@ -1099,5 +1077,1 @@\n-        return checkValidGenericType(null, t);\n-    }\n-\n-    public boolean checkValidGenericType(JCTree pos, Type t) {\n-        return firstIncompatibleTypeArg(pos, t) == null;\n+        return firstIncompatibleTypeArg(t) == null;\n@@ -1106,1 +1080,1 @@\n-        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n+        private Type firstIncompatibleTypeArg(Type type) {\n@@ -1143,1 +1117,1 @@\n-                        !checkExtends(pos, actual, bounds.head)) {\n+                        !checkExtends(actual, bounds.head)) {\n@@ -1485,1 +1459,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n@@ -1889,16 +1863,2 @@\n-        boolean resultTypesOK = false;\n-        try {\n-            types.pushWarner(overrideWarner);\n-            resultTypesOK = types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);\n-            if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n-                warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), LintWarnings.OverridesWithDifferentNullness1);\n-            }\n-            overrideWarner.remove(LintCategory.NULL);\n-            \/\/ at this point we know this will be true but to gather the warnings\n-            types.isSubSignature(mt, ot, overrideWarner);\n-            if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n-                warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), LintWarnings.OverridesWithDifferentNullness2);\n-            }\n-        } finally {\n-            types.popWarner();\n-        }\n+        boolean resultTypesOK =\n+            types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);\n@@ -2636,0 +2596,1 @@\n+\n@@ -4455,22 +4416,0 @@\n-    private class NullnessWarner extends Warner {\n-        public NullnessWarner(DiagnosticPosition pos) {\n-            super(pos);\n-        }\n-\n-        @Override\n-        public void warn(LintCategory lint) {\n-            if (allowNullRestrictedTypes) {\n-                boolean warned = this.warned;\n-                super.warn(lint);\n-                if (warned) return; \/\/ suppress redundant diagnostics\n-                switch (lint) {\n-                    case NULL:\n-                        Check.this.warnNullableTypes(pos(), LintWarnings.UncheckedNullnessConversion);\n-                        break;\n-                    default:\n-                        throw new AssertionError(\"Unexpected lint: \" + lint);\n-                }\n-            }\n-        }\n-    }\n-\n@@ -4505,3 +4444,0 @@\n-                case NULL:\n-                    Check.this.warnNullableTypes(pos(), LintWarnings.UncheckedNullnessConversion);\n-                    break;\n@@ -4511,17 +4447,0 @@\n-            this.warned = true;\n-        }\n-    }\n-\n-    private class CastWarner extends ConversionWarner {\n-        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n-            super(pos, key, found, expected);\n-        }\n-\n-        @Override\n-        public void warn(LintCategory lint) {\n-            if (lint != LintCategory.NULL) {\n-                super.warn(lint);\n-            } else {\n-                boolean warned = this.warned;\n-                if (warned) return;\n-            }\n@@ -4532,1 +4451,1 @@\n-        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":13,"deletions":94,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -4383,20 +4383,0 @@\n-# lint: null\n-compiler.warn.narrowing.nullness.conversion=\\\n-    narrowing nullness conversion\n-\n-# lint: null\n-compiler.warn.unchecked.nullness.conversion=\\\n-    unchecked nullness conversion\n-\n-# lint: null\n-compiler.warn.accessing.member.of.nullable=\\\n-    accessing member of nullable type\n-\n-# lint: null\n-compiler.warn.overrides.with.different.nullness.1=\\\n-    overriding method''s return type does not match nullness of overridden method\n-\n-# lint: null\n-compiler.warn.overrides.with.different.nullness.2=\\\n-    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -248,3 +248,0 @@\n-javac.opt.Xlint.desc.null=\\\n-    Warn about operations on null-restricted and nullable types.\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -231,2 +231,0 @@\n-compiler.warn.accessing.member.of.nullable\n-compiler.warn.narrowing.nullness.conversion\n@@ -236,3 +234,0 @@\n-compiler.warn.unchecked.nullness.conversion\n-compiler.warn.overrides.with.different.nullness.1\n-compiler.warn.overrides.with.different.nullness.2\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-    private static String[] PREVIEW_PLUS_LINT_OPTIONS = {\n-            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()),\n-            \"-Xlint:null\" };\n@@ -67,1 +64,0 @@\n-        COMPILE_WITH_WARNING,\n@@ -84,5 +80,1 @@\n-                if (testResult == TestResult.COMPILE_WITH_WARNING) {\n-                    assertOKWithWarning(diagsMessage, diagsCount, code);\n-                } else {\n-                    assertFail(diagsMessage, code);\n-                }\n+                assertFail(diagsMessage, code);\n@@ -104,14 +96,0 @@\n-            if (diagAndCode.result == Result.Clean) {\n-                testHelper(PREVIEW_PLUS_LINT_OPTIONS, diagAndCode.code);\n-            } else if (diagAndCode.result == Result.Warning) {\n-                testHelper(PREVIEW_PLUS_LINT_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.COMPILE_WITH_WARNING, diagAndCode.code, null);\n-                testHelper(PREVIEW_OPTIONS, diagAndCode.code,\n-                        d -> {\n-                            if (d.getKind() == Diagnostic.Kind.WARNING) {\n-                                \/\/ shouldn't issue any warnings if the -Xlint:null option is not passed\n-                                throw new AssertionError(\"unexpected warning for \" + diagAndCode.code);\n-                            }\n-                        });\n-            } else {\n-                testHelper(PREVIEW_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n-            }\n@@ -120,0 +98,2 @@\n+            } else {\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n@@ -124,1 +104,1 @@\n-    enum Result { Warning, Error, Clean}\n+    enum Result { Error, Clean }\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"}]}