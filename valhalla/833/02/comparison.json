{"files":[{"patch":"@@ -113,1 +113,1 @@\n-    -XDenableValueTypes \\\n+    -XDenableValueTypes -XDenablePrimitiveClasses \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-  JAVA_WARNINGS_ARE_ERRORS ?= -Werror\n+  JAVA_WARNINGS_ARE_ERRORS ?=\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1187,0 +1187,7 @@\n+    movptr(rscratch1, rax);\n+    \/\/ Skip scalarization for vector value objects (concrete vectors and payloads).\n+    super_call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::is_vector_value_instance), rdi);\n+    testptr(rax, rax);\n+    movptr(rax, rscratch1);\n+    jcc(Assembler::notZero, skip);\n+    load_klass(rdi, rax, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1866,7 +1866,10 @@\n-    assert(!inner_field->is_flattened(), \"the iteration over nested fields is handled by the loop itself\");\n-    int off = inner_field->offset() - vk->first_field_offset();\n-    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n-    Value replacement = append(load);\n-    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n-    store->set_enclosing_field(enclosing_field);\n-    append(store);\n+    for (int j = 0, sec_offset = 0; j < inner_field->secondary_fields_count(); j++) {\n+      assert(!inner_field->is_flattened(), \"the iteration over nested fields is handled by the loop itself\");\n+      int off = inner_field->offset() + sec_offset - vk->first_field_offset();\n+      LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n+      sec_offset += type2aelembytes(as_BasicType(load->type()));\n+      Value replacement = append(load);\n+      StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n+      store->set_enclosing_field(enclosing_field);\n+      append(store);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -207,0 +207,2 @@\n+  initialize_from(fd);\n+\n@@ -212,1 +214,1 @@\n-    _type = ciType::make(field_type);\n+    _type = ciType::make(field_type, _secondary_fields_count);\n@@ -215,2 +217,0 @@\n-  initialize_from(fd);\n-\n@@ -245,0 +245,4 @@\n+  _is_multifield = field->_is_multifield;\n+  _is_multifield_base = field->_is_multifield_base;\n+  _secondary_fields_count = field->_secondary_fields_count;\n+\n@@ -298,0 +302,4 @@\n+  _is_multifield = fd->is_multifield();\n+  _is_multifield_base = fd->is_multifield_base();\n+  _secondary_fields_count = fd->secondary_fields_count(fd->index());\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -43,0 +44,1 @@\n+  friend class ciMultiField;\n@@ -52,0 +54,1 @@\n+  int              _secondary_fields_count;\n@@ -55,0 +58,2 @@\n+  bool             _is_multifield;\n+  bool             _is_multifield_base;\n@@ -108,0 +113,4 @@\n+  bool is_multifield() { return _is_multifield; }\n+  bool is_multifield_base() { return _is_multifield_base; }\n+  int secondary_fields_count() { return _secondary_fields_count; } const\n+\n@@ -183,0 +192,2 @@\n+  bool is_multifield           () const { return _is_multifield; }\n+\n@@ -197,0 +208,16 @@\n+class ciMultiField : public ciField {\n+private:\n+  CI_PACKAGE_ACCESS\n+  friend class ciInstanceKlass;\n+\n+  GrowableArray<ciField*>*   _secondary_fields;\n+\n+  ciMultiField(ciInstanceKlass* klass, int index) : ciField(klass, index) {}\n+  ciMultiField(fieldDescriptor* fd) : ciField(fd) {}\n+  ciMultiField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) :\n+       ciField(field, holder, offset, is_final) {}\n+public:\n+  void add_secondary_fields(GrowableArray<ciField*>* fields) { _secondary_fields = fields; }\n+  GrowableArray<ciField*>* secondary_fields() { return _secondary_fields; }\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciEnv.hpp\"\n@@ -81,1 +82,1 @@\n-  GUARDED_VM_ENTRY(return to_InlineKlass()->can_be_passed_as_fields();)\n+  GUARDED_VM_ENTRY(return !VectorSupport::skip_value_scalarization(const_cast<ciInlineKlass*>(this)) && to_InlineKlass()->can_be_passed_as_fields();)\n@@ -86,1 +87,1 @@\n-  GUARDED_VM_ENTRY(return to_InlineKlass()->can_be_returned_as_fields();)\n+  GUARDED_VM_ENTRY(return !VectorSupport::skip_value_scalarization(const_cast<ciInlineKlass*>(this)) && to_InlineKlass()->can_be_returned_as_fields();)\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"ci\/ciField.hpp\"\n@@ -73,1 +74,12 @@\n-    return _declared_nonstatic_fields->at(i);\n+    if (i < _declared_nonstatic_fields->length()) {\n+      return _declared_nonstatic_fields->at(i);\n+    } else {\n+      \/\/ Look for field in preceding multi-field bundle;\n+      for (uint j = 0; j < (uint)i; j++) {\n+        int bundle_size = _declared_nonstatic_fields->at(j)->secondary_fields_count();\n+        if ((j + bundle_size) > (uint)i) {\n+          return static_cast<ciMultiField*>(_declared_nonstatic_fields->at(j))->secondary_fields()->at(i - (j + 1));\n+        }\n+      }\n+    }\n+    return NULL;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-      int  field_off = field->offset_in_bytes();\n+      int field_off = field->offset_in_bytes();\n@@ -428,0 +428,10 @@\n+      if (field->secondary_fields_count() > 1) {\n+        for (int j = 0; j < field->secondary_fields_count(); j++) {\n+          ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_fields()->at(j);\n+          int sec_field_offset = sec_field->offset_in_bytes();\n+          if (sec_field_offset == field_offset)\n+            return sec_field;\n+          if (sec_field_offset > field_offset)\n+            return NULL;\n+        }\n+      }\n@@ -534,0 +544,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -552,0 +563,7 @@\n+    if (fs.is_multifield()) {\n+      assert(fields->last()->is_multifield_base(), \"\");\n+      ciMultiField* multifield_base = static_cast<ciMultiField*>(fields->last());\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      multifield_base->secondary_fields()->append(new (arena) ciField(&fd));\n+      continue;\n+    }\n@@ -568,1 +586,7 @@\n-        ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        ciField* field = NULL;\n+        if (flattened_field->secondary_fields_count() > 1) {\n+          field = new (arena) ciMultiField(flattened_field, this, offset, is_final);\n+          static_cast<ciMultiField*>(field)->add_secondary_fields(static_cast<ciMultiField*>(flattened_field)->secondary_fields());\n+        } else {\n+          field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        }\n@@ -572,1 +596,8 @@\n-      ciField* field = new (arena) ciField(&fd);\n+      ciField* field = NULL;\n+      if (fs.is_multifield_base()) {\n+        field = new (arena) ciMultiField(&fd);\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, field->secondary_fields_count(), 0, NULL);\n+        static_cast<ciMultiField*>(field)->add_secondary_fields(sec_fields);\n+      } else {\n+        field = new (arena) ciField(&fd);\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  friend class ciMultiField;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-ciType::ciType(BasicType basic_type) : ciMetadata() {\n+ciType::ciType(BasicType basic_type, int bundle_size) : ciMetadata() {\n@@ -45,0 +45,1 @@\n+  _bundle_size = bundle_size;\n@@ -49,0 +50,1 @@\n+  _bundle_size = 1;\n@@ -109,7 +111,11 @@\n-ciType* ciType::make(BasicType t) {\n-  \/\/ short, etc.\n-  \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n-  assert((uint)t < T_CONFLICT+1, \"range check\");\n-  if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n-  assert(_basic_types[t] != NULL, \"domain check\");\n-  return _basic_types[t];\n+ciType* ciType::make(BasicType t, int bundle_size) {\n+  if (bundle_size == 1) {\n+    \/\/ short, etc.\n+    \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n+    assert((uint)t < T_CONFLICT+1, \"range check\");\n+    if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n+    assert(_basic_types[t] != NULL, \"domain check\");\n+    return _basic_types[t];\n+  } else {\n+    return new (CURRENT_ENV->arena()) ciType(t, bundle_size);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  int _bundle_size;\n@@ -43,1 +44,1 @@\n-  ciType(BasicType t);     \/\/ for primitive and unloaded types\n+  ciType(BasicType t, int bundle_size = 1);     \/\/ for primitive and unloaded types\n@@ -66,1 +67,2 @@\n-  int size() const                          { return type2size[basic_type()]; }\n+  int size() const                          { return _bundle_size * type2size[basic_type()]; }\n+  int bundle_size() const                   { return _bundle_size; }\n@@ -84,1 +86,1 @@\n-  static ciType* make(BasicType t);\n+  static ciType* make(BasicType t, int bundle_size = 1);\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -196,4 +196,24 @@\n-  do_klass(vector_VectorPayloadMF64_klass,              jdk_internal_vm_vector_VectorPayloadMF64              ) \\\n-  do_klass(vector_VectorPayloadMF128_klass,             jdk_internal_vm_vector_VectorPayloadMF128             ) \\\n-  do_klass(vector_VectorPayloadMF256_klass,             jdk_internal_vm_vector_VectorPayloadMF256             ) \\\n-  do_klass(vector_VectorPayloadMF512_klass,             jdk_internal_vm_vector_VectorPayloadMF512             ) \\\n+  do_klass(vector_VectorPayloadMF64B_klass,              jdk_internal_vm_vector_VectorPayloadMF64B              ) \\\n+  do_klass(vector_VectorPayloadMF128B_klass,             jdk_internal_vm_vector_VectorPayloadMF128B             ) \\\n+  do_klass(vector_VectorPayloadMF256B_klass,             jdk_internal_vm_vector_VectorPayloadMF256B             ) \\\n+  do_klass(vector_VectorPayloadMF512B_klass,             jdk_internal_vm_vector_VectorPayloadMF512B             ) \\\n+  do_klass(vector_VectorPayloadMF64S_klass,              jdk_internal_vm_vector_VectorPayloadMF64S              ) \\\n+  do_klass(vector_VectorPayloadMF128S_klass,             jdk_internal_vm_vector_VectorPayloadMF128S             ) \\\n+  do_klass(vector_VectorPayloadMF256S_klass,             jdk_internal_vm_vector_VectorPayloadMF256S             ) \\\n+  do_klass(vector_VectorPayloadMF512S_klass,             jdk_internal_vm_vector_VectorPayloadMF512S             ) \\\n+  do_klass(vector_VectorPayloadMF64I_klass,              jdk_internal_vm_vector_VectorPayloadMF64I              ) \\\n+  do_klass(vector_VectorPayloadMF128I_klass,             jdk_internal_vm_vector_VectorPayloadMF128I             ) \\\n+  do_klass(vector_VectorPayloadMF256I_klass,             jdk_internal_vm_vector_VectorPayloadMF256I             ) \\\n+  do_klass(vector_VectorPayloadMF512I_klass,             jdk_internal_vm_vector_VectorPayloadMF512I             ) \\\n+  do_klass(vector_VectorPayloadMF64L_klass,              jdk_internal_vm_vector_VectorPayloadMF64L              ) \\\n+  do_klass(vector_VectorPayloadMF128L_klass,             jdk_internal_vm_vector_VectorPayloadMF128L             ) \\\n+  do_klass(vector_VectorPayloadMF256L_klass,             jdk_internal_vm_vector_VectorPayloadMF256L             ) \\\n+  do_klass(vector_VectorPayloadMF512L_klass,             jdk_internal_vm_vector_VectorPayloadMF512L             ) \\\n+  do_klass(vector_VectorPayloadMF64F_klass,              jdk_internal_vm_vector_VectorPayloadMF64F              ) \\\n+  do_klass(vector_VectorPayloadMF128F_klass,             jdk_internal_vm_vector_VectorPayloadMF128F             ) \\\n+  do_klass(vector_VectorPayloadMF256F_klass,             jdk_internal_vm_vector_VectorPayloadMF256F             ) \\\n+  do_klass(vector_VectorPayloadMF512F_klass,             jdk_internal_vm_vector_VectorPayloadMF512F             ) \\\n+  do_klass(vector_VectorPayloadMF64D_klass,              jdk_internal_vm_vector_VectorPayloadMF64D              ) \\\n+  do_klass(vector_VectorPayloadMF128D_klass,             jdk_internal_vm_vector_VectorPayloadMF128D             ) \\\n+  do_klass(vector_VectorPayloadMF256D_klass,             jdk_internal_vm_vector_VectorPayloadMF256D             ) \\\n+  do_klass(vector_VectorPayloadMF512D_klass,             jdk_internal_vm_vector_VectorPayloadMF512D             ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -97,4 +97,24 @@\n-  template(jdk_internal_vm_vector_VectorPayloadMF64,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64\")  \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF128, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128\") \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF256, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256\") \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF512, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64S,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64I,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64L,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64F,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64D,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D\") \\\n@@ -102,0 +122,1 @@\n+  template(mfield_name,                               \"mfield\")                                   \\\n@@ -275,4 +296,24 @@\n-  template(vector_VectorPayloadMF64_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64;\")  \\\n-  template(vector_VectorPayloadMF128_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128;\") \\\n-  template(vector_VectorPayloadMF256_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256;\") \\\n-  template(vector_VectorPayloadMF512_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512;\") \\\n+  template(vector_VectorPayloadMF64B_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B;\")  \\\n+  template(vector_VectorPayloadMF128B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B;\") \\\n+  template(vector_VectorPayloadMF256B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B;\") \\\n+  template(vector_VectorPayloadMF512B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B;\") \\\n+  template(vector_VectorPayloadMF64S_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S;\")  \\\n+  template(vector_VectorPayloadMF128S_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S;\") \\\n+  template(vector_VectorPayloadMF256S_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S;\") \\\n+  template(vector_VectorPayloadMF512S_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S;\") \\\n+  template(vector_VectorPayloadMF64I_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I;\")  \\\n+  template(vector_VectorPayloadMF128I_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I;\") \\\n+  template(vector_VectorPayloadMF256I_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I;\") \\\n+  template(vector_VectorPayloadMF512I_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I;\") \\\n+  template(vector_VectorPayloadMF64L_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L;\")  \\\n+  template(vector_VectorPayloadMF128L_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L;\") \\\n+  template(vector_VectorPayloadMF256L_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L;\") \\\n+  template(vector_VectorPayloadMF512L_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L;\") \\\n+  template(vector_VectorPayloadMF64F_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F;\")  \\\n+  template(vector_VectorPayloadMF128F_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F;\") \\\n+  template(vector_VectorPayloadMF256F_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F;\") \\\n+  template(vector_VectorPayloadMF512F_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F;\") \\\n+  template(vector_VectorPayloadMF64D_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D;\")  \\\n+  template(vector_VectorPayloadMF128D_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D;\") \\\n+  template(vector_VectorPayloadMF256D_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D;\") \\\n+  template(vector_VectorPayloadMF512D_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -240,0 +241,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -334,1 +336,1 @@\n-  return InlineTypePassFieldsAsArgs;\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypePassFieldsAsArgs;\n@@ -339,1 +341,1 @@\n-  return InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -793,1 +793,4 @@\n-    if (vt != NULL) {\n+    \/\/ FIXME: VectorBoxes are neither scalarized nor buffered upfront, currently buffering happens during\n+    \/\/ box expansions if they are live after box-unbox optimizations. This can be optimized by removing\n+    \/\/ VectorBoxAllocation IR altogether.\n+    if (vt != NULL && !result->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2699,3 +2699,3 @@\n-  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n-  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n-  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, 1, igvn);\n+  Node* new_vect_phi = clone_through_phi(root_phi, vtype, 3, igvn);\n+  return VectorBoxNode::make_box_node(*igvn, igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2742,10 +2742,0 @@\n-  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n-  if (EnableVectorSupport && has_vbox_nodes()) {\n-    TracePhase tp(\"\", &timers[_t_vector]);\n-    PhaseVector pv(igvn);\n-    pv.optimize_vector_boxes();\n-\n-    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n-  }\n-  assert(!has_vbox_nodes(), \"sanity\");\n-\n@@ -2776,0 +2766,11 @@\n+  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n+  if (EnableVectorSupport && has_vbox_nodes()) {\n+    TracePhase tp(\"\", &timers[_t_vector]);\n+    PhaseVector pv(igvn);\n+    pv.optimize_vector_boxes();\n+\n+    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n+  }\n+  assert(!has_vbox_nodes(), \"sanity\");\n+\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"opto\/vectornode.hpp\"\n+\n@@ -48,0 +50,20 @@\n+void InlineTypeNode::expand_input_edges(ciInlineKlass * vk) {\n+  \/\/ We generally perform three operations on multi-field bundle, load its contents into vector,\n+  \/\/ store the contents of vector to multi-field bundle or broadcast a value into a vector equivalent\n+  \/\/ in size to a multi-field bundle. If any of these operations are not supported by target platform\n+  \/\/ scalarize the multi-fields into individual fields.\n+  for(int i = 0; i < vk->nof_declared_nonstatic_fields(); i++) {\n+    ciField* field = vk->declared_nonstatic_field_at(i);\n+    int field_count = field->secondary_fields_count();\n+    BasicType bt = field->type()->basic_type();\n+    if (field_count > 1 &&\n+        (!Matcher::match_rule_supported_vector(Op_LoadVector, field_count, bt) ||\n+        !Matcher::match_rule_supported_vector(Op_StoreVector, field_count, bt) ||\n+        !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), field_count, bt))) {\n+      while(--field_count) {\n+        add_req(NULL);\n+      }\n+    }\n+  }\n+}\n+\n@@ -87,0 +109,4 @@\n+      if (vt->is_multifield_base(i) &&\n+          Matcher::vector_size_supported(type->basic_type(), vt->secondary_fields_count(i))) {\n+        phi_type = TypeVect::make(phi_type, vt->secondary_fields_count(i));\n+      }\n@@ -236,0 +262,15 @@\n+int InlineTypeNode::secondary_fields_count(uint index) const {\n+  assert(is_multifield_base(index), \"non-multifield field at index\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->secondary_fields_count();\n+}\n+\n+bool InlineTypeNode::is_multifield(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield();\n+}\n+\n+bool InlineTypeNode::is_multifield_base(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield_base();\n+}\n+\n@@ -362,1 +403,0 @@\n-    int offset = holder_offset + field_offset(i);\n@@ -364,0 +404,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -393,0 +434,1 @@\n+        BasicType bt = type2field[ft->basic_type()];\n@@ -395,1 +437,0 @@\n-        BasicType bt = type2field[ft->basic_type()];\n@@ -401,1 +442,7 @@\n-        value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);\n+        int bundle_size = ft->bundle_size();\n+        bool load_bundle = bundle_size > 1 ? Matcher::match_rule_supported_vector(Op_LoadVector, bundle_size, bt): false;\n+        if (load_bundle) {\n+          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, bundle_size, bt));\n+        } else {\n+          value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);\n+        }\n@@ -427,0 +474,1 @@\n+  int field_idx = 0;\n@@ -428,1 +476,0 @@\n-    int offset = holder_offset + field_offset(i);\n@@ -431,0 +478,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -432,1 +480,0 @@\n-      \/\/ Recursively store the flattened inline type field\n@@ -434,0 +481,1 @@\n+        \/\/ Recursively store the flattened inline type field\n@@ -438,3 +486,1 @@\n-      \/\/ Store field value to memory\n-      const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());\n-      Node* adr = kit->basic_plus_adr(base, ptr, offset);\n+      int vec_len = ft->bundle_size();\n@@ -442,1 +488,0 @@\n-      assert(is_java_primitive(bt) || adr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n@@ -448,1 +493,9 @@\n-      kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);\n+      const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());\n+      Node* adr = kit->basic_plus_adr(base, ptr, offset);\n+      assert(is_java_primitive(bt) || adr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n+      if (value->bottom_type()->isa_vect()) {\n+        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, vec_len));\n+        kit->set_memory(store, adr_type);\n+      } else {\n+        kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);\n+      }\n@@ -554,0 +607,1 @@\n+  \/\/ Primitive objects are always null free.\n@@ -640,1 +694,5 @@\n-  if (is_default(phase) && inline_klass()->is_initialized() &&\n+  \/\/ An InlineTypeNode in larval state is up for updation and\n+  \/\/ should not be replaced by precomputed default oops.\n+  Node* alloc = AllocateNode::Ideal_allocation(oop, phase);\n+  bool is_larval_alloc = alloc && alloc->as_Allocate()->_larval == true;\n+  if (!is_larval_alloc && is_default(phase) && inline_klass()->is_initialized() &&\n@@ -647,1 +705,1 @@\n-  if (oop->isa_InlineType() && !phase->type(oop)->maybe_null()) {\n+  if (oop->isa_InlineType() && !oop->isa_VectorBox() && !phase->type(oop)->maybe_null()) {\n@@ -706,0 +764,14 @@\n+Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type) {\n+  Node* value = gvn.zerocon(field_type->basic_type());\n+  if (field_type->bundle_size() > 1)  {\n+    int vec_len = field_type->bundle_size();\n+    BasicType bt = field_type->basic_type();\n+    if (Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      value = gvn.transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field_type), false));\n+    } else {\n+      \/\/ scalar default value to match the bundle size will be returned in subsiquent calls to default_value.\n+    }\n+  }\n+  return value;\n+}\n+\n@@ -713,1 +785,1 @@\n-    Node* value = gvn.zerocon(field_type->basic_type());\n+    Node* value = default_value(gvn, field_type);\n@@ -745,1 +817,2 @@\n-    if (!gvn->type(value)->is_zero_type()) {\n+    if (!gvn->type(value)->is_zero_type() &&\n+        !VectorNode::is_all_zeros_vector(value)) {\n@@ -1025,1 +1098,0 @@\n-    ciType* type = field_type(i);\n@@ -1027,0 +1099,1 @@\n+    ciType* type = field_type(i);\n@@ -1033,1 +1106,19 @@\n-      if (multi->is_Start()) {\n+      if (type->bundle_size() > 1) {\n+        Node* not_null_oop =  NULL;\n+        ciInlineKlass* ik = inline_klass();\n+        if (multi->is_Call()) {\n+          if (in) {\n+            not_null_oop = multi->as_Call()->in(base_input);\n+          } else {\n+            not_null_oop =  multi->as_Call()->proj_out(TypeFunc::Parms);\n+          }\n+          assert(not_null_oop->bottom_type()->isa_instptr(), \"\");\n+          load(kit, not_null_oop, not_null_oop, ik, \/* holder_offset *\/ 0);\n+          parm = field_value(i);\n+        } else if (multi->is_Start()) {\n+          assert(in, \"return from start?\");\n+          parm = default_value(gvn, type);\n+        } else {\n+          assert(false, \"unhandled case\");\n+        }\n+      } else if (multi->is_Start()) {\n@@ -1051,1 +1142,1 @@\n-      base_input += type->size();\n+      base_input += (type->size() \/ type->bundle_size());\n@@ -1112,1 +1203,1 @@\n-    Node* value = gvn.zerocon(field_type->basic_type());\n+    Node* value = default_value(gvn, field_type);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":109,"deletions":18,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -46,0 +47,1 @@\n+    expand_input_edges(vk);\n@@ -57,2 +59,1 @@\n-  \/\/ Get the klass defining the field layout of the inline type\n-  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n+  void expand_input_edges(ciInlineKlass * vk);\n@@ -74,0 +75,2 @@\n+  \/\/ Get the klass defining the field layout of the inline type\n+  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n@@ -91,0 +94,2 @@\n+  static Node* default_value(PhaseGVN& gvn, ciType* field_type);\n+\n@@ -103,0 +108,1 @@\n+  bool  is_buffered() { return _is_buffered; }\n@@ -105,2 +111,4 @@\n-  uint          field_count() const { return req() - Values; }\n-  Node*         field_value(uint index) const;\n+  virtual uint  field_count() const { return req() - Values; }\n+  virtual Node* field_value(uint index) const;\n+  uint          field_index(int offset) const;\n+\n@@ -108,2 +116,3 @@\n-  void      set_field_value(uint index, Node* value);\n-  void      set_field_value_by_offset(int offset, Node* value);\n+  void          set_field_value(uint index, Node* value);\n+\n+  void          set_field_value_by_offset(int offset, Node* value);\n@@ -111,1 +120,4 @@\n-  uint          field_index(int offset) const;\n+  bool          is_multifield(uint index) const;\n+  bool          is_multifield_base(uint index) const;\n+  int           secondary_fields_count(uint index) const;\n+  bool          is_multifield() const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2320,0 +2320,2 @@\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(base, &_gvn);\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,3 @@\n-      if (C->inlining_incrementally() && res->is_InlineType()) {\n+      \/\/ VectorBoxes should be treated as special InlineTypeNodes, we will defer its buffering\n+      \/\/ to a later stage to give opportunity for consumption by subsequent expanders.\n+      if (C->inlining_incrementally() && res->is_InlineType() && !res->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+class VectorBoxNode;\n@@ -722,0 +723,1 @@\n+        DEFINE_CLASS_ID(VectorBox, InlineType, 0)\n@@ -955,0 +957,1 @@\n+  DEFINE_CLASS_QUERY(VectorBox)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -924,1 +924,5 @@\n-    if (tf()->returns_inline_type_as_fields()) {\n+    if (res->isa_InlineType() && VectorSupport::skip_value_scalarization(res->as_InlineType()->inline_klass())) {\n+      InlineTypeNode* vt = res->as_InlineType();\n+      assert(vt->is_buffered(), \"\");\n+      ret->add_req(vt->get_oop());\n+    } else if (tf()->returns_inline_type_as_fields()) {\n@@ -1137,1 +1141,1 @@\n-  \/\/ record exit from a method if compiled while Dtrace is turned on.\n+  \/\/ record exit from a method if compiled while Dtrace is returned on.\n@@ -2356,1 +2360,8 @@\n-      if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n+      if (VectorSupport::skip_value_scalarization(value->as_InlineType()->inline_klass())) {\n+        \/\/ Buffer the vector return types, for regular inline object caller expects\n+        \/\/ scalarized fields to be passed back.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        inc_sp(1);\n+        value = value->as_InlineType()->buffer(this);\n+      } else if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -371,1 +372,12 @@\n-  new_vt->set_field_value_by_offset(field->offset(), val);\n+\n+  BasicType bt = field->type()->basic_type();\n+  int vec_len = field->secondary_fields_count();\n+  bool scalarize_fields = !is_java_primitive(bt) || !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n+  if (scalarize_fields) {\n+    for(int i = 0; i < vec_len; i++) {\n+      new_vt->set_field_value_by_offset(field->offset() + i * type2aelembytes(bt), val);\n+    }\n+  } else {\n+    val = _gvn.transform(VectorNode::scalar2vector(val, field->secondary_fields_count(), Type::get_const_type(field->type()), false));\n+    new_vt->set_field_value_by_offset(field->offset(), val);\n+  }\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+#include \"prims\/vectorSupport.hpp\"\n+\n+static bool is_vector(ciKlass* klass) {\n+  return VectorSupport::is_vector(klass);\n+}\n@@ -36,1 +41,1 @@\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+  return VectorSupport::is_vector_mask(klass);\n@@ -40,1 +45,1 @@\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+  return VectorSupport::is_vector_shuffle(klass);\n@@ -43,1 +48,0 @@\n-\n@@ -182,1 +186,1 @@\n-  Node* vec_value = vec_box->in(VectorBoxNode::Value);\n+  Node* vec_value = vec_box->get_vec();\n@@ -193,1 +197,1 @@\n-        if (call->has_non_debug_use(vec_box) && vec_box->in(VectorBoxNode::Box)->is_Phi()) {\n+        if (call->has_non_debug_use(vec_box) && vec_box->get_oop()->is_Phi()) {\n@@ -217,1 +221,1 @@\n-        Node* vect = vec_box->in(VectorBoxNode::Value);\n+        Node* vect = vec_box->get_vec();\n@@ -241,0 +245,7 @@\n+  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n+  \/\/ Multi-field based vectors are InlineTypeNodes and are already\n+  \/\/ scalarized by process_inline_types.\n+  if (is_vector(iklass)) {\n+    return;\n+  }\n+\n@@ -261,1 +272,0 @@\n-  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n@@ -307,3 +317,3 @@\n-    Node* vbox = vec_box->in(VectorBoxNode::Box);\n-    Node* vect = vec_box->in(VectorBoxNode::Value);\n-    Node* result = expand_vbox_node_helper(vbox, vect, vec_box->box_type(), vec_box->vec_type());\n+    Node* vbox = vec_box->get_oop();\n+    Node* vect = vec_box->get_vec();\n+    Node* result = expand_vbox_node_helper(vec_box, vbox, vect, vec_box->box_type(), vec_box->vec_type());\n@@ -316,1 +326,2 @@\n-Node* PhaseVector::expand_vbox_node_helper(Node* vbox,\n+Node* PhaseVector::expand_vbox_node_helper(Node* vec_box,\n+                                           Node* vbox,\n@@ -324,1 +335,1 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect->in(i), box_type, vect_type);\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect->in(i), box_type, vect_type);\n@@ -339,1 +350,1 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect, box_type, vect_type);\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect, box_type, vect_type);\n@@ -346,1 +357,1 @@\n-    return expand_vbox_alloc_node(vbox_alloc, vect, box_type, vect_type);\n+    return expand_vbox_alloc_node(vec_box, vbox_alloc, vect, box_type, vect_type);\n@@ -354,1 +365,54 @@\n-Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n+Node* PhaseVector::expand_vbox_alloc_node_mf(Node* vbox,\n+                                             VectorBoxAllocateNode* vbox_alloc,\n+                                             Node* value,\n+                                             const TypeInstPtr* box_type,\n+                                             const TypeVect* vect_type) {\n+  assert(vbox->isa_InlineType(), \"\");\n+  JVMState* jvms = clone_jvms(C, vbox_alloc);\n+  GraphKit kit(jvms);\n+  PhaseGVN& gvn = kit.gvn();\n+\n+  ciInstanceKlass* box_klass = box_type->instance_klass();\n+  BasicType bt = vect_type->element_basic_type();\n+  int num_elem = vect_type->length();\n+  int elem_size = type2aelembytes(bt);\n+\n+  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n+  Node* klass_node = kit.makecon(klass_type);\n+  Node* buffer_mem = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true, vbox->as_InlineType());\n+  \/\/ TODO: Re-use existing value storage routine from InlineTypeNode.\n+  \/\/vbox->as_InlineType()->store(&kit, buffer, buffer, box_klass);\n+\n+  \/\/ Store the vector value into the array.\n+  \/\/ (The store should be captured by InitializeNode and turned into initialized store later.)\n+  ciSymbol* payload_sig = ciSymbol::make(VectorSupport::get_vector_payload_field_signature(bt, num_elem)->as_C_string());\n+  ciSymbol* payload_name = ciSymbol::make(vmSymbols::payload_name()->as_C_string());\n+  ciField* payload = box_klass->get_field_by_name(payload_name, payload_sig, false);\n+\n+  Node* buffer_start_adr = kit.basic_plus_adr(buffer_mem, payload->offset());\n+  const TypePtr* buffer_adr_type = buffer_start_adr->bottom_type()->is_ptr();\n+  Node* buffer_mem_start = kit.memory(buffer_start_adr);\n+  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n+                                                     kit.control(),\n+                                                     buffer_mem_start,\n+                                                     buffer_start_adr,\n+                                                     buffer_adr_type,\n+                                                     value,\n+                                                     num_elem));\n+  \/\/ TODO: With respect to aliasing behaviour multi-field alias type should be same as that of\n+  \/\/ array, since multi-field is a bundle of scalars. An alias type determines the size of\n+  \/\/ memory slice updated in global memory at a particular alias index, subsequent memory read\n+  \/\/ with same alias type can directly fetch the value thus saving an extra load operation.\n+  kit.set_memory(vstore, buffer_adr_type);\n+\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n+\n+  kit.replace_call(vbox_alloc, buffer_mem, true);\n+  C->remove_macro_node(vbox_alloc);\n+\n+  return buffer_mem;\n+}\n+\n+\n+Node* PhaseVector::expand_vbox_alloc_node(Node* vbox,\n+                                          VectorBoxAllocateNode* vbox_alloc,\n@@ -358,0 +422,5 @@\n+  ciInstanceKlass* box_klass = box_type->instance_klass();\n+  if (is_vector(box_klass)) {\n+    return expand_vbox_alloc_node_mf(vbox, vbox_alloc, value, box_type, vect_type);\n+  }\n+\n@@ -362,1 +431,0 @@\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n@@ -427,0 +495,58 @@\n+Node* PhaseVector::get_loaded_payload(VectorUnboxNode* vec_unbox) {\n+   Node* obj = vec_unbox->obj();\n+   while(obj->is_InlineType()) {\n+      obj = obj->as_InlineType()->field_value(0);\n+   }\n+   if (obj->bottom_type()->isa_vect()) {\n+     return obj;\n+   }\n+   return NULL;\n+}\n+\n+void PhaseVector::expand_vunbox_node_mf(VectorUnboxNode* vec_unbox) {\n+  if (vec_unbox->outcnt() > 0) {\n+    GraphKit kit;\n+    PhaseGVN& gvn = kit.gvn();\n+\n+    Node* obj = vec_unbox->obj();\n+    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n+    ciInstanceKlass* from_kls = tinst->instance_klass();\n+    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n+    BasicType bt = vt->element_basic_type();\n+    BasicType masktype = bt;\n+    int num_elem = vt->length();\n+\n+    int elem_size = type2aelembytes(bt);\n+    Node* vec_val_load = get_loaded_payload(vec_unbox);\n+    if (vec_val_load == NULL) {\n+      assert(obj->isa_InlineType(), \"\");\n+      ciSymbol* payload_sig = ciSymbol::make(VectorSupport::get_vector_payload_field_signature(bt, num_elem)->as_C_string());\n+      ciSymbol* payload_name = ciSymbol::make(vmSymbols::payload_name()->as_C_string());\n+      ciField* payload = from_kls->get_field_by_name(payload_name, payload_sig, false);\n+\n+      Node* mem = vec_unbox->mem();\n+      Node* ctrl = vec_unbox->in(0);\n+      Node* vec_adr = gvn.transform(kit.basic_plus_adr(obj, payload->offset()));\n+\n+      const TypePtr *adr_type = gvn.type(vec_adr)->isa_ptr();\n+\n+      int num_elem = vt->length();\n+      vec_val_load = LoadVectorNode::make(0,\n+                                          ctrl,\n+                                          mem,\n+                                          vec_adr,\n+                                          adr_type,\n+                                          num_elem,\n+                                          bt);\n+      vec_val_load = gvn.transform(vec_val_load);\n+    }\n+\n+    C->set_max_vector_size(MAX2(C->max_vector_size(), vt->length_in_bytes()));\n+\n+    gvn.hash_delete(vec_unbox);\n+    vec_unbox->disconnect_inputs(C);\n+    C->gvn_replace_by(vec_unbox, vec_val_load);\n+  }\n+  C->remove_macro_node(vec_unbox);\n+}\n+\n@@ -439,0 +565,4 @@\n+    if (is_vector(from_kls)) {\n+      return expand_vunbox_node_mf(vec_unbox);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":146,"deletions":16,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+                                Node* vbox_alloc,\n@@ -43,1 +44,2 @@\n-  Node* expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n+  Node* expand_vbox_alloc_node(Node* vbox,\n+                               VectorBoxAllocateNode* vbox_alloc,\n@@ -47,0 +49,7 @@\n+  Node* expand_vbox_alloc_node_mf(Node* vbox,\n+                                  VectorBoxAllocateNode* vbox_alloc,\n+                                  Node* value,\n+                                  const TypeInstPtr* box_type,\n+                                  const TypeVect* vect_type);\n+  Node* get_loaded_payload(VectorUnboxNode* vec_unbox);\n+\n@@ -51,0 +60,1 @@\n+  void expand_vunbox_node_mf(VectorUnboxNode* vec_unbox);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,4 +34,3 @@\n-#ifdef ASSERT\n-static bool is_vector(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n-}\n+static bool is_vector(ciKlass* kls) { return VectorSupport::is_vector(kls); }\n+static bool is_vector_mask(ciKlass* kls) { return VectorSupport::is_vector_mask(kls); }\n+static bool is_vector_shuffle(ciKlass* kls) { return VectorSupport::is_vector_shuffle(kls); }\n@@ -39,0 +38,1 @@\n+#ifdef ASSERT\n@@ -43,1 +43,1 @@\n-  assert(is_vector(ik), \"not a vector\");\n+  assert(VectorSupport::is_vector(ik), \"not a vector\");\n@@ -62,8 +62,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -160,1 +152,1 @@\n-  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vt);\n+  Node* vbox = VectorBoxNode::make_box_node(gvn(), C, ret, vector, vbox_type, vt);\n@@ -173,0 +165,4 @@\n+  \/\/ TODO[valhalla] Limiting support to only vectors cases untill mask and shuffle becomes inline types.\n+  if (!is_vector(vbox_type->instance_klass())) {\n+    return NULL;\n+  }\n@@ -794,0 +790,3 @@\n+  if (shuffle_vec == NULL) {\n+    return false;\n+  }\n@@ -857,0 +856,5 @@\n+  bool is_shuffle = is_vector_shuffle(vbox_klass);\n+  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n+  if (is_mask || is_shuffle) {\n+    return false;\n+  }\n@@ -998,0 +1002,5 @@\n+  bool is_shuffle = is_vector_shuffle(vbox_klass);\n+  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n+  if (is_mask || is_shuffle) {\n+    return false;\n+  }\n@@ -1963,1 +1972,2 @@\n-  if (is_masked_op && mask == NULL) {\n+  \/\/ TODO[valhalla] Preveting intrinsification untill mask becomes inline type.\n+  if (true || is_masked_op && mask == NULL) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -857,0 +858,4 @@\n+  case Op_ReplicateF:\n+    return n->in(1)->bottom_type() == TypeF::ONE;\n+  case Op_ReplicateD:\n+    return n->in(1)->bottom_type() == TypeD::ONE;\n@@ -871,0 +876,4 @@\n+  case Op_ReplicateF:\n+    return n->in(1)->bottom_type() == TypeF::ZERO;\n+  case Op_ReplicateD:\n+    return n->in(1)->bottom_type() == TypeD::ZERO;\n@@ -1626,1 +1635,5 @@\n-  Node* n = obj()->uncast();\n+  Node* n = obj();\n+  if (n->is_InlineType() && !n->is_VectorBox()) {\n+    n = n->as_InlineType()->get_oop();\n+  }\n+  n = n->uncast();\n@@ -1628,1 +1641,1 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n+    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n@@ -1637,1 +1650,1 @@\n-        Node* value = vbox->in(VectorBoxNode::Value);\n+        Node* value = vbox->field_value(0);\n@@ -1663,1 +1676,5 @@\n-  Node* n = obj()->uncast();\n+  Node* n = obj();\n+  if (n->is_InlineType() && !n->is_VectorBox()) {\n+    n = n->as_InlineType()->get_oop();\n+  }\n+  n = n->uncast();\n@@ -1665,2 +1682,2 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n-      return n->in(VectorBoxNode::Value); \/\/ VectorUnbox (VectorBox v) ==> v\n+    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n+      return n->as_VectorBox()->get_vec(); \/\/ VectorUnbox (VectorBox v) ==> v\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1668,1 +1669,1 @@\n-class VectorBoxNode : public Node {\n+class VectorBoxNode : public InlineTypeNode {\n@@ -1670,12 +1671,23 @@\n-  const TypeInstPtr* const _box_type;\n-  const TypeVect*    const _vec_type;\n- public:\n-  enum {\n-     Box   = 1,\n-     Value = 2\n-  };\n-  VectorBoxNode(Compile* C, Node* box, Node* val,\n-                const TypeInstPtr* box_type, const TypeVect* vt)\n-    : Node(NULL, box, val), _box_type(box_type), _vec_type(vt) {\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n+  const TypeInstPtr* _box_type;\n+  const TypeVect*    _vec_type;\n+\n+ public:\n+  void set_box_type(const TypeInstPtr* box_type) { _box_type = box_type; }\n+  void set_vec_type(const TypeVect* vec_type) { _vec_type = vec_type; }\n+\n+  VectorBoxNode(ciInlineKlass* vk, Node* oop, bool null_free, bool is_buffered) :\n+    InlineTypeNode(vk, oop, null_free, is_buffered) {}\n+\n+  static VectorBoxNode* make_box_node(PhaseGVN& gvn, Compile* C, Node* box, Node* val,\n+                                      const TypeInstPtr* box_type, const TypeVect* vt) {\n+    ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+    VectorBoxNode* box_node = new VectorBoxNode(vk, box, true, vk->is_empty() && vk->is_initialized());\n+    box_node->set_is_init(gvn);\n+    box_node->set_vec_type(vt);\n+    box_node->set_box_type(box_type);\n+    box_node->init_flags(Flag_is_macro);\n+    box_node->init_class_id(Class_VectorBox);\n+    box_node->init_req(InlineTypeNode::Values, val);\n+    C->add_macro_node(box_node);\n+\n+    return box_node;\n@@ -1686,0 +1698,1 @@\n+  Node*  get_vec() { return field_value(0); }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmClassMacros.hpp\"\n@@ -41,0 +42,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -68,0 +70,5 @@\n+\n+bool VectorSupport::is_vector(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n+}\n+\n@@ -69,1 +76,13 @@\n-  return klass->is_subclass_of(vmClasses::vector_VectorPayload_klass());\n+  return klass->is_subclass_of(vmClasses::vector_Vector_klass());\n+}\n+\n+bool VectorSupport::is_vector_payload_mf(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayloadMF_klass());\n+}\n+\n+bool VectorSupport::is_vector_payload_mf(Klass* klass) {\n+  return klass->is_subclass_of(vmClasses::vector_VectorPayloadMF_klass());\n+}\n+\n+bool VectorSupport::is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n@@ -76,0 +95,4 @@\n+bool VectorSupport::is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n@@ -80,0 +103,8 @@\n+bool VectorSupport::skip_value_scalarization(ciKlass* klass) {\n+  return VectorSupport::is_vector(klass) || VectorSupport::is_vector_payload_mf(klass);\n+}\n+\n+bool VectorSupport::skip_value_scalarization(Klass* klass) {\n+  return VectorSupport::is_vector(klass) || VectorSupport::is_vector_payload_mf(klass);\n+}\n+\n@@ -135,3 +166,1 @@\n-Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS) {\n-  int num_elem = klass2length(ik);\n-  BasicType elem_bt = klass2bt(ik);\n+Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, Location location, TRAPS) {\n@@ -140,0 +169,2 @@\n+  \/\/ FIXME: Existing handling is used for shuffles and mask classes, to be removed after\n+  \/\/ complete support.\n@@ -141,3 +172,3 @@\n-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n-\n-  typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n+  if (is_vector_shuffle(ik) || is_vector_mask(ik)) {\n+    TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n+    typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n@@ -145,3 +176,3 @@\n-  if (location.is_register()) {\n-    \/\/ Value was in a callee-saved register.\n-    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+    if (location.is_register()) {\n+      \/\/ Value was in a callee-saved register.\n+      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n@@ -149,3 +180,3 @@\n-    for (int i = 0; i < num_elem; i++) {\n-      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+      for (int i = 0; i < num_elem; i++) {\n+        int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n@@ -153,2 +184,9 @@\n-      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-      init_payload_element(arr, elem_bt, i, elem_addr);\n+        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+        init_payload_element(arr, elem_bt, i, elem_addr);\n+      }\n+    } else {\n+      \/\/ Value was directly saved on the stack.\n+      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+      for (int i = 0; i < num_elem; i++) {\n+        init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n+      }\n@@ -156,0 +194,1 @@\n+    return Handle(THREAD, arr);\n@@ -157,4 +196,27 @@\n-    \/\/ Value was directly saved on the stack.\n-    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n-    for (int i = 0; i < num_elem; i++) {\n-      init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n+    \/\/ On-heap vector values are represented as primitive class instances with a multi-field payload.\n+    InstanceKlass* payload_kls = get_vector_payload_klass(elem_bt, num_elem);\n+    assert(payload_kls->is_inline_klass(), \"\");\n+    instanceOop obj = InlineKlass::cast(payload_kls)->allocate_instance(THREAD);\n+\n+    fieldDescriptor fd;\n+    Klass* def = payload_kls->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(T_BYTE), false, &fd);\n+    assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == num_elem, \"\");\n+\n+    int ffo = InlineKlass::cast(payload_kls)->first_field_offset();\n+\n+    if (location.is_register()) {\n+      \/\/ Value was in a callee-saved register.\n+      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+      int vec_size = num_elem * elem_size;\n+      for (int i = 0; i < vec_size; i++) {\n+        int vslot = i \/ VMRegImpl::stack_slot_size;\n+        int off   = i % VMRegImpl::stack_slot_size;\n+        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+        obj->byte_field_put(ffo + i, *(jbyte*)elem_addr);\n+      }\n+    } else {\n+      \/\/ Value was directly saved on the stack.\n+      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+      for (int i = 0; i < elem_size * num_elem; i++) {\n+        obj->byte_field_put(ffo + i, *(jbyte*)(base_addr + i));\n+      }\n@@ -162,0 +224,112 @@\n+    return Handle(THREAD, obj);\n+  }\n+}\n+\n+Symbol* VectorSupport::get_vector_payload_field_signature(BasicType elem_bt, int num_elem) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      switch(num_elem) {\n+        case  8: return vmSymbols::vector_VectorPayloadMF64B_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF128B_signature();\n+        case 32: return vmSymbols::vector_VectorPayloadMF256B_signature();\n+        case 64: return vmSymbols::vector_VectorPayloadMF512B_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_SHORT:\n+      switch(num_elem) {\n+        case  4: return vmSymbols::vector_VectorPayloadMF64S_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF128S_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF256S_signature();\n+        case 32: return vmSymbols::vector_VectorPayloadMF512S_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_INT:\n+      switch(num_elem) {\n+        case  2: return vmSymbols::vector_VectorPayloadMF64I_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF128I_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF256I_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF512I_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_LONG:\n+      switch(num_elem) {\n+        case  1: return vmSymbols::vector_VectorPayloadMF64L_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF128L_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF256L_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF512L_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_FLOAT:\n+      switch(num_elem) {\n+        case  2: return vmSymbols::vector_VectorPayloadMF64F_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF128F_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF256F_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF512F_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_DOUBLE:\n+      switch(num_elem) {\n+        case  1: return vmSymbols::vector_VectorPayloadMF64D_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF128D_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF256D_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF512D_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+     default:\n+        ShouldNotReachHere();\n+  }\n+  return NULL;\n+}\n+\n+InstanceKlass* VectorSupport::get_vector_payload_klass(BasicType elem_bt, int num_elem) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      switch(num_elem) {\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64B_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128B_klass));\n+        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256B_klass));\n+        case 64: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512B_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_SHORT:\n+      switch(num_elem) {\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64S_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128S_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256S_klass));\n+        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512S_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_INT:\n+      switch(num_elem) {\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64I_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128I_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256I_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512I_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_LONG:\n+      switch(num_elem) {\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64L_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128L_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256L_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512L_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_FLOAT:\n+      switch(num_elem) {\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64F_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128F_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256F_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512F_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_DOUBLE:\n+      switch(num_elem) {\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64D_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128D_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256D_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512D_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    default:\n+        ShouldNotReachHere();\n@@ -163,1 +337,1 @@\n-  return Handle(THREAD, arr);\n+  return NULL;\n@@ -166,1 +340,1 @@\n-Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS) {\n+Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS) {\n@@ -170,2 +344,2 @@\n-      \/\/ Vector value in an aligned adjacent tuple (1, 2, 4, 8, or 16 slots).\n-      return allocate_vector_payload_helper(ik, fr, reg_map, location, THREAD); \/\/ safepoint\n+      \/\/ Vector payload value in an aligned adjacent tuple (8, 16, 32 or 64 bytes).\n+      return allocate_vector_payload_helper(ik, num_elem, T_BYTE, fr, reg_map, location, THREAD); \/\/ safepoint\n@@ -190,0 +364,11 @@\n+instanceOop VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n+  assert(is_vector_payload_mf(ik), \"%s not a vector payload\", ik->name()->as_C_string());\n+  assert(ov->field_size() == 1, \"%s not a vector\", ik->name()->as_C_string());\n+  assert(ik->is_inline_klass(), \"\");\n+\n+  ScopeValue* payload_value = ov->field_at(0);\n+  int num_elem = InlineKlass::cast(ik)->get_exact_size_in_bytes();\n+  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, num_elem, T_BYTE, fr, reg_map, payload_value, CHECK_NULL);\n+  return (instanceOop)payload_instance();\n+}\n+\n@@ -193,0 +378,1 @@\n+  assert(ik->is_inline_klass(), \"\");\n@@ -194,0 +380,2 @@\n+  int num_elem = klass2length(ik);\n+  BasicType elem_bt = klass2bt(ik);\n@@ -195,3 +383,16 @@\n-  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, fr, reg_map, payload_value, CHECK_NULL);\n-  instanceOop vbox = ik->allocate_instance(CHECK_NULL);\n-  vector_VectorPayload::set_payload(vbox, payload_instance());\n+  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, num_elem, elem_bt, fr, reg_map, payload_value, CHECK_NULL);\n+  instanceOop vbox = ik->allocate_instance(THREAD);\n+  Handle vbox_h = Handle(THREAD, vbox);\n+\n+  fieldDescriptor fd;\n+  int elem_size = type2aelembytes(elem_bt);\n+  Symbol* payload_sig = VectorSupport::get_vector_payload_field_signature(elem_bt, num_elem);\n+  Klass* def = ik->find_field(vmSymbols::payload_name(), payload_sig, false, &fd);\n+  assert(def != NULL, \"\");\n+\n+  if (fd.is_inlined()) {\n+    InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(fd.index()));\n+    field_ik->write_inlined_field(vbox_h(), fd.offset(), payload_instance(), THREAD);\n+  } else {\n+    vbox_h()->obj_field_put(fd.offset(), payload_instance());\n+  }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":227,"deletions":26,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"ci\/ciKlass.hpp\"\n@@ -41,2 +42,2 @@\n-  static Handle allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS);\n-  static Handle allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS);\n+  static Handle allocate_vector_payload_helper(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, Location location, TRAPS);\n+  static Handle allocate_vector_payload(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS);\n@@ -147,0 +148,4 @@\n+  static instanceOop allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n+\n+  static InstanceKlass* get_vector_payload_klass(BasicType elem_bt, int num_elem);\n+  static Symbol* get_vector_payload_field_signature(BasicType elem_bt, int num_elem);\n@@ -149,0 +154,3 @@\n+  static bool is_vector(ciKlass* klass);\n+  static bool is_vector_payload_mf(Klass* klass);\n+  static bool is_vector_payload_mf(ciKlass* klass);\n@@ -150,0 +158,1 @@\n+  static bool is_vector_mask(ciKlass* klass);\n@@ -151,0 +160,3 @@\n+  static bool is_vector_shuffle(ciKlass* klass);\n+  static bool skip_value_scalarization(ciKlass* klass);\n+  static bool skip_value_scalarization(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1146,0 +1146,2 @@\n+        } else if (EnableVectorSupport && VectorSupport::is_vector_payload_mf(ik)) {\n+          obj = VectorSupport::allocate_vector_payload(ik, fr, reg_map, sv, THREAD);\n@@ -1393,1 +1395,1 @@\n-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.access_flags().is_internal())) {\n+      if (!fs.access_flags().is_static() && !fs.is_multifield() && (!skip_internal || !fs.access_flags().is_internal())) {\n@@ -1546,1 +1548,1 @@\n-    if (EnableVectorSupport && VectorSupport::is_vector(k)) {\n+    if (EnableVectorSupport && (VectorSupport::is_vector(k) || VectorSupport::is_vector_payload_mf(k))) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  inline bool is_multifield_base()       const;\n@@ -96,0 +97,2 @@\n+  inline int secondary_fields_count(int base_idx) const;\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); };\n+inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); }\n+inline bool fieldDescriptor::is_multifield_base() const { return field()->is_multifield_base(); }\n@@ -92,1 +93,15 @@\n-#endif \/\/ SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP\n\\ No newline at end of file\n+inline int fieldDescriptor::secondary_fields_count(int base_idx) const {\n+  Array<MultiFieldInfo>* multifield_info = field_holder()->multifield_info();\n+  if (!is_multifield_base() || NULL == multifield_info) {\n+    return 1;\n+  }\n+  int sec_fields_count = 1;\n+  for (int i = 0; i < multifield_info->length(); i++) {\n+    if (field_holder()->multifield_info(i).base_index() == base_idx) {\n+      sec_fields_count++;\n+    }\n+  }\n+  return  sec_fields_count;\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -640,0 +641,3 @@\n+JRT_LEAF(jint, SharedRuntime::is_vector_value_instance(InlineKlass* klass))\n+  return (jint)VectorSupport::skip_value_scalarization(klass);\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+  static int is_vector_value_instance(InlineKlass* klass);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/MultiField.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/MultiField.java","status":"renamed"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -188,1 +189,2 @@\n-        private static VectorPayloadMF newInstanceFactory(int elemSize, int length)  {\n+        @ForceInline\n+        private static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n@@ -190,7 +192,48 @@\n-            int vecSize = elemSize * length;\n-            switch(vecSize) {\n-                case 8: obj = new VectorPayloadMF64(); break;\n-                case 16: obj = new VectorPayloadMF128(); break;\n-                case 32: obj = new VectorPayloadMF256(); break;\n-                case 64: obj = new VectorPayloadMF512(); break;\n-                default: assert false : \"Unhandled vector size\";\n+            if (elemType == byte.class) {\n+                switch(length) {\n+                    case  8: obj = new VectorPayloadMF64B(); break;\n+                    case 16: obj = new VectorPayloadMF128B(); break;\n+                    case 32: obj = new VectorPayloadMF256B(); break;\n+                    case 64: obj = new VectorPayloadMF512B(); break;\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == short.class) {\n+                switch(length) {\n+                    case  4: obj = new VectorPayloadMF64S(); break;\n+                    case  8: obj = new VectorPayloadMF128S(); break;\n+                    case 16: obj = new VectorPayloadMF256S(); break;\n+                    case 32: obj = new VectorPayloadMF512S(); break;\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == int.class) {\n+                switch(length) {\n+                    case  2: obj = new VectorPayloadMF64I(); break;\n+                    case  4: obj = new VectorPayloadMF128I(); break;\n+                    case  8: obj = new VectorPayloadMF256I(); break;\n+                    case 16: obj = new VectorPayloadMF512I(); break;\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == long.class) {\n+                switch(length) {\n+                    case  1: obj = new VectorPayloadMF64L(); break;\n+                    case  2: obj = new VectorPayloadMF128L(); break;\n+                    case  4: obj = new VectorPayloadMF256L(); break;\n+                    case  8: obj = new VectorPayloadMF512L(); break;\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == float.class) {\n+                switch(length) {\n+                    case  2: obj = new VectorPayloadMF64F(); break;\n+                    case  4: obj = new VectorPayloadMF128F(); break;\n+                    case  8: obj = new VectorPayloadMF256F(); break;\n+                    case 16: obj = new VectorPayloadMF512F(); break;\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == double.class) {\n+                switch(length) {\n+                    case  1: obj = new VectorPayloadMF64D(); break;\n+                    case  2: obj = new VectorPayloadMF128D(); break;\n+                    case  4: obj = new VectorPayloadMF256D(); break;\n+                    case  8: obj = new VectorPayloadMF512D(); break;\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n@@ -201,2 +244,3 @@\n-        public static VectorPayloadMF createVectPayloadInstance(int elemSize, int length) {\n-            return newInstanceFactory(elemSize, length);\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstance(Class<?> elemType, int length) {\n+            return newInstanceFactory(elemType, length);\n@@ -205,3 +249,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceB(int elemSize, int length, byte [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(byte.class, length);\n@@ -209,0 +253,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -216,3 +261,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceS(int elemSize, int length, short [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(short.class, length);\n@@ -220,0 +265,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -227,3 +273,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceI(int elemSize, int length, int [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(int.class, length);\n@@ -231,0 +277,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -238,3 +285,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceL(int elemSize, int length, long [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(long.class, length);\n@@ -242,0 +289,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -249,3 +297,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceF(int elemSize, int length, float [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(float.class, length);\n@@ -253,0 +301,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -260,3 +309,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceD(int elemSize, int length, double [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(double.class, length);\n@@ -264,0 +313,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -297,1 +347,1 @@\n-    public primitive static class VectorPayloadMF64 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF64B extends VectorPayloadMF {\n@@ -300,1 +350,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);\n@@ -306,1 +356,1 @@\n-    public primitive static class VectorPayloadMF128 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF128B extends VectorPayloadMF {\n@@ -309,1 +359,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);\n@@ -315,1 +365,1 @@\n-    public primitive static class VectorPayloadMF256 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF256B extends VectorPayloadMF {\n@@ -318,1 +368,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);\n@@ -324,1 +374,1 @@\n-    public primitive static class VectorPayloadMF512 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF512B extends VectorPayloadMF {\n@@ -327,1 +377,154 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64S extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128S extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256S extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512S extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64I extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128I extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256I extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512I extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64L extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128L extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256L extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512L extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64F extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128F extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256F extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512F extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64D extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);\n@@ -333,0 +536,26 @@\n+    public primitive static class VectorPayloadMF128D extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256D extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512D extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":265,"deletions":36,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+\n@@ -327,0 +328,1 @@\n+    @ForceInline\n@@ -335,0 +337,1 @@\n+    @ForceInline\n@@ -339,1 +342,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(elementByteSize(), laneCount, (float[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(laneCount, (float[])initarr);\n@@ -342,1 +345,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(elementByteSize(), laneCount, (double[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(laneCount, (double[])initarr);\n@@ -345,1 +348,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(elementByteSize(), laneCount, (byte[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(laneCount, (byte[])initarr);\n@@ -348,1 +351,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(elementByteSize(), laneCount, (short[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(laneCount, (short[])initarr);\n@@ -351,1 +354,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(elementByteSize(), laneCount, (int[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(laneCount, (int[])initarr);\n@@ -354,1 +357,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(elementByteSize(), laneCount, (long[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(laneCount, (long[])initarr);\n@@ -363,0 +366,1 @@\n+    @ForceInline\n@@ -372,1 +376,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementByteSize(), laneCount);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementType(), laneCount);\n@@ -383,0 +387,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorSupport.VectorPayloadMF128B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorSupport.VectorPayloadMF128B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 16));\n-    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 16, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 16));\n+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorSupport.VectorPayloadMF256B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorSupport.VectorPayloadMF256B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 32));\n-    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 32, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 32));\n+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorSupport.VectorPayloadMF512B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorSupport.VectorPayloadMF512B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 64));\n-    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 64, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 64));\n+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorSupport.VectorPayloadMF64B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorSupport.VectorPayloadMF64B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 8));\n-    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 8, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 8));\n+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n@@ -394,1 +394,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n@@ -420,1 +420,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n@@ -438,1 +438,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorSupport.VectorPayloadMF128D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorSupport.VectorPayloadMF128D)value;\n@@ -75,2 +75,2 @@\n-    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 2));\n-    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 2, (double [])(VSPECIES.iotaArray())));\n+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 2));\n+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorSupport.VectorPayloadMF256D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorSupport.VectorPayloadMF256D)value;\n@@ -75,2 +75,2 @@\n-    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 4));\n-    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 4, (double [])(VSPECIES.iotaArray())));\n+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 4));\n+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorSupport.VectorPayloadMF512D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorSupport.VectorPayloadMF512D)value;\n@@ -75,2 +75,2 @@\n-    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 8));\n-    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 8, (double [])(VSPECIES.iotaArray())));\n+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 8));\n+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorSupport.VectorPayloadMF64D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorSupport.VectorPayloadMF64D)value;\n@@ -75,2 +75,2 @@\n-    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 1));\n-    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 1, (double [])(VSPECIES.iotaArray())));\n+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 1));\n+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n@@ -394,1 +394,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n@@ -420,1 +420,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n@@ -438,1 +438,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorSupport.VectorPayloadMF128F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorSupport.VectorPayloadMF128F)value;\n@@ -75,2 +75,2 @@\n-    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 4));\n-    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 4, (float [])(VSPECIES.iotaArray())));\n+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 4));\n+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorSupport.VectorPayloadMF256F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorSupport.VectorPayloadMF256F)value;\n@@ -75,2 +75,2 @@\n-    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 8));\n-    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 8, (float [])(VSPECIES.iotaArray())));\n+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 8));\n+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorSupport.VectorPayloadMF512F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorSupport.VectorPayloadMF512F)value;\n@@ -75,2 +75,2 @@\n-    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 16));\n-    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 16, (float [])(VSPECIES.iotaArray())));\n+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 16));\n+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorSupport.VectorPayloadMF64F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorSupport.VectorPayloadMF64F)value;\n@@ -75,2 +75,2 @@\n-    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 2));\n-    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 2, (float [])(VSPECIES.iotaArray())));\n+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 2));\n+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n@@ -394,1 +394,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n@@ -420,1 +420,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n@@ -438,1 +438,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorSupport.VectorPayloadMF128I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorSupport.VectorPayloadMF128I)value;\n@@ -75,2 +75,2 @@\n-    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 4));\n-    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 4, (int [])(VSPECIES.iotaArray())));\n+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 4));\n+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorSupport.VectorPayloadMF256I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorSupport.VectorPayloadMF256I)value;\n@@ -75,2 +75,2 @@\n-    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 8));\n-    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 8, (int [])(VSPECIES.iotaArray())));\n+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 8));\n+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorSupport.VectorPayloadMF512I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorSupport.VectorPayloadMF512I)value;\n@@ -75,2 +75,2 @@\n-    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 16));\n-    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 16, (int [])(VSPECIES.iotaArray())));\n+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 16));\n+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorSupport.VectorPayloadMF64I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorSupport.VectorPayloadMF64I)value;\n@@ -75,2 +75,2 @@\n-    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 2));\n-    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 2, (int [])(VSPECIES.iotaArray())));\n+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 2));\n+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n@@ -394,1 +394,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n@@ -420,1 +420,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n@@ -438,1 +438,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorSupport.VectorPayloadMF128L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorSupport.VectorPayloadMF128L)value;\n@@ -75,2 +75,2 @@\n-    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 2));\n-    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 2, (long [])(VSPECIES.iotaArray())));\n+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 2));\n+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorSupport.VectorPayloadMF256L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorSupport.VectorPayloadMF256L)value;\n@@ -75,2 +75,2 @@\n-    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 4));\n-    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 4, (long [])(VSPECIES.iotaArray())));\n+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 4));\n+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorSupport.VectorPayloadMF512L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorSupport.VectorPayloadMF512L)value;\n@@ -75,2 +75,2 @@\n-    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 8));\n-    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 8, (long [])(VSPECIES.iotaArray())));\n+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 8));\n+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorSupport.VectorPayloadMF64L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorSupport.VectorPayloadMF64L)value;\n@@ -75,2 +75,2 @@\n-    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 1));\n-    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 1, (long [])(VSPECIES.iotaArray())));\n+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 1));\n+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n@@ -394,1 +394,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n@@ -420,1 +420,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n@@ -438,1 +438,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorSupport.VectorPayloadMF128S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorSupport.VectorPayloadMF128S)value;\n@@ -75,2 +75,2 @@\n-    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 8));\n-    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 8, (short [])(VSPECIES.iotaArray())));\n+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 8));\n+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorSupport.VectorPayloadMF256S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorSupport.VectorPayloadMF256S)value;\n@@ -75,2 +75,2 @@\n-    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 16));\n-    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 16, (short [])(VSPECIES.iotaArray())));\n+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 16));\n+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorSupport.VectorPayloadMF512S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorSupport.VectorPayloadMF512S)value;\n@@ -75,2 +75,2 @@\n-    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 32));\n-    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 32, (short [])(VSPECIES.iotaArray())));\n+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 32));\n+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorSupport.VectorPayloadMF64S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorSupport.VectorPayloadMF64S)value;\n@@ -75,2 +75,2 @@\n-    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 4));\n-    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 4, (short [])(VSPECIES.iotaArray())));\n+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 4));\n+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n@@ -394,1 +394,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n@@ -420,1 +420,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n@@ -438,1 +438,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n@@ -398,1 +398,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n@@ -424,1 +424,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n@@ -442,1 +442,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF$bits$.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF$bits$$Boxinitials$.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF$bits$ payload;\n+    private final VectorSupport.VectorPayloadMF$bits$$Boxinitials$ payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF$bits$)value;\n+        this.payload = (VectorSupport.VectorPayloadMF$bits$$Boxinitials$)value;\n@@ -75,2 +75,2 @@\n-    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.createVectPayloadInstance($Boxtype$.BYTES, $numLanes$));\n-    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($Boxtype$.BYTES, $numLanes$, ($type$ [])(VSPECIES.iotaArray())));\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.createVectPayloadInstance($type$.class, $numLanes$));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$ [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}