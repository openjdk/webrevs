{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -43,0 +44,1 @@\n+  friend class ciMultiField;\n@@ -206,0 +208,16 @@\n+class ciMultiField : public ciField {\n+private:\n+  CI_PACKAGE_ACCESS\n+  friend class ciInstanceKlass;\n+\n+  GrowableArray<ciField*>*   _secondary_fields;\n+\n+  ciMultiField(ciInstanceKlass* klass, int index) : ciField(klass, index) {}\n+  ciMultiField(fieldDescriptor* fd) : ciField(fd) {}\n+  ciMultiField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) :\n+       ciField(field, holder, offset, is_final) {}\n+public:\n+  void add_secondary_fields(GrowableArray<ciField*>* fields) { _secondary_fields = fields; }\n+  GrowableArray<ciField*>* secondary_fields() { return _secondary_fields; }\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"ci\/ciField.hpp\"\n@@ -73,1 +74,12 @@\n-    return _declared_nonstatic_fields->at(i);\n+    if (i < _declared_nonstatic_fields->length()) {\n+      return _declared_nonstatic_fields->at(i);\n+    } else {\n+      \/\/ Look for field in preceding multi-field bundle;\n+      for (uint j = 0; j < (uint)i; j++) {\n+        int bundle_size = _declared_nonstatic_fields->at(j)->secondary_fields_count();\n+        if ((j + bundle_size) > (uint)i) {\n+          return static_cast<ciMultiField*>(_declared_nonstatic_fields->at(j))->secondary_fields()->at(i - (j + 1));\n+        }\n+      }\n+    }\n+    return NULL;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-      int  field_off = field->offset_in_bytes();\n+      int field_off = field->offset_in_bytes();\n@@ -428,0 +428,10 @@\n+      if (field->secondary_fields_count() > 1) {\n+        for (int j = 0; j < field->secondary_fields_count(); j++) {\n+          ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_fields()->at(j);\n+          int sec_field_offset = sec_field->offset_in_bytes();\n+          if (sec_field_offset == field_offset)\n+            return sec_field;\n+          if (sec_field_offset > field_offset)\n+            return NULL;\n+        }\n+      }\n@@ -553,1 +563,7 @@\n-    if (fs.is_multifield()) continue;\n+    if (fs.is_multifield()) {\n+      assert(fields->last()->is_multifield_base(), \"\");\n+      ciMultiField* multifield_base = static_cast<ciMultiField*>(fields->last());\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      multifield_base->secondary_fields()->append(new (arena) ciField(&fd));\n+      continue;\n+    }\n@@ -570,1 +586,7 @@\n-        ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        ciField* field = NULL;\n+        if (flattened_field->secondary_fields_count() > 1) {\n+          field = new (arena) ciMultiField(flattened_field, this, offset, is_final);\n+          static_cast<ciMultiField*>(field)->add_secondary_fields(static_cast<ciMultiField*>(flattened_field)->secondary_fields());\n+        } else {\n+          field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        }\n@@ -574,1 +596,8 @@\n-      ciField* field = new (arena) ciField(&fd);\n+      ciField* field = NULL;\n+      if (fs.is_multifield_base()) {\n+        field = new (arena) ciMultiField(&fd);\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, field->secondary_fields_count(), 0, NULL);\n+        static_cast<ciMultiField*>(field)->add_secondary_fields(sec_fields);\n+      } else {\n+        field = new (arena) ciField(&fd);\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  friend class ciMultiField;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,20 @@\n+void InlineTypeNode::expand_input_edges(ciInlineKlass * vk) {\n+  \/\/ We generally perform three operations on multi-field bundle, load its contents into vector,\n+  \/\/ store the contents of vector to multi-field bundle or broadcast a value into a vector equivalent\n+  \/\/ in size to a multi-field bundle. If any of these operations are not supported by target platform\n+  \/\/ scalarize the multi-fields into individual fields.\n+  for(int i = 0; i < vk->nof_declared_nonstatic_fields(); i++) {\n+    ciField* field = vk->declared_nonstatic_field_at(i);\n+    int field_count = field->secondary_fields_count();\n+    BasicType bt = field->type()->basic_type();\n+    if (field_count > 1 &&\n+        (!Matcher::match_rule_supported_vector(Op_LoadVector, field_count, bt) ||\n+        !Matcher::match_rule_supported_vector(Op_StoreVector, field_count, bt) ||\n+        !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), field_count, bt))) {\n+      while(--field_count) {\n+        add_req(NULL);\n+      }\n+    }\n+  }\n+}\n+\n@@ -89,2 +109,3 @@\n-      if (vt->is_multifield_base(i)) {\n-        phi_type = TypeVect::make(phi_type, vt->secondary_field_count(i));\n+      if (vt->is_multifield_base(i) &&\n+          Matcher::vector_size_supported(type->basic_type(), vt->secondary_fields_count(i))) {\n+        phi_type = TypeVect::make(phi_type, vt->secondary_fields_count(i));\n@@ -241,1 +262,1 @@\n-int InlineTypeNode::secondary_field_count(uint index) const {\n+int InlineTypeNode::secondary_fields_count(uint index) const {\n@@ -382,1 +403,0 @@\n-    int offset = holder_offset + field_offset(i);\n@@ -384,0 +404,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -413,0 +434,1 @@\n+        BasicType bt = type2field[ft->basic_type()];\n@@ -415,1 +437,0 @@\n-        BasicType bt = type2field[ft->basic_type()];\n@@ -421,14 +442,4 @@\n-        if (ft->bundle_size() > 1) {\n-          int vec_len = ft->bundle_size();\n-          BasicType elem_bt = ft->basic_type();\n-          bool bundle_size_supported = Matcher::vector_size_supported(elem_bt, vec_len);\n-\n-          \/\/ Set the vector length to maximal supported vector length\n-          \/\/ to allow graceful compilation exit at a later stage.\n-          vec_len = bundle_size_supported ? vec_len : Matcher::max_vector_size(elem_bt);\n-\n-          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, vec_len, elem_bt));\n-\n-          if (!bundle_size_supported) {\n-            kit->env()->record_method_not_compilable(\"Mutifield bundle size not supported for target\", false);\n-          }\n+        int bundle_size = ft->bundle_size();\n+        bool load_bundle = bundle_size > 1 ? Matcher::match_rule_supported_vector(Op_LoadVector, bundle_size, bt): false;\n+        if (load_bundle) {\n+          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, bundle_size, bt));\n@@ -463,0 +474,1 @@\n+  int field_idx = 0;\n@@ -464,1 +476,0 @@\n-    int offset = holder_offset + field_offset(i);\n@@ -467,0 +478,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -468,23 +480,3 @@\n-      if (kit->gvn().type(value)->isa_vect()) {\n-        const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());\n-        Node* adr = kit->basic_plus_adr(base, ptr, offset);\n-        int vec_len = kit->gvn().type(value)->is_vect()->length();\n-        BasicType elem_bt = kit->gvn().type(value)->is_vect()->element_basic_type();\n-        bool bundle_size_supported = Matcher::vector_size_supported(elem_bt, vec_len);\n-\n-        \/\/ Set the vector length to  maximal supported vector length to allow\n-        \/\/ graceful compilation exit at a later stage.\n-        vec_len = bundle_size_supported ? vec_len : Matcher::max_vector_size(elem_bt);\n-\n-        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, vec_len));\n-        kit->set_memory(store, adr_type);\n-\n-        if (!bundle_size_supported) {\n-          kit->env()->record_method_not_compilable(\"Mutifield bundle size not supported for target\", false);\n-        }\n-      } else {\n-        if (!value->is_InlineType()) {\n-          \/\/ Recursively store the flattened inline type field\n-          value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass());\n-        }\n-        value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);\n+      if (!value->is_InlineType()) {\n+        \/\/ Recursively store the flattened inline type field\n+        value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass());\n@@ -492,0 +484,1 @@\n+      value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);\n@@ -493,3 +486,1 @@\n-      \/\/ Store field value to memory\n-      const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());\n-      Node* adr = kit->basic_plus_adr(base, ptr, offset);\n+      int vec_len = ft->bundle_size();\n@@ -497,1 +488,0 @@\n-      assert(is_java_primitive(bt) || adr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n@@ -503,17 +493,4 @@\n-      if (ft->bundle_size() > 1) {\n-        int vec_len = ft->bundle_size();\n-        BasicType elem_bt = ft->basic_type();\n-\n-        bool bundle_size_supported =\n-          Matcher::match_rule_supported_vector(Op_StoreVector, vec_len, elem_bt) &&\n-          Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(elem_bt), vec_len, elem_bt);\n-\n-        \/\/ Set the vector length to  maximal supported vector length\n-        \/\/ to allow graceful compilation exit at a later stage.\n-        vec_len = bundle_size_supported ? vec_len : Matcher::max_vector_size(elem_bt);\n-\n-        \/\/ Handling for non-flattened case, with default InlineFieldMaxFlatSize of 128\n-        \/\/ all the concrete vectors should be fully flattened.\n-        value = value->bottom_type()->isa_vect() ? value : kit->gvn().transform(VectorNode::scalar2vector(value, vec_len, val_type, false));\n-        assert(value->bottom_type()->isa_vect() && value->bottom_type()->is_vect()->length() == (uint)ft->bundle_size(), \"\");\n-\n+      const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit->gvn());\n+      Node* adr = kit->basic_plus_adr(base, ptr, offset);\n+      assert(is_java_primitive(bt) || adr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n+      if (value->bottom_type()->isa_vect()) {\n@@ -522,4 +499,0 @@\n-\n-        if (!bundle_size_supported) {\n-          kit->env()->record_method_not_compilable(\"Mutifield bundle size not supported for target\", false);\n-        }\n@@ -795,11 +768,5 @@\n-    BasicType elem_bt = field_type->basic_type();\n-    bool bundle_size_supported =\n-      Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(elem_bt), vec_len, elem_bt);\n-\n-    \/\/ Set the vector length to  maximal supported vector length\n-    \/\/ to allow graceful compilation exit at a later stage.\n-    vec_len = bundle_size_supported ? vec_len : Matcher::max_vector_size(elem_bt);\n-    value = gvn.transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field_type), false));\n-\n-    if (!bundle_size_supported) {\n-        gvn.C->env()->record_method_not_compilable(\"Mutifield bundle size not supported for target\", false);\n+    BasicType bt = field_type->basic_type();\n+    if (Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      value = gvn.transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field_type), false));\n+    } else {\n+      \/\/ scalar default value to match the bundle size will be returned in subsiquent calls to default_value.\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":46,"deletions":79,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -46,0 +47,1 @@\n+    expand_input_edges(vk);\n@@ -57,0 +59,2 @@\n+  void expand_input_edges(ciInlineKlass * vk);\n+\n@@ -113,0 +117,1 @@\n+\n@@ -117,1 +122,1 @@\n-  int           secondary_field_count(uint index) const;\n+  int           secondary_fields_count(uint index) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -372,1 +372,9 @@\n-  if (field->secondary_fields_count() > 1 && !val->bottom_type()->isa_vect()) {\n+\n+  BasicType bt = field->type()->basic_type();\n+  int vec_len = field->secondary_fields_count();\n+  bool scalarize_fields = !is_java_primitive(bt) || !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n+  if (scalarize_fields) {\n+    for(int i = 0; i < vec_len; i++) {\n+      new_vt->set_field_value_by_offset(field->offset() + i * type2aelembytes(bt), val);\n+    }\n+  } else {\n@@ -374,0 +382,1 @@\n+    new_vt->set_field_value_by_offset(field->offset(), val);\n@@ -375,1 +384,0 @@\n-  new_vt->set_field_value_by_offset(field->offset(), val);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}