{"files":[{"patch":"@@ -113,1 +113,1 @@\n-    -XDenableValueTypes \\\n+    -XDenableValueTypes -XDenablePrimitiveClasses \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-  JAVA_WARNINGS_ARE_ERRORS ?= -Werror\n+  JAVA_WARNINGS_ARE_ERRORS ?=\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1182,0 +1182,8 @@\n+    \/\/ Skip scalarization for vector value objects (concrete vectors and payloads).\n+    load_klass(rdi, rax, rscratch1);\n+    movptr(rscratch1, rax);\n+    super_call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::skip_value_scalarization), rdi);\n+    testptr(rax, rax);\n+    movptr(rax, rscratch1);\n+    jcc(Assembler::notZero, skip);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1866,7 +1866,10 @@\n-    assert(!inner_field->is_flattened(), \"the iteration over nested fields is handled by the loop itself\");\n-    int off = inner_field->offset() - vk->first_field_offset();\n-    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n-    Value replacement = append(load);\n-    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n-    store->set_enclosing_field(enclosing_field);\n-    append(store);\n+    for (int j = 0, sec_offset = 0; j < inner_field->secondary_fields_count(); j++) {\n+      assert(!inner_field->is_flattened(), \"the iteration over nested fields is handled by the loop itself\");\n+      int off = inner_field->offset() + sec_offset - vk->first_field_offset();\n+      LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n+      sec_offset += type2aelembytes(as_BasicType(load->type()));\n+      Value replacement = append(load);\n+      StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n+      store->set_enclosing_field(enclosing_field);\n+      append(store);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -169,0 +169,5 @@\n+  int bundle_size = field_desc.secondary_fields_count(field_desc.index());\n+  if (bundle_size > 1) {\n+    _type = ciType::make(field_type, bundle_size);\n+  }\n+\n@@ -207,0 +212,2 @@\n+  initialize_from(fd);\n+\n@@ -212,1 +219,1 @@\n-    _type = ciType::make(field_type);\n+    _type = ciType::make(field_type, fd->secondary_fields_count(fd->index()));\n@@ -215,2 +222,0 @@\n-  initialize_from(fd);\n-\n@@ -245,0 +250,2 @@\n+  _is_multifield = field->_is_multifield;\n+  _is_multifield_base = field->_is_multifield_base;\n@@ -298,0 +305,3 @@\n+  _is_multifield = fd->is_multifield();\n+  _is_multifield_base = fd->is_multifield_base();\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -43,0 +44,1 @@\n+  friend class ciMultiField;\n@@ -55,0 +57,2 @@\n+  bool             _is_multifield;\n+  bool             _is_multifield_base;\n@@ -108,0 +112,4 @@\n+  bool is_multifield() { return _is_multifield; }\n+  bool is_multifield_base() { return _is_multifield_base; }\n+  int secondary_fields_count() { return type()->bundle_size(); } const\n+\n@@ -197,0 +205,20 @@\n+class ciMultiField : public ciField {\n+private:\n+  CI_PACKAGE_ACCESS\n+  friend class ciInstanceKlass;\n+\n+  GrowableArray<ciField*>* _secondary_fields;\n+\n+  ciMultiField(ciInstanceKlass* klass, int index) : ciField(klass, index) {}\n+  ciMultiField(fieldDescriptor* fd) : ciField(fd) {}\n+  ciMultiField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) :\n+       ciField(field, holder, offset, is_final) {}\n+public:\n+  void add_secondary_fields(GrowableArray<ciField*>* fields) { _secondary_fields = fields; }\n+  GrowableArray<ciField*>* secondary_fields() { return _secondary_fields; }\n+  ciField* secondary_field_at(int i) {\n+    assert(_secondary_fields->length() > i, \"\");\n+    return _secondary_fields->at(i);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciEnv.hpp\"\n@@ -57,1 +58,2 @@\n-    int field_offset = _declared_nonstatic_fields->at(i)->offset();\n+    ciField* field = _declared_nonstatic_fields->at(i);\n+    int field_offset = field->offset();\n@@ -61,0 +63,12 @@\n+    } else if (field->is_multifield_base()) {\n+      for (int j = 0; j < field->secondary_fields_count(); j++) {\n+        ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_field_at(j);\n+        assert(sec_field != NULL, \"\");\n+        int sec_field_offset = sec_field->offset();\n+        if (sec_field_offset == offset) {\n+          return i + j + 1;\n+        } else if (sec_field_offset < offset && sec_field_offset > best_offset) {\n+          best_offset = sec_field_offset;\n+          best_index = i + j + 1;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciField.hpp\"\n@@ -73,1 +74,16 @@\n-    return _declared_nonstatic_fields->at(i);\n+    \/\/ Look for field in preceding multi-field bundle;\n+    for (int j = 0; j <= i; j++) {\n+      int bundle_size = _declared_nonstatic_fields->at(j)->secondary_fields_count();\n+      if (bundle_size > 1 && ((j + bundle_size) > i)) {\n+        if (j == i) {\n+          \/\/ Multifield base.\n+          return _declared_nonstatic_fields->at(i);\n+        } else {\n+          \/\/ Secondary multifield.\n+          return static_cast<ciMultiField*>(_declared_nonstatic_fields->at(j))->secondary_fields()->at(i - (j + 1));\n+        }\n+      } else if (j == i) {\n+        return _declared_nonstatic_fields->at(i);\n+      }\n+    }\n+    return NULL;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -422,2 +422,2 @@\n-      int  field_off = field->offset_in_bytes();\n-      if (field_off == field_offset)\n+      int curr_field_offset = field->offset_in_bytes();\n+      if (curr_field_offset == field_offset)\n@@ -425,1 +425,1 @@\n-      if (field_off > field_offset)\n+      if (curr_field_offset > field_offset)\n@@ -428,0 +428,10 @@\n+      if (field->secondary_fields_count() > 1) {\n+        for (int j = 0; j < field->secondary_fields_count(); j++) {\n+          ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_fields()->at(j);\n+          int sec_field_offset = sec_field->offset_in_bytes();\n+          if (sec_field_offset == field_offset)\n+            return sec_field;\n+          if (sec_field_offset > field_offset)\n+            return NULL;\n+        }\n+      }\n@@ -534,0 +544,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -552,0 +563,7 @@\n+    if (fs.is_multifield()) {\n+      assert(fields->last()->is_multifield_base(), \"\");\n+      ciMultiField* multifield_base = static_cast<ciMultiField*>(fields->last());\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      multifield_base->secondary_fields()->append(new (arena) ciField(&fd));\n+      continue;\n+    }\n@@ -568,1 +586,7 @@\n-        ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        ciField* field = NULL;\n+        if (flattened_field->is_multifield_base()) {\n+          field = new (arena) ciMultiField(flattened_field, this, offset, is_final);\n+          static_cast<ciMultiField*>(field)->add_secondary_fields(static_cast<ciMultiField*>(flattened_field)->secondary_fields());\n+        } else {\n+          field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        }\n@@ -572,1 +596,8 @@\n-      ciField* field = new (arena) ciField(&fd);\n+      ciField* field = NULL;\n+      if (fs.is_multifield_base()) {\n+        field = new (arena) ciMultiField(&fd);\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, fd.secondary_fields_count(fd.index()), 0, NULL);\n+        static_cast<ciMultiField*>(field)->add_secondary_fields(sec_fields);\n+      } else {\n+        field = new (arena) ciField(&fd);\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  friend class ciMultiField;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-ciType::ciType(BasicType basic_type) : ciMetadata() {\n+ciType::ciType(BasicType basic_type, int bundle_size) : ciMetadata() {\n@@ -45,0 +45,1 @@\n+  _bundle_size = bundle_size;\n@@ -49,0 +50,1 @@\n+  _bundle_size = 1;\n@@ -109,7 +111,11 @@\n-ciType* ciType::make(BasicType t) {\n-  \/\/ short, etc.\n-  \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n-  assert((uint)t < T_CONFLICT+1, \"range check\");\n-  if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n-  assert(_basic_types[t] != NULL, \"domain check\");\n-  return _basic_types[t];\n+ciType* ciType::make(BasicType t, int bundle_size) {\n+  if (bundle_size == 1) {\n+    \/\/ short, etc.\n+    \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n+    assert((uint)t < T_CONFLICT+1, \"range check\");\n+    if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n+    assert(_basic_types[t] != NULL, \"domain check\");\n+    return _basic_types[t];\n+  } else {\n+    return new (CURRENT_ENV->arena()) ciType(t, bundle_size);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  int _bundle_size;\n@@ -43,1 +44,1 @@\n-  ciType(BasicType t);     \/\/ for primitive and unloaded types\n+  ciType(BasicType t, int bundle_size = 1);     \/\/ for primitive and unloaded types\n@@ -66,1 +67,3 @@\n-  int size() const                          { return type2size[basic_type()]; }\n+  int size() const                          { return _bundle_size * type2size[basic_type()]; }\n+  int elem_word_count() const               { return type2size[basic_type()]; }\n+  int bundle_size() const                   { return _bundle_size; }\n@@ -68,2 +71,2 @@\n-  bool is_one_word() const                  { return size() == 1; }\n-  bool is_two_word() const                  { return size() == 2; }\n+  bool is_one_word() const                  { return type2size[basic_type()] == 1; }\n+  bool is_two_word() const                  { return type2size[basic_type()] == 2; }\n@@ -84,1 +87,1 @@\n-  static ciType* make(BasicType t);\n+  static ciType* make(BasicType t, int bundle_size = 1);\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -196,4 +196,24 @@\n-  do_klass(vector_VectorPayloadMF64_klass,              jdk_internal_vm_vector_VectorPayloadMF64              ) \\\n-  do_klass(vector_VectorPayloadMF128_klass,             jdk_internal_vm_vector_VectorPayloadMF128             ) \\\n-  do_klass(vector_VectorPayloadMF256_klass,             jdk_internal_vm_vector_VectorPayloadMF256             ) \\\n-  do_klass(vector_VectorPayloadMF512_klass,             jdk_internal_vm_vector_VectorPayloadMF512             ) \\\n+  do_klass(vector_VectorPayloadMF64B_klass,             jdk_internal_vm_vector_VectorPayloadMF64B             ) \\\n+  do_klass(vector_VectorPayloadMF128B_klass,            jdk_internal_vm_vector_VectorPayloadMF128B            ) \\\n+  do_klass(vector_VectorPayloadMF256B_klass,            jdk_internal_vm_vector_VectorPayloadMF256B            ) \\\n+  do_klass(vector_VectorPayloadMF512B_klass,            jdk_internal_vm_vector_VectorPayloadMF512B            ) \\\n+  do_klass(vector_VectorPayloadMF64S_klass,             jdk_internal_vm_vector_VectorPayloadMF64S             ) \\\n+  do_klass(vector_VectorPayloadMF128S_klass,            jdk_internal_vm_vector_VectorPayloadMF128S            ) \\\n+  do_klass(vector_VectorPayloadMF256S_klass,            jdk_internal_vm_vector_VectorPayloadMF256S            ) \\\n+  do_klass(vector_VectorPayloadMF512S_klass,            jdk_internal_vm_vector_VectorPayloadMF512S            ) \\\n+  do_klass(vector_VectorPayloadMF64I_klass,             jdk_internal_vm_vector_VectorPayloadMF64I             ) \\\n+  do_klass(vector_VectorPayloadMF128I_klass,            jdk_internal_vm_vector_VectorPayloadMF128I            ) \\\n+  do_klass(vector_VectorPayloadMF256I_klass,            jdk_internal_vm_vector_VectorPayloadMF256I            ) \\\n+  do_klass(vector_VectorPayloadMF512I_klass,            jdk_internal_vm_vector_VectorPayloadMF512I            ) \\\n+  do_klass(vector_VectorPayloadMF64L_klass,             jdk_internal_vm_vector_VectorPayloadMF64L             ) \\\n+  do_klass(vector_VectorPayloadMF128L_klass,            jdk_internal_vm_vector_VectorPayloadMF128L            ) \\\n+  do_klass(vector_VectorPayloadMF256L_klass,            jdk_internal_vm_vector_VectorPayloadMF256L            ) \\\n+  do_klass(vector_VectorPayloadMF512L_klass,            jdk_internal_vm_vector_VectorPayloadMF512L            ) \\\n+  do_klass(vector_VectorPayloadMF64F_klass,             jdk_internal_vm_vector_VectorPayloadMF64F             ) \\\n+  do_klass(vector_VectorPayloadMF128F_klass,            jdk_internal_vm_vector_VectorPayloadMF128F            ) \\\n+  do_klass(vector_VectorPayloadMF256F_klass,            jdk_internal_vm_vector_VectorPayloadMF256F            ) \\\n+  do_klass(vector_VectorPayloadMF512F_klass,            jdk_internal_vm_vector_VectorPayloadMF512F            ) \\\n+  do_klass(vector_VectorPayloadMF64D_klass,             jdk_internal_vm_vector_VectorPayloadMF64D             ) \\\n+  do_klass(vector_VectorPayloadMF128D_klass,            jdk_internal_vm_vector_VectorPayloadMF128D            ) \\\n+  do_klass(vector_VectorPayloadMF256D_klass,            jdk_internal_vm_vector_VectorPayloadMF256D            ) \\\n+  do_klass(vector_VectorPayloadMF512D_klass,            jdk_internal_vm_vector_VectorPayloadMF512D            ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -97,7 +97,28 @@\n-  template(jdk_internal_vm_vector_VectorPayloadMF64,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64\")  \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF128, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128\") \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF256, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256\") \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF512, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512\") \\\n-  template(payload_name,                              \"payload\")                                  \\\n-  template(ETYPE_name,                                \"ETYPE\")                                    \\\n-  template(VLENGTH_name,                              \"VLENGTH\")                                  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64S,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64I,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64L,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64F,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64D,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D\") \\\n+  template(payload_name,                               \"payload\")                                 \\\n+  template(mfield_name,                                \"mfield\")                                  \\\n+  template(ETYPE_name,                                 \"ETYPE\")                                   \\\n+  template(VLENGTH_name,                               \"VLENGTH\")                                 \\\n@@ -275,4 +296,24 @@\n-  template(vector_VectorPayloadMF64_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64;\")  \\\n-  template(vector_VectorPayloadMF128_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128;\") \\\n-  template(vector_VectorPayloadMF256_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256;\") \\\n-  template(vector_VectorPayloadMF512_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512;\") \\\n+  template(vector_VectorPayloadMF64B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B;\")  \\\n+  template(vector_VectorPayloadMF128B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B;\") \\\n+  template(vector_VectorPayloadMF256B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B;\") \\\n+  template(vector_VectorPayloadMF512B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B;\") \\\n+  template(vector_VectorPayloadMF64S_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S;\")  \\\n+  template(vector_VectorPayloadMF128S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S;\") \\\n+  template(vector_VectorPayloadMF256S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S;\") \\\n+  template(vector_VectorPayloadMF512S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S;\") \\\n+  template(vector_VectorPayloadMF64I_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I;\")  \\\n+  template(vector_VectorPayloadMF128I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I;\") \\\n+  template(vector_VectorPayloadMF256I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I;\") \\\n+  template(vector_VectorPayloadMF512I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I;\") \\\n+  template(vector_VectorPayloadMF64L_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L;\")  \\\n+  template(vector_VectorPayloadMF128L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L;\") \\\n+  template(vector_VectorPayloadMF256L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L;\") \\\n+  template(vector_VectorPayloadMF512L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L;\") \\\n+  template(vector_VectorPayloadMF64F_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F;\")  \\\n+  template(vector_VectorPayloadMF128F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F;\") \\\n+  template(vector_VectorPayloadMF256F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F;\") \\\n+  template(vector_VectorPayloadMF512F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F;\") \\\n+  template(vector_VectorPayloadMF64D_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D;\")  \\\n+  template(vector_VectorPayloadMF128D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D;\") \\\n+  template(vector_VectorPayloadMF256D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D;\") \\\n+  template(vector_VectorPayloadMF512D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":52,"deletions":11,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  _is_larval = read_from(stream);\n@@ -176,0 +177,4 @@\n+    if (_is_larval == NULL) {\n+      _is_larval = new MarkerValue();\n+    }\n+    _is_larval->write_on(stream);\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+  ScopeValue*                _is_larval;\n@@ -131,1 +132,1 @@\n-  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = NULL)\n+  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = NULL, ScopeValue* is_larval = NULL)\n@@ -133,0 +134,1 @@\n+     , _is_larval(is_larval)\n@@ -143,0 +145,1 @@\n+     , _is_larval(NULL)\n@@ -154,0 +157,1 @@\n+  ScopeValue*                 is_larval() const         { return _is_larval; }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -240,0 +241,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -334,1 +336,1 @@\n-  return InlineTypePassFieldsAsArgs;\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypePassFieldsAsArgs;\n@@ -339,1 +341,1 @@\n-  return InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) && InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -793,1 +793,3 @@\n-    if (vt != NULL) {\n+    \/\/ Upfront buffering for VectorBox may cause problems in sweeping allocation\n+    \/\/ graph pallets if boxes are removed during unbox-box optimization.\n+    if (vt != NULL && !result->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2605,1 +2605,1 @@\n-    progress = merge_through_phi(this, phase->is_IterGVN());\n+    progress = merge_through_phi(this, phase);\n@@ -2639,1 +2639,1 @@\n-      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+      } else if (def->is_InlineType()) { \/\/ leaf\n@@ -2656,1 +2656,2 @@\n-Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseGVN *phase) {\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -2699,3 +2700,6 @@\n-  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n-  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n-  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n+\n+  Node* new_payload_phi = clone_through_phi(root_phi, cached_vbox->field_value(0)->bottom_type(), 3, igvn);\n+  Node* new_vector_phi = clone_through_phi(new_payload_phi, vtype, 3, igvn);\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, 1, igvn);\n+\n+  return VectorBoxNode::make_box_node(*igvn, phase->C, new_vbox_phi, new_vector_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  static Node* merge_through_phi(Node* root_phi, PhaseIterGVN* igvn);\n+  static Node* merge_through_phi(Node* root_phi, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2742,10 +2742,0 @@\n-  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n-  if (EnableVectorSupport && has_vbox_nodes()) {\n-    TracePhase tp(\"\", &timers[_t_vector]);\n-    PhaseVector pv(igvn);\n-    pv.optimize_vector_boxes();\n-\n-    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n-  }\n-  assert(!has_vbox_nodes(), \"sanity\");\n-\n@@ -2769,0 +2759,13 @@\n+  \/\/ Process inline type nodes now that all inlining is over\n+  process_inline_types(igvn);\n+\n+  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n+  if (EnableVectorSupport && has_vbox_nodes()) {\n+    TracePhase tp(\"\", &timers[_t_vector]);\n+    PhaseVector pv(igvn);\n+    pv.optimize_vector_boxes();\n+\n+    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n+  }\n+  assert(!has_vbox_nodes(), \"sanity\");\n+\n@@ -2773,3 +2776,0 @@\n-  \/\/ Process inline type nodes now that all inlining is over\n-  process_inline_types(igvn);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1070,1 +1070,3 @@\n-      int      size  = field->type()->size();\n+      int size = field->is_multifield_base() ?\n+                   (InlineTypeNode::is_multifield_scalarized(field) ? field->type()->elem_word_count() : 1)\n+                   : field->type()->size();\n@@ -1112,1 +1114,3 @@\n-    int      size  = field->type()->size();\n+    int size = field->is_multifield_base() ?\n+                 (InlineTypeNode::is_multifield_scalarized(field) ? field->type()->elem_word_count() : 1)\n+                   : field->type()->size();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -48,0 +49,28 @@\n+bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n+  int field_count = field->secondary_fields_count();\n+  BasicType bt = field->type()->basic_type();\n+  if (field_count > 1 &&\n+      (!Matcher::match_rule_supported_vector(Op_LoadVector, field_count, bt) ||\n+       !Matcher::match_rule_supported_vector(Op_StoreVector, field_count, bt) ||\n+       !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), field_count, bt))) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void InlineTypeNode::expand_input_edges(ciInlineKlass* vk) {\n+  \/\/ We generally perform three operations on multi-field bundle, load its contents into vector,\n+  \/\/ store the contents of vector to multi-field bundle or broadcast a value into a vector equivalent\n+  \/\/ in size to a multi-field bundle. If any of these operations are not supported by target platform\n+  \/\/ scalarize the multi-fields into individual fields.\n+  for (int i = 0; i < vk->nof_declared_nonstatic_fields(); i++) {\n+    ciField* field = vk->declared_nonstatic_field_at(i);\n+    if (is_multifield_scalarized(field)) {\n+      int field_count = field->secondary_fields_count();\n+      while(--field_count) {\n+        add_req(NULL);\n+      }\n+    }\n+  }\n+}\n+\n@@ -87,0 +116,4 @@\n+      if (vt->is_multifield_base(i) &&\n+          Matcher::vector_size_supported(type->basic_type(), vt->secondary_fields_count(i))) {\n+        phi_type = TypeVect::make(phi_type, vt->secondary_fields_count(i));\n+      }\n@@ -236,0 +269,15 @@\n+int InlineTypeNode::secondary_fields_count(uint index) const {\n+  assert(is_multifield_base(index), \"non-multifield field at index\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->secondary_fields_count();\n+}\n+\n+bool InlineTypeNode::is_multifield(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield();\n+}\n+\n+bool InlineTypeNode::is_multifield_base(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield_base();\n+}\n+\n@@ -270,0 +318,4 @@\n+\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(get_oop(), igvn);\n+  sfpt->add_req(igvn->intcon(alloc && alloc->_larval ? 1 : 0));\n+\n@@ -362,1 +414,0 @@\n-    int offset = holder_offset + field_offset(i);\n@@ -364,0 +415,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -391,0 +443,6 @@\n+        BasicType bt = con_type->basic_type();\n+        int vec_len = field->secondary_fields_count();\n+        if (field->is_multifield_base() &&\n+          Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+          value = kit->gvn().transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field->type()), false));\n+        }\n@@ -393,0 +451,1 @@\n+        BasicType bt = type2field[ft->basic_type()];\n@@ -395,1 +454,0 @@\n-        BasicType bt = type2field[ft->basic_type()];\n@@ -401,1 +459,7 @@\n-        value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);\n+        int bundle_size = ft->bundle_size();\n+        bool load_bundle = bundle_size > 1 ? Matcher::match_rule_supported_vector(Op_LoadVector, bundle_size, bt): false;\n+        if (load_bundle) {\n+          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, bundle_size, bt));\n+        } else {\n+          value = kit->access_load_at(base, adr, adr_type, val_type, bt, decorators);\n+        }\n@@ -427,0 +491,1 @@\n+  int field_idx = 0;\n@@ -428,1 +493,0 @@\n-    int offset = holder_offset + field_offset(i);\n@@ -431,0 +495,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -432,1 +497,0 @@\n-      \/\/ Recursively store the flattened inline type field\n@@ -434,0 +498,1 @@\n+        \/\/ Recursively store the flattened inline type field\n@@ -438,1 +503,3 @@\n-      \/\/ Store field value to memory\n+      int vec_len = ft->bundle_size();\n+      BasicType bt = type2field[ft->basic_type()];\n+      const Type* val_type = Type::get_const_type(ft);\n@@ -441,1 +508,0 @@\n-      BasicType bt = type2field[ft->basic_type()];\n@@ -443,4 +509,10 @@\n-      const Type* val_type = Type::get_const_type(ft);\n-      const TypeAryPtr* ary_type = kit->gvn().type(base)->isa_aryptr();\n-      if (ary_type != NULL) {\n-        decorators |= IS_ARRAY;\n+      if (value->bottom_type()->isa_vect()) {\n+        assert(value->bottom_type()->is_vect()->length() == (uint)vec_len, \"\");\n+        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, vec_len));\n+        kit->set_memory(store, adr_type);\n+      } else {\n+        const TypeAryPtr* ary_type = kit->gvn().type(base)->isa_aryptr();\n+        if (ary_type != NULL) {\n+          decorators |= IS_ARRAY;\n+        }\n+        kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);\n@@ -448,1 +520,0 @@\n-      kit->access_store_at(base, adr, adr_type, value, val_type, bt, decorators);\n@@ -554,0 +625,1 @@\n+  \/\/ Primitive objects are always null free.\n@@ -640,1 +712,5 @@\n-  if (is_default(phase) && inline_klass()->is_initialized() &&\n+  \/\/ An InlineTypeNode in larval state is up for updation and\n+  \/\/ should not be replaced by precomputed default oops.\n+  Node* alloc = AllocateNode::Ideal_allocation(oop, phase);\n+  bool is_larval_alloc = alloc && alloc->as_Allocate()->_larval == true;\n+  if (!is_larval_alloc && is_default(phase) && inline_klass()->is_initialized() &&\n@@ -647,1 +723,1 @@\n-  if (oop->isa_InlineType() && !phase->type(oop)->maybe_null()) {\n+  if (oop->isa_InlineType() && !oop->isa_VectorBox() && !phase->type(oop)->maybe_null()) {\n@@ -706,0 +782,11 @@\n+Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type) {\n+  BasicType bt = field_type->basic_type();\n+  Node* value = gvn.zerocon(field_type->basic_type());\n+  int vec_len = field_type->bundle_size();\n+  if (is_java_primitive(bt) &&\n+      Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      value = gvn.transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field_type), false));\n+  }\n+  return value;\n+}\n+\n@@ -713,1 +800,1 @@\n-    Node* value = gvn.zerocon(field_type->basic_type());\n+    Node* value = default_value(gvn, field_type);\n@@ -745,1 +832,2 @@\n-    if (!gvn->type(value)->is_zero_type()) {\n+    if (!gvn->type(value)->is_zero_type() &&\n+        !VectorNode::is_all_zeros_vector(value)) {\n@@ -1025,1 +1113,0 @@\n-    ciType* type = field_type(i);\n@@ -1027,0 +1114,1 @@\n+    ciType* type = field_type(i);\n@@ -1033,1 +1121,19 @@\n-      if (multi->is_Start()) {\n+      if (type->bundle_size() > 1) {\n+        Node* not_null_oop =  NULL;\n+        ciInlineKlass* ik = inline_klass();\n+        if (multi->is_Call()) {\n+          if (in) {\n+            not_null_oop = multi->as_Call()->in(base_input);\n+          } else {\n+            not_null_oop =  multi->as_Call()->proj_out(TypeFunc::Parms);\n+          }\n+          assert(not_null_oop->bottom_type()->isa_instptr(), \"\");\n+          load(kit, not_null_oop, not_null_oop, ik, \/* holder_offset *\/ 0);\n+          parm = field_value(i);\n+        } else if (multi->is_Start()) {\n+          assert(in, \"return from start?\");\n+          parm = default_value(gvn, type);\n+        } else {\n+          assert(false, \"unhandled case\");\n+        }\n+      } else if (multi->is_Start()) {\n@@ -1051,1 +1157,1 @@\n-      base_input += type->size();\n+      base_input += (type->size() \/ type->bundle_size());\n@@ -1112,1 +1218,1 @@\n-    Node* value = gvn.zerocon(field_type->basic_type());\n+    Node* value = default_value(gvn, field_type);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":126,"deletions":20,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -46,0 +47,1 @@\n+    expand_input_edges(vk);\n@@ -57,2 +59,1 @@\n-  \/\/ Get the klass defining the field layout of the inline type\n-  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n+  void expand_input_edges(ciInlineKlass * vk);\n@@ -74,0 +75,2 @@\n+  \/\/ Get the klass defining the field layout of the inline type\n+  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n@@ -88,0 +91,2 @@\n+  static bool is_multifield_scalarized(ciField* field);\n+\n@@ -91,0 +96,2 @@\n+  static Node* default_value(PhaseGVN& gvn, ciType* field_type);\n+\n@@ -103,0 +110,1 @@\n+  bool  is_buffered() { return _is_buffered; }\n@@ -105,2 +113,4 @@\n-  uint          field_count() const { return req() - Values; }\n-  Node*         field_value(uint index) const;\n+  virtual uint  field_count() const { return req() - Values; }\n+  virtual Node* field_value(uint index) const;\n+  uint          field_index(int offset) const;\n+\n@@ -108,2 +118,3 @@\n-  void      set_field_value(uint index, Node* value);\n-  void      set_field_value_by_offset(int offset, Node* value);\n+  void          set_field_value(uint index, Node* value);\n+\n+  void          set_field_value_by_offset(int offset, Node* value);\n@@ -111,1 +122,3 @@\n-  uint          field_index(int offset) const;\n+  bool          is_multifield(uint index) const;\n+  bool          is_multifield_base(uint index) const;\n+  int           secondary_fields_count(uint index) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2280,1 +2280,1 @@\n- }\n+  }\n@@ -2320,0 +2320,2 @@\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(base, &_gvn);\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n@@ -2329,1 +2331,4 @@\n-        if (field != NULL) {\n+        \/\/ Skip over direct field access for VectorPayloadMF* class instancs since\n+        \/\/ multifield is loaded into vector, alternatively we can create a lane\n+        \/\/ extraction logic.\n+        if (field != NULL && !VectorSupport::is_vector_payload_mf(vk->get_InlineKlass())) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -112,1 +112,3 @@\n-      if (C->inlining_incrementally() && res->is_InlineType()) {\n+      \/\/ VectorBoxes should be treated as special InlineTypeNodes, we will defer its buffering\n+      \/\/ to a later stage to give opportunity for consumption by subsequent expanders.\n+      if (C->inlining_incrementally() && res->is_InlineType() && !res->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+class VectorBoxNode;\n@@ -722,0 +723,1 @@\n+        DEFINE_CLASS_ID(VectorBox, InlineType, 0)\n@@ -955,0 +957,1 @@\n+  DEFINE_CLASS_QUERY(VectorBox)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -914,0 +914,1 @@\n+      ScopeValue* is_larval = NULL;\n@@ -926,0 +927,6 @@\n+\n+        Node* larval_node = sfpt->in(first_ind++);\n+        assert(larval_node != NULL && larval_node->is_Con(), \"is_larval node not found\");\n+\n+        const TypeInt* larval_type = larval_node->bottom_type()->is_int();\n+        is_larval = new ConstantIntValue(larval_type->get_con());\n@@ -928,1 +935,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init);\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init, is_larval);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -924,1 +924,5 @@\n-    if (tf()->returns_inline_type_as_fields()) {\n+    if (res->isa_InlineType() && VectorSupport::skip_value_scalarization(res->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+      InlineTypeNode* vt = res->as_InlineType();\n+      assert(vt->is_buffered(), \"\");\n+      ret->add_req(vt->get_oop());\n+    } else if (tf()->returns_inline_type_as_fields()) {\n@@ -1137,1 +1141,1 @@\n-  \/\/ record exit from a method if compiled while Dtrace is turned on.\n+  \/\/ record exit from a method if compiled while Dtrace is returned on.\n@@ -2356,1 +2360,8 @@\n-      if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n+      if (VectorSupport::skip_value_scalarization(value->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+        \/\/ Buffer the vector return types, for regular inline object caller expects\n+        \/\/ scalarized fields to be passed back.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        inc_sp(1);\n+        value = value->as_InlineType()->buffer(this);\n+      } else if (!_caller->has_method() || Compile::current()->inlining_incrementally()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -344,1 +345,1 @@\n-  int holder_depth = field->type()->size();\n+  int holder_depth = field->type()->size() \/ field->type()->bundle_size();\n@@ -361,1 +362,1 @@\n-    int nargs = 1 + field->type()->size();\n+    int nargs = 1 + field->type()->size() \/ field->type()->bundle_size();\n@@ -371,1 +372,12 @@\n-  new_vt->set_field_value_by_offset(field->offset(), val);\n+\n+  BasicType bt = field->type()->basic_type();\n+  int vec_len = field->secondary_fields_count();\n+  bool scalarize_fields = !is_java_primitive(bt) || !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n+  if (scalarize_fields) {\n+    for(int i = 0; i < vec_len; i++) {\n+      new_vt->set_field_value_by_offset(field->offset() + i * type2aelembytes(bt), val);\n+    }\n+  } else {\n+    val = _gvn.transform(VectorNode::scalar2vector(val, field->secondary_fields_count(), Type::get_const_type(field->type()), false));\n+    new_vt->set_field_value_by_offset(field->offset(), val);\n+  }\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -35,0 +36,8 @@\n+static bool is_vector(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n+}\n+\n+static bool is_vector_payload_mf(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayloadMF_klass());\n+}\n+\n@@ -43,1 +52,0 @@\n-\n@@ -182,1 +190,1 @@\n-  Node* vec_value = vec_box->in(VectorBoxNode::Value);\n+  Node* vec_value = vec_box->get_vec();\n@@ -193,1 +201,1 @@\n-        if (call->has_non_debug_use(vec_box) && vec_box->in(VectorBoxNode::Box)->is_Phi()) {\n+        if (call->has_non_debug_use(vec_box) && vec_box->get_oop()->is_Phi()) {\n@@ -217,1 +225,1 @@\n-        Node* vect = vec_box->in(VectorBoxNode::Value);\n+        Node* vect = vec_box->get_vec();\n@@ -241,0 +249,7 @@\n+  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n+  \/\/ Multi-field based vectors are InlineTypeNodes and are already\n+  \/\/ scalarized by process_inline_types.\n+  if (is_vector(iklass)) {\n+    return;\n+  }\n+\n@@ -261,1 +276,0 @@\n-  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n@@ -307,2 +321,2 @@\n-    Node* vbox = vec_box->in(VectorBoxNode::Box);\n-    Node* vect = vec_box->in(VectorBoxNode::Value);\n+    Node* vbox = vec_box->get_oop();\n+    Node* vect = vec_box->get_vec();\n@@ -354,4 +368,55 @@\n-Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n-                                          Node* value,\n-                                          const TypeInstPtr* box_type,\n-                                          const TypeVect* vect_type) {\n+Node* PhaseVector::expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n+                                                 Node* value,\n+                                                 const TypeInstPtr* box_type,\n+                                                 const TypeVect* vect_type) {\n+  JVMState* jvms = clone_jvms(C, vbox_alloc);\n+  GraphKit kit(jvms);\n+  PhaseGVN& gvn = kit.gvn();\n+\n+  ciInlineKlass* box_klass = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+\n+  BasicType bt = vect_type->element_basic_type();\n+  int num_elem = vect_type->length();\n+  int elem_size = type2aelembytes(bt);\n+\n+  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n+  Node* klass_node = kit.makecon(klass_type);\n+  Node* buffer_mem = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true);\n+\n+  assert(is_vector(box_klass), \"\");\n+  ciField* payload_field = box_klass->declared_nonstatic_field_at(0);\n+  int offset = payload_field->offset();\n+  if (!payload_field->is_flattened()) {\n+    ciInlineKlass* payload_klass = static_cast<ciInlineKlass*>(payload_field->type());\n+    assert(is_vector_payload_mf(payload_klass), \"\");\n+    ciField* mutifield = payload_klass->declared_nonstatic_field_at(0);\n+    offset += mutifield->offset();\n+  }\n+\n+  Node* buffer_start_adr = kit.basic_plus_adr(buffer_mem, offset);\n+  const TypePtr* buffer_adr_type = buffer_start_adr->bottom_type()->is_ptr();\n+  Node* buffer_mem_start = kit.memory(buffer_start_adr);\n+  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n+                                                     kit.control(),\n+                                                     buffer_mem_start,\n+                                                     buffer_start_adr,\n+                                                     buffer_adr_type,\n+                                                     value,\n+                                                     num_elem));\n+  kit.set_memory(vstore, buffer_adr_type);\n+\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n+\n+  kit.replace_call(vbox_alloc, buffer_mem, true);\n+  C->remove_macro_node(vbox_alloc);\n+\n+  return buffer_mem;\n+}\n+\n+\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n+\/\/ Since intrinsification is skipped upfront for  mask\/shuffle related operations\n+\/\/ this is anyways a dead code currently.\n+Node* PhaseVector::expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n+                                                       Node* value,\n+                                                       const TypeInstPtr* box_type,\n+                                                       const TypeVect* vect_type) {\n@@ -427,1 +492,43 @@\n-void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n+Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n+                                          Node* value,\n+                                          const TypeInstPtr* box_type,\n+                                          const TypeVect* vect_type) {\n+  ciInstanceKlass* box_klass = box_type->instance_klass();\n+  if (is_vector(box_klass)) {\n+    return expand_vbox_alloc_node_vector(vbox_alloc, value, box_type, vect_type);\n+  } else {\n+    return expand_vbox_alloc_node_mask_shuffle(vbox_alloc, value, box_type, vect_type);\n+  }\n+}\n+\n+Node* PhaseVector::get_loaded_payload(VectorUnboxNode* vec_unbox) {\n+   Node* obj = vec_unbox->obj();\n+   while(obj->is_InlineType()) {\n+      obj = obj->as_InlineType()->field_value(0);\n+   }\n+   if (obj->bottom_type()->isa_vect()) {\n+     return obj;\n+   }\n+   return NULL;\n+}\n+\n+void PhaseVector::expand_vunbox_node_vector(VectorUnboxNode* vec_unbox) {\n+  if (vec_unbox->outcnt() > 0) {\n+    GraphKit kit;\n+    PhaseGVN& gvn = kit.gvn();\n+\n+    Node* vec_val_load = get_loaded_payload(vec_unbox);\n+    assert (vec_val_load != NULL, \"\");\n+\n+    C->set_max_vector_size(MAX2(C->max_vector_size(), vec_val_load->bottom_type()->is_vect()->length_in_bytes()));\n+    gvn.hash_delete(vec_unbox);\n+    vec_unbox->disconnect_inputs(C);\n+    C->gvn_replace_by(vec_unbox, vec_val_load);\n+  }\n+  C->remove_macro_node(vec_unbox);\n+}\n+\n+\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n+\/\/ Since intrinsification is skipped upfront for mask\/shuffle related operations\n+\/\/ this is anyways a dead code currently.\n+void PhaseVector::expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox) {\n@@ -499,0 +606,17 @@\n+void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n+  if (vec_unbox->outcnt() > 0) {\n+    GraphKit kit;\n+    PhaseGVN& gvn = kit.gvn();\n+    Node* obj = vec_unbox->obj();\n+    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n+    ciInstanceKlass* from_kls = tinst->instance_klass();\n+\n+    if (is_vector(from_kls)) {\n+      return expand_vunbox_node_vector(vec_unbox);\n+    } else {\n+      return expand_vunbox_node_mask_shuffle(vec_unbox);\n+    }\n+  }\n+  C->remove_macro_node(vec_unbox);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":136,"deletions":12,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciKlass.hpp\"\n@@ -39,1 +40,1 @@\n-  Node* expand_vbox_node_helper(Node* vbox,\n+  Node* expand_vbox_node_helper(Node* vbox_alloc,\n@@ -43,0 +44,1 @@\n+\n@@ -47,0 +49,13 @@\n+\n+  Node* expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n+                                      Node* value,\n+                                      const TypeInstPtr* box_type,\n+                                      const TypeVect* vect_type);\n+\n+  Node* expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n+                                            Node* value,\n+                                            const TypeInstPtr* box_type,\n+                                            const TypeVect* vect_type);\n+\n+  Node* get_loaded_payload(VectorUnboxNode* vec_unbox);\n+\n@@ -51,0 +66,2 @@\n+  void expand_vunbox_node_vector(VectorUnboxNode* vec_unbox);\n+  void expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#ifdef ASSERT\n@@ -36,1 +35,1 @@\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n@@ -39,0 +38,9 @@\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+}\n+\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n+#ifdef ASSERT\n@@ -62,8 +70,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -160,1 +160,1 @@\n-  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vt);\n+  Node* vbox = VectorBoxNode::make_box_node(gvn(), C, ret, vector, vbox_type, vt);\n@@ -173,0 +173,4 @@\n+  \/\/ TODO[valhalla] Limiting support to only vectors cases untill mask and shuffle becomes inline types.\n+  if (!is_vector(vbox_type->instance_klass())) {\n+    return NULL;\n+  }\n@@ -794,0 +798,3 @@\n+  if (shuffle_vec == NULL) {\n+    return false;\n+  }\n@@ -857,0 +864,5 @@\n+  bool is_shuffle = is_vector_shuffle(vbox_klass);\n+  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n+  if (is_mask || is_shuffle) {\n+    return false;\n+  }\n@@ -998,0 +1010,5 @@\n+  bool is_shuffle = is_vector_shuffle(vbox_klass);\n+  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n+  if (is_mask || is_shuffle) {\n+    return false;\n+  }\n@@ -1963,1 +1980,2 @@\n-  if (is_masked_op && mask == NULL) {\n+  \/\/ TODO[valhalla] Preveting intrinsification untill mask becomes inline type.\n+  if (true || is_masked_op && mask == NULL) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -857,0 +858,4 @@\n+  case Op_ReplicateF:\n+    return n->in(1)->bottom_type() == TypeF::ONE;\n+  case Op_ReplicateD:\n+    return n->in(1)->bottom_type() == TypeD::ONE;\n@@ -871,0 +876,4 @@\n+  case Op_ReplicateF:\n+    return n->in(1)->bottom_type() == TypeF::ZERO;\n+  case Op_ReplicateD:\n+    return n->in(1)->bottom_type() == TypeD::ZERO;\n@@ -1626,1 +1635,13 @@\n-  Node* n = obj()->uncast();\n+  Node* n = obj();\n+  assert(n->is_InlineType(), \"\");\n+  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n+  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n+  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n+  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n+  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n+  \/\/ to get to the VectorBox.\n+  if (!n->is_VectorBox() &&\n+      VectorSupport::is_vector(n->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+    n = n->as_InlineType()->get_oop();\n+  }\n+  n = n->uncast();\n@@ -1628,1 +1649,1 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n+    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n@@ -1637,1 +1658,1 @@\n-        Node* value = vbox->in(VectorBoxNode::Value);\n+        Node* value = vbox->field_value(0);\n@@ -1663,1 +1684,18 @@\n-  Node* n = obj()->uncast();\n+  Node* n = obj();\n+  if (n->is_InlineType() && !n->is_VectorBox()) {\n+    \/\/ FIXME: Directly return Vector loaded from multi-field for concrete\n+    \/\/ vector InlineType nodes. This can save deferring unbox expansion.\n+    \/\/ For masks\/shuffle emit additional pruning IR to match the vector size.\n+  }\n+  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n+  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n+  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n+  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n+  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n+  \/\/ to get to the VectorBox.\n+  if (n->is_InlineType() &&\n+      !n->is_VectorBox() &&\n+      VectorSupport::is_vector(n->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+    n = n->as_InlineType()->get_oop();\n+  }\n+  n = n->uncast();\n@@ -1665,2 +1703,2 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n-      return n->in(VectorBoxNode::Value); \/\/ VectorUnbox (VectorBox v) ==> v\n+    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n+      return n->as_VectorBox()->get_vec(); \/\/ VectorUnbox (VectorBox v) ==> v\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1668,1 +1669,1 @@\n-class VectorBoxNode : public Node {\n+class VectorBoxNode : public InlineTypeNode {\n@@ -1670,12 +1671,31 @@\n-  const TypeInstPtr* const _box_type;\n-  const TypeVect*    const _vec_type;\n- public:\n-  enum {\n-     Box   = 1,\n-     Value = 2\n-  };\n-  VectorBoxNode(Compile* C, Node* box, Node* val,\n-                const TypeInstPtr* box_type, const TypeVect* vt)\n-    : Node(NULL, box, val), _box_type(box_type), _vec_type(vt) {\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n+  const TypeInstPtr* _box_type;\n+  const TypeVect*    _vec_type;\n+\n+ public:\n+  void set_box_type(const TypeInstPtr* box_type) { _box_type = box_type; }\n+  void set_vec_type(const TypeVect* vec_type) { _vec_type = vec_type; }\n+\n+  VectorBoxNode(Compile* C, ciInlineKlass* vk, Node* oop, const TypeInstPtr* box_type, const TypeVect* vt, bool null_free, bool is_buffered) :\n+    InlineTypeNode(vk, oop, null_free, is_buffered) {\n+      init_flags(Flag_is_macro);\n+      init_class_id(Class_VectorBox);\n+      set_vec_type(vt);\n+      set_box_type(box_type);\n+      C->add_macro_node(this);\n+  }\n+\n+  static VectorBoxNode* make_box_node(PhaseGVN& gvn, Compile* C, Node* box, Node* val,\n+                                      const TypeInstPtr* box_type, const TypeVect* vt) {\n+    ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+    ciInlineKlass* payload = vk->declared_nonstatic_field_at(0)->type()->as_inline_klass();\n+\n+    Node* payload_oop = payload->is_initialized() ? default_oop(gvn, payload) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n+    Node* payload_value = InlineTypeNode::make_uninitialized(gvn, payload, true);\n+    payload_value->as_InlineType()->set_field_value(0, val);\n+    payload_value = gvn.transform(payload_value);\n+\n+    VectorBoxNode* box_node = new VectorBoxNode(C, vk, box, box_type, vt, false, vk->is_empty() && vk->is_initialized());\n+    box_node->set_field_value(0, payload_value);\n+    box_node->set_is_init(gvn);\n+\n+    return box_node;\n@@ -1687,0 +1707,5 @@\n+  Node*  get_vec() {\n+    assert(field_value(0)->is_InlineType(), \"\");\n+    return field_value(0)->as_InlineType()->field_value(0);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":38,"deletions":13,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClassMacros.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -69,1 +72,5 @@\n-  return klass->is_subclass_of(vmClasses::vector_VectorPayload_klass());\n+  return klass->is_subclass_of(vmClasses::vector_Vector_klass());\n+}\n+\n+bool VectorSupport::is_vector_payload_mf(Klass* klass) {\n+  return klass->is_subclass_of(vmClasses::vector_VectorPayloadMF_klass());\n@@ -80,0 +87,4 @@\n+bool VectorSupport::skip_value_scalarization(Klass* klass) {\n+  return VectorSupport::is_vector(klass) || VectorSupport::is_vector_payload_mf(klass);\n+}\n+\n@@ -135,3 +146,1 @@\n-Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS) {\n-  int num_elem = klass2length(ik);\n-  BasicType elem_bt = klass2bt(ik);\n+Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, Location location, int larval, TRAPS) {\n@@ -140,0 +149,2 @@\n+  \/\/ FIXME: Existing handling is used for shuffles and mask classes, to be removed after\n+  \/\/ complete support.\n@@ -141,1 +152,3 @@\n-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n+  if (is_vector_shuffle(ik) || is_vector_mask(ik)) {\n+    TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n+    typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n@@ -143,1 +156,3 @@\n-  typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n+    if (location.is_register()) {\n+      \/\/ Value was in a callee-saved register.\n+      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n@@ -145,3 +160,3 @@\n-  if (location.is_register()) {\n-    \/\/ Value was in a callee-saved register.\n-    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+      for (int i = 0; i < num_elem; i++) {\n+        int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n@@ -149,6 +164,9 @@\n-    for (int i = 0; i < num_elem; i++) {\n-      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n-\n-      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-      init_payload_element(arr, elem_bt, i, elem_addr);\n+        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+        init_payload_element(arr, elem_bt, i, elem_addr);\n+      }\n+    } else {\n+      \/\/ Value was directly saved on the stack.\n+      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+      for (int i = 0; i < num_elem; i++) {\n+        init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n+      }\n@@ -156,0 +174,1 @@\n+    return Handle(THREAD, arr);\n@@ -157,4 +176,28 @@\n-    \/\/ Value was directly saved on the stack.\n-    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n-    for (int i = 0; i < num_elem; i++) {\n-      init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n+    \/\/ On-heap vector values are represented as primitive class instances with a multi-field payload.\n+    InstanceKlass* payload_kls = get_vector_payload_klass(elem_bt, num_elem);\n+    assert(payload_kls->is_inline_klass(), \"\");\n+    instanceOop obj = InlineKlass::cast(payload_kls)->allocate_instance(THREAD);\n+    if (larval) obj->set_mark(obj->mark().enter_larval_state());\n+\n+    fieldDescriptor fd;\n+    Klass* def = payload_kls->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(elem_bt), false, &fd);\n+    assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == num_elem, \"\");\n+\n+    int ffo = InlineKlass::cast(payload_kls)->first_field_offset();\n+\n+    if (location.is_register()) {\n+      \/\/ Value was in a callee-saved register.\n+      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+      int vec_size = num_elem * elem_size;\n+      for (int i = 0; i < vec_size; i++) {\n+        int vslot = i \/ VMRegImpl::stack_slot_size;\n+        int off   = i % VMRegImpl::stack_slot_size;\n+        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+        obj->byte_field_put(ffo + i, *(jbyte*)elem_addr);\n+      }\n+    } else {\n+      \/\/ Value was directly saved on the stack.\n+      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+      for (int i = 0; i < elem_size * num_elem; i++) {\n+        obj->byte_field_put(ffo + i, *(jbyte*)(base_addr + i));\n+      }\n@@ -162,0 +205,1 @@\n+    return Handle(THREAD, obj);\n@@ -163,1 +207,0 @@\n-  return Handle(THREAD, arr);\n@@ -166,1 +209,117 @@\n-Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS) {\n+Symbol* VectorSupport::get_vector_payload_field_signature(BasicType elem_bt, int num_elem) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      switch(num_elem) {\n+        case  8: return vmSymbols::vector_VectorPayloadMF64B_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF128B_signature();\n+        case 32: return vmSymbols::vector_VectorPayloadMF256B_signature();\n+        case 64: return vmSymbols::vector_VectorPayloadMF512B_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_SHORT:\n+      switch(num_elem) {\n+        case  4: return vmSymbols::vector_VectorPayloadMF64S_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF128S_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF256S_signature();\n+        case 32: return vmSymbols::vector_VectorPayloadMF512S_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_INT:\n+      switch(num_elem) {\n+        case  2: return vmSymbols::vector_VectorPayloadMF64I_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF128I_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF256I_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF512I_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_LONG:\n+      switch(num_elem) {\n+        case  1: return vmSymbols::vector_VectorPayloadMF64L_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF128L_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF256L_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF512L_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_FLOAT:\n+      switch(num_elem) {\n+        case  2: return vmSymbols::vector_VectorPayloadMF64F_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF128F_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF256F_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF512F_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_DOUBLE:\n+      switch(num_elem) {\n+        case  1: return vmSymbols::vector_VectorPayloadMF64D_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF128D_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF256D_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF512D_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n+     default:\n+        ShouldNotReachHere();\n+  }\n+  return NULL;\n+}\n+\n+InstanceKlass* VectorSupport::get_vector_payload_klass(BasicType elem_bt, int num_elem) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      switch(num_elem) {\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64B_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128B_klass));\n+        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256B_klass));\n+        case 64: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512B_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_SHORT:\n+      switch(num_elem) {\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64S_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128S_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256S_klass));\n+        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512S_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_INT:\n+      switch(num_elem) {\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64I_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128I_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256I_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512I_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_LONG:\n+      switch(num_elem) {\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64L_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128L_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256L_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512L_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_FLOAT:\n+      switch(num_elem) {\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64F_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128F_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256F_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512F_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    case T_DOUBLE:\n+      switch(num_elem) {\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64D_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128D_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256D_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512D_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n+    default:\n+        ShouldNotReachHere();\n+  }\n+  return NULL;\n+}\n+\n+Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n+  ScopeValue* payload = ov->field_at(0);\n+  intptr_t is_larval = StackValue::create_stack_value(fr, reg_map, ov->is_larval())->get_int();\n+  jint larval = (jint)*((jint*)&is_larval);\n+\n@@ -170,2 +329,2 @@\n-      \/\/ Vector value in an aligned adjacent tuple (1, 2, 4, 8, or 16 slots).\n-      return allocate_vector_payload_helper(ik, fr, reg_map, location, THREAD); \/\/ safepoint\n+      \/\/ Vector payload value in an aligned adjacent tuple (8, 16, 32 or 64 bytes).\n+      return allocate_vector_payload_helper(ik, num_elem, elem_bt, fr, reg_map, location, larval, THREAD); \/\/ safepoint\n@@ -190,0 +349,20 @@\n+instanceOop VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n+  assert(is_vector_payload_mf(ik), \"%s not a vector payload\", ik->name()->as_C_string());\n+  assert(ov->field_size() == 1, \"%s not a vector\", ik->name()->as_C_string());\n+  assert(ik->is_inline_klass(), \"\");\n+\n+  int num_elem = 0;\n+  BasicType elem_bt = T_ILLEGAL;\n+  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+    fieldDescriptor& fd = fs.field_descriptor();\n+    if (fd.is_multifield_base()) {\n+      elem_bt = fd.field_type();\n+      num_elem = fd.secondary_fields_count(fd.index());\n+      break;\n+    }\n+  }\n+  assert(num_elem != 0, \"\");\n+  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, num_elem, elem_bt, fr, reg_map, ov, CHECK_NULL);\n+  return (instanceOop)payload_instance();\n+}\n+\n@@ -193,0 +372,7 @@\n+  assert(ik->is_inline_klass(), \"\");\n+\n+  int num_elem = klass2length(ik);\n+  BasicType elem_bt = klass2bt(ik);\n+  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, num_elem, elem_bt, fr, reg_map, ov, CHECK_NULL);\n+  instanceOop vbox = ik->allocate_instance(THREAD);\n+  Handle vbox_h = Handle(THREAD, vbox);\n@@ -194,4 +380,11 @@\n-  ScopeValue* payload_value = ov->field_at(0);\n-  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, fr, reg_map, payload_value, CHECK_NULL);\n-  instanceOop vbox = ik->allocate_instance(CHECK_NULL);\n-  vector_VectorPayload::set_payload(vbox, payload_instance());\n+  fieldDescriptor fd;\n+  Symbol* payload_sig = VectorSupport::get_vector_payload_field_signature(elem_bt, num_elem);\n+  Klass* def = ik->find_field(vmSymbols::payload_name(), payload_sig, false, &fd);\n+  assert(def != NULL, \"\");\n+\n+  if (fd.is_inlined()) {\n+    InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(fd.index()));\n+    field_ik->write_inlined_field(vbox_h(), fd.offset(), payload_instance(), THREAD);\n+  } else {\n+    vbox_h()->obj_field_put(fd.offset(), payload_instance());\n+  }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":220,"deletions":27,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-  static Handle allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS);\n-  static Handle allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS);\n+  static Handle allocate_vector_payload_helper(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, Location location, int larval, TRAPS);\n+  static Handle allocate_vector_payload(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS);\n@@ -147,0 +147,4 @@\n+  static instanceOop allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n+\n+  static InstanceKlass* get_vector_payload_klass(BasicType elem_bt, int num_elem);\n+  static Symbol* get_vector_payload_field_signature(BasicType elem_bt, int num_elem);\n@@ -149,0 +153,1 @@\n+  static bool is_vector_payload_mf(Klass* klass);\n@@ -151,0 +156,1 @@\n+  static bool skip_value_scalarization(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1146,0 +1146,2 @@\n+        } else if (EnableVectorSupport && VectorSupport::is_vector_payload_mf(ik)) {\n+          obj = VectorSupport::allocate_vector_payload(ik, fr, reg_map, sv, THREAD);\n@@ -1546,1 +1548,1 @@\n-    if (EnableVectorSupport && VectorSupport::is_vector(k)) {\n+    if (EnableVectorSupport && (VectorSupport::is_vector(k) || VectorSupport::is_vector_payload_mf(k))) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  inline bool is_multifield_base()       const;\n@@ -96,0 +97,1 @@\n+  inline int secondary_fields_count(int base_idx) const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); };\n+inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); }\n+inline bool fieldDescriptor::is_multifield_base() const { return field()->is_multifield_base(); }\n@@ -92,1 +93,15 @@\n-#endif \/\/ SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP\n\\ No newline at end of file\n+inline int fieldDescriptor::secondary_fields_count(int base_idx) const {\n+  Array<MultiFieldInfo>* multifield_info = field_holder()->multifield_info();\n+  if (!is_multifield_base() || NULL == multifield_info) {\n+    return 1;\n+  }\n+  int sec_fields_count = 1;\n+  for (int i = 0; i < multifield_info->length(); i++) {\n+    if (field_holder()->multifield_info(i).base_index() == base_idx) {\n+      sec_fields_count++;\n+    }\n+  }\n+  return  sec_fields_count;\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -640,0 +641,3 @@\n+JRT_LEAF(jint, SharedRuntime::skip_value_scalarization(InlineKlass* klass))\n+  return (jint)VectorSupport::skip_value_scalarization(klass);\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+  static int skip_value_scalarization(InlineKlass* klass);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/MultiField.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/MultiField.java","status":"renamed"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -188,9 +189,51 @@\n-        private static VectorPayloadMF newInstanceFactory(int elemSize, int length)  {\n-            VectorPayloadMF obj = null;\n-            int vecSize = elemSize * length;\n-            switch(vecSize) {\n-                case 8: obj = new VectorPayloadMF64(); break;\n-                case 16: obj = new VectorPayloadMF128(); break;\n-                case 32: obj = new VectorPayloadMF256(); break;\n-                case 64: obj = new VectorPayloadMF512(); break;\n-                default: assert false : \"Unhandled vector size\";\n+        @ForceInline\n+        private static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n+            if (elemType == byte.class) {\n+                switch(length) {\n+                    case  8: return new VectorPayloadMF64B();\n+                    case 16: return new VectorPayloadMF128B();\n+                    case 32: return new VectorPayloadMF256B();\n+                    case 64: return new VectorPayloadMF512B();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == short.class) {\n+                switch(length) {\n+                    case  4: return new VectorPayloadMF64S();\n+                    case  8: return new VectorPayloadMF128S();\n+                    case 16: return new VectorPayloadMF256S();\n+                    case 32: return new VectorPayloadMF512S();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == int.class) {\n+                switch(length) {\n+                    case  2: return new VectorPayloadMF64I();\n+                    case  4: return new VectorPayloadMF128I();\n+                    case  8: return new VectorPayloadMF256I();\n+                    case 16: return new VectorPayloadMF512I();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == long.class) {\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF64L();\n+                    case  2: return new VectorPayloadMF128L();\n+                    case  4: return new VectorPayloadMF256L();\n+                    case  8: return new VectorPayloadMF512L();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == float.class) {\n+                switch(length) {\n+                    case  2: return new VectorPayloadMF64F();\n+                    case  4: return new VectorPayloadMF128F();\n+                    case  8: return new VectorPayloadMF256F();\n+                    case 16: return new VectorPayloadMF512F();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else {\n+                assert elemType == double.class;\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF64D();\n+                    case  2: return new VectorPayloadMF128D();\n+                    case  4: return new VectorPayloadMF256D();\n+                    case  8: return new VectorPayloadMF512D();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n@@ -198,1 +241,1 @@\n-            return obj;\n+            return null;\n@@ -201,2 +244,3 @@\n-        public static VectorPayloadMF createVectPayloadInstance(int elemSize, int length) {\n-            return newInstanceFactory(elemSize, length);\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstance(Class<?> elemType, int length) {\n+            return newInstanceFactory(elemType, length);\n@@ -205,3 +249,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceB(int elemSize, int length, byte [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(byte.class, length);\n@@ -209,0 +253,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -216,3 +261,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceS(int elemSize, int length, short [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(short.class, length);\n@@ -220,0 +265,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -227,3 +273,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceI(int elemSize, int length, int [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(int.class, length);\n@@ -231,0 +277,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -238,3 +285,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceL(int elemSize, int length, long [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(long.class, length);\n@@ -242,0 +289,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -249,3 +297,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceF(int elemSize, int length, float [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(float.class, length);\n@@ -253,0 +301,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -260,3 +309,3 @@\n-        public static VectorPayloadMF createVectPayloadInstanceD(int elemSize, int length, double [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n-            long start_offset = obj.multiFieldOffset();\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(double.class, length);\n@@ -264,0 +313,1 @@\n+            long start_offset = obj.multiFieldOffset();\n@@ -297,1 +347,1 @@\n-    public primitive static class VectorPayloadMF64 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF64B extends VectorPayloadMF {\n@@ -300,1 +350,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);\n@@ -306,1 +356,1 @@\n-    public primitive static class VectorPayloadMF128 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF128B extends VectorPayloadMF {\n@@ -309,1 +359,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);\n@@ -315,1 +365,1 @@\n-    public primitive static class VectorPayloadMF256 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF256B extends VectorPayloadMF {\n@@ -318,1 +368,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);\n@@ -324,1 +374,1 @@\n-    public primitive static class VectorPayloadMF512 extends VectorPayloadMF {\n+    public primitive static class VectorPayloadMF512B extends VectorPayloadMF {\n@@ -327,1 +377,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512.class);\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);\n@@ -333,0 +383,179 @@\n+    public primitive static class VectorPayloadMF64S extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128S extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256S extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512S extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64I extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128I extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256I extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512I extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64L extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128L extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256L extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512L extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64F extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128F extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256F extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512F extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF64D extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128D extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256D extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512D extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":267,"deletions":38,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        return vspecies().dummyVector().shuffleFromBytes(reorder);\n+        return vspecies().dummyVectorMF().shuffleFromBytes(reorder);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+\n@@ -327,0 +328,1 @@\n+    @ForceInline\n@@ -335,0 +337,1 @@\n+    @ForceInline\n@@ -339,1 +342,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(elementByteSize(), laneCount, (float[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(laneCount, (float[])initarr);\n@@ -342,1 +345,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(elementByteSize(), laneCount, (double[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(laneCount, (double[])initarr);\n@@ -345,1 +348,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(elementByteSize(), laneCount, (byte[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(laneCount, (byte[])initarr);\n@@ -348,1 +351,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(elementByteSize(), laneCount, (short[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(laneCount, (short[])initarr);\n@@ -351,1 +354,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(elementByteSize(), laneCount, (int[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(laneCount, (int[])initarr);\n@@ -354,1 +357,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(elementByteSize(), laneCount, (long[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(laneCount, (long[])initarr);\n@@ -363,0 +366,1 @@\n+    @ForceInline\n@@ -372,1 +376,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementByteSize(), laneCount);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementType(), laneCount);\n@@ -378,1 +382,1 @@\n-        return dummyVector = vectorFactory.apply(za);\n+        return dummyVectorMF = vectorFactory.apply(za);\n@@ -383,0 +387,1 @@\n+\n@@ -428,1 +433,1 @@\n-        return dummyVector()\n+        return dummyVectorMF()\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-        AbstractVector<?> other = ((AbstractSpecies<?>)species).dummyVector();\n+        AbstractVector<?> other = ((AbstractSpecies<?>)species).dummyVectorMF();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorPayloadMF128B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorPayloadMF128B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 16));\n-    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 16, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 16));\n+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorPayloadMF256B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorPayloadMF256B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 32));\n-    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 32, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 32));\n+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorPayloadMF512B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorPayloadMF512B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 64));\n-    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 64, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 64));\n+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64B.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorPayloadMF64B payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorPayloadMF64B)value;\n@@ -75,2 +75,2 @@\n-    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 8));\n-    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 8, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 8));\n+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n@@ -394,1 +394,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n@@ -420,1 +420,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n@@ -438,1 +438,1 @@\n-                Byte.BYTES, length));\n+                byte.class, length));\n@@ -3115,1 +3115,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3119,1 +3119,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3234,1 +3234,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset);\n@@ -3271,1 +3271,1 @@\n-            return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3275,1 +3275,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3404,1 +3404,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3457,1 +3457,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3461,1 +3461,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -4301,1 +4301,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -4314,6 +4314,0 @@\n-        @ForceInline\n-        @Override final\n-        ByteVector dummyVector() {\n-            return (ByteVector) super.dummyVector();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorPayloadMF128D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorPayloadMF128D)value;\n@@ -75,2 +75,2 @@\n-    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 2));\n-    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 2, (double [])(VSPECIES.iotaArray())));\n+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 2));\n+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorPayloadMF256D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorPayloadMF256D)value;\n@@ -75,2 +75,2 @@\n-    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 4));\n-    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 4, (double [])(VSPECIES.iotaArray())));\n+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 4));\n+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorPayloadMF512D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorPayloadMF512D)value;\n@@ -75,2 +75,2 @@\n-    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 8));\n-    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 8, (double [])(VSPECIES.iotaArray())));\n+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 8));\n+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64D.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorPayloadMF64D payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorPayloadMF64D)value;\n@@ -75,2 +75,2 @@\n-    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 1));\n-    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 1, (double [])(VSPECIES.iotaArray())));\n+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 1));\n+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n@@ -394,1 +394,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n@@ -420,1 +420,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n@@ -438,1 +438,1 @@\n-                Double.BYTES, length));\n+                double.class, length));\n@@ -2905,1 +2905,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -2909,1 +2909,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3037,1 +3037,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3081,1 +3081,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3139,1 +3139,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3143,1 +3143,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3905,1 +3905,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -3918,6 +3918,0 @@\n-        @ForceInline\n-        @Override final\n-        DoubleVector dummyVector() {\n-            return (DoubleVector) super.dummyVector();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorPayloadMF128F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorPayloadMF128F)value;\n@@ -75,2 +75,2 @@\n-    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 4));\n-    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 4, (float [])(VSPECIES.iotaArray())));\n+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 4));\n+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorPayloadMF256F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorPayloadMF256F)value;\n@@ -75,2 +75,2 @@\n-    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 8));\n-    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 8, (float [])(VSPECIES.iotaArray())));\n+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 8));\n+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorPayloadMF512F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorPayloadMF512F)value;\n@@ -75,2 +75,2 @@\n-    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 16));\n-    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 16, (float [])(VSPECIES.iotaArray())));\n+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 16));\n+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64F.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorPayloadMF64F payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorPayloadMF64F)value;\n@@ -75,2 +75,2 @@\n-    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 2));\n-    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 2, (float [])(VSPECIES.iotaArray())));\n+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 2));\n+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n@@ -394,1 +394,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n@@ -420,1 +420,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n@@ -438,1 +438,1 @@\n-                Float.BYTES, length));\n+                float.class, length));\n@@ -2929,1 +2929,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -2933,1 +2933,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3041,1 +3041,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3085,1 +3085,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3143,1 +3143,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3147,1 +3147,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3846,1 +3846,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -3859,6 +3859,0 @@\n-        @ForceInline\n-        @Override final\n-        FloatVector dummyVector() {\n-            return (FloatVector) super.dummyVector();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorPayloadMF128I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorPayloadMF128I)value;\n@@ -75,2 +75,2 @@\n-    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 4));\n-    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 4, (int [])(VSPECIES.iotaArray())));\n+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 4));\n+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorPayloadMF256I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorPayloadMF256I)value;\n@@ -75,2 +75,2 @@\n-    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 8));\n-    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 8, (int [])(VSPECIES.iotaArray())));\n+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 8));\n+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorPayloadMF512I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorPayloadMF512I)value;\n@@ -75,2 +75,2 @@\n-    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 16));\n-    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 16, (int [])(VSPECIES.iotaArray())));\n+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 16));\n+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64I.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorPayloadMF64I payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorPayloadMF64I)value;\n@@ -75,2 +75,2 @@\n-    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 2));\n-    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 2, (int [])(VSPECIES.iotaArray())));\n+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 2));\n+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n@@ -394,1 +394,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n@@ -420,1 +420,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n@@ -438,1 +438,1 @@\n-                Integer.BYTES, length));\n+                int.class, length));\n@@ -3097,1 +3097,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3101,1 +3101,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3209,1 +3209,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3253,1 +3253,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3311,1 +3311,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3315,1 +3315,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -4014,1 +4014,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -4027,6 +4027,0 @@\n-        @ForceInline\n-        @Override final\n-        IntVector dummyVector() {\n-            return (IntVector) super.dummyVector();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorPayloadMF128L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorPayloadMF128L)value;\n@@ -75,2 +75,2 @@\n-    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 2));\n-    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 2, (long [])(VSPECIES.iotaArray())));\n+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 2));\n+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorPayloadMF256L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorPayloadMF256L)value;\n@@ -75,2 +75,2 @@\n-    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 4));\n-    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 4, (long [])(VSPECIES.iotaArray())));\n+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 4));\n+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorPayloadMF512L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorPayloadMF512L)value;\n@@ -75,2 +75,2 @@\n-    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 8));\n-    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 8, (long [])(VSPECIES.iotaArray())));\n+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 8));\n+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64L.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorPayloadMF64L payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorPayloadMF64L)value;\n@@ -75,2 +75,2 @@\n-    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 1));\n-    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 1, (long [])(VSPECIES.iotaArray())));\n+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 1));\n+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n@@ -394,1 +394,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n@@ -420,1 +420,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n@@ -438,1 +438,1 @@\n-                Long.BYTES, length));\n+                long.class, length));\n@@ -2958,1 +2958,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -2962,1 +2962,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3090,1 +3090,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3134,1 +3134,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3192,1 +3192,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3196,1 +3196,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3949,1 +3949,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -3962,6 +3962,0 @@\n-        @ForceInline\n-        @Override final\n-        LongVector dummyVector() {\n-            return (LongVector) super.dummyVector();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF128 payload;\n+    private final VectorPayloadMF128S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+        this.payload = (VectorPayloadMF128S)value;\n@@ -75,2 +75,2 @@\n-    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 8));\n-    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 8, (short [])(VSPECIES.iotaArray())));\n+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 8));\n+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF256 payload;\n+    private final VectorPayloadMF256S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+        this.payload = (VectorPayloadMF256S)value;\n@@ -75,2 +75,2 @@\n-    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 16));\n-    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 16, (short [])(VSPECIES.iotaArray())));\n+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 16));\n+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF512 payload;\n+    private final VectorPayloadMF512S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+        this.payload = (VectorPayloadMF512S)value;\n@@ -75,2 +75,2 @@\n-    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 32));\n-    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 32, (short [])(VSPECIES.iotaArray())));\n+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 32));\n+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64S.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF64 payload;\n+    private final VectorPayloadMF64S payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+        this.payload = (VectorPayloadMF64S)value;\n@@ -75,2 +75,2 @@\n-    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 4));\n-    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 4, (short [])(VSPECIES.iotaArray())));\n+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 4));\n+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n@@ -394,1 +394,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n@@ -420,1 +420,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n@@ -438,1 +438,1 @@\n-                Short.BYTES, length));\n+                short.class, length));\n@@ -3116,1 +3116,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3120,1 +3120,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3231,1 +3231,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset);\n@@ -3264,1 +3264,1 @@\n-            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3268,1 +3268,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3398,1 +3398,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3456,1 +3456,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3460,1 +3460,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -4295,1 +4295,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -4308,6 +4308,0 @@\n-        @ForceInline\n-        @Override final\n-        ShortVector dummyVector() {\n-            return (ShortVector) super.dummyVector();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n@@ -398,1 +398,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n@@ -424,1 +424,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n@@ -442,1 +442,1 @@\n-                $Boxtype$.BYTES, length));\n+                $type$.class, length));\n@@ -3705,1 +3705,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3709,1 +3709,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3866,1 +3866,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3894,1 +3894,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset);\n@@ -3927,1 +3927,1 @@\n-            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3931,1 +3931,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -4049,1 +4049,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset);\n@@ -4086,1 +4086,1 @@\n-            return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -4090,1 +4090,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -4220,1 +4220,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -4282,1 +4282,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -4286,1 +4286,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -5587,1 +5587,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -5599,6 +5599,0 @@\n-\n-        @ForceInline\n-        @Override final\n-        $abstractvectortype$ dummyVector() {\n-            return ($abstractvectortype$) super.dummyVector();\n-        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF$bits$.class);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF$bits$$Boxinitials$.class);\n@@ -60,1 +60,1 @@\n-    private final VectorSupport.VectorPayloadMF$bits$ payload;\n+    private final VectorPayloadMF$bits$$Boxinitials$ payload;\n@@ -63,1 +63,1 @@\n-        this.payload = (VectorSupport.VectorPayloadMF$bits$)value;\n+        this.payload = (VectorPayloadMF$bits$$Boxinitials$)value;\n@@ -75,2 +75,2 @@\n-    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.createVectPayloadInstance($Boxtype$.BYTES, $numLanes$));\n-    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($Boxtype$.BYTES, $numLanes$, ($type$ [])(VSPECIES.iotaArray())));\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.createVectPayloadInstance($type$.class, $numLanes$));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$ [])(VSPECIES.iotaArray())));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}