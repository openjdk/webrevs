{"files":[{"patch":"@@ -795,1 +795,0 @@\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n@@ -801,1 +800,0 @@\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,0 +169,5 @@\n+      \/\/ sender_pc might be invalid so check that the frame\n+      \/\/ actually belongs to a Continuation.\n+      if (!Continuation::is_frame_in_continuation(thread, *this)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2552,14 +2552,2 @@\n-#ifdef _LP64\n-          if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-            assert(tmp->is_valid(), \"need temporary\");\n-            __ vpandn(dest->as_xmm_double_reg(), tmp->as_xmm_double_reg(), value->as_xmm_double_reg(), 2);\n-          } else\n-#endif\n-          {\n-            if (dest->as_xmm_double_reg() != value->as_xmm_double_reg()) {\n-              __ movdbl(dest->as_xmm_double_reg(), value->as_xmm_double_reg());\n-            }\n-            assert(!tmp->is_valid(), \"do not need temporary\");\n-            __ andpd(dest->as_xmm_double_reg(),\n-                     ExternalAddress((address)double_signmask_pool),\n-                     rscratch1);\n+          if (dest->as_xmm_double_reg() != value->as_xmm_double_reg()) {\n+            __ movdbl(dest->as_xmm_double_reg(), value->as_xmm_double_reg());\n@@ -2567,0 +2555,4 @@\n+          assert(!tmp->is_valid(), \"do not need temporary\");\n+          __ andpd(dest->as_xmm_double_reg(),\n+                   ExternalAddress((address)double_signmask_pool),\n+                   rscratch1);\n@@ -4004,16 +3996,3 @@\n-#ifdef _LP64\n-    if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-      assert(tmp->is_valid(), \"need temporary\");\n-      assert_different_registers(left->as_xmm_float_reg(), tmp->as_xmm_float_reg());\n-      __ vpxor(dest->as_xmm_float_reg(), tmp->as_xmm_float_reg(), left->as_xmm_float_reg(), 2);\n-    }\n-    else\n-#endif\n-    {\n-      assert(!tmp->is_valid(), \"do not need temporary\");\n-      if (left->as_xmm_float_reg() != dest->as_xmm_float_reg()) {\n-        __ movflt(dest->as_xmm_float_reg(), left->as_xmm_float_reg());\n-      }\n-      __ xorps(dest->as_xmm_float_reg(),\n-               ExternalAddress((address)float_signflip_pool),\n-               rscratch1);\n+    assert(!tmp->is_valid(), \"do not need temporary\");\n+    if (left->as_xmm_float_reg() != dest->as_xmm_float_reg()) {\n+      __ movflt(dest->as_xmm_float_reg(), left->as_xmm_float_reg());\n@@ -4021,0 +4000,3 @@\n+    __ xorps(dest->as_xmm_float_reg(),\n+             ExternalAddress((address)float_signflip_pool),\n+             rscratch1);\n@@ -4022,16 +4004,3 @@\n-#ifdef _LP64\n-    if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-      assert(tmp->is_valid(), \"need temporary\");\n-      assert_different_registers(left->as_xmm_double_reg(), tmp->as_xmm_double_reg());\n-      __ vpxor(dest->as_xmm_double_reg(), tmp->as_xmm_double_reg(), left->as_xmm_double_reg(), 2);\n-    }\n-    else\n-#endif\n-    {\n-      assert(!tmp->is_valid(), \"do not need temporary\");\n-      if (left->as_xmm_double_reg() != dest->as_xmm_double_reg()) {\n-        __ movdbl(dest->as_xmm_double_reg(), left->as_xmm_double_reg());\n-      }\n-      __ xorpd(dest->as_xmm_double_reg(),\n-               ExternalAddress((address)double_signflip_pool),\n-               rscratch1);\n+    assert(!tmp->is_valid(), \"do not need temporary\");\n+    if (left->as_xmm_double_reg() != dest->as_xmm_double_reg()) {\n+      __ movdbl(dest->as_xmm_double_reg(), left->as_xmm_double_reg());\n@@ -4039,0 +4008,3 @@\n+    __ xorpd(dest->as_xmm_double_reg(),\n+             ExternalAddress((address)double_signflip_pool),\n+             rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":18,"deletions":46,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -372,14 +372,1 @@\n-  LIR_Opr tmp = LIR_OprFact::illegalOpr;\n-#ifdef _LP64\n-  if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-    if (x->type()->tag() == doubleTag) {\n-      tmp = new_register(T_DOUBLE);\n-      __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n-    }\n-    else if (x->type()->tag() == floatTag) {\n-      tmp = new_register(T_FLOAT);\n-      __ move(LIR_OprFact::floatConst(-0.0), tmp);\n-    }\n-  }\n-#endif\n-  __ negate(value.result(), reg, tmp);\n+  __ negate(value.result(), reg);\n@@ -858,7 +845,0 @@\n-#ifdef _LP64\n-  if (UseAVX > 2 && (!VM_Version::supports_avx512vl()) &&\n-      (x->id() == vmIntrinsics::_dabs)) {\n-    tmp = new_register(T_DOUBLE);\n-    __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n-  }\n-#endif\n@@ -867,1 +847,0 @@\n-    __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -160,0 +160,5 @@\n+      \/\/ sender_pc might be invalid so check that the frame\n+      \/\/ actually belongs to a Continuation.\n+      if (!Continuation::is_frame_in_continuation(thread, *this)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1204,1 +1204,5 @@\n-  if (reachable(src)) {\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      (dst->encoding() >= 16)) {\n+    vpand(dst, dst, src, AVX_512bit, rscratch);\n+  } else if (reachable(src)) {\n@@ -3471,1 +3475,6 @@\n-  if (reachable(src)) {\n+\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      (dst->encoding() >= 16)) {\n+    vpxor(dst, dst, src, Assembler::AVX_512bit, rscratch);\n+  } else if (reachable(src)) {\n@@ -3480,1 +3489,3 @@\n-  if (UseAVX > 2 && !VM_Version::supports_avx512dq() && (dst->encoding() == src->encoding())) {\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      ((dst->encoding() >= 16) || (src->encoding() >= 16))) {\n@@ -3482,2 +3493,1 @@\n-  }\n-  else {\n+  } else {\n@@ -3489,1 +3499,3 @@\n-  if (UseAVX > 2 && !VM_Version::supports_avx512dq() && (dst->encoding() == src->encoding())) {\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      ((dst->encoding() >= 16) || (src->encoding() >= 16))) {\n@@ -3501,1 +3513,6 @@\n-  if (reachable(src)) {\n+\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      (dst->encoding() >= 16)) {\n+    vpxor(dst, dst, src, Assembler::AVX_512bit, rscratch);\n+  } else if (reachable(src)) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1725,1 +1725,1 @@\n-          warning(\"Setting ArrayOperationPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n+          warning(\"Setting ArrayOperationPartialInlineSize as MaxVectorSize=%zd\", MaxVectorSize);\n@@ -1727,1 +1727,1 @@\n-          warning(\"Setting ArrayOperationPartialInlineSize as \" INTX_FORMAT, ArrayOperationPartialInlineSize);\n+          warning(\"Setting ArrayOperationPartialInlineSize as %zd\", ArrayOperationPartialInlineSize);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"compiler\/compilerDirectives.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"ci\/ciStreams.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -490,0 +490,5 @@\n+    case lir_sqrt:           \/\/ FP Ops have no info, but input and result\n+    case lir_abs:\n+    case lir_neg:\n+    case lir_f2hf:\n+    case lir_hf2f:\n@@ -496,0 +501,1 @@\n+      if (op1->_tmp->is_valid())       do_temp(op1->_tmp);\n@@ -521,0 +527,1 @@\n+      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -604,5 +611,0 @@\n-    case lir_sqrt:\n-    case lir_abs:\n-    case lir_neg:\n-    case lir_f2hf:\n-    case lir_hf2f:\n@@ -705,0 +707,1 @@\n+      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -1792,1 +1795,1 @@\n-  out->print(\" Disp: \" INTX_FORMAT, _disp);\n+  out->print(\" Disp: %zd\", _disp);\n@@ -1909,0 +1912,5 @@\n+     case lir_abs:                   s = \"abs\";           break;\n+     case lir_neg:                   s = \"neg\";           break;\n+     case lir_sqrt:                  s = \"sqrt\";          break;\n+     case lir_f2hf:                  s = \"f2hf\";          break;\n+     case lir_hf2f:                  s = \"hf2f\";          break;\n@@ -1925,5 +1933,0 @@\n-     case lir_abs:                   s = \"abs\";           break;\n-     case lir_neg:                   s = \"neg\";           break;\n-     case lir_sqrt:                  s = \"sqrt\";          break;\n-     case lir_f2hf:                  s = \"f2hf\";          break;\n-     case lir_hf2f:                  s = \"hf2f\";          break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -947,0 +947,5 @@\n+      , lir_sqrt\n+      , lir_abs\n+      , lir_neg\n+      , lir_f2hf\n+      , lir_hf2f\n@@ -963,7 +968,0 @@\n-      , lir_sqrt\n-      , lir_abs\n-      , lir_neg\n-      , lir_tan\n-      , lir_f2hf\n-      , lir_hf2f\n-      , lir_log10\n@@ -1384,0 +1382,1 @@\n+  LIR_Opr         _tmp;\n@@ -1398,0 +1397,8 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n+    , _type(type)\n+    , _patch(patch)                    { assert(is_in_range(code, begin_op1, end_op1), \"code check\"); }\n+\n+  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result, LIR_Opr tmp, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = nullptr)\n+    : LIR_Op(code, result, info)\n+    , _opr(opr)\n+    , _tmp(tmp)\n@@ -1404,0 +1411,1 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1413,0 +1421,1 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1417,0 +1426,1 @@\n+  LIR_Opr tmp_opr()          const               { return _tmp;   }\n@@ -2414,3 +2424,3 @@\n-  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_abs , from, tmp, to)); }\n-  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr)              { append(new LIR_Op2(lir_neg, from, tmp, to)); }\n-  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_sqrt, from, tmp, to)); }\n+  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_abs , from, to, tmp)); }\n+  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr) { append(new LIR_Op1(lir_neg, from, to, tmp)); }\n+  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_sqrt, from, to, tmp)); }\n@@ -2419,4 +2429,2 @@\n-  void log10 (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)              { append(new LIR_Op2(lir_log10, from, LIR_OprFact::illegalOpr, to, tmp)); }\n-  void tan (LIR_Opr from, LIR_Opr to, LIR_Opr tmp1, LIR_Opr tmp2) { append(new LIR_Op2(lir_tan , from, tmp1, to, tmp2)); }\n-  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_f2hf, from, tmp, to)); }\n-  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_hf2f, from, tmp, to)); }\n+  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_f2hf, from, to, tmp)); }\n+  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_hf2f, from, to, tmp)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -536,0 +536,11 @@\n+    case lir_abs:\n+    case lir_sqrt:\n+    case lir_f2hf:\n+    case lir_hf2f:\n+      intrinsic_op(op->code(), op->in_opr(), op->tmp_opr(), op->result_opr(), op);\n+      break;\n+\n+    case lir_neg:\n+      negate(op->in_opr(), op->result_opr(), op->tmp_opr());\n+      break;\n+\n@@ -858,13 +869,0 @@\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_tan:\n-    case lir_log10:\n-    case lir_f2hf:\n-    case lir_hf2f:\n-      intrinsic_op(op->code(), op->in_opr1(), op->in_opr2(), op->result_opr(), op);\n-      break;\n-\n-    case lir_neg:\n-      negate(op->in_opr1(), op->result_opr(), op->in_opr2());\n-      break;\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,1 +224,1 @@\n-  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op);\n+  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr temp, LIR_Opr dest, LIR_Op* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6742,1 +6742,0 @@\n-        case lir_log10:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"classfile\/modules.hpp\"\n@@ -326,0 +327,4 @@\n+\n+    if (java_lang_Module::is_instance(src_obj)) {\n+      Modules::check_archived_module_oop(src_obj);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-  st->print(INTX_FORMAT, v);\n+  st->print(\"%zd\", v);\n@@ -97,1 +97,1 @@\n-  st->print(UINTX_FORMAT, v);\n+  st->print(\"%zu\", v);\n@@ -355,1 +355,1 @@\n-  st->print_cr(\"- max_heap_size:                  \" UINTX_FORMAT, _max_heap_size);\n+  st->print_cr(\"- max_heap_size:                  %zu\", _max_heap_size);\n@@ -1584,0 +1584,1 @@\n+  _in_reserved_space = false;\n@@ -1965,1 +1966,1 @@\n-  assert(r->mapped_base() == nullptr, \"must be not mapped yet\");\n+  assert(!is_mapped(), \"must be not mapped yet\");\n@@ -1969,0 +1970,1 @@\n+  r->set_in_reserved_space(false);\n@@ -1993,1 +1995,0 @@\n-      return MAP_ARCHIVE_SUCCESS;\n@@ -2015,0 +2016,1 @@\n+  }\n@@ -2016,1 +2018,6 @@\n-    return MAP_ARCHIVE_SUCCESS;\n+  if (rs.is_reserved()) {\n+    char* mapped_base = r->mapped_base();\n+    assert(rs.base() <= mapped_base && mapped_base + size <= rs.end(),\n+           PTR_FORMAT \" <= \" PTR_FORMAT \" < \" PTR_FORMAT \" <= \" PTR_FORMAT,\n+           p2i(rs.base()), p2i(mapped_base), p2i(mapped_base + size), p2i(rs.end()));\n+    r->set_in_reserved_space(rs.is_reserved());\n@@ -2018,0 +2025,1 @@\n+  return MAP_ARCHIVE_SUCCESS;\n@@ -2435,1 +2443,0 @@\n-      unmap_region(MetaspaceShared::hp);\n@@ -2442,1 +2449,1 @@\n-  log_info(cds)(\"CDS heap data relocation delta = \" INTX_FORMAT \" bytes\", delta);\n+  log_info(cds)(\"CDS heap data relocation delta = %zd bytes\", delta);\n@@ -2504,2 +2511,8 @@\n-      if (!os::unmap_memory(mapped_base, size)) {\n-        fatal(\"os::unmap_memory failed\");\n+      if (r->in_reserved_space()) {\n+        \/\/ This region was mapped inside a ReservedSpace. Its memory will be freed when the ReservedSpace\n+        \/\/ is released. Zero it so that we don't accidentally read its content.\n+        log_info(cds)(\"Region #%d (%s) is in a reserved space, it will be freed when the space is released\", i, shared_region_name[i]);\n+      } else {\n+        if (!os::unmap_memory(mapped_base, size)) {\n+          fatal(\"os::unmap_memory failed\");\n+        }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,0 +167,1 @@\n+  bool   in_reserved_space()        const { return _in_reserved_space; }\n@@ -172,0 +173,1 @@\n+  void set_in_reserved_space(bool is_reserved) { _in_reserved_space = is_reserved; }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/aotArtifactFinder.hpp\"\n@@ -223,1 +224,3 @@\n-\n+  if (obj != nullptr) {\n+    assert(has_been_archived(obj), \"must be\");\n+  }\n@@ -293,1 +296,1 @@\n-bool HeapShared::archive_object(oop obj) {\n+bool HeapShared::archive_object(oop obj, KlassSubGraphInfo* subgraph_info) {\n@@ -314,0 +317,30 @@\n+    Klass* k = obj->klass();\n+    if (k->is_instance_klass()) {\n+      \/\/ Whenever we see a non-array Java object of type X, we mark X to be aot-initialized.\n+      \/\/ This ensures that during the production run, whenever Java code sees a cached object\n+      \/\/ of type X, we know that X is already initialized. (see TODO comment below ...)\n+\n+      if (InstanceKlass::cast(k)->is_enum_subclass()\n+          \/\/ We can't rerun <clinit> of enum classes (see cdsEnumKlass.cpp) so\n+          \/\/ we must store them as AOT-initialized.\n+          || (subgraph_info == _dump_time_special_subgraph))\n+          \/\/ TODO: we do this only for the special subgraph for now. Extending this to\n+          \/\/ other subgraphs would require more refactoring of the core library (such as\n+          \/\/ move some initialization logic into runtimeSetup()).\n+          \/\/\n+          \/\/ For the other subgraphs, we have a weaker mechanism to ensure that\n+          \/\/ all classes in a subgraph are initialized before the subgraph is programmatically\n+          \/\/ returned from jdk.internal.misc.CDS::initializeFromArchive().\n+          \/\/ See HeapShared::initialize_from_archived_subgraph().\n+      {\n+        AOTArtifactFinder::add_aot_inited_class(InstanceKlass::cast(k));\n+      }\n+\n+      if (java_lang_Class::is_instance(obj)) {\n+        Klass* mirror_k = java_lang_Class::as_Klass(obj);\n+        if (mirror_k != nullptr) {\n+          AOTArtifactFinder::add_cached_class(mirror_k);\n+        }\n+      }\n+    }\n+\n@@ -331,4 +364,0 @@\n-    if (java_lang_Module::is_instance(obj) && Modules::check_archived_module_oop(obj)) {\n-      Modules::update_oops_in_archived_module(obj, append_root(obj));\n-    }\n-\n@@ -370,1 +399,3 @@\n-  _scratch_references_table->set_oop(src, dest);\n+  if (SystemDictionaryShared::is_builtin_loader(src->pool_holder()->class_loader_data())) {\n+    _scratch_references_table->set_oop(src, dest);\n+  }\n@@ -469,4 +500,8 @@\n-void HeapShared::copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m) {\n-  assert(orig_k->is_instance_klass(), \"sanity\");\n-  InstanceKlass* ik = InstanceKlass::cast(orig_k);\n-  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n+void HeapShared::copy_and_rescan_aot_inited_mirror(InstanceKlass* ik) {\n+  ik->set_has_aot_initialized_mirror();\n+  if (AOTClassInitializer::is_runtime_setup_required(ik)) {\n+    ik->set_is_runtime_setup_required();\n+  }\n+\n+  oop orig_mirror = ik->java_mirror();\n+  oop m = scratch_java_mirror(ik);\n@@ -484,1 +519,13 @@\n-        m->obj_field_put(offset, orig_mirror->obj_field(offset));\n+        {\n+          oop field_obj = orig_mirror->obj_field(offset);\n+          if (offset == java_lang_Class::reflection_data_offset()) {\n+            \/\/ Class::reflectData use SoftReference, which cannot be archived. Set it\n+            \/\/ to null and it will be recreated at runtime.\n+            field_obj = nullptr;\n+          }\n+          m->obj_field_put(offset, field_obj);\n+          if (field_obj != nullptr) {\n+            bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, field_obj);\n+            assert(success, \"sanity\");\n+          }\n+        }\n@@ -517,5 +564,6 @@\n-  java_lang_Class::set_class_data(m, java_lang_Class::class_data(orig_mirror));\n-\n-  \/\/ Class::reflectData use SoftReference, which cannot be archived. Set it\n-  \/\/ to null and it will be recreated at runtime.\n-  java_lang_Class::set_reflection_data(m, nullptr);\n+  oop class_data = java_lang_Class::class_data(orig_mirror);\n+  java_lang_Class::set_class_data(m, class_data);\n+  if (class_data != nullptr) {\n+    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, class_data);\n+    assert(success, \"sanity\");\n+  }\n@@ -525,2 +573,3 @@\n-    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s\", nfields, ik->external_name(),\n-                         ik->is_hidden() ? \" (hidden)\" : \"\");\n+    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s%s\", nfields, ik->external_name(),\n+                         ik->is_hidden() ? \" (hidden)\" : \"\",\n+                         ik->is_enum_subclass() ? \" (enum)\" : \"\");\n@@ -549,4 +598,1 @@\n-  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n-  if (buffered_ik->is_shared_boot_class() ||\n-      buffered_ik->is_shared_platform_class() ||\n-      buffered_ik->is_shared_app_class()) {\n+  if (SystemDictionaryShared::is_builtin_loader(src_ik->class_loader_data())) {\n@@ -561,61 +607,1 @@\n-void HeapShared::archive_java_mirrors() {\n-  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-    BasicType bt = (BasicType)i;\n-    if (!is_reference_type(bt)) {\n-      oop orig_mirror = Universe::java_mirror(bt);\n-      oop m = _scratch_basic_type_mirrors[i].resolve();\n-      assert(m != nullptr, \"sanity\");\n-      copy_java_mirror_hashcode(orig_mirror, m);\n-      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n-      assert(success, \"sanity\");\n-\n-      log_trace(cds, heap, mirror)(\n-        \"Archived %s mirror object from \" PTR_FORMAT,\n-        type2name(bt), p2i(m));\n-\n-      Universe::set_archived_basic_type_mirror_index(bt, append_root(m));\n-    }\n-  }\n-\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  assert(klasses != nullptr, \"sanity\");\n-\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* orig_k = klasses->at(i);\n-    oop orig_mirror = orig_k->java_mirror();\n-    oop m = scratch_java_mirror(orig_k);\n-    if (m != nullptr) {\n-      copy_java_mirror_hashcode(orig_mirror, m);\n-    }\n-  }\n-\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* orig_k = klasses->at(i);\n-    oop orig_mirror = orig_k->java_mirror();\n-    oop m = scratch_java_mirror(orig_k);\n-    if (m != nullptr) {\n-      Klass* buffered_k = ArchiveBuilder::get_buffered_klass(orig_k);\n-      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n-      guarantee(success, \"scratch mirrors must point to only archivable objects\");\n-      buffered_k->set_archived_java_mirror(append_root(m));\n-      ResourceMark rm;\n-      log_trace(cds, heap, mirror)(\n-        \"Archived %s mirror object from \" PTR_FORMAT,\n-        buffered_k->external_name(), p2i(m));\n-\n-      \/\/ archive the resolved_referenes array\n-      if (buffered_k->is_instance_klass()) {\n-        InstanceKlass* ik = InstanceKlass::cast(buffered_k);\n-        objArrayOop rr = get_archived_resolved_references(InstanceKlass::cast(orig_k));\n-        if (rr != nullptr) {\n-          bool success = HeapShared::archive_reachable_objects_from(1, _dump_time_special_subgraph, rr);\n-          assert(success, \"must be\");\n-          int root_index = append_root(rr);\n-          ik->constants()->cache()->set_archived_references(root_index);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-  oop shared_strings_array = StringTable::init_shared_table(_dumped_interned_strings);\n+  oop shared_strings_array = StringTable::init_shared_strings_array(_dumped_interned_strings);\n@@ -659,109 +645,3 @@\n-void HeapShared::start_finding_required_hidden_classes() {\n-  if (!CDSConfig::is_dumping_invokedynamic()) {\n-    return;\n-  }\n-  NoSafepointVerifier nsv;\n-\n-  init_seen_objects_table();\n-\n-  \/\/ We first scan the objects that are known to be archived (from the archive_subgraph\n-  \/\/ tables)\n-  find_required_hidden_classes_helper(archive_subgraph_entry_fields);\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    find_required_hidden_classes_helper(fmg_archive_subgraph_entry_fields);\n-  }\n-\n-  \/\/ Later, SystemDictionaryShared::find_all_archivable_classes_impl() will start\n-  \/\/ scanning the constant pools of all classes that it decides to archive.\n-}\n-\n-void HeapShared::end_finding_required_hidden_classes() {\n-  if (!CDSConfig::is_dumping_invokedynamic()) {\n-    return;\n-  }\n-  NoSafepointVerifier nsv;\n-\n-  delete_seen_objects_table();\n-}\n-\n-void HeapShared::find_required_hidden_classes_helper(ArchivableStaticFieldInfo fields[]) {\n-  if (!CDSConfig::is_dumping_heap()) {\n-    return;\n-  }\n-  for (int i = 0; fields[i].valid(); i++) {\n-    ArchivableStaticFieldInfo* f = &fields[i];\n-    InstanceKlass* k = f->klass;\n-    oop m = k->java_mirror();\n-    oop o = m->obj_field(f->offset);\n-    if (o != nullptr) {\n-      find_required_hidden_classes_in_object(o);\n-    }\n-  }\n-}\n-\n-class HeapShared::FindRequiredHiddenClassesOopClosure: public BasicOopIterateClosure {\n-  GrowableArray<oop> _stack;\n-  template <class T> void do_oop_work(T *p) {\n-    \/\/ Recurse on a GrowableArray to avoid overflowing the C stack.\n-    oop o = RawAccess<>::oop_load(p);\n-    if (o != nullptr) {\n-      _stack.append(o);\n-    }\n-  }\n-\n- public:\n-\n-  void do_oop(narrowOop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n-  void do_oop(      oop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n-\n-  FindRequiredHiddenClassesOopClosure(oop o) {\n-    _stack.append(o);\n-  }\n-  oop pop() {\n-    if (_stack.length() == 0) {\n-      return nullptr;\n-    } else {\n-      return _stack.pop();\n-    }\n-  }\n-};\n-\n-static void mark_required_if_hidden_class(Klass* k) {\n-  if (k != nullptr && k->is_instance_klass()) {\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    if (ik->is_hidden()) {\n-      SystemDictionaryShared::mark_required_hidden_class(ik);\n-    }\n-  }\n-}\n-\n-\n-void HeapShared::find_required_hidden_classes_in_object(oop root) {\n-  ResourceMark rm;\n-  FindRequiredHiddenClassesOopClosure c(root);\n-  oop o;\n-  while ((o = c.pop()) != nullptr) {\n-    if (!has_been_seen_during_subgraph_recording(o)) {\n-      set_has_been_seen_during_subgraph_recording(o);\n-\n-      \/\/ Mark the klass of this object\n-      mark_required_if_hidden_class(o->klass());\n-\n-      \/\/ For special objects, mark the klass that they contain information about.\n-      \/\/ - a Class that refers to an hidden class\n-      \/\/ - a ResolvedMethodName that refers to a method declared in a hidden class\n-      if (java_lang_Class::is_instance(o)) {\n-        mark_required_if_hidden_class(java_lang_Class::as_Klass(o));\n-      } else if (java_lang_invoke_ResolvedMethodName::is_instance(o)) {\n-        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(o);\n-        if (m != nullptr) {\n-          mark_required_if_hidden_class(m->method_holder());\n-        }\n-      }\n-\n-      o->oop_iterate(&c);\n-    }\n-  }\n-}\n-\n-void HeapShared::archive_objects(ArchiveHeapInfo *heap_info) {\n+\/\/ Between start_scanning_for_oops() and end_scanning_for_oops(), we discover all Java heap objects that\n+\/\/ should be stored in the AOT cache. The scanning is coordinated by AOTArtifactFinder.\n+void HeapShared::start_scanning_for_oops() {\n@@ -785,3 +665,1 @@\n-    copy_objects();\n-    CDSHeapVerifier::verify();\n-    check_special_subgraph_classes();\n+    archive_subgraphs();\n@@ -791,4 +669,2 @@\n-  ArchiveHeapWriter::write(_pending_roots, heap_info);\n-}\n-\n-void HeapShared::copy_interned_strings() {\n+  Universe::archive_exception_instances();\n+}\n@@ -797,11 +673,2 @@\n-  auto copier = [&] (oop s, bool value_ignored) {\n-    assert(s != nullptr, \"sanity\");\n-    assert(!ArchiveHeapWriter::is_string_too_large_to_archive(s), \"large strings must have been filtered\");\n-    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, s);\n-    assert(success, \"must be\");\n-    \/\/ Prevent string deduplication from changing the value field to\n-    \/\/ something not in the archive.\n-    java_lang_String::set_deduplication_forbidden(s);\n-  };\n-  _dumped_interned_strings->iterate_all(copier);\n-\n+void HeapShared::end_scanning_for_oops() {\n+  archive_strings();\n@@ -811,4 +678,1 @@\n-void HeapShared::copy_special_subgraph() {\n-  copy_interned_strings();\n-\n-  init_seen_objects_table();\n+void HeapShared::write_heap(ArchiveHeapInfo *heap_info) {\n@@ -816,3 +680,18 @@\n-    archive_java_mirrors();\n-    archive_strings();\n-    Universe::archive_exception_instances();\n+    NoSafepointVerifier nsv;\n+    CDSHeapVerifier::verify();\n+    check_special_subgraph_classes();\n+  }\n+\n+  StringTable::write_shared_table(_dumped_interned_strings);\n+  ArchiveHeapWriter::write(_pending_roots, heap_info);\n+\n+  ArchiveBuilder::OtherROAllocMark mark;\n+  write_subgraph_info_table();\n+}\n+\n+void HeapShared::scan_java_mirror(oop orig_mirror) {\n+  oop m = scratch_java_mirror(orig_mirror);\n+  if (m != nullptr) { \/\/ nullptr if for custom class loader\n+    copy_java_mirror_hashcode(orig_mirror, m);\n+    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n+    assert(success, \"sanity\");\n@@ -820,1 +699,0 @@\n-  delete_seen_objects_table();\n@@ -823,7 +701,10 @@\n-void HeapShared::prepare_resolved_references() {\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* src_k = klasses->at(i);\n-    if (src_k->is_instance_klass()) {\n-      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_k));\n-      buffered_ik->constants()->prepare_resolved_references_for_archiving();\n+void HeapShared::scan_java_class(Klass* orig_k) {\n+  scan_java_mirror(orig_k->java_mirror());\n+\n+  if (orig_k->is_instance_klass()) {\n+    InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n+    orig_ik->constants()->prepare_resolved_references_for_archiving();\n+    objArrayOop rr = get_archived_resolved_references(orig_ik);\n+    if (rr != nullptr) {\n+      bool success = HeapShared::archive_reachable_objects_from(1, _dump_time_special_subgraph, rr);\n+      assert(success, \"must be\");\n@@ -831,0 +712,2 @@\n+\n+    orig_ik->constants()->add_dumped_interned_strings();\n@@ -834,1 +717,1 @@\n-void HeapShared::copy_objects() {\n+void HeapShared::archive_subgraphs() {\n@@ -837,4 +720,0 @@\n-  prepare_resolved_references();\n-  find_all_aot_initialized_classes();\n-  copy_special_subgraph();\n-\n@@ -851,192 +730,0 @@\n-\/\/ Closure used by HeapShared::scan_for_aot_initialized_classes() to look for all objects\n-\/\/ that are reachable from a given root.\n-class HeapShared::AOTInitializedClassScanner : public BasicOopIterateClosure {\n-  bool _made_progress;\n-\n-  template <class T> void check(T *p) {\n-    oop obj = HeapAccess<>::oop_load(p);\n-    if (!java_lang_Class::is_instance(obj)) {\n-      \/\/ Don't scan the mirrors, as we may see an orig_mirror while scanning\n-      \/\/ the object graph, .... TODO more info\n-      _made_progress |= HeapShared::scan_for_aot_initialized_classes(obj);\n-    }\n-  }\n-\n-public:\n-  AOTInitializedClassScanner() : _made_progress(false) {}\n-  void do_oop(narrowOop *p) { check(p); }\n-  void do_oop(      oop *p) { check(p); }\n-  bool made_progress() { return _made_progress; }\n-};\n-\n-\/\/ If <buffered_ik> has been initialized during the assembly phase, mark its\n-\/\/ has_aot_initialized_mirror bit. And then do the same for all supertypes of\n-\/\/ <buffered_ik>.\n-\/\/\n-\/\/ Note: a super interface <intf> of <buffered_ik> may not have been initialized, if\n-\/\/ <intf> has not declared any default methods.\n-\/\/\n-\/\/ Note: this function doesn not call InstanceKlass::initialize() -- we are inside\n-\/\/ a safepoint.\n-\/\/\n-\/\/ Returns true if one or more classes have been newly marked.\n-static bool mark_for_aot_initialization(InstanceKlass* buffered_ik) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n-  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n-\n-  if (buffered_ik->has_aot_initialized_mirror()) { \/\/ already marked\n-    return false;\n-  }\n-\n-  bool made_progress = false;\n-  if (buffered_ik->is_initialized()) {\n-    if (log_is_enabled(Info, cds, init)) {\n-      ResourceMark rm;\n-      log_info(cds, init)(\"Mark class for aot-init: %s\", buffered_ik->external_name());\n-    }\n-\n-    InstanceKlass* src_ik = ArchiveBuilder::current()->get_source_addr(buffered_ik);\n-\n-    \/\/ If we get here with a \"wild\" user class, which may have\n-    \/\/ uncontrolled <clinit> code, exit with an error.  Obviously\n-    \/\/ filtering logic upstream needs to detect APP classes and not mark\n-    \/\/ them for aot-init in the first place, but this will be the final\n-    \/\/ firewall.\n-\n-#ifndef PRODUCT\n-    \/\/ ArchiveHeapTestClass is used for a very small number of internal regression\n-    \/\/ tests (non-product builds only). It may initialize some unexpected classes.\n-    if (ArchiveHeapTestClass == nullptr)\n-#endif\n-    {\n-      if (!src_ik->in_javabase_module()) {\n-        \/\/ Class\/interface types in the boot loader may have been initialized as side effects\n-        \/\/ of JVM bootstrap code, so they are fine. But we need to check all other classes.\n-        if (buffered_ik->is_interface()) {\n-          \/\/ This probably means a bug in AOTConstantPoolResolver.::is_indy_resolution_deterministic()\n-          guarantee(!buffered_ik->interface_needs_clinit_execution_as_super(),\n-                    \"should not have initialized an interface whose <clinit> might have unpredictable side effects\");\n-        } else {\n-          \/\/ \"normal\" classes\n-          guarantee(HeapShared::is_archivable_hidden_klass(buffered_ik),\n-                    \"should not have initialized any non-interface, non-hidden classes outside of java.base\");\n-        }\n-      }\n-    }\n-\n-    buffered_ik->set_has_aot_initialized_mirror();\n-    if (AOTClassInitializer::is_runtime_setup_required(src_ik)) {\n-      buffered_ik->set_is_runtime_setup_required();\n-    }\n-    made_progress = true;\n-\n-    InstanceKlass* super = buffered_ik->java_super();\n-    if (super != nullptr) {\n-      mark_for_aot_initialization(super);\n-    }\n-\n-    Array<InstanceKlass*>* interfaces = buffered_ik->transitive_interfaces();\n-    for (int i = 0; i < interfaces->length(); i++) {\n-      InstanceKlass* intf = interfaces->at(i);\n-      mark_for_aot_initialization(intf);\n-      if (!intf->is_initialized()) {\n-        assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false), \"sanity\");\n-        assert(!intf->has_aot_initialized_mirror(), \"must not be marked\");\n-      }\n-    }\n-  }\n-\n-  return made_progress;\n-}\n-\n-void HeapShared::find_all_aot_initialized_classes() {\n-  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n-    return;\n-  }\n-\n-  init_seen_objects_table();\n-  find_all_aot_initialized_classes_helper();\n-  delete_seen_objects_table();\n-}\n-\n-\/\/ Recursively find all class that should be aot-initialized:\n-\/\/ - the class has at least one instance that can be reachable from the special subgraph; or\n-\/\/ - the class is hard-coded in AOTClassInitializer::can_archive_initialized_mirror()\n-void HeapShared::find_all_aot_initialized_classes_helper() {\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  assert(klasses != nullptr, \"sanity\");\n-\n-  \/\/ First scan all resolved constant pools references.\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* src_k = klasses->at(i);\n-    if (src_k->is_instance_klass()) {\n-      InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n-      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n-      objArrayOop rr = get_archived_resolved_references(src_ik);\n-      if (rr != nullptr) {\n-        objArrayOop scratch_rr = scratch_resolved_references(src_ik->constants());\n-        for (int i = 0; i < scratch_rr->length(); i++) {\n-          scan_for_aot_initialized_classes(scratch_rr->obj_at(i));\n-        }\n-      }\n-\n-      \/\/ If a class is hard-coded to be aot-initialize, mark it as such.\n-      if (AOTClassInitializer::can_archive_initialized_mirror(src_ik)) {\n-        mark_for_aot_initialization(buffered_ik);\n-      }\n-    }\n-  }\n-\n-  \/\/ These objects also belong to the special subgraph\n-  scan_for_aot_initialized_classes(Universe::null_ptr_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::arithmetic_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::internal_error_instance());\n-  scan_for_aot_initialized_classes(Universe::array_index_out_of_bounds_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::array_store_exception_instance());\n-  scan_for_aot_initialized_classes(Universe::class_cast_exception_instance());\n-\n-  bool made_progress;\n-  do {\n-    \/\/ In each pass, we copy the scratch mirrors of the classes that were marked\n-    \/\/ as aot-init in the previous pass. We then scan these mirrors, which may\n-    \/\/ mark more classes. Keep iterating until no more progress can be made.\n-    made_progress = false;\n-    for (int i = 0; i < klasses->length(); i++) {\n-      Klass* orig_k = klasses->at(i);\n-      if (orig_k->is_instance_klass()) {\n-        InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n-        if (ArchiveBuilder::current()->get_buffered_addr(orig_ik)->has_aot_initialized_mirror()) {\n-          oop orig_mirror = orig_ik->java_mirror();\n-          oop scratch_mirror = scratch_java_mirror(orig_k);\n-          if (!has_been_seen_during_subgraph_recording(scratch_mirror)) {\n-            \/\/ Scan scratch_mirror instead of orig_mirror (which has fields like ClassLoader that\n-            \/\/ are not archived).\n-            copy_aot_initialized_mirror(orig_k, orig_mirror, scratch_mirror);\n-            made_progress |= scan_for_aot_initialized_classes(scratch_mirror);\n-          }\n-        }\n-      }\n-    }\n-  } while (made_progress);\n-}\n-\n-bool HeapShared::scan_for_aot_initialized_classes(oop obj) {\n-  if (obj == nullptr || has_been_seen_during_subgraph_recording(obj)) {\n-    return false;\n-  }\n-  set_has_been_seen_during_subgraph_recording(obj);\n-\n-  bool made_progress = false;\n-  Klass* k = obj->klass();\n-  if (k->is_instance_klass()) {\n-    InstanceKlass* orig_ik = InstanceKlass::cast(k);\n-    InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(orig_ik);\n-    made_progress = mark_for_aot_initialization(buffered_ik);\n-  }\n-\n-  AOTInitializedClassScanner scanner;\n-  obj->oop_iterate(&scanner);\n-  made_progress |= scanner.made_progress();\n-  return made_progress;\n-}\n-\n@@ -1055,2 +742,1 @@\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(k);\n-    _dump_time_subgraph_info_table->put_if_absent(k, KlassSubGraphInfo(buffered_k, is_full_module_graph),\n+    _dump_time_subgraph_info_table->put_if_absent(k, KlassSubGraphInfo(k, is_full_module_graph),\n@@ -1085,1 +771,0 @@\n-  Klass* buffered_k = ArchiveBuilder::get_buffered_klass(orig_k);\n@@ -1092,3 +777,1 @@\n-  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_k), \"must be a shared class\");\n-\n-  if (_k == buffered_k) {\n+  if (_k == orig_k) {\n@@ -1100,1 +783,3 @@\n-  if (buffered_k->is_instance_klass()) {\n+  if (orig_k->is_instance_klass()) {\n+#ifdef ASSERT\n+    InstanceKlass* ik = InstanceKlass::cast(orig_k);\n@@ -1102,2 +787,2 @@\n-      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class() ||\n-             HeapShared::is_lambda_proxy_klass(InstanceKlass::cast(buffered_k)),\n+      assert(ik->class_loader() == nullptr ||\n+             HeapShared::is_lambda_proxy_klass(ik),\n@@ -1106,2 +791,1 @@\n-      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n-             \"must be boot class\");\n+      assert(ik->class_loader() == nullptr, \"must be boot class\");\n@@ -1109,0 +793,1 @@\n+#endif\n@@ -1117,6 +802,2 @@\n-    if (buffered_k->has_aot_initialized_mirror()) {\n-      \/\/ No need to add to the runtime-init list.\n-      return;\n-    }\n-  } else if (buffered_k->is_objArray_klass()) {\n-    Klass* abk = ObjArrayKlass::cast(buffered_k)->bottom_klass();\n+  } else if (orig_k->is_objArray_klass()) {\n+    Klass* abk = ObjArrayKlass::cast(orig_k)->bottom_klass();\n@@ -1129,1 +810,1 @@\n-    if (buffered_k == Universe::objectArrayKlass()) {\n+    if (orig_k == Universe::objectArrayKlass()) {\n@@ -1135,1 +816,1 @@\n-    assert(buffered_k->is_typeArray_klass(), \"must be\");\n+    assert(orig_k->is_typeArray_klass(), \"must be\");\n@@ -1141,1 +822,1 @@\n-    if (!_subgraph_object_klasses->contains(buffered_k)) {\n+    if (!_subgraph_object_klasses->contains(orig_k)) {\n@@ -1147,1 +828,1 @@\n-  _subgraph_object_klasses->append_if_missing(buffered_k);\n+  _subgraph_object_klasses->append_if_missing(orig_k);\n@@ -1203,1 +884,1 @@\n-  _k = info->klass();\n+  _k = ArchiveBuilder::get_buffered_klass(info->klass());\n@@ -1236,6 +917,16 @@\n-  \/\/ the Klasses of the objects in the sub-graphs\n-  GrowableArray<Klass*>* subgraph_object_klasses = info->subgraph_object_klasses();\n-  if (subgraph_object_klasses != nullptr) {\n-    int num_subgraphs_klasses = subgraph_object_klasses->length();\n-    _subgraph_object_klasses =\n-      ArchiveBuilder::new_ro_array<Klass*>(num_subgraphs_klasses);\n+  \/\/ <recorded_klasses> has the Klasses of all the objects that are referenced by this subgraph.\n+  \/\/ Copy those that need to be explicitly initialized into <_subgraph_object_klasses>.\n+  GrowableArray<Klass*>* recorded_klasses = info->subgraph_object_klasses();\n+  if (recorded_klasses != nullptr) {\n+    \/\/ AOT-inited classes are automatically marked as \"initialized\" during bootstrap. When\n+    \/\/ programmatically loading a subgraph, we only need to explicitly initialize the classes\n+    \/\/ that are not aot-inited.\n+    int num_to_copy = 0;\n+    for (int i = 0; i < recorded_klasses->length(); i++) {\n+      Klass* subgraph_k = ArchiveBuilder::get_buffered_klass(recorded_klasses->at(i));\n+      if (!subgraph_k->has_aot_initialized_mirror()) {\n+        num_to_copy ++;\n+      }\n+    }\n+\n+    _subgraph_object_klasses = ArchiveBuilder::new_ro_array<Klass*>(num_to_copy);\n@@ -1243,2 +934,5 @@\n-    for (int i = 0; i < num_subgraphs_klasses; i++) {\n-      Klass* subgraph_k = subgraph_object_klasses->at(i);\n+    for (int i = 0, n = 0; i < recorded_klasses->length(); i++) {\n+      Klass* subgraph_k = ArchiveBuilder::get_buffered_klass(recorded_klasses->at(i));\n+      if (subgraph_k->has_aot_initialized_mirror()) {\n+        continue;\n+      }\n@@ -1253,1 +947,1 @@\n-          owner_name, i, subgraph_k->external_name());\n+          owner_name, n, subgraph_k->external_name());\n@@ -1255,2 +949,3 @@\n-      _subgraph_object_klasses->at_put(i, subgraph_k);\n-      ArchivePtrMarker::mark_pointer(_subgraph_object_klasses->adr_at(i));\n+      _subgraph_object_klasses->at_put(n, subgraph_k);\n+      ArchivePtrMarker::mark_pointer(_subgraph_object_klasses->adr_at(n));\n+      n++;\n@@ -1834,1 +1529,1 @@\n-    if (!archive_object(orig_obj)) {\n+    if (!archive_object(orig_obj, subgraph_info)) {\n@@ -2014,1 +1709,1 @@\n-      Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+      Symbol* name = subgraph_k->name();\n@@ -2347,0 +2042,3 @@\n+    \/\/ Prevent string deduplication from changing the value field to\n+    \/\/ something not in the archive.\n+    java_lang_String::set_deduplication_forbidden(string);\n@@ -2351,0 +2049,4 @@\n+bool HeapShared::is_dumped_interned_string(oop o) {\n+  return _dumped_interned_strings->get(o) != nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":161,"deletions":459,"binary":false,"changes":620,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/aotArtifactFinder.hpp\"\n@@ -127,1 +128,1 @@\n-\/\/ The heap region is populated by HeapShared::archive_objects.\n+\/\/ The heap region is written by HeapShared::write_heap().\n@@ -549,0 +550,1 @@\n+    AOTArtifactFinder::all_cached_classes_do(it);\n@@ -619,1 +621,9 @@\n-  SystemDictionaryShared::find_all_archivable_classes();\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (HeapShared::can_write() && _extra_interned_strings != nullptr) {\n+    for (int i = 0; i < _extra_interned_strings->length(); i ++) {\n+      OopHandle string = _extra_interned_strings->at(i);\n+      HeapShared::add_to_dumped_interned_strings(string.resolve());\n+    }\n+  }\n+#endif\n@@ -631,3 +641,0 @@\n-  dump_java_heap_objects(_builder.klasses());\n-  dump_shared_symbol_table(_builder.symbols());\n-\n@@ -638,0 +645,3 @@\n+  dump_java_heap_objects(_builder.klasses());\n+  dump_shared_symbol_table(_builder.symbols());\n+\n@@ -1009,1 +1019,1 @@\n-  if(!HeapShared::can_write()) {\n+  if (!HeapShared::can_write()) {\n@@ -1017,19 +1027,1 @@\n-  \/\/ Find all the interned strings that should be dumped.\n-  int i;\n-  for (i = 0; i < klasses->length(); i++) {\n-    Klass* k = klasses->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      ik->constants()->add_dumped_interned_strings();\n-    }\n-  }\n-  if (_extra_interned_strings != nullptr) {\n-    for (i = 0; i < _extra_interned_strings->length(); i ++) {\n-      OopHandle string = _extra_interned_strings->at(i);\n-      HeapShared::add_to_dumped_interned_strings(string.resolve());\n-    }\n-  }\n-\n-  HeapShared::archive_objects(&_heap_info);\n-  ArchiveBuilder::OtherROAllocMark mark;\n-  HeapShared::write_subgraph_info_table();\n+  HeapShared::write_heap(&_heap_info);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-template<class E> class GrowableArray;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -794,1 +794,1 @@\n-    out->print(\" \" INTX_FORMAT_X, data()[i]);\n+    out->print(\" 0x%zx\", data()[i]);\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,1 +315,0 @@\n-  static int component_mirror_offset()     { CHECK_INIT(_component_mirror_offset); }\n@@ -328,0 +327,1 @@\n+  static int component_mirror_offset() { return _component_mirror_offset; }\n@@ -332,0 +332,1 @@\n+  static int reflection_data_offset() { return _reflectionData_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1607,1 +1607,1 @@\n-    log->print(\" \" XSTR(name) \"_offset='\" INTX_FORMAT \"'\"    , \\\n+    log->print(\" \" XSTR(name) \"_offset='%zd'\"    , \\\n@@ -1983,1 +1983,1 @@\n-      xtty->begin_elem(\"make_not_entrant thread='\" UINTX_FORMAT \"'\",\n+      xtty->begin_elem(\"make_not_entrant thread='%zu'\",\n@@ -2131,1 +2131,1 @@\n-                       \"\/Free CodeCache:\" SIZE_FORMAT \"Kb\",\n+                       \"\/Free CodeCache:%zuKb\",\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  st->print(\"vtable stub (index = %d, receiver_location = \" INTX_FORMAT \", code = [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \"])\",\n+  st->print(\"vtable stub (index = %d, receiver_location = %zd, code = [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \"])\",\n@@ -229,1 +229,1 @@\n-        tty->print_cr(\"Decoding VtableStub (%s) %s[%d]@\" PTR_FORMAT \" [\" PTR_FORMAT \", \" PTR_FORMAT \"] (\" SIZE_FORMAT \" bytes)\",\n+        tty->print_cr(\"Decoding VtableStub (%s) %s[%d]@\" PTR_FORMAT \" [\" PTR_FORMAT \", \" PTR_FORMAT \"] (%zu bytes)\",\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1920,1 +1920,1 @@\n-    log->begin_elem(\"start_compile_thread name='%s' thread='\" UINTX_FORMAT \"' process='%d'\",\n+    log->begin_elem(\"start_compile_thread name='%s' thread='%zu' process='%d'\",\n@@ -2011,1 +2011,1 @@\n-        jio_snprintf(file_name, sizeof(file_name), \"hs_c\" UINTX_FORMAT \"_pid%u.log\",\n+        jio_snprintf(file_name, sizeof(file_name), \"hs_c%zu_pid%u.log\",\n@@ -2015,1 +2015,1 @@\n-                     \"%s%shs_c\" UINTX_FORMAT \"_pid%u.log\", dir,\n+                     \"%s%shs_c%zu_pid%u.log\", dir,\n@@ -2034,1 +2034,1 @@\n-          xtty->elem(\"thread_logfile thread='\" INTX_FORMAT \"' filename='%s'\", thread_id, file_name);\n+          xtty->elem(\"thread_logfile thread='%zd' filename='%s'\", thread_id, file_name);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -933,1 +933,1 @@\n-      \" Base: \" INTPTR_FORMAT \" (@\" INTPTR_FORMAT \") (Offset: \" INTX_FORMAT \")\",\n+      \" Base: \" INTPTR_FORMAT \" (@\" INTPTR_FORMAT \") (Offset: %zd)\",\n@@ -963,1 +963,1 @@\n-                    \" - Derived: \" INTPTR_FORMAT \"  Base: \" INTPTR_FORMAT \" (Offset: \" INTX_FORMAT \")\",\n+                    \" - Derived: \" INTPTR_FORMAT \"  Base: \" INTPTR_FORMAT \" (Offset: %zd)\",\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -588,2 +588,2 @@\n-      err_msg(\"Unable to allocate \" SIZE_FORMAT \"KB bitmaps for parallel \"\n-      \"garbage collection for the requested \" SIZE_FORMAT \"KB heap.\",\n+      err_msg(\"Unable to allocate %zuKB bitmaps for parallel \"\n+      \"garbage collection for the requested %zuKB heap.\",\n@@ -596,2 +596,2 @@\n-      err_msg(\"Unable to allocate \" SIZE_FORMAT \"KB card tables for parallel \"\n-      \"garbage collection for the requested \" SIZE_FORMAT \"KB heap.\",\n+      err_msg(\"Unable to allocate %zuKB card tables for parallel \"\n+      \"garbage collection for the requested %zuKB heap.\",\n@@ -1079,1 +1079,1 @@\n-      log_trace(gc, ergo)(\"old_gen_capacity: \" SIZE_FORMAT \" young_gen_capacity: \" SIZE_FORMAT,\n+      log_trace(gc, ergo)(\"old_gen_capacity: %zu young_gen_capacity: %zu\",\n@@ -1692,1 +1692,1 @@\n-    log.trace(SIZE_FORMAT \" initially fillable regions\", _total_regions);\n+    log.trace(\"%zu initially fillable regions\", _total_regions);\n@@ -1701,1 +1701,1 @@\n-      line.append(\" \" SIZE_FORMAT_W(7), _regions[i]);\n+      line.append(\" %7zu\", _regions[i]);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,2 +297,2 @@\n-           \"Allocation failed, but actual size was updated. min: \" SIZE_FORMAT\n-           \", desired: \" SIZE_FORMAT \", actual: \" SIZE_FORMAT,\n+           \"Allocation failed, but actual size was updated. min: %zu\"\n+           \", desired: %zu, actual: %zu\",\n@@ -303,1 +303,1 @@\n-         PTR_FORMAT \" min: \" SIZE_FORMAT \", desired: \" SIZE_FORMAT,\n+         PTR_FORMAT \" min: %zu, desired: %zu\",\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,2 +70,1 @@\n-    assert(_heap->is_evacuation_in_progress(),\n-           \"evac should be in progress\");\n+    assert(_heap->is_evacuation_in_progress(), \"evac should be in progress\");\n@@ -89,2 +88,2 @@\n-  if (_heap->has_forwarded_objects() &&\n-      _heap->in_collection_set(obj)) { \/\/ Subsumes null-check\n+  if (_heap->has_forwarded_objects() && _heap->in_collection_set(obj)) {\n+    \/\/ Subsumes null-check\n@@ -385,1 +384,1 @@\n-  assert(HAS_FWD == _heap->has_forwarded_objects() || (_heap->gc_state() & ShenandoahHeap::OLD_MARKING) != 0,\n+  assert(HAS_FWD == _heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(),\n@@ -422,1 +421,1 @@\n-  int gc_state = _heap->gc_state();\n+  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"jvm_md.h\"\n@@ -35,0 +34,1 @@\n+#include \"jvm_md.h\"\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -723,1 +723,1 @@\n-      log_info(gc, classhisto)(\"WARNING: Ran out of C-heap; undercounted \" UINTX_FORMAT\n+      log_info(gc, classhisto)(\"WARNING: Ran out of C-heap; undercounted %zu\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -376,1 +376,1 @@\n-      err_msg(\"Size of %s (\" UINTX_FORMAT \" bytes) must be aligned to \" UINTX_FORMAT \" bytes\", name, size, alignment));\n+      err_msg(\"Size of %s (%zu bytes) must be aligned to %zu bytes\", name, size, alignment));\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -336,2 +336,1 @@\n-  if (!(ik->is_shared_boot_class() || ik->is_shared_platform_class() ||\n-        ik->is_shared_app_class())) {\n+  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n@@ -349,2 +348,1 @@\n-    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n-    src_cp->iterate_archivable_resolved_references([&](int rr_index) {\n+    iterate_archivable_resolved_references([&](int rr_index) {\n@@ -354,1 +352,1 @@\n-    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(src_cp);\n+    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(this);\n@@ -382,26 +380,0 @@\n-void ConstantPool::find_required_hidden_classes() {\n-  if (_cache == nullptr) {\n-    return;\n-  }\n-\n-  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-  if (loader_data == nullptr) {\n-    \/\/ These are custom loader classes from the preimage\n-    return;\n-  }\n-\n-  if (!SystemDictionaryShared::is_builtin_loader(loader_data)) {\n-    \/\/ Archiving resolved references for classes from non-builtin loaders\n-    \/\/ is not yet supported.\n-    return;\n-  }\n-\n-  objArrayOop rr = resolved_references();\n-  if (rr != nullptr) {\n-    iterate_archivable_resolved_references([&](int rr_index) {\n-      oop obj = rr->obj_at(rr_index);\n-      HeapShared::find_required_hidden_classes_in_object(obj);\n-    });\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":4,"deletions":32,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -687,1 +687,0 @@\n-  void find_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -413,0 +413,11 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  _archived_references_index = -1;\n+  if (CDSConfig::is_dumping_heap()) {\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n+    oop rr = HeapShared::scratch_resolved_references(src_cp);\n+    if (rr != nullptr) {\n+      _archived_references_index = HeapShared::append_root(rr);\n+    }\n+  }\n+#endif\n@@ -614,5 +625,0 @@\n-\n-void ConstantPoolCache::set_archived_references(int root_index) {\n-  assert(CDSConfig::is_dumping_heap(), \"sanity\");\n-  _archived_references_index = root_index;\n-}\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3950,1 +3950,1 @@\n-  if (n >= MaxSubklassPrintSize) st->print(\"(\" INTX_FORMAT \" more klasses...)\", n - MaxSubklassPrintSize);\n+  if (n >= MaxSubklassPrintSize) st->print(\"(%zd more klasses...)\", n - MaxSubklassPrintSize);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -820,0 +820,13 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  _archived_mirror_index = -1;\n+  if (CDSConfig::is_dumping_heap()) {\n+    Klass* src_k = ArchiveBuilder::current()->get_source_addr(this);\n+    oop orig_mirror = src_k->java_mirror();\n+    oop scratch_mirror = HeapShared::scratch_java_mirror(orig_mirror);\n+    if (scratch_mirror != nullptr) {\n+      _archived_mirror_index = HeapShared::append_root(scratch_mirror);\n+    }\n+  }\n+#endif\n+\n@@ -903,6 +916,0 @@\n-\n-\/\/ No GC barrier\n-void Klass::set_archived_java_mirror(int mirror_index) {\n-  assert(CDSConfig::is_dumping_heap(), \"sanity\");\n-  _archived_mirror_index = mirror_index;\n-}\n@@ -1306,1 +1313,1 @@\n-    st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _secondary_supers_bitmap);\n+    st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0, _secondary_supers_bitmap);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -288,1 +288,0 @@\n-  void set_archived_java_mirror(int mirror_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1060,1 +1060,1 @@\n-    xtty->begin_elem(\"make_not_compilable thread='\" UINTX_FORMAT \"' osr='%d' level='%d'\",\n+    xtty->begin_elem(\"make_not_compilable thread='%zu' osr='%d' level='%d'\",\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,6 +398,0 @@\n-  \/\/ Convert a + a + ... + a into a*n\n-  Node* serial_additions = convert_serial_additions(phase, bt);\n-  if (serial_additions != nullptr) {\n-    return serial_additions;\n-  }\n-\n@@ -407,144 +401,0 @@\n-\/\/ Try to convert a serial of additions into a single multiplication. Also convert `(a * CON) + a` to `(CON + 1) * a` as\n-\/\/ a side effect. On success, a new MulNode is returned.\n-Node* AddNode::convert_serial_additions(PhaseGVN* phase, BasicType bt) {\n-  \/\/ We need to make sure that the current AddNode is not part of a MulNode that has already been optimized to a\n-  \/\/ power-of-2 addition (e.g., 3 * a => (a << 2) + a). Without this check, GVN would keep trying to optimize the same\n-  \/\/ node and can't progress. For example, 3 * a => (a << 2) + a => 3 * a => (a << 2) + a => ...\n-  if (find_power_of_two_addition_pattern(this, bt, nullptr) != nullptr) {\n-    return nullptr;\n-  }\n-\n-  Node* in1 = in(1);\n-  Node* in2 = in(2);\n-  jlong multiplier;\n-\n-  \/\/ While multiplications can be potentially optimized to power-of-2 subtractions (e.g., a * 7 => (a << 3) - a),\n-  \/\/ (x - y) + y => x is already handled by the Identity() methods. So, we don't need to check for that pattern here.\n-  if (find_simple_addition_pattern(in1, bt, &multiplier) == in2\n-      || find_simple_lshift_pattern(in1, bt, &multiplier) == in2\n-      || find_simple_multiplication_pattern(in1, bt, &multiplier) == in2\n-      || find_power_of_two_addition_pattern(in1, bt, &multiplier) == in2) {\n-    multiplier++; \/\/ +1 for the in2 term\n-\n-    Node* con = (bt == T_INT)\n-                ? (Node*) phase->intcon((jint) multiplier) \/\/ intentional type narrowing to allow overflow at max_jint\n-                : (Node*) phase->longcon(multiplier);\n-    return MulNode::make(con, in2, bt);\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/ Try to match `a + a`. On success, return `a` and set `2` as `multiplier`.\n-\/\/ The method matches `n` for pattern: AddNode(a, a).\n-Node* AddNode::find_simple_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n-  if (n->Opcode() == Op_Add(bt) && n->in(1) == n->in(2)) {\n-    *multiplier = 2;\n-    return n->in(1);\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/ Try to match `a << CON`. On success, return `a` and set `1 << CON` as `multiplier`.\n-\/\/ Match `n` for pattern: LShiftNode(a, CON).\n-\/\/ Note that the power-of-2 multiplication optimization could potentially convert a MulNode to this pattern.\n-Node* AddNode::find_simple_lshift_pattern(Node* n, BasicType bt, jlong* multiplier) {\n-  \/\/ Note that power-of-2 multiplication optimization could potentially convert a MulNode to this pattern\n-  if (n->Opcode() == Op_LShift(bt) && n->in(2)->is_Con()) {\n-    Node* con = n->in(2);\n-    if (con->is_top()) {\n-      return nullptr;\n-    }\n-\n-    *multiplier = ((jlong) 1 << con->get_int());\n-    return n->in(1);\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/ Try to match `CON * a`. On success, return `a` and set `CON` as `multiplier`.\n-\/\/ Match `n` for patterns:\n-\/\/     - MulNode(CON, a)\n-\/\/     - MulNode(a, CON)\n-Node* AddNode::find_simple_multiplication_pattern(Node* n, BasicType bt, jlong* multiplier) {\n-  \/\/ This optimization technically only produces MulNode(CON, a), but we might as match MulNode(a, CON), too.\n-  if (n->Opcode() == Op_Mul(bt) && (n->in(1)->is_Con() || n->in(2)->is_Con())) {\n-    Node* con = n->in(1);\n-    Node* base = n->in(2);\n-\n-    \/\/ swap ConNode to lhs for easier matching\n-    if (!con->is_Con()) {\n-      swap(con, base);\n-    }\n-\n-    if (con->is_top()) {\n-      return nullptr;\n-    }\n-\n-    *multiplier = con->get_integer_as_long(bt);\n-    return base;\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/ Try to match `(a << CON1) + (a << CON2)`. On success, return `a` and set `(1 << CON1) + (1 << CON2)` as `multiplier`.\n-\/\/ Match `n` for patterns:\n-\/\/     - AddNode(LShiftNode(a, CON), LShiftNode(a, CON)\/a)\n-\/\/     - AddNode(LShiftNode(a, CON)\/a, LShiftNode(a, CON))\n-\/\/ given that lhs is different from rhs.\n-\/\/ Note that one of the term of the addition could simply be `a` (i.e., a << 0). Calling this function with `multiplier`\n-\/\/ being null is safe.\n-Node* AddNode::find_power_of_two_addition_pattern(Node* n, BasicType bt, jlong* multiplier) {\n-  if (n->Opcode() == Op_Add(bt) && n->in(1) != n->in(2)) {\n-    Node* lhs = n->in(1);\n-    Node* rhs = n->in(2);\n-\n-    \/\/ swap LShiftNode to lhs for easier matching\n-    if (lhs->Opcode() != Op_LShift(bt)) {\n-      swap(lhs, rhs);\n-    }\n-\n-    \/\/ AddNode(LShiftNode(a, CON), *)?\n-    if (lhs->Opcode() != Op_LShift(bt) || !lhs->in(2)->is_Con()) {\n-      return nullptr;\n-    }\n-\n-    jlong lhs_multiplier = 0;\n-    if (multiplier != nullptr) {\n-      Node* con = lhs->in(2);\n-      if (con->is_top()) {\n-        return nullptr;\n-      }\n-\n-      lhs_multiplier = (jlong) 1 << con->get_int();\n-    }\n-\n-    \/\/ AddNode(LShiftNode(a, CON), a)?\n-    if (lhs->in(1) == rhs) {\n-      if (multiplier != nullptr) {\n-        *multiplier = lhs_multiplier + 1;\n-      }\n-\n-      return rhs;\n-    }\n-\n-    \/\/ AddNode(LShiftNode(a, CON), LShiftNode(a, CON2))?\n-    if (rhs->Opcode() == Op_LShift(bt) && lhs->in(1) == rhs->in(1) && rhs->in(2)->is_Con()) {\n-      if (multiplier != nullptr) {\n-        Node* con = rhs->in(2);\n-        if (con->is_top()) {\n-          return nullptr;\n-        }\n-\n-        *multiplier = lhs_multiplier + ((jlong) 1 << con->get_int());\n-      }\n-\n-      return lhs->in(1);\n-    }\n-    return nullptr;\n-  }\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":0,"deletions":150,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -1268,2 +1268,5 @@\n-  \/\/ Better Frequency\n-  if (LCA->_freq < least_freq) {\n+  const double delta = 1 + PROB_UNLIKELY_MAG(4);\n+\n+  \/\/ Better Frequency. Add a small delta to the comparison to not needlessly\n+  \/\/ hoist because of, e.g., small numerical inaccuracies.\n+  if (LCA->_freq * delta < least_freq) {\n@@ -1274,1 +1277,0 @@\n-  const double delta = 1 + PROB_UNLIKELY_MAG(4);\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4471,1 +4471,1 @@\n-Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind) {\n+Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind, Node** obj) {\n@@ -4525,1 +4525,8 @@\n-  return generate_fair_guard(bol, region);\n+  Node* ctrl = generate_fair_guard(bol, region);\n+  Node* is_array_ctrl = kind == NonArray ? control() : ctrl;\n+  if (obj != nullptr && is_array_ctrl != nullptr && is_array_ctrl != top()) {\n+    \/\/ Keep track of the fact that 'obj' is an array to prevent\n+    \/\/ array specific accesses from floating above the guard.\n+    *obj = _gvn.transform(new CastPPNode(is_array_ctrl, *obj, TypeAryPtr::BOTTOM));\n+  }\n+  return ctrl;\n@@ -4647,1 +4654,1 @@\n-  Node* non_array = generate_non_array_guard(load_object_klass(array), nullptr);\n+  Node* non_array = generate_non_array_guard(load_object_klass(array), nullptr, &array);\n@@ -5600,1 +5607,2 @@\n-    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)nullptr);\n+    Node* array_obj = obj;\n+    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)nullptr, &array_obj);\n@@ -5617,1 +5625,1 @@\n-        Node* obj_length = load_array_length(obj);\n+        Node* obj_length = load_array_length(array_obj);\n@@ -5631,1 +5639,1 @@\n-            ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n+            ArrayCopyNode* ac = ArrayCopyNode::make(this, true, array_obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n@@ -6284,2 +6292,2 @@\n-    generate_non_array_guard(load_object_klass(src), slow_region);\n-    generate_non_array_guard(load_object_klass(dest), slow_region);\n+    generate_non_array_guard(load_object_klass(src), slow_region, &src);\n+    generate_non_array_guard(load_object_klass(dest), slow_region, &dest);\n@@ -8922,1 +8930,1 @@\n-    Node* array_ctl = generate_array_guard(klass_node, nullptr);\n+    Node* array_ctl = generate_array_guard(klass_node, nullptr, &obj);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,2 +184,2 @@\n-  Node* generate_array_guard(Node* kls, RegionNode* region) {\n-    return generate_array_guard_common(kls, region, AnyArray);\n+  Node* generate_array_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n+    return generate_array_guard_common(kls, region, AnyArray, obj);\n@@ -187,2 +187,2 @@\n-  Node* generate_non_array_guard(Node* kls, RegionNode* region) {\n-    return generate_array_guard_common(kls, region, NonArray);\n+  Node* generate_non_array_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n+    return generate_array_guard_common(kls, region, NonArray, obj);\n@@ -190,2 +190,2 @@\n-  Node* generate_objArray_guard(Node* kls, RegionNode* region) {\n-    return generate_array_guard_common(kls, region, ObjectArray);\n+  Node* generate_objArray_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n+    return generate_array_guard_common(kls, region, ObjectArray, obj);\n@@ -193,2 +193,2 @@\n-  Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {\n-    return generate_array_guard_common(kls, region, NonObjectArray);\n+  Node* generate_non_objArray_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n+    return generate_array_guard_common(kls, region, NonObjectArray, obj);\n@@ -196,2 +196,2 @@\n-  Node* generate_typeArray_guard(Node* kls, RegionNode* region) {\n-    return generate_array_guard_common(kls, region, TypeArray);\n+  Node* generate_typeArray_guard(Node* kls, RegionNode* region, Node** obj = nullptr) {\n+    return generate_array_guard_common(kls, region, TypeArray, obj);\n@@ -199,1 +199,1 @@\n-  Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);\n+  Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind, Node** obj = nullptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -428,0 +428,13 @@\n+  \/\/ Unswitch the original loop on the invariant loop selector by creating a true-path-loop and a false-path-loop.\n+  \/\/ Remove the unswitch candidate If from both unswitched loop versions which are now covered by the loop selector If.\n+  void unswitch(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    const uint first_false_path_loop_node_index = _phase->C->unique();\n+    clone_loop(unswitched_loop_selector);\n+\n+    move_parse_and_template_assertion_predicates_to_unswitched_loops(unswitched_loop_selector,\n+                                                                     first_false_path_loop_node_index);\n+    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n+\n+    _phase->recompute_dom_depth();\n+  }\n+\n@@ -429,2 +442,8 @@\n-  void fix_loop_entries(IfProjNode* true_path_loop_entry, IfProjNode* false_path_loop_entry) {\n-    _phase->replace_loop_entry(_loop_head, true_path_loop_entry);\n+  void clone_loop(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_loop_head),\n+                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n+    fix_loop_entries(unswitched_loop_selector);\n+  }\n+\n+  void fix_loop_entries(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+    _phase->replace_loop_entry(_loop_head, unswitched_loop_selector.true_path_loop_proj());\n@@ -432,1 +451,2 @@\n-    _phase->replace_loop_entry(false_path_loop_strip_mined_head, false_path_loop_entry);\n+    _phase->replace_loop_entry(false_path_loop_strip_mined_head,\n+                               unswitched_loop_selector.false_path_loop_proj());\n@@ -435,2 +455,13 @@\n-  Node* old_to_new(const Node* old) const {\n-    return _old_new[old->_idx];\n+  \/\/ Moves the Parse And Template Assertion Predicates to the true and false path loop. They are inserted between the\n+  \/\/ loop heads and the loop selector If projections. The old Parse and Template Assertion Predicates before\n+  \/\/ the unswitched loop selector are killed.\n+  void move_parse_and_template_assertion_predicates_to_unswitched_loops(\n+    const UnswitchedLoopSelector& unswitched_loop_selector, const uint first_false_path_loop_node_index) const {\n+    const NodeInOriginalLoopBody node_in_true_path_loop_body(first_false_path_loop_node_index, _old_new);\n+    const NodeInClonedLoopBody node_in_false_path_loop_body(first_false_path_loop_node_index);\n+    CloneUnswitchedLoopPredicatesVisitor\n+    clone_unswitched_loop_predicates_visitor(_loop_head, old_to_new(_loop_head)->as_Loop(), node_in_true_path_loop_body,\n+                                             node_in_false_path_loop_body, _phase);\n+    Node* source_loop_entry = unswitched_loop_selector.selector()->in(0);\n+    PredicateIterator predicate_iterator(source_loop_entry);\n+    predicate_iterator.for_each(clone_unswitched_loop_predicates_visitor);\n@@ -455,18 +486,2 @@\n- public:\n-  \/\/ Unswitch the original loop on the invariant loop selector by creating a true-path-loop and a false-path-loop.\n-  \/\/ Remove the unswitch candidate If from both unswitched loop versions which are now covered by the loop selector If.\n-  void unswitch(const UnswitchedLoopSelector& unswitched_loop_selector) {\n-    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_loop_head),\n-                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n-\n-    \/\/ At this point, the selector If projections are the corresponding loop entries.\n-    \/\/ clone_parse_and_assertion_predicates_to_unswitched_loop() could clone additional predicates after the selector\n-    \/\/ If projections. The loop entries are updated accordingly.\n-    IfProjNode* true_path_loop_entry = unswitched_loop_selector.true_path_loop_proj();\n-    IfProjNode* false_path_loop_entry = unswitched_loop_selector.false_path_loop_proj();\n-    _phase->clone_parse_and_assertion_predicates_to_unswitched_loop(_loop, _old_new,\n-                                                                    true_path_loop_entry, false_path_loop_entry);\n-\n-    fix_loop_entries(true_path_loop_entry, false_path_loop_entry);\n-    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n-    _phase->recompute_dom_depth();\n+  Node* old_to_new(const Node* old) const {\n+    return _old_new[old->_idx];\n@@ -474,0 +489,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":39,"deletions":23,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -950,1 +950,2 @@\n-  static void get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n+  static void get_opaque_template_assertion_predicate_nodes(ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                            Unique_Node_List& list);\n@@ -1358,3 +1359,2 @@\n-      ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n-      bool rewire_uncommon_proj_phi_inputs = false,\n-      AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None);\n+    ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason, int opcode,\n+    bool rewire_uncommon_proj_phi_inputs = false);\n@@ -1673,21 +1673,0 @@\n- public:\n-  \/\/ Clone Parse Predicates to slow and fast loop when unswitching a loop\n-  void clone_parse_and_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new,\n-                                                               IfProjNode*& true_path_loop_entry,\n-                                                               IfProjNode*& false_path_loop_entry);\n-  void clone_loop_predication_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n-                                                            const PredicateBlock* predicate_block,\n-                                                            Deoptimization::DeoptReason reason,\n-                                                            IfProjNode*& true_path_loop_entry,\n-                                                            IfProjNode*& false_path_loop_entry);\n-  void clone_parse_predicate_to_unswitched_loops(const PredicateBlock* predicate_block, Deoptimization::DeoptReason reason,\n-                                                 IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred);\n-  IfProjNode* clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                                       Deoptimization::DeoptReason reason, bool slow_loop);\n-  void clone_assertion_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n-                                                     ParsePredicateSuccessProj* old_parse_predicate_proj,\n-                                                     ParsePredicateNode* true_path_loop_parse_predicate,\n-                                                     ParsePredicateNode* false_path_loop_parse_predicate);\n-  IfTrueNode* clone_assertion_predicate_for_unswitched_loops(IfTrueNode* template_assertion_predicate_success_proj,\n-                                                             ParsePredicateNode* unswitched_loop_parse_predicate);\n-  static void check_cloned_parse_predicate_for_unswitching(const Node* new_entry, bool is_fast_loop) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2045,0 +2045,11 @@\n+  \/\/ If we are loading from a freshly-allocated object, produce a zero,\n+  \/\/ if the load is provably beyond the header of the object.\n+  \/\/ (Also allow a variable load from a fresh array to produce zero.)\n+  const TypeOopPtr* tinst = tp->isa_oopptr();\n+  bool is_instance = (tinst != nullptr) && tinst->is_known_instance_field();\n+  Node* value = can_see_stored_value(mem, phase);\n+  if (value != nullptr && value->is_Con()) {\n+    assert(value->bottom_type()->higher_equal(_type), \"sanity\");\n+    return value->bottom_type();\n+  }\n+\n@@ -2256,14 +2267,0 @@\n-  \/\/ If we are loading from a freshly-allocated object, produce a zero,\n-  \/\/ if the load is provably beyond the header of the object.\n-  \/\/ (Also allow a variable load from a fresh array to produce zero.)\n-  const TypeOopPtr *tinst = tp->isa_oopptr();\n-  bool is_instance = (tinst != nullptr) && tinst->is_known_instance_field();\n-  bool is_boxed_value = (tinst != nullptr) && tinst->is_ptr_to_boxed_value();\n-  if (ReduceFieldZeroing || is_instance || is_boxed_value) {\n-    Node* value = can_see_stored_value(mem,phase);\n-    if (value != nullptr && value->is_Con()) {\n-      assert(value->bottom_type()->higher_equal(_type),\"sanity\");\n-      return value->bottom_type();\n-    }\n-  }\n-\n@@ -5282,1 +5279,1 @@\n-      tty->print_cr(\"*** bad store offset at %d: \" INTX_FORMAT \" > \" INTX_FORMAT, i, last_off, st_off);\n+      tty->print_cr(\"*** bad store offset at %d: %zd > %zd\", i, last_off, st_off);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -674,1 +674,1 @@\n-  if (log)  log->done(\"parse nodes='%d' live='%d' memory='\" SIZE_FORMAT \"'\",\n+  if (log)  log->done(\"parse nodes='%d' live='%d' memory='%zu'\",\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -636,0 +636,1 @@\n+  TypeAryPtr::BOTTOM = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM, TypeInt::POS), nullptr, false, Offset::bottom);\n@@ -4885,0 +4886,1 @@\n+const TypeAryPtr* TypeAryPtr::BOTTOM;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1571,0 +1571,1 @@\n+  static const TypeAryPtr* BOTTOM;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3893,0 +3893,1 @@\n+    thread->unregister_thread_stack_with_NMT();\n@@ -3937,0 +3938,2 @@\n+    thread->unregister_thread_stack_with_NMT();\n+    thread->smr_delete();\n@@ -4033,0 +4036,1 @@\n+  thread->unregister_thread_stack_with_NMT();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1807,1 +1807,1 @@\n-  SetFramePopClosure op(this, state, depth);\n+  SetOrClearFramePopClosure op(this, state, true \/* set *\/, depth);\n@@ -1813,0 +1813,27 @@\n+\/\/ Threads_lock NOT held, java_thread not protected by lock\n+jvmtiError\n+JvmtiEnv::ClearAllFramePops(jthread thread) {\n+  ResourceMark rm;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n+\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  HandleMark hm(current);\n+  Handle thread_handle(current, thread_obj);\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_handle);\n+  if (state == nullptr) {\n+    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n+  }\n+\n+  SetOrClearFramePopClosure op(this, state, false \/* clear all frame pops*\/);\n+  MutexLocker mu(current, JvmtiThreadState_lock);\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+  return op.result();\n+} \/* end ClearAllFramePops *\/\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1735,1 +1735,1 @@\n-    jio_snprintf(buffer, 1024, \"java.lang.Integer.IntegerCache.high=\" INTX_FORMAT, AutoBoxCacheMax);\n+    jio_snprintf(buffer, 1024, \"java.lang.Integer.IntegerCache.high=%zd\", AutoBoxCacheMax);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-    st.print(INTX_FORMAT \" \", frame_sizes()[index]);\n+    st.print(\"%zd \", frame_sizes()[index]);\n@@ -1877,1 +1877,1 @@\n-    xtty->begin_head(\"deoptimized thread='\" UINTX_FORMAT \"' reason='%s' pc='\" INTPTR_FORMAT \"'\",(uintx)thread->osthread()->thread_id(), trap_reason_name(reason), p2i(fr.pc()));\n+    xtty->begin_head(\"deoptimized thread='%zu' reason='%s' pc='\" INTPTR_FORMAT \"'\",(uintx)thread->osthread()->thread_id(), trap_reason_name(reason), p2i(fr.pc()));\n@@ -2246,1 +2246,1 @@\n-        xtty->begin_head(\"uncommon_trap thread='\" UINTX_FORMAT \"' %s\",\n+        xtty->begin_head(\"uncommon_trap thread='%zu' %s\",\n@@ -2310,1 +2310,1 @@\n-        st.print(\" (@\" INTPTR_FORMAT \") thread=\" UINTX_FORMAT \" reason=%s action=%s unloaded_class_index=%d\" JVMCI_ONLY(\" debug_id=%d\"),\n+        st.print(\" (@\" INTPTR_FORMAT \") thread=%zu reason=%s action=%s unloaded_class_index=%d\" JVMCI_ONLY(\" debug_id=%d\"),\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1134,1 +1134,1 @@\n-  assert(Universe::heap()->is_in_or_null(r), \"bad receiver: \" INTPTR_FORMAT \" (\" INTX_FORMAT \")\", p2i(r), p2i(r));\n+  assert(Universe::heap()->is_in_or_null(r), \"bad receiver: \" INTPTR_FORMAT \" (%zd)\", p2i(r), p2i(r));\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -936,1 +936,1 @@\n-           \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n+           \"held monitor count should be equal to jni: %zd != %zd\",\n@@ -939,1 +939,1 @@\n-    assert(held_monitor_count() == 0, \"Failed to unlock \" INTX_FORMAT \" object monitors\",\n+    assert(held_monitor_count() == 0, \"Failed to unlock %zd object monitors\",\n@@ -944,1 +944,1 @@\n-           \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n+           \"held monitor count should be equal to jni: %zd != %zd\",\n@@ -953,1 +953,1 @@\n-    log_debug(jni)(\"JavaThread %s (tid: \" UINTX_FORMAT \") with Objects still locked by JNI MonitorEnter.\",\n+    log_debug(jni)(\"JavaThread %s (tid: %zu) with Objects still locked by JNI MonitorEnter.\",\n@@ -994,1 +994,1 @@\n-    log_info(os, thread)(\"JavaThread %s (name: \\\"%s\\\", tid: \" UINTX_FORMAT \").\",\n+    log_info(os, thread)(\"JavaThread %s (name: \\\"%s\\\", tid: %zu).\",\n@@ -1055,1 +1055,0 @@\n-  this->smr_delete();\n@@ -2016,1 +2015,1 @@\n-  assert(_held_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _held_monitor_count);\n+  assert(_held_monitor_count >= 0, \"Must always be non-negative: %zd\", _held_monitor_count);\n@@ -2019,1 +2018,1 @@\n-    assert(_jni_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _jni_monitor_count);\n+    assert(_jni_monitor_count >= 0, \"Must always be non-negative: %zd\", _jni_monitor_count);\n@@ -2023,1 +2022,1 @@\n-         INTX_FORMAT \" is less than JNI count \" INTX_FORMAT, _held_monitor_count, _jni_monitor_count);\n+         \"%zd is less than JNI count %zd\", _held_monitor_count, _jni_monitor_count);\n@@ -2040,1 +2039,1 @@\n-  assert(_held_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _held_monitor_count);\n+  assert(_held_monitor_count >= 0, \"Must always be non-negative: %zd\", _held_monitor_count);\n@@ -2043,1 +2042,1 @@\n-    assert(_jni_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _jni_monitor_count);\n+    assert(_jni_monitor_count >= 0, \"Must always be non-negative: %zd\", _jni_monitor_count);\n@@ -2050,1 +2049,1 @@\n-         INTX_FORMAT \" is less than JNI count \" INTX_FORMAT, _held_monitor_count, _jni_monitor_count);\n+         \"%zd is less than JNI count %zd\", _held_monitor_count, _jni_monitor_count);\n@@ -2269,1 +2268,1 @@\n-      log_trace(os, thread)(\"Pretouching thread stack for \" UINTX_FORMAT \": \" RANGEFMT \".\",\n+      log_trace(os, thread)(\"Pretouching thread stack for %zu: \" RANGEFMT \".\",\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -725,0 +725,5 @@\n+  \/\/ Temporarily skip posting JVMTI events for safety reasons when executions is in a critical section:\n+  \/\/ - is in a VTMS transition (_is_in_VTMS_transition)\n+  \/\/ - is in an interruptLock or similar critical section (_is_disable_suspend)\n+  bool should_hide_jvmti_events() const          { return _is_in_VTMS_transition || _is_disable_suspend; }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1403,1 +1403,1 @@\n-    log_info(monitorinflation)(\"Async deflation needed: guaranteed interval (\" INTX_FORMAT \" ms) \"\n+    log_info(monitorinflation)(\"Async deflation needed: guaranteed interval (%zd ms) \"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1171,2 +1171,2 @@\n-         \"%s \" PTR_FORMAT \" has incorrect value \" UINTX_FORMAT \" != \"\n-         UINTX_FORMAT, kind, p2i(t), token, expected);\n+         \"%s \" PTR_FORMAT \" has incorrect value %zu != %zu\",\n+         kind, p2i(t), token, expected);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -138,3 +138,0 @@\n-#define SSIZE_FORMAT             \"%\"          PRIdPTR\n-#define SSIZE_PLUS_FORMAT        \"%+\"         PRIdPTR\n-#define SSIZE_FORMAT_W(width)    \"%\"   #width PRIdPTR\n@@ -150,12 +147,0 @@\n-#define INTX_FORMAT              \"%\"          PRIdPTR\n-#define INTX_FORMAT_X            \"0x%\"        PRIxPTR\n-#define INTX_FORMAT_W(width)     \"%\"   #width PRIdPTR\n-#define UINTX_FORMAT             \"%\"          PRIuPTR\n-#define UINTX_FORMAT_X           \"0x%\"        PRIxPTR\n-#ifdef _LP64\n-#define UINTX_FORMAT_X_0         \"0x%016\"     PRIxPTR\n-#else\n-#define UINTX_FORMAT_X_0         \"0x%08\"      PRIxPTR\n-#endif\n-#define UINTX_FORMAT_W(width)    \"%\"   #width PRIuPTR\n-\n@@ -176,1 +161,1 @@\n-\/\/ Format pointers which change size between 32- and 64-bit.\n+\/\/ Format pointers and padded integral values which change size between 32- and 64-bit.\n@@ -180,0 +165,1 @@\n+#define UINTX_FORMAT_X_0         \"0x%016\"     PRIxPTR\n@@ -183,0 +169,1 @@\n+#define UINTX_FORMAT_X_0         \"0x%08\"      PRIxPTR\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1249,11 +1249,4 @@\n-        if (rd == null) {\n-            \/\/ no cloning required\n-            return getInterfaces0();\n-        } else {\n-            Class<?>[] interfaces = rd.interfaces;\n-            if (interfaces == null) {\n-                interfaces = getInterfaces0();\n-                rd.interfaces = interfaces;\n-            }\n-            \/\/ defensively copy if requested\n-            return cloneArray ? interfaces.clone() : interfaces;\n+        Class<?>[] interfaces = rd.interfaces;\n+        if (interfaces == null) {\n+            interfaces = getInterfaces0();\n+            rd.interfaces = interfaces;\n@@ -1261,0 +1254,2 @@\n+        \/\/ defensively copy if requested\n+        return cloneArray ? interfaces.clone() : interfaces;\n@@ -2977,4 +2972,2 @@\n-        if (rd != null) {\n-            res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;\n-            if (res != null) return res;\n-        }\n+        res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;\n+        if (res != null) return res;\n@@ -2983,6 +2976,4 @@\n-        if (rd != null) {\n-            if (publicOnly) {\n-                rd.declaredPublicFields = res;\n-            } else {\n-                rd.declaredFields = res;\n-            }\n+        if (publicOnly) {\n+            rd.declaredPublicFields = res;\n+        } else {\n+            rd.declaredFields = res;\n@@ -2999,4 +2990,2 @@\n-        if (rd != null) {\n-            res = rd.publicFields;\n-            if (res != null) return res;\n-        }\n+        res = rd.publicFields;\n+        if (res != null) return res;\n@@ -3023,3 +3012,1 @@\n-        if (rd != null) {\n-            rd.publicFields = res;\n-        }\n+        rd.publicFields = res;\n@@ -3048,4 +3035,2 @@\n-        if (rd != null) {\n-            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;\n-            if (res != null) return res;\n-        }\n+        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;\n+        if (res != null) return res;\n@@ -3060,6 +3045,4 @@\n-        if (rd != null) {\n-            if (publicOnly) {\n-                rd.publicConstructors = res;\n-            } else {\n-                rd.declaredConstructors = res;\n-            }\n+        if (publicOnly) {\n+            rd.publicConstructors = res;\n+        } else {\n+            rd.declaredConstructors = res;\n@@ -3082,4 +3065,2 @@\n-        if (rd != null) {\n-            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;\n-            if (res != null) return res;\n-        }\n+        res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;\n+        if (res != null) return res;\n@@ -3088,6 +3069,4 @@\n-        if (rd != null) {\n-            if (publicOnly) {\n-                rd.declaredPublicMethods = res;\n-            } else {\n-                rd.declaredMethods = res;\n-            }\n+        if (publicOnly) {\n+            rd.declaredPublicMethods = res;\n+        } else {\n+            rd.declaredMethods = res;\n@@ -3104,4 +3083,2 @@\n-        if (rd != null) {\n-            res = rd.publicMethods;\n-            if (res != null) return res;\n-        }\n+        res = rd.publicMethods;\n+        if (res != null) return res;\n@@ -3133,3 +3110,1 @@\n-        if (rd != null) {\n-            rd.publicMethods = res;\n-        }\n+        rd.publicMethods = res;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":31,"deletions":56,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -361,2 +361,2 @@\n- * @see <a href=\"https:\/\/standards.ieee.org\/ieee\/754\/6210\/\">\n- *      <cite>IEEE Standard for Floating-Point Arithmetic<\/cite><\/a>\n+ * @spec https:\/\/standards.ieee.org\/ieee\/754\/6210\/\n+ *       IEEE Standard for Floating-Point Arithmetic\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,2 +79,2 @@\n- * @see <a href=\"https:\/\/standards.ieee.org\/ieee\/754\/6210\/\">\n- *      <cite>IEEE Standard for Floating-Point Arithmetic<\/cite><\/a>\n+ * @spec https:\/\/standards.ieee.org\/ieee\/754\/6210\/\n+ *       IEEE Standard for Floating-Point Arithmetic\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,8 +34,17 @@\n- * Models a classfile attribute (JVMS {@jvms 4.7}).  Many, though not all, subtypes of\n- * {@linkplain Attribute} will implement {@link ClassElement}, {@link\n- * MethodElement}, {@link FieldElement}, or {@link CodeElement}; attributes that\n- * are also elements will be delivered when traversing the elements of the\n- * corresponding model type. Additionally, all attributes are accessible\n- * directly from the corresponding model type through {@link\n- * AttributedElement#findAttribute(AttributeMapper)}.\n- * @param <A> the attribute type\n+ * Models an attribute (JVMS {@jvms 4.7}) in the {@code class} file format.\n+ * Attributes exist on certain {@code class} file structures modeled by {@link\n+ * AttributedElement}, which provides basic read access to the attributes.\n+ * <p>\n+ * This sealed interface hierarchy includes attributes predefined in the JVMS\n+ * and JDK-specific nonstandard attributes.  Their {@linkplain #attributeMapper()\n+ * mappers} are available in {@link Attributes}.  Two special subtypes of {@code\n+ * Attribute} are {@link CustomAttribute}, which all user-defined attributes\n+ * should extend from, and {@link UnknownAttribute}, representing attributes\n+ * read from {@code class} file but are not recognized by the {@link\n+ * ClassFile.AttributeMapperOption}.\n+ * <p>\n+ * Attributes are read through {@link AttributedElement} or element traversal of\n+ * a {@link CompoundElement}; they are written through {@link ClassFileBuilder}.\n+ * See {@linkplain java.lang.classfile.attribute##reading Reading Attributes}\n+ * and {@linkplain java.lang.classfile.attribute##writing Writing Attributes}\n+ * for more details.\n@@ -43,0 +52,7 @@\n+ * @param <A> the attribute type\n+ * @see java.lang.classfile.attribute\n+ * @see AttributeMapper\n+ * @see AttributedElement\n+ * @see CustomAttribute\n+ * @see UnknownAttribute\n+ * @jvms 4.7 Attributes\n@@ -65,1 +81,7 @@\n-     * {@return the name of the attribute}\n+     * {@return the name of the attribute}  The {@linkplain\n+     * Utf8Entry#stringValue() string value} of the name is equivalent to the\n+     * value of {@link AttributeMapper#name() attributeMapper().name()}.\n+     * <p>\n+     * If this attribute is read from a {@code class} file, this method returns\n+     * the {@link Utf8Entry} indicating the attribute name in the {@code class}\n+     * file.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n- * Attribute mappers for standard classfile attributes.\n+ * Attribute mappers for predefined (JVMS {@jvms 4.7}) and JDK-specific\n+ * nonstandard attributes.\n@@ -35,42 +36,1 @@\n- * Unless otherwise specified, mappers returned by each method\n- * do not permit multiple attribute instances in a given location.\n- * <p>\n- * The most stable {@link AttributeStability#STATELESS STATELESS} mappers are:\n- * <ul>\n- * <li>{@link #deprecated()}\n- * <li>{@link #moduleResolution()}\n- * <li>{@link #sourceDebugExtension()}\n- * <li>{@link #synthetic()}\n- * <\/ul>\n- *\n- * The mappers with {@link AttributeStability#CP_REFS CP_REFS} stability are:\n- * <ul>\n- * <li>{@link #annotationDefault()}\n- * <li>{@link #bootstrapMethods()}\n- * <li>{@link #code()}\n- * <li>{@link #compilationId()}\n- * <li>{@link #constantValue()}\n- * <li>{@link #enclosingMethod()}\n- * <li>{@link #exceptions()}\n- * <li>{@link #innerClasses()}\n- * <li>{@link #loadableDescriptors()}\n- * <li>{@link #methodParameters()}\n- * <li>{@link #module()}\n- * <li>{@link #moduleHashes()}\n- * <li>{@link #moduleMainClass()}\n- * <li>{@link #modulePackages()}\n- * <li>{@link #moduleTarget()}\n- * <li>{@link #nestHost()}\n- * <li>{@link #nestMembers()}\n- * <li>{@link #permittedSubclasses()}\n- * <li>{@link #record()}\n- * <li>{@link #runtimeInvisibleAnnotations()}\n- * <li>{@link #runtimeInvisibleParameterAnnotations()}\n- * <li>{@link #runtimeVisibleAnnotations()}\n- * <li>{@link #runtimeVisibleParameterAnnotations()}\n- * <li>{@link #signature()}\n- * <li>{@link #sourceFile()}\n- * <li>{@link #sourceId()}\n- * <\/ul>\n- *\n- * The mappers with {@link AttributeStability#LABELS LABELS} stability are:\n+ * Unless otherwise specified, each mapper returned by methods in this class:\n@@ -78,10 +38,5 @@\n- * <li>{@link #characterRangeTable()}\n- * <li>{@link #lineNumberTable()}\n- * <li>{@link #localVariableTable()}\n- * <li>{@link #localVariableTypeTable()}\n- * <\/ul>\n- *\n- * The {@link AttributeStability#UNSTABLE UNSTABLE} mappers are:\n- * <ul>\n- * <li>{@link #runtimeInvisibleTypeAnnotations()}\n- * <li>{@link #runtimeVisibleTypeAnnotations()}\n+ * <li>is predefined in the JVMS instead of JDK-specific;\n+ * <li>does not permit {@linkplain AttributeMapper#allowMultiple() multiple\n+ * attribute instances} in the same structure;\n+ * <li>the attribute has a {@linkplain AttributeMapper#stability() data\n+ * dependency} on the {@linkplain AttributeStability#CP_REFS constant pool}.\n@@ -91,1 +46,1 @@\n- *\n+ * @see java.lang.classfile.attribute\n@@ -211,1 +166,1 @@\n-     * {@return Attribute mapper for the {@code AnnotationDefault} attribute}\n+     * {@return the mapper for the {@code AnnotationDefault} attribute}\n@@ -218,1 +173,1 @@\n-     * {@return Attribute mapper for the {@code BootstrapMethods} attribute}\n+     * {@return the mapper for the {@code BootstrapMethods} attribute}\n@@ -225,2 +180,5 @@\n-     * {@return Attribute mapper for the {@code CharacterRangeTable} attribute}\n-     * The mapper permits multiple instances in a given location.\n+     * {@return the mapper for the {@code CharacterRangeTable} attribute}\n+     * This is a JDK-specific attribute.\n+     * The mapper permits multiple instances in a {@code Code} attribute, but this\n+     * attribute should be only emitted once.\n+     * This has a data dependency on {@linkplain AttributeStability#LABELS labels}.\n@@ -233,1 +191,1 @@\n-     * {@return Attribute mapper for the {@code Code} attribute}\n+     * {@return the mapper for the {@code Code} attribute}\n@@ -240,1 +198,2 @@\n-     * {@return Attribute mapper for the {@code CompilationID} attribute}\n+     * {@return the mapper for the {@code CompilationID} attribute}\n+     * This is a JDK-specific attribute.\n@@ -247,1 +206,1 @@\n-     * {@return Attribute mapper for the {@code ConstantValue} attribute}\n+     * {@return the mapper for the {@code ConstantValue} attribute}\n@@ -254,1 +213,1 @@\n-     * {@return Attribute mapper for the {@code Deprecated} attribute}\n+     * {@return the mapper for the {@code Deprecated} attribute}\n@@ -256,0 +215,1 @@\n+     * This has {@linkplain AttributeStability#STATELESS no data dependency}.\n@@ -262,1 +222,1 @@\n-     * {@return Attribute mapper for the {@code EnclosingMethod} attribute}\n+     * {@return the mapper for the {@code EnclosingMethod} attribute}\n@@ -269,1 +229,1 @@\n-     * {@return Attribute mapper for the {@code Exceptions} attribute}\n+     * {@return the mapper for the {@code Exceptions} attribute}\n@@ -276,1 +236,1 @@\n-     * {@return Attribute mapper for the {@code InnerClasses} attribute}\n+     * {@return the mapper for the {@code InnerClasses} attribute}\n@@ -283,2 +243,3 @@\n-     * {@return Attribute mapper for the {@code LineNumberTable} attribute}\n-     * The mapper permits multiple instances in a given location.\n+     * {@return the mapper for the {@code LineNumberTable} attribute}\n+     * The mapper permits multiple instances in a {@code Code} attribute.\n+     * This has a data dependency on {@linkplain AttributeStability#LABELS labels}.\n@@ -299,2 +260,3 @@\n-     * {@return Attribute mapper for the {@code LocalVariableTable} attribute}\n-     * The mapper permits multiple instances in a given location.\n+     * {@return the mapper for the {@code LocalVariableTable} attribute}\n+     * The mapper permits multiple instances in a {@code Code} attribute.\n+     * This has a data dependency on {@linkplain AttributeStability#LABELS labels}.\n@@ -307,1 +269,1 @@\n-     * {@return Attribute mapper for the {@code LocalVariableTypeTable} attribute}\n+     * {@return the mapper for the {@code LocalVariableTypeTable} attribute}\n@@ -309,0 +271,1 @@\n+     * This has a data dependency on {@linkplain AttributeStability#LABELS labels}.\n@@ -315,1 +278,1 @@\n-     * {@return Attribute mapper for the {@code MethodParameters} attribute}\n+     * {@return the mapper for the {@code MethodParameters} attribute}\n@@ -322,1 +285,1 @@\n-     * {@return Attribute mapper for the {@code Module} attribute}\n+     * {@return the mapper for the {@code Module} attribute}\n@@ -329,1 +292,2 @@\n-     * {@return Attribute mapper for the {@code ModuleHashes} attribute}\n+     * {@return the mapper for the {@code ModuleHashes} attribute}\n+     * This is a JDK-specific attribute.\n@@ -336,1 +300,1 @@\n-     * {@return Attribute mapper for the {@code ModuleMainClass} attribute}\n+     * {@return the mapper for the {@code ModuleMainClass} attribute}\n@@ -343,1 +307,1 @@\n-     * {@return Attribute mapper for the {@code ModulePackages} attribute}\n+     * {@return the mapper for the {@code ModulePackages} attribute}\n@@ -350,1 +314,3 @@\n-     * {@return Attribute mapper for the {@code ModuleResolution} attribute}\n+     * {@return the mapper for the {@code ModuleResolution} attribute}\n+     * This is a JDK-specific attribute.\n+     * This has {@linkplain AttributeStability#STATELESS no data dependency}.\n@@ -357,1 +323,2 @@\n-     * {@return Attribute mapper for the {@code ModuleTarget} attribute}\n+     * {@return the mapper for the {@code ModuleTarget} attribute}\n+     * This is a JDK-specific attribute.\n@@ -364,1 +331,1 @@\n-     * {@return Attribute mapper for the {@code NestHost} attribute}\n+     * {@return the mapper for the {@code NestHost} attribute}\n@@ -371,1 +338,1 @@\n-     * {@return Attribute mapper for the {@code NestMembers} attribute}\n+     * {@return the mapper for the {@code NestMembers} attribute}\n@@ -378,1 +345,1 @@\n-     * {@return Attribute mapper for the {@code PermittedSubclasses} attribute}\n+     * {@return the mapper for the {@code PermittedSubclasses} attribute}\n@@ -385,1 +352,1 @@\n-     * {@return Attribute mapper for the {@code Record} attribute}\n+     * {@return the mapper for the {@code Record} attribute}\n@@ -392,1 +359,1 @@\n-     * {@return Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute}\n+     * {@return the mapper for the {@code RuntimeInvisibleAnnotations} attribute}\n@@ -399,1 +366,1 @@\n-     * {@return Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute}\n+     * {@return the mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute}\n@@ -406,1 +373,3 @@\n-     * {@return Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute}\n+     * {@return the mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute}\n+     * This has a data dependency on {@linkplain AttributeStability#UNSTABLE\n+     * arbitrary indices} in the {@code class} file format.\n@@ -413,1 +382,1 @@\n-     * {@return Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute}\n+     * {@return the mapper for the {@code RuntimeVisibleAnnotations} attribute}\n@@ -420,1 +389,1 @@\n-     * {@return Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute}\n+     * {@return the mapper for the {@code RuntimeVisibleParameterAnnotations} attribute}\n@@ -427,1 +396,3 @@\n-     * {@return Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute}\n+     * {@return the mapper for the {@code RuntimeVisibleTypeAnnotations} attribute}\n+     * This has a data dependency on {@linkplain AttributeStability#UNSTABLE\n+     * arbitrary indices} in the {@code class} file format.\n@@ -434,1 +405,1 @@\n-     * {@return Attribute mapper for the {@code Signature} attribute}\n+     * {@return the mapper for the {@code Signature} attribute}\n@@ -441,1 +412,2 @@\n-     * {@return Attribute mapper for the {@code SourceDebugExtension} attribute}\n+     * {@return the mapper for the {@code SourceDebugExtension} attribute}\n+     * This has {@linkplain AttributeStability#STATELESS no data dependency}.\n@@ -448,1 +420,1 @@\n-     * {@return Attribute mapper for the {@code SourceFile} attribute}\n+     * {@return the mapper for the {@code SourceFile} attribute}\n@@ -455,1 +427,2 @@\n-     * {@return Attribute mapper for the {@code SourceID} attribute}\n+     * {@return the mapper for the {@code SourceID} attribute}\n+     * This is a JDK-specific attribute.\n@@ -462,1 +435,2 @@\n-     * {@return Attribute mapper for the {@code StackMapTable} attribute}\n+     * {@return the mapper for the {@code StackMapTable} attribute}\n+     * This has a data dependency on {@linkplain AttributeStability#LABELS labels}.\n@@ -469,1 +443,1 @@\n-     * {@return Attribute mapper for the {@code Synthetic} attribute}\n+     * {@return the mapper for the {@code Synthetic} attribute}\n@@ -471,0 +445,1 @@\n+     * This has {@linkplain AttributeStability#STATELESS no data dependency}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attributes.java","additions":69,"deletions":94,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-     * The number of seconds in the duration.\n+     * @serial The number of seconds in the duration.\n@@ -173,1 +173,1 @@\n-     * The number of nanoseconds in the duration, expressed as a fraction of the\n+     * @serial The number of nanoseconds in the duration, expressed as a fraction of the\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,1 +263,1 @@\n-     * The number of seconds from the epoch of 1970-01-01T00:00:00Z.\n+     * @serial The number of seconds from the epoch of 1970-01-01T00:00:00Z.\n@@ -267,1 +267,1 @@\n-     * The number of nanoseconds, later along the time-line, from the seconds field.\n+     * @serial The number of nanoseconds, later along the time-line, from the seconds field.\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,1 +185,1 @@\n-     * The year.\n+     * @serial The year.\n@@ -189,1 +189,1 @@\n-     * The month-of-year.\n+     * @serial The month-of-year.\n@@ -193,1 +193,1 @@\n-     * The day-of-month.\n+     * @serial The day-of-month.\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-     * The date part.\n+     * @serial The date part.\n@@ -173,1 +173,1 @@\n-     * The time part.\n+     * @serial The time part.\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-     * The hour.\n+     * @serial The hour.\n@@ -243,1 +243,1 @@\n-     * The minute.\n+     * @serial The minute.\n@@ -247,1 +247,1 @@\n-     * The second.\n+     * @serial The second.\n@@ -251,1 +251,1 @@\n-     * The nanosecond.\n+     * @serial The nanosecond.\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-     * The month-of-year, not null.\n+     * @serial The month-of-year, not null.\n@@ -159,1 +159,1 @@\n-     * The day-of-month.\n+     * @serial The day-of-month.\n","filename":"src\/java.base\/share\/classes\/java\/time\/MonthDay.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,1 +201,1 @@\n-     * The local date-time.\n+     * @serial The local date-time.\n@@ -205,1 +205,1 @@\n-     * The offset from UTC\/Greenwich.\n+     * @serial The offset from UTC\/Greenwich.\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-     * The local date-time.\n+     * @serial The local date-time.\n@@ -158,1 +158,1 @@\n-     * The offset from UTC\/Greenwich.\n+     * @serial The offset from UTC\/Greenwich.\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-     * The number of years.\n+     * @serial The number of years.\n@@ -170,1 +170,1 @@\n-     * The number of months.\n+     * @serial The number of months.\n@@ -174,1 +174,1 @@\n-     * The number of days.\n+     * @serial The number of days.\n","filename":"src\/java.base\/share\/classes\/java\/time\/Period.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,1 @@\n-     * The year being represented.\n+     * @serial The year being represented.\n","filename":"src\/java.base\/share\/classes\/java\/time\/Year.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-     * The year.\n+     * @serial The year.\n@@ -162,1 +162,1 @@\n-     * The month-of-year, not null.\n+     * @serial The month-of-year, not null.\n","filename":"src\/java.base\/share\/classes\/java\/time\/YearMonth.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-     * The local date-time.\n+     * @serial The local date-time.\n@@ -187,1 +187,1 @@\n-     * The offset from UTC\/Greenwich.\n+     * @serial The offset from UTC\/Greenwich.\n@@ -191,1 +191,1 @@\n-     * The time-zone.\n+     * @serial The time-zone.\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -4199,0 +4199,1 @@\n+        \/** @serial *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -888,1 +888,1 @@\n-    \/** Attribute type reference in an `extends' or `implements' clause.\n+    \/** Attribute type reference in an `extends', `implements', or 'permits' clause.\n@@ -5437,0 +5437,4 @@\n+                        if (subType.isErroneous()) {\n+                            \/\/ the type already caused errors, don't produce more potentially misleading errors\n+                            continue;\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,2 @@\n+compiler\/startup\/StartupOutput.java 8347406 generic-x64\n+\n@@ -102,0 +104,1 @@\n+gc\/shenandoah\/TestEvilSyncBug.java#generational 8345501 generic-all\n@@ -191,2 +194,0 @@\n-serviceability\/attach\/ConcAttachTest.java 8290043 linux-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n@@ -34,2 +35,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.reflect\n+ * @modules java.base\/jdk.internal.reflect\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/testlibrary\/asm\n@@ -86,2 +86,2 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n@@ -94,14 +94,14 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.AALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_0;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.V1_8;\n+import static org.objectweb.asm.Opcodes.AALOAD;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ARETURN;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+import static org.objectweb.asm.Opcodes.V1_8;\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestMeetIncompatibleInterfaceArrays.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/HelloDynamicInlineClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- *          java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/testlibrary\/asm\n@@ -46,1 +46,1 @@\n- *          java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/testlibrary\/asm\n@@ -60,3 +60,3 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n@@ -67,14 +67,14 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACONST_NULL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.IRETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_SUPER;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.ICONST_2;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.ARETURN;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.RETURN;\n@@ -1598,1 +1598,1 @@\n-    \/\/   java jdk.internal.org.objectweb.asm.util.ASMifier E0.class\n+    \/\/   java org.objectweb.asm.util.ASMifier E0.class\n@@ -1820,1 +1820,1 @@\n-    \/\/   java jdk.internal.org.objectweb.asm.util.ASMifier Sub2G.class\n+    \/\/   java org.objectweb.asm.util.ASMifier Sub2G.class\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NullPointerException\/NullPointerExceptionTest.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n- *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n@@ -70,1 +69,0 @@\n- *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n@@ -86,1 +84,0 @@\n- *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n@@ -102,1 +99,0 @@\n- *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n@@ -119,1 +115,0 @@\n- *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-package jdk.internal.org.objectweb.asm;\n+package org.objectweb.asm;\n","filename":"test\/hotspot\/jtreg\/testlibrary\/asm\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","status":"renamed"},{"patch":"@@ -722,1 +722,0 @@\n-\n@@ -731,2 +730,0 @@\n-com\/sun\/jdi\/ProcessAttachTest.java         8346827 linux-all\n-com\/sun\/jdi\/ReattachStressTest.java        8346827 linux-all\n@@ -840,0 +837,1 @@\n+valhalla\/valuetypes\/ObjectMethodsViaCondy.java 8349725 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/testlibrary\/asm\n@@ -28,1 +29,0 @@\n- *          java.base\/jdk.internal.org.objectweb.asm\n@@ -47,5 +47,5 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ConstantDynamic;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Type;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.ConstantDynamic;\n+import org.objectweb.asm.Handle;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n@@ -54,11 +54,11 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_IDENTITY;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.H_GETFIELD;\n-import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;\n-import static jdk.internal.org.objectweb.asm.Opcodes.V19;\n+import static org.objectweb.asm.Opcodes.ACC_FINAL;\n+import static org.objectweb.asm.Opcodes.ACC_IDENTITY;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ARETURN;\n+import static org.objectweb.asm.Opcodes.H_GETFIELD;\n+import static org.objectweb.asm.Opcodes.H_INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+import static org.objectweb.asm.Opcodes.V19;\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethodsViaCondy.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.security.BasicPermission;\n@@ -38,6 +37,0 @@\n-  @SuppressWarnings(\"serial\")\n-  public static class WhiteBoxPermission extends BasicPermission {\n-    public WhiteBoxPermission(String s) {\n-      super(s);\n-    }\n-  }\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}