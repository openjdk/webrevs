{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=valhalla\n@@ -11,1 +11,1 @@\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n+tags=.*\n@@ -22,4 +22,1 @@\n-[checks \"merge\"]\n-message=Merge\n-\n-reviewers=1\n+committers=1\n@@ -33,1 +30,1 @@\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n+pattern=^([124-8][0-9]{6}): \\[lworld\\] (\\S.*)$\n","filename":".jcheck\/conf","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=ea\n+DEFAULT_PROMOTED_VERSION_PRE=jep401ea2\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -54,0 +55,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -88,0 +90,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -159,0 +162,2 @@\n+#define CONSTANT_CLASS_DESCRIPTORS        71\n+\n@@ -197,1 +202,1 @@\n-      case JVM_CONSTANT_Class : {\n+      case JVM_CONSTANT_Class: {\n@@ -501,0 +506,3 @@\n+\n+        Symbol* const name = cp->symbol_at(class_index);\n+        const unsigned int name_len = name->utf8_length();\n@@ -710,1 +718,1 @@\n-            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n+            } else if (!Signature::is_void_method(signature)) {  \/\/ must have void signature.\n@@ -730,2 +738,3 @@\n-            if (ref_kind == JVM_REF_newInvokeSpecial) {\n-              if (name != vmSymbols::object_initializer_name()) {\n+\n+            if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n+              if (ref_kind == JVM_REF_newInvokeSpecial) {\n@@ -737,2 +746,10 @@\n-            } else {\n-              if (name == vmSymbols::object_initializer_name()) {\n+            } else { \/\/ <init>\n+              \/\/ The allowed invocation mode of <init> depends on its signature.\n+              \/\/ This test corresponds to verify_invoke_instructions in the verifier.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature()\n+                  && ref_kind == JVM_REF_newInvokeSpecial) {\n+                \/\/ OK, could be a constructor call\n+              } else {\n@@ -790,4 +807,13 @@\n-\/\/ Side-effects: populates the _local_interfaces field\n-void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,\n-                                       const int itfs_len,\n-                                       ConstantPool* const cp,\n+static void check_identity_and_value_modifiers(ClassFileParser* current, const InstanceKlass* super_type, TRAPS) {\n+  assert(super_type != nullptr,\"Method doesn't support null super type\");\n+  if (super_type->access_flags().is_identity_class() && !current->access_flags().is_identity_class()\n+      && super_type->name() != vmSymbols::java_lang_Object()) {\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Value type %s has an identity type as supertype\",\n+                current->class_name()->as_klass_external_name()));\n+  }\n+}\n+\n+void ClassFileParser::parse_interfaces(const ClassFileStream* stream,\n+                                       int itfs_len,\n+                                       ConstantPool* cp,\n@@ -795,0 +821,6 @@\n+                                       \/\/ FIXME: lots of these functions\n+                                       \/\/ declare their parameters as const,\n+                                       \/\/ which adds only noise to the code.\n+                                       \/\/ Remove the spurious const modifiers.\n+                                       \/\/ Many are of the form \"const int x\"\n+                                       \/\/ or \"T* const x\".\n@@ -802,0 +834,1 @@\n+\n@@ -804,3 +837,2 @@\n-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n-\n-    int index;\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len);\n+    int index = 0;\n@@ -809,1 +841,0 @@\n-      Klass* interf;\n@@ -814,29 +845,1 @@\n-      if (cp->tag_at(interface_index).is_klass()) {\n-        interf = cp->resolved_klass_at(interface_index);\n-      } else {\n-        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n-\n-        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n-        \/\/ But need to make sure it's not an array type.\n-        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n-                           \"Bad interface name in class file %s\", CHECK);\n-\n-        \/\/ Call resolve on the interface class name with class circularity checking\n-        interf = SystemDictionary::resolve_super_or_fail(_class_name,\n-                                                         unresolved_klass,\n-                                                         Handle(THREAD, _loader_data->class_loader()),\n-                                                         false, CHECK);\n-      }\n-\n-      if (!interf->is_interface()) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n-                          _class_name->as_klass_external_name(),\n-                          interf->external_name(),\n-                          interf->class_in_module_of_loader()));\n-      }\n-\n-      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n-        *has_nonstatic_concrete_methods = true;\n-      }\n-      _local_interfaces->at_put(index, InstanceKlass::cast(interf));\n+      _local_interface_indexes->at_put_grow(index, interface_index);\n@@ -854,2 +857,1 @@\n-      const InstanceKlass* const k = _local_interfaces->at(index);\n-      Symbol* interface_name = k->name();\n+      Symbol* interface_name = cp->klass_name_at(_local_interface_indexes->at(index));\n@@ -942,0 +944,2 @@\n+    _jdk_internal_LooselyConsistentValue,\n+    _jdk_internal_NullRestricted,\n@@ -1368,1 +1372,1 @@\n-                                   bool is_interface,\n+                                   AccessFlags class_access_flags,\n@@ -1381,0 +1385,2 @@\n+  bool is_inline_type = !class_access_flags.is_identity_class() && !class_access_flags.is_abstract();\n+  bool is_value_class = !class_access_flags.is_identity_class() && !class_access_flags.is_interface();\n@@ -1388,1 +1394,6 @@\n-  const int total_fields = length + num_injected;\n+\n+  \/\/ two more slots are required for inline classes:\n+  \/\/ one for the static field with a reference to the pre-allocated default value\n+  \/\/ one for the field the JVM injects when detecting an empty inline class\n+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0)\n+                           + ((UseAltSubstitutabilityMethod && is_value_class) ? 1 : 0);\n@@ -1394,0 +1405,1 @@\n+  int instance_fields_count = 0;\n@@ -1399,0 +1411,7 @@\n+    jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;\n+    if (!supports_inline_types()) {\n+      recognized_modifiers &= ~JVM_ACC_STRICT;\n+    }\n+\n+    const jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    verify_legal_field_modifiers(flags, class_access_flags, CHECK);\n@@ -1400,2 +1419,0 @@\n-    const jint flags = cfs->get_u2_fast() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n-    verify_legal_field_modifiers(flags, is_interface, CHECK);\n@@ -1418,0 +1435,1 @@\n+    if (!access_flags.is_static()) instance_fields_count++;\n@@ -1425,0 +1443,2 @@\n+    bool is_null_restricted = false;\n+\n@@ -1444,0 +1464,18 @@\n+        if (parsed_annotations.has_annotation(AnnotationCollector::_jdk_internal_NullRestricted)) {\n+          if (!Signature::has_envelope(sig)) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s with signature %s (primitive types can never be null)\",\n+              class_name()->as_C_string(), name->as_C_string(), sig->as_C_string());\n+          }\n+          const bool is_strict = (flags & JVM_ACC_STRICT) != 0;\n+          if (!is_strict) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s which doesn't have the @jdk.internal.vm.annotation.Strict annotation\",\n+              class_name()->as_C_string(), name->as_C_string());\n+          }\n+          is_null_restricted = true;\n+        }\n@@ -1466,0 +1504,4 @@\n+    if (is_null_restricted) {\n+      fieldFlags.update_null_free_inline_type(true);\n+    }\n+\n@@ -1482,0 +1524,3 @@\n+    if (access_flags.is_strict() && access_flags.is_static()) {\n+      _has_strict_static_fields = true;\n+    }\n@@ -1486,1 +1531,0 @@\n-  int index = length;\n@@ -1514,3 +1558,2 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n-      index++;\n+      int idx = _temp_field_info->append(fi);\n+      _temp_field_info->adr_at(idx)->set_index(idx);\n@@ -1520,1 +1563,33 @@\n-  assert(_temp_field_info->length() == index, \"Must be\");\n+  if (is_inline_type) {\n+    \/\/ Inject static \".null_reset\" field. This is an all-zero value with its null-channel set to zero.\n+    \/\/ IT should never be seen by user code, it is used when writing \"null\" to a nullable flat field\n+    \/\/ The all-zero value ensure that any embedded oop will be set to null, to avoid keeping dead objects\n+    \/\/ alive.\n+    FieldInfo::FieldFlags fflags2(0);\n+    fflags2.update_injected(true);\n+    AccessFlags aflags2(JVM_ACC_STATIC);\n+    FieldInfo fi2(aflags2,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(null_reset_value_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n+                 0,\n+                 fflags2);\n+    int idx2 = _temp_field_info->append(fi2);\n+    _temp_field_info->adr_at(idx2)->set_index(idx2);\n+    _static_oop_count++;\n+  }\n+  if (!access_flags().is_identity_class() && !access_flags().is_interface()\n+      && _class_name != vmSymbols::java_lang_Object() && UseAltSubstitutabilityMethod) {\n+    \/\/ Acmp map required for abstract and concrete value classes\n+    FieldInfo::FieldFlags fflags2(0);\n+    fflags2.update_injected(true);\n+    fflags2.update_stable(true);\n+    AccessFlags aflags2(JVM_ACC_STATIC | JVM_ACC_FINAL);\n+    FieldInfo fi3(aflags2,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(acmp_maps_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(int_array_signature)),\n+                 0,\n+                 fflags2);\n+    int idx2 = _temp_field_info->append(fi3);\n+    _temp_field_info->adr_at(idx2)->set_index(idx2);\n+    _static_oop_count++;\n+  }\n@@ -1900,0 +1975,8 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_LooselyConsistentValue_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_LooselyConsistentValue;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NullRestricted_signature): {\n+      if (_location != _in_field)   break; \/\/ only allow for fields\n+      return _jdk_internal_NullRestricted;\n+    }\n@@ -2136,0 +2219,2 @@\n+                                      bool is_value_class,\n+                                      bool is_abstract_class,\n@@ -2177,1 +2262,1 @@\n-    verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);\n+    verify_legal_method_modifiers(flags, access_flags() , name, CHECK_NULL);\n@@ -2185,0 +2270,9 @@\n+  if (Arguments::is_valhalla_enabled()) {\n+    if (((flags & JVM_ACC_SYNCHRONIZED) == JVM_ACC_SYNCHRONIZED)\n+        && ((flags & JVM_ACC_STATIC) == 0 )\n+        && !_access_flags.is_identity_class()) {\n+      classfile_parse_error(\"Invalid synchronized method in non-identity class %s\", THREAD);\n+        return nullptr;\n+    }\n+  }\n+\n@@ -2719,0 +2813,2 @@\n+                                    bool is_value_class,\n+                                    bool is_abstract_type,\n@@ -2743,0 +2839,2 @@\n+                                    is_value_class,\n+                                    is_abstract_type,\n@@ -3008,0 +3106,1 @@\n+\n@@ -3016,0 +3115,1 @@\n+\n@@ -3021,0 +3121,8 @@\n+    if (!supports_inline_types()) {\n+      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+      if (!is_module && !is_interface) {\n+        flags |= JVM_ACC_IDENTITY;\n+      }\n+    }\n+\n@@ -3126,0 +3234,43 @@\n+u2 ClassFileParser::parse_classfile_loadable_descriptors_attribute(const ClassFileStream* const cfs,\n+                                                                   const u1* const loadable_descriptors_attribute_start,\n+                                                                   TRAPS) {\n+  const u1* const current_mark = cfs->current();\n+  u2 length = 0;\n+  if (loadable_descriptors_attribute_start != nullptr) {\n+    cfs->set_current(loadable_descriptors_attribute_start);\n+    cfs->guarantee_more(2, CHECK_0);  \/\/ length\n+    length = cfs->get_u2_fast();\n+  }\n+  const int size = length;\n+  Array<u2>* const loadable_descriptors = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  _loadable_descriptors = loadable_descriptors;\n+  if (length > 0) {\n+    int index = 0;\n+    cfs->guarantee_more(2 * length, CHECK_0);\n+    for (int n = 0; n < length; n++) {\n+      const u2 descriptor_index = cfs->get_u2_fast();\n+      guarantee_property(\n+        valid_symbol_at(descriptor_index),\n+        \"LoadableDescriptors descriptor_index %u has bad constant type in class file %s\",\n+        descriptor_index, CHECK_0);\n+      Symbol* descriptor = _cp->symbol_at(descriptor_index);\n+      bool valid = legal_field_signature(descriptor, CHECK_0);\n+      if(!valid) {\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_ClassFormatError(),\n+          \"Descriptor from LoadableDescriptors attribute at index \\\"%d\\\" in class %s has illegal signature \\\"%s\\\"\",\n+          descriptor_index, _class_name->as_C_string(), descriptor->as_C_string());\n+        return 0;\n+      }\n+      loadable_descriptors->at_put(index++, descriptor_index);\n+    }\n+    assert(index == size, \"wrong size\");\n+  }\n+\n+  \/\/ Restore buffer's current position.\n+  cfs->set_current(current_mark);\n+\n+  return length;\n+}\n+\n@@ -3376,0 +3527,2 @@\n+  \/\/ Set _loadable_descriptors attribute to default sentinel\n+  _loadable_descriptors = Universe::the_empty_short_array();\n@@ -3382,0 +3535,1 @@\n+  bool parsed_loadable_descriptors_attribute = false;\n@@ -3403,0 +3557,2 @@\n+  const u1* loadable_descriptors_attribute_start = nullptr;\n+  u4  loadable_descriptors_attribute_length = 0;\n@@ -3618,0 +3774,9 @@\n+            if (Arguments::is_valhalla_enabled() && tag == vmSymbols::tag_loadable_descriptors()) {\n+              if (parsed_loadable_descriptors_attribute) {\n+                classfile_parse_error(\"Multiple LoadableDescriptors attributes in class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_loadable_descriptors_attribute = true;\n+              loadable_descriptors_attribute_start = cfs->current();\n+              loadable_descriptors_attribute_length = attribute_length;\n+            }\n@@ -3694,0 +3859,12 @@\n+  if (parsed_loadable_descriptors_attribute) {\n+    const u2 num_classes = parse_classfile_loadable_descriptors_attribute(\n+                            cfs,\n+                            loadable_descriptors_attribute_start,\n+                            CHECK);\n+    if (_need_verify) {\n+      guarantee_property(\n+        loadable_descriptors_attribute_length == sizeof(num_classes) + sizeof(u2) * num_classes,\n+        \"Wrong LoadableDescriptors attribute length in class file %s\", CHECK);\n+    }\n+  }\n+\n@@ -3760,0 +3937,1 @@\n+  this_klass->set_loadable_descriptors(_loadable_descriptors);\n@@ -3763,0 +3941,1 @@\n+  this_klass->set_inline_layout_info_array(_inline_layout_info_array);\n@@ -3801,2 +3980,1 @@\n-                       \"Invalid superclass index %u in class file %s\",\n-                       super_class_index,\n+                       \"Invalid superclass index 0 in class file %s\",\n@@ -3994,0 +4172,6 @@\n+bool ClassFileParser::supports_inline_types() const {\n+  \/\/ Inline types are only supported by class file version 71.65535 and later\n+  return _major_version > JAVA_27_VERSION ||\n+         (_major_version == JAVA_27_VERSION && _minor_version == JAVA_PREVIEW_MINOR_VERSION);\n+}\n+\n@@ -4037,3 +4221,4 @@\n-  } else if (max_transitive_size == local_size) {\n-    \/\/ only local interfaces added, share local interface array\n-    return local_ifs;\n+    \/\/ The three lines below are commented to work around bug JDK-8245487\n+\/\/  } else if (max_transitive_size == local_size) {\n+\/\/    \/\/ only local interfaces added, share local interface array\n+\/\/    return local_ifs;\n@@ -4060,0 +4245,1 @@\n+\n@@ -4090,0 +4276,10 @@\n+    \/\/ The JVMS says that super classes for value types must not have the ACC_IDENTITY\n+    \/\/ flag set. But, java.lang.Object must still be allowed to be a direct super class\n+    \/\/ for a value classes.  So, it is treated as a special case for now.\n+    if (!this_klass->access_flags().is_identity_class() &&\n+        super->name() != vmSymbols::java_lang_Object() &&\n+        super->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super, THREAD);\n+      return;\n+    }\n+\n@@ -4282,1 +4478,1 @@\n-  const bool is_super      = (flags & JVM_ACC_SUPER)      != 0;\n+  const bool is_identity   = (flags & JVM_ACC_IDENTITY)   != 0;\n@@ -4286,0 +4482,2 @@\n+  const bool valid_value_class = is_identity || is_interface ||\n+                                 (supports_inline_types() && (!is_identity && (is_abstract || is_final)));\n@@ -4289,2 +4487,3 @@\n-      (is_interface && major_gte_1_5 && (is_super || is_enum)) ||\n-      (!is_interface && major_gte_1_5 && is_annotation)) {\n+      (is_interface && major_gte_1_5 && (is_identity || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (!is_interface && major_gte_1_5 && is_annotation) ||\n+      (!valid_value_class)) {\n@@ -4292,0 +4491,4 @@\n+    const char* class_note = \"\";\n+    if (!valid_value_class) {\n+      class_note = \" (a value class must be final or else abstract)\";\n+    }\n@@ -4385,2 +4588,2 @@\n-void ClassFileParser::verify_legal_field_modifiers(jint flags,\n-                                                   bool is_interface,\n+void ClassFileParser:: verify_legal_field_modifiers(jint flags,\n+                                                   AccessFlags class_access_flags,\n@@ -4398,0 +4601,1 @@\n+  const bool is_strict    = (flags & JVM_ACC_STRICT)    != 0;\n@@ -4400,1 +4604,2 @@\n-  bool is_illegal = false;\n+  const bool is_interface = class_access_flags.is_interface();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n@@ -4402,9 +4607,30 @@\n-  if (is_interface) {\n-    if (!is_public || !is_static || !is_final || is_private ||\n-        is_protected || is_volatile || is_transient ||\n-        (major_gte_1_5 && is_enum)) {\n-      is_illegal = true;\n-    }\n-  } else { \/\/ not interface\n-    if (has_illegal_visibility(flags) || (is_final && is_volatile)) {\n-      is_illegal = true;\n+  bool is_illegal = false;\n+  const char* error_msg = \"\";\n+\n+  \/\/ There is some overlap in the checks that apply, for example interface fields\n+  \/\/ must be static, static fields can't be strict, and therefore interfaces can't\n+  \/\/ have strict fields. So we don't have to check every possible invalid combination\n+  \/\/ individually as long as all are covered. Once we have found an illegal combination\n+  \/\/ we can stop checking.\n+\n+  if (!is_illegal) {\n+    if (is_interface) {\n+      if (!is_public || !is_static || !is_final || is_private ||\n+          is_protected || is_volatile || is_transient ||\n+          (major_gte_1_5 && is_enum)) {\n+        is_illegal = true;\n+        error_msg = \"interface fields must be public, static and final, and may be synthetic\";\n+      }\n+    } else { \/\/ not interface\n+      if (has_illegal_visibility(flags)) {\n+        is_illegal = true;\n+        error_msg = \"invalid visibility flags for class field\";\n+      } else if (is_final && is_volatile) {\n+        is_illegal = true;\n+        error_msg = \"fields cannot be final and volatile\";\n+      } else if (supports_inline_types()) {\n+        if (!is_identity_class && !is_static && (!is_strict || !is_final)) {\n+          is_illegal = true;\n+          error_msg = \"value class fields must be either non-static final and strict, or static\";\n+        }\n+      }\n@@ -4420,2 +4646,2 @@\n-      \"Illegal field modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags);\n+      \"Illegal field modifiers (%s) in class %s: 0x%X\",\n+      error_msg, _class_name->as_C_string(), flags);\n@@ -4427,1 +4653,1 @@\n-                                                    bool is_interface,\n+                                                    AccessFlags class_access_flags,\n@@ -4446,0 +4672,4 @@\n+  \/\/ LW401 CR required: removal of value factories support\n+  const bool is_interface    = class_access_flags.is_interface();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+  const bool is_abstract_class = class_access_flags.is_abstract();\n@@ -4449,0 +4679,1 @@\n+  const char* class_note = \"\";\n@@ -4488,4 +4719,9 @@\n-        if (is_abstract) {\n-          if ((is_final || is_native || is_private || is_static ||\n-              (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n-            is_illegal = true;\n+        if (!is_identity_class && is_synchronized && !is_static) {\n+          is_illegal = true;\n+          class_note = \" (not an identity class)\";\n+        } else {\n+          if (is_abstract) {\n+            if ((is_final || is_native || is_private || is_static ||\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n+              is_illegal = true;\n+            }\n@@ -4504,2 +4740,3 @@\n-      \"Method %s in class %s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), flags);\n+      \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+      name->as_C_string(), _class_name->as_C_string(),\n+      class_note, flags);\n@@ -4563,0 +4800,9 @@\n+bool ClassFileParser::is_class_in_loadable_descriptors_attribute(Symbol *klass) {\n+  if (_loadable_descriptors == nullptr) return false;\n+  for (int i = 0; i < _loadable_descriptors->length(); i++) {\n+        Symbol* class_name = _cp->symbol_at(_loadable_descriptors->at(i));\n+        if (class_name == klass) return true;\n+  }\n+  return false;\n+}\n+\n@@ -4664,1 +4910,2 @@\n-    case JVM_SIGNATURE_CLASS: {\n+    case JVM_SIGNATURE_CLASS:\n+    {\n@@ -4679,1 +4926,1 @@\n-        \/\/ Skip leading 'L' and ignore first appearance of ';'\n+        \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n@@ -4735,0 +4982,4 @@\n+    } else if ((_major_version >= CONSTANT_CLASS_DESCRIPTORS || _class_name->starts_with(\"jdk\/internal\/reflect\/\"))\n+                   && bytes[length - 1] == ';' ) {\n+      \/\/ Support for L...; descriptors\n+      legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);\n@@ -4802,1 +5053,2 @@\n-      if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {\n+      if (name == vmSymbols::object_initializer_name() ||\n+          name == vmSymbols::class_initializer_name()) {\n@@ -4829,0 +5081,10 @@\n+bool ClassFileParser::legal_field_signature(const Symbol* signature, TRAPS) const {\n+  const char* const bytes = (const char*)signature->bytes();\n+  const unsigned int length = signature->utf8_length();\n+  const char* const p = skip_over_field_signature(bytes, false, length, CHECK_false);\n+\n+  if (p == nullptr || (p - bytes) != (int)length) {\n+    return false;\n+  }\n+  return true;\n+}\n@@ -4864,3 +5126,3 @@\n-      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-      sig_length > 0 &&\n-      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+    sig_length > 0 &&\n+    signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n@@ -4917,2 +5179,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->_static_field_size;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->_static_field_size;\n@@ -4922,2 +5184,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->oop_map_blocks->_nonstatic_oop_map_count;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->oop_map_blocks->_nonstatic_oop_map_count;\n@@ -4927,2 +5189,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->_instance_size;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->_instance_size;\n@@ -5043,1 +5305,0 @@\n-\n@@ -5066,3 +5327,3 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  assert(ik->static_field_size() == _field_info->_static_field_size, \"sanity\");\n-  assert(ik->nonstatic_oop_map_count() == _field_info->oop_map_blocks->_nonstatic_oop_map_count,\n+  assert(_layout_info != nullptr, \"invariant\");\n+  assert(ik->static_field_size() == _layout_info->_static_field_size, \"sanity\");\n+  assert(ik->nonstatic_oop_map_count() == _layout_info->oop_map_blocks->_nonstatic_oop_map_count,\n@@ -5072,1 +5333,1 @@\n-  assert(ik->size_helper() == _field_info->_instance_size, \"sanity\");\n+  assert(ik->size_helper() == _layout_info->_instance_size, \"sanity\");\n@@ -5078,2 +5339,12 @@\n-  ik->set_nonstatic_field_size(_field_info->_nonstatic_field_size);\n-  ik->set_has_nonstatic_fields(_field_info->_has_nonstatic_fields);\n+  ik->set_nonstatic_field_size(_layout_info->_nonstatic_field_size);\n+  ik->set_has_nonstatic_fields(_layout_info->_has_nonstatic_fields);\n+  ik->set_has_strict_static_fields(_has_strict_static_fields);\n+\n+  if (_layout_info->_is_naturally_atomic) {\n+    ik->set_is_naturally_atomic();\n+  }\n+\n+  if (_layout_info->_must_be_atomic) {\n+    ik->set_must_be_atomic();\n+  }\n+\n@@ -5099,0 +5370,1 @@\n+  assert(nullptr == _loadable_descriptors, \"invariant\");\n@@ -5102,0 +5374,1 @@\n+  assert(nullptr == _inline_layout_info_array, \"invariant\");\n@@ -5178,1 +5451,1 @@\n-  OopMapBlocksBuilder* oop_map_blocks = _field_info->oop_map_blocks;\n+  OopMapBlocksBuilder* oop_map_blocks = _layout_info->oop_map_blocks;\n@@ -5239,0 +5512,49 @@\n+  if (is_inline_type()) {\n+    InlineKlass* vk = InlineKlass::cast(ik);\n+    vk->set_payload_alignment(_layout_info->_payload_alignment);\n+    vk->set_payload_offset(_layout_info->_payload_offset);\n+    vk->set_payload_size_in_bytes(_layout_info->_payload_size_in_bytes);\n+    vk->set_non_atomic_size_in_bytes(_layout_info->_non_atomic_size_in_bytes);\n+    vk->set_non_atomic_alignment(_layout_info->_non_atomic_alignment);\n+    vk->set_atomic_size_in_bytes(_layout_info->_atomic_layout_size_in_bytes);\n+    vk->set_nullable_size_in_bytes(_layout_info->_nullable_layout_size_in_bytes);\n+    vk->set_null_marker_offset(_layout_info->_null_marker_offset);\n+    vk->set_null_reset_value_offset(_layout_info->_null_reset_value_offset);\n+    if (_layout_info->_is_empty_inline_klass) vk->set_is_empty_inline_type();\n+    vk->initialize_calling_convention(CHECK);\n+  }\n+\n+  if (Arguments::is_valhalla_enabled() && !access_flags().is_identity_class() && !access_flags().is_interface()\n+      && _class_name != vmSymbols::java_lang_Object() && UseAltSubstitutabilityMethod) {\n+    \/\/ Both abstract and concrete value classes need a field map for acmp\n+    ik->set_acmp_maps_offset(_layout_info->_acmp_maps_offset);\n+    \/\/ Current format of acmp maps:\n+    \/\/ All maps are stored contiguously in a single int array because it might\n+    \/\/ be too early to instantiate an Object array (to be investigated)\n+    \/\/ Format is:\n+    \/\/ [number_of_nonoop_entries][offset0][size[0][offset1][size1]...[oop_offset0][oop_offset1]...\n+    \/\/                           ^               ^\n+    \/\/                           |               |\n+    \/\/                           --------------------- Pair of integer describing a segment of\n+    \/\/                                                 contiguous non-oop fields\n+    \/\/ First element is the number of segment of contiguous non-oop fields\n+    \/\/ Then, each segment of contiguous non-oop fields is described by two consecutive elements:\n+    \/\/ the offset then the size.\n+    \/\/ After the last segment of contiguous non-oop fields, oop fields are described, one element\n+    \/\/ per oop field, containing the offset of the field.\n+    int nonoop_acmp_map_size = _layout_info->_nonoop_acmp_map->length() * 2;\n+    int oop_acmp_map_size = _layout_info->_oop_acmp_map->length();\n+    typeArrayOop map = oopFactory::new_intArray(nonoop_acmp_map_size + oop_acmp_map_size + 1, CHECK);\n+    typeArrayHandle map_h(THREAD, map);\n+    map_h->int_at_put(0, _layout_info->_nonoop_acmp_map->length());\n+    for (int i = 0; i < _layout_info->_nonoop_acmp_map->length(); i++) {\n+      map_h->int_at_put(i * 2 + 1, _layout_info->_nonoop_acmp_map->at(i).first);\n+      map_h->int_at_put(i * 2 + 2, _layout_info->_nonoop_acmp_map->at(i).second);\n+    }\n+    int oop_map_start = nonoop_acmp_map_size + 1;\n+    for (int i = 0; i < _layout_info->_oop_acmp_map->length(); i++) {\n+      map_h->int_at_put(oop_map_start + i, _layout_info->_oop_acmp_map->at(i));\n+    }\n+    ik->java_mirror()->obj_field_put(ik->acmp_maps_offset(), map_h());\n+  }\n+\n@@ -5319,0 +5641,1 @@\n+  _loadable_descriptors(nullptr),\n@@ -5321,0 +5644,1 @@\n+  _local_interface_indexes(nullptr),\n@@ -5330,1 +5654,2 @@\n-  _field_info(nullptr),\n+  _layout_info(nullptr),\n+  _inline_layout_info_array(nullptr),\n@@ -5359,0 +5684,5 @@\n+  _has_strict_static_fields(false),\n+  _has_inline_type_fields(false),\n+  _is_naturally_atomic(false),\n+  _must_be_atomic(true),\n+  _has_loosely_consistent_annotation(false),\n@@ -5396,0 +5726,1 @@\n+  _loadable_descriptors = nullptr;\n@@ -5400,0 +5731,1 @@\n+  _inline_layout_info_array = nullptr;\n@@ -5419,0 +5751,4 @@\n+  if (_inline_layout_info_array != nullptr) {\n+    MetadataFactory::free_array<InlineLayoutInfo>(_loader_data, _inline_layout_info_array);\n+  }\n+\n@@ -5441,0 +5777,4 @@\n+  if (_loadable_descriptors != nullptr && _loadable_descriptors != Universe::the_empty_short_array()) {\n+    MetadataFactory::free_array<u2>(_loader_data, _loadable_descriptors);\n+  }\n+\n@@ -5540,0 +5880,9 @@\n+  \/\/ Fixing ACC_SUPER\/ACC_IDENTITY for old class files\n+  if (!supports_inline_types()) {\n+    const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+    const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+    if (!is_module && !is_interface) {\n+      flags |= JVM_ACC_IDENTITY;\n+    }\n+  }\n+\n@@ -5643,2 +5992,0 @@\n-  assert(_local_interfaces != nullptr, \"invariant\");\n-\n@@ -5647,1 +5994,1 @@\n-               _access_flags.is_interface(),\n+               _access_flags,\n@@ -5657,1 +6004,3 @@\n-                _access_flags.is_interface(),\n+                is_interface(),\n+                !is_identity_class(),\n+                is_abstract_class(),\n@@ -5745,1 +6094,1 @@\n-    if (_access_flags.is_interface()) {\n+    if (is_interface()) {\n@@ -5767,0 +6116,14 @@\n+    if (_super_klass->is_interface()) {\n+      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (_super_klass->is_final()) {\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (Arguments::is_valhalla_enabled()) {\n+      check_identity_and_value_modifiers(this, _super_klass, CHECK);\n+    }\n+\n@@ -5770,0 +6133,1 @@\n+  }\n@@ -5771,3 +6135,24 @@\n-    if (_super_klass->is_interface()) {\n-      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n-      return;\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && _access_flags.is_identity_class()) {\n+    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n+          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.LooselyConsistentValue, because it is not a value class\",\n+                  _class_name->as_klass_external_name()));\n+  }\n+\n+  \/\/ Determining if the class allows tearing or not (default is not)\n+  if (Arguments::is_valhalla_enabled() && !_access_flags.is_identity_class()) {\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+        && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+      \/\/ Conditions above are not sufficient to determine atomicity requirements,\n+      \/\/ the presence of fields with atomic requirements could force the current class to have atomicy requirements too\n+      \/\/ Marking as not needing atomicity for now, can be updated when computing the fields layout\n+      \/\/ The InstanceKlass must be filled with the value from the FieldLayoutInfo returned by\n+      \/\/ the FieldLayoutBuilder, not with this _must_be_atomic field.\n+      _must_be_atomic = false;\n+    }\n+    \/\/ Apply VM options override\n+    if (*ForceNonTearable != '\\0') {\n+      \/\/ Allow a command line switch to force the same atomicity property:\n+      const char* class_name_str = _class_name->as_C_string();\n+      if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+        _must_be_atomic = true;\n+      }\n@@ -5777,0 +6162,46 @@\n+  int itfs_len = _local_interface_indexes == nullptr ? 0 : _local_interface_indexes->length();\n+  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n+  if (_local_interface_indexes != nullptr) {\n+    for (int i = 0; i < _local_interface_indexes->length(); i++) {\n+      u2 interface_index = _local_interface_indexes->at(i);\n+      Klass* interf;\n+      if (cp->tag_at(interface_index).is_klass()) {\n+        interf = cp->resolved_klass_at(interface_index);\n+      } else {\n+        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n+\n+        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n+        \/\/ But need to make sure it's not an array type.\n+        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n+                            \"Bad interface name in class file %s\", CHECK);\n+\n+        \/\/ Call resolve on the interface class name with class circularity checking\n+        interf = SystemDictionary::resolve_super_or_fail(\n+                                                  _class_name,\n+                                                  unresolved_klass,\n+                                                  Handle(THREAD, _loader_data->class_loader()),\n+                                                  false,\n+                                                  CHECK);\n+      }\n+\n+      if (!interf->is_interface()) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n+                          _class_name->as_klass_external_name(),\n+                          interf->external_name(),\n+                          interf->class_in_module_of_loader()));\n+      }\n+\n+      if (Arguments::is_valhalla_enabled()) {\n+        \/\/ Check modifiers and set carries_identity_modifier\/carries_value_modifier flags\n+        check_identity_and_value_modifiers(this, InstanceKlass::cast(interf), CHECK);\n+      }\n+\n+      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n+        _has_nonstatic_concrete_methods = true;\n+      }\n+      _local_interfaces->at_put(i, InstanceKlass::cast(interf));\n+    }\n+  }\n+  assert(_local_interfaces != nullptr, \"invariant\");\n+\n@@ -5804,1 +6235,1 @@\n-  _itable_size = _access_flags.is_interface() ? 0 :\n+  _itable_size = is_interface() ? 0 :\n@@ -5809,3 +6240,92 @@\n-  _field_info = new FieldLayoutInfo();\n-  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n-                        _parsed_annotations->is_contended(), _field_info);\n+  if (Arguments::is_valhalla_enabled()) {\n+    _inline_layout_info_array = MetadataFactory::new_array<InlineLayoutInfo>(_loader_data,\n+                                                   java_fields_count(),\n+                                                   CHECK);\n+    for (GrowableArrayIterator<FieldInfo> it = _temp_field_info->begin(); it != _temp_field_info->end(); ++it) {\n+      FieldInfo fieldinfo = *it;\n+      if (fieldinfo.access_flags().is_static()) continue;  \/\/ Only non-static fields are processed at load time\n+      Symbol* sig = fieldinfo.signature(cp);\n+      if (fieldinfo.field_flags().is_null_free_inline_type()) {\n+        \/\/ Pre-load classes of null-free fields that are candidate for flattening\n+        TempNewSymbol s = Signature::strip_envelope(sig);\n+        if (s == _class_name) {\n+          THROW_MSG(vmSymbols::java_lang_ClassCircularityError(),\n+                    err_msg(\"Class %s cannot have a null-free non-static field of its own type\", _class_name->as_C_string()));\n+        }\n+        log_info(class, preload)(\"Preloading of class %s during loading of class %s. \"\n+                                  \"Cause: a null-free non-static field is declared with this type\",\n+                                  s->as_C_string(), _class_name->as_C_string());\n+        InstanceKlass* klass = SystemDictionary::resolve_with_circularity_detection(_class_name, s,\n+                                                                                    Handle(THREAD,\n+                                                                                    _loader_data->class_loader()),\n+                                                                                    false, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                      \"(cause: null-free non-static field) failed: %s\",\n+                                      s->as_C_string(), _class_name->as_C_string(),\n+                                      PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          return; \/\/ Exception is still pending\n+        }\n+        assert(klass != nullptr, \"Sanity check\");\n+        InstanceKlass::check_can_be_annotated_with_NullRestricted(klass, _class_name, CHECK);\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(vk);\n+        log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                 \"(cause: null-free non-static field) succeeded\",\n+                                 s->as_C_string(), _class_name->as_C_string());\n+      } else if (Signature::has_envelope(sig) && PreloadClasses) {\n+        \/\/ Preloading classes for nullable fields that are listed in the LoadableDescriptors attribute\n+        \/\/ Those classes would be required later for the flattening of nullable inline type fields\n+        TempNewSymbol name = Signature::strip_envelope(sig);\n+        if (name != _class_name && is_class_in_loadable_descriptors_attribute(sig)) {\n+          log_info(class, preload)(\"Preloading of class %s during loading of class %s. \"\n+                                   \"Cause: field type in LoadableDescriptors attribute\",\n+                                   name->as_C_string(), _class_name->as_C_string());\n+          oop loader = loader_data()->class_loader();\n+          Klass* klass = SystemDictionary::resolve_super_or_fail(_class_name, name,\n+                                                                 Handle(THREAD, loader),\n+                                                                 false, THREAD);\n+          if (klass != nullptr) {\n+            if (klass->is_inline_klass()) {\n+              _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+              log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                       \"(cause: field type in LoadableDescriptors attribute) succeeded\",\n+                                       name->as_C_string(), _class_name->as_C_string());\n+            } else {\n+              \/\/ Non value class are allowed by the current spec, but it could be an indication of an issue so let's log a warning\n+              log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                          \"(cause: field type in LoadableDescriptors attribute) but loaded class is not a value class\",\n+                                          name->as_C_string(), _class_name->as_C_string());\n+            }\n+          } else {\n+            log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                        \"(cause: field type in LoadableDescriptors attribute) failed : %s\",\n+                                        name->as_C_string(), _class_name->as_C_string(),\n+                                        PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          }\n+          \/\/ Loads triggered by the LoadableDescriptors attribute are speculative, failures must not impact loading of current class\n+          if (HAS_PENDING_EXCEPTION) {\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+        } else {\n+          \/\/ Just poking the system dictionary to see if the class has already be loaded. Looking for migrated classes\n+          \/\/ used when --enable-preview when jdk isn't compiled with --enable-preview so doesn't include LoadableDescriptors.\n+          \/\/ This is temporary.\n+          oop loader = loader_data()->class_loader();\n+          InstanceKlass* klass = SystemDictionary::find_instance_klass(THREAD, name, Handle(THREAD, loader));\n+          if (klass != nullptr && klass->is_inline_klass()) {\n+            _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+            log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                     \"(cause: field type not in LoadableDescriptors attribute) succeeded\",\n+                                     name->as_C_string(), _class_name->as_C_string());\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  _layout_info = new FieldLayoutInfo();\n+  FieldLayoutBuilder lb(class_name(), loader_data(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n+      _parsed_annotations->is_contended(), is_inline_type(),\n+      access_flags().is_abstract() && !access_flags().is_identity_class() && !access_flags().is_interface(),\n+      _must_be_atomic, _layout_info, _inline_layout_info_array);\n@@ -5813,0 +6333,1 @@\n+  _has_inline_type_fields = _layout_info->_has_inline_fields;\n@@ -5822,0 +6343,21 @@\n+\n+  \/\/ Strict static fields track initialization status from the beginning of time.\n+  \/\/ After this class runs <clinit>, they will be verified as being \"not unset\".\n+  \/\/ See Step 8 of InstanceKlass::initialize_impl.\n+  if (_has_strict_static_fields) {\n+    bool found_one = false;\n+    for (int i = 0; i < _temp_field_info->length(); i++) {\n+      FieldInfo& fi = *_temp_field_info->adr_at(i);\n+      if (fi.access_flags().is_strict() && fi.access_flags().is_static()) {\n+        found_one = true;\n+        if (fi.initializer_index() != 0) {\n+          \/\/ skip strict static fields with ConstantValue attributes\n+        } else {\n+          _fields_status->adr_at(fi.index())->update_strict_static_unset(true);\n+          _fields_status->adr_at(fi.index())->update_strict_static_unread(true);\n+        }\n+      }\n+    }\n+    assert(found_one == _has_strict_static_fields,\n+           \"correct prediction = %d\", (int)_has_strict_static_fields);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":659,"deletions":117,"binary":false,"changes":776,"status":"modified"},{"patch":"@@ -808,0 +808,3 @@\n+    \/** The bit mask of {@link AccessFlag#IDENTITY} access and property modifier. *\/\n+    int ACC_IDENTITY = 0x0020;\n+\n@@ -841,0 +844,3 @@\n+    \/** The bit mask of {@link AccessFlag#STRICT_INIT} access and property modifier. *\/\n+    int ACC_STRICT_INIT = 0x0800;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.classfile.ClassFile;\n+\n@@ -398,1 +400,1 @@\n-    ; \/\/ Reduce code churn when appending new constants\n+    \/\/ Reduce code churn when appending new constants\n@@ -403,0 +405,4 @@\n+    \/\/\/ The preview features of Valhalla.\n+    \/\/\/ @since 26\n+    CURRENT_PREVIEW_FEATURES(ClassFile.latestMajorVersion());\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -216,0 +216,13 @@\n+    public static boolean isSupported(Feature feature, int majorVersion) {\n+        Source source = null;\n+        for (Target target : Target.values()) {\n+            if (majorVersion == target.majorVersion) {\n+                source = lookup(target.name);\n+            }\n+        }\n+        if (source != null) {\n+            return feature.allowedInSource(source);\n+        }\n+        return false;\n+    }\n+\n@@ -281,0 +294,1 @@\n+        VALUE_CLASSES(JDK22, Fragments.FeatureValueClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -229,0 +229,6 @@\n+    \/** Does the target VM support value classes\n+     *\/\n+    public boolean hasValueClasses() {\n+        return compareTo(JDK1_23) >= 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -503,6 +503,9 @@\n-                if (enclosingElement != null &&\n-                    enclosingElement.getKind().isInterface()) {\n-                    modifiers.remove(Modifier.PUBLIC);\n-                    modifiers.remove(Modifier.ABSTRACT); \/\/ only for methods\n-                    modifiers.remove(Modifier.STATIC);   \/\/ only for fields\n-                    modifiers.remove(Modifier.FINAL);    \/\/ only for fields\n+                if (enclosingElement != null) {\n+                    if (enclosingElement.getKind().isInterface()) {\n+                        modifiers.remove(Modifier.PUBLIC);\n+                        modifiers.remove(Modifier.ABSTRACT); \/\/ only for methods\n+                        modifiers.remove(Modifier.STATIC);   \/\/ only for fields\n+                        modifiers.remove(Modifier.FINAL);    \/\/ only for fields\n+                    } else if (enclosingElement.getKind() == RECORD) {\n+                        modifiers.remove(Modifier.STRICTFP);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,749 @@\n+\/*\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated from the following class files with PointN.x renamed and RectangleP.p1 made private\n+\/\/ java org.openjdk.asmtools.Main jdec NamedRectangleN.class NamedRectangleP.class PointN.class RectangleN.class RectangleP.class\n+\n+\/*\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+@LooselyConsistentValue\n+value class PointN {\n+    int x; \/\/ Removed\n+    int y;\n+\n+    PointN(int i, int j) {\n+        x = i;\n+        y = j;\n+    }\n+}\n+\n+@LooselyConsistentValue\n+value class RectangleN {\n+    @Strict\n+    @NullRestricted\n+    PointN p1 = new PointN(4, 7);\n+}\n+\n+class NamedRectangleN {\n+    @Strict\n+    @NullRestricted\n+    RectangleN rect = new RectangleN();\n+    String name = \"\";\n+\n+    static int getP1X(NamedRectangleN nr) {\n+        return nr.rect.p1.x;\n+    }\n+}\n+\n+@LooselyConsistentValue\n+value class RectangleP {\n+    @Strict\n+    @NullRestricted\n+    PointN p1 = new PointN(4, 7); \/\/ Made private\n+}\n+\n+class NamedRectangleP {\n+    @Strict\n+    @NullRestricted\n+    RectangleP rect = new RectangleP();\n+    String name = \"\";\n+\n+    static int getP1Y(NamedRectangleP nr) {\n+        return nr.rect.p1.y;\n+    }\n+}\n+\n+*\/\n+\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleN {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #10\n+    Utf8 \"rect\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"\"; \/\/ #14\n+    Field #8 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"name\"; \/\/ #17\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #18\n+    Method #20 #4; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Field #1 #23; \/\/ #22\n+    NameAndType #24 #25; \/\/ #23\n+    Utf8 \"p1\"; \/\/ #24\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #25\n+    Field #27 #28; \/\/ #26\n+    class #29; \/\/ #27\n+    NameAndType #30 #31; \/\/ #28\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #29\n+    Utf8 \"x\"; \/\/ #30\n+    Utf8 \"I\"; \/\/ #31\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #32\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #33\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #34\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #35\n+    Utf8 \"Code\"; \/\/ #36\n+    Utf8 \"LineNumberTable\"; \/\/ #37\n+    Utf8 \"getP1X\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"PointN.java\"; \/\/ #41\n+    Utf8 \"LoadableDescriptors\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0800; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#32) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #33;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#34) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #35;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159B70003;\n+            0xB500072A120DB500;\n+            0x0F2AB70013B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                11  29;\n+                17  25;\n+                21  29;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007B40016B4;\n+            0x001AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  32;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#42) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleP {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #10\n+    Utf8 \"rect\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"\"; \/\/ #14\n+    Field #8 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"name\"; \/\/ #17\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #18\n+    Method #20 #4; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Field #1 #23; \/\/ #22\n+    NameAndType #24 #25; \/\/ #23\n+    Utf8 \"p1\"; \/\/ #24\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #25\n+    Field #27 #28; \/\/ #26\n+    class #29; \/\/ #27\n+    NameAndType #30 #31; \/\/ #28\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #29\n+    Utf8 \"y\"; \/\/ #30\n+    Utf8 \"I\"; \/\/ #31\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #32\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #33\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #34\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #35\n+    Utf8 \"Code\"; \/\/ #36\n+    Utf8 \"LineNumberTable\"; \/\/ #37\n+    Utf8 \"getP1Y\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"PointN.java\"; \/\/ #41\n+    Utf8 \"LoadableDescriptors\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0800; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#32) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #33;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#34) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #35;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159B70003;\n+            0xB500072A120DB500;\n+            0x0F2AB70013B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  44;\n+                11  47;\n+                17  43;\n+                21  47;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007B40016B4;\n+            0x001AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  50;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#42) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleP\n+\n+class compiler\/valhalla\/inlinetypes\/PointN {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #4\n+    Utf8 \"x0\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Field #2 #8; \/\/ #7\n+    NameAndType #9 #6; \/\/ #8\n+    Utf8 \"y\"; \/\/ #9\n+    Method #11 #12; \/\/ #10\n+    class #13; \/\/ #11\n+    NameAndType #14 #15; \/\/ #12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #13\n+    Utf8 \"<init>\"; \/\/ #14\n+    Utf8 \"()V\"; \/\/ #15\n+    Utf8 \"(II)V\"; \/\/ #16\n+    Utf8 \"Code\"; \/\/ #17\n+    Utf8 \"LineNumberTable\"; \/\/ #18\n+    Utf8 \"SourceFile\"; \/\/ #19\n+    Utf8 \"PointN.java\"; \/\/ #20\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #21\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #2;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #9; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #14; \/\/ name_index\n+      #16; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB500012A1CB5;\n+            0x00072AB7000AB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  13;\n+                5  14;\n+                10  12;\n+                14  15;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#19) { \/\/ SourceFile\n+      #20;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#21) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #22;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/PointN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleN {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"(II)V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #10\n+    Utf8 \"p1\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #5 #17; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"()V\"; \/\/ #17\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #18\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #19\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #20\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #21\n+    Utf8 \"Code\"; \/\/ #22\n+    Utf8 \"LineNumberTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"PointN.java\"; \/\/ #25\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #26\n+    Utf8 \"LoadableDescriptors\"; \/\/ #27\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #8;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #19;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#20) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #21;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#22) { \/\/ Code\n+          5; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159071007;\n+            0xB70003B500072AB7;\n+            0x000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#23) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  20;\n+                14  19;\n+                18  20;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #26;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+    ;\n+    Attr(#27) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleP {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"(II)V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #10\n+    Utf8 \"p1\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #5 #17; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"()V\"; \/\/ #17\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #18\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #19\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #20\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #21\n+    Utf8 \"Code\"; \/\/ #22\n+    Utf8 \"LineNumberTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"PointN.java\"; \/\/ #25\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #26\n+    Utf8 \"LoadableDescriptors\"; \/\/ #27\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #8;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0812; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #19;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#20) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #21;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#22) { \/\/ Code\n+          5; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159071007;\n+            0xB70003B500072AB7;\n+            0x000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#23) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  38;\n+                14  37;\n+                18  38;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #26;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+    ;\n+    Attr(#27) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleP\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":749,"deletions":0,"binary":false,"changes":749,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8301007\n+ * @key randomness\n+ * @summary Verify that mismatches of the preload attribute are properly handled in the calling convention.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @compile TestMismatchHandling.jcod TestMismatchHandling.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xbatch\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-Inline -XX:-InlineAccessors -XX:-UseBimorphicInlining -XX:-UseCHA -XX:-UseTypeProfile\n+ *                   -XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.TestMismatchHandling::test*\n+ *                   compiler.valhalla.inlinetypes.TestMismatchHandling\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xbatch\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-Inline -XX:-InlineAccessors -XX:-UseBimorphicInlining -XX:-UseCHA -XX:-UseTypeProfile\n+ *                   -XX:CompileCommand=compileonly,*::method\n+ *                   compiler.valhalla.inlinetypes.TestMismatchHandling\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xbatch\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-Inline -XX:-InlineAccessors -XX:-UseBimorphicInlining -XX:-UseCHA -XX:-UseTypeProfile\n+ *                   compiler.valhalla.inlinetypes.TestMismatchHandling\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xbatch\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-Inline -XX:-InlineAccessors -XX:-UseBimorphicInlining -XX:-UseCHA -XX:-UseTypeProfile\n+ *                   -XX:-InlineTypePassFieldsAsArgs\n+ *                   compiler.valhalla.inlinetypes.TestMismatchHandling\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xbatch\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-Inline -XX:-InlineAccessors -XX:-UseBimorphicInlining -XX:-UseCHA -XX:-UseTypeProfile\n+ *                   -XX:-InlineTypeReturnedAsFields\n+ *                   compiler.valhalla.inlinetypes.TestMismatchHandling\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xbatch\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+DeoptimizeNMethodBarriersALot\n+ *                   compiler.valhalla.inlinetypes.TestMismatchHandling\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xbatch\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.valhalla.inlinetypes.TestMismatchHandling\n+ *\/\n+\n+\/\/ ##################################### WARNING ######################################\n+\/\/ Use below script to re-generate TestMismatchHandling.jcod, don't modify it manually.\n+\/\/ Be careful when changing anything (even the order) in this test and related files.\n+\/\/ ##################################### WARNING ######################################\n+\n+\/*\n+  #!\/bin\/bash\n+  export PATH=\/oracle\/valhalla\/build\/fastdebug\/jdk\/bin\/:$PATH\n+  ASMTOOLS=\/oracle\/valhalla\/open\/test\/lib\n+\n+  # With preload attribute\n+  javac --enable-preview --source 27 TestMismatchHandlingGenerator.java\n+  java -cp $ASMTOOLS org.openjdk.asmtools.Main jdec MyValue1Mismatch.class MyValue2Mismatch.class MyValue3Mismatch.class MyValue4Mismatch.class MyValue5Mismatch.class MyValue6Mismatch.class MyValue7Mismatch.class Verifiable.class B.class I3.class I4.class E.class G.class J.class K.class L.class P.class Q.class R.class S.class TestMismatchHandlingHelper.class > TestMismatchHandling.jcod\n+\n+  # Without preload attribute\n+  sed -i 's\/value class MyValue\/class MyValue\/g' TestMismatchHandlingGenerator.java\n+  javac TestMismatchHandlingGenerator.java\n+  java -cp $ASMTOOLS org.openjdk.asmtools.Main jdec A.class C.class I1.class I2.class D.class F.class H.class I5.class M.class N.class O.class I6.class P.class >> TestMismatchHandling.jcod\n+\n+  sed -i 's\/class MyValue\/value class MyValue\/g' TestMismatchHandlingGenerator.java\n+*\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestMismatchHandling {\n+    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws Exception {\n+        M m = new M();\n+        \/\/ Make sure M::method is C1 compiled once with unloaded MyValue4 and not re-compiled\n+        for (int i = 0; i < 1000; ++i) {\n+            TestMismatchHandlingHelper.test4(m, true);\n+        }\n+        Method disable = M.class.getDeclaredMethod(\"method\", boolean.class);\n+        WHITE_BOX.makeMethodNotCompilable(disable, 1, false);\n+        WHITE_BOX.makeMethodNotCompilable(disable, 2, false);\n+        WHITE_BOX.makeMethodNotCompilable(disable, 3, false);\n+        WHITE_BOX.makeMethodNotCompilable(disable, 4, false);\n+\n+        \/\/ Sometimes, exclude some methods from compilation with C2 to stress test the calling convention\n+        \/\/ WARNING: This triggers class loading of argument\/return types of all methods!\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            ArrayList<Method> methods = new ArrayList<Method>();\n+            Collections.addAll(methods, TestMismatchHandlingHelper.class.getDeclaredMethods());\n+            Collections.addAll(methods, A.class.getDeclaredMethods());\n+            Collections.addAll(methods, B.class.getDeclaredMethods());\n+            Collections.addAll(methods, C.class.getDeclaredMethods());\n+            Collections.addAll(methods, E.class.getDeclaredMethods());\n+            Collections.addAll(methods, F.class.getDeclaredMethods());\n+            Collections.addAll(methods, G.class.getDeclaredMethods());\n+            Collections.addAll(methods, H.class.getDeclaredMethods());\n+            Collections.addAll(methods, J.class.getDeclaredMethods());\n+            Collections.addAll(methods, K.class.getDeclaredMethods());\n+            Collections.addAll(methods, L.class.getDeclaredMethods());\n+            \/\/ Don't do this because it would load MyValue5\n+            \/\/ Collections.addAll(methods, N.class.getDeclaredMethods());\n+            System.out.println(\"Excluding methods from C2 compilation:\");\n+            for (Method method : methods) {\n+                if (Utils.getRandomInstance().nextBoolean()) {\n+                    System.out.println(method);\n+                    WHITE_BOX.makeMethodNotCompilable(method, 4, false);\n+                }\n+            }\n+        }\n+\n+        A a = new A();\n+        B b = new B();\n+        C c = new C();\n+        D d = new D();\n+        E e = new E();\n+        H h = new H();\n+        J j = new J();\n+        K k = new K();\n+        N n = new N();\n+        O o = new O();\n+        P p = new P();\n+        Q q = new Q();\n+        R r = new R();\n+\n+        \/\/ Warmup\n+        for (int i = 0; i < 50_000; ++i) {\n+            TestMismatchHandlingHelper.test1(a, a, a, b, c, b, b, c);\n+            TestMismatchHandlingHelper.test1(b, a, a, b, c, b, b, c);\n+            TestMismatchHandlingHelper.test1(c, b, a, b, c, c, b, c);\n+            TestMismatchHandlingHelper.test2(d, d, d, d, d, d,  d, d, d, d, d, d,  e, e, e, e, e, e,  e, e, e, e, e, e,  d, e);\n+            TestMismatchHandlingHelper.test2(d, d, d, d, d, d,  d, d, d, d, d, d,  e, e, e, e, e, e,  e, e, e, e, e, e,  d, e);\n+            TestMismatchHandlingHelper.test3(h, h, h,  j, k, j, k, j,  h, k);\n+            TestMismatchHandlingHelper.test3(h, h, h,  j, k, j, k, k,  h, k);\n+            TestMismatchHandlingHelper.test4(m, true);\n+            TestMismatchHandlingHelper.test5(n, true);\n+            TestMismatchHandlingHelper.test7(o, true);\n+            TestMismatchHandlingHelper.test8(p, p, p,  q, r, q, r, q,  p, r);\n+            TestMismatchHandlingHelper.test8(p, p, p,  q, r, q, r, r,  p, r);\n+        }\n+\n+        \/\/ Only load these now\n+        F f = new F();\n+        G g = new G();\n+        L l = new L();\n+        S s = new S();\n+\n+        for (int i = 0; i < 50_000; ++i) {\n+            TestMismatchHandlingHelper.test1(a, a, a, b, c, b, b, c);\n+            TestMismatchHandlingHelper.test1(b, a, a, b, c, b, b, c);\n+            TestMismatchHandlingHelper.test1(c, b, a, b, c, c, b, c);\n+            TestMismatchHandlingHelper.test2(d, f, g, d, f, d,  d, f, g, d, f, d,  e, f, g, e, f, g,  e, f, g, e, f, g,  d, e);\n+            TestMismatchHandlingHelper.test2(d, f, g, d, f, f,  d, f, g, d, f, f,  e, f, g, e, f, f,  e, f, g, e, f, f,  d, e);\n+            TestMismatchHandlingHelper.test2(d, f, g, f, g, g,  d, f, g, f, g, g,  e, f, g, f, g, g,  e, f, g, f, g, g,  d, e);\n+            TestMismatchHandlingHelper.test3(h, l, h,  j, k, j, k, j,  h, k);\n+            TestMismatchHandlingHelper.test3(h, l, h,  j, k, k, k, k,  h, k);\n+            TestMismatchHandlingHelper.test3(h, l, l,  j, k, k, l, l,  h, l);\n+            TestMismatchHandlingHelper.test4(m, false);\n+            TestMismatchHandlingHelper.test5(n, false);\n+            TestMismatchHandlingHelper.test6(f, g, l);\n+            TestMismatchHandlingHelper.test7TriggerCalleeCompilation(o);\n+            TestMismatchHandlingHelper.test8(p, s, p,  q, r, q, r, q,  p, r);\n+            TestMismatchHandlingHelper.test8(p, s, p,  q, r, r, r, r,  p, r);\n+            TestMismatchHandlingHelper.test8(p, s, s,  q, r, r, s, s,  p, s);\n+        }\n+        TestMismatchHandlingHelper.test7(o, false).verify();\n+\n+        switch (Utils.getRandomInstance().nextInt() % 3) {\n+        case 0:\n+            TestMismatchHandlingHelper.test2(d, d, d, d, d, d,  d, d, d, d, d, d,  e, e, e, e, e, e,  e, e, e, e, e, e,  d, e);\n+            TestMismatchHandlingHelper.test3(l, h, l,  k, l, l, j, j,  h, l);\n+            TestMismatchHandlingHelper.test8(s, p, s,  r, s, s, q, q,  p, s);\n+            break;\n+        case 1:\n+            TestMismatchHandlingHelper.test2(f, f, f, f, f, f,  f, f, f, f, f, f,  f, f, f, f, f, f,  f, f, f, f, f, f,  d, e);\n+            TestMismatchHandlingHelper.test3(l, h, l,  l, j, j, k, l,  h, l);\n+            TestMismatchHandlingHelper.test8(s, p, s,  s, q, q, r, s,  p, s);\n+            break;\n+        case 2:\n+            TestMismatchHandlingHelper.test2(g, g, g, g, g, g,  g, g, g, g, g, g,  g, g, g, g, g, g,  g, g, g, g, g, g,  d, e);\n+            TestMismatchHandlingHelper.test3(l, h, l,  j, k, k, l, j,  h, l);\n+            TestMismatchHandlingHelper.test8(s, p, s,  q, r, r, s, q,  p, s);\n+            break;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMismatchHandling.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,3704 @@\n+class compiler\/valhalla\/inlinetypes\/MyValue1Mismatch {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue1Mismatch\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Utf8 \"ConstantValue\"; \/\/ #13\n+    int 0x0000002A; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #1;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ ConstantValue\n+          #14;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A102AB500032AB7;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  27;\n+                6  26;\n+                10  27;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  33;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue1Mismatch\n+class compiler\/valhalla\/inlinetypes\/MyValue2Mismatch {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue2Mismatch\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Utf8 \"ConstantValue\"; \/\/ #13\n+    int 0x0000002A; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #1;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ ConstantValue\n+          #14;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A102AB500032AB7;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  37;\n+                6  36;\n+                10  37;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  43;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue2Mismatch\n+class compiler\/valhalla\/inlinetypes\/MyValue3Mismatch {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue3Mismatch\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Utf8 \"ConstantValue\"; \/\/ #13\n+    int 0x0000002A; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #1;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ ConstantValue\n+          #14;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A102AB500032AB7;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  47;\n+                6  46;\n+                10  47;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  53;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue3Mismatch\n+class compiler\/valhalla\/inlinetypes\/MyValue4Mismatch {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue4Mismatch\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Method #1 #9; \/\/ #13\n+    Utf8 \"ConstantValue\"; \/\/ #14\n+    int 0x0000002A; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"verify\"; \/\/ #18\n+    Utf8 \"make\"; \/\/ #19\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/MyValue4Mismatch;\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #1;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ ConstantValue\n+          #15;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A102AB500032AB7;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  57;\n+                6  56;\n+                10  57;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  63;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #19; \/\/ name_index\n+      #20; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000159B7000DB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  66;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue4Mismatch\n+class compiler\/valhalla\/inlinetypes\/MyValue5Mismatch {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue5Mismatch\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Method #1 #9; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Verifiable\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x0000002A; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"verify\"; \/\/ #20\n+    Utf8 \"make\"; \/\/ #21\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/MyValue5Mismatch;\"; \/\/ #22\n+    Utf8 \"SourceFile\"; \/\/ #23\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #24\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #1;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A102AB500032AB7;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  75;\n+                6  74;\n+                10  75;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  82;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #21; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000159B7000DB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  85;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#23) { \/\/ SourceFile\n+      #24;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue5Mismatch\n+class compiler\/valhalla\/inlinetypes\/MyValue6Mismatch {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue6Mismatch\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Method #1 #9; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Verifiable\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x0000002A; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"verify\"; \/\/ #20\n+    Utf8 \"make\"; \/\/ #21\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/MyValue6Mismatch;\"; \/\/ #22\n+    Utf8 \"SourceFile\"; \/\/ #23\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #24\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #1;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A102AB500032AB7;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  90;\n+                6  89;\n+                10  90;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  97;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #21; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000159B7000DB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  100;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#23) { \/\/ SourceFile\n+      #24;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue6Mismatch\n+class compiler\/valhalla\/inlinetypes\/MyValue7Mismatch {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Utf8 \"ConstantValue\"; \/\/ #13\n+    int 0x0000002A; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"verify\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #1;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#13) { \/\/ ConstantValue\n+          #14;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A102AB500032AB7;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  105;\n+                6  104;\n+                10  105;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  111;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\n+class compiler\/valhalla\/inlinetypes\/Verifiable {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Verifiable\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"verify\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/Verifiable\n+class compiler\/valhalla\/inlinetypes\/B {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/A\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue1Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/B\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"LoadableDescriptors\"; \/\/ #20\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  121;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  124;\n+                4  125;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ LoadableDescriptors\n+      0x00010015;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/B\n+class compiler\/valhalla\/inlinetypes\/I3 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I3\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+    Utf8 \"LoadableDescriptors\"; \/\/ #9\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#9) { \/\/ LoadableDescriptors\n+      0x0001000A;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/I3\n+class compiler\/valhalla\/inlinetypes\/I4 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I4\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I3\"; \/\/ #6\n+    Utf8 \"method\"; \/\/ #7\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+    Utf8 \"LoadableDescriptors\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/I4\n+class compiler\/valhalla\/inlinetypes\/E {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue2Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/E\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I4\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"LoadableDescriptors\"; \/\/ #22\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  162;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  165;\n+                4  166;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ LoadableDescriptors\n+      0x00010017;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/E\n+class compiler\/valhalla\/inlinetypes\/G {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue2Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/G\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I2\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I4\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"method\"; \/\/ #20\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #21\n+    Utf8 \"SourceFile\"; \/\/ #22\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #23\n+    Utf8 \"LoadableDescriptors\"; \/\/ #24\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+    #16;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  179;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #21; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  182;\n+                4  183;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#22) { \/\/ SourceFile\n+      #23;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#24) { \/\/ LoadableDescriptors\n+      0x00010019;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/G\n+class compiler\/valhalla\/inlinetypes\/J {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue3Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/J\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"LoadableDescriptors\"; \/\/ #20\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  199;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  201;\n+                4  202;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ LoadableDescriptors\n+      0x00010015;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/J\n+class compiler\/valhalla\/inlinetypes\/K {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/J\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue3Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/K\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"LoadableDescriptors\"; \/\/ #20\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  206;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  209;\n+                4  210;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ LoadableDescriptors\n+      0x00010015;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/K\n+class compiler\/valhalla\/inlinetypes\/L {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/K\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue3Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/L\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I5\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"LoadableDescriptors\"; \/\/ #22\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  214;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  217;\n+                4  218;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ LoadableDescriptors\n+      0x00010017;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/L\n+class compiler\/valhalla\/inlinetypes\/P {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/P\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"LoadableDescriptors\"; \/\/ #22\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  265;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  268;\n+                4  269;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ LoadableDescriptors\n+      0x00010017;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/P\n+class compiler\/valhalla\/inlinetypes\/Q {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Q\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"LoadableDescriptors\"; \/\/ #20\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  273;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  275;\n+                4  276;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ LoadableDescriptors\n+      0x00010015;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/Q\n+class compiler\/valhalla\/inlinetypes\/R {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Q\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/R\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+    Utf8 \"LoadableDescriptors\"; \/\/ #20\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  280;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  283;\n+                4  284;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#20) { \/\/ LoadableDescriptors\n+      0x00010015;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/R\n+class compiler\/valhalla\/inlinetypes\/S {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/R\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/S\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+    Utf8 \"LoadableDescriptors\"; \/\/ #22\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  288;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  291;\n+                4  292;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#22) { \/\/ LoadableDescriptors\n+      0x00010017;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/S\n+class compiler\/valhalla\/inlinetypes\/TestMismatchHandlingHelper {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue1Mismatch\"; \/\/ #8\n+    Method #7 #3; \/\/ #9\n+    Method #11 #12; \/\/ #10\n+    class #13; \/\/ #11\n+    NameAndType #14 #15; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/A\"; \/\/ #13\n+    Utf8 \"method\"; \/\/ #14\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;\"; \/\/ #15\n+    Method #7 #17; \/\/ #16\n+    NameAndType #18 #6; \/\/ #17\n+    Utf8 \"verify\"; \/\/ #18\n+    Method #20 #12; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/B\"; \/\/ #21\n+    Method #23 #12; \/\/ #22\n+    class #24; \/\/ #23\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/C\"; \/\/ #24\n+    class #26; \/\/ #25\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue2Mismatch\"; \/\/ #26\n+    Method #25 #3; \/\/ #27\n+    InterfaceMethod #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #14 #32; \/\/ #30\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I1\"; \/\/ #31\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #32\n+    Method #25 #17; \/\/ #33\n+    InterfaceMethod #35 #30; \/\/ #34\n+    class #36; \/\/ #35\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I2\"; \/\/ #36\n+    Method #38 #30; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/D\"; \/\/ #39\n+    InterfaceMethod #41 #30; \/\/ #40\n+    class #42; \/\/ #41\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I3\"; \/\/ #42\n+    InterfaceMethod #44 #30; \/\/ #43\n+    class #45; \/\/ #44\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I4\"; \/\/ #45\n+    Method #47 #30; \/\/ #46\n+    class #48; \/\/ #47\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/E\"; \/\/ #48\n+    class #50; \/\/ #49\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue3Mismatch\"; \/\/ #50\n+    Method #49 #3; \/\/ #51\n+    InterfaceMethod #53 #54; \/\/ #52\n+    class #55; \/\/ #53\n+    NameAndType #14 #56; \/\/ #54\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I5\"; \/\/ #55\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #56\n+    Method #49 #17; \/\/ #57\n+    Method #59 #54; \/\/ #58\n+    class #60; \/\/ #59\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/H\"; \/\/ #60\n+    Method #62 #54; \/\/ #61\n+    class #63; \/\/ #62\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/J\"; \/\/ #63\n+    Method #65 #54; \/\/ #64\n+    class #66; \/\/ #65\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/K\"; \/\/ #66\n+    Method #68 #69; \/\/ #67\n+    class #70; \/\/ #68\n+    NameAndType #14 #71; \/\/ #69\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/M\"; \/\/ #70\n+    Utf8 \"(Z)Lcompiler\/valhalla\/inlinetypes\/MyValue4Mismatch;\"; \/\/ #71\n+    Method #73 #74; \/\/ #72\n+    class #75; \/\/ #73\n+    NameAndType #76 #77; \/\/ #74\n+    Utf8 \"java\/util\/Objects\"; \/\/ #75\n+    Utf8 \"requireNonNull\"; \/\/ #76\n+    Utf8 \"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\"; \/\/ #77\n+    class #79; \/\/ #78\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #79\n+    String #81; \/\/ #80\n+    Utf8 \"Verification failed\"; \/\/ #81\n+    Method #78 #83; \/\/ #82\n+    NameAndType #5 #84; \/\/ #83\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #84\n+    Method #86 #87; \/\/ #85\n+    class #88; \/\/ #86\n+    NameAndType #14 #89; \/\/ #87\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/N\"; \/\/ #88\n+    Utf8 \"(Z)Lcompiler\/valhalla\/inlinetypes\/MyValue5Mismatch;\"; \/\/ #89\n+    InterfaceMethod #91 #17; \/\/ #90\n+    class #92; \/\/ #91\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Verifiable\"; \/\/ #92\n+    Method #94 #30; \/\/ #93\n+    class #95; \/\/ #94\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/F\"; \/\/ #95\n+    Method #97 #30; \/\/ #96\n+    class #98; \/\/ #97\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/G\"; \/\/ #98\n+    Method #100 #54; \/\/ #99\n+    class #101; \/\/ #100\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/L\"; \/\/ #101\n+    Method #103 #104; \/\/ #102\n+    class #105; \/\/ #103\n+    NameAndType #14 #106; \/\/ #104\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/O\"; \/\/ #105\n+    Utf8 \"(Z)Lcompiler\/valhalla\/inlinetypes\/MyValue6Mismatch;\"; \/\/ #106\n+    Method #108 #17; \/\/ #107\n+    class #109; \/\/ #108\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue6Mismatch\"; \/\/ #109\n+    class #111; \/\/ #110\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\"; \/\/ #111\n+    Method #110 #3; \/\/ #112\n+    InterfaceMethod #114 #115; \/\/ #113\n+    class #116; \/\/ #114\n+    NameAndType #14 #117; \/\/ #115\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I6\"; \/\/ #116\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #117\n+    Method #110 #17; \/\/ #118\n+    Method #120 #115; \/\/ #119\n+    class #121; \/\/ #120\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/P\"; \/\/ #121\n+    Method #123 #115; \/\/ #122\n+    class #124; \/\/ #123\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/Q\"; \/\/ #124\n+    Method #126 #115; \/\/ #125\n+    class #127; \/\/ #126\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/R\"; \/\/ #127\n+    class #129; \/\/ #128\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/TestMismatchHandlingHelper\"; \/\/ #129\n+    Utf8 \"Code\"; \/\/ #130\n+    Utf8 \"LineNumberTable\"; \/\/ #131\n+    Utf8 \"test1\"; \/\/ #132\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/A;Lcompiler\/valhalla\/inlinetypes\/A;Lcompiler\/valhalla\/inlinetypes\/A;Lcompiler\/valhalla\/inlinetypes\/A;Lcompiler\/valhalla\/inlinetypes\/A;Lcompiler\/valhalla\/inlinetypes\/B;Lcompiler\/valhalla\/inlinetypes\/B;Lcompiler\/valhalla\/inlinetypes\/C;)V\"; \/\/ #133\n+    Utf8 \"test2\"; \/\/ #134\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/I1;Lcompiler\/valhalla\/inlinetypes\/I1;Lcompiler\/valhalla\/inlinetypes\/I1;Lcompiler\/valhalla\/inlinetypes\/I1;Lcompiler\/valhalla\/inlinetypes\/I1;Lcompiler\/valhalla\/inlinetypes\/I1;Lcompiler\/valhalla\/inlinetypes\/I2;Lcompiler\/valhalla\/inlinetypes\/I2;Lcompiler\/valhalla\/inlinetypes\/I2;Lcompiler\/valhalla\/inlinetypes\/I2;Lcompiler\/valhalla\/inlinetypes\/I2;Lcompiler\/valhalla\/inlinetypes\/I2;Lcompiler\/valhalla\/inlinetypes\/I3;Lcompiler\/valhalla\/inlinetypes\/I3;Lcompiler\/valhalla\/inlinetypes\/I3;Lcompiler\/valhalla\/inlinetypes\/I3;Lcompiler\/valhalla\/inlinetypes\/I3;Lcompiler\/valhalla\/inlinetypes\/I3;Lcompiler\/valhalla\/inlinetypes\/I4;Lcompiler\/valhalla\/inlinetypes\/I4;Lcompiler\/valhalla\/inlinetypes\/I4;Lcompiler\/valhalla\/inlinetypes\/I4;Lcompiler\/valhalla\/inlinetypes\/I4;Lcompiler\/valhalla\/inlinetypes\/I4;Lcompiler\/valhalla\/inlinetypes\/D;Lcompiler\/valhalla\/inlinetypes\/E;)V\"; \/\/ #135\n+    Utf8 \"test3\"; \/\/ #136\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/I5;Lcompiler\/valhalla\/inlinetypes\/I5;Lcompiler\/valhalla\/inlinetypes\/I5;Lcompiler\/valhalla\/inlinetypes\/J;Lcompiler\/valhalla\/inlinetypes\/J;Lcompiler\/valhalla\/inlinetypes\/J;Lcompiler\/valhalla\/inlinetypes\/J;Lcompiler\/valhalla\/inlinetypes\/J;Lcompiler\/valhalla\/inlinetypes\/H;Lcompiler\/valhalla\/inlinetypes\/K;)V\"; \/\/ #137\n+    Utf8 \"test4\"; \/\/ #138\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/M;Z)V\"; \/\/ #139\n+    Utf8 \"StackMapTable\"; \/\/ #140\n+    Utf8 \"test5\"; \/\/ #141\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/N;Z)V\"; \/\/ #142\n+    Utf8 \"test6\"; \/\/ #143\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/F;Lcompiler\/valhalla\/inlinetypes\/G;Lcompiler\/valhalla\/inlinetypes\/L;)V\"; \/\/ #144\n+    Utf8 \"test7\"; \/\/ #145\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/O;Z)Lcompiler\/valhalla\/inlinetypes\/Verifiable;\"; \/\/ #146\n+    Utf8 \"test7TriggerCalleeCompilation\"; \/\/ #147\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/O;)V\"; \/\/ #148\n+    Utf8 \"test8\"; \/\/ #149\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/I6;Lcompiler\/valhalla\/inlinetypes\/I6;Lcompiler\/valhalla\/inlinetypes\/I6;Lcompiler\/valhalla\/inlinetypes\/Q;Lcompiler\/valhalla\/inlinetypes\/Q;Lcompiler\/valhalla\/inlinetypes\/Q;Lcompiler\/valhalla\/inlinetypes\/Q;Lcompiler\/valhalla\/inlinetypes\/Q;Lcompiler\/valhalla\/inlinetypes\/P;Lcompiler\/valhalla\/inlinetypes\/R;)V\"; \/\/ #150\n+    Utf8 \"SourceFile\"; \/\/ #151\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #152\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #128;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  296;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #132; \/\/ name_index\n+      #133; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          8; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000759B70009;\n+            0xB6000AB600102BBB;\n+            0x000759B70009B600;\n+            0x0AB600102CBB0007;\n+            0x59B70009B6000AB6;\n+            0x00102DBB000759B7;\n+            0x0009B6000AB60010;\n+            0x1904BB000759B700;\n+            0x09B6000AB6001019;\n+            0x05BB000759B70009;\n+            0xB60013B600101906;\n+            0xBB000759B70009B6;\n+            0x0013B600101907BB;\n+            0x000759B70009B600;\n+            0x16B60010B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  302;\n+                14  303;\n+                28  304;\n+                42  305;\n+                56  306;\n+                71  308;\n+                86  309;\n+                101  310;\n+                116  311;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #134; \/\/ name_index\n+      #135; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          26; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x2BBB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x2CBB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x2DBB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x1904BB001959B700;\n+            0x1BB9001C0200B600;\n+            0x211905BB001959B7;\n+            0x001BB9001C0200B6;\n+            0x00211906BB001959;\n+            0xB7001BB900220200;\n+            0xB600211907BB0019;\n+            0x59B7001BB9002202;\n+            0x00B600211908BB00;\n+            0x1959B7001BB90022;\n+            0x0200B600211909BB;\n+            0x001959B7001BB900;\n+            0x220200B60021190A;\n+            0xBB001959B7001BB9;\n+            0x00220200B6002119;\n+            0x0BBB001959B7001B;\n+            0xB900220200B60021;\n+            0x1918BB001959B700;\n+            0x1BB60025B6002119;\n+            0x0CBB001959B7001B;\n+            0xB900280200B60021;\n+            0x190DBB001959B700;\n+            0x1BB900280200B600;\n+            0x21190EBB001959B7;\n+            0x001BB900280200B6;\n+            0x0021190FBB001959;\n+            0xB7001BB900280200;\n+            0xB600211910BB0019;\n+            0x59B7001BB9002802;\n+            0x00B600211911BB00;\n+            0x1959B7001BB90028;\n+            0x0200B600211912BB;\n+            0x001959B7001BB900;\n+            0x2B0200B600211913;\n+            0xBB001959B7001BB9;\n+            0x002B0200B6002119;\n+            0x14BB001959B7001B;\n+            0xB9002B0200B60021;\n+            0x1915BB001959B700;\n+            0x1BB9002B0200B600;\n+            0x211916BB001959B7;\n+            0x001BB9002B0200B6;\n+            0x00211917BB001959;\n+            0xB7001BB9002B0200;\n+            0xB600211919BB0019;\n+            0x59B7001BB6002EB6;\n+            0x0021B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  320;\n+                16  321;\n+                32  322;\n+                48  323;\n+                64  324;\n+                81  325;\n+                98  326;\n+                115  327;\n+                132  328;\n+                149  329;\n+                166  330;\n+                183  331;\n+                200  332;\n+                215  334;\n+                232  335;\n+                249  336;\n+                266  337;\n+                283  338;\n+                300  339;\n+                317  340;\n+                334  341;\n+                351  342;\n+                368  343;\n+                385  344;\n+                402  345;\n+                419  346;\n+                434  347;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #136; \/\/ name_index\n+      #137; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          10; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB003159B70033;\n+            0xB900340200B60039;\n+            0x2BBB003159B70033;\n+            0xB900340200B60039;\n+            0x2CBB003159B70033;\n+            0xB900340200B60039;\n+            0x1908BB003159B700;\n+            0x33B6003AB600392D;\n+            0xBB003159B70033B6;\n+            0x003DB600391904BB;\n+            0x003159B70033B600;\n+            0x3DB600391905BB00;\n+            0x3159B70033B6003D;\n+            0xB600391906BB0031;\n+            0x59B70033B6003DB6;\n+            0x00391907BB003159;\n+            0xB70033B6003DB600;\n+            0x391909BB003159B7;\n+            0x0033B60040B60039;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  355;\n+                16  356;\n+                32  357;\n+                48  358;\n+                63  360;\n+                77  361;\n+                92  362;\n+                107  363;\n+                122  364;\n+                137  365;\n+                152  366;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #138; \/\/ name_index\n+      #139; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000C2A1BB600;\n+            0x4357A7001D2A1BB6;\n+            0x0043B8004857102A;\n+            0x102A9F000DBB004E;\n+            0x591250B70052BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  371;\n+                4  372;\n+                13  374;\n+                29  375;\n+                39  378;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#140) { \/\/ StackMapTable\n+              [] { \/\/ \n+                13b; \/\/ same_frame\n+                25b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #141; \/\/ name_index\n+      #142; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB600554D1B9A;\n+            0x00092CB9005A0100;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  383;\n+                6  384;\n+                10  385;\n+                16  387;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#140) { \/\/ StackMapTable\n+              [] { \/\/ \n+                252b, 16, []z{O,91}; \/\/ append_frame 1\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #143; \/\/ name_index\n+      #144; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB001959B7001B;\n+            0xB6005D572BBB0019;\n+            0x59B7001BB6006057;\n+            0x2CBB003159B70033;\n+            0xB6006357B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  391;\n+                12  392;\n+                24  393;\n+                36  394;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #145; \/\/ name_index\n+      #146; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB60066B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  399;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #147; \/\/ name_index\n+      #148; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A04B60066572A03;\n+            0xB60066B6006BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  403;\n+                6  404;\n+                14  405;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #149; \/\/ name_index\n+      #150; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          10; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB006E59B70070;\n+            0xB900710200B60076;\n+            0x2BBB006E59B70070;\n+            0xB900710200B60076;\n+            0x2CBB006E59B70070;\n+            0xB900710200B60076;\n+            0x1908BB006E59B700;\n+            0x70B60077B600762D;\n+            0xBB006E59B70070B6;\n+            0x007AB600761904BB;\n+            0x006E59B70070B600;\n+            0x7AB600761905BB00;\n+            0x6E59B70070B6007A;\n+            0xB600761906BB006E;\n+            0x59B70070B6007AB6;\n+            0x00761907BB006E59;\n+            0xB70070B6007AB600;\n+            0x761909BB006E59B7;\n+            0x0070B6007DB60076;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  414;\n+                16  415;\n+                32  416;\n+                48  417;\n+                63  419;\n+                77  420;\n+                92  421;\n+                107  422;\n+                122  423;\n+                137  424;\n+                152  425;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#151) { \/\/ SourceFile\n+      #152;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/TestMismatchHandlingHelper\n+class compiler\/valhalla\/inlinetypes\/A {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue1Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/A\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  114;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  116;\n+                4  117;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/A\n+class compiler\/valhalla\/inlinetypes\/C {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/B\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue1Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/C\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue1Mismatch;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  129;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  132;\n+                4  133;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/C\n+class compiler\/valhalla\/inlinetypes\/I1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I1\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/I1\n+class compiler\/valhalla\/inlinetypes\/I2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I2\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I1\"; \/\/ #6\n+    Utf8 \"method\"; \/\/ #7\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/I2\n+class compiler\/valhalla\/inlinetypes\/D {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue2Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/D\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I2\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  154;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  157;\n+                4  158;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/D\n+class compiler\/valhalla\/inlinetypes\/F {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue2Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/F\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I2\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I4\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"method\"; \/\/ #20\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue2Mismatch;\"; \/\/ #21\n+    Utf8 \"SourceFile\"; \/\/ #22\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+    #16;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  171;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #21; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  174;\n+                4  175;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#22) { \/\/ SourceFile\n+      #23;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/F\n+class compiler\/valhalla\/inlinetypes\/H {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue3Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/H\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I5\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  191;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  194;\n+                4  195;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/H\n+class compiler\/valhalla\/inlinetypes\/I5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I5\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue3Mismatch;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/I5\n+class compiler\/valhalla\/inlinetypes\/M {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/M\"; \/\/ #10\n+    Utf8 \"val\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #17 #18; \/\/ #15\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue4Mismatch\"; \/\/ #16\n+    Utf8 \"make\"; \/\/ #17\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/MyValue4Mismatch;\"; \/\/ #18\n+    Utf8 \"Code\"; \/\/ #19\n+    Utf8 \"LineNumberTable\"; \/\/ #20\n+    Utf8 \"method\"; \/\/ #21\n+    Utf8 \"(Z)Lcompiler\/valhalla\/inlinetypes\/MyValue4Mismatch;\"; \/\/ #22\n+    Utf8 \"StackMapTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A03B500;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  222;\n+                4  223;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #21; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          3; \/\/ max_stack\n+          4; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x0D4D033E1D100AA2;\n+            0x00132A59B4000704;\n+            0x60B50007840301A7;\n+            0xFFED2CB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  226;\n+                4  227;\n+                6  229;\n+                10  231;\n+                18  232;\n+                28  231;\n+                34  234;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+                253b, 5, []z{O,14; I}; \/\/ append_frame 2\n+                250b, 21; \/\/ chop_frame 1\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/M\n+class compiler\/valhalla\/inlinetypes\/N {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue5Mismatch\"; \/\/ #10\n+    Utf8 \"make\"; \/\/ #11\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/MyValue5Mismatch;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/N\"; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"method\"; \/\/ #17\n+    Utf8 \"(Z)Lcompiler\/valhalla\/inlinetypes\/MyValue5Mismatch;\"; \/\/ #18\n+    Utf8 \"StackMapTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  239;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x07B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  241;\n+                4  242;\n+                6  244;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#19) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/N\n+class compiler\/valhalla\/inlinetypes\/O {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue6Mismatch\"; \/\/ #10\n+    Utf8 \"make\"; \/\/ #11\n+    Utf8 \"()Lcompiler\/valhalla\/inlinetypes\/MyValue6Mismatch;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/O\"; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"method\"; \/\/ #17\n+    Utf8 \"(Z)Lcompiler\/valhalla\/inlinetypes\/MyValue6Mismatch;\"; \/\/ #18\n+    Utf8 \"StackMapTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  249;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x07B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  251;\n+                4  252;\n+                6  254;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#19) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/O\n+class compiler\/valhalla\/inlinetypes\/I6 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I6\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x01B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  261;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/I6\n+class compiler\/valhalla\/inlinetypes\/P {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue7Mismatch\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/P\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;)Lcompiler\/valhalla\/inlinetypes\/MyValue7Mismatch;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  265;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  268;\n+                4  269;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/P\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMismatchHandling.jcod","additions":3704,"deletions":0,"binary":false,"changes":3704,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-  70; \/\/ version\n+  71; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/InnerClassesAttr\/OuterTest1.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  70; \/\/ version\n+  71; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/InnerClassesAttr\/OuterTest2.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Test arguments to JVM_InvokeMethod not flattened into an args array.\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 DirectMethodTest.java\n+ * @run main\/othervm -Djdk.reflect.useNativeAccessorOnly=true -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.DirectMethodTest\n+ *\/\n+\n+\/*\n+ * @test id=no-array-flattening\n+ * @summary Test arguments to JVM_InvokeMethod not flattened into an args array.\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 DirectMethodTest.java\n+ * @run main\/othervm -Djdk.reflect.useNativeAccessorOnly=true -XX:-UseArrayFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.DirectMethodTest\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import jdk.internal.value.ValueClass;\n+\n+public class DirectMethodTest {\n+\n+    public int method1(int i, int j, int k) {\n+        System.out.println(\"i = \" + i + \" j = \" + j + \" k = \" + k);\n+        return i + j * k;\n+    }\n+\n+    public static void printFlat(Object[] array) {\n+        if (!ValueClass.isFlatArray(array)) {\n+            System.out.println(\"not flat \" + array);\n+        } else {\n+            System.out.println(\"yay flat \" + array);\n+        }\n+    }\n+\n+    static value class SmallValue {\n+        byte b;\n+        short s;\n+\n+        SmallValue(short i) { b = 0; s = i; }\n+    }\n+\n+    public int method2(SmallValue i, SmallValue j, SmallValue k) {\n+        System.out.println(\"i = \" + i + \" j = \" + j + \" k = \" + k);\n+        return i.s + j.s * k.s;\n+    }\n+\n+    static final int ARRAY_SIZE = 3;\n+\n+    public static void main(java.lang.String[] unused) throws Exception {\n+        DirectMethodTest d = new DirectMethodTest();\n+\n+        Method m = DirectMethodTest.class.getMethod(\"method1\", int.class, int.class, int.class);\n+        Integer[] intarray = new Integer[]{1, 2, 3};  \/\/ is this flattened?\n+        printFlat(intarray);\n+        Object[] array = (Object[])Array.newInstance(Integer.class, 3);\n+        printFlat(array);\n+        array = ValueClass.newNullableAtomicArray(Integer.class, ARRAY_SIZE);\n+        printFlat(array);\n+        System.out.println(\"value is \" + m.invoke(d, 1, 2, 3));\n+\n+        Method m2 = DirectMethodTest.class.getMethod(\"method2\", SmallValue.class, SmallValue.class, SmallValue.class);\n+        Object[] smallValueArray = (Object[])Array.newInstance(SmallValue.class, ARRAY_SIZE);\n+        printFlat(smallValueArray);\n+        smallValueArray = ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+        printFlat(smallValueArray);\n+        System.out.println(\"value is \" + m2.invoke(d, new SmallValue((short)1), new SmallValue((short)2), new SmallValue((short)3)));\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/DirectMethodTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,568 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test id=default\n+ * @summary Plain array test for Inline Types\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 FlatArraysTest.java\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ *\/\n+\n+\/*\n+ * @test id=no-array-flattening\n+ * @summary Plain array test for Inline Types\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 FlatArraysTest.java\n+ * @run main\/othervm -XX:-UseArrayFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ *\/\n+\n+public class FlatArraysTest {\n+  static final int ARRAY_SIZE = 100;\n+  static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+  @LooselyConsistentValue\n+  static value class SmallValue {\n+      byte b;\n+      short s;\n+\n+      SmallValue() { b = 0 ;  s = 0; }\n+      SmallValue(byte b0, short s0) { b = b0; s = s0; }\n+\n+      public static Object getTestValue() { return new SmallValue(Byte.MIN_VALUE, Short.MIN_VALUE); }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return true; }\n+      public static boolean expectingFlatNullableAtomicArray() { return true; }\n+  }\n+\n+  @LooselyConsistentValue\n+  static value class MediumValue {\n+      int x;\n+      int y;\n+\n+      MediumValue() {\n+         x = 0;\n+         y = 0;\n+      }\n+      MediumValue(int x0, int y0) {\n+        x = x0;\n+        y = y0;\n+      }\n+\n+      public static Object getTestValue() {\n+        return new MediumValue(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+      }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return true; }\n+      public static boolean expectingFlatNullableAtomicArray() { return false; }\n+  }\n+\n+  @LooselyConsistentValue\n+  static value class BigValue {\n+      long x;\n+      long y;\n+      long z;\n+\n+      BigValue() {\n+        x = 0;\n+        y = 0;\n+        z = 0;\n+      }\n+      BigValue(long x0, long y0, long z0) {\n+        x = x0;\n+        y = y0;\n+        z = z0;\n+      }\n+\n+      public static Object getTestValue() {\n+        return new BigValue(Long.MIN_VALUE, Long.MIN_VALUE, Long.MIN_VALUE);\n+      }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return false; }\n+      public static boolean expectingFlatNullableAtomicArray() { return false; }\n+  }\n+\n+  static void testNullFreeArray(Object[] array, Object value) {\n+    testErrorCases(array);\n+    assertNotNull(value, \"Test needs a not null value\");\n+    \/\/   Test 1 : check initial element value is not null\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNotNull(array[i], \"Initial value must not be null\");\n+    }\n+    \/\/   Test 2 : try to write null\n+    for (int i = 0 ; i < array.length; i++) {\n+      try {\n+        array[i] = null;\n+        throw new RuntimeException(\"Missing NullPointerException\");\n+      } catch (NullPointerException e) { }\n+    }\n+    \/\/   Test 3 : overwrite initial value with new value\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = value;\n+    }\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertEquals(array[i], value);\n+    }\n+  }\n+\n+  static void testNullableArray(Object[] array, Object value) {\n+    testErrorCases(array);\n+    assertNotNull(value, \"Test needs a not null value\");\n+    \/\/   Test 1 : check that initial element value is null\n+    System.gc();\n+    System.out.println(\"Test 1\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNull(array[i], \"Initial value should be null\");\n+    }\n+    \/\/   Test 2 : write new value to all elements\n+    System.gc();\n+    System.out.println(\"Test 2a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = value;\n+      assertEquals(array[i], value, \"Value mismatch\");\n+    }\n+    System.gc();\n+    System.out.println(\"Test 2b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertEquals(array[i], value, \"Value mismatch\");\n+    }\n+    \/\/   Test 3 : write null to all elements\n+    System.gc();\n+    System.out.println(\"Test 3a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = null;\n+    }\n+    System.gc();\n+    System.out.println(\"Test 3b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNull(array[i], \"Value mismatch\");\n+    }\n+    \/\/   Test 4 : write alternate null \/ not null values\n+    System.gc();\n+    System.out.println(\"Test 4a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      if (i%2 == 0) {\n+        array[i] = null;\n+      } else {\n+        array[i] = value;\n+      }\n+    }\n+    System.gc();\n+    System.out.println(\"Test 4b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      if (i%2 == 0) {\n+        assertNull(array[i], \"Value mismatch\");\n+      } else {\n+        assertEquals(array[i], value, \"Value mismatch\");\n+      }\n+    }\n+  }\n+\n+  static void testErrorCases(Object[] array) {\n+    try {\n+      Object o = array[-1];\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+\n+    try {\n+      Object o = array[array.length];\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+\n+    assertTrue(array.getClass().getComponentType() != String.class, \"Must be for the test\");\n+    assertTrue(array.length > 0, \"Must be for the test\");\n+    try {\n+      array[0] = new String(\"Bad\");\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+  }\n+\n+  static void testArrayCopy() {\n+\n+    Object[] objArray = new Object[ARRAY_SIZE];\n+    for (int i = 0; i < ARRAY_SIZE; i++) {\n+      objArray[i] = SmallValue.getTestValue();\n+    }\n+    SmallValue[] nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    SmallValue[] atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    SmallValue[] nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    \/\/ obj -> non-atomic\n+    testArrayCopyInternal(objArray, nonAtomicArray);\n+\n+    \/\/ obj -> atomic\n+    testArrayCopyInternal(objArray, atomicArray);\n+\n+    \/\/ obj -> nullable\n+    testArrayCopyInternal(objArray, nullableArray);\n+\n+    objArray[45] = null;\n+    \/\/ obj with null -> non-atomic   => NPE\n+    try {\n+      testArrayCopyInternal(objArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ obj with null -> atomic       => NPE\n+    try {\n+      testArrayCopyInternal(objArray, atomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ obj with null -> nullable\n+    try {\n+      testArrayCopyInternal(objArray, nullableArray);\n+    } catch (NullPointerException e) {\n+      throw new RuntimeException(\"Unexpected NullPointerException\");\n+    }\n+\n+    objArray[45] = new String(\"bad\");\n+    \/\/ obj with wrong type value -> non-atomic   => ASE\n+    try {\n+      testArrayCopyInternal(objArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ obj with wrong type value -> atomic       => ASE\n+    try {\n+      testArrayCopyInternal(objArray, atomicArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ obj with wrong type value -> nullable     => ASE\n+    try {\n+      testArrayCopyInternal(objArray, nullableArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    \/\/ non-atomic -> obj\n+    testArrayCopyInternal(nonAtomicArray, objArray);\n+\n+    \/\/ non-atomic -> non-atomic\n+    SmallValue[] nonAtomicArray2 = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    testArrayCopyInternal(nonAtomicArray, nonAtomicArray2);\n+\n+    \/\/ non-atomic -> non-atomic same array\n+    testArrayCopyInternal(nonAtomicArray, nonAtomicArray);\n+\n+    \/\/ non-atomic -> atomic\n+    testArrayCopyInternal(nonAtomicArray, atomicArray);\n+\n+    \/\/ non-atomic -> nullable\n+    testArrayCopyInternal(nonAtomicArray, nullableArray);\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    for (int i = 0 ; i < ARRAY_SIZE; i++) {\n+      atomicArray[i] = (SmallValue)SmallValue.getTestValue();\n+    }\n+\n+    \/\/ atomic -> obj\n+    testArrayCopyInternal(atomicArray, objArray);\n+\n+    \/\/ atomic -> non-atomic\n+    testArrayCopyInternal(atomicArray, nonAtomicArray);\n+\n+    \/\/ atomic -> atomic\n+    SmallValue[] atomicArray2 = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    testArrayCopyInternal(atomicArray, atomicArray2);\n+\n+    \/\/ atomic -> atomic same array\n+    testArrayCopyInternal(atomicArray, atomicArray);\n+\n+    \/\/ atomic -> nullable\n+    testArrayCopyInternal(atomicArray, nullableArray);\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    for (int i = 0 ; i < ARRAY_SIZE; i++) {\n+      nullableArray[i] = (SmallValue)SmallValue.getTestValue();\n+    }\n+\n+    \/\/ nullable -> obj\n+    testArrayCopyInternal(nullableArray, objArray);\n+\n+    \/\/ nullable -> non-atomic\n+    testArrayCopyInternal(nullableArray, nonAtomicArray);\n+\n+    \/\/ nullable -> atomic\n+    testArrayCopyInternal(nullableArray, atomicArray);\n+\n+    \/\/ nullable -> nullable\n+    SmallValue[] nullableArray2 = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(nullableArray, nullableArray2);\n+\n+    \/\/ nullable -> nullable same array\n+    testArrayCopyInternal(nullableArray, nullableArray);\n+\n+    nullableArray[45] = null;\n+\n+    \/\/ nullable with null -> obj\n+    testArrayCopyInternal(nullableArray, objArray);\n+\n+    \/\/ nullable with null -> non-atomic  => NPE\n+    try {\n+      testArrayCopyInternal(nullableArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ nullable with null -> atomic      => NPE\n+    try {\n+      testArrayCopyInternal(nullableArray, atomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ nullable with null -> nullable\n+    nullableArray2 = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(nullableArray, nullableArray2);\n+\n+    \/\/ nullable with null -> nullable same array\n+    testArrayCopyInternal(nullableArray, nullableArray);\n+  }\n+\n+  static void testArrayCopyInternal(Object[] src, Object[] dst) {\n+    \/\/ When using this method for cases that should trigger a NPE or an ASE,\n+    \/\/ it is recommended to put the faulty value at index 45 in the src array\n+    assertTrue(src.length >= ARRAY_SIZE, \"Must be for the test\");\n+    assertTrue(dst.length >= ARRAY_SIZE, \"Must be for the test\");\n+    \/\/ Test 1 : good copy without indexes overlap\n+    System.arraycopy(src, 3, dst, 51, 40);\n+    for (int i = 0; i < 40; i++) {\n+      assertEquals(src[3+i], dst[51+i], \"Mismatch after copying\");\n+    }\n+    \/\/ Test 2 : good copy with indexes overlap\n+    System.arraycopy(src, 42, dst, 53, 45);\n+    if (src != dst) {  \/\/ Verification doesn't make sense if src and dst are the same\n+      for (int i = 0; i < 45; i++) {\n+        assertEquals(src[42+i], dst[53+i], \"Mismatch after copying\");\n+      }\n+    }\n+    \/\/ Test 3 : IOOB errors\n+    try {\n+      System.arraycopy(src, -1, dst, 3, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, src.length - 5, dst, 3, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, 10, dst, -1, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, 10, dst, dst.length - 5, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+  }\n+\n+  static void testArrayAccesses() throws NoSuchMethodException, InstantiationException,\n+  IllegalAccessException, InvocationTargetException {\n+    RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n+    List<String> arguments = runtimeMxBean.getInputArguments();\n+    boolean UseArrayFlattening = !arguments.contains(\"-XX:-UseArrayFlattening\");\n+    System.out.println(\"UseArrayFlattening: \" + UseArrayFlattening);\n+    Class[] valueClasses = {SmallValue.class, MediumValue.class, BigValue.class};\n+    for (Class c: valueClasses) {\n+      System.out.println(\"Testing class \" + c.getName());\n+      Method gtv = c.getMethod(\"getTestValue\", null);\n+      Object o = gtv.invoke(null, null);\n+      assertNotNull(o);\n+\n+      System.out.println(\"Regular reference array\");\n+      Object[] array = (Object[])Array.newInstance(c, ARRAY_SIZE);\n+      Method ef = c.getMethod(\"expectingFlatNullableAtomicArray\", null);\n+      boolean expectFlat = (Boolean) ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullableArray(array, o);\n+\n+      System.out.println(\"NonAtomic NullRestricted array\");\n+      array = ValueClass.newNullRestrictedNonAtomicArray(c, ARRAY_SIZE, c.newInstance());\n+      ef = c.getMethod(\"expectingFlatNullRestrictedArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullFreeArray(array, o);\n+\n+      System.out.println(\"NullRestricted Atomic array\");\n+      array = ValueClass.newNullRestrictedAtomicArray(c, ARRAY_SIZE, c.newInstance());\n+      ef = c.getMethod(\"expectingFlatNullRestrictedAtomicArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullFreeArray(array, o);\n+\n+      System.out.println(\"Nullable Atomic array\");\n+      array = ValueClass.newNullableAtomicArray(c, ARRAY_SIZE);\n+      ef = c.getMethod(\"expectingFlatNullableAtomicArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullableArray(array, o);\n+    }\n+  }\n+\n+  static value class AtomicValue {\n+    int i = 0;\n+  }\n+\n+  static value class FieldsHolder {\n+    @NullRestricted\n+    SmallValue sv = new SmallValue();\n+\n+    @NullRestricted\n+    AtomicValue av = new AtomicValue();\n+\n+    AtomicValue nav = new AtomicValue();\n+  }\n+\n+  static void testSpecialArrayLayoutFromArray(Object[] array, boolean expectException) {\n+    int lk = UNSAFE.arrayLayout(array);\n+    boolean exception = false;\n+    try {\n+      Object[] newArray = UNSAFE.newSpecialArray(array.getClass().getComponentType(), 10, lk);\n+      int newLk = UNSAFE.arrayLayout(newArray);\n+      assertEquals(newLk, lk);\n+    } catch(IllegalArgumentException e) {\n+      e.printStackTrace();\n+      exception = true;\n+    }\n+    assertEquals(exception, expectException, \"Exception not matching expectations\");\n+  }\n+\n+  static void testSpecialArrayFromFieldLayout(Class c, int layout, boolean expectException) {\n+    boolean exception = false;\n+    try {\n+      Object[] array = UNSAFE.newSpecialArray(c, 10, layout);\n+      int lk = UNSAFE.arrayLayout(array);\n+      assertEquals(lk, layout);\n+    } catch (IllegalArgumentException e) {\n+      e.printStackTrace();\n+      throw new RuntimeException(e);\n+    } catch (UnsupportedOperationException e) {\n+      e.printStackTrace();\n+      exception = true;\n+    }\n+    assertEquals(exception, expectException, \"Exception not matching expectations\");\n+  }\n+\n+  static void testSpecialArrayCreation() {\n+    RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n+    List<String> jvmArgs = runtimeMXBean.getInputArguments();\n+    boolean arrayFlatteningEnabled = true;\n+    for (String s : jvmArgs) {\n+      if (s.compareTo(\"-XX:-UseArrayFlattening\") == 0) arrayFlatteningEnabled = false;\n+    }\n+\n+    \/\/ Test array creation from another array\n+    Object[] array0 = new SmallValue[10];\n+    testSpecialArrayLayoutFromArray(array0, !arrayFlatteningEnabled);\n+    if (arrayFlatteningEnabled) {\n+      Object[] array1 = ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, 10, new SmallValue());\n+      testSpecialArrayLayoutFromArray(array1, false);\n+      Object[] array2 = ValueClass.newNullRestrictedAtomicArray(SmallValue.class, 10, new SmallValue());\n+      testSpecialArrayLayoutFromArray(array2, false);\n+      Object[] array3 = ValueClass.newNullableAtomicArray(SmallValue.class, 10);\n+      testSpecialArrayLayoutFromArray(array3, false);\n+    }\n+\n+    \/\/ Test array creation from a field layout\n+    try {\n+      Class c = FieldsHolder.class;\n+      Field f0 = c.getDeclaredField(\"sv\");\n+      int layout0 = UNSAFE.fieldLayout(f0);\n+      testSpecialArrayFromFieldLayout(f0.getType(), layout0, !arrayFlatteningEnabled);\n+      Field f1 = c.getDeclaredField(\"av\");\n+      int layout1 = UNSAFE.fieldLayout(f1);\n+      testSpecialArrayFromFieldLayout(f1.getType(), layout1, !arrayFlatteningEnabled);\n+      Field f2 = c.getDeclaredField(\"nav\");\n+      int layout2 = UNSAFE.fieldLayout(f2);\n+      testSpecialArrayFromFieldLayout(f2.getType(), layout2, !arrayFlatteningEnabled);\n+    } catch(NoSuchFieldException e) {\n+      e.printStackTrace();\n+    }\n+\n+    \/\/ Testing an invalid layout value\n+    boolean exception = false;\n+    try {\n+      UNSAFE.newSpecialArray(SmallValue.class, 10, 100);\n+    } catch(IllegalArgumentException e) {\n+      e.printStackTrace();\n+      exception = true;\n+    }\n+    assertEquals(exception, true, \"Exception not received\");\n+  }\n+\n+  public static void main(String[] args) throws NoSuchMethodException, InstantiationException,\n+                                                IllegalAccessException, InvocationTargetException {\n+    testArrayAccesses();\n+    testArrayCopy();\n+    testSpecialArrayCreation();\n+  }\n+\n+ }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":568,"deletions":0,"binary":false,"changes":568,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package runtime.valhalla.inlinetypes;\n+\n+import java.lang.ref.*;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+\n+\/*\n+ * @test Ifacmp\n+ * @requires vm.gc == null\n+ * @summary if_acmpeq\/ne bytecode test\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile --source 27 Ifacmp.java\n+ * @run main\/othervm -Xms16m -Xmx16m -XX:+UseSerialGC runtime.valhalla.inlinetypes.Ifacmp\n+ *\/\n+public class Ifacmp {\n+\n+    @LooselyConsistentValue\n+    static value class MyValue {\n+        int value;\n+        public MyValue(int v) { this.value = v; }\n+    };\n+\n+    @LooselyConsistentValue\n+    static value class MyValue2 {\n+        int value;\n+        public MyValue2(int v) { this.value = v; }\n+    };\n+\n+    boolean acmpModeInlineAlwaysFalse = false;\n+\n+    Object aNull = null;\n+    Object bNull = null;\n+\n+    Object aObject = new String(\"Hi\");\n+    Object bObject = new String(\"Hi\");\n+\n+    Object aValue = new MyValue(1);\n+    Object bValue = new MyValue(1);\n+    Object cValue = new MyValue(0);\n+    Object aValue2 = new MyValue2(4711);\n+\n+    Object[][] equalUseCases = {\n+        { aNull, bNull },\n+        { aObject, aObject },\n+        { aValue, bValue },\n+        { cValue, cValue },\n+        { aValue2, aValue2 }\n+    };\n+\n+    int objectEqualsUseCases = 2; \/\/ Nof object equals use cases\n+\n+    \/\/ Would just generate these fail case from the \"equal set\" above,\n+    \/\/ but to do so needs ==, so write out by hand it is...\n+    Object[][] notEqualUseCases = {\n+        { aNull, aObject },\n+        { aNull, bObject },\n+        { aNull, aValue },\n+        { aNull, bValue },\n+        { aNull, cValue },\n+        { aNull, aValue2 },\n+        { aObject, bObject },\n+        { aObject, aValue },\n+        { aObject, bValue },\n+        { aObject, cValue },\n+        { aObject, aValue2 },\n+        { bObject, cValue },\n+        { bObject, aValue2 },\n+        { aValue, cValue },\n+        { aValue, aValue2 },\n+    };\n+\n+    public Ifacmp() { this(false); }\n+    public Ifacmp(boolean acmpModeInlineAlwaysFalse) {\n+        this.acmpModeInlineAlwaysFalse = acmpModeInlineAlwaysFalse;\n+        if (acmpModeInlineAlwaysFalse) {\n+            System.out.println(\"ifacmp always false for inline types\");\n+        } else {\n+            System.out.println(\"ifacmp substitutability inline types\");\n+        }\n+    }\n+\n+    public void test() {\n+        testAllUseCases();\n+    }\n+\n+    public void testUntilGc(int nofGc) {\n+        for (int i = 0; i < nofGc; i++) {\n+            System.out.println(\"GC num \" + (i + 1));\n+            testUntilGc();\n+        }\n+    }\n+\n+    public void testUntilGc() {\n+        Reference ref = new WeakReference<Object>(new Object(), new ReferenceQueue<>());\n+        do {\n+            test();\n+        } while (ref.get() != null);\n+    }\n+\n+    public void testAllUseCases() {\n+        int useCase = 0;\n+        for (Object[] pair : equalUseCases) {\n+            useCase++;\n+            boolean equal = acmpModeInlineAlwaysFalse ? (useCase <= objectEqualsUseCases) : true;\n+            checkEqual(pair[0], pair[1], equal);\n+        }\n+        for (Object[] pair : notEqualUseCases) {\n+            checkEqual(pair[0], pair[1], false);\n+        }\n+        testLocalValues();\n+        testAlot();\n+    }\n+\n+    public void testValues() {\n+        checkEqual(aValue, bValue, true);\n+\n+        checkEqual(aValue, cValue, false);\n+        checkEqual(aValue, aValue2, false);\n+        checkEqual(aValue2, bValue, false);\n+        checkEqual(aValue2, cValue, false);\n+        testLocalValues();\n+    }\n+\n+    public void testLocalValues() {\n+        \/\/ \"aload + ifacmp\" should be same as \"aaload + ifamcp\"\n+        \/\/ but let's be paranoid...\n+        MyValue a = new MyValue(11);\n+        MyValue b = new MyValue(11);\n+        MyValue c = a;\n+        MyValue a1 = new MyValue(7);\n+        MyValue2 a2 = new MyValue2(13);\n+\n+        if (acmpModeInlineAlwaysFalse) {\n+            if (a == b) throw new RuntimeException(\"Always false fail \" + a + \" == \" + b);\n+            if (a == c) throw new RuntimeException(\"Always false fail \" + a + \" == \" + c);\n+        } else {\n+            if (a != b) throw new RuntimeException(\"Substitutability test failed\" + a + \" != \" + b);\n+            if (a != c) throw new RuntimeException(\"Substitutability test failed\");\n+        }\n+        if (a == a1) throw new RuntimeException();\n+        checkEqual(a, a2, false);\n+    }\n+\n+    public void testAlot() {\n+        MyValue a = new MyValue(4711);\n+        Reference ref = new WeakReference<Object>(new Object(), new ReferenceQueue<>());\n+        do {\n+            for (int i = 0; i < 1000; i++) {\n+                MyValue b = new MyValue(4711);\n+                if (acmpModeInlineAlwaysFalse) {\n+                    if (a == b) throw new RuntimeException(\"Always false fail \" + a + \" == \" + b);\n+                } else {\n+                    if (a != b) throw new RuntimeException(\"Substitutability test failed\" + a + \" != \" + b);\n+                }\n+            }\n+            System.gc();\n+        } while (ref.get() != null);\n+    }\n+\n+    boolean shouldEqualSelf(Object a) {\n+        return acmpModeInlineAlwaysFalse ? (!(a != null && a.getClass().isValue())) : true;\n+    }\n+\n+    void checkEqual(Object a, Object b, boolean isEqual) {\n+        testEquals(a, a, shouldEqualSelf(a));\n+        testEquals(b, b, shouldEqualSelf(b));\n+        testEquals(a, b, isEqual);\n+        testNotEquals(a, b, !isEqual);\n+    }\n+\n+    public static void testEquals(Object a, Object b, boolean expected) {\n+        boolean isEqual = (a == b);\n+        if (isEqual != expected) {\n+            throw new RuntimeException(\"Expected \" + expected + \" : \"\n+                                       + a + \" == \" + b);\n+        }\n+    }\n+\n+    public static void testNotEquals(Object a, Object b, boolean expected) {\n+        boolean isNotEqual = (a != b);\n+        if (isNotEqual != expected) {\n+            throw new RuntimeException(\"Expected \" + expected + \" : \"\n+                                       + a + \" != \" + b);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean inlineTypesAlwaysFalse = (args.length > 0) && args[0].equals(\"alwaysFalse\");\n+        new Ifacmp(inlineTypesAlwaysFalse).test();\n+        new Ifacmp(inlineTypesAlwaysFalse).testUntilGc(3);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Ifacmp.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,899 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test id=default\n+ * @summary Plain array test for Inline Types\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 InlineTypeArray.java Point.java Long8Inline.java Person.java\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening runtime.valhalla.inlinetypes.InlineTypeArray\n+ *\/\n+\n+\/*\n+ * @test id=no-array-flattening\n+ * @summary Plain array test for Inline Types\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 InlineTypeArray.java Point.java Long8Inline.java Person.java\n+ * @run main\/othervm -XX:-UseArrayFlattening runtime.valhalla.inlinetypes.InlineTypeArray\n+ *\/\n+\n+\/*\n+ * @test id=no-tearable\n+ * @summary Plain array test for Inline Types\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 InlineTypeArray.java Point.java Long8Inline.java Person.java\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.InlineTypeArray\n+ *\/\n+\n+\/*\n+ * @test id=nullable-value-flattening\n+ * @summary Plain array test for Inline Types\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 27 InlineTypeArray.java Point.java Long8Inline.java Person.java\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.InlineTypeArray\n+ *\/\n+public class InlineTypeArray {\n+    public static void main(String[] args) {\n+        InlineTypeArray inlineTypeArray = new InlineTypeArray();\n+        inlineTypeArray.run();\n+    }\n+\n+    public void run() {\n+        testClassForName();\n+        testSimplePointArray();\n+        testLong8Array();\n+        testMixedPersonArray();\n+        testMultiDimPointArray();\n+        testComposition();\n+\n+        testSanityCheckcasts();\n+        testObjectArrayOfInlines();\n+\n+        testReflectArray();\n+        testUtilArraysOnNullRestrictedNonAtomicArrays();\n+        testUtilArraysOnNullRestrictedAtomicArrays();\n+        testUtilArraysOnNullableAtomicArrays();\n+\n+        testInlineArrayOom();\n+    }\n+\n+    void testClassForName() {\n+        String arrayClsName = \"[Lruntime.valhalla.inlinetypes.Point;\";\n+        try {\n+            Class<?> arrayCls = Class.forName(arrayClsName);\n+            assertTrue(arrayCls.isArray(), \"Expected an array class\");\n+\n+            arrayClsName = \"[\" + arrayClsName;\n+            Class<?> mulArrayCls = Class.forName(arrayClsName);\n+            assertTrue(mulArrayCls.isArray());\n+            assertTrue(mulArrayCls.getComponentType() == arrayCls);\n+        }\n+        catch (ClassNotFoundException cnfe) {\n+            fail(\"Class.forName(\" + arrayClsName + \") failed\", cnfe);\n+        }\n+    }\n+\n+    void testSimplePointArray() {\n+        Point[] defaultPoint = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, 1, new Point(0, 0));\n+        Point p = defaultPoint[0];\n+        assertEquals(p.x, 0, \"invalid default loaded from array\");\n+        assertEquals(p.y, 0, \"invalid default loaded from array\");\n+        boolean gotNpe = false;\n+        try {\n+            defaultPoint[0] = (Point) getNull();\n+        } catch (NullPointerException npe) {\n+            gotNpe = true;\n+        }\n+        assertTrue(gotNpe, \"Expected NullPointerException\");\n+\n+        Point[] points = createSimplePointArray();\n+        System.gc(); \/\/ check that VTs survive GC\n+        checkSimplePointArray(points);\n+        assertTrue(points instanceof Point[], \"Instance of\");\n+\n+        testSimplePointArrayCopy();\n+\n+        \/\/ Locked\/unlocked flat array type checks\n+        points = createSimplePointArray();\n+        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, points.length, new Point(0, 0));\n+        synchronized (points) {\n+            assertTrue(points instanceof Point[], \"Instance of\");\n+            checkSimplePointArray(points);\n+            System.arraycopy(points, 0, pointsCopy, 0, points.length);\n+            synchronized (pointsCopy) {\n+                assertTrue(pointsCopy instanceof Point[], \"Instance of\");\n+                checkSimplePointArray(pointsCopy);\n+                System.gc();\n+            }\n+            System.gc();\n+        }\n+        assertTrue(pointsCopy instanceof Point[], \"Instance of\");\n+        checkSimplePointArray(pointsCopy);\n+    }\n+\n+    void testSimplePointArrayCopy() {\n+        Point[] points = createSimplePointArray();\n+        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, points.length, new Point(0, 0));\n+        System.arraycopy(points, 0, pointsCopy, 0, points.length);\n+        checkSimplePointArray(pointsCopy);\n+\n+        \/\/ Conjoint, overlap...left\n+        System.arraycopy(points, 0, points, 1, 2);\n+        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[0], pointsCopy[1], pointsCopy[3] });\n+\n+        \/\/ Conjoint, overlap...right\n+        points = createSimplePointArray();\n+        System.arraycopy(points, 2, points, 1, 2);\n+        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[2], pointsCopy[3], pointsCopy[3] });\n+    }\n+\n+    static Point[] createSimplePointArray() {\n+        Point[] ps = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, 4, new Point(0, 0));\n+        assertEquals(ps.length, 4, \"Length\");\n+        ps.toString();\n+        ps[0] = new Point(1, 2);\n+        ps[1] = new Point(3, 4);\n+        ps[2] = new Point(5, 6);\n+        ps[3] = new Point(7, 8);\n+        boolean sawOob = false;\n+        try {\n+            ps[ps.length] = new Point(0, 0);\n+        } catch (ArrayIndexOutOfBoundsException aioobe) { sawOob = true; }\n+        assertTrue(sawOob, \"Didn't see AIOOBE\");\n+        return ps;\n+    }\n+\n+    static void checkSimplePointArray(Point[] points) {\n+        assertEquals(points[0].x, 1, \"invalid 0 point x value\");\n+        assertEquals(points[0].y, 2, \"invalid 0 point y value\");\n+        assertEquals(points[1].x, 3, \"invalid 1 point x value\");\n+        assertEquals(points[1].y, 4, \"invalid 1 point y value\");\n+        assertEquals(points[2].x, 5, \"invalid 2 point x value\");\n+        assertEquals(points[2].y, 6, \"invalid 2 point y value\");\n+        assertEquals(points[3].x, 7, \"invalid 3 point x value\");\n+        assertEquals(points[3].y, 8, \"invalid 3 point y value\");\n+    }\n+\n+    void testLong8Array() {\n+        Long8Inline[] values = (Long8Inline[])ValueClass.newNullRestrictedNonAtomicArray(Long8Inline.class, 3, new Long8Inline());\n+        assertEquals(values.length, 3, \"length\");\n+        values.toString();\n+        Long8Inline value = values[1];\n+        long zl = 0;\n+        Long8Inline.check(value, zl, zl, zl, zl, zl, zl, zl, zl);\n+        values[1] = new Long8Inline(1, 2, 3, 4, 5, 6, 7, 8);\n+        value = values[1];\n+        Long8Inline.check(value, 1, 2, 3, 4, 5, 6, 7, 8);\n+\n+        Long8Inline[] copy = (Long8Inline[])ValueClass.newNullRestrictedNonAtomicArray(Long8Inline.class, values.length, new Long8Inline());\n+        System.arraycopy(values, 0, copy, 0, values.length);\n+        value = copy[1];\n+        Long8Inline.check(value, 1, 2, 3, 4, 5, 6, 7, 8);\n+    }\n+\n+    void testMixedPersonArray() {\n+        Person[] people = (Person[])ValueClass.newNullRestrictedNonAtomicArray(Person.class, 3, new Person(0, null, null));\n+\n+        people[0] = new Person(1, \"First\", \"Last\");\n+        assertEquals(people[0].getId(), 1, \"Invalid Id person\");\n+        assertEquals(people[0].getFirstName(), \"First\", \"Invalid First Name\");\n+        assertEquals(people[0].getLastName(), \"Last\", \"Invalid Last Name\");\n+\n+        people[1] = new Person(2, \"Jane\", \"Wayne\");\n+        people[2] = new Person(3, \"Bob\", \"Dobalina\");\n+\n+        Person[] peopleCopy = (Person[])ValueClass.newNullRestrictedNonAtomicArray(Person.class, people.length, new Person(0, null, null));\n+        System.arraycopy(people, 0, peopleCopy, 0, people.length);\n+        assertEquals(peopleCopy[2].getId(), 3, \"Invalid Id\");\n+        assertEquals(peopleCopy[2].getFirstName(), \"Bob\", \"Invalid First Name\");\n+        assertEquals(peopleCopy[2].getLastName(), \"Dobalina\", \"Invalid Last Name\");\n+    }\n+\n+    void testMultiDimPointArray() {\n+        \/*\n+        Point[][][] multiPoints = new Point[2][3][4];\n+        assertEquals(multiPoints.length, 2, \"1st dim length\");\n+        assertEquals(multiPoints[0].length, 3, \"2st dim length\");\n+        assertEquals(multiPoints[0][0].length, 4, \"3rd dim length\");\n+\n+        Point defaultPoint = multiPoints[1][2][3];\n+        assertEquals(defaultPoint.x, 0, \"invalid point x value\");\n+        assertEquals(defaultPoint.y, 0, \"invalid point x value\");\n+        *\/\n+    }\n+\n+    void testReflectArray() {\n+        \/\/ Check the java.lang.reflect.Array.newInstance methods...\n+        Class<?> cls = (Class<?>) Point[].class;\n+        Point[][] array = (Point[][]) Array.newInstance(cls, 1);\n+        assertEquals(array.length, 1, \"Incorrect length\");\n+        assertTrue(array[0] == null, \"Expected NULL\");\n+\n+        Point[][][] array3 = (Point[][][]) Array.newInstance(cls, 1, 2);\n+        assertEquals(array3.length, 1, \"Incorrect length\");\n+        assertEquals(array3[0].length, 2, \"Incorrect length\");\n+        assertTrue(array3[0][0] == null, \"Expected NULL\");\n+\n+        \/\/ Now create ObjArrays of InlineArray...\n+        Point[][] barray = (Point[][]) Array.newInstance(Point.class, 1, 2);\n+        assertEquals(barray.length, 1, \"Incorrect length\");\n+        assertEquals(barray[0].length, 2, \"Incorrect length\");\n+        barray[0][1] = new Point(1, 2);\n+        Point pb = barray[0][1];\n+        int x = pb.getX();\n+        assertEquals(x, 1, \"Bad Point Value\");\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyInt implements Comparable<MyInt> {\n+        int value;\n+\n+        private MyInt() { this(0); }\n+        private MyInt(int v) { value = v; }\n+        public int getValue() { return value; }\n+        public String toString() { return \"MyInt: \" + getValue(); }\n+        public int compareTo(MyInt that) { return Integer.compare(this.getValue(), that.getValue()); }\n+        public boolean equals(Object o) {\n+            if (o instanceof MyInt) {\n+                return this.getValue() == ((MyInt) o).getValue();\n+            }\n+            return false;\n+        }\n+\n+        public static MyInt create(int v) {\n+            return new MyInt(v);\n+        }\n+\n+        public static final MyInt MIN = MyInt.create(Integer.MIN_VALUE);\n+        public static final MyInt ZERO = MyInt.create(0);\n+        public static final MyInt MAX = MyInt.create(Integer.MAX_VALUE);\n+    }\n+\n+    static MyInt staticMyInt;\n+    static MyInt[] staticMyIntArray;\n+    static MyInt[][] staticMyIntArrayArray;\n+\n+    static {\n+        staticMyInt = MyInt.create(-1);\n+        staticMyIntArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 1, new MyInt());\n+        staticMyIntArray[0] = staticMyInt;\n+        staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };\n+    }\n+\n+    static value class MyShorts implements Comparable<MyShorts> {\n+        short s0, s1;\n+\n+        private MyShorts() { this((short)0, (short)0); }\n+        private MyShorts(short sa, short sb) { s0 = sa; s1 = sb; }\n+        public short getS0() { return s0; }\n+        public short getS1() { return s1; }\n+        public String toString() { return \"MyShorts: \" + getS0() + \" \" + getS1(); }\n+        public int compareTo(MyShorts that) {\n+            int r = Short.compare(this.getS0(), that.getS0());\n+            return r != 0 ? r : Short.compare(this.getS1(), that.getS1());\n+        }\n+        public boolean equals(Object o) {\n+            if (o instanceof MyShorts) {\n+                return this.getS0() == ((MyShorts) o).getS0() && this.getS1() == ((MyShorts) o).getS1();\n+            }\n+            return false;\n+        }\n+\n+        public static MyShorts create(short s0, short s1) {\n+            return new MyShorts(s0, s1);\n+        }\n+\n+        public static final MyShorts MIN = MyShorts.create(Short.MIN_VALUE, Short.MIN_VALUE);\n+        public static final MyShorts ZERO = MyShorts.create((short)0, (short)0);\n+        public static final MyShorts MAX = MyShorts.create(Short.MAX_VALUE, Short.MAX_VALUE);\n+    }\n+\n+    static interface SomeSecondaryType {\n+        default String hi() { return \"Hi\"; }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyOtherInt implements SomeSecondaryType {\n+        final int value;\n+        private MyOtherInt() { value = 0; }\n+    }\n+\n+    void testSanityCheckcasts() {\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 1, new MyInt());\n+        assertTrue(myInts instanceof Object[]);\n+        assertTrue(myInts instanceof Comparable[]);\n+        assertTrue(myInts instanceof MyInt[]);\n+\n+        Class<?> cls = MyInt.class;\n+        assertTrue(cls.isValue());\n+        Object arrObj = Array.newInstance(cls, 1);\n+        assertTrue(arrObj instanceof Object[], \"Not Object array\");\n+        assertTrue(arrObj instanceof Comparable[], \"Not Comparable array\");\n+        assertTrue(arrObj instanceof MyInt[], \"Not MyInt array\");\n+\n+        Object[] arr = (Object[]) arrObj;\n+        assertTrue(arr instanceof Comparable[], \"Not Comparable array\");\n+        assertTrue(arr instanceof MyInt[], \"Not MyInt array\");\n+        Comparable[] comparables = (Comparable[])arr;\n+        MyInt[] myIntArr = (MyInt[]) arr;\n+\n+        \/\/ multi-dim, check secondary array types are setup...\n+        MyOtherInt[][] matrix = new MyOtherInt[1][1];\n+        assertTrue(matrix[0] instanceof MyOtherInt[]);\n+        assertTrue(matrix[0] instanceof SomeSecondaryType[]);\n+        assertTrue(matrix[0] instanceof MyOtherInt[]);\n+\n+        \/\/ Box types vs Inline...\n+        MyInt[] myValueRefs = new MyInt[1];\n+        assertTrue(myValueRefs instanceof MyInt[]);\n+        assertTrue(myValueRefs instanceof Object[]);\n+        assertTrue(myValueRefs instanceof Comparable[]);\n+\n+        MyInt[][] myMdValueRefs = new MyInt[1][1];\n+        assertTrue(myMdValueRefs[0] instanceof MyInt[]);\n+        assertTrue(myMdValueRefs[0] instanceof Object[]);\n+        assertTrue(myMdValueRefs[0] instanceof Comparable[]);\n+\n+        \/\/ Did we break checkcast...\n+        MyInt[]     va1 = (MyInt[])null;\n+        MyInt[]     va2 = null;\n+        MyInt[][]   va3 = (MyInt[][])null;\n+        MyInt[][][] va4 = (MyInt[][][])null;\n+    }\n+\n+\n+    void testUtilArraysOnNullRestrictedNonAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        myInts[0] = MyInt.MAX;\n+        myInts[1] = MyInt.MIN;\n+        myInts[2] = MyInt.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length);\n+        MyInt[] expected = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        expected[0] = myInts[0];\n+        expected[1] = myInts[1];\n+        expected[2] = myInts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyInt[] smallCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length - 1);\n+        MyInt[] expected2 = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 2, new MyInt());\n+        expected2[0] = myInts[0];\n+        expected2[1] = myInts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+                \/\/ Copy of zero length on a zero-length array, must work\n+        IllegalArgumentException iae = null;\n+        MyShorts[] zeroCopyMyShorts = (MyShorts[])ValueClass.newNullRestrictedNonAtomicArray(MyShorts.class, 0, new MyShorts());\n+        try {\n+          MyShorts[] res = (MyShorts[]) Arrays.copyOf(zeroCopyMyShorts, 0);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae == null, \"Unexpected exception\");\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+        try {\n+            MyInt[] bigCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyInt[] fullRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, myInts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyInt[] beginningRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+\n+        MyInt[] endingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length);\n+        MyInt[] expected3 = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 2, new MyInt());\n+        expected3[0] = myInts[1];\n+        expected3[1] = myInts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyInt[] exceedingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Range starting after the end of the original array, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyInt[] farRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, myInts.length, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        expected[0] = (MyInt) MyInt.MIN;\n+        expected[1] = (MyInt) MyInt.ZERO;\n+        expected[2] = (MyInt) MyInt.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyInt[] dest = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, copyMyInts.length, new MyInt());\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyInt> aList = new ArrayList<MyInt>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyInt.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyInt.create(5));\n+    }\n+\n+    void testUtilArraysOnNullRestrictedAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyShorts[] myShorts = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        myShorts[0] = MyShorts.MAX;\n+        myShorts[1] = MyShorts.MIN;\n+        myShorts[2] = MyShorts.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyShorts[] copyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length);\n+        MyShorts[] expected = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        expected[0] = myShorts[0];\n+        expected[1] = myShorts[1];\n+        expected[2] = myShorts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyShorts[] smallCopyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length - 1);\n+        MyShorts[] expected2 = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 2, new MyShorts());\n+        expected2[0] = myShorts[0];\n+        expected2[1] = myShorts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+        \/\/ Copy of zero length on a zero-length array, must work\n+        IllegalArgumentException iae = null;\n+        MyShorts[] zeroCopyMyShorts = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 0, new MyShorts());\n+        try {\n+          MyShorts[] res = (MyShorts[]) Arrays.copyOf(zeroCopyMyShorts, 0);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae == null, \"Unexpected exception\");\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+        try {\n+            MyShorts[] bigCopyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyShorts[] fullRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 0, myShorts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyShorts[] beginningRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+\n+        MyShorts[] endingRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 1, myShorts.length);\n+        MyShorts[] expected3 = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 2, new MyShorts());\n+        expected3[0] = myShorts[1];\n+        expected3[1] = myShorts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyShorts[] exceedingRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 1, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Range starting after the end of the original array, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyShorts[] farRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, myShorts.length, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        expected[0] = (MyShorts) MyShorts.MIN;\n+        expected[1] = (MyShorts) MyShorts.ZERO;\n+        expected[2] = (MyShorts) MyShorts.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyShorts[] dest = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, copyMyInts.length, new MyShorts());\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyShorts> aList = new ArrayList<MyShorts>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyShorts.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyShorts.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyShorts.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyShorts.create((short)5, (short)7));\n+    }\n+\n+    void testUtilArraysOnNullableAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        myInts[0] = MyInt.MAX;\n+        myInts[1] = MyInt.MIN;\n+        myInts[2] = MyInt.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length);\n+        MyInt[] expected = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected[0] = myInts[0];\n+        expected[1] = myInts[1];\n+        expected[2] = myInts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyInt[] smallCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length - 1);\n+        MyInt[] expected2 = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 2);\n+        expected2[0] = myInts[0];\n+        expected2[1] = myInts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+        \/\/ Copy of bigger length, must work for nullable arrays\n+        MyInt[] bigCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);\n+        MyInt[] expected2b = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 4);\n+        expected2b[0] = myInts[0];\n+        expected2b[1] = myInts[1];\n+        expected2b[2] = myInts[2];\n+        expected2b[3] = null;\n+        checkArrayElementsEqual(bigCopyMyInts, expected2b);\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyInt[] fullRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, myInts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyInt[] beginningRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+        MyInt[] endingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length);\n+        MyInt[] expected3 = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 2);\n+        expected3[0] = myInts[1];\n+        expected3[1] = myInts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must succeed for nullable arrays\n+        MyInt[] exceedingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length + 1);\n+        MyInt[] expected3b = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected3b[0] = myInts[1];\n+        expected3b[1] = myInts[2];\n+        expected3b[2] = null;\n+        checkArrayElementsEqual(exceedingRangeCopy, expected3b);\n+\n+        \/\/ Range starting after the end of the original array, must suceed for nullable arrays\n+        MyInt[] farRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, myInts.length, myInts.length + 1);\n+        MyInt[] expected3c = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 1);\n+        expected3c[0] = null;\n+        checkArrayElementsEqual(farRangeCopy, expected3c);\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected[0] = (MyInt) MyInt.MIN;\n+        expected[1] = (MyInt) MyInt.ZERO;\n+        expected[2] = (MyInt) MyInt.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyInt[] dest = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, copyMyInts.length);\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyInt> aList = new ArrayList<MyInt>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyInt.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyInt.create(5));\n+    }\n+\n+    void testObjectArrayOfInlines() {\n+        testSanityObjectArrays();\n+        testMixedLayoutArrays();\n+    }\n+\n+    void testSanityObjectArrays() {\n+        Object[] objects = new Object[2];\n+        assertTrue(objects[0] == null && objects[1] == null, \"Not null ?\");\n+\n+        objects[0] = MyInt.create(1);\n+        objects[1] = Integer.valueOf(2);\n+        assertTrue(objects[0].equals(MyInt.create(1)), \"Bad Value\");\n+        assertTrue(objects[1].equals(Integer.valueOf(2)), \"Bad Object\");\n+\n+        Comparable[] copyComparables = new Comparable[objects.length];\n+        System.arraycopy(objects, 0, copyComparables, 0, objects.length);\n+        checkArrayElementsEqual(objects, copyComparables);\n+\n+        objects[0] = null;\n+        objects[1] = null;\n+        assertTrue(objects[0] == null && objects[1] == null, \"Not null ?\");\n+\n+        Comparable[] comparables = new Comparable[2];\n+        assertTrue(comparables[0] == null && comparables[1] == null, \"Not null ?\");\n+        comparables[0] = MyInt.create(3);\n+        comparables[1] = Integer.valueOf(4);\n+        assertTrue(comparables[0].equals(MyInt.create(3)), \"Bad Value\");\n+        assertTrue(comparables[1].equals(Integer.valueOf(4)), \"Bad Object\");\n+\n+        Object[] copyObjects = new Object[2];\n+        System.arraycopy(comparables, 0, copyObjects, 0, comparables.length);\n+        checkArrayElementsEqual(comparables, copyObjects);\n+\n+        comparables[0] = null;\n+        comparables[1] = null;\n+        assertTrue(comparables[0] == null && comparables[1] == null, \"Not null ?\");\n+\n+        MyInt[] myIntRefArray = new MyInt[1];\n+        assertTrue(myIntRefArray[0] == null, \"Got: \" + myIntRefArray[0]);\n+        myIntRefArray[0] = null;\n+\n+        MyInt[] srcNulls = new MyInt[2];\n+        MyInt[] dstNulls = new MyInt[2];\n+        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);\n+        checkArrayElementsEqual(srcNulls, dstNulls);\n+        srcNulls[1] = MyInt.create(1);\n+        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);\n+        checkArrayElementsEqual(srcNulls, dstNulls);\n+\n+\n+        \/\/ Locked\/unlocked flat array type checks\n+        synchronized (srcNulls) {\n+            System.arraycopy(srcNulls, 0, dstNulls, 0, 2);\n+            checkArrayElementsEqual(srcNulls, dstNulls);\n+            System.gc();\n+        }\n+        System.gc();\n+        checkArrayElementsEqual(srcNulls, dstNulls);\n+    }\n+\n+    void testMixedLayoutArrays() {\n+        Object[] objArray = new Object[3];\n+        Comparable[] compArray = new Comparable[3];\n+        MyInt[] valArray = new MyInt[] { (MyInt) MyInt.MIN, (MyInt) MyInt.ZERO, (MyInt) MyInt.MAX };\n+\n+        arrayCopy(valArray, 0, objArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+        arrayCopy(valArray, 0, objArray, 0, 3);\n+\n+        objArray = new Object[3];\n+        System.arraycopy(valArray, 0, objArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+\n+        System.arraycopy(valArray, 0, compArray, 0, 3);\n+        checkArrayElementsEqual(valArray, compArray);\n+\n+        valArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        valArray[0] = (MyInt) MyInt.ZERO;\n+        valArray[1] = (MyInt) MyInt.ZERO;\n+        valArray[2] = (MyInt) MyInt.ZERO;\n+        System.arraycopy(compArray, 0, valArray, 0, 3);\n+        checkArrayElementsEqual(valArray, compArray);\n+\n+        valArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        valArray[0] = (MyInt) MyInt.ZERO;\n+        valArray[1] = (MyInt) MyInt.ZERO;\n+        valArray[2] = (MyInt) MyInt.ZERO;\n+        System.arraycopy(objArray, 0, valArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+\n+        \/\/ Sanity check dst == src\n+        System.arraycopy(valArray, 0, valArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+\n+        objArray[0] = \"Not an inline object\";\n+        try {\n+            System.arraycopy(objArray, 0, valArray, 0, 3);\n+            throw new RuntimeException(\"Expected ArrayStoreException\");\n+        } catch (ArrayStoreException ase) {}\n+\n+        MyInt[] myIntRefArray = new MyInt[3];\n+        System.arraycopy(valArray, 0, myIntRefArray, 0, 3);\n+        checkArrayElementsEqual(valArray, myIntRefArray);\n+\n+        myIntRefArray[0] = null;\n+        try {\n+            System.arraycopy(myIntRefArray, 0, valArray, 0, 3);\n+            throw new RuntimeException(\"Expected NullPointerException\");\n+        } catch (NullPointerException npe) {}\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyPoint {\n+        @Strict\n+        @NullRestricted\n+        MyInt x;\n+        @Strict\n+        @NullRestricted\n+        MyInt y;\n+\n+        private MyPoint() { this(0, 0); }\n+        private MyPoint(int x, int y) {\n+            this.x = new MyInt(x);\n+            this.y = new MyInt(y);\n+        }\n+        public boolean equals(Object that) {\n+            if (that instanceof MyPoint) {\n+                MyPoint thatPoint = (MyPoint) that;\n+                return x.equals(thatPoint.x) && java.util.Objects.equals(y, thatPoint.y);\n+            }\n+            return false;\n+        }\n+        static MyPoint create(int x) {\n+            return new MyPoint(x, x);\n+        }\n+        static MyPoint create(int x, int y) {\n+            return new MyPoint(x, y);\n+        }\n+        @Strict\n+        @NullRestricted\n+        static final MyPoint ORIGIN = create(0);\n+    }\n+\n+    void testComposition() {\n+        \/\/ Test array operations with compostion of inline types, check element payload is correct...\n+        MyPoint a = MyPoint.create(1, 2);\n+        MyPoint b = MyPoint.create(7, 21);\n+        MyPoint c = MyPoint.create(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+\n+        MyPoint[] pts = (MyPoint[])ValueClass.newNullRestrictedNonAtomicArray(MyPoint.class, 3, new MyPoint());\n+        if (!pts[0].equals(MyPoint.ORIGIN)) {\n+            throw new RuntimeException(\"Equals failed: \" + pts[0] + \" vs \" + MyPoint.ORIGIN);\n+        }\n+        pts = (MyPoint[])ValueClass.newNullRestrictedNonAtomicArray(MyPoint.class, 3, new MyPoint());\n+        pts[0] = a;\n+        pts[1] = b;\n+        pts[2] = c;\n+        checkArrayElementsEqual(pts, new Object[] { a, b, c});\n+        Object[] oarr = new Object[3];\n+\n+        arrayCopy(pts, 0, oarr, 0, 3);\n+        checkArrayElementsEqual(pts, oarr);\n+\n+        oarr = new Object[3];\n+        System.arraycopy(pts, 0, oarr, 0, 3);\n+        checkArrayElementsEqual(pts, oarr);\n+\n+        System.arraycopy(oarr, 0, pts, 0, 3);\n+        checkArrayElementsEqual(pts, oarr);\n+\n+        oarr = new Object[3];\n+        try {\n+            System.arraycopy(oarr, 0, pts, 0, 3);\n+            throw new RuntimeException(\"Expected NPE\");\n+        }\n+        catch (NullPointerException npe) {}\n+\n+        oarr = new Object[3];\n+        oarr[0] = new Object();\n+        try {\n+            System.arraycopy(oarr, 0, pts, 0, 3);\n+            throw new RuntimeException(\"Expected ASE\");\n+        }\n+        catch (ArrayStoreException ase) {}\n+    }\n+\n+    void checkArrayElementsEqual(MyInt[] arr1, Object[] arr2) {\n+        assertTrue(arr1.length == arr2.length, \"Bad length\");\n+        for (int i = 0; i < arr1.length; i++) {\n+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), \"Element \" + i + \" not equal\");\n+        }\n+    }\n+\n+    void checkArrayElementsEqual(MyPoint[] arr1, Object[] arr2) {\n+        assertTrue(arr1.length == arr2.length, \"Bad length\");\n+        for (int i = 0; i < arr1.length; i++) {\n+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), \"Element \" + i + \" not equal\");\n+        }\n+    }\n+\n+    void checkArrayElementsEqual(Object[] arr1, Object[] arr2) {\n+        assertTrue(arr1.length == arr2.length, \"Bad length\");\n+        for (int i = 0; i < arr1.length; i++) {\n+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), \"Element \" + i + \" not equal\");\n+        }\n+    }\n+\n+    void arrayCopy(MyInt[] src, int srcPos, Object[] dst, int dstPos, int length) {\n+        for (int i = 0; i < length ; i++) {\n+            dst[dstPos++] = src[srcPos++];\n+        }\n+    }\n+    void arrayCopy(MyPoint[] src, int srcPos, Object[] dst, int dstPos, int length) {\n+        for (int i = 0; i < length ; i++) {\n+            dst[dstPos++] = src[srcPos++];\n+        }\n+    }\n+\n+    Object getNull() { return null; }\n+\n+\n+    void testInlineArrayOom() {\n+        int size = Integer.MAX_VALUE;\n+        try {\n+            MyPoint[] pts = new MyPoint[size];\n+            throw new RuntimeException(\"Excepted OOM\");\n+        } catch (OutOfMemoryError oom) {}\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":899,"deletions":0,"binary":false,"changes":899,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The test class is based in the Java source code below, but the constant\n+\/\/ pool entry #33 (used by the Preload attribute) has been modified to\n+\/\/ contain the name of a non-existing class.\n+\/\/\n+\/\/ public class ValuePreloadClient1 {\n+\/\/     PreloadValue0 value;\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         System.out.print(\"Success\");\n+\/\/     }\n+\/\/ }\n+\n+ class ValuePreloadClient1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/System\"; \/\/ #10\n+    Utf8 \"out\"; \/\/ #11\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"Success\"; \/\/ #14\n+    Method #16 #17; \/\/ #15\n+    class #18; \/\/ #16\n+    NameAndType #19 #20; \/\/ #17\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18\n+    Utf8 \"print\"; \/\/ #19\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"ValuePreloadClient1\"; \/\/ #22\n+    Utf8 \"value\"; \/\/ #23\n+    Utf8 \"LPreloadValue0;\"; \/\/ #24\n+    Utf8 \"Code\"; \/\/ #25\n+    Utf8 \"LineNumberTable\"; \/\/ #26\n+    Utf8 \"main\"; \/\/ #27\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"ValuePreloadClient1.java\"; \/\/ #30\n+    Utf8 \"LoadableDescriptors\"; \/\/ #31\n+    Utf8 \"LPreloadValue1;\"; \/\/ #32\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #27; \/\/ name_index\n+      #28; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  5;\n+                8  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#31) { \/\/ LoadableDescriptors\n+      0x00010020;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class ValuePreloadClient1\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadClient1.jcod","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This file contains a class file with an invalid entry in its\n+\/\/ LoadableDescriptors attribute. The class file has been generated\n+\/\/ from the source below with editing to the constant pool and\n+\/\/ the LoadableDescriptors attribute.\n+\/\/\n+\/\/\n+\/\/ import jdk.internal.vm.annotation.NullRestricted;\n+\/\/ import jdk.internal.vm.annotation.Strict;\n+\/\/\n+\/\/\n+\/\/ public class LDTest {\n+\/\/     static value class Point {\n+\/\/         short s0, s1;\n+\/\/ \t       Point(short sa, short sb) {\n+\/\/ \t           s0 = sa;\n+\/\/ \t           s1 = sb;\n+\/\/ \t       }\n+\/\/    }\n+\/\/\n+\/\/     @Strict\n+\/\/     @NullRestricted\n+\/\/     Point p = new Point((short)0, (short)0);\n+\/\/\n+\/\/      public static void main(String[] args) {\n+\/\/ \t        LDTest test = new LDTest();\n+\/\/      }\n+\/\/ }\n+\n+\n+class LDTest {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"LDTest$Point\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"(SS)V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"LDTest\"; \/\/ #10\n+    Utf8 \"p\"; \/\/ #11\n+    Utf8 \"LLDTest$Point;\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #5 #17; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"()V\"; \/\/ #17\n+    Method #8 #15; \/\/ #18\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #19\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #20\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #21\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"main\"; \/\/ #25\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #26\n+    Utf8 \"SourceFile\"; \/\/ #27\n+    Utf8 \"LDTest.java\"; \/\/ #28\n+    Utf8 \"NestMembers\"; \/\/ #29\n+    Utf8 \"InnerClasses\"; \/\/ #30\n+    Utf8 \"Point\"; \/\/ #31\n+    Utf8 \"LoadableDescriptors\"; \/\/ #32\n+    Utf8 \"[V\"; \/\/ #33                        \/\/ <== new invalid descriptor\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #8;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0800; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #20;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#21) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #22;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          5; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB0001590303B7;\n+            0x0003B500072AB700;\n+            0x0DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  14;\n+                13  5;\n+                17  14;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #25; \/\/ name_index\n+      #26; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000859B700124C;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  19;\n+                8  20;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#27) { \/\/ SourceFile\n+      #28;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#29) { \/\/ NestMembers\n+      [] { \/\/ classes\n+        #1;\n+      }\n+    } \/\/ end NestMembers\n+    ;\n+    Attr(#30) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #1 #8 #31 24;\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#32) { \/\/ LoadableDescriptors\n+      0x00010021;                        \/\/ <== modified index to contant pool\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class LDTest\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/LDTest.jcod","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,1258 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ Simple class generated from the following source:\n+\/\/ public class SimpleClass { }\n+\/\/ The jcod version has been altered to create a class without any of ACC_IDENTITY, ACC_ABSTRACT or ACC_FINAL flags,\n+\/\/ which is illegal according to JVMS 4.1.\n+\n+class InvalidClassFlags {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"InvalidClassFlags\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"InvalidClassFlags.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0001; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class InvalidClassFlags\n+\n+\/\/ Valid class with access flags ACC_PUBLIC, ACC_ABSTRACT and no ACC_IDENTITY\n+class AbstractValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractValue.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValue\n+\n+\/\/ Valid class with access flags ACC_PUBLIC, ACC_FINAL and no ACC_IDENTITY\n+class FinalValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"FinalValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"FinalValue.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class FinalValue\n+\n+\/\/ Abstract class with ACC_IDENTITY flag added to its access flags\n+class AbstractClass {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0421; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClass\n+\n+\/\/ Value class extending the abstract (with identity) class define above\n+class ValueClass {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"ValueClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ValueClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n+\n+\/\/ Concrete identity class from old class file without ACC_IDENTITY extending the abstract (with identity) class define above\n+class IdentityClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"IdentityClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n+\n+\/\/ Concrete value class extending a final value class\n+class ValueClass2 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"FinalValue\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"ValueClass2\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ValueClass2.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass2\n+\n+\/\/ Abstract value class extending an abstract (with identity) class\n+class AbstractValueClass2 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractValueClass2\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractValueClass2.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValueClass2\n+\n+\/\/ Abstract identity class from older class file without ACC_IDENTITY, extending an abstract (with identity) class\n+class AbstractIdentityClass2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractIdentityClass2\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractIdentityClass2.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValueClass2\n+\n+\/\/ Abstract value class extending a final value class\n+class AbstractValueClass3 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"FinalValue\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractValueClass3\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractValueClass3.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValueClass3\n+\n+\/\/ A concrete class without ACC_IDENTITY but with an older class file version, declaring a field without ACC_STATIC nor ACC_STRICT\n+\/\/\n+class NotStaticNotStrictInOldClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"NotStaticNotStrictInOldClass\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"NotStaticNotStrictInOldClass.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NotStaticNotStrictInOldClass\n+\n+\/\/ Valid concrete value class with a synchronized static method\n+class StaticSynchMethod {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"StaticSynchMethod\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"StaticSynchMethod.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0029; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StaticSynchMethod\n+\n+\/\/ Invalid concrete value class with synchronized non-static method\n+class SynchMethod {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"SynchMethod\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"SynchMethod.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0021; \/\/ access               \/\/ Modified to make it synchronized\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class SynchMethod\n+\n+\/\/ Valid abstract value class with synchronized static method\n+class StaticSynchMethodInAbstractValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"StaticSynchMethodInAbstractValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"StaticSynchMethodInAbstractValue.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0029; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StaticSynchMethodInAbstractValue\n+\n+\/\/ Invalid abstract value class with a synchronized non-static method\n+class SynchMethodInAbstractValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"SynchMethodInAbstractValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"SynchMethodInAbstractValue.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0021; \/\/ access                \/\/ modified to make it synchronized\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class SynchMethodInAbstractValue\n+\n+\/\/ Class to test invalid entries in LoadableDescriptors Attributes\n+\/\/ Class generated from this source:\n+\/\/ public class PrimitiveInLoadableDescriptors {\n+\/\/ int i;\n+\/\/ void foo(Integer i) { }\n+\/\/ }\n+\n+class PrimitiveInLoadableDescriptors {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveInLoadableDescriptors\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"foo\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/Integer;)V\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"PrimitiveInLoadableDescriptors.java\"; \/\/ #16\n+    Utf8 \"LoadableDescriptors\"; \/\/ #17\n+    Utf8 \"I\"; \/\/ #18                            \/\/ Modified from \"Ljava\/lang\/Integer;\" to \"I\"\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index\n+      #14; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          0; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#17) { \/\/ LoadableDescriptors\n+      0x00010012;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveInLoadableDescriptors\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpValueClassValidation.jcod","additions":1258,"deletions":0,"binary":false,"changes":1258,"status":"added"},{"patch":"@@ -0,0 +1,637 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ \/\/ This file contains multiple illegal inline type classes that should cause\n+\/\/ ClassFormatError exceptions when attempted to be loaded.\n+\/\/\n+\/\/ Many of these test were originally generated from this Java file and then\n+\/\/ field modifiers are changed to cause a ClassFormatError exceptions.\n+\/\/\n+\/\/ public value class Value {\n+\/\/    static int si = 0;\n+\/\/    int i = 0;\n+\/\/}\n+\n+\n+\/\/ A field has both ACC_FINAL and ACC_VOLATILE set\n+\/\/\n+class FinalAndVolatile {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"FinalAndVolatile\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"FinalAndVolatile.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0850; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class FinalAndVolatile\n+\n+\n+\/\/ A field has both ACC_STRICT and ACC_STATIC set\n+\/\/\n+class StrictAndStatic {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"StrictAndStatic\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"StrictAndStatic.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0808; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StrictAndStatic\n+\n+\n+\/\/ A field has ACC_STRICT set without ACC_FINAL being set\n+\/\/\n+class StrictNotFinal {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"StrictNotFinal\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"StrictNotFinal.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0800; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StrictNotFinal\n+\n+\/\/ A concrete value class declaring a field without ACC_STATIC nor ACC_STRICT\n+\/\/\n+class NotStaticNotStrict {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"NotStaticNotStrict\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"NotStaticNotStrict.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NotStaticNotStrict\n+\n+\/\/ An abstract value class declaring a field without ACC_STATIC nor ACC_STRICT\n+\/\/\n+class NotStaticNotStrictInAbstract {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"NotStaticNotStrictInAbstract\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"NotStaticNotStrictInAbstract.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NotStaticNotStrictInAbstract\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/fieldModifiersTest.jcod","additions":637,"deletions":0,"binary":false,"changes":637,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+class Child {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"Child\"; \/\/ #1\n+    class #1; \/\/ #2\n+    Utf8 \"Parent\"; \/\/ #3\n+    class #3; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    NameAndType #5 #6; \/\/ #7\n+    Method #4 #7; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access NOTE: this is a value class, which cannot inherit from identity\n+  #2;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70008B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+  } \/\/ Attributes\n+} \/\/ end class Child\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/Child.jcod","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+class Parent {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  71; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"Parent\"; \/\/ #1\n+    class #1; \/\/ #2\n+    Utf8 \"java\/lang\/Object\"; \/\/ #3\n+    class #3; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    NameAndType #5 #6; \/\/ #7\n+    Method #4 #7; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access NOTE: this is an identity class\n+  #2;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70008B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+  } \/\/ Attributes\n+} \/\/ end class Parent\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/Parent.jcod","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class BadChild extends Parent {\n+  @Strict int x;\n+  @Strict int y;\n+\n+  BadChild() {\n+    y = 1;\n+    super(); \/\/ FAIL: Strict field x must be set before this call\n+    x = 1;\n+  }\n+}\n+*\/\n+\n+identity class BadChild extends Parent version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"()V\"\n+    stack 4  locals 1\n+  {\n+         aload_0;\n+         aload_0;\n+         iconst_1;\n+         dup_x1;\n+         putfield          Field y:\"I\";\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\"; \/\/ FAIL: Strict field x must be set before this call\n+         putfield          Field x:\"I\";\n+         return;\n+  }\n+\n+  Method       get_x:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field x:\"I\";\n+         ireturn;\n+  }\n+\n+  Method       get_y:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field y:\"I\";\n+         ireturn;\n+  }\n+} \/\/ end Class BadChild\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/BadChild.jasm","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class BadChild extends Parent {\n+  @Strict int x;\n+  @Strict int y;\n+\n+  BadChild() {\n+    x = 1;\n+    super(); \/\/ FAIL: Strict field y must be set before this call\n+    y = 1;\n+  }\n+}\n+*\/\n+\n+identity class BadChild1 extends Parent version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"()V\"\n+    stack 4  locals 1\n+  {\n+         aload_0;\n+         aload_0;\n+         iconst_1;\n+         dup_x1;\n+         putfield          Field x:\"I\";\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\"; \/\/ FAIL: Strict field y must be set before this call\n+         putfield          Field y:\"I\";\n+         return;\n+  }\n+\n+  Method       get_x:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field x:\"I\";\n+         ireturn;\n+  }\n+\n+  Method       get_y:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field y:\"I\";\n+         ireturn;\n+  }\n+} \/\/ end Class BadChild1\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/BadChild1.jasm","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Bnoinit_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {} \/\/ Strict statics not initialized\n+}\n+*\/\n+\n+identity class Bnoinit_BAD version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 0  locals 0\n+  {\n+         return;\n+  }\n+\n+} \/\/ end Class Bnoinit_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Bnoinit_BAD.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Brbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        int x = F2__STRICT; \/\/ Read before write\n+        F1__STRICT = \"hello\";\n+        F2__STRICT = 42;\n+    }\n+}\n+*\/\n+\n+identity class Brbefore_BAD version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         getstatic         Field F2__STRICT:\"I\";\n+         istore_0;\n+         ldc               String \"hello\";\n+         putstatic         Field F1__STRICT:\"Ljava\/lang\/String;\";\n+         bipush            42;\n+         putstatic         Field F2__STRICT:\"I\";\n+         return;\n+  }\n+} \/\/ end Class Brbefore_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Brbefore_BAD.jasm","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class ControlFlowChild extends Parent {\n+    @Strict int x;\n+    @Strict int y;\n+\n+    ControlFlowChild(boolean a, boolean b) {\n+        if (a) {      \/\/ FAIL: Strict field x never set on this path\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super(); \/\/\n+    }\n+}\n+*\/\n+\n+identity class ControlFlowChildBad extends Parent version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"(ZZ)V\"\n+    stack 4  locals 3\n+  {\n+         iload_1;\n+         ifeq              L29;\n+         aload_0;\n+         iconst_1;\n+         putfield          Field y:\"I\";\n+         iload_2;\n+         ifeq              L21;\n+         aload_0;\n+         iconst_1;\n+         putfield          Field y:\"I\";\n+         goto              L39;\n+  L21:   stack_frame_type  early_larval;\n+           unset_fields    y:\"I\";\n+           frame_type      same;\n+         aload_0;\n+         iconst_2;\n+         putfield          Field y:\"I\";\n+         goto              L39;          \/\/ FAIL: Strict field x never set on this path\n+  L29:   stack_frame_type  early_larval;\n+           unset_fields    x:\"I\",\n+                           y:\"I\";\n+           frame_type      same;\n+         aload_0;\n+         aload_0;\n+         iconst_3;\n+         dup_x1;\n+         putfield          Field y:\"I\";\n+         putfield          Field x:\"I\";\n+  L39:   stack_frame_type  early_larval;\n+           unset_fields;\n+           frame_type      same;\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  Method       get_x:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field x:\"I\";\n+         ireturn;\n+  }\n+\n+  Method       get_y:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field y:\"I\";\n+         ireturn;\n+  }\n+} \/\/ end Class ControlFlowChildBad\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/ControlFlowChildBad.jasm","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Creflbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Creflbefore_BAD.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Creflbefore_BAD.class, \"F2__STRICT\");\n+\n+        int x = (int) getstaticReflective(FIELD_F2);  \/\/ Read before write\n+        System.out.println(\"Early read of F2=\" + x);\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n+identity class Creflbefore_BAD version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 3\n+  {\n+         ldc               class Creflbefore_BAD;\n+         ldc               String \"F1__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         ldc               class Creflbefore_BAD;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_1;\n+         aload_1;\n+         invokestatic      Method StrictStaticFieldsTest.getstaticReflective:\"(Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object;\";\n+         checkcast         class java\/lang\/Integer;\n+         invokevirtual     Method java\/lang\/Integer.intValue:\"()I\";\n+         istore_2;\n+         getstatic         Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+         iload_2;\n+         invokedynamic     InvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\n+                           \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":\n+                           makeConcatWithConstants:\"(I)Ljava\/lang\/String;\" {\n+                             String \"Early read of F2=\\u0001\"\n+                           };\n+         invokevirtual     Method java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+         aload_0;\n+         ldc               String \"hello\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         aload_1;\n+         bipush            42;\n+         invokestatic      Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         return;\n+  }\n+\n+  BootstrapMethod          REF_invokeStatic:java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\n+                           \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";\n+                           {\n+                             String \"(early read of F2=\\u0001)\"\n+                           }\n+} \/\/ end Class Creflbefore_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Creflbefore_BAD.jasm","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Cwreflective_OK {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Cwreflective_OK.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Cwreflective_OK.class, \"F2__STRICT\");\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n+\n+identity class Cwreflective_OK version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 2\n+  {\n+         ldc               class Cwreflective_OK;\n+         ldc               String \"F1__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         ldc               class Cwreflective_OK;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_1;\n+         aload_0;\n+         ldc               String \"hello\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         aload_1;\n+         bipush            42;\n+         invokestatic      Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         return;\n+  }\n+} \/\/ end Class Cwreflective_OK\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Cwreflective_OK.jasm","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class EndsInEarlyLarval extends Parent {\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    EndsInEarlyLarval(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+class EndsInEarlyLarval {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  71;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"EndsInEarlyLarval\";               \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8}, {            \/\/ early_larval_frame\n+                  21b;                     \/\/ same\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ FAIL: early_larval_frame with no base frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/EndsInEarlyLarval.jcod","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class InvalidIndexInEarlyLarval extends Parent {\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    InvalidIndexInEarlyLarval(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+class InvalidIndexInEarlyLarval {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  71;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"InvalidIndexInEarlyLarval\";      \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8; #5}, {       \/\/ FAIL: early_larval_frame contains cp index that isn't NameAndType\n+                  21b;                     \/\/ same\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ early_larval_frame\n+                  9b;                      \/\/ same_frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/InvalidIndexInEarlyLarval.jcod","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class NestedEarlyLarval {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  71;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"NestedEarlyLarval\";               \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8}, {            \/\/ early_larval_frame\n+                  246b;                    \/\/ early_larval_frame, illegal\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ early_larval_frame\n+                  9b;                      \/\/ same_frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/NestedEarlyLarval.jcod","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class StrictFieldsNotSubset extends Parent {\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    StrictFieldsNotSubset(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+class StrictFieldsNotSubset {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  71;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"StrictFieldsNotSubset\";          \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8; #12}, {       \/\/ FAIL: early_larval_frame contains NameAndType not present in original list of strict fields\n+                  21b;                     \/\/ same\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ early_larval_frame\n+                  9b;                      \/\/ same_frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFieldsNotSubset.jcod","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class TryCatchChild extends Parent {\n+    @Strict int x;\n+    @Strict int y;\n+\n+    TryCatchChild() {\n+        try {\n+            x = 0;\n+            int[] a = new int[1];\n+            System.out.println(a[2]);\n+        } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n+            y = 0;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+identity class TryCatchChildBad extends Parent version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"()V\"\n+    stack 4  locals 2\n+  {\n+         try               T0, T1;\n+         aload_0;\n+         iconst_0;\n+         putfield          Field x:\"I\";\n+         iconst_1;\n+         newarray          int;\n+         astore_1;\n+         getstatic         Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+         aload_1;\n+         iconst_2;\n+         iaload;\n+         invokevirtual     Method java\/io\/PrintStream.println:\"(I)V\";\n+         endtry            T0,T1;\n+         goto              L63;\n+         catch             T0 java\/lang\/ArrayIndexOutOfBoundsException;\n+         try               T2;\n+         stack_frame_type  stack1;\n+           stack_map       class java\/lang\/ArrayIndexOutOfBoundsException;\n+         astore_1;\n+         aload_0;\n+         iconst_0;\n+         putfield          Field y:\"I\";\n+         endtry            T2;\n+         goto              L63;\n+         catch             T1 #0;\n+         catch             T2 #0;\n+         stack_frame_type  stack1;\n+           stack_map       class java\/lang\/Throwable;\n+         astore_2;\n+         aload_2;\n+         athrow;\n+  L63:   stack_frame_type  early_larval;\n+           unset_fields;\n+           frame_type      same;\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\";\n+         return;\n+  }\n+} \/\/ end Class TryCatchChildBad\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/TryCatchChildBad.jasm","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class WriteAfterReadRefl {\n+        @Strict static final String F1__STRICT;\n+        @Strict static final int    F2__STRICT;\n+        static {\n+            \/\/ Bytecode write\n+            F1__STRICT = \"foo\";\n+            F2__STRICT = 42;\n+\n+\n+            \/\/ Reflective read\n+            Field FIELD_F2 = findField(WriteAfterReadRefl.class, \"F2__STRICT\");\n+            int x = (int) getstaticReflective(FIELD_F2);\n+\n+            \/\/ Bytecode write after read (FAIL)\n+            F2__STRICT = 43;\n+        }\n+    }\n+*\/\n+\n+super class WriteAfterReadRefl version 71:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static final  Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static final Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 2\n+  {\n+         ldc               String \"foo\";\n+         putstatic         Field F1__STRICT:\"Ljava\/lang\/String;\";\n+         bipush            42;\n+         putstatic         Field F2__STRICT:\"I\";\n+         ldc               class WriteAfterReadRefl;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         aload_0;\n+         invokestatic      Method StrictStaticFieldsTest.getstaticReflective:\"(Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object;\";\n+         checkcast         class java\/lang\/Integer;\n+         invokevirtual     Method java\/lang\/Integer.intValue:\"()I\";\n+         istore_1;\n+         bipush            43;\n+         putstatic         Field F2__STRICT:\"I\";\n+         return;\n+  }\n+} \/\/ end Class WriteAfterReadRefl\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/WriteAfterReadRefl.jasm","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Defines the classes used by StrictFields.java to check verification\n+\/\/ of strict fields.\n+\n+\/\/ StrictIgnore is an earlier classfile version for which strict must be ignored\n+\/\/ so we can write to it multiple times in the constructor.\n+public class StrictIgnore version 66:0 {\n+  final strict Field x:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      return;\n+   }\n+}\n+\n+\/\/ StrictBase is a well formed value class with a strict field, that can\n+\/\/ be used for subclassing.\n+public abstract class StrictBase version 71:65535 {\n+  protected final strict Field x:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      return;\n+   }\n+}\n+\n+\/\/ PostInitStrict is a bad value class that writes to a strict field after the\n+\/\/ super constructor call.\n+public final class PostInitStrict version 71:65535 {\n+  final strict Field y:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield y:I;\n+      return;\n+   }\n+}\n+\n+\/\/ BadStrictSubPreInit is a bad value class that tries to write to an inherited\n+\/\/ strict field while acting on UninitializedThis.\n+public final class BadStrictSubPreInit extends StrictBase version 71:65535 {\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method StrictBase.\"<init>\":\"()V\";\n+      return;\n+   }\n+}\n+\n+\/\/ BadStrictSubPostInit is a bad value class that tries to write to an inherited\n+\/\/ strict field in \"regular\" code.\n+public final class BadStrictSubPostInit extends StrictBase version 71:65535 {\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      invokespecial Method StrictBase.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      return;\n+   }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/strictFields.jasm","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,1608 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ Many of the jcod classes in this file were derived from this Java inline type:\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ The changes for each test were made to the bytecodes for method makeValue(int x).\n+\/\/ Its bytecodes are:\n+\/\/\n+\/\/  static Value makeValue(int); descriptor: (I)LValue; flags: (0x0008) ACC_STATIC\n+\/\/    Code:\n+\/\/      stack=2, locals=2, args_size=1\n+\/\/         0: aconst_init   #3                  \/\/ class Value\n+\/\/         3: astore_1\n+\/\/         4: aload_1\n+\/\/         5: iload_0\n+\/\/         6: withfield     #2                  \/\/ Field int_v:I\n+\/\/         9: astore_1\n+\/\/        10: aload_1\n+\/\/        11: areturn\n+\n+\n+\/\/ The constant pool index of the aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 0x93.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class defValBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadCP;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadCP;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadCP.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadCP\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00934C2B1ACC00; \/\/ Changed CP index from 3 to 0x93 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54.  Since this class has a\n+\/\/ aconst_init opcode (0xCB), this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class defValBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 2.  Since this index now points to a Field\n+\/\/ entry instead of a Class entry, a VerifyError exception should get thrown.\n+\/\/\n+class defValWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValWrongCPType;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValWrongCPType;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValWrongCPType.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValWrongCPType\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00024C2B1ACC00; \/\/ Changed CP index from 3 to 2 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the cp index no longer points to a cp Class entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of the withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 0x82.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadCP\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadCP\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadCP;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadCP.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 0x82 for opcode 0xCC (withfield)\n+            0x824C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 5 in the Code array was changed to aload_1\n+\/\/ (0x2B).  This should cause a VerifyError because now the first operand on the\n+\/\/ stack for the withfield opcode (0xCC at bytecode position 6) does not match\n+\/\/ the type (int) of the field being assigned to.\n+\/\/\n+class wthFldBadFldVal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldVal\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldVal\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldVal;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldVal.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B2BCC00; \/\/ Changed opcode at bytecode 5 from iload_0 to aload_1\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldVal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 4 in the Code array was changed to iload_1\n+\/\/ (0x1A).  This should cause a VerifyError because the second operand on the stack\n+\/\/ for the withfield opcode (0xCC at bytecode position 6) must be a reference.\n+\/\/\n+class wthFldBadFldRef {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldRef\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldRef\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldRef;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldRef.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C1A1ACC00; \/\/ Changed opcode at bytecode 4 from aload_1 to iload_0\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldRef\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54 and the first opcode in the Code\n+\/\/ attribute was changed to a withfield (0xCC)..  Since withfield opcodes are not\n+\/\/ allowed in classes with major version 54, this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class wthFldBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LwthFldBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LwthFldBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"wthFldBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"wthFldBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCC00034C2B1ACC00; \/\/ Changed the first opcode to 0xCC (withfield) in order to\n+            0x024C2BB0;         \/\/ test withfield opcode with an illegal major version.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 1.  Since this index now points to a Method\n+\/\/ entry instead of a Field entry, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldWrongCPType\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldWrongCPType\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldWrongCPType;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldWrongCPType.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 1 for opcode 0xCC (withfield)\n+            0x014C2BB0;         \/\/ so that the cp index no longer points to a cp Field entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The cp entry for the aconst_init opcode was changed to a reference that\n+\/\/ is not an inline type.\n+\/\/ This should cause a VerifyError because the cp entry for opcode aconst_init\n+\/\/ must be an inline type.\n+\/\/\n+class defValueObj {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"makedefValueObj\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)QdefValueObj;\"; \/\/ #10     at 0x41\n+    Utf8 \"Code\"; \/\/ #11     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x5A\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x6C\n+    Utf8 \"()I\"; \/\/ #14     at 0x77\n+    Utf8 \"equals\"; \/\/ #15     at 0x7D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x86\n+    Utf8 \"toString\"; \/\/ #17     at 0x9E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0xA9\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0xC0\n+    Utf8 \"()QdefValueObj;\"; \/\/ #20     at 0xC9\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xDA\n+    Utf8 \"defValueObj.java\"; \/\/ #22     at 0xE7\n+    Utf8 \"defValueObj\"; \/\/ #23     at 0xF9\n+    NameAndType #7 #8; \/\/ #24     at 0x0106\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010B\n+    MethodHandle 6b #31; \/\/ #26     at 0x011E\n+    NameAndType #13 #32; \/\/ #27     at 0x0122\n+    NameAndType #15 #33; \/\/ #28     at 0x0127\n+    NameAndType #17 #34; \/\/ #29     at 0x012C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0131\n+    Method #35 #36; \/\/ #31     at 0x0144\n+    Utf8 \"(QdefValueObj;)I\"; \/\/ #32     at 0x0149\n+    Utf8 \"(QdefValueObj;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x015B\n+    Utf8 \"(QdefValueObj;)Ljava\/lang\/String;\"; \/\/ #34     at 0x017F\n+    class #37; \/\/ #35     at 0x01A2\n+    NameAndType #38 #42; \/\/ #36     at 0x01A5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01AA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01D3\n+    class #44; \/\/ #39     at 0x01E9\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01EC\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x01F5\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0204\n+    class #45; \/\/ #43     at 0x027A\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x027D\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02A5\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02D0\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02DA\n+      0x0008; \/\/ access\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x02E2\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00044C1A2B5FCC; \/\/ Changed aconst_init's cp index at byte 3 from 3 to 4.\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x0301\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x030D\n+                4  9; \/\/  at 0x0311\n+                11  10; \/\/  at 0x0315\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0315\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0336\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0342\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0342\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x034A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0364\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0370\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0370\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0378\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0391\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039D\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A5\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C4\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03D0\n+                4  5; \/\/  at 0x03D4\n+                11  6; \/\/  at 0x03D8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03DA\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E2\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class defValueObj\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ This class has a withfield opcode with a non-Q type operand.\n+class withfieldL {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldL\"; \/\/ #2     at 0x0D\n+    class #2; \/\/ #3     at 0x17\n+    Field #1 #5; \/\/ #4     at 0x1A\n+    NameAndType #6 #7; \/\/ #5     at 0x1F\n+    Utf8 \"x\"; \/\/ #6     at 0x24\n+    Utf8 \"I\"; \/\/ #7     at 0x28\n+    Field #1 #9; \/\/ #8     at 0x2C\n+    NameAndType #10 #7; \/\/ #9     at 0x31\n+    Utf8 \"y\"; \/\/ #10     at 0x36\n+    class #12; \/\/ #11     at 0x3A\n+    Utf8 \"QwithfieldL;\"; \/\/ #12     at 0x3D\n+    class #14; \/\/ #13     at 0x49\n+    Utf8 \"java\/lang\/Object\"; \/\/ #14     at 0x4C\n+    Utf8 \"makePoint\"; \/\/ #15     at 0x5F\n+    Utf8 \"(II)QwithfieldL;\"; \/\/ #16     at 0x6B\n+    Utf8 \"Code\"; \/\/ #17     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x82\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0x94\n+    Utf8 \"()QwithfieldL;\"; \/\/ #20     at 0x9D\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xAB\n+    Utf8 \"X.java\"; \/\/ #22     at 0xB8\n+    Utf8 \"NestHost\"; \/\/ #23     at 0xC1\n+    class #25; \/\/ #24     at 0xCC\n+    Utf8 \"X\"; \/\/ #25     at 0xCF\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0xD3\n+    Utf8 \"Point\"; \/\/ #27     at 0xE2\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #13;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0xF4\n+      0x0010; \/\/ access\n+      #6; \/\/ name_index       : x\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0xFC\n+      0x0010; \/\/ access\n+      #10; \/\/ name_index       : y\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0106\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index       : makePoint\n+      #16; \/\/ descriptor_index : (II)QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x010E\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[26]{\n+            0xCB0001C000034D1A;\n+            0x2C5FCC00044D1B2C;\n+            0x5FCC00084D2CC000;\n+            0x0BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x013A\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0146\n+                7  5; \/\/  at 0x014A\n+                14  6; \/\/  at 0x014E\n+                21  7; \/\/  at 0x0152\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0152\n+      0x000A; \/\/ access\n+      #19; \/\/ name_index       : <vnew>\n+      #20; \/\/ descriptor_index : ()QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 55) { \/\/ Code at 0x015A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B032A5FCC;\n+            0x0008594BB400082A;\n+            0x5FCC00044B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0183\n+              [3] { \/\/ line_number_table\n+                0  9; \/\/  at 0x018F\n+                4  10; \/\/  at 0x0193\n+                21  11; \/\/  at 0x0197\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0199\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x01A1\n+      #24; \/\/ X at 0x01A9\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 10) { \/\/ InnerClasses at 0x01A9\n+      [1] { \/\/ classes\n+        #1 #24 #27 280; \/\/  at 0x01B9\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class withfieldL\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that a VerifyError exception is thrown when trying to pass a null\n+\/\/ when the formal parameter is an inline type.\n+\/\/\n+\/\/ \/\/ Java program emulating the jcod contents.\n+\/\/ public inline final class NoNullVT {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private NoNullVT() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/\n+\/\/     public boolean isSameNoNullVT(NoNullVT that) {\n+\/\/         return this.getX() == that.getX() && this.getY() == that.getY();\n+\/\/     }\n+\/\/\n+\/\/     public boolean equals(Object o) {\n+\/\/         if(o instanceof NoNullVT) {\n+\/\/             return ((NoNullVT)o).x == x &&  ((NoNullVT)o).y == y;\n+\/\/         } else {\n+\/\/             return false;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     public static NoNullVT createNoNullVT(int x, int y) {\n+\/\/         NoNullVT p = NoNullVT.default;\n+\/\/         p = __WithField(p.x, x);\n+\/\/         p = __WithField(p.y, y);\n+\/\/         return p;\n+\/\/     }\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         String str = null;\n+\/\/         NoNullVT a = createNoNullVT(3, 4);\n+\/\/         NoNullVT b = createNoNullVT(2, 4);\n+\/\/         boolean res = a.isSameNoNullVT(null); \/\/ Should throw VerifyError\n+\/\/     }\n+\/\/ }\n+\n+class NoNullVT {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  71; \/\/ version\n+  [63] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #36; \/\/ #1     at 0x0A\n+    Field #1 #37; \/\/ #2     at 0x0D\n+    Field #1 #38; \/\/ #3     at 0x12\n+    Method #1 #39; \/\/ #4     at 0x17\n+    Method #1 #40; \/\/ #5     at 0x1C\n+    class #41; \/\/ #6     at 0x21\n+    Method #1 #42; \/\/ #7     at 0x24\n+    Method #1 #43; \/\/ #8     at 0x29\n+    InvokeDynamic 0s #46; \/\/ #9     at 0x2E\n+    InvokeDynamic 0s #47; \/\/ #10     at 0x33\n+    class #48; \/\/ #11     at 0x38\n+    Utf8 \"x\"; \/\/ #12     at 0x3B\n+    Utf8 \"I\"; \/\/ #13     at 0x3F\n+    Utf8 \"y\"; \/\/ #14     at 0x43\n+    Utf8 \"getX\"; \/\/ #15     at 0x47\n+    Utf8 \"()I\"; \/\/ #16     at 0x4E\n+    Utf8 \"Code\"; \/\/ #17     at 0x54\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x5B\n+    Utf8 \"getY\"; \/\/ #19     at 0x6D\n+    Utf8 \"isSameNoNullVT\"; \/\/ #20     at 0x74\n+    Utf8 \"(QNoNullVT;)Z\"; \/\/ #21     at 0x85\n+    Utf8 \"StackMapTable\"; \/\/ #22     at 0x95\n+    Utf8 \"equals\"; \/\/ #23     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAE\n+    Utf8 \"createNoNullVT\"; \/\/ #25     at 0xC6\n+    Utf8 \"(II)QNoNullVT;\"; \/\/ #26     at 0xD7\n+    Utf8 \"main\"; \/\/ #27     at 0xE8\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28     at 0xEF\n+    Utf8 \"hashCode\"; \/\/ #29     at 0x0108\n+    Utf8 \"toString\"; \/\/ #30     at 0x0113\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #31     at 0x011E\n+    Utf8 \"<vnew>\"; \/\/ #32     at 0x0135\n+    Utf8 \"()QNoNullVT;\"; \/\/ #33     at 0x013E\n+    Utf8 \"SourceFile\"; \/\/ #34     at 0x014D\n+    Utf8 \"NoNullVT.java\"; \/\/ #35     at 0x015A\n+    Utf8 \"NoNullVT\"; \/\/ #36     at 0x016A\n+    NameAndType #12 #13; \/\/ #37     at 0x0175\n+    NameAndType #14 #13; \/\/ #38     at 0x017A\n+    NameAndType #15 #16; \/\/ #39     at 0x017F\n+    NameAndType #19 #16; \/\/ #40     at 0x0184\n+    Utf8 \"QNoNullVT;\"; \/\/ #41     at 0x0189\n+    NameAndType #25 #26; \/\/ #42     at 0x0196\n+    NameAndType #20 #21; \/\/ #43     at 0x019B\n+    Utf8 \"BootstrapMethods\"; \/\/ #44     at 0x01A0\n+    MethodHandle 6b #49; \/\/ #45     at 0x01B3\n+    NameAndType #29 #50; \/\/ #46     at 0x01B7\n+    NameAndType #30 #51; \/\/ #47     at 0x01BC\n+    Utf8 \"java\/lang\/Object\"; \/\/ #48     at 0x01C1\n+    Method #52 #53; \/\/ #49     at 0x01D4\n+    Utf8 \"(QNoNullVT;)I\"; \/\/ #50     at 0x01D9\n+    Utf8 \"(QNoNullVT;)Ljava\/lang\/String;\"; \/\/ #51     at 0x01E9\n+    class #54; \/\/ #52     at 0x020A\n+    NameAndType #55 #59; \/\/ #53     at 0x020D\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #54     at 0x0212\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #55     at 0x023B\n+    class #61; \/\/ #56     at 0x0251\n+    Utf8 \"Lookup\"; \/\/ #57     at 0x0254\n+    Utf8 \"InnerClasses\"; \/\/ #58     at 0x025D\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #59     at 0x026C\n+    class #62; \/\/ #60     at 0x02E2\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #61     at 0x02E5\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #62     at 0x030D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0338\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [9] { \/\/ methods\n+    { \/\/ Member at 0x034A\n+      0x0001; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0352\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40002AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0369\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x0375\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0375\n+      0x0001; \/\/ access\n+      #19; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x037D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0394\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x03A0\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03A0\n+      0x0001; \/\/ access\n+      #20; \/\/ name_cpx\n+      #21; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 63) { \/\/ Code at 0x03A8\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[28]{\n+            0x2AB600042BB60004;\n+            0xA000122AB600052B;\n+            0xB60005A0000704A7;\n+            0x000403AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x03D6\n+              [1] { \/\/ LineNumberTable\n+                0  14; \/\/  at 0x03E2\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 5) { \/\/ StackMapTable at 0x03E2\n+              [2] { \/\/\n+                26b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03ED\n+      0x0001; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 87) { \/\/ Code at 0x03F5\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[43]{\n+            0x2BC100019900252B;\n+            0xC00006B400022AB4;\n+            0x0002A000152BC000;\n+            0x06B400032AB40003;\n+            0xA0000704A7000403;\n+            0xAC03AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0432\n+              [3] { \/\/ LineNumberTable\n+                0  18; \/\/  at 0x043E\n+                7  19; \/\/  at 0x0442\n+                41  21; \/\/  at 0x0446\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 6) { \/\/ StackMapTable at 0x0446\n+              [3] { \/\/\n+                39b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+                0b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0452\n+      0x0009; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x045A\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014D1A2C5FCC;\n+            0x00024D1B2C5FCC00;\n+            0x034D2CB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x0480\n+              [4] { \/\/ LineNumberTable\n+                0  26; \/\/  at 0x048C\n+                4  27; \/\/  at 0x0490\n+                11  28; \/\/  at 0x0494\n+                18  29; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0498\n+      0x0009; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x04A0\n+          2; \/\/ max_stack\n+          5; \/\/ max_locals\n+          Bytes[22]{\n+            0x014C0607B800074D;\n+            0x0507B800074E2C2B; \/\/ Change last nibble from C to B to load null\n+            0xB600083604B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 22) { \/\/ LineNumberTable at 0x04C8\n+              [5] { \/\/ LineNumberTable\n+                0  33; \/\/  at 0x04D4\n+                2  34; \/\/  at 0x04D8\n+                8  35; \/\/  at 0x04DC\n+                14  36; \/\/  at 0x04E0\n+                21  37; \/\/  at 0x04E4\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x04E4\n+      0x0011; \/\/ access\n+      #29; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x04EC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00090000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0505\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0511\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0511\n+      0x0011; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x0519\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0532\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x053E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x053E\n+      0x000A; \/\/ access\n+      #32; \/\/ name_cpx\n+      #33; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x0546\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00024B032A5FCC00;\n+            0x034B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x056C\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x0578\n+                4  6; \/\/  at 0x057C\n+                11  7; \/\/  at 0x0580\n+                18  8; \/\/  at 0x0584\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#34, 2) { \/\/ SourceFile at 0x0586\n+      #35;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#58, 10) { \/\/ InnerClasses at 0x058E\n+      [1] { \/\/ InnerClasses\n+        #56 #60 #57 25; \/\/  at 0x059E\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#44, 6) { \/\/ BootstrapMethods at 0x059E\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #45; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class NoNullVT\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":1608,"deletions":0,"binary":false,"changes":1608,"status":"added"},{"patch":"@@ -532,0 +532,5 @@\n+java\/lang\/ModuleLayer\/LayerControllerTest.java                  8337048 generic-all\n+java\/lang\/ModuleLayer\/BasicLayerTest.java                       8337048 generic-all\n+\n+java\/lang\/Thread\/virtual\/stress\/Skynet.java#default             8342977 generic-all\n+\n@@ -549,0 +554,1 @@\n+com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWithEliminatedLock.java 8360599 generic-all\n@@ -570,0 +576,2 @@\n+java\/net\/CookieHandler\/B6644726.java                            8365811 generic-all\n+\n@@ -720,0 +728,4 @@\n+com\/sun\/jdi\/cds\/CDSBreakpointTest.java                          8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSDeleteAllBkptsTest.java                      8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSFieldWatchpoints.java                        8304168 generic-all\n+\n@@ -815,0 +827,1 @@\n+\n@@ -821,0 +834,16 @@\n+\n+############################################################################\n+\n+# valhalla\n+java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessValue.java 8367346 generic-all\n+\n+jdk\/classfile\/AccessFlagsTest.java 8366270 generic-all\n+jdk\/jfr\/event\/runtime\/TestClassLoaderStatsEvent.java 8366820 generic-all\n+\n+jdk\/internal\/vm\/Continuation\/Fuzz.java#default 8370177 generic-aarch64\n+jdk\/internal\/vm\/Continuation\/Fuzz.java#preserve-fp 8370177 generic-aarch64\n+\n+sun\/tools\/jhsdb\/BasicLauncherTest.java 8366806 generic-all\n+sun\/tools\/jhsdb\/HeapDumpTest.java 8366806 generic-all\n+sun\/tools\/jhsdb\/HeapDumpTestWithActiveProcess.java 8366806 generic-all\n+sun\/tools\/jhsdb\/JShellHeapDumpTest.java 8366806 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -101,2 +101,3 @@\n-                Optional<Module> m = layer.findModule(moduleName);\n-                if (!m.isPresent())\n+                \/\/ removing dependency on java.util.Optional, valhalla only, to avoid VM warnings\n+                Module m = layer.findModule(moduleName).get();\n+                if (m == null)\n@@ -104,1 +105,1 @@\n-                m.get().addExports(packageName, getClass().getModule());\n+                m.addExports(packageName, getClass().getModule());\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}