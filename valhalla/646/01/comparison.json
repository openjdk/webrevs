{"files":[{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools;\n+\n+import java.util.ArrayList;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.Files;\n+import java.io.PrintWriter;\n+import java.io.IOException;\n+import org.openjdk.asmtools.jdis.uEscWriter;\n+\n+\/**\n+ * An entry point to AsmTools for use with the jtreg '@run driver' command.\n+ * Unlike 'Main', never invokes 'System.exit' (which crashes jtreg).\n+ *\n+ * Also adjusts file paths:\n+ *\n+ * - For jasm and jcoder, source files are expected to appear in ${test.src},\n+ *   and output is sent to ${test.classes}\n+ *\n+ * - For other tools, class files are expected to appear in ${test.classes},\n+ *   and output is sent to the scratch working directory\n+ *\n+ * Example jtreg usage:\n+ *\n+ * @library \/test\/lib\n+ * @build org.openjdk.asmtools.* org.openjdk.asmtools.jasm.*\n+ * @run driver org.openjdk.asmtools.JtregDriver jasm -strict TestFile.jasm\n+ *\/\n+public class JtregDriver {\n+\n+    public static void main(String... args) throws IOException {\n+        if (args.length == 0) {\n+            throw new IllegalArgumentException(\"Missing asmtools command\");\n+        }\n+        String cmd = args[0];\n+        if (!cmd.equals(\"jasm\") && !cmd.equals(\"jdis\") && !cmd.equals(\"jcoder\")\n+                && !cmd.equals(\"jdec\") && !cmd.equals(\"jcdec\")) {\n+            throw new IllegalArgumentException(\"Unrecognized asmtools command: \" + cmd);\n+        }\n+        boolean isAssembler = cmd.equals(\"jasm\") || cmd.equals(\"jcoder\");\n+        String srcDir = System.getProperty(\"test.src\", \".\");\n+        String clsDir = System.getProperty(\"test.classes\", \".\");\n+        String fileDir = isAssembler ? srcDir : clsDir;\n+\n+        ArrayList<String> toolArgList = new ArrayList<String>();\n+\n+        if (isAssembler) {\n+            Path destPath = Paths.get(clsDir);\n+            if (!Files.exists(destPath)) {\n+                \/\/ jtreg creates classes dir on demand, might not have happened yet\n+                Files.createDirectories(destPath);\n+            }\n+            toolArgList.add(\"-d\");\n+            toolArgList.add(clsDir);\n+        }\n+\n+        boolean isOptionArg = false; \/\/ marks an argument to a previous option\n+        for (int i = 1; i < args.length; i++) {\n+            String arg = args[i];\n+            if (isOptionArg) {\n+                isOptionArg = false; \/\/ reset for next\n+            } else {\n+                if (arg.equals(\"-d\")) {\n+                    isOptionArg = true;\n+                } else if (!arg.startsWith(\"-\") && !arg.startsWith(\"\/\")) {\n+                    \/\/ adjust filename\n+                    arg = Paths.get(fileDir, arg).toString();\n+                }\n+            }\n+            toolArgList.add(arg);\n+        }\n+\n+        String[] toolArgs = toolArgList.toArray(new String[0]);\n+        boolean success = switch (cmd) {\n+            case \"jasm\" -> {\n+                PrintWriter out = new PrintWriter(System.out);\n+                yield new org.openjdk.asmtools.jasm.Main(out, \"jasm\").compile(toolArgs);\n+            }\n+            case \"jdis\" -> {\n+                PrintWriter out = new PrintWriter(new uEscWriter(System.out));\n+                PrintWriter err = new PrintWriter(System.err);\n+                yield new org.openjdk.asmtools.jdis.Main(out, err, \"jdis\").disasm(toolArgs);\n+            }\n+            case \"jcoder\" -> {\n+                PrintWriter out = new PrintWriter(System.out);\n+                yield new org.openjdk.asmtools.jcoder.Main(out, \"jcoder\").compile(toolArgs);\n+            }\n+            case \"jdec\" -> {\n+                PrintWriter out = new PrintWriter(new uEscWriter(System.out));\n+                PrintWriter err = new PrintWriter(System.err);\n+                yield new org.openjdk.asmtools.jdec.Main(out, err, \"jdec\").decode(toolArgs);\n+            }\n+            case \"jcdec\" -> {\n+                PrintWriter out = new PrintWriter(new uEscWriter(System.out));\n+                yield new org.openjdk.asmtools.jcdec.Main(out, \"jcdec\").decode(toolArgs);\n+            }\n+            default -> throw new AssertionError();\n+        };\n+        if (!success) {\n+            throw new RuntimeException(\"asmtools execution failed\");\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/JtregDriver.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools;\n+\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+import org.openjdk.asmtools.util.ProductInfo;\n+\n+\/**\n+ * Wrapper class that reads the first command line argument and invokes a corresponding\n+ * tool.\n+ *\/\n+public class Main {\n+\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    \/**\n+     * Parses the first argument and deligates execution to an appropriate tool\n+     *\n+     * @param args - command line arguments\n+     *\/\n+    public static void main(String args[]) {\n+        if (args.length == 0) {\n+            usage(i18n.getString(\"main.error.no_arguments\"), 1);\n+        }\n+        String cmd = args[0];\n+        if (cmd.equals(\"-?\") || cmd.equals(\"-h\") || cmd.equals(\"-help\")) {\n+            usage(null, 0);\n+        } else if (cmd.equals(\"-version\")) {\n+            printVersion();\n+        } else {\n+            String[] newArgs = new String[args.length - 1];\n+            System.arraycopy(args, 1, newArgs, 0, args.length - 1);\n+            if (cmd.equals(\"jasm\")) {\n+                jasm(newArgs);\n+            } else if (cmd.equals(\"jdis\")) {\n+                jdis(newArgs);\n+            } else if (cmd.equals(\"jcoder\")) {\n+                jcoder(newArgs);\n+            } else if (cmd.equals(\"jdec\")) {\n+                jdec(newArgs);\n+            } else if (cmd.equals(\"jcdec\")) {\n+                jcdec(newArgs);\n+            } else {\n+                usage(i18n.getString(\"main.error.unknown_tool\", cmd), 1);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Prints usage info and error message, afterwards invokes System.exit()\n+     *\n+     * @param msg - error message to print, or null if no errors occurred\n+     * @param exitCode - exit code to be returned by System.exit()\n+     *\/\n+    public static void usage(String msg, int exitCode) {\n+        System.err.println(i18n.getString(\"main.usage\", \"asmtools.jar\"));\n+        if (msg != null) {\n+            System.err.println(msg);\n+        }\n+        System.exit(exitCode);\n+    }\n+\n+    \/**\n+     * Prints the tools version\n+     *\/\n+    public static void printVersion() {\n+        System.out.println(ProductInfo.FULL_VERSION);\n+    }\n+\n+    \/**\n+     * Invokes jasm main class with passed arguments\n+     *\/\n+    public static void jasm(String[] args) {\n+        org.openjdk.asmtools.jasm.Main.main(args);\n+    }\n+\n+    \/**\n+     * Invokes jcdec main class with passed arguments\n+     *\/\n+    public static void jcdec(String[] args) {\n+        org.openjdk.asmtools.jcdec.Main.main(args);\n+    }\n+\n+    \/**\n+     * Invokes jcoder main class with passed arguments\n+     *\/\n+    public static void jcoder(String[] args) {\n+        org.openjdk.asmtools.jcoder.Main.main(args);\n+    }\n+\n+    \/**\n+     * Invokes jdec main class with passed arguments\n+     *\/\n+    public static void jdec(String[] args) {\n+        org.openjdk.asmtools.jdec.Main.main(args);\n+    }\n+\n+    \/**\n+     * Invokes jdis main class with passed arguments\n+     *\/\n+    public static void jdis(String[] args) {\n+        org.openjdk.asmtools.jdis.Main.main(args);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/Main.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.asmutils;\n+\n+\/**\n+ *\n+ *\/\n+public class HexUtils {\n+    \/*======================================================== Hex *\/\n+\n+    private static final String hexString = \"0123456789ABCDEF\";\n+    private static final char hexTable[] = hexString.toCharArray();\n+\n+    public static String toHex(long val, int width) {\n+        StringBuffer sb = new StringBuffer();\n+        for (int i = width - 1; i >= 0; i--) {\n+            sb.append(hexTable[((int) (val >> (4 * i))) & 0xF]);\n+        }\n+        String s = sb.toString();\n+        return \"0x\" + (s.isEmpty() ? \"0\" : s);\n+    }\n+\n+    public static String toHex(long val) {\n+        int width;\n+        for (width = 16; width > 0; width--) {\n+            if ((val >> (width - 1) * 4) != 0) {\n+                break;\n+            }\n+        }\n+        return toHex(val, width);\n+    }\n+\n+    public static String toHex(int val) {\n+        int width;\n+        for (width = 8; width > 0; width--) {\n+            if ((val >> (width - 1) * 4) != 0) {\n+                break;\n+            }\n+        }\n+        return toHex(val, width);\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/asmutils\/HexUtils.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.asmutils;\n+\n+\/**\n+ * Utility class to share common tools\/methods.\n+ *\/\n+public class StringUtils {\n+    \/**\n+     * Converts CONSTANT_Utf8_info string to a printable string for jdis\/jdes.\n+     * @param utf8 UTF8 string taken from within ConstantPool of a class file\n+     * @return output string for jcod\/jasm\n+     *\/\n+    public static String Utf8ToString(String utf8) {\n+        StringBuilder sb = new StringBuilder(\"\\\"\");\n+        for (int k = 0; k < utf8.length(); k++) {\n+            char c = utf8.charAt(k);\n+            switch (c) {\n+                case '\\t':\n+                    sb.append('\\\\').append('t');\n+                    break;\n+                case '\\n':\n+                    sb.append('\\\\').append('n');\n+                    break;\n+                case '\\r':\n+                    sb.append('\\\\').append('r');\n+                    break;\n+                case '\\b':\n+                    sb.append('\\\\').append('b');\n+                    break;\n+                case '\\f':\n+                    sb.append('\\\\').append('f');\n+                    break;\n+                case '\\\"':\n+                    sb.append('\\\\').append('\\\"');\n+                    break;\n+                case '\\'':\n+                    sb.append('\\\\').append('\\'');\n+                    break;\n+                case '\\\\':\n+                    sb.append('\\\\').append('\\\\');\n+                    break;\n+                default:\n+                    sb.append(c);\n+            }\n+        }\n+        return sb.append('\\\"').toString();\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/asmutils\/StringUtils.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,440 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.common;\n+\n+import org.openjdk.asmtools.jdis.Indenter;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+\n+\/**\n+ * Internal presentation of a module\n+ *\/\n+public final class Module extends Indenter {\n+\n+  \/\/* A module name and module_flags\n+  public final Header header;\n+  \/\/* A service dependence's of this module\n+  public final Set<Uses> uses;\n+  \/\/* Modules on which the current module has a dependence.\n+  public final Set<Dependence> requires;\n+  \/\/* A module exports, may be qualified or unqualified.\n+  public final Map<Exported, Set<String>> exports;\n+  \/\/* Packages, to be opened by the current module\n+  public final Map<Opened, Set<String>> opens;\n+  \/\/* A service that a module provides one or more implementations of.\n+  public final Map<Provided, Set<String>> provides;\n+\n+  private Module(Builder builder) {\n+    this.header = builder.header;\n+    this.requires = Collections.unmodifiableSet(builder.requires);\n+    this.exports = Collections.unmodifiableMap(builder.exports);\n+    this.opens = Collections.unmodifiableMap(builder.opens);\n+    this.uses = Collections.unmodifiableSet(builder.uses);\n+    this.provides = Collections.unmodifiableMap(builder.provides);\n+  }\n+\n+  public String getModuleFlags () {\n+    return Modifier.getModuleModifiers(header.getFlags());\n+  }\n+  public String getModuleName () { return header.getModuleName();  }\n+  public String getModuleVersion()  { return header.getModuleVersion(); };\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    int l = 0;\n+    requires.stream()\n+        .sorted()\n+        .forEach(d -> sb.append(getIndentString()).append(format(\"requires %s;%s%n\",\n+            d.toString(),\n+            d.getModuleVersion() == null ? \"\" : \" \/\/ @\" + d.getModuleVersion())));\n+    \/\/\n+    l = newLine(sb,l);\n+    exports.entrySet().stream()\n+        .filter(e -> e.getValue().isEmpty())\n+        .sorted(Map.Entry.comparingByKey())\n+        .map(e -> format(\"%sexports %s;%n\", getIndentString(), e.getKey().toString()))\n+        .forEach(sb::append);\n+    exports.entrySet().stream()\n+        .filter(e -> !e.getValue().isEmpty())\n+        .sorted(Map.Entry.comparingByKey())\n+        .map(e -> format(\"%sexports %s to%n%s;%n\", getIndentString(), e.getKey().toString(),\n+            e.getValue().stream().sorted()\n+                .map(mn -> format(\"%s          %s\", getIndentString(), mn))\n+                .collect(Collectors.joining(\",\\n\"))))\n+        .forEach(sb::append);\n+    \/\/\n+    l = newLine(sb,l);\n+    opens.entrySet().stream()\n+        .filter(e -> e.getValue().isEmpty())\n+        .sorted(Map.Entry.comparingByKey())\n+        .map(e -> format(\"%sopens %s;%n\", getIndentString(), e.getKey().toString()))\n+        .forEach(sb::append);\n+    opens.entrySet().stream()\n+        .filter(e -> !e.getValue().isEmpty())\n+        .sorted(Map.Entry.comparingByKey())\n+        .map(e -> format(\"%sopens %s to%n%s;%n\", getIndentString(), e.getKey().toString(),\n+            e.getValue().stream().sorted()\n+                .map(mn -> format(\"%s          %s\", getIndentString(), mn))\n+                .collect(Collectors.joining(\",\\n\"))))\n+        .forEach(sb::append);\n+    \/\/\n+    l = newLine(sb,l);\n+    uses.stream().sorted()\n+        .map(s -> format(\"%suses %s;%n\", getIndentString(), s))\n+        .forEach(sb::append);\n+    \/\/\n+    l = newLine(sb,l);\n+    provides.entrySet().stream()\n+        .filter(e -> !e.getValue().isEmpty())\n+        .sorted(Map.Entry.comparingByKey())\n+        .map(e -> format(\"%sprovides %s with%n%s;%n\", getIndentString(), e.getKey().toString(),\n+            e.getValue().stream().sorted()\n+                .map(mn -> format(\"%s          %s\", getIndentString(), mn))\n+                .collect(Collectors.joining(\",\\n\"))))\n+        .forEach(sb::append);\n+    \/\/\n+    if( Character.isWhitespace(sb.charAt(sb.length()-1)) )\n+      sb.deleteCharAt(sb.length()-1);\n+    return sb.toString();\n+  }\n+\n+  private int newLine(StringBuilder sb, int length) {\n+    if(sb.length() > length) {\n+      sb.append(\"\\n\");\n+      return sb.length() + 1;\n+    }\n+    return length;\n+  }\n+\n+  \/**\n+   * Modules flags\n+   *\/\n+  public enum Modifier {\n+    ACC_NONE(0x0000, \"\", \"\"),\n+    ACC_OPEN(0x0020, \"open\", \"ACC_OPEN\"),\n+    ACC_TRANSITIVE(0x0020, \"transitive\", \"ACC_TRANSITIVE\"),\n+    ACC_STATIC_PHASE(0x0040, \"static\", \"ACC_STATIC_PHASE\"),\n+    ACC_SYNTHETIC(0x1000, \"\", \"ACC_SYNTHETIC\"),\n+    ACC_MANDATED(0x8000, \"\", \"ACC_MANDATED\");\n+    private final int value;\n+    private final String keyword;\n+    private final String flag;\n+    Modifier(int value, String keyword, String flagName) {\n+      this.value = value;\n+      this.keyword = keyword;\n+      this.flag = flagName;\n+    }\n+\n+    public int asInt() { return value; }\n+\n+    public static String getModuleModifiers(int flag) {\n+      return asString(flag, false, ACC_TRANSITIVE);\n+    }\n+\n+    public static String getModuleFlags(int flag) {\n+      return asString(flag, true, ACC_TRANSITIVE);\n+    }\n+\n+    public static String getStatementModifiers(int flag) {\n+      return asString(flag, false, ACC_OPEN);\n+    }\n+\n+    public static String getStatementFlags(int flag) {\n+      return asString(flag, true, ACC_OPEN);\n+    }\n+\n+    private static String asString(int value, boolean flagFormat, Modifier skipped ) {\n+      String buf = \"\";\n+      for(Module.Modifier m : values()) {\n+        if( m != skipped && (value & m.value) != 0) {\n+          buf += ((flagFormat) ? m.flag : m.keyword) + \" \";\n+          value ^= m.value;\n+        }\n+      }\n+      if( flagFormat && value != 0 )\n+        buf += String.format(\"0x%04X \", value);\n+      return buf;\n+    }\n+  }\n+\n+  \/\/ A module header consists of a module name and module flags\n+  public final static class Header extends VersionedFlaggedTargetType{\n+    Header(String typeName, int flag) { this(typeName, flag, null); }\n+    Header(String typeName, int flag, String moduleVersion) { super(typeName, flag, moduleVersion); }\n+    public String getModuleName()    { return getTypeName(); }\n+    public int    getModuleFlags()   { return getFlags();    }\n+    public String getModuleVersion() { return getVersion();  }\n+  }\n+\n+  \/\/* A module on which the current module has a dependence.\n+  public final static class Dependence extends VersionedFlaggedTargetType {\n+    public Dependence(String moduleName, int flag) {this(moduleName, flag, null);}\n+    public Dependence(String moduleName, int flag, String moduleVersion) {super(moduleName, flag, moduleVersion);}\n+    public Dependence(String moduleName, boolean transitive, boolean staticPhase) { this(moduleName,transitive,staticPhase,null);}\n+    public Dependence(String moduleName, boolean transitive, boolean staticPhase, String moduleVersion) {\n+      this(moduleName,\n+          (transitive ? Modifier.ACC_TRANSITIVE.value : Modifier.ACC_NONE.value) |\n+          (staticPhase ? Modifier.ACC_STATIC_PHASE.value : Modifier.ACC_NONE.value), moduleVersion);\n+    }\n+    public String getModuleVersion()          { return getVersion();  }\n+  }\n+\n+  public final static class Uses extends TargetType {\n+    public Uses(String typeName) { super(typeName); }\n+  }\n+\n+  \/\/* A provided type of the current module.\n+  public final static class Provided extends TargetType {\n+    public Provided(String typeName) { super(typeName); }\n+  }\n+\n+  \/\/* An opened package of the current module.\n+  public final static class Opened extends FlaggedTargetType {\n+    public Opened(String typeName) {\n+      super(typeName, 0);\n+    }\n+    public Opened(String typeName, int opensFlags) {\n+      super(typeName, opensFlags);\n+    }\n+  }\n+\n+  \/\/* An exported package of the current module.\n+  public final static class Exported extends FlaggedTargetType {\n+    public Exported(String typeName) {\n+      super(typeName, 0);\n+    }\n+\n+    public Exported(String typeName, int exportsFlags) {\n+      super(typeName, exportsFlags);\n+    }\n+  }\n+\n+  public static class VersionedFlaggedTargetType extends FlaggedTargetType {\n+    private String version;\n+\n+    VersionedFlaggedTargetType(String typeName, int flag) {\n+      this(typeName,flag, null);\n+    }\n+\n+    VersionedFlaggedTargetType(String typeName, int flag, String version) {\n+      super(typeName, flag);\n+      this.version = version != null && !version.isEmpty() ? version : null;\n+    }\n+    public String getVersion() { return version; }\n+\n+    @Override\n+    public int hashCode() {\n+      int code = version == null ? 0 : version.hashCode();\n+      return code + super.hashCode();\n+    }\n+  }\n+\n+  public static class FlaggedTargetType extends TargetType {\n+    private int flag;\n+\n+    FlaggedTargetType(String typeName, int flag) {\n+      super(typeName);\n+      this.flag = flag;\n+    }\n+\n+    public boolean isFlagged() {\n+      return true;\n+    }\n+\n+    public int getFlags() {\n+      return flag;\n+    }\n+\n+    public void setFlag(int value) { flag = value; }\n+\n+    @Override\n+    public int hashCode() {\n+      return super.hashCode() + flag;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return super.equals(o) && ((FlaggedTargetType) o).flag == this.flag;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return Modifier.getStatementModifiers(this.flag)+ super.toString();\n+    }\n+  }\n+\n+  public static class TargetType implements Comparable<TargetType> {\n+    private String typeName;\n+\n+    TargetType(String typeName) { this.typeName = typeName; }\n+\n+    public String getTypeName() {\n+      return typeName;\n+    }\n+\n+    public void setTypeName(String value) { typeName = value; }\n+\n+    public boolean isFlagged() {\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() { return typeName.hashCode() * 11; }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof TargetType) {\n+        TargetType t = (TargetType) o;\n+        return this.typeName.equals(t.getTypeName());\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int compareTo(TargetType t) {\n+      return this.typeName.compareTo(t.getTypeName());\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typeName;\n+    }\n+  }\n+\n+  \/**\n+   * The module builder.\n+   *\/\n+  public static final class Builder {\n+    final Header header;\n+    final Set<Dependence> requires = new HashSet<>();\n+    final Map<Exported, Set<String>> exports = new HashMap<>();\n+    final Map<Opened, Set<String>> opens = new HashMap<>();\n+    final Set<Uses> uses = new HashSet<>();\n+    final Map<Provided, Set<String>> provides = new HashMap<>();\n+\n+\n+    public Builder() {\n+      this(\"\", Modifier.ACC_NONE.asInt(), null);\n+    }\n+\n+    public Builder(String moduleName, int moduleFlags, String moduleVersion) {\n+      header = new Header( moduleName,moduleFlags, moduleVersion);\n+    }\n+\n+    public Builder setModuleFlags(int moduleFlags) {\n+      header.setFlag(header.getFlags() | moduleFlags);\n+      return this;\n+    }\n+\n+    public Builder setModuleFlags(Modifier... moduleFlags) {\n+      for (Modifier m : moduleFlags)\n+        setModuleFlags(m.value);\n+      return this;\n+    }\n+\n+    public Builder setModuleName(String value) {\n+      header.setTypeName(value);\n+      return this;\n+    }\n+\n+    public Builder require(String d, boolean transitive, boolean staticPhase, String version) {\n+      requires.add(new Dependence(d, transitive, staticPhase, version));\n+      return this;\n+    }\n+\n+    public Builder require(String d, int requiresFlag, String version) {\n+      requires.add(new Dependence(d, requiresFlag, version));\n+      return this;\n+    }\n+\n+    public Builder require(String d, int requiresFlag) {\n+      requires.add(new Dependence(d, requiresFlag, null));\n+      return this;\n+    }\n+\n+    public Builder opens(Opened p, Set<String> ms) {\n+      return add(opens, p, ms);\n+    }\n+\n+    public Builder opens(String packageName, int exportFlags, Set<String> ms) {\n+      return add(opens, new Opened(packageName, exportFlags), ms);\n+    }\n+\n+    public Builder opens(String packageName, int exportFlags) {\n+      return add(opens, new Opened(packageName, exportFlags), new HashSet<>());\n+    }\n+\n+\n+    public Builder exports(Exported p, Set<String> ms) {\n+      return add(exports, p, ms);\n+    }\n+\n+    public Builder exports(String packageName, int exportFlags, Set<String> ms) {\n+      return add(exports, new Exported(packageName, exportFlags), ms);\n+    }\n+\n+    public Builder exports(String packageName, int exportFlags) {\n+      return add(exports, new Exported(packageName, exportFlags), new HashSet<>());\n+    }\n+\n+    public Builder uses(String serviceName) {\n+      uses.add(new Uses(serviceName));\n+      return this;\n+    }\n+\n+\n+    public Builder uses(Set<String> serviceNames) {\n+      uses.addAll(serviceNames.stream().map(Uses::new).collect(Collectors.toList()));\n+      return this;\n+    }\n+\n+    public Builder provides(Provided t, Set<String> implementations) {\n+      return add(provides, t, implementations);\n+    }\n+\n+    public Builder provides(String serviceName, Set<String> implementations) {\n+      return add(provides, new Provided(serviceName), implementations);\n+    }\n+\n+\n+    \/**\n+     * @return The new module\n+     *\/\n+    public Module build() {\n+      return new Module(this);\n+    }\n+\n+    private <T extends TargetType> Builder  add( Map<T, Set<String>> collection, T source, Set<String> target) {\n+      Objects.requireNonNull(source);\n+      Objects.requireNonNull(target);\n+      if (!collection.containsKey(source))\n+        collection.put(source, new HashSet<>());\n+      collection.get(source).addAll(target);\n+      return this;\n+    }\n+  }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/common\/Module.java","additions":440,"deletions":0,"binary":false,"changes":440,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.common;\n+\n+\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+public abstract class Tool {\n+\n+    \/\/ Name of the program.\n+    protected final String programName;\n+    \/\/ Errors counter.\n+    protected int nerrors = 0;\n+    \/\/ The stream where error message are printed.\n+    protected PrintWriter err;\n+\n+    \/\/ Output stream\n+    protected PrintWriter out;\n+\n+    \/\/ A consumer to print a error message if the tool can't read a file\n+    protected Consumer<String> printCannotReadMsg;\n+\n+    \/\/ A supplier to get a status of a debug flag\n+    protected BooleanSupplier DebugFlag = () -> false;\n+\n+    public Tool(PrintWriter out, String programName) {\n+        this(out, out, programName);\n+    }\n+\n+    public Tool(PrintWriter out, PrintWriter err, String programName) {\n+        this.out = out;\n+        this.err = err;\n+        this.programName = programName;\n+    }\n+\n+\n+    public String getError(String msg) {\n+        return programName + \": \" + msg;\n+    }\n+\n+    \/**\n+     * Top level error message\n+     *\/\n+    public void error(String msg) {\n+        err.println(getError(msg));\n+        err.flush();\n+    }\n+\n+    \/**\n+     * Top level print message\n+     *\/\n+    public void println(String msg) {\n+        out.println(msg);\n+        out.flush();\n+    }\n+\n+    public void println() {\n+        println(\"\");\n+    }\n+\n+    public void print(String msg) {\n+        out.print(getError(msg));\n+        out.flush();\n+    }\n+\n+    \/**\n+     * @param fname file name\n+     * @return DataInputStream or null if the method can't read a file\n+     *\/\n+    public DataInputStream getDataInputStream(String fname) {\n+        try {\n+            return new DataInputStream(new FileInputStream(fname));\n+        } catch (IOException ex) {\n+            if (fname.matches(\"^[A-Za-z]+:.*\")) {\n+                try {\n+                    final URI uri = new URI(fname);\n+                    final URL url = uri.toURL();\n+                    final URLConnection conn = url.openConnection();\n+                    conn.setUseCaches(false);\n+                    return new DataInputStream(conn.getInputStream());\n+                } catch (URISyntaxException | IOException e) {\n+                    if (DebugFlag.getAsBoolean())\n+                        e.printStackTrace();\n+                }\n+            }\n+            if (printCannotReadMsg != null)\n+                printCannotReadMsg.accept(fname);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Usage\n+     *\/\n+    protected abstract void usage();\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/common\/Tool.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+# Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+main.usage=\\\n+Usage: \\n\\\n+to run an assembly tool: \\n\\\n+\\   $ java -jar {0} toolName [args...] \\n\\\n+\\   where toolName one of: jasm, jdis, jcoder, jdec, jcdec \\n\\\n+to get the version: \\n\\\n+\\   $ java -jar {0} -version \\n\\\n+to get this message \\n\\\n+\\   $ java -jar {0} -?|-h|-help\\n\n+\n+main.error.no_arguments=No arguments provided!  See options above.\n+main.error.unknown_tool=Tool name ''{0}'' unrecognized.  See usage above for possible tool choices.\n\\ No newline at end of file\n","filename":"test\/lib\/org\/openjdk\/asmtools\/i18n.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+\/**\n+ * JVMS 4.7.16.\n+ *\n+ * annotation {\n+ *     u2 type_index;\n+ *     u2 num_element_value_pairs;\n+ *     {   u2            element_name_index;\n+ *         element_value value;\n+ *     } element_value_pairs[num_element_value_pairs];\n+ * }\n+ *\/\n+class AnnotationData implements Data {\n+\n+    boolean invisible;\n+    Argument typeCPX;\n+    ArrayList<ElemValuePair> elemValuePairs;\n+    int annotationLength = 0;\n+\n+    \/**\n+     * AnnotationElemValue\n+     *\n+     * Used to store Annotation Data\n+     *\/\n+    static public class ElemValuePair implements Data {\n+\n+        ConstantPool.ConstCell name;\n+        Data value;\n+\n+        public ElemValuePair(ConstantPool.ConstCell name, Data value) {\n+            this.name = name;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            name.write(out);\n+            value.write(out);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2 + value.getLength();\n+        }\n+    }\n+\n+    public AnnotationData(Argument typeCPX, boolean invisible) {\n+        this.typeCPX = typeCPX;\n+        this.elemValuePairs = new ArrayList<>();\n+        this.invisible = invisible;\n+    }\n+\n+    public void add(ElemValuePair elemValuePair) {\n+        elemValuePairs.add(elemValuePair);\n+        annotationLength += elemValuePair.getLength();\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        out.writeShort(typeCPX.arg);\n+        out.writeShort(elemValuePairs.size());\n+\n+        for (Data pair : elemValuePairs) {\n+            pair.write(out);\n+        }\n+    }\n+\n+    @Override\n+    public int getLength() {\n+        return 4 + annotationLength;\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/AnnotationData.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+\/**\n+ *\n+ *\/\n+class Argument {\n+\n+    static final int NotSet = -1;\n+    int arg;\n+\n+    Argument() {\n+        arg = NotSet;\n+    }\n+\n+    Argument(int arg) {\n+        this.arg = arg;\n+    }\n+\n+    public int hashCode() {\n+        return arg;\n+    }\n+\n+    \/**\n+     * Compares this object to the specified object.\n+     *\n+     * @param obj the object to compare with\n+     * @return true if the objects are the same; false otherwise.\n+     *\/\n+    public boolean equals(Object obj) {\n+        throw new Parser.CompilerError(\"ConstCell.equals\");\n+    }\n+\n+    boolean isSet() {\n+        return arg != NotSet;\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Argument.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * AttrData\n+ *\n+ * AttrData is the base class for many attributes (or parts of attributes), and it is\n+ * instantiated directly for simple attributes (like Synthetic or Deprecated).\n+ *\/\n+class AttrData implements Data {\n+\n+    private final ClassData clsData;\n+    private final Argument attrNameCPX;\n+\n+    AttrData(ClassData cdata, String name) {\n+        clsData = cdata;\n+        attrNameCPX = cdata.pool.FindCellAsciz(name);\n+    }\n+\n+    protected ClassData getClassData() {\n+        return clsData;\n+    }\n+\n+    \/\/ full length of the attribute\n+    \/\/ declared in Data\n+    public int getLength() {\n+        return 6 + attrLength();\n+    }\n+\n+    \/\/ subclasses must redefine this\n+    public int attrLength() {\n+        return 0;\n+    }\n+\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        out.writeShort(attrNameCPX.arg);\n+        out.writeInt(attrLength()); \/\/ attr len\n+    }\n+} \/\/ end class AttrData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/AttrData.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+\/**\n+ *\n+ *\/\n+class BootstrapMethodData extends Argument implements Data {\n+\n+    ConstantPool.ConstCell bootstrapMethodHandle;\n+    ArrayList<ConstantPool.ConstCell> arguments;\n+    public int placeholder_index = -1;\n+\n+    public BootstrapMethodData(ConstantPool.ConstCell bsmHandle, ArrayList<ConstantPool.ConstCell> arguments) {\n+        super();\n+        this.bootstrapMethodHandle = bsmHandle;\n+        this.arguments = arguments;\n+    }\n+\n+    public BootstrapMethodData(int placeholder) {\n+        super();\n+        this.bootstrapMethodHandle = null;\n+        this.arguments = null;\n+        this.placeholder_index = placeholder;\n+    }\n+\n+    public int getLength() {\n+        return 4 + arguments.size() * 2;\n+    }\n+\n+    public boolean isPlaceholder() {\n+        return placeholder_index > -1;\n+    }\n+\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        out.writeShort(bootstrapMethodHandle.arg);\n+        out.writeShort(arguments.size());\n+\n+        for (ConstantPool.ConstCell argument : arguments) {\n+            out.writeShort(argument.arg);\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/BootstrapMethodData.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+\/*\n+ * Class File Version\n+ *\/\n+public class CFVersion implements Cloneable{\n+    \/**\n+     * Default versions of class file\n+     *\/\n+    public static final short DEFAULT_MAJOR_VERSION = 45;\n+    public static final short DEFAULT_MINOR_VERSION = 3;\n+    public static final short DEFAULT_MODULE_MAJOR_VERSION = 53;\n+    public static final short DEFAULT_MODULE_MINOR_VERSION = 0;\n+    public static final short UNDEFINED_VERSION = -1;\n+\n+    private short major_version;\n+    private short minor_version;\n+    private boolean frozen;\n+    private boolean isSet;\n+\n+    public CFVersion() {\n+        frozen = false;\n+        isSet = false;\n+        major_version = UNDEFINED_VERSION;\n+        minor_version = UNDEFINED_VERSION;\n+    }\n+\n+    public CFVersion(boolean frozenCFV, short major_version, short minor_version) {\n+        isSet = true;\n+        frozen = frozenCFV;\n+        this.major_version = major_version;\n+        this.minor_version = minor_version;\n+    }\n+\n+    public void setMajorVersion(short major_version) {\n+        if ( !frozen ) {\n+            isSet = true;\n+            this.major_version = major_version;\n+        }\n+    }\n+\n+    public void setMinorVersion(short minor_version) {\n+        if (!frozen) {\n+            isSet = true;\n+            this.minor_version = minor_version;\n+        }\n+    }\n+\n+    public String asString() {\n+        return (isSet) ? this.major_version + \":\" +this.minor_version : \"(undef):(undef)\";\n+    }\n+\n+    public void initModuleDefaults() {\n+        if( ! isSet) {\n+            major_version = DEFAULT_MODULE_MAJOR_VERSION;\n+            minor_version = DEFAULT_MODULE_MINOR_VERSION;\n+        }\n+    }\n+\n+    public void initClassDefaults() {\n+        if( !isSet ) {\n+            major_version = DEFAULT_MAJOR_VERSION;\n+            minor_version = DEFAULT_MINOR_VERSION;\n+        }\n+    }\n+\n+    public short minor_version() {\n+        return this.minor_version;\n+    }\n+\n+    public short major_version() {\n+        return this.major_version;\n+    }\n+\n+    public CFVersion clone() {\n+        try {\n+            return (CFVersion)super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/CFVersion.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * Constant Pool Index Attribute\n+ *\/\n+class CPXAttr extends AttrData {\n+\n+    Argument cell;\n+\n+    public CPXAttr(ClassData cls, String attrName, Argument cell) {\n+        super(cls, attrName);\n+        this.cell = cell;\n+    }\n+\n+    public int attrLength() {\n+        return 2;\n+    }\n+\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        super.write(out);  \/\/ attr name, attr len\n+        out.writeShort(cell.arg);\n+    }\n+} \/\/ end class CPXAttr\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/CPXAttr.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+\/**\n+ *\n+ *\/\n+public interface CheckedDataOutputStream {\n+\n+    public void write(int b) throws IOException;\n+\n+    public void write(byte b[], int off, int len) throws IOException;\n+\n+    public void writeBoolean(boolean v) throws IOException;\n+\n+    public void writeByte(int v) throws IOException;\n+\n+    public void writeShort(int v) throws IOException;\n+\n+    public void writeChar(int v) throws IOException;\n+\n+    public void writeInt(int v) throws IOException;\n+\n+    public void writeLong(long v) throws IOException;\n+\n+    public void writeFloat(float v) throws IOException;\n+\n+    public void writeDouble(double v) throws IOException;\n+\n+    public void writeBytes(String s) throws IOException;\n+\n+    public void writeChars(String s) throws IOException;\n+\n+    public void writeUTF(String s) throws IOException;\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/CheckedDataOutputStream.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+\/**\n+ * Base class of the \"classes[]\" data of attributes\n+ * <p>\n+ * JEP 181 (Nest-based Access Control): class file 55.0\n+ * NestMembers_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ * <p>\n+ * JEP 360 (Sealed types): class file 59.65535\n+ * PermittedSubclasses_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ *\/\n+public class ClassArrayAttr extends AttrData {\n+\n+    List<ConstantPool.ConstCell> classes;\n+\n+    public ClassArrayAttr(String attributeName, ClassData cdata, List<ConstantPool.ConstCell> classes) {\n+        super(cdata, attributeName);\n+        this.classes = classes;\n+    }\n+\n+    @Override\n+    public int attrLength() {\n+        return 2 + classes.size() * 2;\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        super.write(out);\n+        out.writeShort(classes.size());\n+        for (ConstantPool.ConstCell c : classes) {\n+            out.writeShort(c.arg);\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ClassArrayAttr.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,641 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+\n+\/**\n+ * ClassData\n+ *\n+ * This is the main data structure for representing parsed class data. This structure\n+ * renders directly to a class file.\n+ *\n+ *\/\n+class ClassData extends MemberData {\n+\n+    \/* ClassData Fields *\/\n+    CFVersion cfv;\n+    ConstantPool.ConstCell me, father;\n+    String myClassName;\n+    AttrData sourceFileNameAttr;\n+    ArrayList<Argument> interfaces;\n+    ArrayList<FieldData> fields = new ArrayList<>();\n+    ArrayList<MethodData> methods = new ArrayList<>();\n+    DataVectorAttr<InnerClassData> innerClasses = null;\n+    DataVectorAttr<BootstrapMethodData> bootstrapMethodsAttr = null;\n+\n+    \/\/ JEP 181 - NestHost, NestMembers attributes since class version 55.0\n+    CPXAttr nestHostAttr;\n+    NestMembersAttr nestMembersAttr;\n+\n+    \/\/ JEP 359 - Record attribute since class file 58.65535\n+    private RecordData recordData;\n+\n+    \/\/ JEP 360 - PermittedSubclasses attribute since class file 59.65535\n+    private PermittedSubclassesAttr permittedSubclassesAttr;\n+\n+    ModuleAttr moduleAttribute = null;\n+    Environment env;\n+    protected ConstantPool pool;\n+\n+    private static final String DEFAULT_EXTENSION = \".class\";\n+    String fileExtension = DEFAULT_EXTENSION;\n+    public CDOutputStream cdos;\n+\n+    \/**\n+     * Initializes the ClassData.\n+     *\n+     * @param me The constant pool reference to this class\n+     * @param father The constant pool reference to the super class\n+     * @param interfaces A list of interfaces that this class implements\n+     *\/\n+    public final void init(int access, ConstantPool.ConstCell me, ConstantPool.ConstCell father, ArrayList<Argument> interfaces) {\n+        this.access = access;\n+\n+        \/\/ normalize the modifiers to access flags\n+        if (Modifiers.hasPseudoMod(access)) {\n+            createPseudoMod();\n+        }\n+\n+        this.me = me;\n+        if (father == null) {\n+            father = pool.FindCellClassByName(\"java\/lang\/Object\");\n+        }\n+        this.father = father;\n+        this.interfaces = interfaces;\n+        \/\/ Set default class file version if it is not set.\n+        cfv.initClassDefaults();\n+    }\n+\n+    public final void initAsModule() {\n+        this.access = RuntimeConstants.ACC_MODULE;\n+        \/\/ this_class\" module-info\n+        this.me = pool.FindCellClassByName(\"module-info\");\n+        \/\/ super_class: zero\n+        this.father = new ConstantPool.ConstCell(0);\n+        cfv.initModuleDefaults();\n+    }\n+\n+    \/**\n+     * canonical default constructor\n+     *\n+     * @param env The error reporting environment.\n+     * @param cfv The class file version that this class file supports.\n+     *\/\n+    public ClassData(Environment env, CFVersion cfv) {\n+        super(null, 0);  \/\/ for a class, these get inited in the super - later.\n+        cls = this;\n+\n+        this.env = env;\n+        this.cfv = cfv;\n+\n+        pool = new ConstantPool(env);\n+        cdos = new CDOutputStream();\n+    }\n+\n+    \/**\n+     * Predicate that describes if this class has an access flag indicating that it is an\n+     * interface.\n+     *\n+     * @return True if the classes access flag indicates it is an interface.\n+     *\/\n+    public final boolean isInterface() {\n+        return Modifiers.isInterface(access);\n+    }\n+\n+    \/*\n+     * After a constant pool has been explicitly declared,\n+     * this method links the Constant_InvokeDynamic Constant_Dynamic\n+     * constants with any bootstrap methods that they index in the\n+     * Bootstrap Methods Attribute\n+     *\/\n+    protected void relinkBootstrapMethods() {\n+        if (bootstrapMethodsAttr == null) {\n+            return;\n+        }\n+\n+        env.traceln(\"relinkBootstrapMethods\");\n+\n+        for (ConstantPool.ConstCell cell : pool) {\n+            ConstantPool.ConstValue ref = null;\n+            if (cell != null) {\n+                ref = cell.ref;\n+            }\n+            if (ref != null\n+                    && (ref.tag == ConstType.CONSTANT_INVOKEDYNAMIC || ref.tag == ConstType.CONSTANT_DYNAMIC)) {\n+                \/\/ Find only the Constant\n+                ConstantPool.ConstValue_IndyOrCondyPair refval = (ConstantPool.ConstValue_IndyOrCondyPair) ref;\n+                BootstrapMethodData bsmdata = refval.bsmData;\n+                \/\/ only care about BSM Data that were placeholders\n+                if (bsmdata != null && bsmdata.isPlaceholder()) {\n+                    \/\/ find the real BSM Data at the index\n+                    int bsmindex = bsmdata.placeholder_index;\n+                    if (bsmindex < 0 || bsmindex > bootstrapMethodsAttr.size()) {\n+                        \/\/ bad BSM index --\n+                        \/\/ give a warning, but place the index in the arg anyway\n+                        env.traceln(\"Warning: (ClassData.relinkBootstrapMethods()): Bad bootstrapMethods index: \" + bsmindex);\n+                        \/\/ env.error(\"const.bsmindex\", bsmindex);\n+                        bsmdata.arg = bsmindex;\n+                    } else {\n+\n+                        BootstrapMethodData realbsmdata = bootstrapMethodsAttr.get(bsmindex);\n+                        \/\/ make the IndyPairs BSM Data point to the one from the attribute\n+                        refval.bsmData = realbsmdata;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void numberBootstrapMethods() {\n+        env.traceln(\"Numbering Bootstrap Methods\");\n+        if (bootstrapMethodsAttr == null) {\n+            return;\n+        }\n+\n+        int index = 0;\n+        for (BootstrapMethodData data : bootstrapMethodsAttr) {\n+            data.arg = index++;\n+        }\n+    }\n+\n+    \/\/ API\n+    \/\/ Record\n+    public RecordData setRecord(int where) {\n+        if( recordAttributeExists() ) {\n+            env.error(where, \"warn.record.repeated\");\n+        }\n+        this.recordData = new RecordData(cls);\n+        return this.recordData;\n+    }\n+\n+    \/**\n+     * Rejects a record: removes the record attribute if there are no components\n+     *\/\n+    public void rejectRecord() {\n+        this.recordData = null;\n+    }\n+\n+    \/\/ Field\n+    public ConstantPool.ConstValue_Pair mkNape(ConstantPool.ConstCell name, ConstantPool.ConstCell sig) {\n+        return new ConstantPool.ConstValue_Pair(ConstType.CONSTANT_NAMEANDTYPE, name, sig);\n+    }\n+\n+    public ConstantPool.ConstValue_Pair mkNape(String name, String sig) {\n+        return mkNape(pool.FindCellAsciz(name), pool.FindCellAsciz(sig));\n+    }\n+\n+    public FieldData addFieldIfAbsent(int access, ConstantPool.ConstCell name, ConstantPool.ConstCell sig) {\n+        ConstantPool.ConstValue_Pair nape = mkNape(name, sig);\n+        env.traceln(\" [ClassData.addFieldIfAbsent]:  #\" + nape.left.arg + \":#\" + nape.right.arg);\n+        FieldData fd = getField(nape);\n+        if( fd == null ) {\n+            env.traceln(\" [ClassData.addFieldIfAbsent]:  new field.\");\n+            fd = addField(access,nape);\n+        }\n+        return fd;\n+    }\n+\n+    private FieldData getField(ConstantPool.ConstValue_Pair nape) {\n+        for (FieldData fd : fields) {\n+            if( fd.getNameDesc().equals(nape) ) {\n+                return fd;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public FieldData addField(int access, ConstantPool.ConstValue_Pair nape) {\n+        env.traceln(\" [ClassData.addField]:  #\" + nape.left.arg + \":#\" + nape.right.arg);\n+        FieldData res = new FieldData(this, access, nape);\n+        fields.add(res);\n+        return res;\n+    }\n+\n+    public FieldData addField(int access, ConstantPool.ConstCell name, ConstantPool.ConstCell sig) {\n+        return addField(access, mkNape(name, sig));\n+    }\n+\n+    public FieldData addField(int access, String name, String type) {\n+        return addField(access, pool.FindCellAsciz(name), pool.FindCellAsciz(type));\n+    }\n+\n+    public ConstantPool.ConstCell LocalFieldRef(FieldData field) {\n+        return pool.FindCell(ConstType.CONSTANT_FIELD, me, pool.FindCell(field.getNameDesc()));\n+    }\n+\n+    public ConstantPool.ConstCell LocalFieldRef(ConstantPool.ConstValue nape) {\n+        return pool.FindCell(ConstType.CONSTANT_FIELD, me, pool.FindCell(nape));\n+    }\n+\n+    public ConstantPool.ConstCell LocalFieldRef(ConstantPool.ConstCell name, ConstantPool.ConstCell sig) {\n+        return LocalFieldRef(mkNape(name, sig));\n+    }\n+\n+    public ConstantPool.ConstCell LocalFieldRef(String name, String sig) {\n+        return LocalFieldRef(pool.FindCellAsciz(name), pool.FindCellAsciz(sig));\n+    }\n+\n+    MethodData curMethod;\n+\n+    public MethodData StartMethod(int access, ConstantPool.ConstCell name, ConstantPool.ConstCell sig, ArrayList exc_table) {\n+        EndMethod();\n+        env.traceln(\" [ClassData.StartMethod]:  #\" + name.arg + \":#\" + sig.arg);\n+        curMethod = new MethodData(this, access, name, sig, exc_table);\n+        methods.add(curMethod);\n+        return curMethod;\n+    }\n+\n+    public void EndMethod() {\n+        curMethod = null;\n+    }\n+\n+    public ConstantPool.ConstCell LocalMethodRef(ConstantPool.ConstValue nape) {\n+        return pool.FindCell(ConstType.CONSTANT_METHOD, me, pool.FindCell(nape));\n+    }\n+\n+    public ConstantPool.ConstCell LocalMethodRef(ConstantPool.ConstCell name, ConstantPool.ConstCell sig) {\n+        return LocalMethodRef(mkNape(name, sig));\n+    }\n+\n+    void addLocVarData(int opc, Argument arg) {\n+    }\n+\n+    public void addInnerClass(int access, ConstantPool.ConstCell name, ConstantPool.ConstCell innerClass, ConstantPool.ConstCell outerClass) {\n+        env.traceln(\"addInnerClass (with indexes: Name (\" + name.toString() + \"), Inner (\" + innerClass.toString() + \"), Outer (\" + outerClass.toString() + \").\");\n+        if (innerClasses == null) {\n+            innerClasses = new DataVectorAttr<>(this, AttrTag.ATT_InnerClasses.parsekey());\n+        }\n+        innerClasses.add(new InnerClassData(access, name, innerClass, outerClass));\n+    }\n+\n+    public void addBootstrapMethod(BootstrapMethodData bsmData) {\n+        env.traceln(\"addBootstrapMethod\");\n+        if (bootstrapMethodsAttr == null) {\n+            bootstrapMethodsAttr = new DataVectorAttr<>(this, AttrTag.ATT_BootstrapMethods.parsekey());\n+        }\n+        bootstrapMethodsAttr.add(bsmData);\n+    }\n+\n+    public void addNestHost(ConstantPool.ConstCell hostClass) {\n+        env.traceln(\"addNestHost\");\n+        nestHostAttr = new CPXAttr(this, AttrTag.ATT_NestHost.parsekey(), hostClass);\n+    }\n+\n+    public void addNestMembers(List<ConstantPool.ConstCell> classes) {\n+        env.traceln(\"addNestMembers\");\n+        nestMembersAttr = new NestMembersAttr(this, classes);\n+    }\n+\n+    public void addPermittedSubclasses(List<ConstantPool.ConstCell> classes) {\n+        env.traceln(\"addPermittedSubclasses\");\n+        permittedSubclassesAttr = new PermittedSubclassesAttr(this, classes);\n+    }\n+\n+\n+    public void endClass() {\n+        sourceFileNameAttr = new CPXAttr(this,\n+                AttrTag.ATT_SourceFile.parsekey(),\n+                pool.FindCellAsciz(env.getSimpleInputFileName()));\n+        pool.NumberizePool();\n+        pool.CheckGlobals();\n+        numberBootstrapMethods();\n+        try {\n+            me = pool.uncheckedGetCell(me.arg);\n+            env.traceln(\"me=\" + me);\n+            ConstantPool.ConstValue_Cell me_value = (ConstantPool.ConstValue_Cell) me.ref;\n+            ConstantPool.ConstCell ascicell = me_value.cell;\n+            env.traceln(\"ascicell=\" + ascicell);\n+            ConstantPool.ConstValue_String me_str = (ConstantPool.ConstValue_String) ascicell.ref;\n+            myClassName = me_str.value;\n+            env.traceln(\"-------------------\");\n+            env.traceln(\"-- Constant Pool --\");\n+            env.traceln(\"-------------------\");\n+            pool.printPool();\n+            env.traceln(\"-------------------\");\n+            env.traceln(\" \");\n+            env.traceln(\" \");\n+            env.traceln(\"-------------------\");\n+            env.traceln(\"-- Inner Classes --\");\n+            env.traceln(\"-------------------\");\n+            printInnerClasses();\n+\n+        } catch (Throwable e) {\n+            env.traceln(\"check name:\" + e);\n+            env.error(\"no.classname\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void endModule(ModuleAttr moduleAttr) {\n+        moduleAttribute = moduleAttr.build();\n+        pool.NumberizePool();\n+        pool.CheckGlobals();\n+        myClassName = \"module-info\";\n+    }\n+\n+    private void printInnerClasses() {\n+        if (innerClasses != null) {\n+            int i = 1;\n+            for (InnerClassData entry : innerClasses) {\n+                env.trace(\" InnerClass[\" + i + \"]: (\" + Modifiers.toString(entry.access, CF_Context.CTX_INNERCLASS) + \"]), \");\n+                env.trace(\"Name:  \" + entry.name.toString() + \" \");\n+                env.trace(\"IC_info:  \" + entry.innerClass.toString() + \" \");\n+                env.trace(\"OC_info:  \" + entry.outerClass.toString() + \" \");\n+                env.traceln(\" \");\n+                i += 1;\n+            }\n+        } else {\n+            env.traceln(\"<< NO INNER CLASSES >>\");\n+        }\n+\n+    }\n+\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+\n+        \/\/ Write the header\n+        out.writeInt(JAVA_MAGIC);\n+        out.writeShort(cfv.minor_version());\n+        out.writeShort(cfv.major_version());\n+\n+        pool.write(out);\n+        out.writeShort(access); \/\/ & MM_CLASS; \/\/ Q\n+        out.writeShort(me.arg);\n+        out.writeShort(father.arg);\n+\n+        \/\/ Write the interface names\n+        if (interfaces != null) {\n+            out.writeShort(interfaces.size());\n+            for (Argument intf : interfaces) {\n+                out.writeShort(intf.arg);\n+            }\n+        } else {\n+            out.writeShort(0);\n+        }\n+\n+        \/\/ Write the fields\n+        if (fields != null) {\n+            out.writeShort(fields.size());\n+            for (FieldData field : fields) {\n+                field.write(out);\n+            }\n+        } else {\n+            out.writeShort(0);\n+        }\n+\n+        \/\/ Write the methods\n+        if (methods != null) {\n+            out.writeShort(methods.size());\n+            for (MethodData method : methods) {\n+                method.write(out);\n+            }\n+        } else {\n+            out.writeShort(0);\n+        }\n+\n+        \/\/ Write the attributes\n+        DataVector attrs = getAttrVector();\n+        attrs.write(out);\n+    } \/\/ end ClassData.write()\n+\n+    @Override\n+    protected DataVector getAttrVector() {\n+        DataVector attrs = new DataVector();\n+        if( moduleAttribute != null ) {\n+            if (annotAttrVis != null)\n+                attrs.add(annotAttrVis);\n+            if (annotAttrInv != null)\n+                attrs.add(annotAttrInv);\n+            attrs.add(moduleAttribute);\n+        } else {\n+            attrs.add(sourceFileNameAttr);\n+            \/\/ JEP 359 since class file 58.65535\n+            if( recordData != null ) {\n+                attrs.add(recordData);\n+            }\n+            if (innerClasses != null)\n+                attrs.add(innerClasses);\n+            if (syntheticAttr != null)\n+                attrs.add(syntheticAttr);\n+            if (deprecatedAttr != null)\n+                attrs.add(deprecatedAttr);\n+            if (annotAttrVis != null)\n+                attrs.add(annotAttrVis);\n+            if (annotAttrInv != null)\n+                attrs.add(annotAttrInv);\n+            if (type_annotAttrVis != null)\n+                attrs.add(type_annotAttrVis);\n+            if (type_annotAttrInv != null)\n+                attrs.add(type_annotAttrInv);\n+            if (bootstrapMethodsAttr != null)\n+                attrs.add(bootstrapMethodsAttr);\n+            \/\/ since class version 55.0\n+            if(nestHostAttributeExists())\n+                attrs.add(nestHostAttr);\n+            if(nestMembersAttributesExist())\n+                attrs.add(nestMembersAttr);\n+            \/\/ since class version 59.65535 (JEP 360)\n+            if ( permittedSubclassesAttributesExist() )\n+                attrs.add(permittedSubclassesAttr);\n+        }\n+        return attrs;\n+    }\n+\n+    static char fileSeparator; \/\/=System.getProperty(\"file.separator\");\n+\n+    \/**\n+     * Writes to the directory passed with -d option\n+     *\/\n+    public void write(File destdir) throws IOException {\n+        File outfile;\n+        if (destdir == null) {\n+            int startofname = myClassName.lastIndexOf(\"\/\");\n+            if (startofname != -1) {\n+                myClassName = myClassName.substring(startofname + 1);\n+            }\n+            outfile = new File(myClassName + fileExtension);\n+        } else {\n+            env.traceln(\"writing -d \" + destdir.getPath());\n+            if (fileSeparator == 0) {\n+                fileSeparator = System.getProperty(\"file.separator\").charAt(0);\n+            }\n+            if (fileSeparator != '\/') {\n+                myClassName = myClassName.replace('\/', fileSeparator);\n+            }\n+            outfile = new File(destdir, myClassName + fileExtension);\n+            File outdir = new File(outfile.getParent());\n+            if (!outdir.exists() && !outdir.mkdirs()) {\n+                env.error(\"cannot.write\", outdir.getPath());\n+                return;\n+            }\n+        }\n+\n+        DataOutputStream dos = new DataOutputStream(\n+                new BufferedOutputStream(new FileOutputStream(outfile)));\n+        cdos.setDataOutputStream(dos);\n+        try {\n+            write(cdos);\n+        } finally {\n+            dos.close();\n+        }\n+    }  \/\/ end write()\n+\n+    public void setByteLimit(int bytelimit) {\n+        cdos.enable();\n+        cdos.setLimit(bytelimit);\n+    }\n+\n+    public boolean nestHostAttributeExists() {\n+        return nestHostAttr != null;\n+    }\n+\n+    public boolean nestMembersAttributesExist() { return nestMembersAttr != null;  }\n+\n+    public boolean permittedSubclassesAttributesExist() { return permittedSubclassesAttr != null;  }\n+\n+    public boolean recordAttributeExists() { return recordData != null;  }\n+\n+    \/**\n+     * This is a wrapper for DataOutputStream, used for debugging purposes. it allows\n+     * writing the byte-stream of a class up to a given byte number.\n+     *\/\n+    static private class CDOutputStream implements CheckedDataOutputStream {\n+\n+        private int bytelimit;\n+        private DataOutputStream dos;\n+        public boolean enabled = false;\n+\n+        public CDOutputStream() {\n+            dos = null;\n+        }\n+\n+        public CDOutputStream(OutputStream out) {\n+            setOutputStream(out);\n+        }\n+\n+        public final void setOutputStream(OutputStream out) {\n+            dos = new DataOutputStream(out);\n+        }\n+\n+        public void setDataOutputStream(DataOutputStream dos) {\n+            this.dos = dos;\n+        }\n+\n+        public void setLimit(int lim) {\n+            bytelimit = lim;\n+        }\n+\n+        public void enable() {\n+            enabled = true;\n+        }\n+\n+        private synchronized void check(String loc) throws IOException {\n+            if (enabled && dos.size() >= bytelimit) {\n+                throw new IOException(loc);\n+            }\n+        }\n+\n+        @Override\n+        public synchronized void write(int b) throws IOException {\n+            dos.write(b);\n+            check(\"Writing byte: \" + b);\n+        }\n+\n+        @Override\n+        public synchronized void write(byte b[], int off, int len) throws IOException {\n+            dos.write(b, off, len);\n+            check(\"Writing byte-array: \" + b);\n+        }\n+\n+        @Override\n+        public final void writeBoolean(boolean v) throws IOException {\n+            dos.writeBoolean(v);\n+            check(\"Writing writeBoolean: \" + (v ? \"true\" : \"false\"));\n+        }\n+\n+        @Override\n+        public final void writeByte(int v) throws IOException {\n+            dos.writeByte(v);\n+            check(\"Writing writeByte: \" + v);\n+        }\n+\n+        @Override\n+        public void writeShort(int v) throws IOException {\n+            dos.writeShort(v);\n+            check(\"Writing writeShort: \" + v);\n+        }\n+\n+        @Override\n+        public void writeChar(int v) throws IOException {\n+            dos.writeChar(v);\n+            check(\"Writing writeChar: \" + v);\n+        }\n+\n+        @Override\n+        public void writeInt(int v) throws IOException {\n+            dos.writeInt(v);\n+            check(\"Writing writeInt: \" + v);\n+        }\n+\n+        @Override\n+        public void writeLong(long v) throws IOException {\n+            dos.writeLong(v);\n+            check(\"Writing writeLong: \" + v);\n+        }\n+\n+        @Override\n+        public void writeFloat(float v) throws IOException {\n+            dos.writeFloat(v);\n+            check(\"Writing writeFloat: \" + v);\n+        }\n+\n+        @Override\n+        public void writeDouble(double v) throws IOException {\n+            dos.writeDouble(v);\n+            check(\"Writing writeDouble: \" + v);\n+        }\n+\n+        @Override\n+        public void writeBytes(String s) throws IOException {\n+            dos.writeBytes(s);\n+            check(\"Writing writeBytes: \" + s);\n+        }\n+\n+        @Override\n+        public void writeChars(String s) throws IOException {\n+            dos.writeChars(s);\n+            check(\"Writing writeChars: \" + s);\n+        }\n+\n+        @Override\n+        public void writeUTF(String s) throws IOException {\n+            dos.writeUTF(s);\n+            check(\"Writing writeUTF: \" + s);\n+        }\n+    }\n+}\/\/ end class ClassData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ClassData.java","additions":641,"deletions":0,"binary":false,"changes":641,"status":"added"},{"patch":"@@ -0,0 +1,529 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.jasm.OpcodeTables.Opcode;\n+import org.openjdk.asmtools.jasm.Tables.AttrTag;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import static org.openjdk.asmtools.jasm.RuntimeConstants.SPLIT_VERIFIER_CFV;\n+\n+class CodeAttr extends AttrData {\n+\n+    protected ClassData cls;\n+\n+    protected MethodData mtd;\n+    protected Environment env;\n+    protected Argument max_stack, max_locals;\n+    protected Instr zeroInstr, lastInstr;\n+    protected int cur_pc = 0;\n+    protected DataVector<TrapData> trap_table; \/\/ TrapData\n+    protected DataVectorAttr<LineNumData> lin_num_tb; \/\/ LineNumData\n+    protected int lastln = 0;\n+    protected DataVectorAttr<LocVarData> loc_var_tb;  \/\/ LocVarData\n+    protected DataVector<DataVectorAttr<? extends Data>> attrs;\n+    protected ArrayList<Integer> slots;\n+    protected HashMap<String, LocVarData> locvarsHash;\n+    protected HashMap<String, Label> labelsHash;\n+    protected HashMap<String, Trap> trapsHash;\n+    protected StackMapData curMapEntry = null;\n+    protected DataVectorAttr<StackMapData> stackMap;\n+    \/\/ type annotations\n+    protected DataVectorAttr<TypeAnnotationData> type_annotAttrVis = null;\n+    protected DataVectorAttr<TypeAnnotationData> type_annotAttrInv = null;\n+\n+    public CodeAttr(MethodData mtd, int pos, int paramcnt, Argument max_stack, Argument max_locals) {\n+        super(mtd.cls, AttrTag.ATT_Code.parsekey());\n+        this.mtd = mtd;\n+        this.cls = mtd.cls;\n+        this.env = cls.env;\n+        this.max_stack = max_stack;\n+        this.max_locals = max_locals;\n+        lastInstr = zeroInstr = new Instr();\n+        trap_table = new DataVector<>(0); \/\/ TrapData\n+        attrs = new DataVector<>();\n+        if (env.debugInfoFlag) {\n+            lin_num_tb = new DataVectorAttr<>(cls, AttrTag.ATT_LineNumberTable.parsekey());\n+            attrs.add(lin_num_tb);\n+        }\n+        slots = new ArrayList<>(paramcnt);\n+        for (int k = 0; k < paramcnt; k++) {\n+            slots.add(k, 1);\n+        }\n+    }\n+\n+    void endCode() {\n+        checkTraps();\n+        checkLocVars();\n+        checkLabels();\n+        \/\/\n+        if (type_annotAttrVis != null) {\n+            attrs.add(type_annotAttrVis);\n+        }\n+        if (type_annotAttrInv != null) {\n+            attrs.add(type_annotAttrInv);\n+        }\n+    }\n+\n+    public void addAnnotations(ArrayList<AnnotationData> list) {\n+        for (AnnotationData item : list) {\n+            boolean invisible = item.invisible;\n+            if (item instanceof TypeAnnotationData) {\n+                \/\/ Type Annotations\n+                TypeAnnotationData ta = (TypeAnnotationData) item;\n+                if (invisible) {\n+                    if (type_annotAttrInv == null) {\n+                        type_annotAttrInv = new DataVectorAttr(cls,\n+                                AttrTag.ATT_RuntimeInvisibleTypeAnnotations.parsekey());\n+                    }\n+                    type_annotAttrInv.add(ta);\n+                } else {\n+                    if (type_annotAttrVis == null) {\n+                        type_annotAttrVis = new DataVectorAttr(cls,\n+                                AttrTag.ATT_RuntimeVisibleTypeAnnotations.parsekey());\n+                    }\n+                    type_annotAttrVis.add(ta);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/* -------------------------------------- Traps *\/\n+    Trap trapDecl(int pos, String name) {\n+        Trap local;\n+        if (trapsHash == null) {\n+            trapsHash = new HashMap<>(10);\n+            local = null;\n+        } else {\n+            local = trapsHash.get(name);\n+        }\n+        if (local == null) {\n+            local = new Trap(pos, name);\n+            trapsHash.put(name, local);\n+        }\n+        return local;\n+    }\n+\n+    void beginTrap(int pos, String name) {\n+        Trap trap = trapDecl(pos, name);\n+        if (trap.start_pc != Argument.NotSet) {\n+            env.error(\"trap.tryredecl\", name);\n+            return;\n+        }\n+        trap.start_pc = cur_pc;\n+    }\n+\n+    void endTrap(int pos, String name) {\n+        Trap trap = trapDecl(pos, name);\n+        if (trap.end_pc != Argument.NotSet) {\n+            env.error(\"trap.endtryredecl\", name);\n+            return;\n+        }\n+        trap.end_pc = cur_pc;\n+    }\n+\n+    void trapHandler(int pos, String name, Argument type) {\n+        Trap trap = trapDecl(pos, name);\n+        trap.refd = true;\n+        TrapData trapData = new TrapData(pos, trap, cur_pc, type);\n+        trap_table.addElement(trapData);\n+    }\n+\n+    void checkTraps() {\n+        if (trapsHash == null) {\n+            return;\n+        }\n+        for (Trap trap : trapsHash.values()) {\n+            if (!trap.refd) {\n+                env.error(trap.pos, \"warn.trap.notref\", trap.name);\n+            }\n+        }\n+\n+        for (TrapData trapData : trap_table) {\n+            Trap trapLabel = trapData.trap;\n+            if (trapLabel.start_pc == Argument.NotSet) {\n+                env.error(trapData.pos, \"trap.notry\", trapLabel.name);\n+            }\n+            if (trapLabel.end_pc == Argument.NotSet) {\n+                env.error(trapData.pos, \"trap.noendtry\", trapLabel.name);\n+            }\n+        }\n+    }\n+\n+    \/* -------------------------------------- Labels *\/\n+    Label labelDecl(String name) {\n+        Label local;\n+        if (labelsHash == null) {\n+            labelsHash = new HashMap<>(10);\n+            local = null;\n+        } else {\n+            local = labelsHash.get(name);\n+        }\n+        if (local == null) {\n+            local = new Label(name);\n+            labelsHash.put(name, local);\n+        }\n+        return local;\n+    }\n+\n+    public Label LabelDef(int pos, String name) {\n+        Label label = labelDecl(name);\n+        if (label.defd) {\n+            env.error(pos, \"label.redecl\", name);\n+            return null;\n+        }\n+        label.defd = true;\n+        label.arg = cur_pc;\n+        return label;\n+    }\n+\n+    public Label LabelRef(String name) {\n+        Label label = labelDecl(name);\n+        label.refd = true;\n+        return label;\n+    }\n+\n+    void checkLabels() {\n+        if (labelsHash == null) {\n+            return;\n+        }\n+\n+        for (Label local : labelsHash.values()) {\n+            \/\/ check that every label is defined\n+            if (!local.defd) {\n+                env.error(\"label.undecl\", local.name);\n+            }\n+        }\n+    }\n+\n+    \/* -------------------------------------- Variables *\/\n+    LocVarData locvarDecl(String name) {\n+        LocVarData local;\n+        if (locvarsHash == null) {\n+            locvarsHash = new HashMap<>(10);\n+            local = null;\n+        } else {\n+            local = locvarsHash.get(name);\n+        }\n+        if (local == null) {\n+            local = new LocVarData(name);\n+            locvarsHash.put(name, local);\n+        }\n+        return local;\n+    }\n+\n+    public void LocVarDataDef(int slot) {\n+        slots.set(slot, 1);\n+        if ((max_locals != null) && (max_locals.arg < slots.size())) {\n+            env.error(\"warn.illslot\", Integer.toString(slot));\n+        }\n+    }\n+\n+    public void LocVarDataDef(String name, ConstantPool.ConstCell type) {\n+        LocVarData locvar = locvarDecl(name);\n+        if (locvar.defd) {\n+            env.error(\"locvar.redecl\", name);\n+            return;\n+        }\n+        locvar.defd = true;\n+        locvar.start_pc = (short) cur_pc;\n+        locvar.name_cpx = cls.pool.FindCellAsciz(name);\n+        locvar.sig_cpx = type;\n+        int k;\n+        findSlot:\n+        {\n+            for (k = 0; k < slots.size(); k++) {\n+                if (slots.get(k) == 0) {\n+                    break findSlot;\n+                }\n+            }\n+            k = slots.size();\n+        }\n+        LocVarDataDef(k);\n+        locvar.arg = k;\n+        if (loc_var_tb == null) {\n+            loc_var_tb = new DataVectorAttr<>(cls, AttrTag.ATT_LocalVariableTable.parsekey());\n+            attrs.add(loc_var_tb);\n+        }\n+        loc_var_tb.add(locvar);\n+    }\n+\n+    public Argument LocVarDataRef(String name) {\n+        LocVarData locvar = locvarDecl(name);\n+        if (!locvar.defd) {\n+            env.error(\"locvar.undecl\", name);\n+            locvar.defd = true; \/\/ to avoid multiple error messages\n+        }\n+        locvar.refd = true;\n+        return locvar;\n+    }\n+\n+    public void LocVarDataEnd(int slot) {\n+        slots.set(slot, 0);\n+    }\n+\n+    public void LocVarDataEnd(String name) {\n+        LocVarData locvar = locvarsHash.get(name);\n+        if (locvar == null) {\n+            env.error(\"locvar.undecl\", name);\n+            return;\n+        } else if (!locvar.defd) {\n+            env.error(\"locvar.undecl\", name);\n+            return;\n+        }\n+        locvar.length = (short) (cur_pc - locvar.start_pc);\n+\n+        slots.set(locvar.arg, 0);\n+        locvarsHash.put(name, new LocVarData(name));\n+    }\n+\n+    void checkLocVars() {\n+        if (locvarsHash == null) {\n+            return;\n+        }\n+        for (LocVarData locvar : locvarsHash.values()) {\n+            if (!locvar.defd) {\n+                continue;\n+            } \/\/ this is false locvar\n+            \/\/ set end of scope, if not set\n+            if (slots.get(locvar.arg) == 1) {\n+                locvar.length = (short) (cur_pc - locvar.start_pc);\n+                slots.set(locvar.arg, 0);\n+            }\n+        }\n+    }\n+\n+    \/* -------------------------------------- StackMap *\/\n+    public StackMapData getStackMap() {\n+        if (curMapEntry == null) {\n+            curMapEntry = new StackMapData(env);\n+            if (cls.cfv.major_version() >= SPLIT_VERIFIER_CFV) {\n+                curMapEntry.setIsStackMapTable(true);\n+            }\n+        }\n+        return curMapEntry;\n+    }\n+\n+    \/*====================================================== Instr *\/\n+    void addInstr(int mnenoc_pos, Opcode opcode, Argument arg, Object arg2) {\n+        Instr newInstr = new Instr(cur_pc, cls.env.pos, opcode, arg, arg2);\n+        lastInstr.next = newInstr;\n+        lastInstr = newInstr;\n+        int len = opcode.length();\n+        switch (opcode) {\n+            case opc_tableswitch:\n+                len = ((SwitchTable) arg2).recalcTableSwitch(cur_pc);\n+                break;\n+            case opc_lookupswitch:\n+                len = ((SwitchTable) arg2).calcLookupSwitch(cur_pc);\n+                break;\n+            case opc_ldc:\n+                ((ConstantPool.ConstCell) arg).setRank(ConstantPool.ReferenceRank.LDC);\n+                break;\n+            default:\n+                if (arg instanceof ConstantPool.ConstCell) {\n+                    ((ConstantPool.ConstCell) arg).setRank(ConstantPool.ReferenceRank.ANY);\n+                }\n+        }\n+        if (env.debugInfoFlag) {\n+            int ln = env.lineNumber(mnenoc_pos);\n+            if (ln != lastln) { \/\/ only one entry in lin_num_tb per line\n+                lin_num_tb.add(new LineNumData(cur_pc, ln));\n+                lastln = ln;\n+            }\n+        }\n+        if (curMapEntry != null) {\n+            curMapEntry.pc = cur_pc;\n+            StackMapData prevStackFrame = null;\n+            if (stackMap == null) {\n+                if (cls.cfv.major_version() >= SPLIT_VERIFIER_CFV) {\n+                    stackMap = new DataVectorAttr<>(cls, AttrTag.ATT_StackMapTable.parsekey());\n+                } else {\n+                    stackMap = new DataVectorAttr<>(cls, AttrTag.ATT_StackMap.parsekey());\n+                }\n+                attrs.add(stackMap);\n+            } else if (stackMap.size() > 0) {\n+                prevStackFrame = stackMap.get(stackMap.size() - 1);\n+            }\n+            curMapEntry.setOffset(prevStackFrame);\n+            stackMap.add(curMapEntry);\n+            curMapEntry = null;\n+        }\n+\n+        cur_pc += len;\n+    }\n+\n+    \/*====================================================== Attr interface *\/\n+    \/\/ subclasses must redefine this\n+    @Override\n+    public int attrLength() {\n+        return 2 + 2 + 4 \/\/ for max_stack, max_locals, and cur_pc\n+                + cur_pc \/\/      + 2+trap_table.size()*8\n+                + trap_table.getLength() + attrs.getLength();\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out)\n+            throws IOException, Parser.CompilerError {\n+        int mxstck = (max_stack != null) ? max_stack.arg : 0;\n+        int mxloc = (max_locals != null) ? max_locals.arg : slots.size();\n+        super.write(out);  \/\/ attr name, attr len\n+        out.writeShort(mxstck);\n+        out.writeShort(mxloc);\n+        out.writeInt(cur_pc);\n+        for (Instr instr = zeroInstr.next; instr != null; instr = instr.next) {\n+            instr.write(out, env);\n+        }\n+\n+        trap_table.write(out);\n+\n+        attrs.write(out);\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* CodeAttr inner classes *\/\n+    static public class Local extends Argument {\n+\n+        String name;\n+        boolean defd = false, refd = false;\n+\n+        public Local(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    \/**\n+     *\n+     *\/\n+    static public class Label extends Local {\n+\n+        public Label(String name) {\n+            super(name);\n+        }\n+    }\n+\n+    \/**\n+     *\n+     *\/\n+    class LocVarData extends Local implements Data {\n+\n+        \/\/ arg means slot\n+        short start_pc, length;\n+        ConstantPool.ConstCell name_cpx, sig_cpx;\n+\n+        public LocVarData(String name) {\n+            super(name);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 10;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(start_pc);\n+            out.writeShort(length);\n+            out.writeShort(name_cpx.arg);\n+            out.writeShort(sig_cpx.arg);\n+            out.writeShort(arg);\n+        }\n+    }\n+\n+    \/**\n+     *\n+     *\/\n+    class LineNumData implements Data {\n+\n+        int start_pc, line_number;\n+\n+        public LineNumData(int start_pc, int line_number) {\n+            this.start_pc = start_pc;\n+            this.line_number = line_number;\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 4;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(start_pc);\n+            out.writeShort(line_number);\n+        }\n+    }\n+\n+    \/**\n+     *\n+     *\/\n+    class Trap extends Local {\n+\n+        int start_pc = Argument.NotSet, end_pc = Argument.NotSet;\n+        int pos;\n+\n+        Trap(int pos, String name) {\n+            super(name);\n+            this.pos = pos;\n+        }\n+    }\n+\n+    \/**\n+     *\n+     *\/\n+    class TrapData implements Data {\n+\n+        int pos;\n+        Trap trap;\n+        int handler_pc;\n+        Argument catchType;\n+\n+        public TrapData(int pos, Trap trap, int handler_pc, Argument catchType) {\n+            this.pos = pos;\n+            this.trap = trap;\n+            this.handler_pc = handler_pc;\n+            this.catchType = catchType;\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 8; \/\/ add the length of number of elements\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(trap.start_pc);\n+            out.writeShort(trap.end_pc);\n+            out.writeShort(handler_pc);\n+            if (catchType.isSet()) {\n+                out.writeShort(catchType.arg);\n+            } else {\n+                out.writeShort(0);\n+            }\n+        }\n+    }  \/\/ end TrapData\n+} \/\/ end CodeAttr\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/CodeAttr.java","additions":529,"deletions":0,"binary":false,"changes":529,"status":"added"},{"patch":"@@ -0,0 +1,1264 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.jasm.Tables.ConstType;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * ConstantPool\n+ *\n+ * ConstantPool is the class responsible for maintaining constants for a given class file.\n+ *\n+ *\/\n+public class ConstantPool implements Iterable<ConstantPool.ConstCell> {\n+\n+\n+    static public enum ReferenceRank {\n+        LDC(0),  \/\/ 0 - highest - ref from ldc\n+        ANY(1),  \/\/ 1 - any ref\n+        NO(2);   \/\/ 2 - no ref\n+        final int rank;\n+        ReferenceRank(int rank) {\n+            this.rank = rank;\n+        }\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* ConstantPool Inner Classes *\/\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue {\n+\n+        protected ConstType tag;\n+        protected boolean isSet = false;\n+        private boolean visited = false;\n+\n+        public ConstValue(ConstType tag) {\n+            this.tag = tag;\n+        }\n+\n+        public int size() {\n+            return 1;\n+        }\n+\n+        public boolean hasValue() {\n+            return isSet;\n+        }\n+\n+        \/**\n+         * Compute the hash-code, based on the value of the native (_hashCode()) hashcode.\n+         *\/\n+        @Override\n+        public int hashCode() {\n+            if (visited) {\n+                throw new Parser.CompilerError(\"CV hash:\" + this);\n+            }\n+            visited = true;\n+            int res = _hashCode() + tag.value() * 1023;\n+            visited = false;\n+            return res;\n+        }\n+\n+        \/\/ sub-classes override this.\n+        \/\/ this is the default for getting a hash code.\n+        protected int _hashCode() {\n+            return 37;\n+        }\n+\n+        \/**\n+         * Compares this object to the specified object.\n+         *\n+         * Sub-classes must override this\n+         *\n+         * @param obj the object to compare with\n+         * @return true if the objects are the same; false otherwise.\n+         *\/\n+        @Override\n+        public boolean equals(Object obj) {\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String tagstr = tag.printval();\n+            String retval = \"\";\n+            if (tagstr == null) {\n+                return \"BOGUS_TAG:\" + tag;\n+            }\n+\n+            String valueStr = _toString();\n+            if (valueStr != null) {\n+                retval = \"<\" + tagstr + \" \" + valueStr + \">\";\n+            } else {\n+                retval = \"<\" + tagstr + \">\";\n+            }\n+            return retval;\n+        }\n+\n+        protected String _toString() {\n+            return \"\";\n+        }\n+\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte(tag.value());\n+        }\n+    } \/\/ end ConstValue\n+\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_Zero extends ConstValue {\n+\n+        public ConstValue_Zero() {\n+            super(ConstType.CONSTANT_ZERO);\n+            isSet = false;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            throw new Parser.CompilerError(\"Trying to write Constant 0.\");\n+        }\n+    }\n+\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_String extends ConstValue {\n+\n+        String value;\n+\n+        public ConstValue_String(String value) {\n+            super(ConstType.CONSTANT_UTF8);\n+            this.value = value;\n+            isSet = (value != null);\n+        }\n+\n+        @Override\n+        protected String _toString() {\n+            return value;\n+        }\n+\n+        @Override\n+        protected int _hashCode() {\n+            return value.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if ((obj == null) || !(obj instanceof ConstValue_String)) {\n+                return false;\n+            }\n+            ConstValue_String dobj = (ConstValue_String) obj;\n+            if (tag != dobj.tag) {\n+                return false;\n+            }\n+            return value.equals(dobj.value);\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            super.write(out);\n+            out.writeUTF(value);\n+        }\n+    }\n+\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_Integer extends ConstValue {\n+\n+        Integer value;\n+\n+        public ConstValue_Integer(ConstType tag, Integer value) {\n+            super(tag);\n+            this.value = value;\n+            isSet = (value != null);\n+        }\n+\n+        @Override\n+        protected String _toString() {\n+            return value.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if ((obj == null) || !(obj instanceof ConstValue_Integer)) {\n+                return false;\n+            }\n+            ConstValue_Integer dobj = (ConstValue_Integer) obj;\n+            if (tag != dobj.tag) {\n+                return false;\n+            }\n+            return value.equals(dobj.value);\n+        }\n+\n+        @Override\n+        protected int _hashCode() {\n+            return value.hashCode();\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            super.write(out);\n+            out.writeInt(value.intValue());\n+        }\n+    }\n+\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_Long extends ConstValue {\n+\n+        Long value;\n+\n+        public ConstValue_Long(ConstType tag, Long value) {\n+            super(tag);\n+            this.value = value;\n+            isSet = (value != null);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return 2;\n+        }\n+\n+        @Override\n+        protected String _toString() {\n+            return value.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if ((obj == null) || !(obj instanceof ConstValue_Long)) {\n+                return false;\n+            }\n+            ConstValue_Long dobj = (ConstValue_Long) obj;\n+            if (tag != dobj.tag) {\n+                return false;\n+            }\n+            return value.equals(dobj.value);\n+        }\n+\n+        @Override\n+        protected int _hashCode() {\n+            return value.hashCode();\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            super.write(out);\n+            out.writeLong(value.longValue());\n+        }\n+    }\n+\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_Cell extends ConstValue {\n+\n+        ConstCell cell;\n+\n+        public ConstValue_Cell(ConstType tag, ConstCell cell) {\n+            super(tag);\n+            this.cell = cell;\n+            isSet = (cell != null);\n+        }\n+\n+        @Override\n+        protected String _toString() {\n+            return cell.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if ((obj == null) || !(obj instanceof ConstValue_Cell)) {\n+                return false;\n+            }\n+            ConstValue_Cell dobj = (ConstValue_Cell) obj;\n+            if (tag != dobj.tag) {\n+                return false;\n+            }\n+            return cell.equals(dobj.cell);\n+        }\n+\n+        @Override\n+        protected int _hashCode() {\n+            return cell.hashCode();\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            super.write(out);\n+            cell.write(out);\n+        }\n+    }\n+\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_Pair extends ConstValue {\n+\n+        ConstCell left, right;\n+\n+        public ConstValue_Pair(ConstType tag, ConstCell left, ConstCell right) {\n+            super(tag);\n+            this.left = left;\n+            this.right = right;\n+            isSet = (left != null && right != null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if ((obj == null) || !(obj instanceof ConstValue_Pair)) {\n+                return false;\n+            }\n+            ConstValue_Pair dobj = (ConstValue_Pair) obj;\n+            if (tag != dobj.tag) {\n+                return false;\n+            }\n+            if (dobj.left != null)\n+                if (!dobj.left.equals(left))\n+                    return false;\n+            if (dobj.right != null)\n+                if (!dobj.right.equals(right))\n+                    return false;\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return super.toString() + \"{\" + left + \",\" + right + \"}\";\n+        }\n+\n+        @Override\n+        protected int _hashCode() {\n+            return left.hashCode() * right.hashCode();\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            super.write(out);\n+            if (tag == ConstType.CONSTANT_METHODHANDLE) {\n+                out.writeByte(left.arg); \/\/ write subtag value\n+            } else {\n+                out.writeShort(left.arg);\n+            }\n+            out.writeShort(right.arg);\n+        }\n+    }\n+\n+    static public class ConstValue_IndyOrCondyPair extends ConstValue {\n+        BootstrapMethodData bsmData;\n+        ConstantPool.ConstCell napeCell;\n+\n+        protected ConstValue_IndyOrCondyPair(ConstType tag, BootstrapMethodData bsmdata, ConstCell napeCell) {\n+            super(tag);\n+            assert (tag == ConstType.CONSTANT_DYNAMIC && ConstValue_CondyPair.class.isAssignableFrom(getClass())) ||\n+                   tag == ConstType.CONSTANT_INVOKEDYNAMIC && ConstValue_IndyPair.class.isAssignableFrom(getClass());\n+\n+            this.bsmData = bsmdata;\n+            this.napeCell = napeCell;\n+            isSet = (bsmdata != null && napeCell != null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if ((obj == null) || !(getClass().isInstance(obj))) {\n+                return false;\n+            }\n+\n+            ConstValue_IndyOrCondyPair iobj = (ConstValue_IndyOrCondyPair) obj;\n+            return (iobj.bsmData == bsmData) && (iobj.napeCell == napeCell);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return super.toString() + \"{\" + bsmData + \",\" + napeCell + \"}\";\n+        }\n+\n+        @Override\n+        protected int _hashCode() {\n+            if (bsmData.isPlaceholder()) {\n+                return napeCell.hashCode();\n+            }\n+            return bsmData.hashCode() * napeCell.hashCode();\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            super.write(out);\n+            out.writeShort(bsmData.arg);\n+            out.writeShort(napeCell.arg);\n+        }\n+    }\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_CondyPair extends ConstValue_IndyOrCondyPair {\n+\n+        public ConstValue_CondyPair(BootstrapMethodData bsmdata, ConstCell napeCell) {\n+            super(ConstType.CONSTANT_DYNAMIC, bsmdata, napeCell);\n+        }\n+    }\n+\n+    \/**\n+     * ConstValue\n+     *\n+     * A (typed) tagged value in the constant pool.\n+     *\/\n+    static public class ConstValue_IndyPair extends ConstValue_IndyOrCondyPair {\n+\n+        public ConstValue_IndyPair(BootstrapMethodData bsmdata, ConstCell napeCell) {\n+            super(ConstType.CONSTANT_INVOKEDYNAMIC, bsmdata, napeCell);\n+        }\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* ConstantPool Inner Classes *\/\n+    \/**\n+     * ConstantCell\n+     *\n+     * ConstantCell is a type of data that can be in a constant pool.\n+     *\/\n+    static public class ConstCell extends Argument implements Data {\n+\n+        ConstValue ref;\n+        \/\/ 0 - highest - ref from ldc, 1 - any ref, 2 - no ref\n+        ReferenceRank rank = ReferenceRank.NO;\n+\n+        ConstCell(int arg, ConstValue ref) {\n+            this.arg = arg;\n+            this.ref = ref;\n+        }\n+\n+        ConstCell(ConstValue ref) {\n+            this(NotSet, ref);\n+        }\n+\n+        ConstCell(int arg) {\n+            this(arg, null);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(arg);\n+        }\n+\n+        public void setRank(ReferenceRank rank) {\n+            \/\/ don't change a short ref to long due to limitation of ldc - max 256 indexes allowed\n+            if( this.rank != ReferenceRank.LDC) {\n+                this.rank = rank;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (arg == NotSet) {\n+                if (ref != null) {\n+                    return ref.hashCode();\n+                } else {\n+                    throw new Parser.CompilerError(\"Can't generate Hash Code, Null ConstCell Reference.\");\n+                }\n+            }\n+            return arg;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null) {\n+                return false;\n+            }\n+            ConstCell cc = (ConstCell)obj;\n+            if( cc.ref == null ) {\n+                return this.ref == null && cc.rank == this.rank;\n+            }\n+            return cc.ref.equals(this.ref) && cc.rank == this.rank;\n+        }\n+\n+        public boolean isUnset() {\n+            return (arg == NotSet) && (ref == null);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"#\" + arg + \"=\" + ref;\n+        }\n+    }\n+\n+    \/**\n+     * CPVisitor\n+     *\n+     * CPVisitor base class defining a visitor for decoding constants.\n+     *\/\n+    public static class CPTagVisitor<R> implements Constants {\n+\n+        public CPTagVisitor() {\n+        }\n+\n+        public final R visit(ConstType tag) {\n+            R retVal = null;\n+            switch (tag) {\n+                case CONSTANT_UTF8:\n+                    retVal = visitUTF8(tag);\n+                    break;\n+                case CONSTANT_INTEGER:\n+                    retVal = visitInteger(tag);\n+                    break;\n+                case CONSTANT_FLOAT:\n+                    retVal = visitFloat(tag);\n+                    break;\n+                case CONSTANT_DOUBLE:\n+                    retVal = visitDouble(tag);\n+                    break;\n+                case CONSTANT_LONG:\n+                    retVal = visitLong(tag);\n+                    break;\n+                case CONSTANT_METHODTYPE:\n+                    retVal = visitMethodtype(tag);\n+                    break;\n+                case CONSTANT_STRING:\n+                    retVal = visitString(tag);\n+                    break;\n+                case CONSTANT_CLASS:\n+                    retVal = visitClass(tag);\n+                    break;\n+                case CONSTANT_METHOD:\n+                    retVal = visitMethod(tag);\n+                    break;\n+                case CONSTANT_FIELD:\n+                    retVal = visitField(tag);\n+                    break;\n+                case CONSTANT_INTERFACEMETHOD:\n+                    retVal = visitInterfacemethod(tag);\n+                    break;\n+                case CONSTANT_NAMEANDTYPE:\n+                    retVal = visitNameandtype(tag);\n+                    break;\n+                case CONSTANT_METHODHANDLE:\n+                    retVal = visitMethodhandle(tag);\n+                    break;\n+                case CONSTANT_DYNAMIC:\n+                    retVal = visitDynamic(tag);\n+                    break;\n+                case CONSTANT_INVOKEDYNAMIC:\n+                    retVal = visitInvokedynamic(tag);\n+                    break;\n+                default:\n+                    visitDefault(tag);\n+            }\n+            return retVal;\n+        }\n+\n+        public R visitUTF8(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitInteger(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitFloat(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitDouble(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitLong(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitMethodtype(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitString(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitClass(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitMethod(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitField(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitInterfacemethod(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitNameandtype(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitMethodhandle(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitDynamic(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitInvokedynamic(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitModule(ConstType tag) {\n+            return null;\n+        }\n+\n+        public R visitPackage(ConstType tag) {\n+            return null;\n+        }\n+\n+        public void visitDefault(ConstType tag) {\n+        }\n+    }\n+\n+    \/**\n+    * CPVisitor\n+    *\n+    * CPVisitor base class defining a visitor for decoding constants.\n+    *\/\n+   public static class CPVisitor<R> implements Constants {\n+\n+        public CPVisitor() {\n+        }\n+\n+        public final R visit(ConstValue val) {\n+            R retVal = null;\n+            ConstType tag = val.tag;\n+            switch (tag) {\n+                case CONSTANT_UTF8:\n+                    retVal = visitUTF8((ConstValue_String) val);\n+                    break;\n+                case CONSTANT_INTEGER:\n+                    retVal = visitInteger((ConstValue_Integer) val);\n+                    break;\n+                case CONSTANT_FLOAT:\n+                    retVal = visitFloat((ConstValue_Integer) val);\n+                    break;\n+                case CONSTANT_DOUBLE:\n+                    retVal = visitDouble((ConstValue_Long) val);\n+                    break;\n+                case CONSTANT_LONG:\n+                    retVal = visitLong((ConstValue_Long) val);\n+                    break;\n+                case CONSTANT_METHODTYPE:\n+                    retVal = visitMethodtype((ConstValue_Cell) val);\n+                    break;\n+                case CONSTANT_STRING:\n+                    retVal = visitString((ConstValue_Cell) val);\n+                    break;\n+                case CONSTANT_CLASS:\n+                    retVal = visitClass((ConstValue_Cell) val);\n+                    break;\n+                case CONSTANT_METHOD:\n+                    retVal = visitMethod((ConstValue_Pair) val);\n+                    break;\n+                case CONSTANT_FIELD:\n+                    retVal = visitField((ConstValue_Pair) val);\n+                    break;\n+                case CONSTANT_INTERFACEMETHOD:\n+                    retVal = visitInterfacemethod((ConstValue_Pair) val);\n+                    break;\n+                case CONSTANT_NAMEANDTYPE:\n+                    retVal = visitNameandtype((ConstValue_Pair) val);\n+                    break;\n+                case CONSTANT_METHODHANDLE:\n+                    retVal = visitMethodhandle((ConstValue_Pair) val);\n+                    break;\n+                case CONSTANT_DYNAMIC:\n+                    retVal = visitDynamic((ConstValue_CondyPair) val);\n+                    break;\n+                case CONSTANT_INVOKEDYNAMIC:\n+                    retVal = visitInvokedynamic((ConstValue_IndyPair) val);\n+                    break;\n+                case CONSTANT_MODULE:\n+                    retVal = visitModule((ConstValue_Cell) val);\n+                    break;\n+                case CONSTANT_PACKAGE:\n+                    retVal = visitPackage((ConstValue_Cell) val);\n+                    break;\n+                default:\n+                    visitDefault(tag);\n+            }\n+            return retVal;\n+        }\n+\n+        public R visitUTF8(ConstValue_String p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitInteger(ConstValue_Integer p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitFloat(ConstValue_Integer p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitDouble(ConstValue_Long p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitLong(ConstValue_Long p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitMethodtype(ConstValue_Cell p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitString(ConstValue_Cell p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitClass(ConstValue_Cell p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitMethod(ConstValue_Pair p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitField(ConstValue_Pair p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitInterfacemethod(ConstValue_Pair p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitNameandtype(ConstValue_Pair p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitMethodhandle(ConstValue_Pair p) {\n+            return null;\n+        }\n+\n+        ;\n+        public R visitDynamic(ConstValue_CondyPair p) { return null;}\n+\n+        ;\n+        public R visitInvokedynamic(ConstValue_IndyPair p) { return null;}\n+\n+        ;\n+        public R visitModule(ConstValue_Cell p) { return null; }\n+\n+        ;\n+        public R visitPackage(ConstValue_Cell p) { return null; }\n+        ;\n+\n+        public void visitDefault(ConstType tag) {}\n+        ;\n+\n+    }\n+\n+\n+\n+  \/*-------------------------------------------------------- *\/\n+  \/* Constant Pool Fields *\/\n+\n+    private ArrayList<ConstCell> pool = new ArrayList<>(20);\n+\n+    private final ConstValue ConstValue0\n+            = new ConstValue_String(\"\");\n+\/\/    private final ConstValue ConstValue0 =\n+\/\/            new ConstValue(CONSTANT_UTF8, \"\");\n+    private final ConstCell nullConst\n+            = new ConstCell(null);\n+    private final ConstCell constant_0\n+            = new ConstCell(new ConstValue_Zero());\n+\/\/    private final ConstCell constant_0 =\n+\/\/            new ConstCell(new ConstValue(CONSTANT_ZERO, null));\n+\n+    \/\/ For hashing by value\n+    Hashtable<ConstValue, ConstCell> cpoolHashByValue\n+            = new Hashtable<>(40);\n+\n+    public Environment env;\n+\n+    private static boolean debugCP = false;\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * main constructor\n+     *\n+     * @param env The error reporting environment\n+     *\/\n+    public ConstantPool(Environment env) {\n+        this.env = env;\n+        pool.add(constant_0);\n+\n+    }\n+\n+    public void debugStr(String s) {\n+        if (debugCP) {\n+            env.traceln(s);\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<ConstCell> iterator() {\n+        return pool.iterator();\n+    }\n+\n+\n+    \/*\n+     * Fix Refs in constant pool.\n+     *\n+     * This is used when scanning JASM files produced from JDis with the verbose\n+     * option (eg. where the constant pool is declared in the jasm itself).  In\n+     * this scenario, we need two passes - the first pass to scan the entries\n+     * (which creates constant references with indexes, but no reference values);\n+     * and the second pass, which links references to existing constants.\n+     *\n+     *\/\n+    public void fixRefsInPool() {\n+        \/\/ used to fix CP refs when a constant pool is constructed by refs alone.\n+        env.traceln(\"Fixing CP for explicit Constant Entries.\");\n+        int i = 0;\n+        \/\/ simply iterate through the pool.\n+        for (ConstCell item : pool) {\n+            i += 1;\n+            \/\/ first item is always null\n+            if (item == null) {\n+                continue;\n+            }\n+\n+            checkAndFixCPRef(i, item);\n+        }\n+    }\n+\n+    protected void CheckGlobals() {\n+        env.traceln(\"Checking Globals\");\n+        \/\/\n+        \/\/ This fn will put empty UTF8 string entries on any unset\n+        \/\/ CP entries - before the last CP entry.\n+        \/\/\n+        for (int cpx = 1; cpx < pool.size(); cpx++) {\n+            ConstCell cell = pool.get(cpx);\n+            if (cell == nullConst) { \/\/ gap\n+                cell = new ConstCell(cpx, ConstValue0);\n+                pool.set(cpx, cell);\n+            }\n+            ConstValue cval = cell.ref;\n+            if ((cval == null) || !cval.hasValue()) {\n+                String name = Integer.toString(cpx);\n+                env.error(\"const.undecl\", name);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     *  Helper function for \"fixRefsInPool\"\n+     *\n+     *  Does recursive checking of references,\n+     * using a locally-defined visitor.\n+     *\/\n+    private void checkAndFixCPRef(int i, ConstCell item) {\n+        ConstValue cv = item.ref;\n+        if (cv != null) {\n+            fixCPVstr.visit(cv);\n+        }\n+    }\n+\n+    private CPVisitor<Void> fixCPVstr = new CPVisitor<Void>() {\n+        @Override\n+        public Void visitUTF8(ConstValue_String p) {\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitInteger(ConstValue_Integer p) {\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitFloat(ConstValue_Integer p) {\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitDouble(ConstValue_Long p) {\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitLong(ConstValue_Long p) {\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitMethodtype(ConstValue_Cell p) {\n+            handleClassRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitString(ConstValue_Cell p) {\n+            handleClassRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitClass(ConstValue_Cell p) {\n+            handleClassRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitMethod(ConstValue_Pair p) {\n+            handleMemberRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitField(ConstValue_Pair p) {\n+            handleMemberRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitInterfacemethod(ConstValue_Pair p) {\n+            handleMemberRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitNameandtype(ConstValue_Pair p) {\n+            handleMemberRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitMethodhandle(ConstValue_Pair p) {\n+            handleMemberRef(p);\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitDynamic(ConstValue_CondyPair p) {\n+            return null;\n+        }\n+\n+        ;\n+        @Override\n+        public Void visitInvokedynamic(ConstValue_IndyPair p) {\n+            return null;\n+        }\n+        ;\n+\n+        @Override\n+        public Void visitModule(ConstValue_Cell p) {\n+            handleClassRef(p);\n+            return null;\n+        }\n+        ;\n+\n+        @Override\n+        public Void visitPackage(ConstValue_Cell p) {\n+            handleClassRef(p);\n+            return null;\n+        }\n+        ;\n+\n+\n+        public void handleClassRef(ConstValue_Cell cv) {\n+            ConstCell clref = cv.cell;\n+            if (clref.ref == null) {\n+                ConstCell refval = cpool_get(clref.arg);\n+                if (refval != null) {\n+                    checkAndFixCPRef(clref.arg, refval);\n+                    clref.ref = refval.ref;\n+                } else {\n+                    clref.ref = null;\n+                }\n+                \/\/ env.traceln(\"FIXED ConstPool[\" + i + \"](\" + cv.TagString(cv.tag) + \") = \" + cv.value);\n+            }\n+        }\n+\n+        public void handleMemberRef(ConstValue_Pair cv) {\n+            \/\/ env.traceln(\"ConstPool[\" + i + \"](\" + cv.TagString(cv.tag) + \") = \" + cv.value);\n+            ConstCell clref = cv.left;\n+            ConstCell typref = cv.right;\n+            if (clref.ref == null) {\n+                ConstCell refval = cpool_get(clref.arg);\n+                if (refval != null) {\n+                    checkAndFixCPRef(clref.arg, refval);\n+                    clref.ref = refval.ref;\n+                } else {\n+                    clref.ref = null;\n+                }\n+                \/\/ env.traceln(\"FIXED ConstPool[\" + i + \"](\" + cv.TagString(cv.tag) + \") = \" + cv.value);\n+            }\n+            if (typref.ref == null) {\n+                ConstCell refval = cpool_get(typref.arg);\n+                if (refval != null) {\n+                    checkAndFixCPRef(typref.arg, refval);\n+                    typref.ref = refval.ref;\n+                } else {\n+                    typref.ref = null;\n+                }\n+                \/\/ env.traceln(\"FIXED ConstPool[\" + i + \"](\" + cv.TagString(cv.tag) + \") = \" + cv.value);\n+            }\n+        }\n+\n+    };\n+\n+    \/*\n+     * Help debug Constant Pools\n+     *\/\n+    public void printPool() {\n+        int i = 0;\n+        for (ConstCell item : pool) {\n+            env.traceln(\"^^^^^^^^^^^^^  const #\" + i + \": \" + item);\n+            i += 1;\n+        }\n+    }\n+\n+    private ConstCell cpool_get(int cpx) {\n+        if (cpx >= pool.size()) {\n+            return null;\n+        }\n+        return pool.get(cpx);\n+    }\n+\n+    private void cpool_set(int cpx, ConstCell cell, int sz) {\n+        debugStr(\"cpool_set1: \" + cpx + \" \" + cell);\n+        debugStr(\"param_size: \" + sz);\n+        debugStr(\"pool_size: \" + pool.size());\n+        cell.arg = cpx;\n+        if (cpx + sz >= pool.size()) {\n+            debugStr(\"calling ensureCapacity( \" + (cpx + sz + 1) + \")\");\n+            int low = pool.size();\n+            int high = cpx + sz;\n+            for (int i = 0; i < high - low; i++) {\n+                pool.add(nullConst);\n+            }\n+        }\n+        pool.set(cpx, cell);\n+        if (sz == 2) {\n+            pool.set(cpx + 1, new ConstCell(cpx + 1, ConstValue0));\n+        }\n+        debugStr(\" cpool_set2: \" + cpx + \" \" + cell);\n+    }\n+\n+    protected ConstCell uncheckedGetCell(int cpx) { \/\/ by index\n+        return pool.get(cpx);\n+    }\n+\n+    public ConstCell getCell(int cpx) { \/\/ by index\n+        ConstCell cell = cpool_get(cpx);\n+        if (cell != null) {\n+            return cell;\n+        }\n+        cell = new ConstCell(cpx, null);\n+        return cell;\n+    }\n+\n+    public void setCell(int cpx, ConstCell cell) {\n+        ConstValue value = cell.ref;\n+        if (value == null) {\n+            throw new Parser.CompilerError(env.errorStr(\"comperr.constcell.nullvalset\"));\n+        }\n+        int sz = value.size();\n+\n+        if (cpx == 0) {\n+            \/\/ It is correct to warn about redeclaring constant zero,\n+            \/\/ since this value is never written out to a class file.\n+            env.error(\"warn.const0.redecl\");\n+        } else {\n+            if ((cpool_get(cpx) != null) || ((sz == 2) && (cpool_get(cpx + 1) != null))) {\n+                String name = \"#\" + cpx;\n+                env.error(\"const.redecl\", name);\n+                return;\n+            }\n+            if (cell.isSet() && (cell.arg != cpx)) {\n+                env.traceln(\"setCell: new ConstCell\");\n+                cell = new ConstCell(value);\n+            }\n+        }\n+        cpool_set(cpx, cell, sz);\n+    }\n+\n+    protected void NumberizePool() {\n+        env.traceln(\"NumberizePool\");\n+\n+        for (ReferenceRank rank : ReferenceRank.values()) {\n+            for (ConstCell cell : cpoolHashByValue.values().stream().\n+                     filter(v-> !v.isSet() && rank.equals(v.rank)).\n+                     collect(Collectors.toList())) {\n+\n+                ConstValue value = cell.ref;\n+                if (value == null) {\n+                    throw new Parser.CompilerError(env.errorStr(\"comperr.constcell.nullvalhash\"));\n+                }\n+                int sz = value.size(), cpx;\n+find:\n+                for (cpx = 1; cpx < pool.size(); cpx++) {\n+                    if ((pool.get(cpx) == nullConst) && ((sz == 1) || (pool.get(cpx + 1) == nullConst))) {\n+                        break find;\n+                    }\n+                }\n+                cpool_set(cpx, cell, sz);\n+            }\n+        }\n+\n+        ConstCell firstCell = cpool_get(0);\n+        firstCell.arg = 0;\n+    }\n+\n+    public ConstCell FindCell(ConstValue ref) {\n+        if (ref == null) {\n+            throw new Parser.CompilerError(env.errorStr(\"comperr.constcell.nullval\"));\n+        }\n+        ConstCell pconst = null;\n+        try {\n+            pconst = cpoolHashByValue.get(ref);\n+        } catch (Parser.CompilerError e) {\n+            throw new Parser.CompilerError(env.errorStr(\"comperr.constcell.nullvalhash\"));\n+        }\n+        \/\/ If we fund a cached ConstValue\n+        if (pconst != null) {\n+            ConstValue value = pconst.ref;\n+            if (!value.equals(ref)) {\n+                throw new Parser.CompilerError(env.errorStr(\"comperr.val.noteq\"));\n+            }\n+            return pconst;\n+        }\n+        \/\/ If we didn't find a cached ConstValue\n+        \/\/      Add it to the cache\n+        pconst = new ConstCell(ref);\n+        cpoolHashByValue.put(ref, pconst);\n+        return pconst;\n+    }\n+\n+    public ConstCell FindCell(ConstType tag, String value) {\n+        return FindCell(new ConstValue_String(value));\n+    }\n+\n+    public ConstCell FindCell(ConstType tag, Integer value) {\n+        return FindCell(new ConstValue_Integer(tag, value));\n+    }\n+\n+    public ConstCell FindCell(ConstType tag, Long value) {\n+        return FindCell(new ConstValue_Long(tag, value));\n+    }\n+\n+    public ConstCell FindCell(ConstType tag, ConstCell value) {\n+        return FindCell(new ConstValue_Cell(tag, value));\n+    }\n+\n+    public ConstCell FindCell(ConstType tag, ConstCell left, ConstCell right) {\n+        return FindCell(new ConstValue_Pair(tag, left, right));\n+    }\n+\n+    public ConstCell FindCellAsciz(String str) {\n+        return FindCell(ConstType.CONSTANT_UTF8, str);\n+    }\n+\n+    public ConstCell FindCellClassByName(String name) { return FindCell(ConstType.CONSTANT_CLASS, FindCellAsciz(name)); }\n+\n+    public ConstCell FindCellModuleByName(String name) { return FindCell(ConstType.CONSTANT_MODULE, FindCellAsciz(name)); }\n+\n+    public ConstCell FindCellPackageByName(String name) { return FindCell(ConstType.CONSTANT_PACKAGE, FindCellAsciz(name)); }\n+\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        \/\/ Write the constant pool\n+        int length = pool.size();\n+        out.writeShort(length);\n+        int i;\n+        env.traceln(\"wr.pool:size=\" + length);\n+        for (i = 1; i < length;) {\n+            ConstCell cell = pool.get(i);\n+            ConstValue value = cell.ref;\n+            if (cell.arg != i) {\n+                throw new Parser.CompilerError(env.errorStr(\"comperr.constcell.invarg\", Integer.toString(i), cell.arg));\n+            }\n+            value.write(out);\n+            i += value.size();\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ConstantPool.java","additions":1264,"deletions":0,"binary":false,"changes":1264,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+\/**\n+ * This interface defines constant that are used throughout the compiler. It inherits from\n+ * RuntimeConstants, which is an autogenerated class that contains constants defined in\n+ * the interpreter.\n+ *\/\n+public interface Constants extends RuntimeConstants {\n+\n+\n+    \/**\n+     * End of input\n+     *\/\n+    public static final int EOF        = -1;\n+\n+    \/*\n+     * Flags\n+     *\/\n+    public static final int F_VERBOSE        = 1 << 0;\n+    public static final int F_DUMP           = 1 << 1;\n+    public static final int F_WARNINGS       = 1 << 2;\n+    public static final int F_DEBUG          = 1 << 3;\n+    public static final int F_OPTIMIZE       = 1 << 4;\n+    public static final int F_DEPENDENCIES   = 1 << 5;\n+\n+    \/*\n+     * Type codes\n+     *\/\n+    public static final int TC_BOOLEAN   = 0;\n+    public static final int TC_BYTE      = 1;\n+    public static final int TC_CHAR      = 2;\n+    public static final int TC_SHORT     = 3;\n+    public static final int TC_INT       = 4;\n+    public static final int TC_LONG      = 5;\n+    public static final int TC_FLOAT     = 6;\n+    public static final int TC_DOUBLE    = 7;\n+    public static final int TC_NULL      = 8;\n+    public static final int TC_ARRAY     = 9;\n+    public static final int TC_CLASS     = 10;\n+    public static final int TC_VOID      = 11;\n+    public static final int TC_METHOD    = 12;\n+    public static final int TC_ERROR     = 13;\n+\n+    \/*\n+     * Type Masks\n+     *\/\n+    public static final int TM_NULL      = 1 << TC_NULL;\n+    public static final int TM_VOID      = 1 << TC_VOID;\n+    public static final int TM_BOOLEAN   = 1 << TC_BOOLEAN;\n+    public static final int TM_BYTE      = 1 << TC_BYTE;\n+    public static final int TM_CHAR      = 1 << TC_CHAR;\n+    public static final int TM_SHORT     = 1 << TC_SHORT;\n+    public static final int TM_INT       = 1 << TC_INT;\n+    public static final int TM_LONG      = 1 << TC_LONG;\n+    public static final int TM_FLOAT     = 1 << TC_FLOAT;\n+    public static final int TM_DOUBLE    = 1 << TC_DOUBLE;\n+    public static final int TM_ARRAY     = 1 << TC_ARRAY;\n+    public static final int TM_CLASS     = 1 << TC_CLASS;\n+    public static final int TM_METHOD    = 1 << TC_METHOD;\n+    public static final int TM_ERROR     = 1 << TC_ERROR;\n+\n+    public static final int TM_INT32     = TM_BYTE | TM_SHORT | TM_CHAR | TM_INT;\n+    public static final int TM_NUM32     = TM_INT32 | TM_FLOAT;\n+    public static final int TM_NUM64     = TM_LONG | TM_DOUBLE;\n+    public static final int TM_INTEGER   = TM_INT32 | TM_LONG;\n+    public static final int TM_REAL      = TM_FLOAT | TM_DOUBLE;\n+    public static final int TM_NUMBER    = TM_INTEGER | TM_REAL;\n+    public static final int TM_REFERENCE = TM_ARRAY | TM_CLASS | TM_NULL;\n+\n+    \/*\n+     * Class status\n+     *\/\n+    public static final int CS_UNDEFINED        = 0;\n+    public static final int CS_UNDECIDED        = 1;\n+    public static final int CS_BINARY           = 2;\n+    public static final int CS_SOURCE           = 3;\n+    public static final int CS_PARSED           = 4;\n+    public static final int CS_COMPILED         = 5;\n+    public static final int CS_NOTFOUND         = 6;\n+\n+    \/*\n+     * Attributes\n+     *\/\n+    public static final int ATT_ALL             = -1;\n+    public static final int ATT_CODE            = 1;\n+\n+    \/*\n+     * Number of bits used in file offsets\n+     *\/\n+    public static final int OFFSETBITS          = 19;\n+    public static final int MAXFILESIZE         = (1 << OFFSETBITS) - 1;\n+    public static final int MAXLINENUMBER       = (1 << (32 - OFFSETBITS)) - 1;\n+\n+    \/*\n+     * Operator precedence\n+     *\/\n+    \/* Who uses this????\n+    public static final int opPrecedence[] = {\n+        10,  11,  11,  11,  11,  11,  11,  11,  11,  11,\n+        11,  11,  11,  12,  13,  14,  15,  16,  17,  18,\n+        18,  19,  19,  19,  19,  19,  20,  20,  20,  21,\n+        21,  22,  22,  22,  23,  24,  24,  24,  24,  24,\n+        24,  25,  25,  26,  26,  26,  26,  26,  26\n+    };\n+    * *\/\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Constants.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * Base contract for writeable structures\n+ *\/\n+interface Data {\n+\n+    void write(CheckedDataOutputStream out) throws IOException;\n+\n+    int getLength();\n+\n+    default String tabString(int tabLevel) {\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < tabLevel; i++) {\n+            sb.append('\\t');\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Data.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+\/**\n+ *\n+ *\/\n+public class DataVector<T extends Data> implements Iterable<T> {\n+\n+    ArrayList<T> elements;\n+\n+    public DataVector(int initSize) {\n+        elements = new ArrayList<>(initSize);\n+    }\n+\n+    public DataVector() {\n+        this(12);\n+    }\n+\n+    public Iterator<T> iterator() {\n+        return elements.iterator();\n+    }\n+\n+    public void add(T element) {\n+        elements.add(element);\n+    }\n+\n+    public void addAll(List<T> collection) {\n+        elements.addAll(collection);\n+    }\n+\n+    \/\/ full length of the attribute conveyor\n+    \/\/ declared in Data\n+    public int getLength() {\n+        int length = 0;\n+        \/\/ calculate overall size here rather than in add()\n+        \/\/ because it may not be available at the time of invoking of add()\n+        for (T element : elements) {\n+            length += element.getLength();\n+        }\n+\n+        return 2 + length; \/\/ add the length of number of elements\n+    }\n+\n+    public void write(CheckedDataOutputStream out)\n+            throws IOException {\n+        out.writeShort(elements.size());\n+        writeElements(out);\n+    }\n+\n+    public void writeElements(CheckedDataOutputStream out)\n+            throws IOException {\n+        for (Data element : elements) {\n+            element.write(out);\n+        }\n+    }\n+\n+    \/* for compatibility with Vector *\/\n+    public void addElement(T element) {\n+        elements.add(element);\n+    }\n+\n+    public int size() {\n+        return elements.size();\n+    }\n+\n+    public Data elementAt(int k) {\n+        return elements.get(k);\n+    }\n+}\/\/ end class DataVector\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/DataVector.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+\n+\/**\n+ *\n+ *\/\n+\/\/ public class DataVectorAttr extends AttrData implements Constants {\n+\/\/ }\n+class DataVectorAttr<T extends Data> extends AttrData implements Iterable<T> {\n+\n+    private ArrayList<T> elements;\n+    private boolean byteIndex;\n+\n+    private DataVectorAttr(ClassData cls, String name, boolean byteIndex, ArrayList<T> initialData) {\n+        super(cls, name);\n+        this.elements = initialData;\n+        this.byteIndex = byteIndex;\n+    }\n+\n+    DataVectorAttr(ClassData cls, String name, ArrayList<T> initialData) {\n+        this(cls, name, false, initialData);\n+    }\n+\n+    DataVectorAttr(ClassData cls, String name) {\n+        this(cls, name, false, new ArrayList<>());\n+\n+    }\n+\n+    DataVectorAttr(ClassData cls, String name, boolean byteIndex) {\n+        this(cls, name, byteIndex, new ArrayList<>());\n+\n+    }\n+\n+    public T get(int index) {\n+        return elements.get(index);\n+    }\n+\n+    public void add(T element) {\n+        elements.add(element);\n+    }\n+\n+    public void put(int i, T element) {\n+        elements.set(i, element);\n+    }\n+\n+    public int size() {\n+        return elements.size();\n+    }\n+\n+    @Override\n+    public Iterator<T> iterator() {\n+        return elements.iterator();\n+    }\n+\n+    @Override\n+    public int attrLength() {\n+        int length = 0;\n+        \/\/ calculate overall size here rather than in add()\n+        \/\/ because it may not be available at the time of invoking of add()\n+        for (T elem : elements) {\n+            length += elem.getLength();\n+        }\n+\n+        \/\/ add the length of number of elements\n+        if (byteIndex) {\n+            length += 1;\n+        } else {\n+            length += 2;\n+        }\n+\n+        return length;\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        super.write(out);  \/\/ attr name, attr len\n+        if (byteIndex) {\n+            out.writeByte(elements.size());\n+        } else {\n+            out.writeShort(elements.size());\n+        } \/\/ number of elements\n+        for (T elem : elements) {\n+            elem.write(out);\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/DataVectorAttr.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * DefaultAnnotationAttr\n+ *\n+ * Used to represent Default Annotation Attributes\n+ *\n+ *\/\n+public class DefaultAnnotationAttr extends AttrData {\n+\n+    Data element; \/\/ Data\n+\n+    public DefaultAnnotationAttr(ClassData cls, String name, Data element) {\n+        super(cls, name);\n+        this.element = element;\n+    }\n+\n+    public DefaultAnnotationAttr(ClassData cls, String name) {\n+        super(cls, name);\n+        this.element = null;\n+    }\n+\n+    public void add(Data element) {\n+        this.element = element;\n+    }\n+\n+    @Override\n+    public int attrLength() {\n+        return element.getLength(); \/\/ add the length of number of elements\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        super.write(out);  \/\/ attr name, attr len\n+        element.write(out);\n+    }\n+}\/\/ end class DataVectorAttr\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/DefaultAnnotationAttr.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,454 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import static org.openjdk.asmtools.jasm.Constants.EOF;\n+import static org.openjdk.asmtools.jasm.Constants.OFFSETBITS;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+\n+import java.io.*;\n+import java.nio.file.Paths;\n+import java.text.MessageFormat;\n+\n+\/**\n+ * An input stream for java programs. The stream treats either \"\\n\", \"\\r\" or \"\\r\\n\" as the\n+ * end of a line, it always returns \\n. It also parses UNICODE characters expressed as\n+ * \\uffff. However, if it sees \"\\\\\", the second slash cannot begin a unicode sequence. It\n+ * keeps track of the current position in the input stream.\n+ *\n+ * An position consists of: ((linenr &lt;&lt; OFFSETBITS) | offset) this means that both\n+ * the line number and the exact offset into the file are encoded in each position\n+ * value.<p>\n+ *\/\n+public class Environment {\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Environment Inner Classes *\/\n+    \/**\n+     * A sorted list of error messages\n+     *\/\n+    final class ErrorMessage {\n+\n+        int where;\n+        String message;\n+        ErrorMessage next;\n+\n+        \/**\n+         * Constructor\n+         *\/\n+        ErrorMessage(int where, String message) {\n+            this.where = where;\n+            this.message = message;\n+        }\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Environment Fields *\/\n+    static boolean traceFlag = false;\n+    boolean debugInfoFlag = false;\n+\n+    private String inputFileName;\n+    private String simpleInputFileName;\n+    public PrintWriter out;\n+    private boolean nowarn;\n+    private byte[] data;\n+    private int bytepos;\n+    private int linepos;\n+    public int pos;\n+    \/*-------------------------------------------------------- *\/\n+\n+    public Environment(DataInputStream dis, String inputFileName, PrintWriter out, boolean nowarn) throws IOException {\n+        this.out = out;\n+        this.inputFileName = inputFileName;\n+        this.nowarn = nowarn;\n+        \/\/ Read the file\n+        data = new byte[dis.available()];\n+        dis.read(data);\n+        dis.close();\n+        bytepos = 0;\n+        linepos = 1;\n+    }\n+\n+    public String getInputFileName() {\n+        return inputFileName;\n+    }\n+\n+    public String getSimpleInputFileName() {\n+        if( simpleInputFileName == null ) {\n+            simpleInputFileName = Paths.get(inputFileName).getFileName().toString();\n+        }\n+        return simpleInputFileName;\n+    }\n+\n+    int lookForward() {\n+        try {\n+            return data[bytepos];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return EOF;\n+        }\n+    }\n+\n+    int convertUnicode() {\n+        int c;\n+        try {\n+            while ((c = data[bytepos]) == 'u') {\n+                bytepos++;\n+            }\n+            int d = 0;\n+            for (int i = 0; i < 4; i++) {\n+                switch (c) {\n+                    case '0':\n+                    case '1':\n+                    case '2':\n+                    case '3':\n+                    case '4':\n+                    case '5':\n+                    case '6':\n+                    case '7':\n+                    case '8':\n+                    case '9':\n+                        d = (d << 4) + c - '0';\n+                        break;\n+                    case 'a':\n+                    case 'b':\n+                    case 'c':\n+                    case 'd':\n+                    case 'e':\n+                    case 'f':\n+                        d = (d << 4) + 10 + c - 'a';\n+                        break;\n+                    case 'A':\n+                    case 'B':\n+                    case 'C':\n+                    case 'D':\n+                    case 'E':\n+                    case 'F':\n+                        d = (d << 4) + 10 + c - 'A';\n+                        break;\n+                    default:\n+                        error(pos, \"invalid.escape.char\");\n+                        return d;\n+                }\n+                ++bytepos;\n+                c = data[bytepos];\n+            }\n+            return d;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            error(pos, \"invalid.escape.char\");\n+            return EOF;\n+        }\n+    }\n+\n+    public int read() {\n+        int c;\n+        pos = (linepos << OFFSETBITS) | bytepos;\n+        try {\n+            c = data[bytepos];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return EOF;\n+        }\n+        bytepos++;\n+\n+        \/\/ parse special characters\n+        switch (c) {\n+            \/*            case '\\\\':\n+             if (lookForward() != 'u') {\n+             return '\\\\';\n+             }\n+             \/\/ we have a unicode sequence\n+             return convertUnicode();*\/\n+            case '\\n':\n+                linepos++;\n+                return '\\n';\n+\n+            case '\\r':\n+                if (lookForward() == '\\n') {\n+                    bytepos++;\n+                }\n+                linepos++;\n+                return '\\n';\n+\n+            default:\n+                return c;\n+        }\n+    }\n+\n+    int lineNumber(int lcpos) {\n+        return lcpos >>> OFFSETBITS;\n+    }\n+\n+    int lineNumber() {\n+        return lineNumber(pos);\n+    }\n+\n+    int lineOffset(int lcpos) {\n+        return lcpos & ((1 << OFFSETBITS) - 1);\n+    }\n+\n+    int lineOffset() {\n+        return lineOffset(pos);\n+    }\n+\n+    \/*==============================================================  Environment *\/\n+    \/**\n+     * The number of errors and warnings\n+     *\/\n+    public int nerrors;\n+    public int nwarnings;\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    \/**\n+     * Error String\n+     *\/\n+    String errorString(String err, Object arg1, Object arg2, Object arg3) {\n+        String str = null;\n+\n+        \/\/str = getProperty(err);\n+        str = i18n.getString(err);\n+        if (str == null) {\n+            return \"error message '\" + err + \"' not found\";\n+        }\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (int i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            if ((c == '%') && (i + 1 < str.length())) {\n+                switch (str.charAt(++i)) {\n+                    case 's':\n+                        String arg = arg1.toString();\n+                        for (int j = 0; j < arg.length(); j++) {\n+                            switch (c = arg.charAt(j)) {\n+                                case ' ':\n+                                case '\\t':\n+                                case '\\n':\n+                                case '\\r':\n+                                    buf.append((char) c);\n+                                    break;\n+\n+                                default:\n+                                    if ((c > ' ') && (c <= 255)) {\n+                                        buf.append((char) c);\n+                                    } else {\n+                                        buf.append('\\\\');\n+                                        buf.append('u');\n+                                        buf.append(Integer.toString(c, 16));\n+                                    }\n+                            }\n+                        }\n+                        arg1 = arg2;\n+                        arg2 = arg3;\n+                        break;\n+\n+                    case '%':\n+                        buf.append('%');\n+                        break;\n+\n+                    default:\n+                        buf.append('?');\n+                        break;\n+                }\n+            } else {\n+                buf.append((char) c);\n+            }\n+        }\n+        \/\/ KTL\n+        \/\/ Need to do message format to substitute args\n+        String msg = buf.toString();\n+        MessageFormat form = new MessageFormat(msg);\n+        Object args[] = {arg1, arg2, arg3};\n+        msg = form.format(args);\n+\n+        return msg;\n+\n+    }\n+\n+    \/**\n+     * List of outstanding error messages\n+     *\/\n+    ErrorMessage errors;\n+\n+    \/**\n+     * Insert an error message in the list of outstanding error messages. The list is\n+     * sorted on input position.\n+     *\/\n+    void insertError(int where, String message) {\n+        \/\/output(\"ERR = \" + message);\n+        ErrorMessage msg = new ErrorMessage(where, message);\n+        if (errors == null) {\n+            errors = msg;\n+        } else if (errors.where > where) {\n+            msg.next = errors;\n+            errors = msg;\n+        } else {\n+            ErrorMessage m = errors;\n+            for (; (m.next != null) && (m.next.where <= where); m = m.next);\n+            msg.next = m.next;\n+            m.next = msg;\n+        }\n+    }\n+\n+    \/**\n+     * Flush outstanding errors\n+     *\/\n+    public void flushErrors() {\n+        if (errors == null) {\n+            traceln(\"flushErrors: errors == null\");\n+            return;\n+        }\n+\n+        \/\/ Report the errors\n+        for (ErrorMessage msg = errors; msg != null; msg = msg.next) {\n+            int off = lineOffset(msg.where);\n+\n+            int i, j;\n+            for (i = off; (i > 0) && (data[i - 1] != '\\n') && (data[i - 1] != '\\r'); i--);\n+            for (j = off; (j < data.length) && (data[j] != '\\n') && (data[j] != '\\r'); j++);\n+\n+            outputln( String.format( \"%s (%d:%d) %s\", getSimpleInputFileName(), lineNumber(msg.where), off - i, msg.message));\n+            outputln(new String(data, i, j - i));\n+\n+            char strdata[] = new char[(off - i) + 1];\n+            for (j = i; j < off; j++) {\n+                strdata[j - i] = (data[j] == '\\t') ? '\\t' : ' ';\n+            }\n+            strdata[off - i] = '^';\n+            outputln(new String(strdata));\n+        }\n+        errors = null;\n+    }\n+\n+    \/**\n+     * Output a string. This can either be an error message or something for debugging.\n+     * This should be used instead of print.\n+     *\/\n+    public void output(String msg) {\n+        int len = msg.length();\n+        for (int i = 0; i < len; i++) {\n+            out.write(msg.charAt(i));\n+        }\n+        out.flush();\n+    }\n+\n+    \/**\n+     * Output a string. This can either be an error message or something for debugging.\n+     * This should be used instead of println.\n+     *\/\n+    public void outputln(String msg) {\n+        output((msg == null ? \"\" : msg) + \"\\n\");\n+    }\n+\n+    \/**\n+     * Issue an error. source - the input source, usually a file name string offset - the\n+     * offset in the source of the error err - the error number (as defined in this\n+     * interface) arg1 - an optional argument to the error (null if not applicable) arg2 -\n+     * a second optional argument to the error (null if not applicable) arg3 - a third\n+     * optional argument to the error (null if not applicable)\n+     *\/\n+    \/**\n+     * Issue an error\n+     *\/\n+    public void error(int where, String err, Object arg1, Object arg2, Object arg3) {\n+        String msg;\n+        if (err.startsWith(\"warn.\")) {\n+            if (nowarn) {\n+                return;\n+            }\n+            nwarnings++;\n+            msg = \"Warning: \";\n+        } else {\n+            err = \"err.\" + err;\n+            nerrors++;\n+            msg = \"Error: \";\n+        }\n+        msg = msg + errorString(err, arg1, arg2, arg3);\n+        traceln(msg);\n+        insertError(where, msg);\n+    }\n+\n+    public final void error(int where, String err, Object arg1, Object arg2) {\n+        error(where, err, arg1, arg2, null);\n+    }\n+\n+    public final void error(int where, String err, Object arg1) {\n+        error(where, err, arg1, null, null);\n+    }\n+\n+    public final void error(int where, String err) {\n+        error(where, err, null, null, null);\n+    }\n+\n+    public final void error(String err, Object arg1, Object arg2, Object arg3) {\n+        error(pos, err, arg1, arg2, arg3);\n+    }\n+\n+    public final void error(String err, Object arg1, Object arg2) {\n+        error(pos, err, arg1, arg2, null);\n+    }\n+\n+    public final void error(String err, Object arg1) {\n+        error(pos, err, arg1, null, null);\n+    }\n+\n+    public final void error(String err) {\n+        error(pos, err, null, null, null);\n+    }\n+\n+    public final String errorStr(String err, Object arg1, Object arg2, Object arg3) {\n+        return errorString(err, arg1, arg2, arg3);\n+    }\n+\n+    public final String errorStr(String err, Object arg1, Object arg2) {\n+        return errorStr(err, arg1, arg2, null);\n+    }\n+\n+    public final String errorStr(String err, Object arg1) {\n+        return errorStr(err, arg1, null, null);\n+    }\n+\n+    public final String errorStr(String err) {\n+        return errorStr(err, null, null, null);\n+    }\n+\n+    \/*==============================================================  trace *\/\n+    public boolean isTraceEnabled() {\n+        return traceFlag;\n+    }\n+\n+    public boolean isDebugEnabled() {\n+        return debugInfoFlag;\n+    }\n+\n+    void trace(String message) {\n+        if (traceFlag) {\n+            output(message);\n+        }\n+    }\n+\n+    void traceln(String message) {\n+        if (traceFlag) {\n+            outputln(message);\n+        }\n+    }\n+\n+} \/\/ end Environment\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Environment.java","additions":454,"deletions":0,"binary":false,"changes":454,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.jasm.Tables.AttrTag;\n+import java.io.IOException;\n+\n+\/**\n+ *  field_info\n+ *\/\n+class FieldData extends MemberData {\n+\n+    \/* FieldData Fields *\/\n+    private ConstantPool.ConstValue_Pair nape;\n+    private AttrData initValue;\n+\n+    public FieldData(ClassData cls, int acc, ConstantPool.ConstValue_Pair nape) {\n+        super(cls, acc);\n+        this.nape = nape;\n+        if (Modifiers.hasPseudoMod(acc)) {\n+            createPseudoMod();\n+        }\n+    }\n+\n+    public ConstantPool.ConstValue_Pair getNameDesc() {\n+        return nape;\n+    }\n+\n+    public void SetValue(Argument value_cpx) {\n+        initValue = new CPXAttr(cls, AttrTag.ATT_ConstantValue.parsekey(),\n+                value_cpx);\n+    }\n+\n+    @Override\n+    protected DataVector getAttrVector() {\n+        return getDataVector(initValue, syntheticAttr, deprecatedAttr, signatureAttr);\n+    }\n+\n+    public void write(CheckedDataOutputStream out) throws IOException, Parser.CompilerError {\n+        out.writeShort(access);\n+        out.writeShort(nape.left.arg);\n+        out.writeShort(nape.right.arg);\n+        DataVector attrs = getAttrVector();\n+        attrs.write(out);\n+    }\n+} \/\/ end FieldData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/FieldData.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+\n+\/**\n+ *\n+ *\/\n+class InnerClassData implements Data {\n+\n+    int access;\n+    ConstantPool.ConstCell name, innerClass, outerClass;\n+\n+    public InnerClassData(int access, ConstantPool.ConstCell name, ConstantPool.ConstCell innerClass, ConstantPool.ConstCell outerClass) {\n+        this.access = access;\n+        this.name = name;\n+        this.innerClass = innerClass;\n+        this.outerClass = outerClass;\n+    }\n+\n+    @Override\n+    public int getLength() {\n+        return 8;\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        out.writeShort(innerClass.arg);\n+        if (outerClass.isSet()) {\n+            out.writeShort(outerClass.arg);\n+        } else {\n+            out.writeShort(0);\n+        }\n+        if (name.isSet()) {\n+            out.writeShort(name.arg);\n+        } else {\n+            out.writeShort(0);\n+        }\n+        out.writeShort(access);\n+    }\n+}\/\/ end class InnerClassData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/InnerClassData.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+\n+import static org.openjdk.asmtools.jasm.OpcodeTables.*;\n+\n+\/**\n+ *\n+ *\/\n+class Instr {\n+\n+    Instr next = null;\n+    int pc;\n+    int pos;\n+    Opcode opc;\n+    Argument arg;\n+    Object arg2; \/\/ second or unusual argument\n+\n+    public Instr(int pc, int pos, Opcode opc, Argument arg, Object arg2) {\n+        this.pc = pc;\n+        this.pos = pos;\n+        this.opc = opc;\n+        this.arg = arg;\n+        this.arg2 = arg2;\n+    }\n+\n+    public Instr() {\n+    }\n+\n+    public void write(CheckedDataOutputStream out, Environment env) throws IOException {\n+        OpcodeType type = opc.type();\n+        switch (type) {\n+            case NORMAL: {\n+                if (opc == Opcode.opc_bytecode) {\n+                    out.writeByte(arg.arg);\n+                    return;\n+                }\n+                out.writeByte(opc.value());\n+                int opcLen = opc.length();\n+                if (opcLen == 1) {\n+                    return;\n+                }\n+\n+                switch (opc) {\n+                    case opc_tableswitch:\n+                        ((SwitchTable) arg2).writeTableSwitch(out);\n+                        return;\n+                    case opc_lookupswitch:\n+                        ((SwitchTable) arg2).writeLookupSwitch(out);\n+                        return;\n+                }\n+\n+                int iarg;\n+                try {\n+                    iarg = arg.arg;\n+                } catch (NullPointerException e) {\n+                    throw new Parser.CompilerError(env.errorStr(\"comperr.instr.nullarg\", opc.parsekey()));\n+                }\n+\/\/env.traceln(\"instr:\"+opcNamesTab[opc]+\" len=\"+opcLen+\" arg:\"+iarg);\n+                switch (opc) {\n+                    case opc_jsr:\n+                    case opc_goto:\n+                    case opc_ifeq:\n+                    case opc_ifge:\n+                    case opc_ifgt:\n+                    case opc_ifle:\n+                    case opc_iflt:\n+                    case opc_ifne:\n+                    case opc_if_icmpeq:\n+                    case opc_if_icmpne:\n+                    case opc_if_icmpge:\n+                    case opc_if_icmpgt:\n+                    case opc_if_icmple:\n+                    case opc_if_icmplt:\n+                    case opc_if_acmpeq:\n+                    case opc_if_acmpne:\n+                    case opc_ifnull:\n+                    case opc_ifnonnull:\n+                    case opc_jsr_w:\n+                    case opc_goto_w:\n+                        iarg = iarg - pc;\n+                        break;\n+                    case opc_iinc:\n+                        iarg = (iarg << 8) | (((Argument) arg2).arg & 0xFF);\n+                        break;\n+                    case opc_invokeinterface:\n+                        iarg = ((iarg << 8) | (((Argument) arg2).arg & 0xFF)) << 8;\n+                        break;\n+                    case opc_invokedynamic: \/\/ JSR-292\n+                        iarg = (iarg << 16);\n+                        break;\n+                    case opc_ldc:\n+                        if ((iarg & 0xFFFFFF00) != 0) {\n+                            throw new Parser.CompilerError(\n+                                    env.errorStr(\"comperr.instr.arglong\", opc.parsekey(), iarg));\n+                        }\n+                        break;\n+                }\n+                switch (opcLen) {\n+                    case 1:\n+                        return;\n+                    case 2:\n+                        out.writeByte(iarg);\n+                        return;\n+                    case 3:\n+                        out.writeShort(iarg);\n+                        return;\n+                    case 4: \/\/ opc_multianewarray only\n+                        out.writeShort(iarg);\n+                        iarg = ((Argument) arg2).arg;\n+                        out.writeByte(iarg);\n+                        return;\n+                    case 5:\n+                        out.writeInt(iarg);\n+                        return;\n+                    default:\n+                        throw new Parser.CompilerError(\n+                                env.errorStr(\"comperr.instr.opclen\", opc.parsekey()));\n+                }\n+            }\n+            case WIDE:\n+                out.writeByte(Opcode.opc_wide.value());\n+                out.writeByte(opc.value() & 0xFF);\n+                out.writeShort(arg.arg);\n+                if (opc == Opcode.opc_iinc_w) {\n+                    out.writeShort(((Argument) arg2).arg);\n+                }\n+                return;\n+            case PRIVELEGED:\n+            case NONPRIVELEGED:\n+                out.writeByte(opc.value() >> 8);\n+                out.writeByte(opc.value() & 0xFF);\n+                return;\n+            default:\n+                throw new Parser.CompilerError(\n+                        env.errorStr(\"comperr.instr.opclen\", opc.parsekey()));\n+        } \/\/ end writeSpecCode\n+\n+    }\n+} \/\/ end Instr\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Instr.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,487 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.Optional;\n+\n+\/**\n+ *\n+ * JasmTokens\n+ *\n+ * This class contains tokens specific to parsing JASM syntax.\n+ *\n+ * The classes in JasmTokens are following a Singleton Pattern. These classes are Enums,\n+ * and they are contained in private hash maps (lookup tables and reverse lookup tables).\n+ * These hash maps all have public accessors, which clients use to look-up enums.\n+ *\n+ * Tokens in this table carry no external state, and are typically treated as constants.\n+ * They do not need to be reset.\n+ *\/\n+public class JasmTokens {\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Marker: describes the type of Keyword *\/\n+    static public enum KeywordType {\n+        TOKEN            (0, \"TOKEN\"),\n+        VALUE            (1, \"VALUE\"),\n+        JASMIDENTIFIER   (2, \"JASM\"),\n+        KEYWORD          (3, \"KEYWORD\");\n+\n+        private final Integer value;\n+        private final String printval;\n+\n+        KeywordType(Integer val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+    }\n+\n+\n+    \/*--------------------------------------------------------  *\/\n+    \/* Marker - describes the type of token                     *\/\n+    \/*    this is rather cosmetic, no function currently.       *\/\n+    static public enum TokenType {\n+        MODIFIER            (1, \"Modifier\"),\n+        OPERATOR            (2, \"Operator\"),\n+        VALUE               (3, \"Value\"),\n+        TYPE                (4, \"Type\"),\n+        EXPRESSION          (5, \"Expression\"),\n+        STATEMENT           (6, \"Statement\"),\n+        DECLARATION         (7, \"Declaration\"),\n+        PUNCTUATION         (8, \"Punctuation\"),\n+        SPECIAL             (9, \"Special\"),\n+        JASM                (10, \"Jasm\"),\n+        MISC                (11, \"Misc\"),\n+        JASM_IDENT          (12, \"Jasm identifier\"),\n+        MODULE_NAME         (13, \"Module Name\"),\n+        TYPE_PATH_KIND      (14, \"Type path kind\")          \/\/ Table 4.7.20.2-A Interpretation of type_path_kind values\n+        ;\n+\n+        private final Integer value;\n+        private final String printval;\n+\n+        TokenType(Integer val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+        public String printval() {\n+            return printval;\n+        }\n+    }\n+\n+    public enum AnnotationType {\n+        Visible(\"@+\"),\n+        Invisible(\"@-\"),\n+        VisibleType(\"@T+\"),\n+        InvisibleType(\"@T-\");\n+\n+        private final String jasmPrefix;\n+\n+        AnnotationType(String jasmPrefix) {\n+            this.jasmPrefix = jasmPrefix;\n+        }\n+\n+        \/**\n+         * isAnnotationToken\n+         *\n+         * examines the beginning of a string to see if it starts with an annotation\n+         * characters ('@+' = visible annotation, '@-' = invisible).\n+         *\n+         * @param str String to be analyzed\n+         * @return True if the string starts with an annotation char.\n+         *\/\n+        static public boolean isAnnotationToken(String str) {\n+            return (str.startsWith(AnnotationType.Invisible.jasmPrefix) ||\n+                    str.startsWith(AnnotationType.Visible.jasmPrefix));\n+        }\n+\n+        \/**\n+         * isTypeAnnotationToken\n+         *\n+         * examines the beginning of a string to see if it starts with type annotation\n+         * characters ('@T+' = visible type annotation, '@T-' = invisible).\n+         *\n+         * @param str String to be analyzed\n+         * @return True if the string starts with an annotation char.\n+         *\/\n+        static public boolean isTypeAnnotationToken(String str) {\n+            return (str.startsWith(AnnotationType.InvisibleType.jasmPrefix) ||\n+                    str.startsWith(AnnotationType.VisibleType.jasmPrefix));\n+        }\n+\n+        \/**\n+         * isAnnotation\n+         *\n+         * examines the beginning of a string to see if it starts with an annotation character\n+         *\n+         * @param str String to be analyzed\n+         * @return True if the string starts with an annotation char.\n+         *\/\n+        static public boolean isAnnotation(String str) {\n+            return (str.startsWith(\"@\"));\n+        }\n+\n+        \/**\n+         * isInvisibleAnnotationToken\n+         *\n+         * examines the end of an annotation token to determine visibility ('+' = visible\n+         * annotation, '-' = invisible).\n+         *\n+         * @param str String to be analyzed\n+         * @return True if the token implies invisible annotation.\n+         *\/\n+        static public boolean isInvisibleAnnotationToken(String str) {\n+            return (str.endsWith(\"-\"));\n+        }\n+    }\n+\n+    \/**\n+     * Scanner Tokens (Definitive List)\n+     *\/\n+    public enum Token {\n+        EOF                 (-1, \"EOF\",         \"EOF\",  EnumSet.of(TokenType.MISC)),\n+        COMMA               (0, \"COMMA\",        \",\",    EnumSet.of(TokenType.OPERATOR)),\n+        ASSIGN              (1, \"ASSIGN\",       \"=\",    EnumSet.of(TokenType.OPERATOR)),\n+\n+        ASGMUL              (2, \"ASGMUL\",       \"*=\",   EnumSet.of(TokenType.OPERATOR)),\n+        ASGDIV              (3, \"ASGDIV\",       \"\/=\",   EnumSet.of(TokenType.OPERATOR)),\n+        ASGREM              (4, \"ASGREM\",       \"%=\",   EnumSet.of(TokenType.OPERATOR)),\n+        ASGADD              (5, \"ASGADD\",       \"+=\",   EnumSet.of(TokenType.OPERATOR)),\n+        ASGSUB              (6, \"ASGSUB\",       \"-=\",   EnumSet.of(TokenType.OPERATOR)),\n+        ASGLSHIFT           (7, \"ASGLSHIFT\",    \"<<=\",  EnumSet.of(TokenType.OPERATOR)),\n+        ASGRSHIFT           (8, \"ASGRSHIFT\",    \">>=\",  EnumSet.of(TokenType.OPERATOR)),\n+        ASGURSHIFT          (9, \"ASGURSHIFT\",   \"<<<=\", EnumSet.of(TokenType.OPERATOR)),\n+        ASGBITAND           (10, \"ASGBITAND\",   \"&=\",   EnumSet.of(TokenType.OPERATOR)),\n+        ASGBITOR            (11, \"ASGBITOR\",    \"|=\",   EnumSet.of(TokenType.OPERATOR)),\n+        ASGBITXOR           (12, \"ASGBITXOR\",   \"^=\",   EnumSet.of(TokenType.OPERATOR)),\n+\n+        COND                (13, \"COND\",        \"?:\",   EnumSet.of(TokenType.OPERATOR)),\n+        OR                  (14, \"OR\",          \"||\",   EnumSet.of(TokenType.OPERATOR)),\n+        AND                 (15, \"AND\",         \"&&\",   EnumSet.of(TokenType.OPERATOR)),\n+        BITOR               (16, \"BITOR\",       \"|\",    EnumSet.of(TokenType.OPERATOR)),\n+        BITXOR              (17, \"BITXOR\",      \"^\",    EnumSet.of(TokenType.OPERATOR)),\n+        BITAND              (18, \"BITAND\",      \"&\",    EnumSet.of(TokenType.OPERATOR)),\n+        NE                  (19, \"NE\",          \"!=\",   EnumSet.of(TokenType.OPERATOR)),\n+        EQ                  (20, \"EQ\",          \"==\",   EnumSet.of(TokenType.OPERATOR)),\n+        GE                  (21, \"GE\",          \">=\",   EnumSet.of(TokenType.OPERATOR)),\n+        GT                  (22, \"GT\",          \">\",    EnumSet.of(TokenType.OPERATOR)),\n+        LE                  (23, \"LE\",          \"<=\",   EnumSet.of(TokenType.OPERATOR)),\n+        LT                  (24, \"LT\",          \"<\",    EnumSet.of(TokenType.OPERATOR)),\n+        INSTANCEOF          (25, \"INSTANCEOF\",  \"instanceof\",  EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        LSHIFT              (26, \"LSHIFT\",      \"<<\",   EnumSet.of(TokenType.OPERATOR)),\n+        RSHIFT              (27, \"RSHIFT\",      \">>\",   EnumSet.of(TokenType.OPERATOR)),\n+        URSHIFT             (28, \"URSHIFT\",     \"<<<\",  EnumSet.of(TokenType.OPERATOR)),\n+        ADD                 (29, \"ADD\",         \"+\",    EnumSet.of(TokenType.OPERATOR)),\n+        SUB                 (30, \"SUB\",         \"-\",    EnumSet.of(TokenType.OPERATOR)),\n+        DIV                 (31, \"DIV\",         \"\/\",    EnumSet.of(TokenType.OPERATOR)),\n+        REM                 (32, \"REM\",         \"%\",    EnumSet.of(TokenType.OPERATOR)),\n+        MUL                 (33, \"MUL\",         \"*\",    EnumSet.of(TokenType.OPERATOR)),\n+        CAST                (34, \"CAST\",        \"cast\", EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        POS                 (35, \"POS\",         \"+\",    EnumSet.of(TokenType.OPERATOR)),\n+        NEG                 (36, \"NEG\",         \"-\",    EnumSet.of(TokenType.OPERATOR)),\n+        NOT                 (37, \"NOT\",         \"!\",    EnumSet.of(TokenType.OPERATOR)),\n+        BITNOT              (38, \"BITNOT\",      \"~\",    EnumSet.of(TokenType.OPERATOR)),\n+        PREINC              (39, \"PREINC\",      \"++\",   EnumSet.of(TokenType.OPERATOR)),\n+        PREDEC              (40, \"PREDEC\",      \"--\",   EnumSet.of(TokenType.OPERATOR)),\n+        NEWARRAY            (41, \"NEWARRAY\",    \"new\",  EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        NEWINSTANCE         (42, \"NEWINSTANCE\", \"new\",  EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        NEWFROMNAME         (43, \"NEWFROMNAME\", \"new\",  EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        POSTINC             (44, \"POSTINC\",     \"++\",   EnumSet.of(TokenType.OPERATOR)),\n+        POSTDEC             (45, \"POSTDEC\",     \"--\",   EnumSet.of(TokenType.OPERATOR)),\n+        FIELD               (46, \"FIELD\",       \"field\", EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        METHOD              (47, \"METHOD\",      \"method\",  EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        ARRAYACCESS         (48, \"ARRAYACCESS\", \"[]\",   EnumSet.of(TokenType.OPERATOR)),\n+        NEW                 (49, \"NEW\",         \"new\",  EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        INC                 (50, \"INC\",         \"++\",   EnumSet.of(TokenType.OPERATOR)),\n+        DEC                 (51, \"DEC\",         \"--\",   EnumSet.of(TokenType.OPERATOR)),\n+\n+        CONVERT             (55, \"CONVERT\",     \"convert\", EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        EXPR                (56, \"EXPR\",        \"expr\", EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        ARRAY               (57, \"ARRAY\",       \"array\", EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+        GOTO                (58, \"GOTO\",        \"goto\", EnumSet.of(TokenType.OPERATOR, TokenType.MODULE_NAME)),\n+\n+    \/*\n+     * Value tokens\n+     *\/\n+        IDENT               (60, \"IDENT\",       \"Identifier\", EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME, TokenType.JASM_IDENT), KeywordType.VALUE),\n+        BOOLEANVAL          (61, \"BOOLEANVAL\",  \"Boolean\",    EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME),   KeywordType.VALUE),\n+        BYTEVAL             (62, \"BYTEVAL\",     \"Byte\",       EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME)),\n+        CHARVAL             (63, \"CHARVAL\",     \"Char\",       EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME)),\n+        SHORTVAL            (64, \"SHORTVAL\",    \"Short\",      EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME)),\n+        INTVAL              (65, \"INTVAL\",      \"Integer\",    EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME),   KeywordType.VALUE),\n+        LONGVAL             (66, \"LONGVAL\",     \"Long\",       EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME),   KeywordType.VALUE),\n+        FLOATVAL            (67, \"FLOATVAL\",    \"Float\",      EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME),   KeywordType.VALUE),\n+        DOUBLEVAL           (68, \"DOUBLEVAL\",   \"Double\",     EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME),   KeywordType.VALUE),\n+        STRINGVAL           (69, \"STRINGVAL\",   \"String\",     EnumSet.of(TokenType.VALUE, TokenType.MODULE_NAME),   KeywordType.VALUE),\n+\n+    \/*\n+     * Type keywords\n+     *\/\n+        BYTE                (70, \"BYTE\",        \"byte\",     EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME )),\n+        CHAR                (71, \"CHAR\",        \"char\",     EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME )),\n+        SHORT               (72, \"SHORT\",       \"short\",    EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME )),\n+        INT                 (73, \"INT\",         \"int\",      EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME )),\n+        LONG                (74, \"LONG\",        \"long\",     EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME )),\n+        FLOAT               (75, \"FLOAT\",       \"float\",    EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME)),\n+        DOUBLE              (76, \"DOUBLE\",      \"double\",   EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME)),\n+        VOID                (77, \"VOID\",        \"void\",     EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME)),\n+        BOOLEAN             (78, \"BOOLEAN\",     \"boolean\",  EnumSet.of(TokenType.TYPE, TokenType.MODULE_NAME)),\n+\n+    \/*\n+     * Expression keywords\n+     *\/\n+        TRUE                (80, \"TRUE\",        \"true\",     EnumSet.of(TokenType.EXPRESSION, TokenType.MODULE_NAME )),\n+        FALSE               (81, \"FALSE\",       \"false\",    EnumSet.of(TokenType.EXPRESSION, TokenType.MODULE_NAME )),\n+        THIS                (82, \"THIS\",        \"this\",     EnumSet.of(TokenType.EXPRESSION, TokenType.MODULE_NAME )),\n+        SUPER               (83, \"SUPER\",       \"super\",    EnumSet.of(TokenType.MODIFIER,   TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        NULL                (84, \"NULL\",        \"null\",     EnumSet.of(TokenType.EXPRESSION, TokenType.MODULE_NAME )),\n+\n+    \/*\n+     * Statement keywords\n+     *\/\n+        IF                  (90, \"IF\",          \"if\",       EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        ELSE                (91, \"ELSE\",        \"else\",     EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        FOR                 (92, \"FOR\",         \"for\",      EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        WHILE               (93, \"WHILE\",       \"while\",    EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        DO                  (94, \"DO\",          \"do\",       EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        SWITCH              (95, \"SWITCH\",      \"switch\",   EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        CASE                (96, \"CASE\",        \"case\",     EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        DEFAULT             (97,  \"DEFAULT\",    \"default\",  EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        BREAK               (98, \"BREAK\",       \"break\",    EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        CONTINUE            (99, \"CONTINUE\",    \"continue\", EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        RETURN              (100, \"RETURN\",     \"return\",   EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        TRY                 (101, \"TRY\",        \"try\",      EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+\n+        CATCH               (102, \"CATCH\",      \"catch\",    EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        FINALLY             (103, \"FINALLY\",    \"finally\",  EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        THROW               (104, \"THROW\",      \"throw\",            EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        STAT                (105, \"STAT\",       \"stat\",             EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        EXPRESSION          (106, \"EXPRESSION\", \"expression\",       EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        DECLARATION         (107, \"DECLARATION\", \"declaration\",     EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+        VARDECLARATION      (108, \"VARDECLARATION\", \"vdeclaration\", EnumSet.of(TokenType.STATEMENT, TokenType.MODULE_NAME )),\n+\n+    \/*\n+     * Declaration keywords\n+     *\/\n+        IMPORT              (110, \"IMPORT\",     \"import\",   EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME )),\n+        CLASS               (111, \"CLASS\",      \"class\",    EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        EXTENDS             (112, \"EXTENDS\",    \"extends\",  EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        IMPLEMENTS          (113, \"IMPLEMENTS\", \"implements\",   EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        INTERFACE           (114, \"INTERFACE\",  \"interface\",    EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        PACKAGE             (115, \"PACKAGE\",    \"package\",  EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        ENUM                (116, \"ENUM\",       \"enum\",     EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        MANDATED            (117, \"MANDATED\",   \"mandated\", EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        THROWS              (118, \"THROWS\",     \"throws\",   EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+\n+    \/*\n+     * Modifier keywords\n+     *\/\n+        ANNOTATION_ACCESS   (119, \"ANNOTATION_ACCESS\",  \"annotation\",       EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        PRIVATE             (120, \"PRIVATE\",            \"private\",          EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        PUBLIC              (121, \"PUBLIC\",             \"public\",           EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        PROTECTED           (122, \"PROTECTED\",          \"protected\",        EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        CONST               (123, \"CONST\",              \"const\",            EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME), KeywordType.KEYWORD),\n+        STATIC              (124, \"STATIC\",             \"static\",           EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        TRANSIENT           (125, \"TRANSIENT\",          \"transient\",        EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        SYNCHRONIZED        (126, \"SYNCHRONIZED\",       \"synchronized\",     EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        NATIVE              (127, \"NATIVE\",             \"native\",           EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        FINAL               (128, \"FINAL\",              \"final\",            EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        VOLATILE            (129, \"VOLATILE\",           \"volatile\",         EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        ABSTRACT            (130, \"ABSTRACT\",           \"abstract\",         EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        TRANSITIVE          (131, \"TRANSITIVE\",         \"transitive\",       EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        OPEN                (132, \"OPEN\",               \"open\",             EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+\n+    \/*\n+     * Punctuation\n+     *\/\n+        AT_SIGN             (133, \"AT\",         \";\",       EnumSet.of(TokenType.PUNCTUATION), KeywordType.VALUE),\n+        SEMICOLON           (134, \"SEMICOLON\",  \";\",       EnumSet.of(TokenType.PUNCTUATION), KeywordType.VALUE),\n+        COLON               (135, \"COLON\",      \":\",       EnumSet.of(TokenType.PUNCTUATION), KeywordType.VALUE),\n+        QUESTIONMARK        (136, \"QUESTIONMARK\", \"?\",     EnumSet.of(TokenType.PUNCTUATION)),\n+        LBRACE              (137, \"LBRACE\",     \"{\",       EnumSet.of(TokenType.PUNCTUATION), KeywordType.VALUE),\n+        RBRACE              (138, \"RBRACE\",     \"}\",       EnumSet.of(TokenType.PUNCTUATION), KeywordType.VALUE),\n+        LPAREN              (139, \"LPAREN\",     \"(\",       EnumSet.of(TokenType.PUNCTUATION)),\n+        RPAREN              (140, \"RPAREN\",     \")\",       EnumSet.of(TokenType.PUNCTUATION)),\n+        LSQBRACKET          (141, \"LSQBRACKET\", \"[\",       EnumSet.of(TokenType.PUNCTUATION)),\n+        RSQBRACKET          (142, \"RSQBRACKET\", \"]\",       EnumSet.of(TokenType.PUNCTUATION)),\n+\n+        ESCAPED_COLON       (201, \"ESCCOLON\",     \"\\\\:\",     EnumSet.of(TokenType.PUNCTUATION, TokenType.MODULE_NAME)),\n+        ESCAPED_ATSIGH      (202, \"ESCATSIGH\",    \"\\\\@\",     EnumSet.of(TokenType.PUNCTUATION, TokenType.MODULE_NAME)),\n+        ESCAPED_BACKSLASH   (203, \"ESCBACKSLASH\", \"\\\\\\\\\",    EnumSet.of(TokenType.PUNCTUATION, TokenType.MODULE_NAME)),\n+    \/*\n+     * Special tokens\n+     *\/\n+        ERROR               (145, \"ERROR\",      \"error\",    EnumSet.of(TokenType.MODIFIER,    TokenType.MODULE_NAME)),\n+        COMMENT             (146, \"COMMENT\",    \"comment\",  EnumSet.of(TokenType.MODIFIER,    TokenType.MODULE_NAME)),\n+        TYPE                (147, \"TYPE\",       \"type\",     EnumSet.of(TokenType.MODIFIER,    TokenType.MODULE_NAME)),\n+        LENGTH              (148, \"LENGTH\",     \"length\",   EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME )),\n+        INLINERETURN        (149, \"INLINERETURN\", \"inline-return\",  EnumSet.of(TokenType.MODIFIER)),\n+        INLINEMETHOD        (150, \"INLINEMETHOD\", \"inline-method\",  EnumSet.of(TokenType.MODIFIER)),\n+        INLINENEWINSTANCE   (151, \"INLINENEWINSTANCE\", \"inline-new\",EnumSet.of(TokenType.MODIFIER)),\n+\n+    \/*\n+     * Added for jasm\n+     *\/\n+        METHODREF           (152, \"METHODREF\",  \"Method\",   EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        FIELDREF            (153, \"FIELD\",      \"Field\",    EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        STACK               (154, \"STACK\",      \"stack\",    EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        LOCAL               (155, \"LOCAL\",      \"locals\",   EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        CPINDEX             (156, \"CPINDEX\",    \"CPINDEX\",  EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME )),\n+        CPNAME              (157, \"CPNAME\",     \"CPName\",   EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME )),\n+        SIGN                (158, \"SIGN\",       \"SIGN\",     EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME )),\n+        BITS                (159, \"BITS\",       \"bits\",                 EnumSet.of(TokenType.MISC, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+\n+        INF                 (160, \"INF\",        \"Inf\", \"Infinity\",  EnumSet.of(TokenType.MISC, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        NAN                 (161, \"NAN\",        \"NaN\",                  EnumSet.of(TokenType.MISC, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+\n+        INNERCLASS          (162, \"INNERCLASS\", \"InnerClass\",       EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        OF                  (163, \"OF\",         \"of\",               EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        SYNTHETIC           (164, \"SYNTHETIC\",  \"synthetic\",  EnumSet.of(TokenType.MODIFIER, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        STRICT              (165, \"STRICT\",     \"strict\",     EnumSet.of(TokenType.MODIFIER, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        DEPRECATED          (166, \"DEPRECATED\", \"deprecated\", EnumSet.of(TokenType.MODIFIER, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        VERSION             (167, \"VERSION\",    \"version\",    EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        MODULE              (168, \"MODULE\",     \"module\",   EnumSet.of(TokenType.DECLARATION, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        ANNOTATION          (169, \"ANNOTATION\", \"@\",        EnumSet.of(TokenType.MISC, TokenType.MODULE_NAME )),\n+        PARAM_NAME          (173, \"PARAM_NAME\", \"#\",        EnumSet.of(TokenType.MISC, TokenType.MODULE_NAME )),\n+\n+        VARARGS             (170, \"VARARGS\",    \"varargs\",  EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        BRIDGE              (171, \"BRIDGE\",     \"bridge\",   EnumSet.of(TokenType.MODIFIER, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+\n+        \/\/ Declaration keywords\n+        BOOTSTRAPMETHOD     (172, \"BOOTSTRAPMETHOD\", \"BootstrapMethod\", EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        NESTHOST            (173, \"NESTHOST\",       \"NestHost\",         EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        NESTMEMBERS         (174, \"NESTMEMBERS\",    \"NestMembers\",      EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        \/\/\n+        RECORD              (175, \"RECORD\",    \"Record\",                EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        COMPONENT           (176, \"COMPONENT\", \"Component\",             EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        \/\/\n+        PERMITTEDSUBCLASSES (177, \"PERMITTEDSUBCLASSES\", \"PermittedSubclasses\", EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+\n+        \/\/Module statements\n+        REQUIRES            (180, \"REQUIRES\", \"requires\", EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        EXPORTS             (182, \"EXPORTS\",  \"exports\",  EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        TO                  (183, \"TO\",       \"to\",       EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        USES                (184, \"USES\",     \"uses\",     EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        PROVIDES            (185, \"PROVIDES\", \"provides\", EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        WITH                (186, \"WITH\",     \"with\",     EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        OPENS               (187, \"OPENS\",    \"opens\",    EnumSet.of(TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+\n+        \/\/ Table 4.7.20.2-1 type_path_kind\n+        ARRAY_TYPEPATH         (188, TypeAnnotationTypes.EPathKind.ARRAY.parseKey(),    TypeAnnotationTypes.EPathKind.ARRAY.parseKey(),\n+                EnumSet.of(TokenType.TYPE_PATH_KIND, TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        INNER_TYPE_TYPEPATH    (189, TypeAnnotationTypes.EPathKind.INNER_TYPE.parseKey(),    TypeAnnotationTypes.EPathKind.INNER_TYPE.parseKey(),\n+                EnumSet.of(TokenType.TYPE_PATH_KIND, TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        WILDCARD_TYPEPATH      (190, TypeAnnotationTypes.EPathKind.WILDCARD.parseKey(),    TypeAnnotationTypes.EPathKind.WILDCARD.parseKey(),\n+                EnumSet.of(TokenType.TYPE_PATH_KIND, TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD),\n+        TYPE_ARGUMENT_TYPEPATH (191, TypeAnnotationTypes.EPathKind.TYPE_ARGUMENT.parseKey(),    TypeAnnotationTypes.EPathKind.TYPE_ARGUMENT.parseKey(),\n+                EnumSet.of(TokenType.TYPE_PATH_KIND, TokenType.DECLARATION, TokenType.JASM_IDENT, TokenType.MODULE_NAME ), KeywordType.KEYWORD);\n+\n+        final static EnumSet<Token> ALL_TOKENS = EnumSet.allOf(Token.class);\n+        \/\/ Misc Keywords\n+        final private Integer value;                    \/\/ 160\n+        final private String  printval;                 \/\/ INF\n+        final private String  parsekey;                 \/\/ inf\n+        final private String  alias;                    \/\/ Infinity\n+        final private EnumSet<TokenType>  tokenType;    \/\/ TokenType.MISC, TokenType.MODULE_NAME\n+        final private KeywordType key_type;             \/\/ KeywordType.KEYWORD\n+\n+        public static Optional<Token> get(String  parsekey, KeywordType ktype) {\n+            return ALL_TOKENS.stream().\n+                    filter(t->t.key_type == ktype).\n+                    filter(t->t.parsekey.equals(parsekey) || ( t.alias != null && t.alias.equals(parsekey))).\n+                    findFirst();\n+        }\n+\n+        \/**\n+         * Checks that this enum element is in an enum list\n+         *\n+         * @param tokens the list of enum elements for checking\n+         * @return true if a tokens list contains this enum element\n+         *\/\n+        public boolean in(Token... tokens) {\n+            return (tokens == null) ? false : Arrays.asList(tokens).contains(this);\n+        }\n+\n+        \/\/ By default, if a KeywordType is not specified, it has the value 'TOKEN'\n+        Token(Integer val, String print, String parsekey, EnumSet<TokenType> ttype) {\n+            this(val, print, parsekey, null, ttype, KeywordType.TOKEN);\n+        }\n+\n+        Token(Integer val, String print, String parsekey, String als, EnumSet<TokenType> ttype) {\n+            this(val, print, parsekey, als, ttype, KeywordType.TOKEN);\n+        }\n+\n+        Token(Integer val, String print, String parsekey, EnumSet<TokenType> ttype, KeywordType ktype) {\n+            this(val, print, parsekey, null, ttype, ktype);\n+        }\n+\n+        Token(Integer val, String print, String parsekey, String als, EnumSet<TokenType> ttype, KeywordType ktype) {\n+            this.value = val;\n+            this.printval = print;\n+            this.parsekey = parsekey;\n+            this.tokenType = ttype;\n+            this.key_type = ktype;\n+            this.alias = als;\n+        }\n+\n+        public String printValue() {\n+            return printval;\n+        }\n+\n+        public String parseKey() {\n+            return parsekey;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public boolean possibleJasmIdentifier() {\n+            return tokenType.contains(TokenType.JASM_IDENT);\n+        }\n+\n+        public boolean possibleModuleName() {  return tokenType.contains(TokenType.MODULE_NAME)  && !tokenType.contains(TokenType.PUNCTUATION); }\n+\n+        \/**\n+         * Checks a token belonging to the table: Table 4.7.20.2-A. Interpretation of type_path_kind values\n+         *\n+         * @return true if token is ARRAY, INNER_TYPE, WILDCARD or TYPE_ARGUMENT\n+         *\/\n+        public boolean possibleTypePathKind() { return tokenType.contains(TokenType.TYPE_PATH_KIND); }\n+\n+        @Override\n+        public String toString() {\n+            return \"<\" + printval + \"> [\" + value + \"]\";\n+        }\n+    }\n+\n+    public static Token keyword_token_ident(String idValue) {\n+        return Token.get(idValue,KeywordType.KEYWORD).orElse(Token.IDENT);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/JasmTokens.java","additions":487,"deletions":0,"binary":false,"changes":487,"status":"added"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+ * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import static org.openjdk.asmtools.jasm.CFVersion.DEFAULT_MAJOR_VERSION;\n+import static org.openjdk.asmtools.jasm.CFVersion.DEFAULT_MINOR_VERSION;\n+\n+import org.openjdk.asmtools.common.Tool;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+import org.openjdk.asmtools.util.ProductInfo;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+\n+\/**\n+ *\n+ *\n+ *\/\n+public class Main extends Tool {\n+\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    private File destDir = null;\n+    private boolean traceFlag = false;\n+    private long tm = System.currentTimeMillis();\n+    private ArrayList<String> v = new ArrayList<>();\n+    private boolean nowrite = false;\n+    private boolean nowarn = false;\n+    private boolean strict = false;\n+    private String props = null;\n+    private int nwarnings = 0;\n+    private CFVersion cfv = new CFVersion();\n+    private int bytelimit = 0;\n+    private boolean debugScanner = false;\n+    private boolean debugMembers = false;\n+    private boolean debugCP = false;\n+    private boolean debugAnnot = false;\n+    private boolean debugInstr = false;\n+\n+\n+    public Main(PrintWriter out, String programName) {\n+        super(out, programName);\n+        printCannotReadMsg = (fname) ->\n+            error( i18n.getString(\"jasm.error.cannot_read\", fname));\n+    }\n+\n+    public Main(PrintStream out, String program) {\n+        this(new PrintWriter(out), program);\n+    }\n+\n+    @Override\n+    public void usage() {\n+        println(i18n.getString(\"jasm.usage\"));\n+        println(i18n.getString(\"jasm.opt.d\"));\n+        println(i18n.getString(\"jasm.opt.g\"));\n+        println(i18n.getString(\"jasm.opt.v\"));\n+        println(i18n.getString(\"jasm.opt.nowrite\"));\n+        println(i18n.getString(\"jasm.opt.nowarn\"));\n+        println(i18n.getString(\"jasm.opt.strict\"));\n+        println(i18n.getString(\"jasm.opt.cv\", DEFAULT_MAJOR_VERSION, DEFAULT_MINOR_VERSION));\n+        println(i18n.getString(\"jasm.opt.version\"));\n+    }\n+\n+    \/**\n+     * Run the compiler\n+     *\/\n+    private synchronized boolean parseArgs(String argv[]) {\n+        \/\/ Parse arguments\n+        boolean frozenCFV = false;\n+        for (int i = 0; i < argv.length; i++) {\n+            String arg = argv[i];\n+            switch (arg) {\n+                case \"-v\":\n+                    traceFlag = true;\n+                    break;\n+                case \"-g\":\n+                    super.DebugFlag = () -> true;\n+                    break;\n+                case \"-nowrite\":\n+                    nowrite = true;\n+                    break;\n+                case \"-strict\":\n+                    strict = true;\n+                    break;\n+                case \"-nowarn\":\n+                    nowarn = true;\n+                    break;\n+                case \"-version\":\n+                    println(ProductInfo.FULL_VERSION);\n+                    break;\n+                case \"-d\":\n+                    if ((i + 1) >= argv.length) {\n+                        error(i18n.getString(\"jasm.error.d_requires_argument\"));\n+                        usage();\n+                        return false;\n+                    }\n+                    destDir = new File(argv[++i]);\n+                    if (!destDir.exists()) {\n+                        error(i18n.getString(\"jasm.error.does_not_exist\", destDir.getPath()));\n+                        return false;\n+                    }\n+                    break;\n+                \/\/ non-public options\n+                case \"-XdScanner\":\n+                    debugScanner = true;\n+                    break;\n+                case \"-XdMember\":\n+                    debugMembers = true;\n+                    break;\n+                case \"-XdCP\":\n+                    debugCP = true;\n+                    break;\n+                case \"-XdInstr\":\n+                    debugInstr = true;\n+                    break;\n+                case \"-XdAnnot\":\n+                    debugAnnot = true;\n+                    break;\n+                case \"-XdAll\":\n+                    debugScanner = true;\n+                    debugMembers = true;\n+                    debugCP = true;\n+                    debugInstr = true;\n+                    debugAnnot = true;\n+                    break;\n+                case \"-Xdlimit\":\n+                    \/\/ parses file until the specified byte number\n+                    if (i + 1 > argv.length) {\n+                        println(\" Error: Unspecified byte-limit\");\n+                        return false;\n+                    } else {\n+                        i++;\n+                        String bytelimstr = argv[i];\n+                        bytelimit = 0;\n+                        try {\n+                            bytelimit = Integer.parseInt(bytelimstr);\n+                        } catch (NumberFormatException e) {\n+                            println(\" Error: Unspecified byte-limit\");\n+                            return false;\n+                        }\n+                    }\n+                    break;\n+                case \"-fixcv\":\n+                    \/\/ overrides cf version if it's defined in the source file.\n+                    frozenCFV = true;\n+                \/\/ public options\n+                case \"-cv\":\n+                    if ((i + 1) >= argv.length) {\n+                        error(i18n.getString(\"jasm.error.cv_requires_arg\"));\n+                        usage();\n+                        return false;\n+                    }\n+                    String[] versions = {\"\", \"\"};                      \/\/ workaround for String.split()\n+                    int index = argv[++i].indexOf(\".\");                \/\/\n+                    if (index != -1) {                                 \/\/\n+                        versions[0] = argv[i].substring(0, index);     \/\/\n+                        versions[1] = argv[i].substring(index + 1);    \/\/\n+                    }                                                  \/\/\n+                    if (versions.length != 2) {\n+                        error(i18n.getString(\"jasm.error.invalid_major_minor_param\"));\n+                        usage();\n+                        return false;\n+                    }\n+                    try {\n+                        cfv = new CFVersion(frozenCFV, Short.parseShort(versions[0]), Short.parseShort(versions[1]) );\n+                    } catch (NumberFormatException e) {\n+                        error(i18n.getString(\"jasm.error.invalid_major_minor_param\"));\n+                        usage();\n+                        return false;\n+                    }\n+                    break;\n+                default:\n+                    if (arg.startsWith(\"-\")) {\n+                        error(i18n.getString(\"jasm.error.invalid_option\", arg));\n+                        usage();\n+                        return false;\n+                    } else {\n+                        v.add(argv[i]);\n+                    }\n+                    break;\n+            }\n+        }\n+        if (v.size() == 0) {\n+            usage();\n+            return false;\n+        }\n+        if (strict) {\n+            nowarn = false;\n+        }\n+        return true;\n+    }\n+\n+    private void reset() {\n+        destDir = null;\n+        traceFlag = false;\n+        super.DebugFlag = () -> false;\n+        System.currentTimeMillis();\n+        v = new ArrayList<>();\n+        nowrite = false;\n+        nowarn = false;\n+        strict = false;\n+        props = null;\n+        nwarnings = 0;\n+        bytelimit = 0;\n+    }\n+\n+    \/**\n+     * Run the compiler\n+     *\/\n+    public synchronized boolean compile(String argv[]) {\n+        \/\/ Reset the state of all objs\n+        reset();\n+\n+        boolean validArgs = parseArgs(argv);\n+        if (!validArgs) {\n+            return false;\n+        }\n+        \/\/ compile all input files\n+        Environment sf = null;\n+        try {\n+            for (String inpname : v) {\n+                Parser p;\n+\n+                DataInputStream dataInputStream = getDataInputStream(inpname);\n+                if( dataInputStream == null ) {\n+                    nerrors++;\n+                    continue;\n+                }\n+                sf = new Environment(dataInputStream, inpname, out, nowarn);\n+                sf.traceFlag = traceFlag;\n+                sf.debugInfoFlag = DebugFlag.getAsBoolean();\n+                p = new Parser(sf, cfv.clone() );\n+                p.setDebugFlags(debugScanner, debugMembers, debugCP, debugAnnot, debugInstr);\n+                p.parseFile();\n+\n+                nerrors += sf.nerrors;\n+                nwarnings += sf.nwarnings;\n+                if (nowrite || (nerrors > 0)) {\n+                    sf.flushErrors();\n+                    continue;\n+                }\n+                try {\n+                    ClassData[] clsData = p.getClassesData();\n+                    for (int i = 0; i < clsData.length; i++) {\n+                        ClassData cd = clsData[i];\n+                        if (bytelimit > 0) {\n+                            cd.setByteLimit(bytelimit);\n+                        }\n+                        cd.write(destDir);\n+                    }\n+                } catch (IOException ex) {\n+                    if (bytelimit > 0) {\n+                        \/\/ IO Error thrown from user-specified byte count\n+                        ex.printStackTrace();\n+                        error(\"UserSpecified byte-limit at byte[\" + bytelimit + \"]: \" +\n+                                ex.getMessage() + \"\\n\" +\n+                                inpname + \": [\" + sf.lineNumber() + \", \" + sf.lineOffset() + \"]\");\n+                    } else {\n+                        String er = i18n.getString(\"jasm.error.cannot_write\", ex.getMessage());\n+                        error(er + \"\\n\" + inpname + \": [\" + sf.lineNumber() + \", \" + sf.lineOffset() + \"]\");\n+                    }\n+                }\n+                sf.flushErrors(); \/\/ possible errors from write()\n+            }\n+        } catch (Error ee) {\n+            if (DebugFlag.getAsBoolean()) {\n+                ee.printStackTrace();\n+            }\n+            String er = ee.getMessage() + \"\\n\" + i18n.getString(\"jasm.error.fatal_error\");\n+            error(er + \"\\n\" + sf.getInputFileName() + \": [\" + sf.lineNumber() + \", \" + sf.lineOffset() + \"]\");\n+        } catch (Exception ee) {\n+            if (DebugFlag.getAsBoolean()) {\n+                ee.printStackTrace();\n+            }\n+            String er = ee.getMessage() + \"\\n\" + ee.getMessage() + \"\\n\" + i18n.getString(\"jasm.error.fatal_exception\");\n+            error(er + \"\\n\" + sf.getInputFileName() + \": [\" + sf.lineNumber() + \", \" + sf.lineOffset() + \"]\");\n+        }\n+\n+        boolean errs = nerrors > 0;\n+        boolean warns = (nwarnings > 0) && (!nowarn);\n+        boolean errsOrWarns = errs || warns;\n+        if (!errsOrWarns) {\n+            return true;\n+        }\n+        if (errs) {\n+            out.print(nerrors > 1 ? (nerrors + \" errors\") : \"1 error\");\n+        }\n+        if (errs && warns) {\n+            out.print(\", \");\n+        }\n+        if (warns) {\n+            out.print(nwarnings > 1 ? (nwarnings + \" warnings\") : \"1 warning\");\n+        }\n+        println();\n+        if (strict) {\n+            return !errsOrWarns;\n+        } else {\n+            return !errs;\n+        }\n+    }\n+\n+    \/**\n+     * main program\n+     *\/\n+    public static void main(String argv[]) {\n+        Main compiler = new Main(new PrintWriter(System.out), \"jasm\");\n+        System.exit(compiler.compile(argv) ? 0 : 1);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Main.java","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import static org.openjdk.asmtools.jasm.RuntimeConstants.DEPRECATED_ATTRIBUTE;\n+import static org.openjdk.asmtools.jasm.RuntimeConstants.SYNTHETIC_ATTRIBUTE;\n+import org.openjdk.asmtools.jasm.Tables.AttrTag;\n+import java.util.ArrayList;\n+\n+\/**\n+ * The common base structure for field_info, method_info, and component_info\n+ *\/\n+abstract public class MemberData {\n+\n+    protected int access;\n+    protected AttrData syntheticAttr, deprecatedAttr;\n+    protected DataVectorAttr<AnnotationData> annotAttrVis = null;\n+    protected DataVectorAttr<AnnotationData> annotAttrInv = null;\n+    protected DataVectorAttr<TypeAnnotationData> type_annotAttrVis = null;\n+    protected DataVectorAttr<TypeAnnotationData> type_annotAttrInv = null;\n+    protected ClassData cls;\n+    protected AttrData signatureAttr;\n+\n+    public MemberData(ClassData cls, int access) {\n+        this.cls = cls;\n+        init(access);\n+    }\n+\n+    public MemberData(ClassData cls) {\n+        this.cls = cls;\n+    }\n+\n+    public void init(int access) {\n+        this.access = access;\n+    }\n+\n+    public void createPseudoMod() {\n+        \/\/ If a member has a Pseudo-modifier\n+\n+        \/\/ create the appropriate marker attributes,\n+        \/\/ and clear the PseudoModifiers from the access flags.\n+        if (Modifiers.isSyntheticPseudoMod(access)) {\n+            syntheticAttr = new AttrData(cls, AttrTag.ATT_Synthetic.parsekey());\n+            access &= ~SYNTHETIC_ATTRIBUTE;\n+        }\n+        if (Modifiers.isDeprecatedPseudoMod(access)) {\n+            deprecatedAttr = new AttrData(cls, AttrTag.ATT_Deprecated.parsekey());\n+            access &= ~DEPRECATED_ATTRIBUTE;\n+        }\n+    }\n+\n+    public void setSignatureAttr(ConstantPool.ConstCell value_cpx) {\n+        signatureAttr = new CPXAttr(cls, Tables.AttrTag.ATT_Signature.parsekey(), value_cpx);\n+    }\n+\n+    protected abstract DataVector getAttrVector();\n+\n+    protected final DataVector getDataVector(Data... extraAttrs) {\n+        DataVector attrs = new DataVector();\n+        for( Data extra : extraAttrs ) {\n+            if (extra != null) {\n+                attrs.add(extra);\n+            }\n+        }\n+        \/\/ common set for [ FieldData, MethodData, RecordData ]\n+        if (annotAttrVis != null) {\n+            attrs.add(annotAttrVis);\n+        }\n+        if (annotAttrInv != null) {\n+            attrs.add(annotAttrInv);\n+        }\n+        if (type_annotAttrVis != null) {\n+            attrs.add(type_annotAttrVis);\n+        }\n+        if (type_annotAttrInv != null) {\n+            attrs.add(type_annotAttrInv);\n+        }\n+        return attrs;\n+    }\n+\n+    public void addAnnotations(ArrayList<AnnotationData> list) {\n+        for (AnnotationData item : list) {\n+            boolean invisible = item.invisible;\n+            if (item instanceof TypeAnnotationData) {\n+                \/\/ Type Annotations\n+                TypeAnnotationData ta = (TypeAnnotationData) item;\n+                if (invisible) {\n+                    if (type_annotAttrInv == null) {\n+                        type_annotAttrInv = new DataVectorAttr(cls,\n+                                AttrTag.ATT_RuntimeInvisibleTypeAnnotations.parsekey());\n+                    }\n+                    type_annotAttrInv.add(ta);\n+                } else {\n+                    if (type_annotAttrVis == null) {\n+                        type_annotAttrVis = new DataVectorAttr(cls,\n+                                AttrTag.ATT_RuntimeVisibleTypeAnnotations.parsekey());\n+                    }\n+                    type_annotAttrVis.add(ta);\n+                }\n+            } else {\n+                \/\/ Regular Annotations\n+                if (invisible) {\n+                    if (annotAttrInv == null) {\n+                        annotAttrInv = new DataVectorAttr(cls,\n+                                AttrTag.ATT_RuntimeInvisibleAnnotations.parsekey());\n+                    }\n+                    annotAttrInv.add(item);\n+                } else {\n+                    if (annotAttrVis == null) {\n+                        annotAttrVis = new DataVectorAttr(cls,\n+                                AttrTag.ATT_RuntimeVisibleAnnotations.parsekey());\n+                    }\n+                    annotAttrVis.add(item);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/MemberData.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.jasm.Tables.AttrTag;\n+import org.openjdk.asmtools.jasm.ConstantPool.ConstCell;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TreeMap;\n+\n+\/**\n+ *\n+ *\/\n+class MethodData extends MemberData {\n+\n+    \/**\n+     * MethodParamData\n+     *\/\n+    class ParamNameData implements Data {\n+\n+        int access;\n+        ConstCell name;\n+\n+        public ParamNameData(int access, ConstCell name) {\n+            this.access = access;\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 4;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            int nm = 0;\n+            int ac = 0;\n+            if (name != null) {\n+                nm = name.arg;\n+                ac = access;\n+            }\n+            out.writeShort(nm);\n+            out.writeShort(ac);\n+        }\n+    }\/\/ end class MethodParamData\n+\n+    \/**\n+     * Used to store Parameter Arrays (as attributes)\n+     *\/\n+    static public class DataPArrayAttr<T extends Data> extends AttrData implements Constants {\n+\n+        TreeMap<Integer, ArrayList<T>> elements; \/\/ Data\n+        int paramsTotal;\n+\n+        public DataPArrayAttr(ClassData cls, String name, int paramsTotal, TreeMap<Integer, ArrayList<T>> elements) {\n+            super(cls, name);\n+            this.paramsTotal = paramsTotal;\n+            this.elements = elements;\n+        }\n+\n+        public DataPArrayAttr(ClassData cls, String name, int paramsTotal) {\n+            this(cls, name, paramsTotal, new TreeMap<Integer, ArrayList<T>>());\n+        }\n+\n+        public void put(int paramNum, T element) {\n+            ArrayList<T> v = get(paramNum);\n+            if (v == null) {\n+                v = new ArrayList<>();\n+                elements.put(paramNum, v);\n+            }\n+\n+            v.add(element);\n+        }\n+\n+        public ArrayList<T> get(int paramNum) {\n+            return elements.get(paramNum);\n+        }\n+\n+        @Override\n+        public int attrLength() {\n+            int length = 1;  \/\/ One byte for the parameter count\n+\n+            \/\/ calculate overall size here rather than in add()\n+            \/\/ because it may not be available at the time of invoking of add()\n+            for (int i = 0; i < paramsTotal; i++) {\n+                ArrayList<T> attrarray = get(i);\n+                if (attrarray != null) {\n+                    for (Data item : attrarray) {\n+                        length += item.getLength();\n+                    }\n+                }\n+                length += 2; \/\/ 2 bytes for the annotation count for each parameter\n+            }\n+\n+            return length;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            super.write(out);  \/\/ attr name, attr len\n+            out.writeByte(paramsTotal); \/\/ number of parameters total (in byte)\n+\n+            for (int i = 0; i < paramsTotal; i++) {\n+                ArrayList<T> attrarray = get(i);\n+                if (attrarray != null) {\n+                    \/\/ write out the number of annotations for the current param\n+                    out.writeShort(attrarray.size());\n+                    for (T item : attrarray) {\n+                        item.write(out); \/\/ write the current annotation\n+                    }\n+                } else {\n+                    out.writeShort(0);\n+                    \/\/ No annotations to write out\n+                }\n+            }\n+        }\n+    }\/\/ end class DataPArrayAttr\n+\n+\n+    \/* Method Data Fields *\/\n+    protected Environment env;\n+    protected ConstCell nameCell, sigCell;\n+    protected CodeAttr code;\n+    protected DataVectorAttr<ConstCell> exceptions = null;\n+    protected DataVectorAttr<ParamNameData> paramNames = null;\n+    protected DataPArrayAttr<AnnotationData> pannotAttrVis = null;\n+    protected DataPArrayAttr<AnnotationData> pannotAttrInv = null;\n+    protected DefaultAnnotationAttr defaultAnnot = null;\n+\n+    public MethodData(ClassData cls, int acc,\n+            ConstCell name, ConstCell sig, ArrayList<ConstCell> exc_table) {\n+        super(cls, acc);\n+        this.env = cls.env;\n+        nameCell = name;\n+        sigCell = sig;\n+        if ((exc_table != null) && (!exc_table.isEmpty())) {\n+            exceptions = new DataVectorAttr<>(cls,\n+                    AttrTag.ATT_Exceptions.parsekey(),\n+                    exc_table);\n+        }\n+        \/\/ Normalize the modifiers to access flags\n+        if (Modifiers.hasPseudoMod(acc)) {\n+            createPseudoMod();\n+        }\n+    }\n+\n+    public void addMethodParameter(int totalParams, int paramNum, ConstCell name, int access) {\n+        env.traceln(\"addMethodParameter Param[\" + paramNum + \"] (name: \" + name.toString() + \", Flags (\" + access + \").\");\n+        if (paramNames == null) {\n+            paramNames = new DataVectorAttr<>(cls, AttrTag.ATT_MethodParameters.parsekey(), true);\n+            for (int i = 0; i < totalParams; i++) {\n+                \/\/ initialize the paramName array (in case the name is not given in Jasm syntax)\n+                paramNames.add(new ParamNameData(0, null));\n+            }\n+        }\n+        paramNames.put(paramNum, new ParamNameData(access, name));\n+    }\n+\n+    public CodeAttr startCode(int pos, int paramcnt, Argument max_stack, Argument max_locals) {\n+        code = new CodeAttr(this, pos, paramcnt, max_stack, max_locals);\n+        return code;\n+    }\n+\n+    public void addDefaultAnnotation(DefaultAnnotationAttr data) {\n+        defaultAnnot = data;\n+    }\n+\n+    public void addParamAnnotation(int totalParams, int paramNum, AnnotationData data) {\n+        if (!data.invisible) {\n+            if (pannotAttrVis == null) {\n+                pannotAttrVis = new DataPArrayAttr<>(cls,\n+                        AttrTag.ATT_RuntimeVisibleParameterAnnotations.parsekey(),\n+                        totalParams);\n+            }\n+            pannotAttrVis.put(paramNum, data);\n+\n+        } else {\n+            if (pannotAttrInv == null) {\n+                pannotAttrInv = new DataPArrayAttr<>(cls,\n+                        AttrTag.ATT_RuntimeInvisibleParameterAnnotations.parsekey(),\n+                        totalParams);\n+            }\n+            pannotAttrInv.put(paramNum, data);\n+        }\n+    }\n+\n+    @Override\n+    protected DataVector getAttrVector() {\n+        DataVector dv = getDataVector( exceptions, syntheticAttr, deprecatedAttr, paramNames, code, defaultAnnot);\n+        if (pannotAttrVis != null) {\n+            dv.add(pannotAttrVis);\n+        }\n+        if (pannotAttrInv != null) {\n+            dv.add(pannotAttrInv);\n+        }\n+        return dv;\n+    }\n+\n+    \/*====================================================== Write *\/\n+    public void write(CheckedDataOutputStream out) throws IOException, Parser.CompilerError {\n+        out.writeShort(access);\n+        out.writeShort(nameCell.arg);\n+        out.writeShort(sigCell.arg);\n+        getAttrVector().write(out);\n+    }\n+} \/\/ end MethodData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/MethodData.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,465 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import static org.openjdk.asmtools.jasm.JasmTokens.Token;\n+import static org.openjdk.asmtools.jasm.RuntimeConstants.*;\n+import static org.openjdk.asmtools.jasm.Tables.CF_Context;\n+\n+\/**\n+ *\n+ *\n+ *\/\n+public class Modifiers {\n+\n+    \/*\n+     * Modifier masks\n+     *\/\n+    public static final int MM_ATTR        = SYNTHETIC_ATTRIBUTE | DEPRECATED_ATTRIBUTE;\n+\n+    public static final int MM_ACCESS      = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;\n+\n+    public static final int MM_INTRF       = MM_ACCESS  | ACC_ABSTRACT  | ACC_INTERFACE | MM_ATTR | ACC_ANNOTATION;\n+\n+    public static final int MM_CLASS       = MM_ACCESS  | ACC_FINAL     |  ACC_SUPER    | ACC_ABSTRACT | ACC_ENUM |\n+                                             MM_ATTR    |  ACC_MODULE ;\n+\n+    public static final int MM_FIELD       = MM_ACCESS    | ACC_STATIC | ACC_FINAL    |  ACC_VOLATILE | ACC_TRANSIENT |\n+                                            ACC_SYNTHETIC | ACC_ENUM   |\n+                                            ACC_MANDATED |         \/\/ JEP 359 Record\n+                                            MM_ATTR;\n+\n+    public static final int MM_I_METHOD    = ACC_ABSTRACT | ACC_PUBLIC | ACC_PRIVATE | ACC_STATIC | ACC_VARARGS |\n+                                            ACC_BRIDGE    | ACC_SYNTHETIC ; \/\/ interface method\n+\n+    public static final int MM_A_METHOD    = MM_ACCESS | ACC_ABSTRACT | MM_ATTR;\n+\n+    public static final int MM_N_METHOD    = MM_ACCESS | ACC_STRICT | ACC_VARARGS | ACC_SYNTHETIC | MM_ATTR;  \/\/ <init>\n+\n+    public static final int MM_METHOD      = MM_ACCESS    | ACC_STATIC | ACC_FINAL    | ACC_SYNCHRONIZED |  ACC_BRIDGE |\n+                                             ACC_VARARGS  | ACC_NATIVE | ACC_ABSTRACT |  ACC_STRICT      | ACC_SYNTHETIC |\n+                                             ACC_MANDATED |         \/\/ JEP 359 Record\n+                                             MM_ATTR ;\n+\n+    public static final int MM_INNERCLASS  = MM_ACCESS    | ACC_STATIC    | ACC_FINAL      | ACC_SUPER | ACC_INTERFACE |\n+                                             ACC_ABSTRACT | ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM  | MM_ATTR ;\n+\n+    public static final int MM_REQUIRES    = ACC_TRANSITIVE | ACC_STATIC_PHASE  | ACC_SYNTHETIC | ACC_MANDATED ;\n+\n+    public static final int MM_EXPORTS     = ACC_SYNTHETIC | ACC_MANDATED ;\n+\n+    private Modifiers() {\n+    }\n+\n+    public static boolean validRequires(int mod) {\n+        return (mod & ~MM_REQUIRES) == 0;\n+    }\n+\n+    public static boolean validExports(int mod) { return (mod & ~MM_EXPORTS) == 0; }\n+\n+    public static boolean validInnerClass(int mod) {\n+        return (mod & ~MM_INNERCLASS) == 0;\n+    }\n+\n+    public static boolean validField(int mod) {\n+        return (mod & ~MM_FIELD) == 0;\n+    }\n+\n+    public static boolean validMethod(int mod) {\n+        return (mod & ~MM_METHOD) == 0;\n+    }\n+\n+    public static boolean validInterface(int mod) {\n+        return (mod & ~MM_INTRF) == 0;\n+    }\n+\n+    public static int getInvalidModifiers4Interface(int mod) {\n+        return  mod & ~MM_INTRF;\n+    }\n+\n+    public static boolean validClass(int mod) {\n+        return (mod & ~MM_CLASS) == 0;\n+    }\n+\n+    public static int getInvalidModifiers4Class(int mod) {\n+        return (mod & ~MM_CLASS);\n+    }\n+\n+    public static boolean validAbstractMethod(int mod) {\n+        return (mod & ~MM_A_METHOD) == 0;\n+    }\n+\n+    public static boolean validInitMethod(int mod) {\n+        return (mod & ~MM_N_METHOD) == 0;\n+    }\n+\n+    public static boolean validInterfaceMethod(int mod, ClassData cd) {\n+        return ((mod & ~MM_I_METHOD) == 0) &&\n+            (cd.cfv.major_version() >= 52 || isPublic(mod) && isAbstract(mod) && !isStatic(mod));\n+    }\n+\n+    public static boolean validInterfaceField(int mod) {\n+        return mod == (ACC_STATIC | ACC_PUBLIC | ACC_FINAL);\n+    }\n+\n+    public static boolean isPublic(int mod) {\n+        return (mod & ACC_PUBLIC) != 0;\n+    }\n+\n+    public static boolean isPrivate(int mod) {\n+        return (mod & ACC_PRIVATE) != 0;\n+    }\n+\n+    public static boolean isProtected(int mod) {\n+        return (mod & ACC_PROTECTED) != 0;\n+    }\n+\n+    public static boolean isInterface(int mod) {\n+        return (mod & ACC_INTERFACE) != 0;\n+    }\n+\n+    public static boolean isAbstract(int mod) {\n+        return (mod & ACC_ABSTRACT) != 0;\n+    }\n+\n+    public static boolean isFinal(int mod) {\n+        return (mod & ACC_FINAL) != 0;\n+    }\n+\n+    public static boolean isStatic(int mod) {\n+        return (mod & ACC_STATIC) != 0;\n+    }\n+\n+    public static boolean isSynthetic(int mod) {\n+        return (mod & ACC_SYNTHETIC) != 0;\n+    }\n+\n+    public static boolean isDeprecated(int mod) {\n+        return (mod & DEPRECATED_ATTRIBUTE) != 0;\n+    }\n+\n+    public static boolean isTransient(int mod) {\n+        return (mod & ACC_TRANSIENT) != 0;\n+    }\n+\n+    public static boolean isAnnotation(int mod) {\n+        return (mod & ACC_ANNOTATION) != 0;\n+    }\n+\n+    public static boolean isNative(int mod) {\n+        return (mod & ACC_NATIVE) != 0;\n+    }\n+\n+    public static boolean isStrict(int mod) {\n+        return (mod & ACC_STRICT) != 0;\n+    }\n+\n+    public static boolean isEnum(int mod) {\n+        return (mod & ACC_ENUM) != 0;\n+    }\n+\n+    public static boolean isSuper(int mod) {\n+        return (mod & ACC_SUPER) != 0;\n+    }\n+\n+    public static boolean isModule(int mod) { return (mod & ACC_MODULE)!=0; }\n+\n+    public static boolean isMandated(int mod) { return (mod & ACC_MANDATED) != 0; }\n+\n+    public static boolean isSynchronized(int mod) {\n+        return (mod & ACC_SYNCHRONIZED) != 0;\n+    }\n+\n+    public static boolean isBridge(int mod) {\n+        return (mod & ACC_BRIDGE) != 0;\n+    }\n+\n+    public static boolean isVolatile(int mod) {\n+        return (mod & ACC_VOLATILE) != 0;\n+    }\n+\n+    public static boolean isVarArgs(int mod) {\n+        return (mod & ACC_VARARGS) != 0;\n+    }\n+\n+    public static boolean isSyntheticPseudoMod(int mod) {\n+        return (mod & SYNTHETIC_ATTRIBUTE) != 0;\n+    }\n+\n+    public static boolean isDeprecatedPseudoMod(int mod) {\n+        return (mod & DEPRECATED_ATTRIBUTE) != 0;\n+    }\n+\n+    public static boolean hasPseudoMod(int mod) {\n+        return isSyntheticPseudoMod(mod) || isDeprecatedPseudoMod(mod);\n+    }\n+\n+    public static boolean isTransitive(int mod) { return (mod & ACC_TRANSITIVE) != 0;  }\n+\n+    public static boolean isStaticPhase(int mod) { return (mod & ACC_STATIC_PHASE) != 0;  }\n+\n+    \/*\n+     * Checks that only one (or none) of the Access flags are set.\n+     *\/\n+    public static boolean validAccess(int mod) {\n+        boolean retval = true;\n+        switch (mod & MM_ACCESS) {\n+            case 0:\n+            case ACC_PUBLIC:\n+            case ACC_PRIVATE:\n+            case ACC_PROTECTED:\n+                break;\n+            default:\n+                retval = false;\n+        }\n+        return retval;\n+    }\n+\n+    \/*\n+     * Are both flags set\n+     *\n+     *\/\n+    public static boolean both(int mod, int flagA, int flagB) {\n+        return (mod & (flagA | flagB)) == (flagA | flagB);\n+    }\n+\n+    \/**\n+     * Check the modifier flags for the class\n+     *\n+     * @param env       The error reporting environment.\n+     * @param mod       The modifier flags being checked\n+     * @param scanner   The file parser\n+     *\/\n+    public static void checkClassModifiers(Environment env, int mod, Scanner scanner) {\n+        if (isInterface(mod)) {\n+            if( isEnum(mod) ) {\n+                env.error(scanner.pos, \"warn.invalid.modifier.class.intenum\");\n+            } else if ( !validInterface(mod) ) {\n+                env.error(scanner.pos, \"warn.invalid.modifier.int\",\n+                        toString(mod & ~MM_INTRF, CF_Context.CTX_CLASS));\n+            }\n+            if (!isAbstract(mod)) {\n+                env.error(scanner.pos, \"warn.invalid.modifier.int.abs\");\n+            }\n+        } else {\n+            if ( scanner.token != Token.CLASS && !isEnum(mod) && scanner.token != Token.ANNOTATION) {\n+                env.error(scanner.pos, \"warn.missing.modifier.class\");\n+            }\n+            if (! validClass(mod)) {\n+                env.error(scanner.pos, \"warn.invalid.modifier.class\",\n+                            toString(mod & ~MM_CLASS, CF_Context.CTX_CLASS));\n+            }\n+            if (isAbstract(mod) && Modifiers.isFinal(mod)) {\n+                env.error(scanner.pos, \"warn.invalid.modifier.class.finabs\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Check the modifier flags for the field\n+     *\n+     * @param cd The ClassData for the current class\n+     * @param mod The modifier flags being checked\n+     * @param pos the position of the parser in the file\n+     *\/\n+    public static void checkFieldModifiers(ClassData cd, int mod, int pos) {\n+        Environment env = cd.env;\n+        if (cd.isInterface()) {\n+            \/\/ For interfaces\n+            if (!validInterfaceField(mod)) {\n+                env.error(pos, \"warn.invalid.modifier.intfield\");\n+            }\n+        } else {\n+            \/\/ For non-interfaces\n+            if (!validField(mod)) {\n+                env.error(pos, \"warn.invalid.modifier.field\",\n+                        toString(mod & ~MM_FIELD, CF_Context.CTX_METHOD));\n+            }\n+            if (both(mod, ACC_FINAL, ACC_VOLATILE)) {\n+                env.error(pos, \"warn.invalid.modifier.fiva\");\n+            }\n+            if (!validAccess(mod)) {\n+                env.error(pos, \"warn.invalid.modifier.acc\");\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * Check the modifier flags for the method\n+     *\n+     * @param cd The ClassData for the current class\n+     * @param mod The modifier flags being checked\n+     * @param pos the position of the parser in the file\n+     *\/\n+    public static void checkMethodModifiers(ClassData cd, int mod, int pos, boolean is_init, boolean is_clinit) {\n+        Environment env = cd.env;\n+        if (!is_clinit) {\n+            if (cd.isInterface()) {\n+                if (is_init) {\n+                    env.error(pos, \"warn.init.in_int\");\n+                } else if (!validInterfaceMethod(mod, cd)) {\n+                    int badflags = (mod & ~MM_I_METHOD);\n+                    env.error(pos, \"warn.invalid.modifier.intmth\", toString(badflags, CF_Context.CTX_METHOD)\n+                            + \"   *****\" + toString(mod, CF_Context.CTX_METHOD) + \"*****\");\n+                }\n+            } else {\n+                if (is_init && !validInitMethod(mod)) {\n+                    int badflags = (mod & ~MM_N_METHOD);\n+                    env.error(pos, \"warn.invalid.modifier.init\", toString(badflags, CF_Context.CTX_METHOD)\n+                            + \"   *****\" + toString(mod, CF_Context.CTX_METHOD) + \"*****\");\n+                } else if (isAbstract(mod)) {\n+                    if (!validAbstractMethod(mod)) {\n+                        int badflags = (mod & ~MM_A_METHOD);\n+                        env.error(pos, \"warn.invalid.modifier.abst\", toString(badflags, CF_Context.CTX_METHOD)\n+                                + \"   *****\" + toString(mod, CF_Context.CTX_METHOD) + \"*****\");\n+                    }\n+                } else {\n+                    if (!validMethod(mod)) {\n+                        env.error(pos, \"warn.invalid.modifier.mth\",\n+                                toString(mod & ~MM_METHOD, CF_Context.CTX_METHOD));\n+                    }\n+                }\n+                if (!validAccess(mod)) {\n+                    env.error(pos, \"warn.invalid.modifier.acc\");\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Check the modifier flags for the inner-class\n+     *\n+     * @param cd The ClassData for the current class\n+     * @param mod The modifier flags being checked\n+     * @param pos the position of the parser in the file\n+     *\/\n+    public static void checkInnerClassModifiers(ClassData cd, int mod, int pos) {\n+        Environment env = cd.env;\n+\n+        if (!validInnerClass(mod)) {\n+            int badflags = (mod & ~MM_INNERCLASS);\n+            env.error(pos, \"warn.invalid.modifier.innerclass\",\n+                    toString(badflags, CF_Context.CTX_INNERCLASS)\n+                    + \"   *****\" + toString(mod, CF_Context.CTX_INNERCLASS) + \"*****\");\n+        }\n+\n+    }\n+\n+    private static StringBuffer _accessString(int mod, CF_Context context) {\n+        StringBuffer sb = new StringBuffer();\n+        if (context == CF_Context.CTX_CLASS && isModule(mod)) {\n+            sb.append(Token.MODULE.parseKey() + \" \");\n+        }\n+        if (isPublic(mod)) {\n+            sb.append(Token.PUBLIC.parseKey() + \" \");\n+        }\n+        if (isPrivate(mod)) {\n+            sb.append(Token.PRIVATE.parseKey() + \" \");\n+        }\n+        if (isProtected(mod)) {\n+            sb.append(Token.PROTECTED.parseKey() + \" \");\n+        }\n+        if (isStatic(mod)) {\n+            sb.append(Token.STATIC.parseKey() + \" \");\n+        }\n+        if (context == CF_Context.CTX_METHOD && isFinal(mod)) {\n+            sb.append(Token.FINAL.parseKey() + \" \");\n+        }\n+        if (context == CF_Context.CTX_FIELD && isTransient(mod)) {\n+            sb.append(Token.TRANSIENT.parseKey() + \" \");\n+        }\n+        if (context == CF_Context.CTX_CLASS && isSuper(mod)) {\n+            sb.append(Token.SUPER.parseKey() + \" \");\n+        }\n+        if (context == CF_Context.CTX_METHOD && isSynchronized(mod)) {\n+            sb.append(Token.SYNCHRONIZED.parseKey() + \" \");\n+        }\n+        if (context == CF_Context.CTX_METHOD) {\n+            if (isBridge(mod)) {\n+                sb.append(Token.BRIDGE.parseKey() + \" \");\n+            }\n+            if (isVarArgs(mod)) {\n+                sb.append(Token.VARARGS.parseKey() + \" \");\n+            }\n+            if (isNative(mod)) {\n+                sb.append(Token.NATIVE.parseKey() + \" \");\n+            }\n+        }\n+        if (isAbstract(mod)) {\n+            if ((context != CF_Context.CTX_CLASS) || !isInterface(mod)) {\n+                sb.append(Token.ABSTRACT.parseKey() + \" \");\n+            }\n+        }\n+        if (  context.isOneOf(CF_Context.CTX_CLASS, CF_Context.CTX_INNERCLASS, CF_Context.CTX_FIELD) && isFinal(mod)) {\n+            sb.append(Token.FINAL.parseKey() + \" \");\n+        }\n+        if (context.isOneOf(CF_Context.CTX_CLASS, CF_Context.CTX_INNERCLASS) && isInterface(mod)) {\n+            if (isAnnotation(mod)) {\n+                sb.append(Token.ANNOTATION_ACCESS.parseKey() + \" \");\n+            }\n+            sb.append(Token.INTERFACE.parseKey() + \" \");\n+        }\n+        if (isStrict(mod)) {\n+            sb.append(Token.STRICT.parseKey() + \" \");\n+        }\n+        if (isSynthetic(mod)) {\n+            sb.append(Token.SYNTHETIC.parseKey() + \" \");\n+        }\n+        if (context == CF_Context.CTX_FIELD && isVolatile(mod)) {\n+            sb.append(Token.VOLATILE.parseKey() + \" \");\n+        }\n+        if (isEnum(mod)) {\n+            sb.append(Token.ENUM.parseKey() + \" \");\n+        }\n+        if (context.isOneOf(CF_Context.CTX_METHOD, CF_Context.CTX_FIELD) && isMandated(mod)) {\n+            sb.append(Token.MANDATED.parseKey() + \" \");\n+        }\n+\n+        return sb;\n+    }\n+\n+    public static String toString(int mod, CF_Context context) {\n+        StringBuffer sb = _accessString(mod, context);\n+\n+        if (isSyntheticPseudoMod(mod)) {\n+            sb.append(\"Synthetic(Pseudo) \");\n+        }\n+        if (isDeprecatedPseudoMod(mod)) {\n+            sb.append(\"Deprecated(Pseudo) \");\n+        }\n+\n+        return sb.toString().trim();\n+    }\n+\n+    public static String moduleFlags( int flags ) {\n+        return \"\";\n+    }\n+\n+    public static String accessString(int mod, CF_Context context) {\n+        return (context == CF_Context.CTX_MODULE) ?\n+            moduleFlags(mod) :\n+            _accessString(mod, context).toString();\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Modifiers.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.common.Module;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * The module attribute\n+ *\/\n+class ModuleAttr extends AttrData {\n+  \/\/ shared data\n+  private Module.Builder builder;\n+  private final ClassData clsData;\n+  private final Function<String, ConstantPool.ConstCell> findCellAsciz;\n+  private final Function<String, ConstantPool.ConstCell> findCellClassByName;\n+  private final Function<String, ConstantPool.ConstCell> findCellModuleByName;\n+  private final Function<String, ConstantPool.ConstCell> findCellPackageByName;\n+\n+  \/\/ entries to populate tables of the module attribute\n+  BiConsumer<String, Integer> requires       = (mn, f) -> this.builder.require(mn, f);\n+  BiConsumer<String, Set<String>> exports    = (pn, ms) -> this.builder.exports(new Module.Exported(pn), ms);\n+  BiConsumer<String, Set<String>> opens      = (pn, ms) -> this.builder.opens(new Module.Opened(pn), ms);\n+  BiConsumer<String, Set<String>> provides   = (tn, ts) -> this.builder.provides(new Module.Provided(tn), ts);\n+  Consumer<Set<String>>           uses       = (ts) -> this.builder.uses(ts);\n+\n+  ModuleAttr(ClassData cdata) {\n+    super(cdata, Tables.AttrTag.ATT_Module.parsekey());\n+    builder = new Module.Builder();\n+    clsData = cdata;\n+    findCellAsciz = (name) -> clsData.pool.FindCellAsciz(name);\n+    findCellClassByName = (name) -> clsData.pool.FindCellClassByName(name);\n+    findCellModuleByName = (name) -> clsData.pool.FindCellModuleByName(name);\n+    findCellPackageByName = (name) -> clsData.pool.FindCellPackageByName(name);\n+  }\n+\n+  void openModule() {\n+    builder.setModuleFlags(Module.Modifier.ACC_OPEN);\n+  }\n+  void setModuleName(String value) { builder.setModuleName(value);}\n+\n+  ModuleAttr build() {\n+    Module module = builder.build();\n+    Content.instance.header = new HeaderStruct(module.header, findCellModuleByName, findCellAsciz);\n+    Content.instance.requiresStruct = new SetStruct<>(module.requires, findCellModuleByName, findCellAsciz);\n+    Content.instance.exportsMapStruct = new MapStruct<>(module.exports, findCellPackageByName, findCellModuleByName );\n+    Content.instance.opensMapStruct = new MapStruct<>(module.opens,findCellPackageByName, findCellModuleByName );\n+    Content.instance.usesStruct = new SetStruct<>(module.uses, findCellClassByName, null);\n+    Content.instance.providesMapStruct = new MapStruct<>(module.provides, findCellClassByName, findCellClassByName);\n+    return this;\n+  }\n+\n+  @Override\n+  public int attrLength() {\n+    return Content.instance.getLength();\n+  }\n+\n+  @Override\n+  public void write(CheckedDataOutputStream out) throws IOException {\n+    super.write(out);\n+    Content.instance.write(out);\n+  }\n+\n+  private enum Content implements Data {\n+    instance {\n+      @Override\n+      public int getLength() {\n+        return header.getLength() +\n+            requiresStruct.getLength() +\n+            exportsMapStruct.getLength() +\n+            opensMapStruct.getLength() +\n+            usesStruct.getLength() +\n+            providesMapStruct.getLength();\n+      }\n+\n+      @Override\n+      public void write(CheckedDataOutputStream out) throws IOException {\n+        \/\/ keep order!\n+        header.write(out);\n+        requiresStruct.write(out);\n+        exportsMapStruct.write(out);\n+        opensMapStruct.write(out);\n+        usesStruct.write(out);\n+        providesMapStruct.write(out);\n+      }\n+    };\n+\n+    HeaderStruct header ;\n+    SetStruct<Module.Dependence>  requiresStruct;\n+    MapStruct<Module.Exported>    exportsMapStruct;\n+    MapStruct<Module.Opened>      opensMapStruct;\n+    SetStruct<Module.Uses>        usesStruct;\n+    MapStruct<Module.Provided>    providesMapStruct;\n+  }\n+\n+  \/**\n+   * u2 {exports|opens}_count;\n+   * {  u2 {exports|opens}_index;\n+   * u2 {exports|opens}_flags;\n+   * u2 {exports|opens}_to_count;\n+   * u2 {exports|opens}_to_index[{exports|opens}_to_count];\n+   * } {exports|opens}[{exports|opens}_count];\n+   * or\n+   * u2 provides_count;\n+   * {  u2 provides_index;\n+   * u2 provides_with_count;\n+   * u2 provides_with_index[provides_with_count];\n+   * } provides[provides_count];\n+   *\/\n+  private class MapStruct<T extends Module.TargetType> implements Data {\n+    final List<Triplet<ConstantPool.ConstCell, Integer, List<ConstantPool.ConstCell>>> exportsOpensList = new ArrayList<>();\n+    final List<Pair<ConstantPool.ConstCell, List<ConstantPool.ConstCell>>> providesList = new ArrayList<>();\n+\n+    MapStruct(Map<T, Set<String>> source,\n+              Function<String,ConstantPool.ConstCell> nameFinder,\n+              Function<String,ConstantPool.ConstCell> targetFinder) {\n+      Objects.requireNonNull(source);\n+      source.entrySet().stream()\n+          .sorted(Map.Entry.comparingByKey())\n+          .forEach(e -> {\n+                ArrayList<ConstantPool.ConstCell> to = new ArrayList<>();\n+                e.getValue().forEach(mn -> to.add(targetFinder.apply(mn)));\n+                if (e.getKey().isFlagged()) {\n+                  exportsOpensList.add(new Triplet<>\n+                      ( nameFinder.apply(e.getKey().getTypeName()),\n+                        ((Module.FlaggedTargetType) e.getKey()).getFlags(),\n+                        to));\n+                } else {\n+                  providesList.add(new Pair<>(nameFinder.apply(e.getKey().getTypeName()),\n+                      to));\n+                }\n+              }\n+          );\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+      if (providesList.isEmpty()) {\n+        out.writeShort(exportsOpensList.size());          \/\/ u2 {exports|opens}_count;\n+        for (Triplet<ConstantPool.ConstCell, Integer, List<ConstantPool.ConstCell>> triplet : exportsOpensList) {\n+          out.writeShort(triplet.first.arg);              \/\/ {  u2 {exports|opens}_index;\n+          out.writeShort(triplet.second);                 \/\/    u2 {exports|opens}_flags;\n+          out.writeShort(triplet.third.size());           \/\/    u2 {exports|opens}_to_count;\n+          for (ConstantPool.ConstCell to : triplet.third)\n+            out.writeShort(to.arg);                       \/\/ u2 {exports|opens}_to_index[{exports|opens}_to_count]; }\n+        }\n+      } else {\n+        out.writeShort(providesList.size());              \/\/ u2 provides_count;\n+        for (Pair<ConstantPool.ConstCell, List<ConstantPool.ConstCell>> pair : providesList) {\n+          out.writeShort(pair.first.arg);                 \/\/ {  u2 provides_index;\n+          out.writeShort(pair.second.size());             \/\/    u2 provides_with_count;\n+          for (ConstantPool.ConstCell to : pair.second)\n+            out.writeShort(to.arg);                       \/\/ u2 provides_with_index[provides_with_count]; }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public int getLength() {\n+      if (providesList.isEmpty()) {\n+        \/\/ (u2:{exports|opens}_count) + (u2:{exports|opens}_index + u2:{exports|opens}_flags u2:{exports|opens}_to_count) * {exports|opens}_count +\n+        return 2 + 6 * exportsOpensList.size() +\n+        \/\/  (u2:{exports|opens}_to_index) * {exports|opens}_to_count\n+            exportsOpensList.stream().mapToInt(p -> p.third.size()).filter(s -> s > 0).sum() * 2;\n+      } else {\n+        \/\/ (u2 : provides_count) + (u2:provides_index + u2:provides_with_count) * provides_count +\n+        return 2 + 4 * providesList.size() +\n+        \/\/ (u2:provides_with_index) * provides_with_count\n+            providesList.stream().mapToInt(p -> p.second.size()).filter(s -> s > 0).sum() * 2;\n+      }\n+    }\n+  }\n+\n+  private class HeaderStruct implements Data {\n+    final ConstantPool.ConstCell index;\n+    final int flags;\n+    final ConstantPool.ConstCell versionIndex;\n+\n+    HeaderStruct(Module.Header source,\n+                 Function<String,ConstantPool.ConstCell> nameFinder,\n+                 Function<String,ConstantPool.ConstCell> versionFinder) {\n+      index = nameFinder.apply(source.getModuleName());\n+      versionIndex = (source.getModuleVersion() == null ) ? null : versionFinder.apply(source.getModuleVersion());\n+      flags = source.getModuleFlags();\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+      out.writeShort(index.arg);                                    \/\/ u2 module_name_index;\n+      out.writeShort(flags);                                        \/\/ u2 module_flags;\n+      out.writeShort(versionIndex == null ? 0 : versionIndex.arg);  \/\/ u2 module_version_index;\n+    }\n+\n+    @Override\n+    public int getLength() {\n+      \/\/ u2:module_name_index) +  u2:module_flags +u2:module_version_index\n+      return 6;\n+    }\n+  }\n+\n+  \/**\n+   * u2 uses_count;\n+   * u2 uses_index[uses_count];\n+   * or\n+   * u2 requires_count;\n+   * {  u2 requires_index;\n+   *    u2 requires_flags;\n+   *    u2 requires_version_index;\n+   * } requires[requires_count];\n+   *\/\n+  private class SetStruct<T extends Module.TargetType> implements Data {\n+    final List<ConstantPool.ConstCell> usesList = new ArrayList<>();\n+    final List<Triplet<ConstantPool.ConstCell, Integer, ConstantPool.ConstCell>> requiresList = new ArrayList<>();\n+\n+    SetStruct(Set<T> source,\n+              Function<String,ConstantPool.ConstCell> nameFinder,\n+              Function<String,ConstantPool.ConstCell> versionFinder) {\n+      Objects.requireNonNull(source);\n+      source.forEach(e -> {\n+        if (e.isFlagged()) {\n+          requiresList.add(new Triplet<>(\n+              nameFinder.apply(e.getTypeName()),\n+              ((Module.FlaggedTargetType) e).getFlags(),\n+              (((Module.VersionedFlaggedTargetType) e).getVersion() == null) ?\n+                  null :\n+                  versionFinder.apply(((Module.VersionedFlaggedTargetType) e).getVersion())));\n+        } else {\n+          usesList.add(nameFinder.apply((e.getTypeName())));\n+        }\n+      });\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+      if (usesList.isEmpty()) {\n+        out.writeShort(requiresList.size());                  \/\/ u2 requires_count;\n+        for (Triplet<ConstantPool.ConstCell, Integer, ConstantPool.ConstCell> r : requiresList) {\n+          out.writeShort(r.first.arg);                        \/\/ u2 requires_index;\n+          out.writeShort(r.second);                           \/\/ u2 requires_flags;\n+          out.writeShort(r.third == null ? 0 : r.third.arg);  \/\/ u2 requires_version_index;\n+        }\n+      } else {\n+        out.writeShort(usesList.size());                      \/\/ u2 uses_count;\n+        for (ConstantPool.ConstCell u : usesList)\n+          out.writeShort(u.arg);                              \/\/ u2 uses_index[uses_count];\n+      }\n+    }\n+\n+    @Override\n+    public int getLength() {\n+      return usesList.isEmpty() ?\n+          \/\/ (u2:requires_count) + (u2:requires_index + u2:requires_flags + u2:requires_version_index) * requires_count\n+          2 + 6 * requiresList.size() :\n+          \/\/ (u2:uses_count) + (u2:uses_index) * uses_count\n+          2 + 2 * usesList.size();\n+    }\n+  }\n+\n+  \/\/ Helper classes\n+  private class Pair<F, S> {\n+    final F first;\n+    final S second;\n+\n+    Pair(F first, S second) {\n+      this.first = first;\n+      this.second = second;\n+    }\n+  }\n+\n+  public class Triplet<F, S, T>  extends Pair<F,S> {\n+    private final T third;\n+    Triplet(F first, S second, T third) {\n+      super(first,second);\n+      this.third = third;\n+    }\n+  }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ModuleAttr.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.util.List;\n+\n+\/**\n+ * The \"classes[]\" data of attributes\n+ * JEP 181 (Nest-based Access Control): class file 55.0\n+ * NestMembers_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ *\/\n+public class NestMembersAttr extends ClassArrayAttr {\n+    public NestMembersAttr(ClassData cdata, List<ConstantPool.ConstCell> classes) {\n+        super(Tables.AttrTag.ATT_NestMembers.parsekey(), cdata, classes);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/NestMembersAttr.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,567 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.util.HashMap;\n+\n+\/**\n+ *\n+ * OpcodeTables\n+ *\n+ * The OpcodeTables class follows a Singleton Pattern. This class contains Enums, that are\n+ * contained in private hash maps (lookup tables and reverse lookup tables). These hash\n+ * maps all have public accessors, which clients use to look-up opcodes.\n+ *\n+ * Tokens in this table carry no external state, and are typically treated as constants.\n+ * They do not need to be reset.\n+ *\n+ *\/\n+public class OpcodeTables {\n+\n+    \/**\n+     * Initialized keyword and token Hash Maps (and Reverse Tables)\n+     *\/\n+    static private final int MaxOpcodes = 301;\n+    static private HashMap<Integer, Opcode> IntToNormalOpcodes = new HashMap<>(MaxOpcodes);\n+    static private HashMap<Integer, Opcode> IntToAllOpcodes = new HashMap<>(MaxOpcodes);\n+    static private HashMap<String, Opcode> mnemocodes = new HashMap<>(MaxOpcodes);\n+\n+    static private HashMap<Integer, Opcode> IntToPrivOpcode = new HashMap<>(MaxOpcodes);\n+    static private HashMap<String, Opcode> PrivMnemocodes = new HashMap<>(MaxOpcodes);\n+\n+    static private HashMap<Integer, Opcode> IntToNonPrivOpcode = new HashMap<>(MaxOpcodes);\n+    static private HashMap<String, Opcode> NonPrivMnemocodes = new HashMap<>(MaxOpcodes);\n+\n+    static {\n+        \/\/ register all of the tokens\n+        for (Opcode opc : Opcode.values()) {\n+            registerOpcode(opc);\n+        }\n+\n+    }\n+\n+    private static void registerOpcode(Opcode opc) {\n+        IntToAllOpcodes.put(opc.value, opc);\n+        mnemocodes.put(opc.parsekey, opc);\n+        if (opc.alias != null) {\n+            mnemocodes.put(opc.alias, opc);\n+        }\n+\n+        if (opc.type == OpcodeType.PRIVELEGED) {\n+            PrivMnemocodes.put(opc.parsekey, opc);\n+            IntToPrivOpcode.put(opc.baseVal, opc);\n+        } else if (opc.type == OpcodeType.NONPRIVELEGED) {\n+            NonPrivMnemocodes.put(opc.parsekey, opc);\n+            IntToNonPrivOpcode.put(opc.baseVal, opc);\n+        }\n+\n+    }\n+\n+    public static Opcode opcode(String mnemonic) {\n+        return mnemocodes.get(mnemonic);\n+    }\n+\n+    public static Opcode opcode(Integer mnem_code) {\n+        return IntToAllOpcodes.get(mnem_code);\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * Marker: describes the type of Opcode.\n+     *\n+     * certain types of Opcodes will be added to specific lookup tables.\n+     *\/\n+    static public enum OpcodeType {\n+        NORMAL            (0, \"Normal\"),\n+        NONPRIVELEGED     (1, \"NonPriv\"),\n+        PRIVELEGED        (2, \"Priv\"),\n+        WIDE              (3, \"Wide\");\n+\n+        private final Integer value;\n+        private final String printval;\n+\n+        OpcodeType(Integer val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Opcode Enums *\/\n+    static public enum Opcode {\n+     \/* Opcodes *\/\n+    opc_dead                (-2, \" opc_dead\", 0),\n+    opc_label               (-1, \"opc_label\", 0),\n+    opc_nop                 (0, \"nop\", 1),\n+    opc_aconst_null         (1, \"aconst_null\", 1),\n+    opc_iconst_m1           (2, \"iconst_m1\", 1),\n+    opc_iconst_0            (3, \"iconst_0\", 1),\n+    opc_iconst_1            (4, \"iconst_1\", 1),\n+    opc_iconst_2            (5, \"iconst_2\", 1),\n+    opc_iconst_3            (6, \"iconst_3\", 1),\n+    opc_iconst_4            (7, \"iconst_4\", 1),\n+    opc_iconst_5            (8, \"iconst_5\", 1),\n+    opc_lconst_0            (9, \"lconst_0\", 1),\n+    opc_lconst_1            (10, \"lconst_1\", 1),\n+    opc_fconst_0            (11, \"fconst_0\", 1),\n+    opc_fconst_1            (12, \"fconst_1\", 1),\n+    opc_fconst_2            (13, \"fconst_2\", 1),\n+    opc_dconst_0            (14, \"dconst_0\", 1),\n+    opc_dconst_1            (15, \"dconst_1\", 1),\n+    opc_bipush              (16, \"bipush\", 2),\n+    opc_sipush              (17, \"sipush\", 3),\n+    opc_ldc                 (18, \"ldc\", 2),\n+    opc_ldc_w               (19, \"ldc_w\", 3),\n+    opc_ldc2_w              (20, \"ldc2_w\", 3),\n+    opc_iload               (21, \"iload\", 2),\n+    opc_lload               (22, \"lload\", 2),\n+    opc_fload               (23, \"fload\", 2),\n+    opc_dload               (24, \"dload\", 2),\n+    opc_aload               (25, \"aload\", 2),\n+    opc_iload_0            (26, \"iload_0\", 1),\n+    opc_iload_1            (27, \"iload_1\", 1),\n+    opc_iload_2            (28, \"iload_2\", 1),\n+    opc_iload_3            (29, \"iload_3\", 1),\n+    opc_lload_0            (30, \"lload_0\", 1),\n+    opc_lload_1            (31, \"lload_1\", 1),\n+    opc_lload_2            (32, \"lload_2\", 1),\n+    opc_lload_3            (33, \"lload_3\", 1),\n+    opc_fload_0            (34, \"fload_0\", 1),\n+    opc_fload_1            (35, \"fload_1\", 1),\n+    opc_fload_2            (36, \"fload_2\", 1),\n+    opc_fload_3            (37, \"fload_3\", 1),\n+    opc_dload_0            (38, \"dload_0\", 1),\n+    opc_dload_1            (39, \"dload_1\", 1),\n+    opc_dload_2            (40, \"dload_2\", 1),\n+    opc_dload_3            (41, \"dload_3\", 1),\n+    opc_aload_0            (42, \"aload_0\", 1),\n+    opc_aload_1            (43, \"aload_1\", 1),\n+    opc_aload_2            (44, \"aload_2\", 1),\n+    opc_aload_3            (45, \"aload_3\", 1),\n+    opc_iaload            (46, \"iaload\", 1),\n+    opc_laload            (47, \"laload\", 1),\n+    opc_faload            (48, \"faload\", 1),\n+    opc_daload            (49, \"daload\", 1),\n+    opc_aaload            (50, \"aaload\", 1),\n+    opc_baload            (51, \"baload\", 1),\n+    opc_caload            (52, \"caload\", 1),\n+    opc_saload            (53, \"saload\", 1),\n+    opc_istore            (54, \"istore\", 2),\n+    opc_lstore            (55, \"lstore\", 2),\n+    opc_fstore            (56, \"fstore\", 2),\n+    opc_dstore            (57, \"dstore\", 2),\n+    opc_astore            (58, \"astore\", 2),\n+    opc_istore_0            (59, \"istore_0\", 1),\n+    opc_istore_1            (60, \"istore_1\", 1),\n+    opc_istore_2            (61, \"istore_2\", 1),\n+    opc_istore_3            (62, \"istore_3\", 1),\n+    opc_lstore_0            (63, \"lstore_0\", 1),\n+    opc_lstore_1            (64, \"lstore_1\", 1),\n+    opc_lstore_2            (65, \"lstore_2\", 1),\n+    opc_lstore_3            (66, \"lstore_3\", 1),\n+    opc_fstore_0            (67, \"fstore_0\", 1),\n+    opc_fstore_1            (68, \"fstore_1\", 1),\n+    opc_fstore_2            (69, \"fstore_2\", 1),\n+    opc_fstore_3            (70, \"fstore_3\", 1),\n+    opc_dstore_0            (71, \"dstore_0\", 1),\n+    opc_dstore_1            (72, \"dstore_1\", 1),\n+    opc_dstore_2            (73, \"dstore_2\", 1),\n+    opc_dstore_3            (74, \"dstore_3\", 1),\n+    opc_astore_0            (75, \"astore_0\", 1),\n+    opc_astore_1            (76, \"astore_1\", 1),\n+    opc_astore_2            (77, \"astore_2\", 1),\n+    opc_astore_3            (78, \"astore_3\", 1),\n+    opc_iastore             (79, \"iastore\", 1),\n+    opc_lastore             (80, \"lastore\", 1),\n+    opc_fastore             (81, \"fastore\", 1),\n+    opc_dastore             (82, \"dastore\", 1),\n+    opc_aastore             (83, \"aastore\", 1),\n+    opc_bastore             (84, \"bastore\", 1),\n+    opc_castore             (85, \"castore\", 1),\n+    opc_sastore             (86, \"sastore\", 1),\n+    opc_pop                 (87, \"pop\", 1),\n+    opc_pop2                (88, \"pop2\", 1),\n+    opc_dup                 (89, \"dup\", 1),\n+    opc_dup_x1              (90, \"dup_x1\", 1),\n+    opc_dup_x2              (91, \"dup_x2\", 1),\n+    opc_dup2                (92, \"dup2\", 1),\n+    opc_dup2_x1             (93, \"dup2_x1\", 1),\n+    opc_dup2_x2             (94, \"dup2_x2\", 1),\n+    opc_swap                (95, \"swap\", 1),\n+    opc_iadd                (96, \"iadd\", 1),\n+    opc_ladd                (97, \"ladd\", 1),\n+    opc_fadd                (98, \"fadd\", 1),\n+    opc_dadd                (99, \"dadd\", 1),\n+    opc_isub                (100, \"isub\", 1),\n+    opc_lsub                (101, \"lsub\", 1),\n+    opc_fsub                (102, \"fsub\", 1),\n+    opc_dsub                (103, \"dsub\", 1),\n+    opc_imul                (104, \"imul\", 1),\n+    opc_lmul                (105, \"lmul\", 1),\n+    opc_fmul                (106, \"fmul\", 1),\n+    opc_dmul                (107, \"dmul\", 1),\n+    opc_idiv                (108, \"idiv\", 1),\n+    opc_ldiv                (109, \"ldiv\", 1),\n+    opc_fdiv                (110, \"fdiv\", 1),\n+    opc_ddiv                (111, \"ddiv\", 1),\n+    opc_irem                (112, \"irem\", 1),\n+    opc_lrem                (113, \"lrem\", 1),\n+    opc_frem                (114, \"frem\", 1),\n+    opc_drem                (115, \"drem\", 1),\n+    opc_ineg                (116, \"ineg\", 1),\n+    opc_lneg                (117, \"lneg\", 1),\n+    opc_fneg                (118, \"fneg\", 1),\n+    opc_dneg                (119, \"dneg\", 1),\n+    opc_ishl                (120, \"ishl\", 1),\n+    opc_lshl                (121, \"lshl\", 1),\n+    opc_ishr                (122, \"ishr\", 1),\n+    opc_lshr                (123, \"lshr\", 1),\n+    opc_iushr               (124, \"iushr\", 1),\n+    opc_lushr               (125, \"lushr\", 1),\n+    opc_iand                (126, \"iand\", 1),\n+    opc_land                (127, \"land\", 1),\n+    opc_ior                 (128, \"ior\", 1),\n+    opc_lor                 (129, \"lor\", 1),\n+    opc_ixor                (130, \"ixor\", 1),\n+    opc_lxor                (131, \"lxor\", 1),\n+    opc_iinc                (132, \"iinc\", 3),\n+    opc_i2l                 (133, \"i2l\", 1),\n+    opc_i2f                 (134, \"i2f\", 1),\n+    opc_i2d                 (135, \"i2d\", 1),\n+    opc_l2i                 (136, \"l2i\", 1),\n+    opc_l2f                 (137, \"l2f\", 1),\n+    opc_l2d                 (138, \"l2d\", 1),\n+    opc_f2i                 (139, \"f2i\", 1),\n+    opc_f2l                 (140, \"f2l\", 1),\n+    opc_f2d                 (141, \"f2d\", 1),\n+    opc_d2i                 (142, \"d2i\", 1),\n+    opc_d2l                 (143, \"d2l\", 1),\n+    opc_d2f                 (144, \"d2f\", 1),\n+    opc_i2b                 (145, \"i2b\", 1),\n+    opc_i2c                 (146, \"i2c\", 1),\n+    opc_i2s                 (147, \"i2s\", 1),\n+    opc_lcmp                (148, \"lcmp\", 1),\n+    opc_fcmpl               (149, \"fcmpl\", 1),\n+    opc_fcmpg               (150, \"fcmpg\", 1),\n+    opc_dcmpl               (151, \"dcmpl\", 1),\n+    opc_dcmpg               (152, \"dcmpg\", 1),\n+    opc_ifeq                (153, \"ifeq\", 3),\n+    opc_ifne                (154, \"ifne\", 3),\n+    opc_iflt                (155, \"iflt\", 3),\n+    opc_ifge                (156, \"ifge\", 3),\n+    opc_ifgt                (157, \"ifgt\", 3),\n+    opc_ifle                (158, \"ifle\", 3),\n+    opc_if_icmpeq           (159, \"if_icmpeq\", 3),\n+    opc_if_icmpne           (160, \"if_icmpne\", 3),\n+    opc_if_icmplt           (161, \"if_icmplt\", 3),\n+    opc_if_icmpge           (162, \"if_icmpge\", 3),\n+    opc_if_icmpgt           (163, \"if_icmpgt\", 3),\n+    opc_if_icmple           (164, \"if_icmple\", 3),\n+    opc_if_acmpeq           (165, \"if_acmpeq\", 3),\n+    opc_if_acmpne           (166, \"if_acmpne\", 3),\n+    opc_goto                (167, \"goto\", 3),\n+    opc_jsr                 (168, \"jsr\", 3),\n+    opc_ret                 (169, \"ret\", 2),\n+    opc_tableswitch         (170, \"tableswitch\", 99),\n+    opc_lookupswitch        (171, \"lookupswitch\", 99),\n+    opc_ireturn             (172, \"ireturn\", 1),\n+    opc_lreturn             (173, \"lreturn\", 1),\n+    opc_freturn             (174, \"freturn\", 1),\n+    opc_dreturn             (175, \"dreturn\", 1),\n+    opc_areturn             (176, \"areturn\", 1),\n+    opc_return              (177, \"return\", 1),\n+    opc_getstatic           (178, \"getstatic\", 3),\n+    opc_putstatic           (179, \"putstatic\", 3),\n+    opc_getfield            (180, \"getfield\", 3),\n+    opc_putfield            (181, \"putfield\", 3),\n+    opc_invokevirtual       (182, \"invokevirtual\", 3),\n+    opc_invokespecial       (183, \"invokespecial\", \"invokenonvirtual\", 3),\n+    opc_invokestatic        (184, \"invokestatic\", 3),\n+    opc_invokeinterface     (185, \"invokeinterface\", 5),\n+    opc_invokedynamic       (186, \"invokedynamic\", 5),\n+    opc_new                 (187, \"new\", 3),\n+    opc_newarray            (188, \"newarray\", 2),\n+    opc_anewarray           (189, \"anewarray\", 3),\n+    opc_arraylength         (190, \"arraylength\", 1),\n+    opc_athrow              (191, \"athrow\", 1),\n+    opc_checkcast           (192, \"checkcast\", 3),\n+    opc_instanceof          (193, \"instanceof\", 3),\n+    opc_monitorenter        (194, \"monitorenter\", 1),\n+    opc_monitorexit         (195, \"monitorexit\", 1),\n+\n+        \/\/ Wide Marker (not really an opcode)\n+        opc_wide            (196, null, 0),\n+    opc_multianewarray      (197, \"multianewarray\", 4),\n+    opc_ifnull              (198, \"ifnull\", 3),\n+    opc_ifnonnull           (199, \"ifnonnull\", 3),\n+    opc_goto_w              (200, \"goto_w\", 5),\n+    opc_jsr_w               (201, \"jsr_w\", 5),\n+\/\/    opc_bytecode 202            (202, \"bytecode 202\", 1),\n+        \/* Pseudo-instructions *\/\n+    opc_bytecode            (203, \"bytecode\", 1),\n+    opc_try                 (204, \"try\", 0),\n+    opc_endtry              (205, \"endtry\", 0),\n+    opc_catch               (206, \"catch\", 0),\n+    opc_var                 (207, \"var\", 0),\n+    opc_endvar              (208, \"endvar\", 0),\n+    opc_locals_map          (209, \"locals_map\", 0),\n+    opc_stack_map           (210, \"stack_map\", 0),\n+    opc_stack_frame_type    (211, \"stack_frame_type\", 0),\n+\n+\n+        \/\/ Priv\/NonPriv Marker (not really an opcode)\n+        opc_nonpriv         (254, \"priv\", 0),\n+        opc_priv            (255, \"nonpriv\", 0),\n+\n+\n+        \/* Wide instructions *\/\n+        opc_iload_w                     (opc_iload.value, \"iload_w\", 4, OpcodeType.WIDE),\n+        opc_lload_w                     (opc_lload.value, \"lload_w\", 4, OpcodeType.WIDE),\n+        opc_fload_w                     (opc_fload.value, \"fload_w\", 4, OpcodeType.WIDE),\n+        opc_dload_w                     (opc_dload.value, \"dload_w\", 4, OpcodeType.WIDE),\n+        opc_aload_w                     (opc_aload.value, \"aload_w\", 4, OpcodeType.WIDE),\n+        opc_istore_w                    (opc_istore.value, \"istore_w\", 4, OpcodeType.WIDE),\n+        opc_lstore_w                    (opc_lstore.value, \"lstore_w\", 4, OpcodeType.WIDE),\n+        opc_fstore_w                    (opc_fstore.value, \"fstore_w\", 4, OpcodeType.WIDE),\n+        opc_dstore_w                    (opc_dstore.value, \"dstore_w\", 4, OpcodeType.WIDE),\n+        opc_astore_w                    (opc_astore.value, \"astore_w\", 4, OpcodeType.WIDE),\n+        opc_ret_w                       (opc_ret.value, \"ret_w\", 4, OpcodeType.WIDE),\n+        opc_iinc_w                      (opc_iinc.value, \"iinc_w\", 6, OpcodeType.WIDE),\n+\n+\n+        \/* Priveleged instructions *\/\n+    opc_load_ubyte                  (0, \"load_ubyte\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_ubyte        (0, \"priv_load_ubyte\", OpcodeType.PRIVELEGED),\n+    opc_load_byte            (1, \"load_byte\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_byte        (1, \"priv_load_byte\", OpcodeType.PRIVELEGED),\n+    opc_load_char            (2, \"load_char\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_char        (2, \"priv_load_char\", OpcodeType.PRIVELEGED),\n+    opc_load_short            (3, \"load_short\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_short        (3, \"priv_load_short\", OpcodeType.PRIVELEGED),\n+    opc_load_word            (4, \"load_word\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_word        (4, \"priv_load_word\", OpcodeType.PRIVELEGED),\n+    opc_load_char_oe            (10, \"load_char_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_char_oe        (10, \"priv_load_char_oe\", OpcodeType.PRIVELEGED),\n+    opc_load_short_oe        (11, \"load_short_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_short_oe        (11, \"priv_load_short_oe\", OpcodeType.PRIVELEGED),\n+    opc_load_word_oe            (12, \"load_word_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_load_word_oe        (12, \"priv_load_word_oe\", OpcodeType.PRIVELEGED),\n+    opc_ncload_ubyte            (16, \"ncload_ubyte\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_ubyte        (16, \"priv_ncload_ubyte\", OpcodeType.PRIVELEGED),\n+    opc_ncload_byte            (17, \"ncload_byte\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_byte        (17, \"priv_ncload_byte\", OpcodeType.PRIVELEGED),\n+    opc_ncload_char            (18, \"ncload_char\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_char        (18, \"priv_ncload_char\", OpcodeType.PRIVELEGED),\n+    opc_ncload_short            (19, \"ncload_short\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_short        (19, \"priv_ncload_short\", OpcodeType.PRIVELEGED),\n+    opc_ncload_word            (20, \"ncload_word\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_word        (20, \"priv_ncload_word\", OpcodeType.PRIVELEGED),\n+    opc_ncload_char_oe        (26, \"ncload_char_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_char_oe        (26, \"priv_ncload_char_oe\", OpcodeType.PRIVELEGED),\n+    opc_ncload_short_oe        (27, \"ncload_short_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_short_oe        (27, \"priv_ncload_short_oe\", OpcodeType.PRIVELEGED),\n+    opc_ncload_word_oe        (28, \"ncload_word_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncload_word_oe        (28, \"priv_ncload_word_oe\", OpcodeType.PRIVELEGED),\n+    opc_cache_flush            (30, \"cache_flush\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_cache_flush        (30, \"priv_cache_flush\", OpcodeType.PRIVELEGED),\n+    opc_store_byte            (32, \"store_byte\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_store_byte        (32, \"priv_store_byte\", OpcodeType.PRIVELEGED),\n+    opc_store_short            (34, \"store_short\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_store_short        (34, \"priv_store_short\", OpcodeType.PRIVELEGED),\n+    opc_store_word            (36, \"store_word\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_store_word        (36, \"priv_store_word\", OpcodeType.PRIVELEGED),\n+    opc_store_short_oe        (42, \"store_short_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_store_short_oe        (42, \"priv_store_short_oe\", OpcodeType.PRIVELEGED),\n+    opc_store_word_oe        (44, \"store_word_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_store_word_oe        (44, \"priv_store_word_oe\", OpcodeType.PRIVELEGED),\n+    opc_ncstore_byte            (48, \"ncstore_byte\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncstore_byte        (48, \"priv_ncstore_byte\", OpcodeType.PRIVELEGED),\n+    opc_ncstore_short        (50, \"ncstore_short\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncstore_short        (50, \"priv_ncstore_short\", OpcodeType.PRIVELEGED),\n+    opc_ncstore_word        (52, \"ncstore_word\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncstore_word        (52, \"priv_ncstore_word\", OpcodeType.PRIVELEGED),\n+    opc_ncstore_short_oe        (58, \"ncstore_short_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncstore_short_oe    (58, \"priv_ncstore_short_oe\", OpcodeType.PRIVELEGED),\n+    opc_ncstore_word_oe        (60, \"ncstore_word_oe\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ncstore_word_oe        (60, \"priv_ncstore_word_oe\", OpcodeType.PRIVELEGED),\n+    opc_zero_line            (62, \"zero_line\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_zero_line        (62, \"priv_zero_line\", OpcodeType.PRIVELEGED),\n+    opc_ret_from_sub            (5, \"ret_from_sub\", OpcodeType.NONPRIVELEGED),\n+    opc_enter_sync_method        (63, \"enter_sync_method\", OpcodeType.NONPRIVELEGED),\n+    opc_priv_ret_from_trap        (5, \"priv_ret_from_trap\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_dcache_tag    (6, \"priv_read_dcache_tag\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_dcache_data    (7, \"priv_read_dcache_data\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_icache_tag    (14, \"priv_read_icache_tag\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_icache_data    (15, \"priv_read_icache_data\", OpcodeType.PRIVELEGED),\n+    opc_priv_powerdown        (22, \"priv_powerdown\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_scache_data    (23, \"priv_read_scache_data\", OpcodeType.PRIVELEGED),\n+    opc_priv_cache_index_flush    (31, \"priv_cache_index_flush\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_dcache_tag    (38, \"priv_write_dcache_tag\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_dcache_data    (39, \"priv_write_dcache_data\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_icache_tag    (46, \"priv_write_icache_tag\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_icache_data    (47, \"priv_write_icache_data\", OpcodeType.PRIVELEGED),\n+    opc_priv_reset            (54, \"priv_reset\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_scache_data    (55, \"priv_write_scache_data\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_0        (64, \"priv_read_reg_0\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_1        (65, \"priv_read_reg_1\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_2        (66, \"priv_read_reg_2\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_3        (67, \"priv_read_reg_3\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_4        (68, \"priv_read_reg_4\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_5        (69, \"priv_read_reg_5\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_6        (70, \"priv_read_reg_6\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_7        (71, \"priv_read_reg_7\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_8        (72, \"priv_read_reg_8\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_9        (73, \"priv_read_reg_9\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_10        (74, \"priv_read_reg_10\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_11        (75, \"priv_read_reg_11\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_12        (76, \"priv_read_reg_12\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_13        (77, \"priv_read_reg_13\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_14        (78, \"priv_read_reg_14\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_15        (79, \"priv_read_reg_15\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_16        (80, \"priv_read_reg_16\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_17        (81, \"priv_read_reg_17\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_18        (82, \"priv_read_reg_18\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_19        (83, \"priv_read_reg_19\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_20        (84, \"priv_read_reg_20\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_21        (85, \"priv_read_reg_21\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_22        (86, \"priv_read_reg_22\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_23        (87, \"priv_read_reg_23\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_24        (88, \"priv_read_reg_24\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_25        (89, \"priv_read_reg_25\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_26        (90, \"priv_read_reg_26\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_27        (91, \"priv_read_reg_27\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_28        (92, \"priv_read_reg_28\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_29        (93, \"priv_read_reg_29\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_30        (94, \"priv_read_reg_30\", OpcodeType.PRIVELEGED),\n+    opc_priv_read_reg_31        (95, \"priv_read_reg_31\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_0        (96, \"priv_write_reg_0\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_1        (97, \"priv_write_reg_1\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_2        (98, \"priv_write_reg_2\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_3        (99, \"priv_write_reg_3\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_4        (100, \"priv_write_reg_4\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_5        (101, \"priv_write_reg_5\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_6        (102, \"priv_write_reg_6\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_7        (103, \"priv_write_reg_7\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_8        (104, \"priv_write_reg_8\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_9        (105, \"priv_write_reg_9\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_10        (106, \"priv_write_reg_10\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_11        (107, \"priv_write_reg_11\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_12        (108, \"priv_write_reg_12\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_13        (109, \"priv_write_reg_13\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_14        (110, \"priv_write_reg_14\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_15        (111, \"priv_write_reg_15\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_16        (112, \"priv_write_reg_16\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_17        (113, \"priv_write_reg_17\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_18        (114, \"priv_write_reg_18\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_19        (115, \"priv_write_reg_19\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_20        (116, \"priv_write_reg_20\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_21        (117, \"priv_write_reg_21\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_22        (118, \"priv_write_reg_22\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_23        (119, \"priv_write_reg_23\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_24        (120, \"priv_write_reg_24\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_25        (121, \"priv_write_reg_25\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_26        (122, \"priv_write_reg_26\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_27        (123, \"priv_write_reg_27\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_28        (124, \"priv_write_reg_28\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_29        (125, \"priv_write_reg_29\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_30        (126, \"priv_write_reg_30\", OpcodeType.PRIVELEGED),\n+    opc_priv_write_reg_31        (127, \"priv_write_reg_31\", OpcodeType.PRIVELEGED);\n+\n+        private Integer value;\n+        private String parsekey;\n+        private String alias;\n+        private Integer length;\n+        private Integer baseVal;\n+        private OpcodeType type;\n+\n+        Opcode(Integer val, String parse, OpcodeType tp) {\n+            init(val, parse, null, 2, tp);\n+        }\n+\n+        Opcode(Integer val, String parse, int len, OpcodeType tp) {\n+            init(val, parse, null, len, tp);\n+        }\n+\n+        Opcode(Integer val, String parse) {\n+            init(val, parse, null, 2, OpcodeType.NORMAL);\n+        }\n+\n+        Opcode(Integer val, String parse, int len) {\n+            init(val, parse, null, len, OpcodeType.NORMAL);\n+        }\n+\n+        Opcode(Integer val, String parse, String als, int len) {\n+            init(val, parse, als, len, OpcodeType.NORMAL);\n+        }\n+\n+        Opcode(Integer val, String parse, String als, int len, OpcodeType tp) {\n+            init(val, parse, als, len, tp);\n+        }\n+\n+        private void init(Integer val, String parse, String als, int len, OpcodeType tp) {\n+            type = tp;\n+            baseVal = null;\n+            switch (tp) {\n+                case NORMAL:\n+                    value = val;\n+                    break;\n+                case WIDE:\n+                    value = (opc_wide.value << 8) | val;\n+                    break;\n+                case PRIVELEGED:\n+                    value = (opc_priv.value * 0xFF) + val;\n+                    baseVal = val;\n+                    break;\n+                case NONPRIVELEGED:\n+                    value = (opc_nonpriv.value * 0xFF) + val;\n+                    baseVal = val;\n+                    break;\n+            }\n+            parsekey = parse;\n+            alias = als;\n+            length = len;\n+        }\n+\n+        public Integer value() {\n+            return value;\n+        }\n+\n+        public int length() {\n+            return length;\n+        }\n+\n+        public String parsekey() {\n+            return parsekey;\n+        }\n+\n+        public OpcodeType type() {\n+            return type;\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/OpcodeTables.java","additions":567,"deletions":0,"binary":false,"changes":567,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+\/**\n+ *\n+ *\/\n+public class ParseBase {\n+\n+    protected boolean debugFlag;\n+    protected Scanner scanner;\n+    protected Parser parser;\n+    protected Environment env;\n+\n+    public ParseBase() {\n+        init(null, null, null);\n+    }\n+\n+    public void init(Scanner scnr, Parser prsr, Environment envr) {\n+        debugFlag = false;\n+        scanner = scnr;\n+        parser = prsr;\n+        env = envr;\n+    }\n+\n+    public void enableDebug(boolean debState) {\n+        debugFlag = debState;\n+    }\n+\n+    protected void debugStr(String str) {\n+        if (debugFlag) {\n+            env.traceln(str);\n+        }\n+    }\n+\n+    protected void debugScan(String str) {\n+        if (debugFlag) {\n+            scanner.debugScan(str);\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ParseBase.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,2066 @@\n+\/*\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.common.Module;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+import static org.openjdk.asmtools.jasm.ConstantPool.*;\n+import static org.openjdk.asmtools.jasm.JasmTokens.Token;\n+import static org.openjdk.asmtools.jasm.JasmTokens.Token.*;\n+import static org.openjdk.asmtools.jasm.RuntimeConstants.*;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+\n+\/**\n+ * This class is used to parse Jasm statements and expressions.\n+ * The result is a parse tree.<p>\n+ * <p>\n+ * This class implements an operator precedence parser. Errors are\n+ * reported to the Environment object, if the error can't be\n+ * resolved immediately, a SyntaxError exception is thrown.<p>\n+ * <p>\n+ * Error recovery is implemented by catching Scanner.SyntaxError exceptions\n+ * and discarding input scanner.tokens until an input token is reached that\n+ * is possibly a legal continuation.<p>\n+ * <p>\n+ * The parse tree that is constructed represents the input\n+ * exactly (no rewrites to simpler forms). This is important\n+ * if the resulting tree is to be used for code formatting in\n+ * a programming environment. Currently only documentation comments\n+ * are retained.<p>\n+ * <p>\n+ * A parser owns several components (scanner, constant-parser,\n+ * instruction-parser, annotations-parser) to which it delegates certain\n+ * parsing responsibilities.  This parser contains functions to parse the\n+ * overall form of a class, and any members (fields, methods, inner-classes).\n+ * <p>\n+ * <p>\n+ * Syntax errors, should always be caught inside the\n+ * parser for error recovery.\n+ *\/\n+class Parser extends ParseBase {\n+\n+    \/* Parser Fields *\/\n+    protected ConstantPool pool = null;\n+\n+    ClassData cd = null;\n+\n+    CodeAttr curCode;\n+\n+    private ArrayList<ClassData> clsDataList = new ArrayList<>();\n+    private String pkg = null;\n+    private String pkgPrefix = \"\";\n+    private ArrayList<AnnotationData> pkgAnnttns = null;\n+    private ArrayList<AnnotationData> clsAnnttns = null;\n+    private ArrayList<AnnotationData> memberAnnttns = null;\n+    private boolean explicitcp = false;\n+    private ModuleAttr moduleAttribute;\n+    private CFVersion currentCFV;\n+    \/**\n+     * other parser components\n+     *\/\n+    private ParserAnnotation annotParser;       \/\/ For parsing Annotations\n+    private ParserCP cpParser;                  \/\/ for parsing Constants\n+    private ParserInstr instrParser;            \/\/ for parsing Instructions\n+\n+\n+    \/**\n+     * Create a parser\n+     *\/\n+    protected Parser(Environment sf, CFVersion cfVersion) throws IOException {\n+        super.init(new Scanner(sf), this, sf);\n+        this.currentCFV = cfVersion;\n+        this.annotParser = new ParserAnnotation(scanner, this, env);\n+        this.cpParser = new ParserCP(scanner, this, env);\n+        this.instrParser = new ParserInstr(scanner, this, cpParser, env);\n+    }\n+\n+    void setDebugFlags(boolean debugScanner, boolean debugMembers,\n+                       boolean debugCP, boolean debugAnnot, boolean debugInstr) {\n+\n+        enableDebug(debugMembers);\n+        scanner.enableDebug(debugScanner);\n+        cpParser.enableDebug(debugCP);\n+        annotParser.enableDebug(debugAnnot);\n+        instrParser.enableDebug(debugInstr);\n+    }\n+\n+    String encodeClassString(String classname) {\n+        return \"L\" + classname + \";\";\n+    }\n+\n+\n+    \/*-------------------------------------------------------- *\/\n+\n+    \/**\n+     * Parses version in package statements\n+     *\/\n+\n+    private void parseVersionPkg() throws IOException {\n+        if (scanner.token == SEMICOLON) {\n+            return;\n+        }\n+        parse_ver:\n+        {\n+            if (scanner.token != Token.VERSION) {\n+                break parse_ver;\n+            }\n+            scanner.scan();\n+            if (scanner.token != Token.INTVAL) {\n+                break parse_ver;\n+            }\n+            currentCFV.setMajorVersion((short) scanner.intValue);\n+            scanner.scan();\n+            if (scanner.token != Token.COLON) {\n+                break parse_ver;\n+            }\n+            scanner.scan();\n+            if (scanner.token != Token.INTVAL) {\n+                break parse_ver;\n+            }\n+            currentCFV.setMinorVersion((short) scanner.intValue);\n+            scanner.scan();\n+            debugScan(\"     [Parser.parseVersionPkg]: \" + currentCFV.asString());\n+            return;\n+        }\n+        env.error(scanner.pos, \"version.expected\");\n+        throw new Scanner.SyntaxError();\n+    }\n+\n+    private void parseVersion() throws IOException {\n+        if (scanner.token == Token.LBRACE) {\n+            return;\n+        }\n+        parse_ver:\n+        {\n+            if (scanner.token != Token.VERSION) {\n+                break parse_ver;\n+            }\n+            scanner.scan();\n+            if (scanner.token != Token.INTVAL) {\n+                break parse_ver;\n+            }\n+            cd.cfv.setMajorVersion((short) scanner.intValue);\n+            scanner.scan();\n+            if (scanner.token != Token.COLON) {\n+                break parse_ver;\n+            }\n+            scanner.scan();\n+            if (scanner.token != Token.INTVAL) {\n+                break parse_ver;\n+            }\n+            cd.cfv.setMinorVersion((short) scanner.intValue);\n+            scanner.scan();\n+            debugStr(\"parseVersion: \" + cd.cfv.asString());\n+            return;\n+        }\n+        env.error(scanner.pos, \"version.expected\");\n+        throw new Scanner.SyntaxError();\n+    }\n+\n+\n+    \/*---------------------------------------------*\/\n+\n+    \/**\n+     * Parse an internal name: identifier.\n+     *\/\n+    String parseIdent() throws Scanner.SyntaxError, IOException {\n+        String v = scanner.idValue;\n+        scanner.expect(Token.IDENT);\n+        return v;\n+    }\n+\n+    \/**\n+     * Parse a local variable\n+     *\/\n+    void parseLocVarDef() throws Scanner.SyntaxError, IOException {\n+        if (scanner.token == Token.INTVAL) {\n+            int v = scanner.intValue;\n+            scanner.scan();\n+            curCode.LocVarDataDef(v);\n+        } else {\n+            String name = scanner.stringValue, type;\n+            scanner.expect(Token.IDENT);\n+            if (scanner.token == Token.COLON) {\n+                scanner.scan();\n+                type = parseIdent();\n+            } else {\n+                type = \"I\";                  \/\/ TBD\n+            }\n+            curCode.LocVarDataDef(name, pool.FindCellAsciz(type));\n+        }\n+    }\n+\n+    Argument parseLocVarRef() throws Scanner.SyntaxError, IOException {\n+        if (scanner.token == Token.INTVAL) {\n+            int v = scanner.intValue;\n+            scanner.scan();\n+            return new Argument(v);\n+        } else {\n+            String name = scanner.stringValue;\n+            scanner.expect(Token.IDENT);\n+            return curCode.LocVarDataRef(name);\n+        }\n+    }\n+\n+    void parseLocVarEnd() throws Scanner.SyntaxError, IOException {\n+        if (scanner.token == Token.INTVAL) {\n+            int v = scanner.intValue;\n+            scanner.scan();\n+            curCode.LocVarDataEnd(v);\n+        } else {\n+            String name = scanner.stringValue;\n+            scanner.expect(Token.IDENT);\n+            curCode.LocVarDataEnd(name);\n+        }\n+    }\n+\n+    void parseMapItem(DataVector map) throws Scanner.SyntaxError, IOException {\n+        StackMapType itemType = stackMapType(scanner.intValue, null);\n+        ConstType tag = null;\n+        Argument arg = null;\n+        Token ptoken = scanner.token;\n+        int iValue = scanner.intValue;\n+        String sValue = scanner.stringValue;\n+        scanner.scan();\n+        resolve:\n+        {\n+            switch (ptoken) {\n+                case INTVAL:\n+                    break resolve;\n+                case CLASS:\n+                    itemType = StackMapType.ITEM_Object;\n+                    tag = ConstType.CONSTANT_CLASS;\n+                    break resolve;\n+                case CPINDEX:\n+                    itemType = StackMapType.ITEM_Object;\n+                    arg = pool.getCell(iValue);\n+                    break resolve;\n+                case IDENT:\n+                    itemType = stackMapType(sValue);\n+                    tag = Tables.tag(sValue);\n+                    if (itemType != null) { \/\/ itemType OK\n+                        if ((tag != null) \/\/ ambiguity: \"int,\" or \"int 77,\"?\n+                                && (scanner.token != SEMICOLON)\n+                                && (scanner.token != COMMA)) {\n+                            itemType = StackMapType.ITEM_Object;\n+                        }\n+                        break resolve;\n+                    } else if (tag != null) { \/\/ tag OK\n+                        itemType = StackMapType.ITEM_Object;\n+                        break resolve;\n+                    }\n+            }\n+            \/\/ resolution failed:\n+            itemType = StackMapType.ITEM_Bogus;\n+            env.error(\"itemtype.expected\", \"<\" + ptoken.printValue() + \">\");\n+        }\n+        switch (itemType) {\n+            case ITEM_Object:  \/\/ followed by CP index\n+                if (arg == null) {\n+                    arg = pool.FindCell(cpParser.parseConstValue(tag));\n+                }\n+                map.addElement(new StackMapData.StackMapItem2(itemType, arg));\n+                break;\n+            case ITEM_NewObject:  \/\/ followed by label\n+                arg = instrParser.parseLabelRef();\n+                map.addElement(new StackMapData.StackMapItem2(itemType, arg));\n+                break;\n+            default:\n+                map.addElement(new StackMapData.StackMapItem1(itemType));\n+        }\n+    }\n+\n+    \/**\n+     * Parse an external name: CPINDEX, string, or identifier.\n+     *\/\n+    ConstCell parseName() throws Scanner.SyntaxError, IOException {\n+        debugScan(\"------- [Parser.parseName]: \");\n+        String v;\n+        switch (scanner.token) {\n+            case CPINDEX: {\n+                int cpx = scanner.intValue;\n+                scanner.scan();\n+                return pool.getCell(cpx);\n+            }\n+            case STRINGVAL:\n+                v = scanner.stringValue;\n+                scanner.scan();\n+                return pool.FindCellAsciz(v);\n+\n+            \/\/ In many cases, Identifiers can correctly have the same\n+            \/\/ names as keywords.  We need to allow these.\n+            case OPEN:\n+            case MODULE:\n+            case VARARGS:\n+            case REQUIRES:\n+            case EXPORTS:\n+            case TO:\n+            case USES:\n+            case PROVIDES:\n+            case WITH:\n+            case OPENS:\n+\n+            case ARRAY_TYPEPATH:\n+            case INNER_TYPE_TYPEPATH:\n+            case WILDCARD_TYPEPATH:\n+            case TYPE_ARGUMENT_TYPEPATH:\n+            case PERMITTEDSUBCLASSES:\n+            case INF:\n+            case NAN:\n+            case COMPONENT:\n+\n+            case SYNTHETIC:\n+            case DEPRECATED:\n+            case VERSION:\n+            case BITS:\n+            case STACK:\n+            case LOCAL:\n+            case OF:\n+            case INNERCLASS:\n+            case STRICT:\n+            case FIELDREF:\n+            case METHODREF:\n+            case IDENT:\n+            case BRIDGE:\n+                v = scanner.idValue;\n+                scanner.scan();\n+                return pool.FindCellAsciz(v);\n+            default:\n+                env.error(scanner.pos, \"name.expected\", scanner.token);\n+                throw new Scanner.SyntaxError();\n+        }\n+    }\n+\n+    \/**\n+     * Parses a field or method reference for method handle.\n+     *\/\n+    ConstCell parseMethodHandle(SubTag subtag) throws Scanner.SyntaxError, IOException {\n+        ConstCell refCell;\n+        final int pos = parser.env.pos;\n+        switch (subtag) {\n+            \/\/ If the value of the reference_kind item is\n+            \/\/ 1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField)  or 4 (REF_putStatic),\n+            \/\/ then the constant_pool entry at that index must be a CONSTANT_Fieldref_info structure (4.4.2)\n+            \/\/ representing a field for which a method handle is to be created. jvms-4.4.8-200-C-A\n+            case REF_GETFIELD:\n+            case REF_GETSTATIC:\n+            case REF_PUTFIELD:\n+            case REF_PUTSTATIC:\n+                refCell = pool.FindCell(cpParser.parseConstValue(ConstType.CONSTANT_FIELD));\n+                break;\n+            \/\/  If the value of the reference_kind item is\n+            \/\/  5 (REF_invokeVirtual) or 8 (REF_newInvokeSpecial),\n+            \/\/  then the constant_pool entry at that index must be a CONSTANT_Methodref_info structure (4.4.2)\n+            \/\/  representing a class's method or constructor (2.9.1) for which a method handle is to be created.\n+            \/\/  jvms-4.4.8-200-C-B\n+            case REF_INVOKEVIRTUAL:\n+            case REF_NEWINVOKESPECIAL:\n+                cpParser.setExitImmediately(true);\n+                refCell = cpParser.parseConstRef(ConstType.CONSTANT_METHOD, ConstType.CONSTANT_INTERFACEMETHOD);\n+                cpParser.setExitImmediately(false);\n+                checkReferenceIndex(pos, ConstType.CONSTANT_METHOD, null);\n+                break;\n+            case REF_INVOKESTATIC:\n+            case REF_INVOKESPECIAL:\n+                \/\/ CODETOOLS-7902333\n+                \/\/ 4.4.8. The CONSTANT_MethodHandle_info Structure\n+                \/\/ reference_index\n+                \/\/ The value of the reference_index item must be a valid index into the constant_pool table.\n+                \/\/ The constant_pool entry at that index must be as follows:\n+                \/\/ If the value of the reference_kind item is 6 (REF_invokeStatic) or 7 (REF_invokeSpecial),\n+                \/\/ then if the class file version number is less than 52.0, the constant_pool entry at that index must be\n+                \/\/ a CONSTANT_Methodref_info structure representing a class's method for which a method handle is to be created;\n+                \/\/ if the class file version number is 52.0 or above, the constant_pool entry at that index must be\n+                \/\/ either a CONSTANT_Methodref_info structure or a CONSTANT_InterfaceMethodref_info structure (4.4.2)\n+                \/\/ representing a class's or interface's method for which a method handle is to be created.\n+                ConstType ctype01 = ConstType.CONSTANT_METHOD;\n+                ConstType ctype02 = ConstType.CONSTANT_INTERFACEMETHOD;\n+                if (this.cd.cfv.major_version() >= 52 && Modifiers.isInterface(this.cd.access)) {\n+                    ctype01 = ConstType.CONSTANT_INTERFACEMETHOD;\n+                    ctype02 = ConstType.CONSTANT_METHOD;\n+                }\n+                cpParser.setExitImmediately(true);\n+                refCell = cpParser.parseConstRef(ctype01, ctype02);\n+                cpParser.setExitImmediately(false);\n+                checkReferenceIndex(pos, ctype01, ctype02);\n+                break;\n+\n+            case REF_INVOKEINTERFACE:\n+                cpParser.setExitImmediately(true);\n+                refCell = cpParser.parseConstRef(ConstType.CONSTANT_INTERFACEMETHOD, ConstType.CONSTANT_METHOD);\n+                cpParser.setExitImmediately(false);\n+                checkReferenceIndex(pos, ConstType.CONSTANT_INTERFACEMETHOD, null);\n+                break;\n+            default:\n+                \/\/ should not reach\n+                throw new Scanner.SyntaxError();\n+        }\n+        return refCell;\n+    }\n+\n+    \/**\n+     * Check the pair reference_kind:reference_index where reference_kind is any from:\n+     * REF_invokeVirtual, REF_newInvokeSpecial, REF_invokeStatic, REF_invokeSpecial, REF_invokeInterface\n+     * and reference_index is one of [Empty], Method or InterfaceMethod\n+     * There are possible entries:\n+     * ldc Dynamic REF_newInvokeSpecial:InterfaceMethod  LdcConDyTwice.\"<init>\":\n+     * ldc Dynamic REF_invokeInterface:LdcConDyTwice.\"<init>\":\n+     * ldc Dynamic REF_newInvokeSpecial:Method LdcConDyTwice.\"<init>\":\n+     * ldc MethodHandle REF_newInvokeSpecial:InterfaceMethod  LdcConDyTwice.\"<init>\":\n+     * ldc MethodHandle REF_invokeInterface:LdcConDyTwice.\"<init>\":\n+     * ldc MethodHandle REF_newInvokeSpecial:Method LdcConDyTwice.\"<init>\":\n+     * invokedynamic MethodHandle REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\n+     * invokedynamic MethodHandle REF_invokeStatic:java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\n+     * ....\n+     * @param position   the position in a source file\n+     * @param defaultTag expected reference_index tag (Method or InterfaceMethod)\n+     * @param defaultTag 2nd expected reference_index tag (Method or InterfaceMethod)\n+     *\/\n+    private void checkReferenceIndex(int position, ConstType defaultTag, ConstType default2Tag) {\n+        if ( ! scanner.token.in(COLON, SEMICOLON) ) {\n+            if (default2Tag != null) {\n+                env.error(position, \"wrong.tag2\", defaultTag.parseKey(), default2Tag.parseKey());\n+            } else {\n+                env.error(position, \"wrong.tag\", defaultTag.parseKey());\n+            }\n+            throw new Scanner.SyntaxError().Fatal();\n+        }\n+    }\n+\n+    \/**\n+     * Parses a sub-tag value in method handle.\n+     *\/\n+    SubTag parseSubtag() throws Scanner.SyntaxError, IOException {\n+        SubTag subtag = null;\n+        switch (scanner.token) {\n+            case IDENT:\n+                subtag = subtag(scanner.stringValue);\n+                break;\n+            case INTVAL:\n+                subtag = subtag(scanner.intValue);\n+                break;\n+        }\n+        if (subtag == null) {\n+            env.error(\"subtag.expected\");\n+            throw new Scanner.SyntaxError();\n+        }\n+        scanner.scan();\n+        return subtag;\n+    }\n+\n+    ConstCell parseClassName(boolean uncond) throws Scanner.SyntaxError, IOException {\n+        String v;\n+        switch (scanner.token) {\n+            case CPINDEX: {\n+                int cpx = scanner.intValue;\n+                scanner.scan();\n+                return pool.getCell(cpx);\n+            }\n+            case STRINGVAL:\n+                v = scanner.stringValue;\n+                scanner.scan();\n+                v = prependPackage(v, uncond);\n+                return pool.FindCellAsciz(v);\n+            \/\/ Some identifiers might coincide with token names.\n+            \/\/ these should be OK to use as identifier names.\n+            case OPEN:\n+            case MODULE:\n+            case VARARGS:\n+            case REQUIRES:\n+            case EXPORTS:\n+            case TO:\n+            case USES:\n+            case PROVIDES:\n+            case WITH:\n+            case OPENS:\n+\n+            case ARRAY_TYPEPATH:\n+            case INNER_TYPE_TYPEPATH:\n+            case WILDCARD_TYPEPATH:\n+            case TYPE_ARGUMENT_TYPEPATH:\n+            case PERMITTEDSUBCLASSES:\n+            case INF:\n+            case NAN:\n+            case COMPONENT:\n+\n+            case SYNTHETIC:\n+            case DEPRECATED:\n+            case VERSION:\n+            case BITS:\n+            case STACK:\n+            case LOCAL:\n+            case OF:\n+            case INNERCLASS:\n+            case STRICT:\n+            case FIELDREF:\n+            case METHODREF:\n+            case BRIDGE:\n+            case IDENT:\n+                v = scanner.idValue;\n+                scanner.scan();\n+                v = prependPackage(v, uncond);\n+                return pool.FindCellAsciz(v);\n+            default:\n+                ConstType key = Tables.tag(scanner.token.value());\n+                env.traceln(\"%%%%% Unrecognized token [\" + scanner.token + \"]: '\" + (key == null ? \"null\" : key.parseKey()) + \"'.\");\n+                env.error(scanner.prevPos, \"name.expected\", \"\\\"\" + scanner.token.parseKey() + \"\\\"\");\n+                throw new Scanner.SyntaxError();\n+        }\n+    }\n+\n+    private String prependPackage(String className, boolean uncond) {\n+        if (uncond || (scanner.token == Token.FIELD)) {\n+            if ((!className.contains(\"\/\"))             \/\/ class identifier doesn't contain \"\/\"\n+                    && (!className.contains(\"[\"))) {    \/\/ class identifier doesn't contain \"[\"\n+                className = pkgPrefix + className; \/\/ add package\n+            }\n+        }\n+        return className;\n+    }\n+\n+    \/**\n+     * Parse a signed integer of size bytes long.\n+     * size = 1 or 2\n+     *\/\n+    Argument parseInt(int size) throws Scanner.SyntaxError, IOException {\n+        if (scanner.token == Token.BITS) {\n+            scanner.scan();\n+        }\n+        if (scanner.token != Token.INTVAL) {\n+            env.error(scanner.pos, \"int.expected\");\n+            throw new Scanner.SyntaxError();\n+        }\n+        int arg = scanner.intValue * scanner.sign;\n+        switch (size) {\n+            case 1:\n+\/\/                if ((arg>127)||(arg<-128)) { \/\/ 0xFF not allowed\n+                if ((arg > 255) || (arg < -128)) { \/\/ to allow 0xFF\n+                    env.error(scanner.pos, \"value.large\", \"1 byte\");\n+                    throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            case 2:\n+\/\/                if ((arg > 32767) || (arg < -32768)) { \/\/this seems\n+\/\/ natural but is not backward compatible. Some tests contain\n+\/\/ expressions like:\n+\/\/                sipush    0x8765;\n+\n+                if ((arg > 65535) || (arg < -32768)) {\n+                    env.error(scanner.pos, \"value.large\", \"2 bytes\");\n+                    throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            default:\n+                throw new InternalError(\"parseInt(\" + size + \")\");\n+        }\n+        scanner.scan();\n+        return new Argument(arg);\n+    }\n+\n+    \/**\n+     * Parse an unsigned integer of size bytes long.\n+     * size = 1 or 2\n+     *\/\n+    Argument parseUInt(int size) throws Scanner.SyntaxError, IOException {\n+        if (scanner.token != Token.INTVAL) {\n+            env.error(scanner.pos, \"int.expected\");\n+            throw new Scanner.SyntaxError();\n+        }\n+        if (scanner.sign == -1) {\n+            env.error(scanner.pos, \"neg.forbidden\");\n+            throw new Scanner.SyntaxError();\n+        }\n+        int arg = scanner.intValue;\n+        switch (size) {\n+            case 1:\n+                if (arg > 255) {\n+                    env.error(scanner.pos, \"value.large\", \"1 byte\");\n+                    throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            case 2:\n+                if (arg > 65535) {\n+                    env.error(scanner.pos, \"value.large\", \"2 bytes\");\n+                    throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            default:\n+                throw new InternalError(\"parseUInt(\" + size + \")\");\n+        }\n+        scanner.scan();\n+        return new Argument(arg);\n+    }\n+\n+    \/**\n+     * Parse constant declaration\n+     *\/\n+    private void parseConstDef() throws IOException {\n+        for (; ; ) {\n+            if (scanner.token == Token.CPINDEX) {\n+                int cpx = scanner.intValue;\n+                scanner.scan();\n+                scanner.expect(Token.ASSIGN);\n+                env.traceln(\"parseConstDef:\" + cpx);\n+                pool.setCell(cpx, cpParser.parseConstRef(null));\n+            } else {\n+                env.error(\"const.def.expected\");\n+                throw new Scanner.SyntaxError();\n+            }\n+            if (scanner.token != COMMA) {\n+                scanner.expect(SEMICOLON);\n+                return;\n+            }\n+            scanner.scan(); \/\/ COMMA\n+        }\n+    }\n+\n+    \/**\n+     * Parse the modifiers\n+     *\/\n+    private int scanModifier(int mod) throws IOException {\n+        int nextmod, prevpos;\n+\n+        while (true) {\n+            nextmod = 0;\n+            switch (scanner.token) {\n+                case PUBLIC:\n+                    nextmod = ACC_PUBLIC;\n+                    break;\n+                case PRIVATE:\n+                    nextmod = ACC_PRIVATE;\n+                    break;\n+                case PROTECTED:\n+                    nextmod = ACC_PROTECTED;\n+                    break;\n+                case STATIC:\n+                    nextmod = ACC_STATIC;\n+                    break;\n+                case FINAL:\n+                    nextmod = ACC_FINAL;\n+                    break;\n+                case SYNCHRONIZED:\n+                    nextmod = ACC_SYNCHRONIZED;\n+                    break;\n+                case SUPER:\n+                    nextmod = ACC_SUPER;\n+                    break;\n+                case VOLATILE:\n+                    nextmod = ACC_VOLATILE;\n+                    break;\n+                case BRIDGE:\n+                    nextmod = ACC_BRIDGE;\n+                    break;\n+                case TRANSIENT:\n+                    nextmod = ACC_TRANSIENT;\n+                    break;\n+                case VARARGS:\n+                    nextmod = ACC_VARARGS;\n+                    break;\n+                case NATIVE:\n+                    nextmod = ACC_NATIVE;\n+                    break;\n+                case INTERFACE:\n+                    nextmod = ACC_INTERFACE;\n+                    break;\n+                case ABSTRACT:\n+                    nextmod = ACC_ABSTRACT;\n+                    break;\n+                case STRICT:\n+                    nextmod = ACC_STRICT;\n+                    break;\n+                case ENUM:\n+                    nextmod = ACC_ENUM;\n+                    break;\n+                case SYNTHETIC:\n+                    nextmod = ACC_SYNTHETIC;\n+                    break;\n+                case ANNOTATION_ACCESS:\n+                    nextmod = ACC_ANNOTATION;\n+                    break;\n+\n+                case DEPRECATED:\n+                    nextmod = DEPRECATED_ATTRIBUTE;\n+                    break;\n+                case MANDATED:\n+                    nextmod = ACC_MANDATED;\n+                    break;\n+                default:\n+                    return nextmod;\n+            }\n+            prevpos = scanner.pos;\n+            scanner.scan();\n+            if ((mod & nextmod) == 0) {\n+                return nextmod;\n+            }\n+            env.error(prevpos, \"warn.repeated.modifier\");\n+        }\n+    }\n+\n+    int scanModifiers() throws IOException {\n+        int mod = 0, nextmod;\n+\n+        while (true) {\n+            nextmod = scanModifier(mod);\n+            if (nextmod == 0) {\n+                return mod;\n+            }\n+            mod = mod | nextmod;\n+        }\n+    }\n+\n+    \/**\n+     * Parse a field.\n+     *\/\n+    private void parseField(int mod) throws Scanner.SyntaxError, IOException {\n+        debugStr(\"  [Parser.parseField]: <<<Begin>>>\");\n+        \/\/ check access modifiers:\n+        Modifiers.checkFieldModifiers(cd, mod, scanner.pos);\n+\n+        while (true) {\n+            ConstCell nameCell = parseName();\n+            scanner.expect(Token.COLON);\n+            ConstCell typeCell = parseName();\n+\n+            \/\/ Define the variable\n+            FieldData fld = cd.addField(mod, nameCell, typeCell);\n+\n+            if (memberAnnttns != null) {\n+                fld.addAnnotations(memberAnnttns);\n+            }\n+\n+            \/\/ Parse the optional attribute: signature\n+            if (scanner.token == Token.COLON) {\n+                scanner.scan();\n+                ConstCell signatureCell = parseName();\n+                fld.setSignatureAttr(signatureCell);\n+            }\n+\n+            \/\/ Parse the optional initializer\n+            if (scanner.token == Token.ASSIGN) {\n+                scanner.scan();\n+                fld.SetValue(cpParser.parseConstRef(null));\n+            }\n+\n+            \/\/ If the next scanner.token is a comma, then there is more\n+            debugScan(\"  [Parser.parseField]: Field: \" + fld + \" \");\n+\n+            if (scanner.token != COMMA) {\n+                scanner.expect(SEMICOLON);\n+                return;\n+            }\n+            scanner.scan();\n+        }  \/\/ end while\n+    }  \/\/ end parseField\n+\n+    \/**\n+     * Scan method's signature to determine size of parameters.\n+     *\/\n+    private int countParams(ConstCell sigCell) throws Scanner.SyntaxError {\n+        String sig;\n+        try {\n+            ConstValue_String strConst = (ConstValue_String) sigCell.ref;\n+            sig = strConst.value;\n+        } catch (NullPointerException | ClassCastException e) {\n+            return 0; \/\/ ??? TBD\n+        }\n+        int siglen = sig.length(), k = 0, loccnt = 0, errparam = 0;\n+        boolean arraytype = false;\n+        scan:\n+        {\n+            if (k >= siglen) {\n+                break scan;\n+            }\n+            if (sig.charAt(k) != '(') {\n+                errparam = 1;\n+                break scan;\n+            }\n+            for (k = 1; k < siglen; k++) {\n+                switch (sig.charAt(k)) {\n+                    case ')':\n+                        if (arraytype) {\n+                            errparam = 2;\n+                            break scan;\n+                        }\n+                        return loccnt;\n+                    case '[':\n+                        arraytype = true;\n+                        break;\n+                    case 'B':\n+                    case 'C':\n+                    case 'F':\n+                    case 'I':\n+                    case 'S':\n+                    case 'Z':\n+                        loccnt++;\n+                        arraytype = false;\n+                        break;\n+                    case 'D':\n+                    case 'J':\n+                        loccnt++;\n+                        if (arraytype) {\n+                            arraytype = false;\n+                        } else {\n+                            loccnt++;\n+                        }\n+                        break;\n+                    case 'L':\n+                        for (; ; k++) {\n+                            if (k >= siglen) {\n+                                errparam = 3;\n+                                break scan;\n+                            }\n+                            if (sig.charAt(k) == ';') {\n+                                break;\n+                            }\n+                        }\n+                        loccnt++;\n+                        arraytype = false;\n+                        break;\n+                    default:\n+                        errparam = 4;\n+                        break scan;\n+                }\n+            }\n+        }\n+        env.error(scanner.pos, \"msig.malformed\", Integer.toString(k), Integer.toString(errparam));\n+        return loccnt;\n+    }\n+\n+    \/**\n+     * Parse a method.\n+     *\/\n+    private void parseMethod(int mod) throws Scanner.SyntaxError, IOException {\n+\n+        \/\/ The start of the method\n+        int posa = scanner.pos;\n+        debugStr(\"  [Parser.parseMethod]: <<<Begin>>>\");\n+\n+        ConstCell nameCell = parseName();\n+        ConstValue_String strConst = (ConstValue_String) nameCell.ref;\n+        String name = strConst.value;\n+        boolean is_clinit = name.equals(\"<clinit>\");\n+        boolean is_init = name.equals(\"<init>\");\n+        DefaultAnnotationAttr defAnnot = null;\n+\n+        \/\/ check access modifiers:\n+        Modifiers.checkMethodModifiers(cd, mod, posa, is_init, is_clinit);\n+\n+        scanner.expect(Token.COLON);\n+        ConstCell typeCell = parseName();\n+        int paramcnt = countParams(typeCell);\n+        if ((!Modifiers.isStatic(mod)) && !is_clinit) {\n+            paramcnt++;\n+        }\n+        if (paramcnt > 255) {\n+            env.error(scanner.pos, \"warn.msig.more255\", Integer.toString(paramcnt));\n+        }\n+        \/\/ Parse throws clause\n+        ArrayList<ConstCell> exc_table = null;\n+        if (scanner.token == Token.THROWS) {\n+            scanner.scan();\n+            exc_table = new ArrayList<>();\n+            for (; ; ) {\n+                posa = scanner.pos;\n+                ConstCell exc = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+                if (exc_table.contains(exc)) {\n+                    env.error(posa, \"warn.exc.repeated\");\n+                } else {\n+                    exc_table.add(exc);\n+                    env.traceln(\"THROWS:\" + exc.arg);\n+                }\n+                if (scanner.token != COMMA) {\n+                    break;\n+                }\n+                scanner.scan();\n+            }\n+        }\n+        if (scanner.token == Token.DEFAULT) {\n+            \/\/ need to scan the annotation value\n+            defAnnot = annotParser.parseDefaultAnnotation();\n+        }\n+\n+        MethodData curMethod = cd.StartMethod(mod, nameCell, typeCell, exc_table);\n+        Argument max_stack = null, max_locals = null;\n+\n+        if (scanner.token == Token.STACK) {\n+            scanner.scan();\n+            max_stack = parseUInt(2);\n+        }\n+        if (scanner.token == Token.LOCAL) {\n+            scanner.scan();\n+            max_locals = parseUInt(2);\n+        }\n+        if (scanner.token == Token.INTVAL) {\n+            annotParser.parseParamAnnots(paramcnt, curMethod);\n+        }\n+\n+        if (scanner.token == SEMICOLON) {\n+            if ((max_stack != null) || (max_locals != null)) {\n+                env.error(\"token.expected\", \"{\");\n+            }\n+            scanner.scan();\n+        } else {\n+            scanner.expect(Token.LBRACE);\n+            curCode = curMethod.startCode(posa, paramcnt, max_stack, max_locals);\n+            while ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+                instrParser.parseInstr();\n+                if (scanner.token == Token.RBRACE) {\n+                    break;\n+                }\n+                \/\/ code's type annotation(s)\n+                if (scanner.token == Token.ANNOTATION) {\n+                    curCode.addAnnotations(annotParser.scanAnnotations());\n+                    break;\n+                }\n+                scanner.expect(SEMICOLON);\n+            }\n+            curCode.endCode();\n+            scanner.expect(Token.RBRACE);\n+        }\n+\n+        if (defAnnot != null) {\n+            curMethod.addDefaultAnnotation(defAnnot);\n+        }\n+        if (memberAnnttns != null) {\n+            curMethod.addAnnotations(memberAnnttns);\n+        }\n+        cd.EndMethod();\n+        debugStr(\"  [Parser.parseMethod]: Method: \" + curMethod);\n+\n+    }  \/\/ end parseMethod\n+\n+    \/**\n+     * Parse a (CPX based) BootstrapMethod entry.\n+     *\/\n+    private void parseCPXBootstrapMethod() throws Scanner.SyntaxError, IOException {\n+        \/\/ Parses in the form:\n+        \/\/ BOOTSTRAPMETHOD CPX_MethodHandle (CPX_Arg)* ;\n+        if (scanner.token == Token.CPINDEX) {\n+            \/\/ CPX can be a CPX to an MethodHandle constant,\n+            int cpx = scanner.intValue;\n+            ConstCell MHCell = pool.getCell(cpx);\n+            scanner.scan();\n+            ArrayList<ConstCell> bsm_args = new ArrayList<>(256);\n+\n+            while (scanner.token != SEMICOLON) {\n+                if (scanner.token == Token.CPINDEX) {\n+                    bsm_args.add(pool.getCell(scanner.intValue));\n+\n+                } else {\n+                    \/\/ throw error, bootstrap method is not recognizable\n+                    env.error(scanner.pos, \"invalid.bootstrapmethod\");\n+                    throw new Scanner.SyntaxError();\n+                }\n+                scanner.scan();\n+            }\n+            BootstrapMethodData bsmData = new BootstrapMethodData(MHCell, bsm_args);\n+            cd.addBootstrapMethod(bsmData);\n+        } else {\n+            \/\/ throw error, bootstrap method is not recognizable\n+            env.error(scanner.pos, \"invalid.bootstrapmethod\");\n+            throw new Scanner.SyntaxError();\n+        }\n+    }\n+\n+    \/**\n+     * Parse a NestHost entry\n+     *\/\n+    private void parseNestHost() throws Scanner.SyntaxError, IOException {\n+        \/\/ Parses in the form:\n+        \/\/ NESTHOST IDENT;\n+        debugStr(\"  [Parser.parseNestHost]: <<<Begin>>>\");\n+        String className = prependPackage(parseIdent(), true);\n+        ConstCell hostClass = pool.FindCellClassByName(className);\n+        debugScan(\"  [Parser.parseNestHost]: NestHost: class \" + className);\n+        scanner.expect(SEMICOLON);\n+        cd.addNestHost(hostClass);\n+    }\n+\n+    \/**\n+     * Parse a list of classes belonging to the [NestMembers | PermittedSubclasses]  entry\n+     *\/\n+    private void parseClasses(Consumer<ArrayList<ConstCell>> classesConsumer)\n+            throws Scanner.SyntaxError, IOException {\n+        ArrayList<ConstCell> classes = new ArrayList<>();\n+        \/\/ Parses in the form:\n+        \/\/ (NESTMEMBERS|PERMITTEDSUBCLASSES)? IDENT(, IDENT)*;\n+        debugStr(\"  [Parser.parseClasses]: <<<Begin>>>\");\n+        while (true) {\n+            String className = prependPackage(parseIdent(), true);\n+            classes.add(pool.FindCellClassByName(className));\n+            debugScan(\"  [Parser.parseClasses]: class \" + className);\n+            if (scanner.token != COMMA) {\n+                scanner.expect(SEMICOLON);\n+                classesConsumer.accept(classes);\n+                return;\n+            }\n+            scanner.scan();\n+        }\n+    }\n+\n+    \/**\n+     * Parse the Record entry\n+     *\/\n+    private void parseRecord() throws Scanner.SyntaxError, IOException {\n+        \/\/ Parses in the form:\n+        \/\/ RECORD { (COMPONENT)+ }\n+        \/\/ where\n+        \/\/ COMPONENT Component (ANNOTATION)* NAME:DESCRIPTOR(:SIGNATURE)? (,|;)\n+        \/\/ NAME = (CPINDEX | IDENT)\n+        \/\/ DESCRIPTOR = (CPINDEX | STRING)\n+        \/\/ SIGNATURE  = (CPINDEX | STRING)\n+        debugScan(\"[Parser.parseRecord]:  Begin\");\n+        scanner.expect(Token.LBRACE);\n+\n+        ArrayList<AnnotationData> componentAnntts = null;\n+        boolean grouped = false;\n+        RecordData rd = cd.setRecord(scanner.pos);\n+\n+        while (true) {\n+            if (scanner.token == Token.RBRACE) {\n+                if (rd.isEmpty()) {\n+                    env.error(scanner.pos, \"warn.no.components.in.record.attribute\");\n+                    cd.rejectRecord();\n+                } else if (grouped) {\n+                    env.error(scanner.pos, \"grouped.component.expected\");\n+                }\n+                scanner.scan();\n+                break;\n+            }\n+\n+            ConstCell nameCell, descCell, signatureCell = null;\n+            if (scanner.token == Token.ANNOTATION) {\n+                componentAnntts = annotParser.scanAnnotations();\n+            }\n+\n+            scanner.expect(Token.COMPONENT);\n+\n+            nameCell = parseName();\n+            scanner.expect(Token.COLON);\n+            descCell = parseName();\n+            \/\/ Parse the optional attribute: signature\n+            if (scanner.token == Token.COLON) {\n+                scanner.scan();\n+                signatureCell = parseName();\n+            }\n+\n+            rd.addComponent(nameCell, descCell, signatureCell, componentAnntts);\n+\n+            switch (scanner.token) {\n+                case COMMA:\n+                    grouped = true;\n+                    break;\n+                case SEMICOLON:\n+                    grouped = false;\n+                    componentAnntts = null;\n+                    break;\n+                default:\n+                    env.error(scanner.pos, \"one.of.two.token.expected\",\n+                            \"<\" + SEMICOLON.printValue() + \">\",\n+                            \"<\" + COMMA.printValue() + \">\");\n+                    break;\n+            }\n+            \/\/ next component\n+            scanner.scan();\n+        }  \/\/ end while\n+        debugScan(\"[Parser.parseRecord]:  End\");\n+    }\n+\n+    \/**\n+     * Parse an inner class.\n+     *\/\n+    private void parseInnerClass(int mod) throws Scanner.SyntaxError, IOException {\n+        \/\/ Parses in the form:\n+        \/\/ MODIFIERS (INNERCLASSNAME =)? (INNERCLASS) (OF OUTERCLASS)? ;\n+        \/\/\n+        \/\/ where\n+        \/\/    INNERCLASSNAME = (IDENT | CPX_IN-CL-NM)\n+        \/\/    INNERCLASS = (CLASS IDENT | CPX_IN-CL) (S2)\n+        \/\/    OUTERCLASS = (CLASS IDENT | CPX_OT-CL) (S3)\n+        \/\/\n+        \/\/ Note:\n+        \/\/    If a class reference cannot be identified using IDENT, CPX indexes must be used.\n+\n+        \/\/ check access modifiers:\n+        debugScan(\"[Parser.parseInnerClass]:  Begin \");\n+        Modifiers.checkInnerClassModifiers(cd, mod, scanner.pos);\n+\n+        ConstCell nameCell;\n+        ConstCell innerClass = null;\n+        ConstCell outerClass = null;\n+\n+\n+        if (scanner.token == Token.CLASS) {\n+            nameCell = pool.getCell(0);  \/\/ no NameIndex\n+            parseInnerClass_s2(mod, nameCell, innerClass, outerClass);\n+        } else {\n+            if ((scanner.token == Token.IDENT) || scanner.checkTokenIdent()) {\n+                \/\/ Got a Class Name\n+                nameCell = parseName();\n+                parseInnerClass_s1(mod, nameCell, innerClass, outerClass);\n+            } else if (scanner.token == Token.CPINDEX) {\n+                \/\/ CPX can be either a CPX to an InnerClassName,\n+                \/\/ or a CPX to an InnerClassInfo\n+                int cpx = scanner.intValue;\n+                nameCell = pool.getCell(cpx);\n+                ConstValue nameCellValue = nameCell.ref;\n+\n+                if (nameCellValue instanceof ConstValue_String) {\n+                    \/\/ got a name cell\n+                    scanner.scan();\n+                    parseInnerClass_s1(mod, nameCell, innerClass, outerClass);\n+                } else {\n+                    \/\/ got a CPRef cell\n+                    nameCell = pool.getCell(0);  \/\/ no NameIndex\n+                    parseInnerClass_s2(mod, nameCell, innerClass, outerClass);\n+                }\n+            } else {\n+                pic_error();\n+            }\n+\n+        }\n+    }\n+\n+    private void parseInnerClass_s1(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) throws IOException {\n+        \/\/ next scanner.token must be '='\n+        if (scanner.token == Token.ASSIGN) {\n+            scanner.scan();\n+            parseInnerClass_s2(mod, nameCell, innerClass, outerClass);\n+        } else {\n+            pic_error();\n+        }\n+\n+    }\n+\n+    private void parseInnerClass_s2(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) throws IOException {\n+        \/\/ scanner.token is either \"CLASS IDENT\" or \"CPX_Class\"\n+        if ((scanner.token == Token.CPINDEX) || (scanner.token == Token.CLASS)) {\n+            if (scanner.token == Token.CPINDEX) {\n+                innerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+            }\n+\n+            if (scanner.token == Token.CLASS) {\n+                \/\/ next symbol needs to be InnerClass\n+                scanner.scan();\n+                innerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+            }\n+\n+            \/\/ See if declaration is terminated\n+            if (scanner.token == SEMICOLON) {\n+                \/\/ InnerClass is complete, no OUTERINFO;\n+                outerClass = pool.getCell(0);\n+                pic_tracecreate(mod, nameCell, innerClass, outerClass);\n+                cd.addInnerClass(mod, nameCell, innerClass, outerClass);\n+            } else if (scanner.token == Token.OF) {\n+                \/\/ got an outer class reference\n+                parseInnerClass_s3(mod, nameCell, innerClass, outerClass);\n+            } else {\n+                pic_error();\n+            }\n+\n+        } else {\n+            pic_error();\n+        }\n+\n+    }\n+\n+    private void parseInnerClass_s3(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) throws IOException {\n+        scanner.scan();\n+        if ((scanner.token == Token.CLASS) || (scanner.token == Token.CPINDEX)) {\n+            if (scanner.token == Token.CLASS) {\n+                \/\/ next symbol needs to be InnerClass\n+                scanner.scan();\n+                outerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+            }\n+            if (scanner.token == Token.CPINDEX) {\n+                outerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+            }\n+\n+            if (scanner.token == SEMICOLON) {\n+                pic_tracecreate(mod, nameCell, innerClass, outerClass);\n+                cd.addInnerClass(mod, nameCell, innerClass, outerClass);\n+            } else {\n+                pic_error();\n+            }\n+        } else {\n+            pic_error();\n+        }\n+    }\n+\n+    private void pic_tracecreate(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) {\n+        \/\/ throw error, IC is not recognizable\n+        env.trace(\" Creating InnerClass: [\" + Modifiers.toString(mod, CF_Context.CTX_INNERCLASS) + \"], \");\n+\n+        if (nameCell != pool.getCell(0)) {\n+            ConstValue value = nameCell.ref;\n+            if (value != null) {\n+                env.trace(value.toString() + \" = \");\n+            }\n+        }\n+\n+        ConstValue_Cell ici_val = (ConstValue_Cell) innerClass.ref;\n+        ConstCell ici_ascii = ici_val.cell;\n+        \/\/ Constant pool may not be numberized yet.\n+        \/\/\n+        \/\/ check values before dereference on a trace.\n+        if (ici_ascii.ref == null) {\n+            env.trace(\"<#cpx-unresolved> \");\n+        } else {\n+            ConstValue_String cval = (ConstValue_String) ici_ascii.ref;\n+            if (cval.value == null) {\n+                env.trace(\"<#cpx-0> \");\n+            } else {\n+                env.trace(cval.value + \" \");\n+            }\n+        }\n+\n+        if (outerClass != pool.getCell(0)) {\n+            if (outerClass.arg != 0) {\n+                ConstValue_Cell oci_val = (ConstValue_Cell) outerClass.ref;\n+                ConstCell oci_ascii = oci_val.cell;\n+                if (oci_ascii.ref == null) {\n+                    env.trace(\" of <#cpx-unresolved>  \");\n+                } else {\n+                    ConstValue_String cval = (ConstValue_String) oci_ascii.ref;\n+                    if (cval.value == null) {\n+                        env.trace(\" of <#cpx-0>  \");\n+                    } else {\n+                        env.trace(\" of \" + cval.value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        env.traceln(\"\");\n+    }\n+\n+    private void pic_error() {\n+        \/\/ throw error, IC is not recognizable\n+        env.error(scanner.pos, \"invalid.innerclass\");\n+        throw new Scanner.SyntaxError();\n+    }\n+\n+    \/**\n+     * The match() method is used to quickly match opening\n+     * brackets (ie: '(', '{', or '[') with their closing\n+     * counter part. This is useful during error recovery.<p>\n+     * <p>\n+     * Scan to a matching '}', ']' or ')'. The current scanner.token must be\n+     * a '{', '[' or '(';\n+     *\/\n+    private void match(Token open, Token close) throws IOException {\n+        int depth = 1;\n+\n+        while (true) {\n+            scanner.scan();\n+            if (scanner.token == open) {\n+                depth++;\n+            } else if (scanner.token == close) {\n+                if (--depth == 0) {\n+                    return;\n+                }\n+            } else if (scanner.token == Token.EOF) {\n+                env.error(scanner.pos, \"unbalanced.paren\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Recover after a syntax error in a field. This involves\n+     * discarding scanner.tokens until an EOF or a possible legal\n+     * continuation is encountered.\n+     *\/\n+    private void recoverField() throws Scanner.SyntaxError, IOException {\n+        while (true) {\n+            switch (scanner.token) {\n+                case EOF:\n+                case STATIC:\n+                case FINAL:\n+                case PUBLIC:\n+                case PRIVATE:\n+                case SYNCHRONIZED:\n+                case TRANSIENT:\n+                case PROTECTED:\n+                case VOLATILE:\n+                case NATIVE:\n+\/\/                case INTERFACE: see below\n+                case ABSTRACT:\n+                case ANNOTATION_ACCESS:\n+                    \/\/ possible begin of a field, continue\n+                    return;\n+\n+                case LBRACE:\n+                    match(Token.LBRACE, Token.RBRACE);\n+                    scanner.scan();\n+                    break;\n+\n+                case LPAREN:\n+                    match(Token.LPAREN, Token.RPAREN);\n+                    scanner.scan();\n+                    break;\n+\n+                case LSQBRACKET:\n+                    match(Token.LSQBRACKET, Token.RSQBRACKET);\n+                    scanner.scan();\n+                    break;\n+\n+                case RBRACE:\n+                case INTERFACE:\n+                case CLASS:\n+                case IMPORT:\n+                case PACKAGE:\n+                    \/\/ begin of something outside a class, panic more\n+                    endClass();\n+                    scanner.debugStr(\"    [Parser.recoverField]: pos: [\" + scanner.pos + \"]: \");\n+                    throw new Scanner.SyntaxError().Fatal();\n+                default:\n+                    \/\/ don't know what to do, skip\n+                    scanner.scan();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Parse a class or interface declaration.\n+     *\/\n+    private void parseClass(int mod) throws IOException {\n+        int posa = scanner.pos;\n+        debugStr(\"   [Parser.parseClass]:  Begin \");\n+        \/\/ check access modifiers:\n+        Modifiers.checkClassModifiers(env, mod, scanner);\n+\n+        if (cd == null) {\n+            cd = new ClassData(env, currentCFV.clone());\n+            pool = cd.pool;\n+        }\n+\n+        if (clsAnnttns != null) {\n+            cd.addAnnotations(clsAnnttns);\n+        }\n+\n+        \/\/ move the tokenizer to the identifier:\n+        if (scanner.token == Token.CLASS) {\n+            scanner.scan();\n+        } else if (scanner.token == Token.ANNOTATION) {\n+            scanner.scan();\n+            if (scanner.token == Token.INTERFACE) {\n+                mod |= ACC_ANNOTATION | ACC_INTERFACE;\n+                scanner.scan();\n+            } else {\n+                env.error(scanner.prevPos, \"token.expected\", Token.ANNOTATION.parseKey() + Token.INTERFACE.parseKey());\n+                throw new Scanner.SyntaxError();\n+            }\n+        }\n+\n+        \/\/ Parse the class name\n+        ConstCell nm = cpParser.parseConstRef(ConstType.CONSTANT_CLASS, null, true);\n+\n+        if (scanner.token == Token.FIELD) { \/\/ DOT\n+            String fileExtension;\n+            scanner.scan();\n+            switch (scanner.token) {\n+                case STRINGVAL:\n+                    fileExtension = scanner.stringValue;\n+                    break;\n+                case IDENT:\n+                    fileExtension = scanner.idValue;\n+                    break;\n+                default:\n+                    env.error(scanner.pos, \"name.expected\");\n+                    throw new Scanner.SyntaxError();\n+            }\n+            scanner.scan();\n+            cd.fileExtension = \".\" + fileExtension;\n+        } else if (scanner.token == Token.MODULE) {\n+            env.error(scanner.prevPos, \"token.expected\", Token.OPEN.parseKey());\n+            throw new Scanner.SyntaxError();\n+        } else if (scanner.token == SEMICOLON) {\n+            \/\/ drop the semi-colon following a name\n+            scanner.scan();\n+        }\n+\n+        \/\/ Parse extends clause\n+        ConstCell sup = null;\n+        if (scanner.token == Token.EXTENDS) {\n+            scanner.scan();\n+            sup = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+            while (scanner.token == COMMA) {\n+                scanner.scan();\n+                env.error(posa, \"multiple.inherit\");\n+                cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+            }\n+        }\n+\n+        \/\/ Parse implements clause\n+        ArrayList<Argument> impl = new ArrayList<>();\n+        if (scanner.token == Token.IMPLEMENTS) {\n+            do {\n+                scanner.scan();\n+                Argument intf = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+                if (impl.contains(intf)) {\n+                    env.error(posa, \"warn.intf.repeated\", intf);\n+                } else {\n+                    impl.add(intf);\n+                }\n+            } while (scanner.token == COMMA);\n+        }\n+        parseVersion();\n+        scanner.expect(Token.LBRACE);\n+\n+        \/\/ Begin a new class\n+        cd.init(mod, nm, sup, impl);\n+\n+        \/\/ Parse constant declarations\n+\n+        \/\/ Parse class members\n+        while ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+            switch (scanner.token) {\n+                case SEMICOLON:\n+                    \/\/ Empty fields are allowed\n+                    scanner.scan();\n+                    break;\n+                case CONST:\n+                    scanner.scan();\n+                    parseConstDef();\n+                    explicitcp = true;\n+                    break;\n+                default:   \/\/ scanner.token is some member.\n+                    parseClassMembers();\n+            }  \/\/ end switch\n+        } \/\/ while\n+        scanner.expect(Token.RBRACE);\n+        \/\/ End the class\n+        endClass();\n+    } \/\/ end parseClass\n+\n+    \/**\n+     * Parses a package or type name in a module statement(s)\n+     *\/\n+    private String parseTypeName() throws IOException {\n+        String name = \"\", field = \"\";\n+        while (true) {\n+            if (scanner.token.possibleModuleName()) {\n+                name = name + field + scanner.idValue;\n+                scanner.scan();\n+            } else {\n+                env.error(scanner.pos, \"name.expected\", \"\\\"\" + scanner.token.parseKey() + \"\\\"\");\n+                throw new Scanner.SyntaxError();\n+            }\n+            if (scanner.token == Token.FIELD) {\n+                env.error(scanner.pos, \"warn.dot.will.be.converted\");\n+                field = \"\/\";\n+                scanner.scan();\n+            } else {\n+                break;\n+            }\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Parses a module name in a module statement(s)\n+     *\/\n+    private String parseModuleName() throws IOException {\n+        String name = \"\", field = \"\";\n+        while (true) {\n+            if (scanner.token.possibleModuleName()) {\n+                name = name + field + scanner.idValue;\n+                scanner.scanModuleStatement();\n+            } else {\n+                env.error(scanner.pos, \"module.name.expected\", \"\\\"\" + scanner.token.parseKey() + \"\\\"\");\n+                throw new Scanner.SyntaxError().Fatal();\n+            }\n+            if (scanner.token == Token.FIELD) {\n+                field = Character.toString((char) scanner.token.value());\n+                scanner.scanModuleStatement();\n+            } else {\n+                break;\n+            }\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Parse a module declaration.\n+     *\/\n+    private void parseModule() throws IOException {\n+        debugStr(\"   [Parser.parseModule]:  Begin \");\n+        if (cd == null) {\n+            cd = new ClassData(env, currentCFV.clone());\n+            pool = cd.pool;\n+        }\n+        if (clsAnnttns != null) {\n+            cd.addAnnotations(clsAnnttns);\n+        }\n+        moduleAttribute = new ModuleAttr(cd);\n+\n+        if (scanner.token == Token.OPEN) {\n+            moduleAttribute.openModule();\n+            scanner.scan();\n+        }\n+\n+        \/\/ move the tokenizer to the identifier:\n+        if (scanner.token == Token.MODULE) {\n+            scanner.scanModuleStatement();\n+            \/\/ scanner.scan();\n+        } else {\n+            env.error(scanner.pos, \"token.expected\", Token.MODULE.parseKey());\n+            throw new Scanner.SyntaxError().Fatal();\n+        }\n+        \/\/ Parse the module name\n+        String moduleName = parseModuleName();\n+        if (moduleName.isEmpty()) {\n+            env.error(scanner.pos, \"name.expected\");\n+            throw new Scanner.SyntaxError().Fatal();\n+        }\n+        moduleAttribute.setModuleName(moduleName);\n+\n+        parseVersion();\n+        scanner.expect(Token.LBRACE);\n+\n+        \/\/ Begin a new class as module\n+        cd.initAsModule();\n+\n+        \/\/ Parse module statement(s)\n+        while ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+            switch (scanner.token) {\n+                case REQUIRES:\n+                    scanRequires(moduleAttribute.requires);\n+                    break;\n+                case EXPORTS:\n+                    scanStatement(moduleAttribute.exports,\n+                            this::parseTypeName,\n+                            this::parseModuleName,\n+                            Token.TO,\n+                            true,\n+                            \"exports.expected\");\n+                    break;\n+                case OPENS:\n+                    scanStatement(moduleAttribute.opens,\n+                            this::parseTypeName,\n+                            this::parseModuleName,\n+                            Token.TO, true, \"opens.expected\");\n+                    break;\n+                case USES:\n+                    scanStatement(moduleAttribute.uses, \"uses.expected\");\n+                    break;\n+                case PROVIDES:\n+                    scanStatement(moduleAttribute.provides,\n+                            this::parseTypeName,\n+                            this::parseTypeName,\n+                            Token.WITH,\n+                            false,\n+                            \"provides.expected\");\n+                    break;\n+                case SEMICOLON:\n+                    \/\/ Empty fields are allowed\n+                    scanner.scan();\n+                    break;\n+                default:\n+                    env.error(scanner.pos, \"module.statement.expected\");\n+                    throw new Scanner.SyntaxError().Fatal();\n+            }  \/\/ end switch\n+        } \/\/ while\n+        scanner.expect(Token.RBRACE);\n+        \/\/ End the module\n+        endModule();\n+    } \/\/ end parseModule\n+\n+    \/**\n+     * Scans  ModuleStatement: requires [transitive] [static] ModuleName ;\n+     *\/\n+    private void scanRequires(BiConsumer<String, Integer> action) throws IOException {\n+        int flags = 0;\n+        String mn = \"\";\n+        scanner.scanModuleStatement();\n+        while (scanner.token != SEMICOLON) {\n+            switch (scanner.token) {\n+                case STATIC:\n+                    if (((flags & (1 << Module.Modifier.ACC_STATIC_PHASE.asInt())) != 0) || !mn.isEmpty()) {\n+                        env.error(scanner.pos, \"requires.expected\");\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+                    flags |= Module.Modifier.ACC_STATIC_PHASE.asInt();\n+                    break;\n+                case TRANSITIVE:\n+                    if (((flags & (1 << Module.Modifier.ACC_TRANSITIVE.asInt())) != 0) || !mn.isEmpty()) {\n+                        env.error(scanner.pos, \"requires.expected\");\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+                    flags |= Module.Modifier.ACC_TRANSITIVE.asInt();\n+                    break;\n+                case IDENT:\n+                    if (!mn.isEmpty()) {\n+                        env.error(scanner.pos, \"requires.expected\");\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+                    mn = parseModuleName();\n+                    continue;\n+                default:\n+                    if (mn.isEmpty() && scanner.token.possibleModuleName()) {\n+                        mn = parseModuleName();\n+                        continue;\n+                    } else {\n+                        env.error(scanner.pos, \"requires.expected\");\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+            }\n+            scanner.scanModuleStatement();\n+        }\n+        \/\/ Token.SEMICOLON\n+        if (mn.isEmpty()) {\n+            env.error(scanner.pos, \"requires.expected\");\n+            throw new Scanner.SyntaxError().Fatal();\n+        }\n+        action.accept(mn, flags);\n+        scanner.scanModuleStatement();\n+    }\n+\n+    \/**\n+     * Scans  ModuleStatement: uses TypeName;\n+     *\/\n+    private void scanStatement(Consumer<Set<String>> action, String err) throws IOException {\n+        HashSet<String> names = scanList(() -> scanner.scan(), this::parseTypeName, err, true);\n+        \/\/ Token.SEMICOLON\n+        if (names.size() != 1) {\n+            env.error(scanner.pos, err);\n+            throw new Scanner.SyntaxError().Fatal();\n+        }\n+        action.accept(names);\n+        scanner.scan();\n+    }\n+\n+    \/**\n+     * Scans  Module Statement(s):\n+     * exports  packageName [to ModuleName {, ModuleName}] ;\n+     * opens    packageName [to ModuleName {, ModuleName}] ;\n+     * provides TypeName with TypeName [,typeName] ;\n+     *\/\n+    private void scanStatement(BiConsumer<String, Set<String>> action,\n+                               NameSupplier source,\n+                               NameSupplier target,\n+                               Token startList,\n+                               boolean emptyListAllowed,\n+                               String err) throws IOException {\n+        String typeName = \"\";\n+        HashSet<String> names = new HashSet<>();\n+        scanner.scan();\n+        while (scanner.token != SEMICOLON) {\n+            if (scanner.token == Token.IDENT) {\n+                if (typeName.isEmpty()) {\n+                    typeName = source.get();\n+                    continue;\n+                }\n+                env.error(scanner.pos, err);\n+                throw new Scanner.SyntaxError().Fatal();\n+            }\n+            if (scanner.token == startList) {\n+                if (typeName.isEmpty()) {\n+                    env.error(scanner.pos, err);\n+                    throw new Scanner.SyntaxError().Fatal();\n+                }\n+                names = scanList(scanner.token == Token.TO ? () -> scanner.scanModuleStatement() : () -> scanner.scan(), target, err, false);\n+                break;\n+            } else {\n+                env.error(scanner.pos, err);\n+                throw new Scanner.SyntaxError().Fatal();\n+            }\n+        }\n+        \/\/ Token.SEMICOLON\n+        if (typeName.isEmpty() || (names.isEmpty() && !emptyListAllowed)) {\n+            env.error(scanner.pos, err);\n+            throw new Scanner.SyntaxError().Fatal();\n+        }\n+        action.accept(typeName, names);\n+        scanner.scan();\n+    }\n+\n+    \/**\n+     * Scans the \"to\" or \"with\" part of ModuleStatement: exports PackageName  [to  ModuleName {, ModuleName}] ;,\n+     * opens  packageName   [to  ModuleName {, ModuleName}] ;\n+     * provides TypeName with TypeName [,typeName] ;\n+     * uses TypeName;\n+     * : [ModuleName {, ModuleName}]; , [TypeName [,typeName]]; or TypeName;\n+     *\/\n+    private HashSet<String> scanList(Method scanMethod, NameSupplier target, String err, boolean onlyOneElement) throws IOException {\n+        HashSet<String> names = new HashSet<>();\n+        boolean comma = false, first = true;\n+        scanMethod.call();\n+        while (scanner.token != SEMICOLON) {\n+            switch (scanner.token) {\n+                case COMMA:\n+                    if (comma || first || onlyOneElement) {\n+                        env.error(scanner.pos, err);\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+                    comma = true;\n+                    break;\n+                case IDENT:\n+                    if (!first && !comma) {\n+                        env.error(scanner.pos, err);\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+                    names.add(target.get());\n+                    comma = false;\n+                    first = false;\n+                    continue;\n+                default:\n+                    env.error(scanner.pos, err);\n+                    throw new Scanner.SyntaxError().Fatal();\n+            }\n+            scanner.scan();\n+        }\n+        \/\/ Token.SEMICOLON\n+        if (names.isEmpty() || comma) {\n+            env.error(scanner.pos, err);\n+            throw new Scanner.SyntaxError().Fatal();\n+        }\n+        return names;\n+    }\n+\n+    private void parseClassMembers() throws IOException {\n+        debugScan(\"[Parser.parseClassMembers]:  Begin \");\n+        \/\/ Parse annotations\n+        if (scanner.token == Token.ANNOTATION) {\n+            memberAnnttns = annotParser.scanAnnotations();\n+        }\n+        \/\/ Parse modifiers\n+        int mod = scanModifiers();\n+        try {\n+            switch (scanner.token) {\n+                case FIELDREF:\n+                    scanner.scan();\n+                    parseField(mod);\n+                    break;\n+                case METHODREF:\n+                    scanner.scan();\n+                    parseMethod(mod);\n+                    break;\n+                case INNERCLASS:\n+                    scanner.scan();\n+                    parseInnerClass(mod);\n+                    break;\n+                case BOOTSTRAPMETHOD:\n+                    scanner.scan();\n+                    parseCPXBootstrapMethod();\n+                    break;\n+                case NESTHOST:\n+                    if (cd.nestHostAttributeExists()) {\n+                        env.error(scanner.pos, \"extra.nesthost.attribute\");\n+                        throw new Scanner.SyntaxError();\n+                    } else if (cd.nestMembersAttributesExist()) {\n+                        env.error(scanner.pos, \"both.nesthost.nestmembers.found\");\n+                        throw new Scanner.SyntaxError();\n+                    }\n+                    scanner.scan();\n+                    parseNestHost();\n+                    break;\n+                case NESTMEMBERS:\n+                    if (cd.nestMembersAttributesExist()) {\n+                        env.error(scanner.pos, \"extra.nestmembers.attribute\");\n+                        throw new Scanner.SyntaxError();\n+                    } else if (cd.nestHostAttributeExists()) {\n+                        env.error(scanner.pos, \"both.nesthost.nestmembers.found\");\n+                        throw new Scanner.SyntaxError();\n+                    }\n+                    scanner.scan();\n+                    parseClasses(list -> cd.addNestMembers(list));\n+                    break;\n+                case PERMITTEDSUBCLASSES:         \/\/ JEP 360\n+                    if (cd.nestMembersAttributesExist()) {\n+                        env.error(scanner.pos, \"extra.permittedsubclasses.attribute\");\n+                        throw new Scanner.SyntaxError();\n+                    }\n+                    scanner.scan();\n+                    parseClasses(list -> cd.addPermittedSubclasses(list));\n+                    break;\n+                case RECORD:                    \/\/ JEP 359\n+                    if (cd.recordAttributeExists()) {\n+                        env.error(scanner.pos, \"extra.record.attribute\");\n+                        throw new Scanner.SyntaxError();\n+                    }\n+                    scanner.scan();\n+                    parseRecord();\n+                    break;\n+                default:\n+                    env.error(scanner.pos, \"field.expected\");\n+                    throw new Scanner.SyntaxError();\n+            }  \/\/ end switch\n+        } catch (Scanner.SyntaxError e) {\n+            recoverField();\n+        }\n+        memberAnnttns = null;\n+    }\n+\n+    \/**\n+     * Recover after a syntax error in the file.\n+     * This involves discarding scanner.tokens until an EOF\n+     * or a possible legal continuation is encountered.\n+     *\/\n+    private void recoverFile() throws IOException {\n+        while (true) {\n+            env.traceln(\"recoverFile: scanner.token=\" + scanner.token);\n+            switch (scanner.token) {\n+                case CLASS:\n+                case INTERFACE:\n+                    \/\/ Start of a new source file statement, continue\n+                    return;\n+\n+                case LBRACE:\n+                    match(Token.LBRACE, Token.RBRACE);\n+                    scanner.scan();\n+                    break;\n+\n+                case LPAREN:\n+                    match(Token.LPAREN, Token.RPAREN);\n+                    scanner.scan();\n+                    break;\n+\n+                case LSQBRACKET:\n+                    match(Token.LSQBRACKET, Token.RSQBRACKET);\n+                    scanner.scan();\n+                    break;\n+\n+                case EOF:\n+                    return;\n+\n+                default:\n+                    \/\/ Don't know what to do, skip\n+                    scanner.scan();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * End class\n+     *\/\n+    private void endClass() {\n+        if (explicitcp) {\n+            \/\/ Fix references in the constant pool (for explicitly coded CPs)\n+            pool.fixRefsInPool();\n+            \/\/ Fix any bootstrap Method references too\n+            cd.relinkBootstrapMethods();\n+        }\n+        cd.endClass();\n+        clsDataList.add(cd);\n+        cd = null;\n+    }\n+\n+    \/**\n+     * End module\n+     *\/\n+    private void endModule() {\n+        cd.endModule(moduleAttribute);\n+        clsDataList.add(cd);\n+        cd = null;\n+    }\n+\n+    final ClassData[] getClassesData() {\n+        return clsDataList.toArray(new ClassData[0]);\n+    }\n+\n+    \/**\n+     * Determines whether the JASM file is for a package-info class\n+     * or for a module-info class.\n+     * <p>\n+     * creates the correct kind of ClassData accordingly.\n+     *\n+     * @throws IOException\n+     *\/\n+    private void parseJasmPackages() throws IOException {\n+        try {\n+            \/\/ starting annotations could either be\n+            \/\/ a package annotation, or a class annotation\n+            if (scanner.token == Token.ANNOTATION) {\n+                if (cd == null) {\n+                    cd = new ClassData(env, currentCFV.clone());\n+                    pool = cd.pool;\n+                }\n+                pkgAnnttns = annotParser.scanAnnotations();\n+            }\n+            if (scanner.token == Token.PACKAGE) {\n+                \/\/ Package statement\n+                scanner.scan();\n+                int where = scanner.pos;\n+                String id = parseIdent();\n+                parseVersionPkg();\n+                scanner.expect(SEMICOLON);\n+\n+                if (pkg == null) {\n+                    pkg = id;\n+                    pkgPrefix = id + \"\/\";\n+                } else {\n+                    env.error(where, \"package.repeated\");\n+                }\n+                debugScan(\"[Parser.parseJasmPackages] {PARSED} package-prefix: \" + pkgPrefix + \" \");\n+            }\n+        } catch (Scanner.SyntaxError e) {\n+            recoverFile();\n+        }\n+        \/\/ skip bogus semi colons\n+        while (scanner.token == SEMICOLON) {\n+            scanner.scan();\n+        }\n+\n+        \/\/ checks that we compile module or package compilation unit\n+        if (scanner.token == Token.EOF) {\n+            env.traceln(\"Scanner:  EOF\");\n+            String sourceName = env.getSimpleInputFileName();\n+            int mod = ACC_INTERFACE | ACC_ABSTRACT;\n+\n+            \/\/ package-info\n+            if (sourceName.endsWith(\"package-info.jasm\")) {\n+                env.traceln(\"Creating \\\"package-info.jasm\\\": package: \" + pkg + \" \" + currentCFV.asString());\n+\n+                if (cd == null) {\n+                    cd = new ClassData(env, currentCFV.clone());\n+                    pool = cd.pool;\n+                } else {\n+                    cd.cfv = currentCFV.clone();\n+                }\n+                ConstCell me = pool.FindCellClassByName(pkgPrefix + \"package-info\");\n+\n+                \/\/ Interface package-info should be marked synthetic and abstract\n+                if (currentCFV.major_version() > 49) {\n+                    mod |= SYNTHETIC_ATTRIBUTE;\n+                }\n+                cd.init(mod, me, new ConstCell(0), null);\n+\n+                if (pkgAnnttns != null) {\n+                    cd.addAnnotations(pkgAnnttns);\n+                }\n+\n+                endClass();\n+            }\n+            return;\n+        }\n+\n+        if (pkg == null && pkgAnnttns != null) { \/\/ RemoveModules\n+            clsAnnttns = pkgAnnttns;\n+            pkgAnnttns = null;\n+        }\n+    }\n+\n+    \/**\n+     * Parse an Jasm file.\n+     *\/\n+    void parseFile() {\n+        try {\n+            \/\/ First, parse any package identifiers (and associated package annotations)\n+            parseJasmPackages();\n+\n+            while (scanner.token != Token.EOF) {\n+                \/\/ Second, parse any class identifiers (and associated class annotations)\n+                try {\n+                    \/\/ Parse annotations\n+                    if (scanner.token == Token.ANNOTATION) {\n+                        if (cd == null) {\n+                            cd = new ClassData(env, currentCFV.clone());\n+                            pool = cd.pool;\n+                        } else {\n+                            cd.cfv = currentCFV.clone();\n+                        }\n+                        clsAnnttns = annotParser.scanAnnotations();\n+                    }\n+\n+                    \/\/ Parse class modifiers\n+                    int mod = scanModifiers();\n+                    if (mod == 0) {\n+                        switch (scanner.token) {\n+                            case OPEN:\n+                            case MODULE:\n+                            case CLASS:\n+                            case CPINDEX:\n+                            case STRINGVAL:\n+                            case IDENT:\n+                                \/\/ this is a class declaration anyway\n+                                break;\n+                            case SEMICOLON:\n+                                \/\/ Bogus semi colon\n+                                scanner.scan();\n+                                continue;\n+                            default:\n+                                \/\/ no class declaration found\n+                                debugScan(\" [Parser.parseFile]: \");\n+                                env.error(scanner.pos, \"toplevel.expected\");\n+                                throw new Scanner.SyntaxError();\n+                        }\n+                    } else if (Modifiers.isInterface(mod) && (scanner.token != Token.CLASS)) {\n+                        \/\/ rare syntactic sugar:\n+                        \/\/ interface <ident> == abstract interface class <ident>\n+                        mod |= ACC_ABSTRACT;\n+                    }\n+                    if (scanner.token == Token.MODULE || scanner.token == Token.OPEN)\n+                        parseModule();\n+                    else\n+                        parseClass(mod);\n+                    clsAnnttns = null;\n+\n+                } catch (Scanner.SyntaxError e) {\n+                    \/\/ KTL\n+                    env.traceln(\"^^^^^^^ Syntax Error ^^^^^^^^^^^^\");\n+                    if (scanner.debugFlag)\n+                        e.printStackTrace();\n+                    if (e.isFatal()) {\n+                        break;\n+                    }\n+                    recoverFile();\n+                }\n+            }\n+        } catch (IOException e) {\n+            env.error(scanner.pos, \"io.exception\", env.getSimpleInputFileName());\n+        } catch (Error er) {\n+            er.printStackTrace();\n+        }\n+    } \/\/end parseFile\n+\n+    @FunctionalInterface\n+    interface NameSupplier {\n+        String get() throws IOException;\n+    }\n+\n+    @FunctionalInterface\n+    interface Method {\n+        void call() throws IOException;\n+    }\n+\n+    \/**\n+     * The main compile error for the parser\n+     *\/\n+    static class CompilerError extends Error {\n+\n+        CompilerError(String message) {\n+            super(message);\n+        }\n+    }\n+}  \/\/end Parser\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Parser.java","additions":2066,"deletions":0,"binary":false,"changes":2066,"status":"added"},{"patch":"@@ -0,0 +1,1085 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.jasm.TypeAnnotationTargetInfoData.*;\n+\n+import static org.openjdk.asmtools.jasm.JasmTokens.AnnotationType.isInvisibleAnnotationToken;\n+import static org.openjdk.asmtools.jasm.TypeAnnotationTypes.*;\n+import static org.openjdk.asmtools.jasm.JasmTokens.*;\n+import static org.openjdk.asmtools.jasm.ConstantPool.*;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.TreeMap;\n+\n+\/**\n+ * ParserAnnotation\n+ *\n+ * ParserAnnotation is a parser class owned by Parser.java. It is primarily responsible\n+ * for parsing Annotations (for classes, methods or fields).\n+ *\n+ * ParserAnnotation can parse the different types of Annotation Attributes:\n+ * Runtime(In)Visible Annotations (JDK 6+) Default Annotations (JDK 6+)\n+ * Runtime(In)VisibleParameter Annotations (JDK 7+) Runtime(In)VisibleType Annotations\n+ * (JSR308, JDK8+)\n+ *\/\n+public class ParserAnnotation extends ParseBase {\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Annotation Inner Classes *\/\n+    \/**\n+     * AnnotationElemValue\n+     *\n+     * Used to store Annotation values\n+     *\/\n+    static class AnnotationElemValue implements Data {\n+\n+        AnnotationData annotation;\n+\n+        AnnotationElemValue(AnnotationData annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte('@');\n+            annotation.write(out);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 1 + annotation.getLength();\n+        }\n+    }\n+\n+    \/**\n+     * ClassElemValue\n+     *\n+     * Annotation Element value referring to a class\n+     *\/\n+    static class ClassElemValue implements Data {\n+\n+        ConstCell indx;\n+\n+        ClassElemValue(ConstCell indx) {\n+            this.indx = indx;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte('c');\n+            indx.write(out);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 3;\n+        }\n+    }\n+\n+    \/**\n+     * ArrayElemValue\n+     *\n+     * Annotation Element value referring to an Array\n+     *\/\n+    static class ArrayElemValue implements Data {\n+\n+        ArrayList<Data> elemValues;\n+        int arrayLength = 0;\n+\n+        ArrayElemValue() {\n+            this.elemValues = new ArrayList<>();\n+        }\n+\n+        void add(Data elemValue) {\n+            elemValues.add(elemValue);\n+            arrayLength += elemValue.getLength();\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte('[');\n+            out.writeShort(elemValues.size());\n+\n+            for (Data eval : elemValues) {\n+                eval.write(out);\n+            }\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 3 + arrayLength;\n+        }\n+    }\n+\n+    \/**\n+     * ConstElemValue\n+     *\n+     * Annotation Element value referring to a Constant\n+     *\/\n+    static class ConstElemValue implements Data {\n+\n+        char tag;\n+        ConstCell indx;\n+\n+        ConstElemValue(char tag, ConstCell indx) {\n+            this.tag = tag;\n+            this.indx = indx;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte(tag);\n+            indx.write(out);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 3;\n+        }\n+    }\n+\n+    \/**\n+     * EnumElemValue\n+     *\n+     * Element Value for Enums\n+     *\/\n+    static class EnumElemValue implements Data {\n+\n+        ConstCell type;\n+        ConstCell value;\n+\n+        EnumElemValue(ConstCell type, ConstCell value) {\n+            this.type = type;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte('e');\n+            type.write(out);\n+            value.write(out);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 5;\n+        }\n+    }\n+\n+    \/**\n+     * local handles on the scanner, main parser, and the error reporting env\n+     *\/\n+    private static TTVis ttVisitor;\n+\n+    protected ParserAnnotation(Scanner scanner, Parser parser, Environment env) {\n+        super.init(scanner, parser, env);\n+        ttVisitor = new TTVis();\n+        ttVisitor.init(env, scanner);\n+    }\n+\n+    protected void scanParamName(int totalParams, int paramNum, MethodData curMethod) throws IOException {\n+        debugScan(\" - - - > [ParserAnnotation.scanParamName]: Begin \");\n+        scanner.scan();\n+        scanner.expect(Token.LBRACE);\n+        \/\/ First scan the Name (String, or CPX to name)\n+        ConstCell nameCell;\n+        if ((scanner.token == Token.IDENT) || scanner.checkTokenIdent()) {\n+            \/\/ Got a Class Name\n+            nameCell = parser.parseName();\n+        } else if (scanner.token == Token.CPINDEX) {\n+            int cpx = scanner.intValue;\n+            nameCell = parser.pool.getCell(cpx);\n+            \/\/ check the constant\n+            ConstValue nameCellValue = nameCell.ref;\n+            if (!(nameCellValue instanceof ConstValue_String)) {\n+                \/\/ throw an error\n+                env.error(scanner.pos, \"paramname.constnum.invaltype\", cpx);\n+                throw new Scanner.SyntaxError();\n+            }\n+\n+        } else {\n+            \/\/ throw scan error - unexpected token\n+            env.error(scanner.pos, \"paramname.token.unexpected\", scanner.stringValue);\n+            throw new Scanner.SyntaxError();\n+        }\n+\n+        \/\/ Got the name cell. Next, scan the access flags\n+        int mod = parser.scanModifiers();\n+\n+        scanner.expect(Token.RBRACE);\n+\n+        curMethod.addMethodParameter(totalParams, paramNum, nameCell, mod);\n+\n+        debugScan(\" - - - > [ParserAnnotation.scanParamName]: End \");\n+    }\n+\n+    \/**\n+     * The main entry for parsing an annotation list.\n+     *\n+     * @return An ArrayList of parsed annotations\n+     * @throws IOException\n+     *\/\n+    ArrayList<AnnotationData> scanAnnotations() throws IOException {\n+        ArrayList<AnnotationData> list = new ArrayList<>();\n+        while (scanner.token == Token.ANNOTATION) {\n+            if ( JasmTokens.AnnotationType.isAnnotationToken(scanner.stringValue)) {\n+                list.add(parseAnnotation());\n+            } else if (JasmTokens.AnnotationType.isTypeAnnotationToken(scanner.stringValue)) {\n+                list.add(parseTypeAnnotation());\n+            } else {\n+                return null;\n+            }\n+        }\n+        if (list.size() > 0) {\n+            return list;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * parseDefaultAnnotation\n+     *\n+     * parses a default Annotation attribute\n+     *\n+     * @return the parsed Annotation Attribute\n+     * @throws org.openjdk.asmtools.jasm.Scanner.SyntaxError\n+     * @throws IOException\n+     *\/\n+    protected DefaultAnnotationAttr parseDefaultAnnotation() throws Scanner.SyntaxError, IOException {\n+        scanner.scan();\n+        DefaultAnnotationAttr attr = null;\n+        Data value = null;\n+        scanner.expect(Token.LBRACE);\n+\n+        if ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+            value = scanAnnotationData(\"default\");\n+        }\n+        scanner.expect(Token.RBRACE);\n+        attr = new DefaultAnnotationAttr(parser.cd,\n+                AttrTag.ATT_AnnotationDefault.parsekey(),\n+                value);\n+        return attr;\n+    }\n+\n+    \/**\n+     * parseParamAnnots\n+     *\n+     * Parses Parameter Annotations attributes.\n+     *\n+     * @param _totalParams\n+     * @param curMethod\n+     * @throws org.openjdk.asmtools.jasm.Scanner.SyntaxError\n+     * @throws IOException\n+     *\/\n+    protected void parseParamAnnots(int _totalParams, MethodData curMethod) throws Scanner.SyntaxError, IOException {\n+        debugScan(\" - - - > [ParserAnnotation.parseParamAnnots]: Begin, totalParams =  \" + _totalParams + \" \");\n+        \/\/ The _method thinks there are N+1 params in the signature\n+        \/\/ (N = total params in the call list) + 1 (return value)\n+        int totalParams = _totalParams - 1;\n+        TreeMap<Integer, ArrayList<AnnotationData>> pAnnots = new TreeMap<>();\n+\n+        while (scanner.token == Token.INTVAL) {\n+            \/\/ Create the Parameter Array for  Param Annotations\n+\n+            \/\/ Do something with Parameter annotations\n+            \/\/ --------------------\n+            \/\/ First - validate that the parameter number (integer)\n+            \/\/ (eg >= 0, < numParams, and param num is not previously set)\n+            int paramNum = scanner.intValue;\n+            Integer iParamNum = Integer.valueOf(paramNum);\n+            if (paramNum < 0 || paramNum >= totalParams) {\n+                \/\/invalid Parameter number.  Throw an error.\n+                env.error(scanner.pos, \"invalid.paramnum\", paramNum);\n+            }\n+            if (pAnnots.get(iParamNum) != null) {\n+                \/\/ paramter is already populated with annotations\/pnames, Throw an error.\n+                env.error(scanner.pos, \"duplicate.paramnum\", paramNum);\n+            }\n+            \/\/ 2nd - Parse the COLON (invalid if not present)\n+            scanner.scan();\n+            scanner.expect(Token.COLON);\n+\n+            \/\/ 3rd - parse either an optional ParamName, or a list of annotations\n+            if (scanner.token == Token.PARAM_NAME) {\n+                \/\/parse the ParamName\n+                scanParamName(totalParams, iParamNum, curMethod);\n+            }\n+\n+            \/\/ 4th - parse each Annotation (followed by comma, followed by annotation\n+            \/\/       assign array of annotations to param array\n+            if (scanner.token == Token.ANNOTATION) {\n+                ArrayList<AnnotationData> pAnnot = scanAnnotations();\n+                pAnnots.put(iParamNum, pAnnot);\n+\n+                for (AnnotationData data : pAnnot) {\n+                    curMethod.addParamAnnotation(totalParams, paramNum, data);\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    \/* ************************* Private Members  *************************** *\/\n+    \/**\n+     * parseTypeAnnotation\n+     *\n+     * parses an individual annotation.\n+     *\n+     * @return a parsed annotation.\n+     * @throws IOException\n+     *\/\n+    private AnnotationData parseTypeAnnotation() throws Scanner.SyntaxError, IOException {\n+        boolean invisible = isInvisibleAnnotationToken(scanner.stringValue);\n+        scanner.scan();\n+        debugScan(\"     [ParserAnnotation.parseTypeAnnotation]: id = \" + scanner.stringValue + \" \");\n+        String annoName = \"L\" + scanner.stringValue + \";\";\n+        TypeAnnotationData anno = new TypeAnnotationData(parser.pool.FindCellAsciz(annoName), invisible);\n+        scanner.scan();\n+        debugScan(\"     [ParserAnnotation.parseTypeAnnotation]:new type annotation: \" + annoName + \" \");\n+\n+        scanner.expect(Token.LBRACE);\n+\n+        \/\/ Scan the usual annotation data\n+        _scanAnnotation(anno);\n+\n+        \/\/ scan the Target (u1: target_type, union{...}: target_info)\n+        _scanTypeTarget(anno);\n+\n+        if( scanner.token != Token.RBRACE ) {\n+            \/\/ scan the Location (type_path: target_path)\n+            _scanTargetPath(anno);\n+        }\n+\n+        scanner.expect(Token.RBRACE);\n+        return anno;\n+    }\n+\n+    \/**\n+     * scanAnnotation\n+     *\n+     * parses an individual annotation.\n+     *\n+     * @return a parsed annotation.\n+     * @throws IOException\n+     *\/\n+    private AnnotationData parseAnnotation() throws Scanner.SyntaxError, IOException {\n+        debugScan(\" - - - > [ParserAnnotation.parseAnnotation]: Begin \");\n+        boolean invisible = isInvisibleAnnotationToken(scanner.stringValue);\n+        scanner.scan();\n+        String annoName = \"L\" + scanner.stringValue + \";\";\n+\n+        AnnotationData anno = new AnnotationData(parser.pool.FindCellAsciz(annoName), invisible);\n+        scanner.scan();\n+        debugScan(\"[ParserAnnotation.parseAnnotation]: new annotation: \" + annoName);\n+        _scanAnnotation(anno);\n+\n+        return anno;\n+    }\n+\n+    \/**\n+     * _scanAnnotation\n+     *\n+     * parses an individual annotation-data.\n+     *\n+     * @return a parsed annotation.\n+     * @throws IOException\n+     *\/\n+    private void _scanAnnotation(AnnotationData annotData) throws Scanner.SyntaxError, IOException {\n+        debugScan(\" - - - > [ParserAnnotation._scanAnnotation]: Begin\");\n+        scanner.expect(Token.LBRACE);\n+\n+        while ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+            ConstCell nameCell = parser.parseName();\n+            scanner.expect(Token.ASSIGN);\n+\n+            ConstValue cellref = nameCell.ref;\n+            if (cellref.tag != ConstType.CONSTANT_UTF8) {\n+                throw new Scanner.SyntaxError();\n+            }\n+            String name = ((ConstValue_String) cellref)._toString();\n+            debugScan(\"     [ParserAnnotation._scanAnnotation]: Annot - Field Name: \" + name);\n+            Data data = scanAnnotationData(name);\n+            annotData.add(new AnnotationData.ElemValuePair(nameCell, data));\n+\n+            \/\/ consume tokens inbetween annotation fields\n+            if (scanner.token == Token.COMMA) {\n+                scanner.scan();\n+            }\n+        }\n+        scanner.expect(Token.RBRACE);\n+    }\n+\n+    \/**\n+     * _scanAnnotation\n+     *\n+     * parses an individual annotation-data.\n+     *\n+     * @return a parsed annotation.\n+     * @throws IOException\n+     *\/\n+    private void _scanTypeTarget(TypeAnnotationData annotData) throws Scanner.SyntaxError, IOException {\n+        debugScan(\"     [ParserAnnotation._scanTypeTarget]: Begin \");\n+        scanner.expect(Token.LBRACE);\n+\n+        \/\/Scan the target_type and the target_info\n+        scanner.expect(Token.IDENT);\n+        debugScan(\"     [ParserAnnotation._scanTypeTarget]: TargetType: \" + scanner.idValue);\n+        ETargetType targetType = ETargetType.getTargetType(scanner.idValue);\n+        if (targetType == null) {\n+            env.error(scanner.pos, \"incorrect.typeannot.target\", scanner.idValue);\n+            throw new Scanner.SyntaxError();\n+        }\n+\n+        debugScan(\"     [ParserAnnotation._scanTypeTarget]: Got TargetType: \" + targetType);\n+\n+        if (ttVisitor.scanner == null) {\n+            ttVisitor.scanner = scanner;\n+        }\n+        ttVisitor.visitExcept(targetType);\n+\n+        annotData.targetInfo = ttVisitor.getTargetInfo();\n+        annotData.targetType = targetType;\n+        debugScan(\"     [ParserAnnotation._scanTypeTarget]: Got TargetInfo: \" + annotData.targetInfo);\n+\n+        scanner.expect(Token.RBRACE);\n+    }\n+\n+    \/**\n+     * TTVis\n+     *\n+     * Target Type visitor, used for constructing the target-info within a type\n+     * annotation. visitExcept() is the entry point. ti is the constructed target info.\n+     *\/\n+    private static class TTVis extends TypeAnnotationTypes.TypeAnnotationTargetVisitor {\n+\n+        private TypeAnnotationTargetInfoData ti;\n+        private IOException IOProb;\n+        private Scanner.SyntaxError SyProb;\n+        private Scanner scanner;\n+        private Environment env;\n+\n+        public TTVis() {\n+            super();\n+            reset();\n+        }\n+\n+        public void init(Environment en, Scanner scn) {\n+            if (scanner == null) {\n+                scanner = scn;\n+            }\n+            if (env == null) {\n+                env = en;\n+            }\n+        }\n+\n+        public final void reset() {\n+            ti = null;\n+            IOProb = null;\n+            SyProb = null;\n+        }\n+\n+        \/\/This is the entry point for a visitor that tunnels exceptions\n+        public void visitExcept(ETargetType tt) throws IOException, Scanner.SyntaxError {\n+            IOProb = null;\n+            SyProb = null;\n+            ti = null;\n+\n+            visit(tt);\n+\n+            if (IOProb != null) {\n+                throw IOProb;\n+            }\n+\n+            if (SyProb != null) {\n+                throw SyProb;\n+            }\n+        }\n+\n+        public TypeAnnotationTargetInfoData getTargetInfo() {\n+            return ti;\n+        }\n+\n+        \/\/ this fn gathers intvals, and tunnels any exceptions thrown by\n+        \/\/ the scanner\n+        private int scanIntVal(ETargetType tt) {\n+            int ret = -1;\n+            if (scanner.token == Token.INTVAL) {\n+                ret = scanner.intValue;\n+                try {\n+                    scanner.scan();\n+                } catch (IOException e) {\n+                    IOProb = e;\n+                } catch (Scanner.SyntaxError e) {\n+                    SyProb = e;\n+                }\n+            } else {\n+                env.error(scanner.pos, \"incorrect.typeannot.targtype.int\", tt.parseKey(), scanner.token);\n+                SyProb = new Scanner.SyntaxError();\n+            }\n+            return ret;\n+        }\n+\n+        \/\/ this fn gathers intvals, and tunnels any exceptions thrown by\n+        \/\/ the scanner\n+        private String scanStringVal(ETargetType tt) {\n+            String ret = \"\";\n+            if (scanner.token == Token.STRINGVAL) {\n+                ret = scanner.stringValue;\n+                try {\n+                    scanner.scan();\n+                } catch (IOException e) {\n+                    IOProb = e;\n+                } catch (Scanner.SyntaxError e) {\n+                    SyProb = e;\n+                }\n+            } else {\n+                env.error(scanner.pos, \"incorrect.typeannot.targtype.string\", tt.parseKey(), scanner.token);\n+                SyProb = new Scanner.SyntaxError();\n+            }\n+            return ret;\n+        }\n+\n+        \/\/ this fn gathers intvals, and tunnels any exceptions thrown by\n+        \/\/ the scanner\n+        private void scanBrace(boolean left) {\n+            try {\n+                scanner.expect(left ? Token.LBRACE : Token.RBRACE);\n+            } catch (IOException e) {\n+                IOProb = e;\n+            } catch (Scanner.SyntaxError e) {\n+                SyProb = e;\n+            }\n+        }\n+\n+        private boolean error() {\n+            return IOProb != null || SyProb != null;\n+        }\n+\n+        @Override\n+        public void visit_type_param_target(ETargetType tt) {\n+            env.traceln(\"Type Param Target: \");\n+            int byteval = scanIntVal(tt); \/\/ param index\n+            if (!error()) {\n+                ti = new TypeAnnotationTargetInfoData.type_parameter_target(tt, byteval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_supertype_target(ETargetType tt) {\n+            env.traceln(\"SuperType Target: \");\n+            int shortval = scanIntVal(tt); \/\/ type index\n+            if (!error()) {\n+                ti = new TypeAnnotationTargetInfoData.supertype_target(tt, shortval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_typeparam_bound_target(ETargetType tt) {\n+            env.traceln(\"TypeParam Bound Target: \");\n+            int byteval1 = scanIntVal(tt); \/\/ param index\n+            if (error()) {\n+                return;\n+            }\n+            int byteval2 = scanIntVal(tt); \/\/ bound index\n+            if (error()) {\n+                return;\n+            }\n+            ti = new TypeAnnotationTargetInfoData.type_parameter_bound_target(tt, byteval1, byteval2);\n+        }\n+\n+        @Override\n+        public void visit_empty_target(ETargetType tt) {\n+            env.traceln(\"Empty Target: \");\n+            if (!error()) {\n+                ti = new TypeAnnotationTargetInfoData.empty_target(tt);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_methodformalparam_target(ETargetType tt) {\n+            env.traceln(\"MethodParam Target: \");\n+            int byteval = scanIntVal(tt); \/\/ param index\n+            if (!error()) {\n+                ti = new formal_parameter_target(tt, byteval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_throws_target(ETargetType tt) {\n+            env.traceln(\"Throws Target: \");\n+            int shortval = scanIntVal(tt); \/\/ exception index\n+            if (!error()) {\n+                ti = new throws_target(tt, shortval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_localvar_target(ETargetType tt) {\n+            env.traceln(\"LocalVar Target: \");\n+            localvar_target locvartab = new localvar_target(tt, 0);\n+            ti = locvartab;\n+\n+            while ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+                \/\/ consume the left brace\n+                scanBrace(true);\n+                if (error()) {\n+                    return;\n+                }\n+                \/\/ scan the local var triple\n+                int shortval1 = scanIntVal(tt); \/\/ startPC\n+                if (error()) {\n+                    return;\n+                }\n+                int shortval2 = scanIntVal(tt); \/\/ length\n+                if (error()) {\n+                    return;\n+                }\n+                int shortval3 = scanIntVal(tt); \/\/ CPX\n+                locvartab.addEntry(shortval1, shortval2, shortval3);\n+                scanBrace(false);\n+                if (error()) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visit_catch_target(ETargetType tt) {\n+            env.traceln(\"Catch Target: \");\n+            int shortval = scanIntVal(tt); \/\/ catch index\n+\n+            ti = new catch_target(tt, shortval);\n+        }\n+\n+        @Override\n+        public void visit_offset_target(ETargetType tt) {\n+            env.traceln(\"Offset Target: \");\n+            int shortval = scanIntVal(tt); \/\/ offset index\n+            if (!error()) {\n+                ti = new offset_target(tt, shortval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_typearg_target(ETargetType tt) {\n+            env.traceln(\"TypeArg Target: \");\n+            int shortval = scanIntVal(tt); \/\/ offset\n+            if (error()) {\n+                return;\n+            }\n+            int byteval = scanIntVal(tt); \/\/ type index\n+            if (error()) {\n+                return;\n+            }\n+            ti = new type_argument_target(tt, shortval, byteval);\n+        }\n+\n+    }\n+\n+    \/**\n+     * _scanTargetPath\n+     *\n+     * parses and fills the type_path structure (4.7.20.2)\n+     *\n+     * type_path {\n+     *     u1 path_length;\n+     *     {   u1 type_path_kind;\n+     *         u1 type_argument_index;\n+     *     } path[path_length];\n+     * }\n+     *\n+     * @throws Scanner.SyntaxError, IOException\n+     *\/\n+    private void _scanTargetPath(TypeAnnotationData annotData) throws Scanner.SyntaxError, IOException {\n+        \/\/ parse the location info\n+        scanner.expect(Token.LBRACE);\n+\n+        while ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+            TypePathEntry tpe = _scanTypePathEntry();\n+            annotData.addTypePathEntry(tpe);\n+            \/\/ throw away comma\n+            if (scanner.token == Token.COMMA) {\n+                scanner.scan();\n+            }\n+        }\n+\n+        scanner.expect(Token.RBRACE);\n+    }\n+\n+    \/**\n+     * _scanTypeLocation\n+     *\n+     * parses a path entry of the type_path.\n+     *\n+     * {   u1 type_path_kind;\n+     *     u1 type_argument_index;\n+     * }\n+     *\n+     * @return a parsed type path.\n+     * @throws Scanner.SyntaxError, IOException\n+     *\/\n+    private TypePathEntry _scanTypePathEntry() throws Scanner.SyntaxError, IOException {\n+        TypePathEntry tpe;\n+\n+        if ( (scanner.token != Token.EOF) && scanner.token.possibleTypePathKind() ) {\n+            EPathKind pathKind = EPathKind.getPathKind(scanner.stringValue);\n+            if (pathKind == EPathKind.TYPE_ARGUMENT) {\n+                scanner.scan();\n+                \/\/ need to scan the index\n+                \/\/ Take the form:  TYPE_ARGUMENT{#}\n+                scanner.expect(Token.LBRACE);\n+                int index = 0;\n+                if ((scanner.token != Token.EOF) && (scanner.token == Token.INTVAL)) {\n+                    index = scanner.intValue;\n+                    scanner.scan();\n+                } else {\n+                    \/\/ incorrect Arg index\n+                    env.error(scanner.pos, \"incorrect.typeannot.pathentry.argindex\", scanner.token);\n+                    throw new Scanner.SyntaxError();\n+                }\n+                tpe = new TypePathEntry(pathKind, index);\n+                scanner.expect(Token.RBRACE);\n+            } else {\n+                tpe = new TypePathEntry(pathKind, 0);\n+                scanner.scan();\n+            }\n+        } else {\n+            \/\/ unexpected Type Path\n+            env.error(scanner.pos, \"incorrect.typeannot.pathentry\", scanner.token);\n+            throw new Scanner.SyntaxError();\n+        }\n+\n+        return tpe;\n+    }\n+\n+    \/**\n+     * scanAnnotationArray\n+     *\n+     * Scans an Array of annotations.\n+     *\n+     * @param name Name of the annotation\n+     * @return Array Element\n+     * @throws IOException if scanning errors exist\n+     *\/\n+    private ArrayElemValue scanAnnotationArray(String name) throws IOException {\n+        scanner.scan();\n+        ArrayElemValue arrayElem = new ArrayElemValue();\n+\n+        while ((scanner.token != Token.EOF) && (scanner.token != Token.RBRACE)) {\n+            Data data = scanAnnotationData(name + \" {}\");\n+            arrayElem.add(data);\n+\n+            \/\/ consume tokens inbetween annotation fields\n+            if (scanner.token == Token.COMMA) {\n+                scanner.scan();\n+            }\n+        }\n+\n+        scanner.expect(Token.RBRACE);\n+        return arrayElem;\n+    }\n+\n+    \/**\n+     * scanAnnotationEnum\n+     *\n+     * Scans an annotation enum val.\n+     *\n+     * @param name Annotation Name\n+     * @return Constant element value for the Class Annotation.\n+     * @throws IOException\n+     *\/\n+    private Data scanAnnotationClass(String name) throws IOException {\n+        Data constVal = null;\n+        \/\/ scan the next identifier.\n+        \/\/ if it is an Ident, consume it as the class name.\n+        scanner.scan();\n+        switch (scanner.token) {\n+            case IDENT:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Constant Class Field: \" + name + \" = \" + scanner.stringValue);\n+                \/\/need to encode the stringval as an (internal) descriptor.\n+                String desc = parser.encodeClassString(scanner.stringValue);\n+\n+                \/\/ note: for annotations, a class field points to a string with the class descriptor.\n+                constVal = new ConstElemValue('c', parser.pool.FindCellAsciz(desc));\n+                scanner.scan();\n+                break;\n+            case CPINDEX:\n+                \/\/ could be a reference to a class name\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Constant Class Field: \" + name + \" = \" + scanner.stringValue);\n+                Integer ConstNmCPX = Integer.valueOf(scanner.stringValue);\n+                constVal = new ClassElemValue(parser.pool.getCell(ConstNmCPX));\n+                scanner.scan();\n+                break;\n+            default:\n+                env.error(scanner.pos, \"incorrect.annot.class\", scanner.stringValue);\n+                throw new Scanner.SyntaxError();\n+        }\n+\n+        return constVal;\n+    }\n+\n+    \/**\n+     * scanAnnotationEnum\n+     *\n+     * Scans an annotation enum val.\n+     *\n+     * @param name Annotation Name\n+     * @return Enumeration Element Value\n+     * @throws IOException for scanning errors.\n+     *\/\n+    private EnumElemValue scanAnnotationEnum(String name) throws IOException {\n+        scanner.scan();\n+        EnumElemValue enumval = null;\n+        switch (scanner.token) {\n+            case IDENT:\n+                \/\/ could be a string identifying enum class and name\n+                String enumClassName = scanner.stringValue;\n+                scanner.scan();\n+                \/\/ could be a string identifying enum class and name\n+                switch (scanner.token) {\n+                    case IDENT:\n+                        \/\/ could be a string identifying enum class and name\n+                        String enumTypeName = scanner.stringValue;\n+                        env.traceln(\"[AnnotationParser.scanAnnotationEnum]:: Constant Enum Field: \" + name + \" = \" + enumClassName + \" \" + enumTypeName);\n+                        String encodedClass = parser.encodeClassString(enumClassName);\n+                        ConstElemValue classConst = new ConstElemValue('s', parser.pool.FindCellAsciz(encodedClass));\n+                        ConstElemValue typeConst = new ConstElemValue('s', parser.pool.FindCellAsciz(enumTypeName));\n+                        enumval = new EnumElemValue(classConst.indx, typeConst.indx);\n+                        scanner.scan();\n+                        break;\n+\n+                    default:\n+                        env.error(scanner.pos, \"incorrect.annot.enum\", scanner.stringValue);\n+                        throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            case CPINDEX:\n+                Integer typeNmCPX = Integer.valueOf(scanner.stringValue);\n+                scanner.scan();\n+                \/\/need two indexes to form a proper enum\n+                switch (scanner.token) {\n+                    case CPINDEX:\n+                        Integer ConstNmCPX = Integer.valueOf(scanner.stringValue);\n+                        env.traceln(\"[AnnotationParser.scanAnnotationEnum]:: Enumeration Field: \" + name + \" = #\" + typeNmCPX + \" #\" + ConstNmCPX);\n+                        enumval = new EnumElemValue(parser.pool.getCell(typeNmCPX), parser.pool.getCell(ConstNmCPX));\n+                        scanner.scan();\n+                        break;\n+                    default:\n+                        env.error(scanner.pos, \"incorrect.annot.enum.cpx\");\n+                        throw new Scanner.SyntaxError();\n+                }\n+                break;\n+        }\n+\n+        return enumval;\n+    }\n+\n+    \/**\n+     * scanAnnotationData\n+     *\n+     * parses the internals of an annotation.\n+     *\n+     * @param name Annotation Name\n+     * @return a Data data structure containing the annotation data.\n+     * @throws IOException for scanning errors.\n+     *\/\n+    private Data scanAnnotationData(String name) throws IOException {\n+        Data data = null;\n+        switch (scanner.token) {\n+            \/\/ This handles the Annotation types (as normalized in the constant pool)\n+            \/\/ Some primitive types (Boolean, char, short, byte) are identified by a keyword.\n+            case INTVAL:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Integer Field: \" + name + \" = \" + scanner.intValue);\n+                data = new ConstElemValue('I', parser.pool.FindCell(ConstType.CONSTANT_INTEGER, scanner.intValue));\n+                scanner.scan();\n+                break;\n+            case DOUBLEVAL:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Double Field: \" + name + \" = \" + scanner.doubleValue);\n+                double dval = scanner.doubleValue;\n+                long ivdal = Double.doubleToLongBits(dval);\n+                Long val = ivdal;\n+                data = new ConstElemValue('D', parser.pool.FindCell(ConstType.CONSTANT_DOUBLE, val));\n+                scanner.scan();\n+                break;\n+            case FLOATVAL:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Float Field: \" + name + \" = \" + scanner.floatValue);\n+                float fval = scanner.floatValue;\n+                int ifval = Float.floatToIntBits(fval);\n+                Integer val1 = ifval;\n+                data = new ConstElemValue('F', parser.pool.FindCell(ConstType.CONSTANT_FLOAT, val1));\n+                scanner.scan();\n+                break;\n+            case LONGVAL:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Long Field: \" + name + \" = \" + scanner.longValue);\n+                data = new ConstElemValue('J', parser.pool.FindCell(ConstType.CONSTANT_LONG, scanner.longValue));\n+                scanner.scan();\n+                break;\n+            case STRINGVAL:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: String Field: \" + name + \" = \" + scanner.stringValue);\n+                data = new ConstElemValue('s', parser.pool.FindCellAsciz(scanner.stringValue));\n+                scanner.scan();\n+                break;\n+            case CLASS:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Class) keyword: \" + scanner.stringValue);\n+                data = scanAnnotationClass(name);\n+                break;\n+            case ENUM:\n+                \/\/ scan the next two identifiers (eg ident.ident), or 2 CPRefs.\n+                \/\/ if it is an Ident, use consume it as the class name.\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Enum) keyword: \" + scanner.stringValue);\n+                data = scanAnnotationEnum(name);\n+                break;\n+            case IDENT:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: JASM Keyword: (annotation field name: \" + name + \") keyword: \" + scanner.stringValue);\n+                data = scanAnnotationIdent(scanner.stringValue, name);\n+                break;\n+            case ANNOTATION:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Annotation Field: \" + name + \" = \" + scanner.stringValue);\n+                data = new AnnotationElemValue(parseAnnotation());\n+                break;\n+            case LBRACE:\n+                env.traceln(\"[AnnotationParser.scanAnnotationData]:: Annotation Array Field: \" + name);\n+                data = scanAnnotationArray(name);\n+                break;\n+            default:\n+                env.error(scanner.pos, \"incorrect.annot.token\", scanner.token);\n+                throw new Scanner.SyntaxError();\n+        }\n+\n+        return data;\n+    }\n+\n+    \/**\n+     * scanAnnotationIdent\n+     *\n+     * parses the identifier of an annotation.\n+     *\n+     * @param ident Basic Type identifier\n+     * @param name Annotation Name\n+     * @return Basic Type Annotation data\n+     * @throws IOException if scanning errors occur\n+     *\/\n+    private Data scanAnnotationIdent(String ident, String name) throws IOException {\n+        \/\/ Handle JASM annotation Keyword Identifiers\n+        Data data;\n+        BasicType type = basictype(ident);\n+        switch (type) {\n+\n+            case T_BOOLEAN:\n+                \/\/ consume the keyword, get the value\n+                scanner.scan();\n+                switch (scanner.token) {\n+                    case INTVAL:\n+                        \/\/ Handle Boolean value in integer form\n+                        env.traceln(\"Boolean Field: \" + name + \" = \" + scanner.intValue);\n+                        Integer val = scanner.intValue;\n+                        if (val > 1 || val < 0) {\n+                            env.traceln(\"Warning: Boolean Field: \" + name + \" value is not 0 or 1, value = \" + scanner.intValue);\n+                        }\n+                        data = new ConstElemValue('Z', parser.pool.FindCell(ConstType.CONSTANT_INTEGER, val));\n+                        scanner.scan();\n+                        break;\n+                    case IDENT:\n+                        \/\/ handle boolean value with true\/false keywords\n+                        int val1;\n+                        switch (scanner.stringValue) {\n+                            case \"true\":\n+                                val1 = 1;\n+                                break;\n+                            case \"false\":\n+                                val1 = 0;\n+                                break;\n+                            default:\n+                                throw new IOException(\"Incorrect Annotation (boolean), expected true\/false), got \\\"\" + scanner.stringValue + \"\\\".\");\n+                        }\n+                        env.traceln(\"Boolean Field: \" + name + \" = \" + scanner.stringValue);\n+                        data = new ConstElemValue('Z', parser.pool.FindCell(ConstType.CONSTANT_INTEGER, val1));\n+                        scanner.scan();\n+                        break;\n+                    default:\n+                        env.error(scanner.pos, \"incorrect.annot.bool\", scanner.stringValue);\n+                        throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            case T_BYTE:\n+                \/\/ consume the keyword, get the value\n+                scanner.scan();\n+                switch (scanner.token) {\n+                    case INTVAL:\n+                        env.traceln(\"Byte Field: \" + name + \" = \" + scanner.intValue);\n+                        Integer val = scanner.intValue;\n+                        if (val > 0xFF) {\n+                            env.traceln(\"Warning: Byte Field: \" + name + \" value is greater than 0xFF, value = \" + scanner.intValue);\n+                        }\n+                        data = new ConstElemValue('B', parser.pool.FindCell(ConstType.CONSTANT_INTEGER, val));\n+                        scanner.scan();\n+                        break;\n+                    default:\n+                        env.error(scanner.pos, \"incorrect.annot.byte\", scanner.stringValue);\n+                        throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            case T_CHAR:\n+                \/\/ consume the keyword, get the value\n+                scanner.scan();\n+                switch (scanner.token) {\n+                    case INTVAL:\n+                        env.traceln(\"Char Field: \" + name + \" = \" + scanner.intValue);\n+                        Integer val = scanner.intValue;\n+                        \/\/ Bounds check?\n+                        data = new ConstElemValue('C', parser.pool.FindCell(ConstType.CONSTANT_INTEGER, val));\n+                        scanner.scan();\n+                        break;\n+                    default:\n+                        env.error(scanner.pos, \"incorrect.annot.char\", scanner.stringValue);\n+                        throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            case T_SHORT:\n+                \/\/ consume the keyword, get the value\n+                scanner.scan();\n+                switch (scanner.token) {\n+                    case INTVAL:\n+                        env.traceln(\"Short Field: \" + name + \" = \" + scanner.intValue);\n+                        Integer val = scanner.intValue;\n+                        if (val > 0xFFFF) {\n+                            env.traceln(\"Warning: Short Field: \" + name + \" value is greater than 0xFFFF, value = \" + scanner.intValue);\n+                        }\n+                        data = new ConstElemValue('S', parser.pool.FindCell(ConstType.CONSTANT_INTEGER, val));\n+                        scanner.scan();\n+                        break;\n+                    default:\n+                        env.error(scanner.pos, \"incorrect.annot.short\", scanner.stringValue);\n+                        throw new Scanner.SyntaxError();\n+                }\n+                break;\n+            default:\n+                env.error(scanner.pos, \"incorrect.annot.keyword\", ident);\n+                throw new Scanner.SyntaxError();\n+        }\n+        return data;\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ParserAnnotation.java","additions":1085,"deletions":0,"binary":false,"changes":1085,"status":"added"},{"patch":"@@ -0,0 +1,665 @@\n+\/*\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.function.BiFunction;\n+\n+import static org.openjdk.asmtools.jasm.JasmTokens.Token;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+\n+\/**\n+ * ParserCP\n+ *\n+ * ParseCP is a parser class owned by Parser.java. It is primarily responsible for parsing\n+ * the constant pool and constant declarations.\n+ *\/\n+public class ParserCP extends ParseBase {\n+\n+    \/**\n+     * Stop parsing a source file immediately and interpret any issue as an error\n+     *\/\n+    private boolean exitImmediately = false;\n+\n+    \/**\n+     * local handles on the scanner, main parser, and the error reporting env\n+     *\/\n+    \/**\n+     * Visitor object\n+     *\/\n+    private ParserCPVisitor pConstVstr;\n+    \/**\n+     * counter of left braces\n+     *\/\n+    private int lbrace = 0;\n+\n+\n+    \/**\n+     * main constructor\n+     *\n+     * @param scanner\n+     * @param parser\n+     * @param env\n+     *\/\n+    protected ParserCP(Scanner scanner, Parser parser, Environment env) {\n+        super.init(scanner, parser, env);\n+        pConstVstr = new ParserCPVisitor();\n+    }\n+\n+    \/**\n+     * In particular cases it's necessary to interpret a warning issue as an error and\n+     * stop parsing a source file immediately\n+     * cpParser.setExitImmediately(true);\n+     * parseConstRef(...);\n+     * cpParser.setExitImmediately(false);\n+     *\/\n+    public void setExitImmediately(boolean exitImmediately) {\n+        this.exitImmediately = exitImmediately;\n+    }\n+\n+    public boolean isExitImmediately() {\n+        return exitImmediately;\n+    }\n+\n+    \/**\n+     * ParserCPVisitor\n+     *\n+     * This inner class overrides a constant pool visitor to provide specific parsing\n+     * instructions (per method) for each type of Constant.\n+     *\n+     * Note: since the generic visitor throws no exceptions, this derived class tunnels\n+     * the exceptions, rethrown in the visitEcept method.\n+     *\/\n+    class ParserCPVisitor extends ConstantPool.CPTagVisitor<ConstantPool.ConstValue> {\n+\n+        private IOException IOProb;\n+        private Scanner.SyntaxError SyProb;\n+\n+\n+        public ParserCPVisitor() {\n+            IOProb = null;\n+            SyProb = null;\n+        }\n+\n+        \/\/This is the entry point for a visitor that tunnels exceptions\n+        public ConstantPool.ConstValue visitExcept(ConstType tag) throws IOException, Scanner.SyntaxError {\n+            IOProb = null;\n+            SyProb = null;\n+            debugStr(\"------- [ParserCPVisitor.visitExcept]: \");\n+            ConstantPool.ConstValue ret = visit(tag);\n+\n+            if (IOProb != null) {\n+                throw IOProb;\n+            }\n+\n+            if (SyProb != null) {\n+                throw SyProb;\n+            }\n+\n+            return ret;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitUTF8(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitUTF8]: \");\n+            try {\n+                scanner.expect(Token.STRINGVAL);\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            ConstantPool.ConstValue_String obj\n+                    = new ConstantPool.ConstValue_String(scanner.stringValue);\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitInteger(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitInteger]: \");\n+            ConstantPool.ConstValue_Integer obj;\n+            int v = 0;\n+            try {\n+                if (scanner.token == Token.BITS) {\n+                    scanner.scan();\n+                    scanner.inBits = true;\n+                }\n+                v = scanner.intValue * scanner.sign;\n+                scanner.expect(Token.INTVAL);\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            obj = new ConstantPool.ConstValue_Integer(tag, v);\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitLong(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitLong]: \");\n+            ConstantPool.ConstValue_Long obj = null;\n+            try {\n+                long v;\n+                if (scanner.token == Token.BITS) {\n+                    scanner.scan();\n+                    scanner.inBits = true;\n+                }\n+                switch (scanner.token) {\n+                    case INTVAL:\n+                        v = scanner.intValue;\n+                        break;\n+                    case LONGVAL:\n+                        v = scanner.longValue;\n+                        break;\n+                    default:\n+                        env.error(scanner.prevPos, \"token.expected\", \"Integer\");\n+                        throw new Scanner.SyntaxError();\n+                }\n+                obj = new ConstantPool.ConstValue_Long(tag, v * scanner.sign);\n+                scanner.scan();\n+            } catch (IOException e) {\n+                IOProb = e;\n+            } catch (Scanner.SyntaxError e) {\n+                SyProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitFloat(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitFloat]: \");\n+            ConstantPool.ConstValue_Integer obj = null;\n+            try {\n+                int v;\n+                float f;\n+                scanner.inBits = false;  \/\/ this needs to be initialized for each float!\n+                if (scanner.token == Token.BITS) {\n+                    scanner.scan();\n+                    scanner.inBits = true;\n+                }\n+i2f:            {\n+                    switch (scanner.token) {\n+                        case INTVAL:\n+                            if (scanner.inBits) {\n+                                v = scanner.intValue;\n+                                break i2f;\n+                            } else {\n+                                f = (float) scanner.intValue;\n+                                break;\n+                            }\n+                        case FLOATVAL:\n+                            f = scanner.floatValue;\n+                            break;\n+                        case DOUBLEVAL:\n+                            f = (float) scanner.doubleValue; \/\/ to be excluded?\n+                            break;\n+                        case INF:\n+                            f = Float.POSITIVE_INFINITY;\n+                            break;\n+                        case NAN:\n+                            f = Float.NaN;\n+                            break;\n+                        default:\n+                            env.traceln(\"token=\" + scanner.token);\n+                            env.error(scanner.pos, \"token.expected\", \"<Float>\");\n+                            throw new Scanner.SyntaxError();\n+                    }\n+                    v = Float.floatToIntBits(f);\n+                }\n+                if (scanner.sign == -1) {\n+                    v = v ^ 0x80000000;\n+                }\n+                obj = new ConstantPool.ConstValue_Integer(tag, v);\n+                scanner.scan();\n+            } catch (IOException e) {\n+                IOProb = e;\n+            } catch (Scanner.SyntaxError e) {\n+                SyProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitDouble(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitDouble]: \");\n+            ConstantPool.ConstValue_Long obj = null;\n+            try {\n+                long v;\n+                double d;\n+                if (scanner.token == Token.BITS) {\n+                    scanner.scan();\n+                    scanner.inBits = true;\n+                }\n+d2l:            {\n+                    switch (scanner.token) {\n+                        case INTVAL:\n+                            if (scanner.inBits) {\n+                                v = scanner.intValue;\n+                                break d2l;\n+                            } else {\n+                                d = scanner.intValue;\n+                                break;\n+                            }\n+                        case LONGVAL:\n+                            if (scanner.inBits) {\n+                                v = scanner.longValue;\n+                                break d2l;\n+                            } else {\n+                                d = (double) scanner.longValue;\n+                                break;\n+                            }\n+                        case FLOATVAL:\n+                            d = scanner.floatValue;\n+                            break;\n+                        case DOUBLEVAL:\n+                            d = scanner.doubleValue;\n+                            break;\n+                        case INF:\n+                            d = Double.POSITIVE_INFINITY;\n+                            break;\n+                        case NAN:\n+                            d = Double.NaN;\n+                            break;\n+                        default:\n+                            env.error(scanner.pos, \"token.expected\", \"Double\");\n+                            throw new Scanner.SyntaxError();\n+                    }\n+                    v = Double.doubleToLongBits(d);\n+                }\n+                if (scanner.sign == -1) {\n+                    v = v ^ 0x8000000000000000L;\n+                }\n+                obj = new ConstantPool.ConstValue_Long(tag, v);\n+                scanner.scan();\n+            } catch (IOException e) {\n+                IOProb = e;\n+            } catch (Scanner.SyntaxError e) {\n+                SyProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        private ConstantPool.ConstCell visitName(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitName]: \");\n+            ConstantPool.ConstCell obj = null;\n+            try {\n+                obj = parser.parseName();\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitMethodtype(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitMethodtype]: \");\n+            ConstantPool.ConstValue_Cell obj = null;\n+            ConstantPool.ConstCell cell = visitName(tag);\n+            if (IOProb == null) {\n+                obj = new ConstantPool.ConstValue_Cell(tag, cell);\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitString(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitString]: \");\n+            ConstantPool.ConstValue_Cell obj = null;\n+            ConstantPool.ConstCell cell = visitName(tag);\n+            if (IOProb == null) {\n+                obj = new ConstantPool.ConstValue_Cell(tag, cell);\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitClass(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitClass]: \");\n+            ConstantPool.ConstValue_Cell obj = null;\n+            try {\n+                ConstantPool.ConstCell cell = parser.parseClassName(true);\n+                obj = new ConstantPool.ConstValue_Cell(tag, cell);\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitMethodhandle(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitMethodHandle]: \");\n+            ConstantPool.ConstValue_Pair obj = null;\n+            try {\n+                ConstantPool.ConstCell refCell;\n+                ConstantPool.ConstCell subtagCell;\n+                SubTag subtag;\n+                \/\/ MethodHandle    [INVOKESUBTAG|INVOKESUBTAG_INDEX] :    CONSTANT_FIELD | [FIELDREF|METHODREF|INTERFACEMETHODREF]\n+                if (scanner.token == Token.INTVAL) {\n+                    \/\/ INVOKESUBTAG_INDEX\n+                    \/\/ Handle explicit constant pool form\n+                    subtag = subtag(scanner.intValue);\n+                    subtagCell = new ConstantPool.ConstCell(subtag.value());\n+                    scanner.scan();\n+                    scanner.expect(Token.COLON);\n+                    if (scanner.token == Token.CPINDEX) {\n+                        \/\/ CONSTANT_FIELD\n+                        int cpx = scanner.intValue;\n+                        refCell = parser.pool.getCell(cpx);\n+                        scanner.scan();\n+                    } else {\n+                        \/\/ [FIELDREF|METHODREF|INTERFACEMETHODREF]\n+                        refCell = parser.parseMethodHandle(subtag);\n+                    }\n+                } else {\n+                    \/\/ INVOKESUBTAG : REF_INVOKEINTERFACE, REF_NEWINVOKESPECIAL, ...\n+                    \/\/ normal JASM\n+                    subtag = parser.parseSubtag();\n+                    subtagCell = new ConstantPool.ConstCell(subtag.value());\n+                    scanner.expect(Token.COLON);\n+                    if (scanner.token == Token.CPINDEX) {\n+                        \/\/ CODETOOLS-7901522: Jasm doesn't allow to create REF_invoke* referring an InterfaceMethod\n+                        \/\/ Parsing the case when refCell is CP index (#1)\n+                        \/\/ const #1 = InterfaceMethod m:\"()V\";\n+                        \/\/ const #2 = MethodHandle REF_invokeSpecial:#1;\n+                        int cpx = scanner.intValue;\n+                        refCell = parser.pool.getCell(cpx);\n+                        scanner.scan();\n+                    } else {\n+                        refCell = parser.parseMethodHandle(subtag);\n+                    }\n+                }\n+                obj = new ConstantPool.ConstValue_Pair(tag, subtagCell, refCell);\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        private ConstantPool.ConstValue_Pair visitMember(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitMember]: \");\n+            ConstantPool.ConstValue_Pair obj = null;\n+            try {\n+                Token prevtoken = scanner.token;\n+                ConstantPool.ConstCell firstName, ClassCell, NameCell, NapeCell;\n+                firstName = parser.parseClassName(false);\n+                if (scanner.token == Token.FIELD) { \/\/ DOT\n+                    scanner.scan();\n+                    if (prevtoken == Token.CPINDEX) {\n+                        ClassCell = firstName;\n+                    } else {\n+                        ClassCell = parser.pool.FindCell(ConstType.CONSTANT_CLASS, firstName);\n+                    }\n+                    NameCell = parser.parseName();\n+                } else {\n+                    \/\/ no class provided - assume current class\n+                    ClassCell = parser.cd.me;\n+                    NameCell = firstName;\n+                }\n+                if (scanner.token == Token.COLON) {\n+                    \/\/ name and type separately\n+                    scanner.scan();\n+                    NapeCell = parser.pool.FindCell(ConstType.CONSTANT_NAMEANDTYPE, NameCell, parser.parseName());\n+                } else {\n+                    \/\/ name and type as single name\n+                    NapeCell = NameCell;\n+                }\n+                obj = new ConstantPool.ConstValue_Pair(tag, ClassCell, NapeCell);\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitField(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitField]: \");\n+            return visitMember(tag);\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitMethod(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitMethod]: \");\n+            return visitMember(tag);\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitInterfacemethod(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitInterfacemethod]: \");\n+            return visitMember(tag);\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue visitNameandtype(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitNameandtype]: \");\n+            ConstantPool.ConstValue_Pair obj = null;\n+            try {\n+                ConstantPool.ConstCell NameCell = parser.parseName(), TypeCell;\n+                scanner.expect(Token.COLON);\n+                TypeCell = parser.parseName();\n+                obj = new ConstantPool.ConstValue_Pair(tag, NameCell, TypeCell);\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return obj;\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue_IndyPair visitInvokedynamic(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitInvokeDynamic]: \");\n+            final BiFunction<BootstrapMethodData, ConstantPool.ConstCell, ConstantPool.ConstValue_IndyPair> ctor =\n+                    (bsmData, napeCell) -> new ConstantPool.ConstValue_IndyPair(bsmData, napeCell);\n+            return visitBsm(ctor);\n+        }\n+\n+        @Override\n+        public ConstantPool.ConstValue_CondyPair visitDynamic(ConstType tag) {\n+            debugStr(\"------- [ParserCPVisitor.visitDynamic]: \");\n+            final BiFunction<BootstrapMethodData, ConstantPool.ConstCell, ConstantPool.ConstValue_CondyPair> ctor =\n+                    (bsmData, napeCell) -> new ConstantPool.ConstValue_CondyPair(bsmData, napeCell);\n+            return visitBsm(ctor);\n+        }\n+\n+        private <E extends ConstantPool.ConstValue_IndyOrCondyPair> E visitBsm(BiFunction<BootstrapMethodData, ConstantPool.ConstCell, E> ctor) {\n+            E obj = null;\n+            try {\n+                if (scanner.token == Token.INTVAL) {\n+                    \/\/ Handle explicit constant pool form\n+                    int bsmIndex = scanner.intValue;\n+                    scanner.scan();\n+                    scanner.expect(Token.COLON);\n+                    if (scanner.token != Token.CPINDEX) {\n+                        env.traceln(\"token=\" + scanner.token);\n+                        env.error(scanner.pos, \"token.expected\", \"<CPINDEX>\");\n+                        throw new Scanner.SyntaxError();\n+                    }\n+                    int cpx = scanner.intValue;\n+                    scanner.scan();\n+                    \/\/ Put a placeholder in place of BSM.\n+                    \/\/ resolve placeholder after the attributes are scanned.\n+                    BootstrapMethodData bsmData = new BootstrapMethodData(bsmIndex);\n+                    obj =   ctor.apply(bsmData, parser.pool.getCell(cpx));\n+                } else {\n+                    \/\/ Handle full form\n+                    ConstantPool.ConstCell MHCell = parser.pool.FindCell(parseConstValue(ConstType.CONSTANT_METHODHANDLE));\n+                    scanner.expect(Token.COLON);\n+                    ConstantPool.ConstCell NapeCell = parser.pool.FindCell(parseConstValue(ConstType.CONSTANT_NAMEANDTYPE));\n+                    if(scanner.token == Token.LBRACE) {\n+                        ParserCP.this.lbrace++;\n+                        scanner.scan();\n+                    }\n+                    ArrayList<ConstantPool.ConstCell> bsm_args = new ArrayList<>(256);\n+                    while(true) {\n+                        if( ParserCP.this.lbrace > 0 ) {\n+                            if(scanner.token == Token.RBRACE ) {\n+                                ParserCP.this.lbrace--;\n+                                scanner.scan();\n+                                break;\n+                            } else if(scanner.token == Token.SEMICOLON) {\n+                                scanner.expect(Token.RBRACE);\n+                            }\n+                        } else if(scanner.token == Token.SEMICOLON) {\n+                            break;\n+                        }\n+                        if (scanner.token == Token.COMMA) {\n+                            scanner.scan();\n+                        }\n+                        bsm_args.add(parseConstRef(null));\n+                    }\n+                    if( ParserCP.this.lbrace == 0 ) {\n+                        scanner.check(Token.SEMICOLON);\n+                    }\n+                    BootstrapMethodData bsmData = new BootstrapMethodData(MHCell, bsm_args);\n+                    parser.cd.addBootstrapMethod(bsmData);\n+                    obj = ctor.apply(bsmData, NapeCell);\n+                }\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return obj;\n+        }\n+    } \/\/ End Visitor\n+\n+    \/**\n+     * Parse CONSTVALUE\n+     *\/\n+    protected ConstantPool.ConstValue parseConstValue(ConstType tag) throws IOException, Scanner.SyntaxError {\n+        return pConstVstr.visitExcept(tag);\n+    }\n+\n+    \/**\n+     * Parse [TAG] CONSTVALUE\n+     *\/\n+    protected ConstantPool.ConstValue parseTagConstValue(ConstType defaultTag) throws Scanner.SyntaxError, IOException {\n+        return parseTagConstValue(defaultTag, null, false);\n+    }\n+\n+    private ConstType scanConstByID(boolean ignoreKeywords) {\n+        ConstType tag = null;\n+        if (!ignoreKeywords) {\n+            ConstType tg = Tables.tag(scanner.idValue);\n+            if (tg != null) {\n+                tag = tg;\n+            }\n+            debugStr(\" *^*^*^*^ [ParserCP.scanConst]: {TAG = \" + (tg == null ? \"null\" : tg.toString()) + \" \");\n+        }\n+        return tag;\n+    }\n+\n+    private ConstType scanConstPrimVal() throws Scanner.SyntaxError, IOException {\n+        ConstType tag = null;\n+        switch (scanner.token) {\n+            case INTVAL:\n+                tag = ConstType.CONSTANT_INTEGER;\n+                break;\n+            case LONGVAL:\n+                tag = ConstType.CONSTANT_LONG;\n+                break;\n+            case FLOATVAL:\n+                tag = ConstType.CONSTANT_FLOAT;\n+                break;\n+            case DOUBLEVAL:\n+                tag = ConstType.CONSTANT_DOUBLE;\n+                break;\n+            case STRINGVAL:\n+            case BITS:\n+            case IDENT:\n+                tag = ConstType.CONSTANT_STRING;\n+                break;\n+            default:\n+                \/\/ problem - no constant value\n+                System.err.println(\"NEAR: \" + scanner.token.printValue());\n+                env.error(scanner.pos, \"value.expected\");\n+                throw new Scanner.SyntaxError();\n+        }\n+        return tag;\n+    }\n+\n+    private void checkWrongTag(ConstType tag, ConstType defaultTag, ConstType default2Tag) throws Scanner.SyntaxError, IOException {\n+        if (defaultTag != null) {\n+            if (tag != defaultTag) {\n+                if (default2Tag == null) {\n+                    if( exitImmediately ) {\n+                        env.error(\"wrong.tag\", defaultTag.parseKey());\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+                    env.error(\"warn.wrong.tag\", defaultTag.parseKey());\n+                } else if (tag != default2Tag) {\n+                    if( exitImmediately ) {\n+                        env.error(\"wrong.tag2\", defaultTag.parseKey(), default2Tag.parseKey());\n+                        throw new Scanner.SyntaxError().Fatal();\n+                    }\n+                    env.error(\"warn.wrong.tag2\", defaultTag.parseKey(), default2Tag.parseKey());\n+                }\n+            }\n+        }\n+    }\n+\n+    protected ConstantPool.ConstValue parseTagConstValue(ConstType defaultTag, ConstType default2Tag, boolean ignoreKeywords) throws Scanner.SyntaxError, IOException {\n+        debugScan(\" *^*^*^*^ [ParserCP.parseTagConstValue]: Begin default_tag:  ignoreKeywords: \" + (ignoreKeywords ? \"true\" : \"false\"));\n+        \/\/ Lookup the Tag from the scanner\n+        ConstType tag = scanConstByID(ignoreKeywords);\n+        debugStr(\" *^*^*^*^ [ParserCP.parseTagConstValue]: {tag = \" + tag + \", defaulttag = \" + defaultTag + \"} \");\n+\n+        \/\/ If the scanned tag is null\n+        if (tag == null) {\n+            \/\/ and, if the expected tag is null\n+            if (defaultTag == null) {\n+                \/\/ return some other type of constant as the tag\n+                tag = scanConstPrimVal();\n+            } else {\n+                \/\/ otherwise, make the scanned-tag the same constant-type\n+                \/\/ as the expected tag.\n+                tag = defaultTag;\n+            }\n+        } else {\n+            \/\/ If the scanned tag is some constant type\n+            \/\/ and the scanned type does not equal the expected type\n+            checkWrongTag(tag, defaultTag, default2Tag);\n+            scanner.scan();\n+        }\n+        return parseConstValue(tag);\n+    } \/\/ end parseTagConstValue\n+\n+    protected ConstantPool.ConstCell parseConstRef(ConstType defaultTag) throws Scanner.SyntaxError, IOException {\n+        return parseConstRef(defaultTag, null, false);\n+    }\n+\n+    protected ConstantPool.ConstCell parseConstRef(ConstType defaultTag, ConstType default2Tag) throws Scanner.SyntaxError, IOException {\n+        return parseConstRef(defaultTag, default2Tag, false);\n+    }\n+\n+    \/**\n+     * Parse an instruction argument, one of: * #NUMBER, #NAME, [TAG] CONSTVALUE\n+     *\/\n+    protected ConstantPool.ConstCell parseConstRef(ConstType defaultTag,\n+            ConstType default2Tag,\n+            boolean ignoreKeywords) throws Scanner.SyntaxError, IOException {\n+        if (scanner.token == Token.CPINDEX) {\n+            int cpx = scanner.intValue;\n+            scanner.scan();\n+            return parser.pool.getCell(cpx);\n+        } else {\n+            ConstantPool.ConstValue ref = parseTagConstValue(defaultTag, default2Tag, ignoreKeywords);\n+            return parser.pool.FindCell(ref);\n+        }\n+    } \/\/ end parseConstRef\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ParserCP.java","additions":665,"deletions":0,"binary":false,"changes":665,"status":"added"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import static org.openjdk.asmtools.jasm.JasmTokens.*;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import static org.openjdk.asmtools.jasm.OpcodeTables.*;\n+import java.io.IOException;\n+import java.lang.reflect.Modifier;\n+\n+\/**\n+ * ParserInstr\n+ *\n+ * ParserInstr is a parser class owned by Parser.java. It is primarily responsible for\n+ * parsing instruction byte codes.\n+ *\/\n+public class ParserInstr extends ParseBase {\n+\n+    \/**\n+     * local handle for the constant parser - needed for parsing constants during\n+     * instruction construction.\n+     *\/\n+    private ParserCP cpParser = null;\n+\n+    \/**\n+     * main constructor\n+     *\n+     * @param scanner\n+     * @param parser\n+     * @param env\n+     *\/\n+    protected ParserInstr(Scanner scanner, Parser parser, ParserCP cpParser, Environment env) {\n+        super.init(scanner, parser, env);\n+        this.cpParser = cpParser;\n+    }\n+\n+    \/**\n+     * Parse an instruction.\n+     *\/\n+    protected void parseInstr() throws Scanner.SyntaxError, IOException {\n+        \/\/ ignore possible line numbers after java disassembler\n+        if (scanner.token == Token.INTVAL) {\n+            scanner.scan();\n+        }\n+        \/\/ ignore possible numeric labels after java disassembler\n+        if (scanner.token == Token.INTVAL) {\n+            scanner.scan();\n+        }\n+        if (scanner.token == Token.COLON) {\n+            scanner.scan();\n+        }\n+\n+        String mnemocode;\n+        int mnenoc_pos;\n+        for (;;) { \/\/ read labels\n+            if (scanner.token != Token.IDENT) {\n+                return;\n+            }\n+            mnemocode = scanner.idValue;\n+            mnenoc_pos = scanner.pos;\n+            scanner.scan();\n+            if (scanner.token != Token.COLON) {\n+                break;\n+            }\n+            \/\/ actually it was a label\n+            scanner.scan();\n+            parser.curCode.LabelDef(mnenoc_pos, mnemocode);\n+        }\n+\n+        Opcode opcode = OpcodeTables.opcode(mnemocode);\n+        if (opcode == null) {\n+            debugScan(\" Error:  mnemocode = '\" + mnemocode + \"'.   \");\n+        }\n+        OpcodeType optype = opcode.type();\n+\n+        Argument arg = null;\n+        Object arg2 = null;\n+        StackMapData sMap = null;\n+\n+        debugScan(\" --IIIII---[ParserInstr:[parseInstr]:  (Pos: \" + mnenoc_pos + \") mnemocode: '\" + opcode.parsekey() + \"' \");\n+\n+        switch (optype) {\n+            case NORMAL:\n+                switch (opcode) {\n+\n+                    \/\/ pseudo-instructions:\n+                    case opc_bytecode:\n+                        for (;;) {\n+                            parser.curCode.addInstr(mnenoc_pos, Opcode.opc_bytecode, parser.parseUInt(1), null);\n+                            if (scanner.token != Token.COMMA) {\n+                                return;\n+                            }\n+                            scanner.scan();\n+                        }\n+                    case opc_try:\n+                        for (;;) {\n+                            parser.curCode.beginTrap(scanner.pos, parser.parseIdent());\n+                            if (scanner.token != Token.COMMA) {\n+                                return;\n+                            }\n+                            scanner.scan();\n+                        }\n+                    case opc_endtry:\n+                        for (;;) {\n+                            parser.curCode.endTrap(scanner.pos, parser.parseIdent());\n+                            if (scanner.token != Token.COMMA) {\n+                                return;\n+                            }\n+                            scanner.scan();\n+                        }\n+                    case opc_catch:\n+                        parser.curCode.trapHandler(scanner.pos, parser.parseIdent(),\n+                                cpParser.parseConstRef(ConstType.CONSTANT_CLASS));\n+                        return;\n+                    case opc_var:\n+                        for (;;) {\n+                            parser.parseLocVarDef();\n+                            if (scanner.token != Token.COMMA) {\n+                                return;\n+                            }\n+                            scanner.scan();\n+                        }\n+                    case opc_endvar:\n+                        for (;;) {\n+                            parser.parseLocVarEnd();\n+                            if (scanner.token != Token.COMMA) {\n+                                return;\n+                            }\n+                            scanner.scan();\n+                        }\n+                    case opc_locals_map:\n+                        sMap = parser.curCode.getStackMap();\n+                        if (sMap.localsMap != null) {\n+                            env.error(scanner.pos, \"localsmap.repeated\");\n+                        }\n+                        ;\n+                        DataVector localsMap = new DataVector();\n+                        sMap.localsMap = localsMap;\n+                        if (scanner.token == Token.SEMICOLON) {\n+                            return;  \/\/ empty locals_map allowed\n+                        }\n+                        for (;;) {\n+                            parser.parseMapItem(localsMap);\n+                            if (scanner.token != Token.COMMA) {\n+                                return;\n+                            }\n+                            scanner.scan();\n+                        }\n+                    case opc_stack_map:\n+                        sMap = parser.curCode.getStackMap();\n+                        if (sMap.stackMap != null) {\n+                            env.error(scanner.pos, \"stackmap.repeated\");\n+                        }\n+                        ;\n+                        DataVector stackMap = new DataVector();\n+                        sMap.stackMap = stackMap;\n+                        if (scanner.token == Token.SEMICOLON) {\n+                            return;  \/\/ empty stack_map allowed\n+                        }\n+                        for (;;) {\n+                            parser.parseMapItem(stackMap);\n+                            if (scanner.token != Token.COMMA) {\n+                                return;\n+                            }\n+                            scanner.scan();\n+                        }\n+                    case opc_stack_frame_type:\n+                        sMap = parser.curCode.getStackMap();\n+                        if (sMap.stackFrameType != null) {\n+                            env.error(scanner.pos, \"frametype.repeated\");\n+                        }\n+                        ;\n+                        sMap.setStackFrameType(parser.parseIdent());\n+                        return;\n+\n+                    \/\/ normal instructions:\n+                    case opc_aload:\n+                    case opc_astore:\n+                    case opc_fload:\n+                    case opc_fstore:\n+                    case opc_iload:\n+                    case opc_istore:\n+                    case opc_lload:\n+                    case opc_lstore:\n+                    case opc_dload:\n+                    case opc_dstore:\n+                    case opc_ret:\n+                    case opc_aload_w:\n+                    case opc_astore_w:\n+                    case opc_fload_w:\n+                    case opc_fstore_w:\n+                    case opc_iload_w:\n+                    case opc_istore_w:\n+                    case opc_lload_w:\n+                    case opc_lstore_w:\n+                    case opc_dload_w:\n+                    case opc_dstore_w:\n+                    case opc_ret_w:\n+                        \/\/ loc var\n+                        arg = parser.parseLocVarRef();\n+                        break;\n+                    case opc_iinc: \/\/ loc var, const\n+                        arg = parser.parseLocVarRef();\n+                        scanner.expect(Token.COMMA);\n+                        arg2 = parser.parseInt(1);\n+                        break;\n+                    case opc_tableswitch:\n+                    case opc_lookupswitch:\n+                        arg2 = parseSwitchTable();\n+                        break;\n+                    case opc_newarray: {\n+                        int type;\n+                        if (scanner.token == Token.INTVAL) {\n+                            type = scanner.intValue;\n+                        } else if ((type = Tables.basictypeValue(scanner.idValue)) == -1) {\n+                            env.error(scanner.pos, \"type.expected\");\n+                            throw new Scanner.SyntaxError();\n+                        }\n+                        scanner.scan();\n+                        arg = new Argument(type);\n+                        break;\n+                    }\n+                    case opc_new:\n+                    case opc_anewarray:\n+                    case opc_instanceof:\n+                    case opc_checkcast:\n+                        arg = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+                        break;\n+                    case opc_bipush:\n+                        arg = parser.parseInt(1);\n+                        break;\n+                    case opc_sipush:\n+                        arg = parser.parseInt(2);\n+                        break;\n+                    case opc_ldc:\n+                    case opc_ldc_w:\n+                    case opc_ldc2_w:\n+                        arg = cpParser.parseConstRef(null);\n+                        break;\n+                    case opc_putstatic:\n+                    case opc_getstatic:\n+                    case opc_putfield:\n+                    case opc_getfield:\n+                        arg = cpParser.parseConstRef(ConstType.CONSTANT_FIELD);\n+                        break;\n+                    case opc_invokevirtual:\n+                        arg = cpParser.parseConstRef(ConstType.CONSTANT_METHOD);\n+                        break;\n+                    case opc_invokestatic:\n+                    case opc_invokespecial:\n+                        ConstType ctype01  = ConstType.CONSTANT_METHOD;\n+                        ConstType ctype02  = ConstType.CONSTANT_INTERFACEMETHOD;\n+                        if(Modifier.isInterface(this.parser.cd.access)) {\n+                            ctype01  = ConstType.CONSTANT_INTERFACEMETHOD;\n+                            ctype02  = ConstType.CONSTANT_METHOD;\n+                        }\n+                        arg = cpParser.parseConstRef(ctype01, ctype02);\n+                        break;\n+                    case opc_jsr:\n+                    case opc_goto:\n+                    case opc_ifeq:\n+                    case opc_ifge:\n+                    case opc_ifgt:\n+                    case opc_ifle:\n+                    case opc_iflt:\n+                    case opc_ifne:\n+                    case opc_if_icmpeq:\n+                    case opc_if_icmpne:\n+                    case opc_if_icmpge:\n+                    case opc_if_icmpgt:\n+                    case opc_if_icmple:\n+                    case opc_if_icmplt:\n+                    case opc_if_acmpeq:\n+                    case opc_if_acmpne:\n+                    case opc_ifnull:\n+                    case opc_ifnonnull:\n+                    case opc_jsr_w:\n+                    case opc_goto_w:\n+                        arg = parseLabelRef();\n+                        break;\n+\n+                    case opc_invokeinterface:\n+                        arg = cpParser.parseConstRef(ConstType.CONSTANT_INTERFACEMETHOD);\n+                        scanner.expect(Token.COMMA);\n+                        arg2 = parser.parseUInt(1);\n+                        break;\n+                    case opc_invokedynamic:\n+                        arg = cpParser.parseConstRef(ConstType.CONSTANT_INVOKEDYNAMIC);\n+                        break;\n+\n+                    case opc_multianewarray:\n+                        arg = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);\n+                        scanner.expect(Token.COMMA);\n+                        arg2 = parser.parseUInt(1);\n+                        break;\n+                    case opc_wide:\n+                    case opc_nonpriv:\n+                    case opc_priv:\n+                        int opc2 = (opcode.value() << 8) | parser.parseUInt(1).arg;\n+                        opcode = opcode(opc2);\n+                        break;\n+                }\n+                break;\n+            case WIDE:\n+                arg = parser.parseLocVarRef();\n+                if (opcode == Opcode.opc_iinc_w) { \/\/ loc var, const\n+                    scanner.expect(Token.COMMA);\n+                    arg2 = parser.parseInt(2);\n+                }\n+                break;\n+            case NONPRIVELEGED:\n+            case PRIVELEGED:\n+                break;\n+            default:\n+                env.error(scanner.prevPos, \"wrong.mnemocode\", mnemocode);\n+                throw new Scanner.SyntaxError();\n+        }\n+        \/\/ env.traceln(\" [ParserInstr.parseInstr] ===============> Adding Instruction: [\" + mnenoc_pos + \"]: instr: \"+ mnemocode \/* opcNamesTab[opc] *\/);\n+        parser.curCode.addInstr(mnenoc_pos, opcode, arg, arg2);\n+    } \/\/end parseInstr\n+\n+    \/**\n+     * Parse a Switch Table. return value: SwitchTable.\n+     *\/\n+    protected SwitchTable parseSwitchTable() throws Scanner.SyntaxError, IOException {\n+        scanner.expect(Token.LBRACE);\n+        Argument label;\n+        int numpairs = 0, key;\n+        SwitchTable table = new SwitchTable(env);\n+tableScan:\n+        {\n+            while (numpairs < 1000) {\n+\/\/              env.traceln(\"start tableScan:\" + token);\n+                switch (scanner.token) {\n+                    case INTVAL:\n+\/\/                        env.traceln(\"enter tableScan:\" + token);\n+                        key = scanner.intValue * scanner.sign;\n+                        scanner.scan();\n+                        scanner.expect(Token.COLON);\n+                        table.addEntry(key, parseLabelRef());\n+                        numpairs++;\n+                        if (scanner.token != Token.SEMICOLON) {\n+\/\/                            env.traceln(\"break tableScan1:\" + token);\n+                            break tableScan;\n+                        }\n+                        scanner.scan();\n+                        break;\n+                    case DEFAULT:\n+                        scanner.scan();\n+                        scanner.expect(Token.COLON);\n+                        if (table.deflabel != null) {\n+                            env.error(\"default.redecl\");\n+                        }\n+                        table.deflabel = parseLabelRef();\n+                        if (scanner.token != Token.SEMICOLON) {\n+\/\/                            env.traceln(\"break tableScan2:\" + token);\n+                            break tableScan;\n+                        }\n+                        scanner.scan();\n+                        break;\n+                    default:\n+\/\/                      env.traceln(\"break tableScan3:\" + token + \"val=\" + intValue);\n+                        break tableScan;\n+                } \/\/ end switch\n+            } \/\/ while (numpairs<1000)\n+            env.error(\"long.switchtable\", \"1000\");\n+        } \/\/ end tableScan\n+        scanner.expect(Token.RBRACE);\n+        return table;\n+    } \/\/ end parseSwitchTable\n+\n+    \/**\n+     * Parse a label instruction argument\n+     *\/\n+    protected Argument parseLabelRef() throws Scanner.SyntaxError, IOException {\n+        switch (scanner.token) {\n+            case INTVAL: {\n+                int v = scanner.intValue * scanner.sign;\n+                scanner.scan();\n+                return new Argument(v);\n+            }\n+            case IDENT: {\n+                String label = scanner.stringValue;\n+                scanner.scan();\n+                return parser.curCode.LabelRef(label);\n+            }\n+        }\n+        env.error(\"label.expected\");\n+        throw new Scanner.SyntaxError();\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/ParserInstr.java","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.util.List;\n+\n+\/**\n+ * The \"classes[]\" data of attributes\n+ * JEP 360 (Sealed types): class file 59.65535\n+ * PermittedSubclasses_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ *\/\n+public class PermittedSubclassesAttr extends ClassArrayAttr {\n+    public PermittedSubclassesAttr(ClassData cdata, List<ConstantPool.ConstCell> classes) {\n+        super(Tables.AttrTag.ATT_PermittedSubclasses.parsekey(), cdata, classes);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/PermittedSubclassesAttr.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.openjdk.asmtools.jasm.RuntimeConstants.*;\n+\n+\/**\n+ * The record attribute (JEP 359 since class file 58.65535)\n+ *\/\n+public class RecordData extends AttrData {\n+    private List<ComponentData> components = new ArrayList<>();\n+\n+    public RecordData(ClassData cls) {\n+        super(cls, Tables.AttrTag.ATT_Record.parsekey());\n+    }\n+\n+    public void addComponent(ConstantPool.ConstCell nameCell,\n+                             ConstantPool.ConstCell descCell,\n+                             ConstantPool.ConstCell signature,\n+                             ArrayList<AnnotationData> annotations) {\n+        \/\/ Define a field if absent\n+        FieldData fd = getClassData().addFieldIfAbsent(ACC_MANDATED & ACC_PRIVATE & ACC_FINAL, nameCell, descCell);\n+        ComponentData cd = new ComponentData(fd);\n+        if( annotations != null ) {\n+            cd.addAnnotations(annotations);\n+        }\n+        if( signature != null ) {\n+            cd.setSignatureAttr(signature);\n+        }\n+        components.add(cd);\n+    }\n+\n+    public boolean isEmpty() {\n+        return components.isEmpty();\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        super.write(out);\n+        out.writeShort(components.size());\n+        for (ComponentData cd : components) {\n+            cd.write(out);\n+        }\n+    }\n+\n+    @Override\n+    public int attrLength() {\n+        int compsLength = components.stream().mapToInt(c -> c.getLength()).sum();\n+        return 2 + compsLength;\n+    }\n+\n+    class ComponentData extends MemberData {\n+        private FieldData field;\n+\n+        public ComponentData(FieldData field) {\n+            super(getClassData());\n+            this.field = field;\n+        }\n+\n+        @Override\n+        protected DataVector getAttrVector() {\n+            return getDataVector(signatureAttr);\n+        }\n+\n+        public void write(CheckedDataOutputStream out) throws IOException, Parser.CompilerError {\n+            out.writeShort(field.getNameDesc().left.arg);\n+            out.writeShort(field.getNameDesc().right.arg);\n+            DataVector attrs = getAttrVector();\n+            attrs.write(out);\n+        }\n+\n+        public int getLength() {\n+            return 4 + getAttrVector().getLength();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/RecordData.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ *\n+ *\/\n+public interface RuntimeConstants {\n+    \/* Access Flags *\/\n+\n+    int ACC_NONE          = 0x0000; \/\/ <<everywhere>>\n+    int ACC_PUBLIC        = 0x0001; \/\/ class, inner, field, method\n+    int ACC_PRIVATE       = 0x0002; \/\/        inner, field, method\n+    int ACC_PROTECTED     = 0x0004; \/\/        inner, field, method\n+    int ACC_STATIC        = 0x0008; \/\/        inner, field, method\n+    int ACC_FINAL         = 0x0010; \/\/ class, inner, field, method\n+    int ACC_TRANSITIVE    = 0x0010; \/\/                                      requires(module)\n+    int ACC_SUPER         = 0x0020; \/\/ class\n+    int ACC_STATIC_PHASE  = 0x0020; \/\/                                      requires(module)\n+    int ACC_SYNCHRONIZED  = 0x0020; \/\/                      method\n+    int ACC_OPEN          = 0x0020; \/\/                              module\n+    int ACC_VOLATILE      = 0x0040; \/\/               field\n+    int ACC_BRIDGE        = 0x0040; \/\/                      method\n+    int ACC_TRANSIENT     = 0x0080; \/\/               field\n+    int ACC_VARARGS       = 0x0080; \/\/                      method\n+    int ACC_NATIVE        = 0x0100; \/\/                      method\n+    int ACC_INTERFACE     = 0x0200; \/\/ class, inner\n+    int ACC_ABSTRACT      = 0x0400; \/\/ class, inner,        method\n+    int ACC_STRICT        = 0x0800; \/\/                      method\n+    int ACC_SYNTHETIC     = 0x1000; \/\/ class, inner, field, method, module  requires(module) exports(module)\n+    int ACC_ANNOTATION    = 0x2000; \/\/ class, inner\n+    int ACC_ENUM          = 0x4000; \/\/ class, inner, field\n+    int ACC_MODULE        = 0x8000; \/\/ class\n+    int ACC_MANDATED      = 0x8000; \/\/                      method  module  requires(module) exports(module)\n+\n+   \/* Attribute codes *\/\n+   int SYNTHETIC_ATTRIBUTE          = 0x00010000; \/\/ actually, this is an attribute\n+   int DEPRECATED_ATTRIBUTE         = 0x00020000; \/\/ actually, this is an attribute\n+\n+   Map<Integer,String> ACC_NAMES = new HashMap() {{\n+                        put(ACC_PUBLIC       ,\"public\");\n+                        put(ACC_PRIVATE      ,\"private\");\n+                        put(ACC_PROTECTED    ,\"protected\");\n+                        put(ACC_STATIC       ,\"static\");\n+                        put(ACC_FINAL        ,\"final\");\n+                        put(ACC_SUPER        ,\"super\");\n+                        put(ACC_SYNCHRONIZED ,\"synchronized\");\n+                        put(ACC_VOLATILE     ,\"volatile\");\n+                        put(ACC_BRIDGE       ,\"bridge\");\n+                        put(ACC_TRANSIENT    ,\"transient\");\n+                        put(ACC_VARARGS      ,\"varargs\");\n+                        put(ACC_NATIVE       ,\"native\");\n+                        put(ACC_INTERFACE    ,\"interface\");\n+                        put(ACC_ABSTRACT     ,\"abstract\");\n+                        put(ACC_STRICT       ,\"strict\");\n+                        put(ACC_SYNTHETIC    ,\"synthetic\");\n+                        put(ACC_ANNOTATION   ,\"annotation\");\n+                        put(ACC_ENUM         ,\"enum\");\n+                        put(ACC_MODULE       ,\"module\");\n+                        put(ACC_MANDATED     ,\"mandated\");\n+                        put(SYNTHETIC_ATTRIBUTE     ,\"synthetic\");\n+  }};\n+\n+    \/* The version of a class file since which the compact format of stack map is necessary *\/\n+    int SPLIT_VERIFIER_CFV = 50;\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/RuntimeConstants.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,1209 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jasm.JasmTokens.*;\n+import static org.openjdk.asmtools.jasm.Constants.EOF;\n+import static org.openjdk.asmtools.jasm.Constants.OFFSETBITS;\n+import java.io.IOException;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * A Scanner for Jasm tokens. Errors are reported to the environment object.<p>\n+ *\n+ * The scanner keeps track of the current token, the value of the current token (if any),\n+ * and the start position of the current token.<p>\n+ *\n+ * The scan() method advances the scanner to the next token in the input.<p>\n+ *\n+ * The match() method is used to quickly match opening brackets (ie: '(', '{', or '[')\n+ * with their closing counter part. This is useful during error recovery.<p>\n+ *\n+ * The compiler treats either \"\\n\", \"\\r\" or \"\\r\\n\" as the end of a line.<p>\n+ *\/\n+public class Scanner extends ParseBase {\n+\n+    \/**\n+     * SyntaxError is the generic error thrown for parsing problems.\n+     *\/\n+    protected static class SyntaxError extends Error {\n+        boolean fatalError = false;\n+        SyntaxError Fatal() { fatalError = true; return this; }\n+        boolean isFatal() {return fatalError;}\n+    }\n+\n+    \/**\n+     * Input stream\n+     *\/\n+    protected Environment in;\n+\n+    \/**\n+     * The current character\n+     *\/\n+    protected int ch;\n+\n+    \/**\n+     * Current token\n+     *\/\n+\/\/    protected int token;\n+    protected Token token;\n+\n+    \/**\n+     * The position of the current token\n+     *\/\n+    protected int pos;\n+\n+    \/*\n+     * Token values.\n+     *\/\n+    protected char charValue;\n+    protected int intValue;\n+    protected long longValue;\n+    protected float floatValue;\n+    protected double doubleValue;\n+    protected String stringValue;\n+    protected String idValue;\n+    protected int radix;        \/\/ Radix, when reading int or long\n+\n+    \/*   doc comment preceding the most recent token  *\/\n+    protected String docComment;\n+\n+    \/* A growable character buffer. *\/\n+    private int count;\n+    private char buffer[] = new char[32];\n+    \/\/\n+    private Predicate<Integer> escapingAllowed;\n+    \/**\n+     * The position of the previous token\n+     *\/\n+    protected int prevPos;\n+    protected int sign;              \/\/ sign, when reading number\n+    protected boolean inBits;        \/\/ inBits prefix, when reading number\n+\n+    \/**\n+     * main constructor.\n+     *\n+     * Create a scanner to scan an input stream.\n+     *\/\n+    protected Scanner(Environment env) throws IOException {\n+        super.init(this, null, env);\n+        escapingAllowed = noFunc;\n+        this.in = env;\n+        ch = env.read();\n+        xscan();\n+    }\n+\n+    protected void scanModuleStatement() throws IOException {\n+        try {\n+            escapingAllowed = yesAndProcessFunc;\n+            scan();\n+        } finally {\n+            escapingAllowed = noFunc;\n+        }\n+    }\n+\n+    \/**\n+     * scan\n+     *\n+     * Scan the next token.\n+     *\n+     * @throws IOException\n+     *\/\n+    protected void scan() throws IOException {\n+        int signloc = 1, cnt = 0;\n+        prevPos = pos;\n+prefix:\n+        for (;;) {\n+            xscan();\n+            switch (token) {\n+                case SIGN:\n+                    signloc = signloc * intValue;\n+                    break;\n+                default:\n+                    break prefix;\n+            }\n+            cnt++;\n+        }\n+        switch (token) {\n+            case INTVAL:\n+            case LONGVAL:\n+            case FLOATVAL:\n+            case DOUBLEVAL:\n+            case INF:\n+            case NAN:\n+                sign = signloc;\n+                break;\n+            default:\n+        }\n+    }\n+\n+    \/**\n+     * Check the token may be identifier\n+     *\/\n+    protected final boolean checkTokenIdent() {\n+        return token.possibleJasmIdentifier();\n+    }\n+\n+    static String readableConstant(int t) {\n+        return \"<\" + Tables.tag(t) + \"> [\" + t + \"]\";\n+    }\n+\n+    \/**\n+     * Expects a token, scans the next token or throws an exception.\n+     *\/\n+    protected final void expect(Token t) throws SyntaxError, IOException {\n+        check(t);\n+        scan();\n+    }\n+\n+    \/**\n+     * Checks a token, throws an exception if not the same\n+     *\/\n+    protected final void check(Token t) throws SyntaxError, IOException {\n+        if (token != t) {\n+            if ((t != Token.IDENT) || !checkTokenIdent()) {\n+                env.traceln(\"expect: \" + t + \" instead of \" + token);\n+                switch (t) {\n+                    case IDENT:\n+                        env.error(pos, \"identifier.expected\");\n+                        break;\n+                    default:\n+                        env.error(pos, \"token.expected\", \"<\" + t.printValue() + \">\");\n+                        break;\n+                }\n+\n+                if (debugFlag) {\n+                    debugStr(\"<<<<<PROBLEM>>>>>>>: \");\n+                    throw new Error(\"<<<<<PROBLEM>>>>>>>\");\n+                } else {\n+                    throw new SyntaxError();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void putCh(int ch) {\n+        if (count == buffer.length) {\n+            char newBuffer[] = new char[buffer.length * 2];\n+            System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);\n+            buffer = newBuffer;\n+        }\n+        buffer[count++] = (char) ch;\n+    }\n+\n+    private String bufferString() {\n+        char buf[] = new char[count];\n+        System.arraycopy(buffer, 0, buf, 0, count);\n+        return new String(buf);\n+    }\n+\n+    \/**\n+     * Returns true if the character is a unicode digit.\n+     *\n+     * @param ch the character to be checked\n+     *\/\n+    public static boolean isUCDigit(int ch) {\n+        if ((ch >= '0') && (ch <= '9')) {\n+            return true;\n+        }\n+        switch (ch >> 8) {\n+            case 0x06:\n+                return ((ch >= 0x0660) && (ch <= 0x0669)) ||        \/\/ Arabic-Indic\n+                        ((ch >= 0x06f0) && (ch <= 0x06f9));         \/\/ Eastern Arabic-Indic\n+            case 0x07:\n+            case 0x08:\n+            default:\n+                return false;\n+            case 0x09:\n+                return ((ch >= 0x0966) && (ch <= 0x096f)) ||        \/\/ Devanagari\n+                        ((ch >= 0x09e6) && (ch <= 0x09ef));         \/\/ Bengali\n+            case 0x0a:\n+                return ((ch >= 0x0a66) && (ch <= 0x0a6f)) ||        \/\/ Gurmukhi\n+                        ((ch >= 0x0ae6) && (ch <= 0x0aef));         \/\/ Gujarati\n+            case 0x0b:\n+                return ((ch >= 0x0b66) && (ch <= 0x0b6f)) ||        \/\/ Oriya\n+                        ((ch >= 0x0be7) && (ch <= 0x0bef));         \/\/ Tamil\n+            case 0x0c:\n+                return ((ch >= 0x0c66) && (ch <= 0x0c6f)) ||        \/\/ Telugu\n+                        ((ch >= 0x0ce6) && (ch <= 0x0cef));         \/\/ Kannada\n+            case 0x0d:\n+                return ((ch >= 0x0d66) && (ch <= 0x0d6f));          \/\/ Malayalam\n+            case 0x0e:\n+                return ((ch >= 0x0e50) && (ch <= 0x0e59)) ||        \/\/ Thai\n+                        ((ch >= 0x0ed0) && (ch <= 0x0ed9));         \/\/ Lao\n+            case 0x0f:\n+                return false;\n+            case 0x10:\n+                return ((ch >= 0x1040) && (ch <= 0x1049));         \/\/ Tibetan\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the character is a Unicode letter.\n+     *\n+     * @param ch the character to be checked\n+     *\/\n+    public static boolean isUCLetter(int ch) {\n+        \/\/ fast check for Latin capitals and small letters\n+        if (((ch >= 'A') && (ch <= 'Z'))\n+                || ((ch >= 'a') && (ch <= 'z'))) {\n+            return true;\n+        }\n+        \/\/ rest of ISO-LATIN-1\n+        if (ch < 0x0100) {\n+            \/\/ fast check\n+            if (ch < 0x00c0) {\n+                return (ch == '_') || (ch == '$');\n+            }\n+            \/\/ various latin letters and diacritics,\n+            \/\/ but *not* the multiplication and division symbols\n+            return ((ch >= 0x00c0) && (ch <= 0x00d6))\n+                    || ((ch >= 0x00d8) && (ch <= 0x00f6))\n+                    || ((ch >= 0x00f8) && (ch <= 0x00ff));\n+        }\n+        \/\/ other non CJK alphabets and symbols, but not digits\n+        if (ch <= 0x1fff) {\n+            return !isUCDigit(ch);\n+        }\n+        \/\/ rest are letters only in five ranges:\n+        \/\/        Hiragana, Katakana, Bopomofo and Hangul\n+        \/\/        CJK Squared Words\n+        \/\/        Korean Hangul Symbols\n+        \/\/        Han (Chinese, Japanese, Korean)\n+        \/\/        Han compatibility\n+        return ((ch >= 0x3040) && (ch <= 0x318f))\n+                || ((ch >= 0x3300) && (ch <= 0x337f))\n+                || ((ch >= 0x3400) && (ch <= 0x3d2d))\n+                || ((ch >= 0x4e00) && (ch <= 0x9fff))\n+                || ((ch >= 0xf900) && (ch <= 0xfaff));\n+    }\n+\n+    \/**\n+     * Scan a comment. This method should be called once the initial \/, * and the next\n+     * character have been read.\n+     *\/\n+    private void skipComment() throws IOException {\n+        while (true) {\n+            switch (ch) {\n+                case EOF:\n+                    env.error(pos, \"eof.in.comment\");\n+                    return;\n+                case '*':\n+                    if ((ch = in.read()) == '\/') {\n+                        ch = in.read();\n+                        return;\n+                    }\n+                    break;\n+                default:\n+                    ch = in.read();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Scan a doc comment. This method should be called once the initial \/, * and * have\n+     * been read. It gathers the content of the comment (without leading spaces and '*'s)\n+     * in the string buffer.\n+     *\/\n+    @SuppressWarnings(\"empty-statement\")\n+    private String scanDocComment() throws IOException {\n+        count = 0;\n+\n+        if (ch == '*') {\n+            do {\n+                ch = in.read();\n+            } while (ch == '*');\n+            if (ch == '\/') {\n+                ch = in.read();\n+                return \"\";\n+            }\n+        }\n+        switch (ch) {\n+            case '\\n':\n+            case ' ':\n+                ch = in.read();\n+                break;\n+        }\n+\n+        boolean seenstar = false;\n+        int c = count;\n+        while (true) {\n+            switch (ch) {\n+                case EOF:\n+                    env.error(pos, \"eof.in.comment\");\n+                    return bufferString();\n+                case '\\n':\n+                    putCh('\\n');\n+                    ch = in.read();\n+                    seenstar = false;\n+                    c = count;\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                    putCh(ch);\n+                    ch = in.read();\n+                    break;\n+                case '*':\n+                    if (seenstar) {\n+                        if ((ch = in.read()) == '\/') {\n+                            ch = in.read();\n+                            count = c;\n+                            return bufferString();\n+                        }\n+                        putCh('*');\n+                    } else {\n+                        seenstar = true;\n+                        count = c;\n+                        while ((ch = in.read()) == '*');\n+                        switch (ch) {\n+                            case ' ':\n+                                ch = in.read();\n+                                break;\n+                            case '\/':\n+                                ch = in.read();\n+                                count = c;\n+                                return bufferString();\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    if (!seenstar) {\n+                        seenstar = true;\n+                    }\n+                    putCh(ch);\n+                    ch = in.read();\n+                    c = count;\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Scan a decimal at this point\n+     *\/\n+    private void scanCPRef() throws IOException {\n+        switch (ch = in.read()) {\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+            case '8':\n+            case '9': {\n+                boolean overflow = false;\n+                long value = ch - '0';\n+                count = 0;\n+                putCh(ch);                \/\/ save character in buffer\n+numberLoop:\n+                for (;;) {\n+                    switch (ch = in.read()) {\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                        case '8':\n+                        case '9':\n+                            putCh(ch);\n+                            if (overflow) {\n+                                break;\n+                            }\n+                            value = (value * 10) + (ch - '0');\n+                            overflow = (value > 0xFFFF);\n+                            break;\n+                        default:\n+                            break numberLoop;\n+                    }\n+                } \/\/ while true\n+                intValue = (int) value;\n+                stringValue = bufferString();\n+                token = Token.CPINDEX;\n+                if (overflow) {\n+                    env.error(pos, \"overflow\");\n+                }\n+                break;\n+            }\n+            default:\n+                stringValue = Character.toString((char)ch);\n+                env.error(in.pos, \"invalid.number\", stringValue);\n+                intValue = 0;\n+                token = Token.CPINDEX;\n+                ch = in.read();\n+        }\n+    } \/\/ scanCPRef()\n+\n+    \/**\n+     * Scan a number. The first digit of the number should be the current character. We\n+     * may be scanning hex, decimal, or octal at this point\n+     *\/\n+    private void scanNumber() throws IOException {\n+        boolean seenNonOctal = false;\n+        boolean overflow = false;\n+        radix = (ch == '0' ? 8 : 10);\n+        long value = ch - '0';\n+        count = 0;\n+        putCh(ch);                \/\/ save character in buffer\n+numberLoop:\n+        for (;;) {\n+            switch (ch = in.read()) {\n+                case '.':\n+                    if (radix == 16) {\n+                        break numberLoop; \/\/ an illegal character\n+                    }\n+                    scanReal();\n+                    return;\n+\n+                case '8':\n+                case '9':\n+                    \/\/ We can't yet throw an error if reading an octal.  We might\n+                    \/\/ discover we're really reading a real.\n+                    seenNonOctal = true;\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                    putCh(ch);\n+                    if (radix == 10) {\n+                        overflow = overflow || (value * 10) \/ 10 != value;\n+                        value = (value * 10) + (ch - '0');\n+                        overflow = overflow || (value - 1 < -1);\n+                    } else if (radix == 8) {\n+                        overflow = overflow || (value >>> 61) != 0;\n+                        value = (value << 3) + (ch - '0');\n+                    } else {\n+                        overflow = overflow || (value >>> 60) != 0;\n+                        value = (value << 4) + (ch - '0');\n+                    }\n+                    break;\n+                case 'd':\n+                case 'D':\n+                case 'e':\n+                case 'E':\n+                case 'f':\n+                case 'F':\n+                    if (radix != 16) {\n+                        scanReal();\n+                        return;\n+                    }\n+                \/\/ fall through\n+                case 'a':\n+                case 'A':\n+                case 'b':\n+                case 'B':\n+                case 'c':\n+                case 'C':\n+                    putCh(ch);\n+                    if (radix != 16) {\n+                        break numberLoop; \/\/ an illegal character\n+                    }\n+                    overflow = overflow || (value >>> 60) != 0;\n+                    value = (value << 4) + 10\n+                            + Character.toLowerCase((char) ch) - 'a';\n+                    break;\n+                case 'l':\n+                case 'L':\n+                    ch = in.read();        \/\/ skip over 'l'\n+                    longValue = value;\n+                    token = Token.LONGVAL;\n+                    break numberLoop;\n+                case 'x':\n+                case 'X':\n+                   \/\/ if the first character is a '0' and this is the second\n+                    \/\/ letter, then read in a hexadecimal number.  Otherwise, error.\n+                    if (count == 1 && radix == 8) {\n+                        radix = 16;\n+                        break;\n+                    } else {\n+                        \/\/ we'll get an illegal character error\n+                        break numberLoop;\n+                    }\n+                default:\n+                    intValue = (int) value;\n+                    token = Token.INTVAL;\n+                    break numberLoop;\n+            }\n+        } \/\/ while true\n+        \/\/ we have just finished reading the number.  The next thing better\n+        \/\/ not be a letter or digit.\n+        if (isUCDigit(ch) || isUCLetter(ch) || ch == '.') {\n+            env.error(in.pos, \"invalid.number\", Character.toString((char)ch));\n+            do {\n+                ch = in.read();\n+            } while (isUCDigit(ch) || isUCLetter(ch) || ch == '.');\n+            intValue = 0;\n+            token = Token.INTVAL;\n+        } else if (radix == 8 && seenNonOctal) {\n+            intValue = 0;\n+            token = Token.INTVAL;\n+            env.error(in.pos, \"invalid.octal.number\");\n+        } else if (overflow\n+                || (token == Token.INTVAL\n+                && ((radix == 10) ? (intValue - 1 < -1)\n+                        : ((value & 0xFFFFFFFF00000000L) != 0)))) {\n+            intValue = 0;        \/\/ so we don't get second overflow in Parser\n+            longValue = 0;\n+            env.error(pos, \"overflow\");\n+        }\n+    } \/\/ scanNumber()\n+\n+    \/**\n+     * Scan a float. We are either looking at the decimal, or we have already seen it and\n+     * put it into the buffer. We haven't seen an exponent. Scan a float. Should be called\n+     * with the current character is either the 'e', 'E' or '.'\n+     *\/\n+    private void scanReal() throws IOException {\n+        boolean seenExponent = false;\n+        boolean isSingleFloat = false;\n+        char lastChar;\n+        if (ch == '.') {\n+            putCh(ch);\n+            ch = in.read();\n+        }\n+\n+numberLoop:\n+        for (;; ch = in.read()) {\n+            switch (ch) {\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    putCh(ch);\n+                    break;\n+                case 'e':\n+                case 'E':\n+                    if (seenExponent) {\n+                        break numberLoop; \/\/ we'll get a format error\n+                    }\n+                    putCh(ch);\n+                    seenExponent = true;\n+                    break;\n+                case '+':\n+                case '-':\n+                    lastChar = buffer[count - 1];\n+                    if (lastChar != 'e' && lastChar != 'E') {\n+                        break numberLoop; \/\/ this isn't an error, though!\n+                    }\n+                    putCh(ch);\n+                    break;\n+                case 'f':\n+                case 'F':\n+                    ch = in.read(); \/\/ skip over 'f'\n+                    isSingleFloat = true;\n+                    break numberLoop;\n+                case 'd':\n+                case 'D':\n+                    ch = in.read(); \/\/ skip over 'd'\n+                \/\/ fall through\n+                default:\n+                    break numberLoop;\n+            } \/\/ sswitch\n+        } \/\/ loop\n+\n+        \/\/ we have just finished reading the number.  The next thing better\n+        \/\/ not be a letter or digit.\n+        if (isUCDigit(ch) || isUCLetter(ch) || ch == '.') {\n+            env.error(in.pos, \"invalid.number\", Character.toString((char)ch));\n+            do {\n+                ch = in.read();\n+            } while (isUCDigit(ch) || isUCLetter(ch) || ch == '.');\n+            doubleValue = 0;\n+            token = Token.DOUBLEVAL;\n+        } else {\n+            token = isSingleFloat ? Token.FLOATVAL : Token.DOUBLEVAL;\n+            try {\n+                lastChar = buffer[count - 1];\n+                if (lastChar == 'e' || lastChar == 'E'\n+                        || lastChar == '+' || lastChar == '-') {\n+                    env.error(in.pos - 1, \"float.format\");\n+                } else if (isSingleFloat) {\n+                    floatValue = Float.valueOf(bufferString());\n+                    if (Float.isInfinite(floatValue)) {\n+                        env.error(pos, \"overflow\");\n+                    }\n+                } else {\n+                    doubleValue = Double.valueOf(bufferString());\n+                    if (Double.isInfinite(doubleValue)) {\n+                        env.error(pos, \"overflow\");\n+                        env.error(pos, \"overflow\");\n+                    }\n+                }\n+            } catch (NumberFormatException ee) {\n+                env.error(pos, \"float.format\");\n+                doubleValue = 0;\n+                floatValue = 0;\n+            }\n+        }\n+    } \/\/ scanReal\n+\n+    \/**\n+     * Scan an escape character.\n+     *\n+     * @return the character or '\\\\'\n+     *\/\n+    private int scanEscapeChar() throws IOException {\n+        int p = in.pos;\n+\n+        switch (ch = in.read()) {\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7': {\n+                int n = ch - '0';\n+                for (int i = 2; i > 0; i--) {\n+                    switch (ch = in.read()) {\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                            n = (n << 3) + ch - '0';\n+                            break;\n+                        default:\n+                            if (n > 0xFF) {\n+                                env.error(p, \"invalid.escape.char\");\n+                            }\n+                            return n;\n+                    }\n+                }\n+                ch = in.read();\n+                if (n > 0xFF) {\n+                    env.error(p, \"invalid.escape.char\");\n+                }\n+                return n;\n+            }\n+            case 'r':\n+                ch = in.read();\n+                return '\\r';\n+            case 'n':\n+                ch = in.read();\n+                return '\\n';\n+            case 'f':\n+                ch = in.read();\n+                return '\\f';\n+            case 'b':\n+                ch = in.read();\n+                return '\\b';\n+            case 't':\n+                ch = in.read();\n+                return '\\t';\n+            case '\\\\':\n+                ch = in.read();\n+                return '\\\\';\n+            case '\\\"':\n+                ch = in.read();\n+                return '\\\"';\n+            case '\\'':\n+                ch = in.read();\n+                return '\\'';\n+            case 'u':\n+                int unich = in.convertUnicode();\n+                ch = in.read();\n+                return unich;\n+        }\n+        return '\\\\';\n+    }\n+\n+    \/**\n+     * Scan a string. The current character should be the opening \" of the string.\n+     *\/\n+    private void scanString() throws IOException {\n+        token = Token.STRINGVAL;\n+        count = 0;\n+        ch = in.read();\n+\n+        \/\/ Scan a String\n+        while (true) {\n+            switch (ch) {\n+                case EOF:\n+                    env.error(pos, \"eof.in.string\");\n+                    stringValue = bufferString();\n+                    return;\n+                case '\\n':\n+                    ch = in.read();\n+                    env.error(pos, \"newline.in.string\");\n+                    stringValue = bufferString();\n+                    return;\n+                case '\"':\n+                    ch = in.read();\n+                    stringValue = bufferString();\n+                    return;\n+                case '\\\\': {\n+                    int c = scanEscapeChar();\n+                    if (c >= 0) {\n+                        putCh((char) c);\n+                    }\n+                    break;\n+                }\n+                default:\n+                    putCh(ch);\n+                    ch = in.read();\n+                    break;\n+            }\n+        }\n+    }\n+\n+\n+    \/**\n+     * Scan an Identifier. The current character should be the first character of the\n+     * identifier.\n+     *\/\n+    private void scanIdentifier(char[] prefix) throws IOException {\n+        int firstChar;\n+        count = 0;\n+        if(prefix != null) {\n+            for(;;) {\n+                for (int i = 0; i < prefix.length; i++)\n+                    putCh(prefix[i]);\n+                ch = in.read();\n+                if (ch == '\\\\') {\n+                    ch = in.read();\n+                    if (ch == 'u') {\n+                        ch = in.convertUnicode();\n+                        if (!isUCLetter(ch) && !isUCDigit(ch)) {\n+                            prefix = new char[]{(char)ch};\n+                            continue;\n+                        }\n+                    } else if (escapingAllowed.test(ch)) {\n+                        prefix = new char[]{(char)ch};\n+                        continue;\n+                    }\n+                    int p = in.pos;\n+                    env.error(p, \"invalid.escape.char\");\n+                }\n+                break;\n+            }\n+        }\n+        firstChar = ch;\n+        boolean firstIteration = true;\n+scanloop:\n+        while (true) {\n+            putCh(ch);\n+            ch = in.read();\n+\n+            \/\/ Check to see if the annotation marker is at\n+            \/\/ the front of the identifier.\n+            if (firstIteration && firstChar == '@') {\n+                \/\/ May be a type annotation\n+                if (ch == 'T') {  \/\/ type annotation\n+                    putCh(ch);\n+                    ch = in.read();\n+                }\n+\n+                \/\/ is either a runtime visible or invisible annotation\n+                if (ch == '+' || ch == '-') {  \/\/ regular annotation\n+                    \/\/ possible annotation -\n+                    \/\/ need to eat up the '@+' or '@-'\n+                    putCh(ch);\n+                    ch = in.read();\n+                }\n+                idValue = bufferString();\n+                stringValue = idValue;\n+                token = Token.ANNOTATION;\n+                return;\n+            }\n+\n+            firstIteration = false;\n+            switch (ch) {\n+                case 'a':\n+                case 'b':\n+                case 'c':\n+                case 'd':\n+                case 'e':\n+                case 'f':\n+                case 'g':\n+                case 'h':\n+                case 'i':\n+                case 'j':\n+                case 'k':\n+                case 'l':\n+                case 'm':\n+                case 'n':\n+                case 'o':\n+                case 'p':\n+                case 'q':\n+                case 'r':\n+                case 's':\n+                case 't':\n+                case 'u':\n+                case 'v':\n+                case 'w':\n+                case 'x':\n+                case 'y':\n+                case 'z':\n+                case 'A':\n+                case 'B':\n+                case 'C':\n+                case 'D':\n+                case 'E':\n+                case 'F':\n+                case 'G':\n+                case 'H':\n+                case 'I':\n+                case 'J':\n+                case 'K':\n+                case 'L':\n+                case 'M':\n+                case 'N':\n+                case 'O':\n+                case 'P':\n+                case 'Q':\n+                case 'R':\n+                case 'S':\n+                case 'T':\n+                case 'U':\n+                case 'V':\n+                case 'W':\n+                case 'X':\n+                case 'Y':\n+                case 'Z':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                case '$':\n+                case '_':\n+                case '-':\n+                case '[':\n+                case ']':\n+                case '(':\n+                case ')':\n+                case '<':\n+                case '>':\n+                    break;\n+                case '\/': {\/\/ may be comment right after identifier\n+                    int c = in.lookForward();\n+                    if ((c == '*') || (c == '\/')) {\n+                        break scanloop; \/\/ yes, comment\n+                    }\n+                    break; \/\/ no, continue to parse identifier\n+                }\n+                case '\\\\':\n+                    ch = in.read();\n+                    if ( ch == 'u') {\n+                        ch = in.convertUnicode();\n+                        if (isUCLetter(ch) || isUCDigit(ch)) {\n+                            break;\n+                        }\n+                    } else if( escapingAllowed.test(ch)) {\n+                        break;\n+                    }\n+                    int p = in.pos;\n+                    env.error(p, \"invalid.escape.char\");\n+                default:\n+\/\/                    if ((!isUCDigit(ch)) && (!isUCLetter(ch))) {\n+                    break scanloop;\n+\/\/                    }\n+            } \/\/ end switch\n+        } \/\/ end scanloop\n+        idValue = bufferString();\n+        stringValue = idValue;\n+        token = keyword_token_ident(idValue);\n+        debugStr(format(\"##### SCANNER (scanIdent) ######## token = %s value = \\\"%s\\\"\\n\", token, idValue));\n+    } \/\/ end scanIdentifier\n+\n+\/\/==============================\n+    @SuppressWarnings(\"empty-statement\")\n+    protected final void xscan() throws IOException {\n+        docComment = null;\n+loop:\n+        for (;;) {\n+            pos = in.pos;\n+            switch (ch) {\n+                case EOF:\n+                    token = Token.EOF;\n+                    break loop;\n+                case '\\n':\n+                case ' ':\n+                case '\\t':\n+                case '\\f':\n+                    ch = in.read();\n+                    break;\n+                case '\/':\n+                    switch (ch = in.read()) {\n+                        case '\/':\n+                            \/\/ Parse a \/\/ comment\n+                            while (((ch = in.read()) != EOF) && (ch != '\\n'));\n+                            break;\n+                        case '*':\n+                            ch = in.read();\n+                            if (ch == '*') {\n+                                docComment = scanDocComment();\n+                            } else {\n+                                skipComment();\n+                            }\n+                            break;\n+                        default:\n+                            token = Token.DIV;\n+                            break loop;\n+                    }\n+                    break;\n+                case '\"':\n+                    scanString();\n+                    break loop;\n+                case '-':\n+                    intValue = -1;\n+                    token = Token.SIGN;\n+                    ch = in.read();\n+                    break loop;\n+                case '+':\n+                    intValue = +1;\n+                    ch = in.read();\n+                    token = Token.SIGN;\n+                    break loop;\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    scanNumber();\n+                    break loop;\n+                case '.':\n+                    switch (ch = in.read()) {\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                        case '8':\n+                        case '9':\n+                            count = 0;\n+                            putCh('.');\n+                            scanReal();\n+                            break;\n+                        default:\n+                            token = Token.FIELD;\n+                    }\n+                    break loop;\n+                case '{':\n+                    ch = in.read();\n+                    token = Token.LBRACE;\n+                    break loop;\n+                case '}':\n+                    ch = in.read();\n+                    token = Token.RBRACE;\n+                    break loop;\n+                case ',':\n+                    ch = in.read();\n+                    token = Token.COMMA;\n+                    break loop;\n+                case ';':\n+                    ch = in.read();\n+                    token = Token.SEMICOLON;\n+                    break loop;\n+                case ':':\n+                    ch = in.read();\n+                    token = Token.COLON;\n+                    break loop;\n+                case '=':\n+                    if ((ch = in.read()) == '=') {\n+                        ch = in.read();\n+                        token = Token.EQ;\n+                        break loop;\n+                    }\n+                    token = Token.ASSIGN;\n+                    break loop;\n+                case 'a':\n+                case 'b':\n+                case 'c':\n+                case 'd':\n+                case 'e':\n+                case 'f':\n+                case 'g':\n+                case 'h':\n+                case 'i':\n+                case 'j':\n+                case 'k':\n+                case 'l':\n+                case 'm':\n+                case 'n':\n+                case 'o':\n+                case 'p':\n+                case 'q':\n+                case 'r':\n+                case 's':\n+                case 't':\n+                case 'u':\n+                case 'v':\n+                case 'w':\n+                case 'x':\n+                case 'y':\n+                case 'z':\n+                case 'A':\n+                case 'B':\n+                case 'C':\n+                case 'D':\n+                case 'E':\n+                case 'F':\n+                case 'G':\n+                case 'H':\n+                case 'I':\n+                case 'J':\n+                case 'K':\n+                case 'L':\n+                case 'M':\n+                case 'N':\n+                case 'O':\n+                case 'P':\n+                case 'Q':\n+                case 'R':\n+                case 'S':\n+                case 'T':\n+                case 'U':\n+                case 'V':\n+                case 'W':\n+                case 'X':\n+                case 'Y':\n+                case 'Z':\n+                case '$':\n+                case '_':\n+                case '@':\n+                case '[':\n+                case ']':\n+                case '(':\n+                case ')':\n+                case '<':\n+                case '>':\n+                    scanIdentifier(null);\n+                    break loop;\n+                case '\\u001a':\n+                    \/\/ Our one concession to DOS.\n+                    if ((ch = in.read()) == EOF) {\n+                        token = Token.EOF;\n+                        break loop;\n+                    }\n+                    env.error(pos, \"funny.char\");\n+                    ch = in.read();\n+                    break;\n+                case '#':\n+                    int c = in.lookForward();\n+                    if (c == '{') {\n+                        \/\/ '#' char denotes a \"paramMethod name\" token\n+                        ch = in.read();\n+                        token = Token.PARAM_NAME;\n+                        break loop;\n+                    }\n+                    \/\/ otherwise, it is a normal cpref\n+                    scanCPRef();\n+                    break loop;\n+                case '\\\\':\n+                    ch = in.read();\n+                    if ( ch == 'u') {\n+                        ch = in.convertUnicode();\n+                        if (isUCLetter(ch)) {\n+                            scanIdentifier(null);\n+                            break loop;\n+                        }\n+                    } else if( escapingAllowed.test(ch)) {\n+                        scanIdentifier(new char[]{'\\\\', (char)ch});\n+                        break loop;\n+                    }\n+\/\/                    if ((ch = in.read()) == 'u') {\n+\/\/                        ch = in.convertUnicode();\n+\/\/                        if (isUCLetter(ch)) {\n+\/\/                            scanIdentifier();\n+\/\/                            break loop;\n+\/\/                        }\n+\/\/                    }\n+                default:\n+                    env.out.println(\"funny.char:\" + env.lineNumber(pos) + \"\/\" + (pos & ((1 << OFFSETBITS) - 1)));\n+                    env.error(pos, \"funny.char\");\n+                    ch = in.read();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void debugScan(String dbstr) {\n+        if (token == null) {\n+            env.traceln(dbstr + \"<<<NULL TOKEN>>>\");\n+            return;\n+        }\n+        env.trace(dbstr + token);\n+        switch (token) {\n+            case IDENT:\n+                env.traceln(\" = '\" + stringValue + \"' {idValue = '\" + idValue + \"'}\");\n+                break;\n+            case STRINGVAL:\n+                env.traceln(\" = {stringValue}: \\\"\" + stringValue + \"\\\"\");\n+                break;\n+            case INTVAL:\n+                env.traceln(\" = {intValue}: \" + intValue + \"}\");\n+                break;\n+            case FLOATVAL:\n+                env.traceln(\" = {floatValue}: \" + floatValue);\n+                break;\n+            case DOUBLEVAL:\n+                env.traceln(\" = {doubleValue}: \" + doubleValue);\n+                break;\n+            default:\n+                env.traceln(\"\");\n+        }\n+    }\n+\n+    private Predicate<Integer> noFunc = (ch)-> false;\n+    private Predicate<Integer> yesAndProcessFunc = (ch) -> {\n+        boolean res = ((ch == '\\\\') || (ch == ':') || (ch == '@'));\n+        if (res)\n+            putCh('\\\\');\n+        return res;\n+    };\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Scanner.java","additions":1209,"deletions":0,"binary":false,"changes":1209,"status":"added"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import java.io.IOException;\n+\n+\/**\n+ *\n+ *\/\n+public class StackMapData implements Data {\n+\n+    \/**\n+     *\n+     *\/\n+    static public class StackMapItem1 implements Data {\n+\n+        StackMapType itemType;\n+\n+        StackMapItem1(StackMapType itemType) {\n+            this.itemType = itemType;\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte(itemType.value());\n+        }\n+    }\n+\n+    \/**\n+     *\n+     *\/\n+    static public class StackMapItem2 implements Data {\n+\n+        StackMapType itemType;\n+        Argument arg;\n+\n+        StackMapItem2(StackMapType itemType, Argument arg) {\n+            this.itemType = itemType;\n+            this.arg = arg;\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 3;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte(itemType.value());\n+            out.writeShort(arg.arg);\n+        }\n+    }\n+\n+    int pc;\n+    int offset;\n+    int type;\n+    String stackFrameType = null;\n+    boolean isStackMapTable = false;\n+    DataVector localsMap, stackMap;\n+    Environment env;\n+\n+    StackMapData(Environment env) {\n+        this.env = env;\n+    }\n+\n+    void setPC(int pc) {\n+        this.pc = pc;\n+    }\n+\n+    void setOffset(int offset) {\n+        this.offset = offset;\n+    }\n+\n+    void setOffset(StackMapData prevFrame) {\n+        offset = (prevFrame == null) ? pc : (pc - prevFrame.pc - 1);\n+    }\n+\n+    void setStackFrameType(String stackFrameType) {\n+        this.stackFrameType = stackFrameType;\n+\n+        if (stackFrameType != null) {\n+            type = stackMapFrameTypeValue(stackFrameType);\n+        }\n+\n+        if (stackFrameType == null || type == -1) {\n+            env.error(pc, \"invalid.stack.frame.type\", stackFrameType, \"\" + type);\n+        }\n+    }\n+\n+    void setIsStackMapTable(boolean isStackMapTable) {\n+        this.isStackMapTable = isStackMapTable;\n+    }\n+\n+    void setLocalsMap(DataVector localsMap) {\n+        this.localsMap = localsMap;\n+    }\n+\n+    void setStackMap(DataVector stackMap) {\n+        this.stackMap = stackMap;\n+    }\n+\n+    @Override\n+    public int getLength() {\n+        int res = 0;\n+        StackMapFrameType frame_type = StackMapFrameType.FULL_FRAME;\n+        \/\/    int frame_type = FULL_FRAME;\n+\n+        if (isStackMapTable) {\n+            if (stackFrameType != null) {\n+                frame_type = stackMapFrameType(type);\n+            }\n+            res += 1;\n+        }\n+\n+        switch (frame_type) {\n+            case SAME_FRAME:\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_FRAME:\n+                res += stackMap.getLength() - 2;\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_EXTENDED_FRAME:\n+                res += stackMap.getLength();\n+                break;\n+            case CHOP_1_FRAME:\n+            case CHOP_2_FRAME:\n+            case CHOP_3_FRAME:\n+                res += 2;\n+                break;\n+            case SAME_FRAME_EX:\n+                res += 2;\n+                break;\n+            case APPEND_FRAME:\n+                res += 2 + (localsMap == null ? 0 : (localsMap.getLength() - 2));\n+                break;\n+            case FULL_FRAME:\n+                res += 2;\n+                res += (localsMap == null ? 2 : localsMap.getLength());\n+                res += (stackMap == null ? 2 : stackMap.getLength());\n+                break;\n+            default:\n+                ;\n+        }\n+        return res;\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        StackMapFrameType frame_type = StackMapFrameType.FULL_FRAME;\n+\n+        if (isStackMapTable) {\n+            if (stackFrameType != null) {\n+                frame_type = stackMapFrameType(type);\n+            }\n+        }\n+\n+        switch (frame_type) {\n+            case SAME_FRAME:\n+                if (offset >= 64) {\n+                    env.error(pc, \"invalid.offset.same.frame\", \"\" + offset);\n+                }\n+                out.writeByte(offset);\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_FRAME:\n+                if (stackMap == null) {\n+                    env.error(pc, \"no.stack.map.same.locals\");\n+                    break;\n+                }\n+\n+                if (stackMap.elements.size() != 1) {\n+                    env.error(pc, \"should.be.only.one.stack.map.element\");\n+                    break;\n+                }\n+\n+                if (offset >= 64) {\n+                    env.error(pc, \"invalid.offset.same.locals\", \"\" + offset);\n+                    break;\n+                }\n+                out.writeByte(frame_type.value() + offset);\n+                stackMap.writeElements(out);\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_EXTENDED_FRAME:\n+                if (stackMap == null) {\n+                    env.error(pc, \"no.stack.map.same.locals\");\n+                    break;\n+                }\n+\n+                if (stackMap.elements.size() != 1) {\n+                    env.error(pc, \"should.be.only.one.stack.map.element\");\n+                    break;\n+                }\n+                out.writeByte(frame_type.value());\n+                out.writeShort(offset);\n+                stackMap.writeElements(out);\n+                break;\n+            case CHOP_1_FRAME:\n+            case CHOP_2_FRAME:\n+            case CHOP_3_FRAME:\n+            case SAME_FRAME_EX:\n+                boolean error = false;\n+\n+                if (stackMap != null) {\n+                    env.error(pc, \"unexpected.stack.maps\");\n+                    error = true;\n+                }\n+\n+                if (localsMap != null) {\n+                    env.error(pc, \"unexpected.locals.maps\");\n+                    error = true;\n+                }\n+\n+                if (error) {\n+                    break;\n+                }\n+                out.writeByte(frame_type.value());\n+                out.writeShort(offset);\n+                break;\n+            case APPEND_FRAME:\n+                if (localsMap == null) {\n+                    env.error(pc, \"no.locals.map.append\");\n+                    break;\n+                }\n+\n+                if (localsMap.elements.size() > 3) {\n+                    env.error(pc, \"more.locals.map.elements\");\n+                    break;\n+                }\n+                out.writeByte(frame_type.value() + localsMap.elements.size() - 1);\n+                out.writeShort(offset);\n+                localsMap.writeElements(out);\n+                break;\n+            case FULL_FRAME:\n+                if (isStackMapTable) {\n+                    out.writeByte(frame_type.value());\n+                    out.writeShort(offset);\n+                } else {\n+                    out.writeShort(pc);\n+                }\n+\n+                if (localsMap == null) {\n+                    out.writeShort(0);\n+                } else {\n+                    localsMap.write(out);\n+                }\n+\n+                if (stackMap == null) {\n+                    out.writeShort(0);\n+                } else {\n+                    stackMap.write(out);\n+                }\n+                break;\n+            default:\n+                env.error(pc, \"invalid.stack.frame.type\", \"\" + frame_type);\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/StackMapData.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+\/**\n+ *\n+ *\/\n+class SwitchTable {\n+\n+    Argument deflabel = null;\n+    ArrayList<Argument> labels = new ArrayList<>();\n+    ArrayList<Integer> keys = new ArrayList<>();\n+\n+\/\/ for tableswitch:\n+    Argument[] resLabels;\n+    int high, low;\n+\n+    int pc, pad;\n+    Environment env;\n+\n+    SwitchTable(Environment env) {\n+        this.env = env;\n+    }\n+\n+    void addEntry(int key, Argument label) {\n+        keys.add(key);\n+        labels.add(label);\n+    }\n+\n+\/\/ for lookupswitch:\n+    int calcLookupSwitch(int pc) {\n+        this.pc = pc;\n+        pad = ((3 - pc) & 0x3);\n+        int len = 1 + pad + (keys.size() + 1) * 8;\n+        if (deflabel == null) {\n+            deflabel = new Argument(pc + len);\n+        }\n+        return len;\n+    }\n+\n+    void writeLookupSwitch(CheckedDataOutputStream out) throws IOException {\n+        env.traceln(\"  writeLookupSwitch: pc=\" + pc + \" pad=\" + pad + \" deflabel=\" + deflabel.arg);\n+        int k;\n+        for (k = 0; k < pad; k++) {\n+            out.writeByte(0);\n+        }\n+        out.writeInt(deflabel.arg - pc);\n+        out.writeInt(keys.size());\n+        for (k = 0; k < keys.size(); k++) {\n+            out.writeInt(keys.get(k));\n+            out.writeInt((labels.get(k)).arg - pc);\n+        }\n+    }\n+\n+    int recalcTableSwitch(int pc) {\n+        int k;\n+        int numpairs = keys.size();\n+        int high1 = Integer.MIN_VALUE, low1 = Integer.MAX_VALUE;\n+        int numslots = 0;\n+        if (numpairs > 0) {\n+            for (k = 0; k < numpairs; k++) {\n+                int key = keys.get(k);\n+                if (key > high1) {\n+                    high1 = key;\n+                }\n+                if (key < low1) {\n+                    low1 = key;\n+                }\n+            }\n+            numslots = high1 - low1 + 1;\n+        }\n+\/\/      if (numslots>2000) env.error(\"long.switchtable\", \"2000\");\n+        env.traceln(\"  recalcTableSwitch: low=\" + low1 + \" high=\" + high1);\n+        this.pc = pc;\n+        pad = ((3 - pc) & 0x3);\n+        int len = 1 + pad + (numslots + 3) * 4;\n+        if (deflabel == null) {\n+            deflabel = new Argument(pc + len);\n+        }\n+        Argument[] resLabels1 = new Argument[numslots];\n+        for (k = 0; k < numslots; k++) {\n+            resLabels1[k] = deflabel;\n+        }\n+        for (k = 0; k < numpairs; k++) {\n+            env.traceln(\"   keys.data[\" + k + \"]=\" + keys.get(k));\n+            resLabels1[keys.get(k) - low1] = labels.get(k);\n+        }\n+        this.resLabels = resLabels1;\n+        this.labels = null;\n+        this.keys = null;\n+        this.high = high1;\n+        this.low = low1;\n+        return len;\n+    }\n+\n+    void writeTableSwitch(CheckedDataOutputStream out) throws IOException {\n+        int k;\n+        for (k = 0; k < pad; k++) {\n+            out.writeByte(0);\n+        }\n+        out.writeInt(deflabel.arg - pc);\n+        out.writeInt(low);\n+        out.writeInt(high);\n+        for (k = 0; k < resLabels.length; k++) {\n+            out.writeInt(resLabels[k].arg - pc);\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/SwitchTable.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,688 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.PrintWriter;\n+import java.util.HashMap;\n+\n+\/**\n+ *\n+ * Tables\n+ *\n+ * The classes in Tables are following a Singleton Pattern. These classes are Enums, and\n+ * they are contained in private hash maps (lookup tables and reverse lookup tables).\n+ * These hash maps all have public accessors, which clients use to look-up enums.\n+ *\n+ * Tokens in this table carry no external state, and are typically treated as constants.\n+ * They do not need to be reset.\n+ *\n+ *\/\n+public class Tables {\n+\n+    public static final int JAVA_MAGIC = 0xCAFEBABE;\n+    \/**\n+     * Lookup-tables for various types.\n+     *\/\n+    private static HashMap<String, AttrTag> NameToAttrTag = new HashMap<>(9);\n+    private static HashMap<Integer, AttrTag> AttrTags = new HashMap<>(9);\n+\n+    private static HashMap<String, SubTag> NameToSubTag = new HashMap<>(9);\n+    private static HashMap<Integer, SubTag> SubTags = new HashMap<>(9);\n+\n+    private static HashMap<String, BasicType> NameToBasicType = new HashMap<>(10);\n+    private static HashMap<Integer, BasicType> BasicTypes = new HashMap<>(10);\n+\n+    private static HashMap<String, AnnotElemType> NameToAnnotElemType = new HashMap<>(10);\n+    private static HashMap<Character, AnnotElemType> AnnotElemTypes = new HashMap<>(10);\n+\n+    private static HashMap<String, StackMapType> KeyToStackMapType = new HashMap<>(10);\n+    private static HashMap<String, StackMapType> NameToStackMapType = new HashMap<>(10);\n+    private static HashMap<Integer, StackMapType> StackMapTypes = new HashMap<>(10);\n+\n+    private static HashMap<String, StackMapFrameType> NameToStackMapFrameType = new HashMap<>(10);\n+    private static HashMap<Integer, StackMapFrameType> StackMapFrameTypes = new HashMap<>(10);\n+\n+    private static HashMap<String, ConstType> NameToConstantType = new HashMap<>(ConstType.maxTag);\n+    private static HashMap<Integer, ConstType> ConstantTypes = new HashMap<>(ConstType.maxTag);\n+\n+    static {\n+        \/\/ register all of the tokens\n+        for (ConstType ct : ConstType.values()) {\n+            registerConstantType(ct);\n+        }\n+\n+        \/* Type codes for SubTags *\/\n+        for (AttrTag at : AttrTag.values()) {\n+            registerAttrtag(at);\n+        }\n+\n+        \/* Type codes for SubTags *\/\n+        for (SubTag st : SubTag.values()) {\n+            registerSubtag(st);\n+        }\n+\n+        \/* Type codes for BasicTypes *\/\n+        for (BasicType bt : BasicType.values()) {\n+            registerBasicType(bt);\n+        }\n+\n+        \/* Type codes for BasicTypes *\/\n+        for (AnnotElemType aet : AnnotElemType.values()) {\n+            registerAnnotElemType(aet);\n+        }\n+\n+        \/* Type codes for StackMapTypes *\/\n+        for (StackMapType smt : StackMapType.values()) {\n+            registerStackMapType(smt);\n+        }\n+\n+        \/* Type codes for StackMapFrame attribute *\/\n+        for (StackMapFrameType smft : StackMapFrameType.values()) {\n+            registerStackMapFrameType(smft);\n+        }\n+\n+    }\n+\n+    \/**\n+     * ConstType\n+     *\n+     * A (typed) tag (constant) representing the type of Constant in the Constant Pool.\n+     *\/\n+    static public enum ConstType {\n+        CONSTANT_ZERO                       (-3, \"CONSTANT_ZERO\", \"\"),\n+        CONSTANT_UTF8                       (1, \"CONSTANT_UTF8\", \"Asciz\"),\n+        CONSTANT_UNICODE                    (2, \"CONSTANT_UNICODE\", \"\"),\n+        CONSTANT_INTEGER                    (3, \"CONSTANT_INTEGER\", \"int\"),\n+        CONSTANT_FLOAT                      (4, \"CONSTANT_FLOAT\", \"float\"),\n+        CONSTANT_LONG                       (5, \"CONSTANT_LONG\", \"long\"),\n+        CONSTANT_DOUBLE                     (6, \"CONSTANT_DOUBLE\", \"double\"),\n+        CONSTANT_CLASS                      (7, \"CONSTANT_CLASS\", \"class\"),\n+        CONSTANT_STRING                     (8, \"CONSTANT_STRING\", \"String\"),\n+        CONSTANT_FIELD                      (9, \"CONSTANT_FIELD\", \"Field\"),\n+        CONSTANT_METHOD                     (10, \"CONSTANT_METHOD\", \"Method\"),\n+        CONSTANT_INTERFACEMETHOD            (11, \"CONSTANT_INTERFACEMETHOD\", \"InterfaceMethod\"),\n+        CONSTANT_NAMEANDTYPE                (12, \"CONSTANT_NAMEANDTYPE\", \"NameAndType\"),\n+        \/\/ Constant 13 reserved\n+        \/\/ Constant 14 reserved\n+        CONSTANT_METHODHANDLE               (15, \"CONSTANT_METHODHANDLE\", \"MethodHandle\"),\n+        CONSTANT_METHODTYPE                 (16, \"CONSTANT_METHODTYPE\", \"MethodType\"),\n+        CONSTANT_DYNAMIC                    (17, \"CONSTANT_DYNAMIC\", \"Dynamic\"),\n+        CONSTANT_INVOKEDYNAMIC              (18, \"CONSTANT_INVOKEDYNAMIC\", \"InvokeDynamic\"),\n+        CONSTANT_MODULE                     (19, \"CONSTANT_MODULE\",        \"Module\"),\n+        CONSTANT_PACKAGE                    (20, \"CONSTANT_PACKAGE\",       \"Package\");\n+\n+        static final public int maxTag = 20;\n+\n+        private final int value;\n+        private final String parseKey;\n+        private final String printval;\n+\n+        ConstType(int val, String print, String parse) {\n+            value = val;\n+            parseKey = parse;\n+            printval = print;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public String parseKey() {\n+            return parseKey;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+\n+        public void print(PrintWriter out) {\n+            out.print(parseKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<\" + printval + \"> [\" + Integer.toString(value) + \"]\";\n+        }\n+    };\n+\n+    static public ConstType tag(int i) {\n+        return ConstantTypes.get(i);\n+    }\n+\n+    static public ConstType tag(String parsekey) {\n+        return NameToConstantType.get(parsekey);\n+    }\n+\n+    private static void registerConstantType(ConstType tt) {\n+        NameToConstantType.put(tt.parseKey, tt);\n+        ConstantTypes.put(tt.value, tt);\n+    }\n+\n+    \/**\n+     * Attribute descriptor enums\n+     *\/\n+    static public enum AttrTag {\n+\n+        \/\/ Constant for ME Spec (StackMap does not appear in SE VM Spec)\n+        ATT_Unrecognized                            (0, \"ATT_Unrecognized\", \"\"),\n+        ATT_StackMap                                (1, \"ATT_StackMap\", \"StackMap\"),\n+        \/\/ Numbers corespond to VM spec (chapter 4.7.X)\n+        ATT_ConstantValue                           (2, \"ATT_ConstantValue\", \"ConstantValue\"),\n+        ATT_Code                                    (3, \"ATT_Code\", \"Code\"),\n+        ATT_StackMapTable                           (4, \"ATT_StackMapTable\", \"StackMapTable\"),\n+        ATT_Exceptions                              (5, \"ATT_Exceptions\", \"Exceptions\"),\n+        ATT_InnerClasses                            (6, \"ATT_InnerClasses\", \"InnerClasses\"),\n+        ATT_EnclosingMethod                         (7, \"ATT_EnclosingMethod\", \"EnclosingMethod\"),\n+        ATT_Synthetic                               (8, \"ATT_Synthetic\", \"Synthetic\"),\n+        ATT_Signature                               (9, \"ATT_Signature\", \"Signature\"),\n+        ATT_SourceFile                              (10, \"ATT_SourceFile\", \"SourceFile\"),\n+        ATT_SourceDebugExtension                    (11, \"ATT_SourceDebugExtension\", \"SourceDebugExtension\"),\n+        ATT_LineNumberTable                         (12, \"ATT_LineNumberTable\", \"LineNumberTable\"),\n+        ATT_LocalVariableTable                      (13, \"ATT_LocalVariableTable\", \"LocalVariableTable\"),\n+        ATT_LocalVariableTypeTable                  (14, \"ATT_LocalVariableTypeTable\", \"LocalVariableTypeTable\"),\n+        ATT_Deprecated                              (15, \"ATT_Deprecated\", \"Deprecated\"),\n+        ATT_RuntimeVisibleAnnotations               (16, \"ATT_RuntimeVisibleAnnotations\", \"RuntimeVisibleAnnotations\"),\n+        ATT_RuntimeInvisibleAnnotations             (17, \"ATT_RuntimeInvisibleAnnotations\", \"RuntimeInvisibleAnnotations\"),\n+        ATT_RuntimeVisibleParameterAnnotations      (18, \"ATT_RuntimeVisibleParameterAnnotations\", \"RuntimeVisibleParameterAnnotations\"),\n+        ATT_RuntimeInvisibleParameterAnnotations    (19, \"ATT_RuntimeInvisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\"),\n+        ATT_AnnotationDefault                       (20, \"ATT_AnnotationDefault\", \"AnnotationDefault\"),\n+        ATT_BootstrapMethods                        (21, \"ATT_BootstrapMethods\", \"BootstrapMethods\"),\n+        ATT_RuntimeVisibleTypeAnnotations           (22, \"ATT_RuntimeVisibleTypeAnnotations\", \"RuntimeVisibleTypeAnnotations\"),\n+        ATT_RuntimeInvisibleTypeAnnotations         (23, \"ATT_RuntimeInvisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\"),\n+        ATT_MethodParameters                        (24, \"ATT_MethodParameters\", \"MethodParameters\"),\n+        ATT_Module                                  (25, \"ATT_Module\",  \"Module\"),\n+        ATT_Version                                 (26, \"ATT_Version\", \"Version\"),\n+        ATT_TargetPlatform                          (27, \"ATT_TargetPlatform\", \"TargetPlatform\"),\n+        ATT_MainClass                               (28, \"ATT_MainClass\", \"MainClass\"),\n+        ATT_ModulePackages                          (29, \"ATT_ModulePackages\", \"ModulePackages\"),\n+        ATT_ModuleMainClass                         (30, \"ATT_ModuleMainClass\", \"ModuleMainClass\"),\n+        ATT_ModuleTarget                            (31, \"ATT_ModuleTarget\", \"ModuleTarget\"),\n+        \/\/ JEP 181: class file 55.0\n+        ATT_NestHost                                (32, \"ATT_NestHost\", \"NestHost\"),\n+        ATT_NestMembers                             (33, \"ATT_NestMembers\", \"NestMembers\"),\n+        \/\/  JEP 359 Record(Preview): class file 58.65535\n+        \/\/  Record_attribute {\n+        \/\/    u2 attribute_name_index;\n+        \/\/    u4 attribute_length;\n+        \/\/    u2 components_count;\n+        \/\/    component_info components[components_count];\n+        \/\/ }\n+        ATT_Record                                  (34, \"ATT_Record\", \"Record\"),\n+        \/\/ JEP 360 (Sealed types): class file 59.65535\n+        \/\/ PermittedSubclasses_attribute {\n+        \/\/    u2 attribute_name_index;\n+        \/\/    u4 attribute_length;\n+        \/\/    u2 number_of_classes;\n+        \/\/    u2 classes[number_of_classes];\n+        \/\/ }\n+        ATT_PermittedSubclasses                       (35, \"ATT_PermittedSubclasses\", \"PermittedSubclasses\");\n+\n+        private final Integer value;\n+        private final String printval;\n+        private final String parsekey;\n+\n+        AttrTag(Integer val, String print, String parse) {\n+            value = val;\n+            printval = print;\n+            parsekey = parse;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+\n+        public String parsekey() {\n+            return parsekey;\n+        }\n+    }\n+\n+    private static void registerAttrtag(AttrTag tg) {\n+        NameToAttrTag.put(tg.parsekey, tg);\n+        AttrTags.put(tg.value, tg);\n+    }\n+\n+    public static AttrTag attrtag(int val) {\n+        AttrTag tg = AttrTags.get(val);\n+        if (tg == null) {\n+            tg = AttrTag.ATT_Unrecognized;\n+        }\n+        return tg;\n+    }\n+\n+    public static AttrTag attrtag(String idValue) {\n+        AttrTag tg = NameToAttrTag.get(idValue);\n+        if (tg == null) {\n+            tg = AttrTag.ATT_Unrecognized;\n+        }\n+        return tg;\n+    }\n+\n+    public static String attrtagName(int subtag) {\n+        AttrTag tg = AttrTags.get(subtag);\n+        return tg.parsekey;\n+    }\n+\n+    public static int attrtagValue(String idValue) {\n+        AttrTag tg = attrtag(idValue);\n+        return tg.value;\n+    }\n+\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * SubTag enums\n+     *\/\n+    static public enum SubTag {\n+        REF_GETFIELD            (1, \"REF_getField\"),\n+        REF_GETSTATIC           (2, \"REF_getStatic\"),\n+        REF_PUTFIELD            (3, \"REF_putField\"),\n+        REF_PUTSTATIC           (4, \"REF_putStatic\"),\n+        REF_INVOKEVIRTUAL       (5, \"REF_invokeVirtual\"),\n+        REF_INVOKESTATIC        (6, \"REF_invokeStatic\"),\n+        REF_INVOKESPECIAL       (7, \"REF_invokeSpecial\"),\n+        REF_NEWINVOKESPECIAL    (8, \"REF_newInvokeSpecial\"),\n+        REF_INVOKEINTERFACE     (9, \"REF_invokeInterface\");\n+\n+        private final Integer value;\n+        private final String printval;\n+\n+        SubTag(Integer val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+\n+        public Integer value() {\n+            return value;\n+        }\n+    }\n+\n+    private static void registerSubtag(SubTag tg) {\n+        NameToSubTag.put(tg.printval, tg);\n+        SubTags.put(tg.value, tg);\n+    }\n+\n+    public static SubTag subtag(String subtag) {\n+        return NameToSubTag.get(subtag);\n+    }\n+\n+    public static SubTag subtag(int subtag) {\n+        return SubTags.get(subtag);\n+    }\n+\n+    public static String subtagName(int subtag) {\n+        String retval = null;\n+        SubTag tg = SubTags.get(subtag);\n+        if (tg != null) {\n+            retval = tg.printval;\n+        }\n+        return retval;\n+    }\n+\n+    public static int subtagValue(String idValue) {\n+        int retval = 0;\n+        SubTag tg = NameToSubTag.get(idValue);\n+        if (tg != null) {\n+            retval = tg.value;\n+        }\n+        return retval;\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * BasicType enums\n+     *\/\n+    static public enum BasicType {\n+        T_INT       (0x0000000a, \"int\"),\n+        T_LONG      (0x0000000b, \"long\"),\n+        T_FLOAT     (0x00000006, \"float\"),\n+        T_DOUBLE    (0x00000007, \"double\"),\n+        T_CLASS     (0x00000002, \"class\"),\n+        T_BOOLEAN   (0x00000004, \"boolean\"),\n+        T_CHAR      (0x00000005, \"char\"),\n+        T_BYTE      (0x00000008, \"byte\"),\n+        T_SHORT     (0x00000009, \"short\");\n+\n+        private final Integer value;\n+        private final String printval;\n+\n+        BasicType(Integer val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+    }\n+\n+    private static void registerBasicType(BasicType typ) {\n+        NameToBasicType.put(typ.printval, typ);\n+        BasicTypes.put(typ.value, typ);\n+    }\n+\n+    public static BasicType basictype(String idValue) {\n+        return NameToBasicType.get(idValue);\n+    }\n+\n+    public static BasicType basictype(int subtag) {\n+        return BasicTypes.get(subtag);\n+    }\n+\n+    public static String basictypeName(int subtag) {\n+        String retval = null;\n+        BasicType tg = BasicTypes.get(subtag);\n+        if (tg != null) {\n+            retval = tg.printval;\n+        }\n+        return retval;\n+    }\n+\n+    public static int basictypeValue(String idValue) {\n+        int retval = -1;\n+        BasicType tg = NameToBasicType.get(idValue);\n+        if (tg != null) {\n+            retval = tg.value;\n+        }\n+        return retval;\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * AnnotElemType enums\n+     *\/\n+    static public enum AnnotElemType {\n+\n+        AE_BYTE         ('B', \"byte\"),\n+        AE_CHAR         ('C', \"char\"),\n+        AE_SHORT        ('S', \"short\"),\n+        AE_INT          ('I', \"int\"),\n+        AE_LONG         ('J', \"long\"),\n+        AE_FLOAT        ('F', \"float\"),\n+        AE_DOUBLE       ('D', \"double\"),\n+        AE_BOOLEAN      ('Z', \"boolean\"),\n+        AE_STRING       ('s', \"string\"),\n+        AE_ENUM         ('e', \"enum\"),\n+        AE_CLASS        ('c', \"class\"),\n+        AE_ANNOTATION   ('@', \"annotation\"),\n+        AE_ARRAY        ('[', \"array\"),\n+        AE_UNKNOWN      ((char)0, \"unknown\");\n+\n+        private char value;\n+        private final String printval;\n+\n+        AnnotElemType(char val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        public char val() {\n+            return value;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+    }\n+\n+    private static void registerAnnotElemType(AnnotElemType typ) {\n+        NameToAnnotElemType.put(typ.printval, typ);\n+        AnnotElemTypes.put(typ.value, typ);\n+    }\n+\n+    public static AnnotElemType annotElemType(String idValue) {\n+        return NameToAnnotElemType.get(idValue);\n+    }\n+\n+    public static AnnotElemType annotElemType(char subtag) {\n+        AnnotElemType type = AnnotElemTypes.get(subtag);\n+        if ( type == null ) {\n+            type = AnnotElemType.AE_UNKNOWN;\n+        }\n+        return type;\n+    }\n+\n+    public static String annotElemTypeName(char subtag) {\n+        String retval = null;\n+        AnnotElemType tg = AnnotElemTypes.get(subtag);\n+        if (tg != null) {\n+            retval = tg.printval;\n+        }\n+        return retval;\n+    }\n+\n+    public static char annotElemTypeVal(String idValue) {\n+        char retval = 0;\n+        AnnotElemType tg = NameToAnnotElemType.get(idValue);\n+        if (tg != null) {\n+            retval = tg.value;\n+        }\n+        return retval;\n+    }\n+\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * MapTypes table. These constants are used in stackmap pseudo-instructions only.\n+     *\/\n+    static public enum StackMapType {\n+        \/* Type codes for StackMap attribute *\/\n+        ITEM_Bogus      (0,     \"bogus\",    \"B\"),           \/\/ an unknown or uninitialized value\n+        ITEM_Integer    (1,     \"int\",      \"I\"),           \/\/ a 32-bit integer\n+        ITEM_Float      (2,     \"float\",    \"F\"),           \/\/ not used\n+        ITEM_Double     (3,     \"double\",   \"D\"),           \/\/ not used\n+        ITEM_Long       (4,     \"long\",     \"L\"),           \/\/ a 64-bit integer\n+        ITEM_Null       (5,     \"null\",     \"N\"),           \/\/ the type of null\n+        ITEM_InitObject (6,     \"this\",     \"IO\"),          \/\/ \"this\" in constructor\n+        ITEM_Object     (7,     \"CP\",       \"O\"),           \/\/ followed by 2-byte index of class name\n+        ITEM_NewObject  (8,     \"at\",       \"NO\"),          \/\/ followed by 2-byte ref to \"new\"\n+        ITEM_UNKNOWN    (null,  \"UNKNOWN\",  \"UNKNOWN\");     \/\/ placeholder for wrong types\n+\n+        private Integer value;\n+        private final String printval;\n+        private final String parsekey;\n+\n+        StackMapType(Integer val, String print, String parse) {\n+            value = val;\n+            printval = print;\n+            parsekey = parse;\n+        }\n+\n+        public String parsekey() {\n+            return parsekey;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+\n+        public Integer value() {\n+            return value;\n+        }\n+    }\n+\n+    private static void registerStackMapType(StackMapType typ) {\n+        KeyToStackMapType.put(typ.parsekey, typ);\n+        NameToStackMapType.put(typ.printval, typ);\n+        StackMapTypes.put(typ.value, typ);\n+    }\n+\n+    public static StackMapType stackMapType(int subtag, PrintWriter out) {\n+        StackMapType type = StackMapTypes.get(subtag);\n+        if (type == null || type == StackMapType.ITEM_UNKNOWN) {\n+            if (out != null)\n+                out.println(\"\/\/ Unknown StackMap type \" + subtag);\n+            type = StackMapType.ITEM_UNKNOWN;\n+            type.value = subtag;\n+        }\n+        return type;\n+    }\n+\n+    public static StackMapType stackMapType(String subtag) {\n+        return NameToStackMapType.get(subtag);\n+    }\n+\n+    public static StackMapType stackMapTypeKey(String subtag) {\n+        return KeyToStackMapType.get(subtag);\n+    }\n+\n+    public static String stackMapTypeName(int subtag) {\n+        String retval = null;\n+        StackMapType tg = StackMapTypes.get(subtag);\n+        if (tg != null) {\n+            retval = tg.printval;\n+        }\n+        return retval;\n+    }\n+\n+    public static int stackMapTypeValue(String idValue) {\n+        int retval = 0;\n+        StackMapType tg = NameToStackMapType.get(idValue);\n+        if (tg != null) {\n+            retval = tg.value;\n+        }\n+        return retval;\n+    }\n+\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * StackMap-FrameType table. These constants are used in stackmap pseudo-instructions\n+     * only.\n+     *\/\n+    static public enum StackMapFrameType {\n+        \/* Type codes for StackMapFrame attribute *\/\n+        SAME_FRAME                              (0, \"same\"),\n+        SAME_LOCALS_1_STACK_ITEM_FRAME          (64, \"stack1\"),\n+        SAME_LOCALS_1_STACK_ITEM_EXTENDED_FRAME (247, \"stack1_ex\"),\n+        CHOP_1_FRAME                            (250, \"chop1\"),\n+        CHOP_2_FRAME                            (249, \"chop2\"),\n+        CHOP_3_FRAME                            (248, \"chop3\"),\n+        SAME_FRAME_EX                           (251, \"same_ex\"),\n+        APPEND_FRAME                            (252, \"append\"),\n+        FULL_FRAME                              (255, \"full\");\n+\n+        private final Integer value;\n+        private final String parsekey;\n+\n+        StackMapFrameType(Integer val, String print) {\n+            value = val;\n+            parsekey = print;\n+        }\n+\n+        public String parsekey() {\n+            return parsekey;\n+        }\n+\n+        public Integer value() {\n+            return value;\n+        }\n+    }\n+\n+    private static void registerStackMapFrameType(StackMapFrameType typ) {\n+        NameToStackMapFrameType.put(typ.parsekey, typ);\n+        StackMapFrameTypes.put(typ.value, typ);\n+    }\n+\n+    public static StackMapFrameType stackMapFrameTypeVal(int subtag) {\n+        return StackMapFrameTypes.get(subtag);\n+    }\n+\n+    public static String stackMapFrameTypeName(int subtag) {\n+        String retval = null;\n+        StackMapFrameType tg = StackMapFrameTypes.get(subtag);\n+        if (tg != null) {\n+            retval = tg.parsekey;\n+        }\n+        return retval;\n+    }\n+\n+    public static StackMapFrameType stackMapFrameType(int subtag) {\n+        StackMapFrameType frametype;\n+        if (subtag < StackMapFrameType.SAME_LOCALS_1_STACK_ITEM_FRAME.value()) {\n+            \/\/ type is same_frame;\n+            frametype = StackMapFrameType.SAME_FRAME;\n+        } else if (subtag >= StackMapFrameType.SAME_LOCALS_1_STACK_ITEM_FRAME.value()\n+                && subtag <= 127) {\n+            \/\/ type is same_locals_1_stack_item_frame\n+            frametype = StackMapFrameType.SAME_LOCALS_1_STACK_ITEM_FRAME;\n+\n+        } else if (subtag >= StackMapFrameType.APPEND_FRAME.value()\n+                && subtag < StackMapFrameType.FULL_FRAME.value()) {\n+            \/\/ type is append_frame\n+            frametype = StackMapFrameType.APPEND_FRAME;\n+        } else {\n+            frametype = StackMapFrameTypes.get(subtag);\n+        }\n+        return frametype;\n+    }\n+\n+    public static int stackMapFrameTypeValue(String idValue) {\n+        int retval = 0;\n+        StackMapFrameType tg = NameToStackMapFrameType.get(idValue);\n+        if (tg != null) {\n+            retval = tg.value;\n+        }\n+        return retval;\n+    }\n+\n+    \/**\n+     * CF_Context enums\n+     *\/\n+    public enum CF_Context {\n+\n+        CTX_CLASS       (0, \"class\"),\n+        CTX_FIELD       (1, \"field\"),\n+        CTX_METHOD      (2, \"method\"),\n+        CTX_INNERCLASS  (3, \"inner-class\"),\n+        CTX_MODULE      (4, \"module\") ;\n+\n+        private final int value;\n+        private final String printval;\n+\n+        CF_Context(int val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        boolean isOneOf(CF_Context... items) {\n+            for(CF_Context item : items) {\n+                if(item.value == value) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public int val() {\n+            return value;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/Tables.java","additions":688,"deletions":0,"binary":false,"changes":688,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.jasm.TypeAnnotationTypes.ETargetType;\n+import org.openjdk.asmtools.jasm.TypeAnnotationTypes.TypePathEntry;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * JVMS 4.7.20.\n+ * type_annotation {\n+ *     u1 target_type;\n+ *     union {\n+ *         type_parameter_target;\n+ *         supertype_target;\n+ *         type_parameter_bound_target;\n+ *         empty_target;\n+ *         formal_parameter_target;\n+ *         throws_target;\n+ *         localvar_target;\n+ *         catch_target;\n+ *         offset_target;\n+ *         type_argument_target;\n+ *     } target_info;\n+ *     type_path target_path;\n+ *     u2        type_index;\n+ *     \/\/\n+ *     \/\/\n+ *     u2        num_element_value_pairs;\n+ *     {   u2            element_name_index;\n+ *         element_value value;\n+ *     } element_value_pairs[num_element_value_pairs];\n+ * }\n+ *\/\n+public class TypeAnnotationData extends AnnotationData {\n+\n+    protected ETargetType targetType;\n+    protected TypeAnnotationTargetInfoData targetInfo;\n+    protected TypeAnnotationTypePathData typePath;\n+\n+    public TypeAnnotationData(Argument typeCPX, boolean invisible) {\n+        super(typeCPX, invisible);\n+        typePath = new TypeAnnotationTypePathData();\n+    }\n+\n+    @Override\n+    public int getLength() {\n+        \/\/ lengthOf(annotations[]) + lengthOf(targetType) + lengthOf(targetInfo) + lengthOf(targetInfo)\n+        return super.getLength() + 1 + targetInfo.getLength() + typePath.getLength();\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        out.writeByte(targetType.value);\n+        targetInfo.write(out);\n+        typePath.write(out);\n+        super.write(out);\n+    }\n+\n+    public void addTypePathEntry(TypePathEntry path) {\n+        typePath.addTypePathEntry(path);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(0);\n+    }\n+\n+    public String toString(int tabLevel) {\n+        StringBuilder sb = new StringBuilder(tabString(tabLevel));\n+        sb.append(targetType.toString()).\n+                append(' ').\n+                append(targetInfo.toString(tabLevel)).\n+                append(typePath.toString(tabLevel));\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/TypeAnnotationData.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,546 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ * TargetInfo (4.7.20.1. The target_info union)\n+ *\n+ * BaseClass for any Type Annotation Target-Info.\n+ *\/\n+public abstract class TypeAnnotationTargetInfoData implements Data {\n+\n+    protected TypeAnnotationTypes.ETargetType targettype = null;\n+\n+    public TypeAnnotationTargetInfoData(TypeAnnotationTypes.ETargetType tt) {\n+        targettype = tt;\n+    }\n+\n+    public TypeAnnotationTypes.ETargetType getTargetType() {\n+        return targettype;\n+    }\n+\n+    public void print(PrintWriter out, String tab) {\n+        \/\/ print the TargetType and TargetInfo\n+        out.print(tab + \" {\");\n+        targettype.print(out);\n+        _print(out, tab);\n+        out.print(tab + \"} \");\n+    }\n+\n+    public abstract void _print(PrintWriter out, String tab);\n+\n+    public abstract void write(CheckedDataOutputStream out) throws IOException;\n+\n+    @Override\n+    public String toString() {\n+        return toString(0);\n+    }\n+\n+    protected abstract void _toString(StringBuilder sb, int tabLevel);\n+\n+    public  String toString(int tabLevel)  {\n+        StringBuilder sb = new StringBuilder(tabString(tabLevel));\n+        \/\/ first print the target info name (\n+        sb.append(targettype.targetInfo().printValue()).append(\"_target \");\n+        \/\/ get the sub-classes parts\n+        _toString(sb, tabLevel);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * type_parameter_target (4.7.20.1. The target_info union)\n+     *\n+     * The type_parameter_target item indicates that an annotation appears on the declaration of the i'th type parameter\n+     * of a generic class, generic interface, generic method, or generic constructor.\n+     *\n+     * type_parameter_target {\n+     *     u1 type_parameter_index;\n+     * }\n+     *\/\n+    public static class type_parameter_target extends TypeAnnotationTargetInfoData {\n+\n+        int typeParamIndex;\n+\n+        public type_parameter_target(TypeAnnotationTypes.ETargetType tt, int index) {\n+            super(tt);\n+            typeParamIndex = index;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte(typeParamIndex);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(typeParamIndex);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 1;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ type_parameter_index: %d; }\",typeParamIndex));\n+        }\n+    }\n+\n+    \/**\n+     * supertype_target (4.7.20.1. The target_info union)\n+     *\n+     * The supertype_target item indicates that an annotation appears on a type in the extends or implements clause of\n+     * a class or interface declaration.\n+     *\n+     * supertype_target {\n+     *     u2 supertype_index;\n+     * }\n+     *\/\n+    public static class supertype_target extends TypeAnnotationTargetInfoData {\n+\n+        int superTypeIndex;\n+\n+        public supertype_target(TypeAnnotationTypes.ETargetType tt, int index) {\n+            super(tt);\n+            superTypeIndex = index;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(superTypeIndex);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(superTypeIndex);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ supertype_index: %d; }\",superTypeIndex));\n+        }\n+    }\n+\n+    \/**\n+     * type_parameter_bound_target (4.7.20.1. The target_info union)\n+     *\n+     * The type_parameter_bound_target item indicates that an annotation appears on the i'th bound of the j'th type parameter\n+     * declaration of a generic class, interface, method, or constructor.\n+     *\n+     * type_parameter_bound_target {\n+     *     u1 type_parameter_index;\n+     *     u1 bound_index;\n+     * }\n+     *\/\n+    public static class type_parameter_bound_target extends TypeAnnotationTargetInfoData {\n+\n+        int typeParamIndex;\n+        int boundIndex;\n+\n+        public type_parameter_bound_target(TypeAnnotationTypes.ETargetType tt, int pindx, int bindx) {\n+            super(tt);\n+            typeParamIndex = pindx;\n+            boundIndex = bindx;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte(typeParamIndex);\n+            out.writeByte(boundIndex);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(typeParamIndex);\n+            out.print(\" \");\n+            out.print(boundIndex);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ type_parameter_index: %d; bound_index: %d; }\",\n+                    typeParamIndex, boundIndex));\n+        }\n+    }\n+\n+    \/**\n+     * empty_target (4.7.20.1. The target_info union)\n+     *\n+     * The empty_target item indicates that an annotation appears on either the type in a field declaration,\n+     * the return type of a method, the type of a newly constructed object, or the receiver type of a method or constructor.\n+     *\n+     * empty_target {\n+     * }\n+     *\/\n+    public static class empty_target extends TypeAnnotationTargetInfoData {\n+\n+        public empty_target(TypeAnnotationTypes.ETargetType tt) {\n+            super(tt);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public int getLength() { return 0; }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(\"{ }\");\n+        }\n+    }\n+\n+    \/**\n+     * formal_parameter_target (4.7.20.1. The target_info union)\n+     *\n+     * The formal_parameter_target item indicates that an annotation appears on the type in a formal parameter\n+     * declaration of a method, constructor, or lambda expression.\n+     *\n+     * formal_parameter_target {\n+     *     u1 formal_parameter_index;\n+     * }\n+     *\/\n+    public static class formal_parameter_target extends TypeAnnotationTargetInfoData {\n+\n+        int formalParamIndex;\n+\n+        public formal_parameter_target(TypeAnnotationTypes.ETargetType tt, int index) {\n+            super(tt);\n+            formalParamIndex = index;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeByte(formalParamIndex);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(formalParamIndex);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 1;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ formal_parameter_index: %d; }\",formalParamIndex));\n+        }\n+    }\n+\n+    \/**\n+     * throws_target (4.7.20.1. The target_info union)\n+     *\n+     * The throws_target item indicates that an annotation appears on the i'th type in the throws clause of a method or\n+     * constructor declaration.\n+     *\n+     * throws_target {\n+     *     u2 throws_type_index;\n+     * }\n+     *\/\n+    public static class throws_target extends TypeAnnotationTargetInfoData {\n+\n+        int throwsTypeIndex;\n+\n+        public throws_target(TypeAnnotationTypes.ETargetType tt, int index) {\n+            super(tt);\n+            throwsTypeIndex = index;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(throwsTypeIndex);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(throwsTypeIndex);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ throws_type_index: %d; }\",throwsTypeIndex));\n+        }\n+    }\n+\n+    \/**\n+     * localvar_target (4.7.20.1. The target_info union)\n+     *\n+     * The localvar_target item indicates that an annotation appears on the type in a local variable declaration,\n+     * including a variable declared as a resource in a try-with-resources statement.\n+     *\n+     * localvar_target {\n+     *     u2 table_length;\n+     *     {   u2 start_pc;\n+     *         u2 length;\n+     *         u2 index;\n+     *     } table[table_length];\n+     * }\n+     *\/\n+    public static class localvar_target extends TypeAnnotationTargetInfoData {\n+\n+        public class LocalVar_Entry {\n+\n+            public int startPC;\n+            public int length;\n+            public int cpx;\n+\n+            public LocalVar_Entry(int st, int len, int index) {\n+                startPC = st;\n+                length = len;\n+                cpx = index;\n+            }\n+\n+            void write(CheckedDataOutputStream out) throws IOException {\n+                out.writeShort(startPC);\n+                out.writeShort(length);\n+                out.writeShort(cpx);\n+            }\n+\n+            public void _print(PrintWriter out, String tab) {\n+                out.print(tab + \"{\");\n+                out.print(startPC);\n+                out.print(\" \");\n+                out.print(length);\n+                out.print(\" \");\n+                out.print(cpx);\n+                out.print(\"}\");\n+            }\n+\n+            public String toString() {\n+                return String.format(\"start_pc: %d, length: %d, index: %d\", startPC, length, cpx);\n+            }\n+        }\n+\n+        ArrayList<LocalVar_Entry> table = null;\n+\n+        public localvar_target(TypeAnnotationTypes.ETargetType tt, int size) {\n+            super(tt);\n+            table = new ArrayList<>(size);\n+        }\n+\n+        public void addEntry(int startPC, int length, int cpx) {\n+            LocalVar_Entry entry = new LocalVar_Entry(startPC, length, cpx);\n+            table.add(entry);\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(table.size());\n+            for (LocalVar_Entry entry : table) {\n+                entry.write(out);\n+            }\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            String innerTab = tab + \" \";\n+            for (LocalVar_Entry entry : table) {\n+                entry._print(out, innerTab);\n+            }\n+            out.print(tab);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2 + \/\/ U2 for table size\n+                    (6 * table.size()); \/\/ (3 * U2) for each table entry\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            int i = 0;\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ %d  {\", table.size()));\n+            for (LocalVar_Entry entry : table) {\n+                sb.append(String.format(\" [%d]: %s;\", i++, entry.toString()));\n+            }\n+            sb.append(\" } }\");\n+        }\n+    }\n+\n+    \/**\n+     * catch_target (4.7.20.1. The target_info union)\n+     *\n+     * The catch_target item indicates that an annotation appears on the i'th type in an exception parameter declaration.\n+     *\n+     * catch_target {\n+     *     u2 exception_table_index;\n+     * }\n+     *\/\n+    public static class catch_target extends TypeAnnotationTargetInfoData {\n+\n+        int exceptionTableIndex;\n+\n+        public catch_target(TypeAnnotationTypes.ETargetType tt, int index) {\n+            super(tt);\n+            exceptionTableIndex = index;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(exceptionTableIndex);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(exceptionTableIndex);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ exception_table_index: %d; }\",exceptionTableIndex));\n+        }\n+    }\n+\n+    \/**\n+     * offset_target (4.7.20.1. The target_info union)\n+     *\n+     *  The offset_target item indicates that an annotation appears on either the type in an instanceof expression or\n+     *  a new expression, or the type before the :: in a method reference expression.\n+     *\n+     *  offset_target {\n+     *     u2 offset;\n+     * }\n+     *\/\n+    public static class offset_target extends TypeAnnotationTargetInfoData {\n+\n+        int offset;\n+\n+        public offset_target(TypeAnnotationTypes.ETargetType tt, int offset) {\n+            super(tt);\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(offset);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(offset);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 2;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ offset: %d; }\", offset));\n+        }\n+    }\n+\n+    \/**\n+     * type_argument_target (4.7.20.1. The target_info union)\n+     *\n+     *  The type_argument_target item indicates that an annotation appears either on the i'th type in a cast expression,\n+     *  or on the i'th type argument in the explicit type argument list for any of the following: a new expression,\n+     *  an explicit constructor invocation statement, a method invocation expression, or a method reference expression\n+     *\n+     *  type_argument_target {\n+     *     u2 offset;\n+     *     u1 type_argument_index;\n+     * }\n+     *\/\n+    public static class type_argument_target extends TypeAnnotationTargetInfoData {\n+\n+        int offset;\n+        int typeArgumentIndex;\n+\n+        public type_argument_target(TypeAnnotationTypes.ETargetType tt, int offset, int index) {\n+            super(tt);\n+            this.offset = offset;\n+            typeArgumentIndex = index;\n+        }\n+\n+        @Override\n+        public void write(CheckedDataOutputStream out) throws IOException {\n+            out.writeShort(offset);\n+            out.writeByte(typeArgumentIndex);\n+        }\n+\n+        @Override\n+        public void _print(PrintWriter out, String tab) {\n+            out.print(\" \");\n+            out.print(offset);\n+            out.print(\" \");\n+            out.print(typeArgumentIndex);\n+        }\n+\n+        @Override\n+        public int getLength() {\n+            return 3;\n+        }\n+\n+        @Override\n+        protected void _toString(StringBuilder sb, int tabLevel) {\n+            sb.append(tabString(tabLevel)).append(String.format(\"{ offset: %d; type_argument_index: %d; }\",\n+                    offset, typeArgumentIndex));\n+        }\n+    }\n+\n+}\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/TypeAnnotationTargetInfoData.java","additions":546,"deletions":0,"binary":false,"changes":546,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import org.openjdk.asmtools.jasm.TypeAnnotationTypes.TypePathEntry;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ * JVMS 4.7.20.2. The type_path structure\n+ *\n+ * type_path {\n+ *     u1 path_length;\n+ *     {   u1 type_path_kind;\n+ *         u1 type_argument_index;\n+ *     } path[path_length];\n+ * }\n+ *\/\n+public class TypeAnnotationTypePathData implements Data {\n+\n+    private ArrayList<TypePathEntry> typePathEntries = new ArrayList<>();\n+\n+    public void addTypePathEntry( TypePathEntry entry) {\n+        typePathEntries.add(entry);\n+    }\n+\n+    @Override\n+    public void write(CheckedDataOutputStream out) throws IOException {\n+        out.writeByte(typePathEntries.size());\n+        for (TypePathEntry entry : typePathEntries) {\n+            out.writeByte(entry.getTypePathKind());\n+            out.writeByte(entry.getTypeArgumentIndex());\n+        }\n+    }\n+\n+    @Override\n+    public int getLength() {\n+        return 1 + typePathEntries.size() * 2;\n+    }\n+\n+    public String toString(int tabLevel) {\n+        String buffer = \"\";\n+        if( typePathEntries.size() > 0 ) {\n+        StringBuilder sb = new StringBuilder(tabString(tabLevel));\n+        sb.append(\" [ \");\n+        boolean first = true;\n+        for (TypePathEntry entry : typePathEntries) {\n+                if (!first)\n+                    sb.append(\", \");\n+                first = false;\n+            sb.append(entry.toString());\n+            }\n+            sb.append(\"]\");\n+        buffer = sb.toString();\n+        }\n+        return buffer;\n+    }\n+\n+    \/**\n+     * jdis: print the type_path structure\n+     *\/\n+    public void print(PrintWriter out, String tab) {\n+        if( typePathEntries.size() > 0 ) {\n+            out.print(tab + \" {\");\n+            boolean first = true;\n+            for (TypePathEntry entry : typePathEntries) {\n+                if (!first) {\n+                    out.print(\", \");\n+                }\n+                first = false;\n+                out.print(entry.toString());\n+            }\n+            out.print(tab + \"} \");\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/TypeAnnotationTypePathData.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm;\n+\n+import java.io.PrintWriter;\n+\n+\/**\n+ * Type annotation types: target_type, target_info &amp;&amp; target_path\n+ *\/\n+public class TypeAnnotationTypes {\n+\n+    \/**\n+     * Interpretation of type_path_kind values (Table 4.7.20.2-A)\n+     *\/\n+    public enum EPathKind {\n+        ARRAY(0),\n+        INNER_TYPE(1),\n+        WILDCARD(2),\n+        TYPE_ARGUMENT(3);\n+\n+        private final int tag;\n+        public static final int maxLen = 3;\n+\n+        EPathKind(int tag) {\n+            this.tag = tag;\n+        }\n+\n+        public int tag() {\n+            return tag;\n+        }\n+\n+        public String parseKey() {\n+            return this.toString();\n+        }\n+\n+        static EPathKind getPathKind(String token) {\n+            for (EPathKind pk : values()) {\n+                if( pk.parseKey().equals(token)) {\n+                    return pk;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/\/ will throw ArrayIndexOutOfBounds if i < 0 or i > 3\n+    static public EPathKind getPathKind(int i) {\n+        return EPathKind.values()[i];\n+    }\n+\n+    static public class TypePathEntry {\n+\n+        private final EPathKind kind;\n+        private final int typeArgumentIndex;\n+\n+        public TypePathEntry(int kind, int typeArgumentIndex) {\n+            this.kind = getPathKind(kind);\n+            this.typeArgumentIndex = typeArgumentIndex;\n+        }\n+\n+        public TypePathEntry(EPathKind kind, int typeArgumentIndex) {\n+            this.kind = kind;\n+            this.typeArgumentIndex = typeArgumentIndex;\n+        }\n+\n+        public int getTypePathKind() {\n+            return kind.tag();\n+        }\n+\n+        public int getTypeArgumentIndex() {\n+            return typeArgumentIndex;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            \/\/ Chapter 4.7.20.2 The type_path structure\n+            \/\/ if the value of the type_path_kind is 0,1, or 2, thebn the value of the\n+            \/\/ type_argument_index item is 0.\n+            return kind.parseKey() +  ( kind.tag == 3 ?\n+                    JasmTokens.Token.LBRACE.parseKey() + typeArgumentIndex + JasmTokens.Token.RBRACE.parseKey() :\n+                    \"\");\n+        }\n+    }\n+\n+    \/**\n+     *     union {\n+     *         type_parameter_target;\n+     *         supertype_target;\n+     *         type_parameter_bound_target;\n+     *         empty_target;\n+     *         method_formal_parameter_target;\n+     *         throws_target;\n+     *         localvar_target;\n+     *         catch_target;\n+     *         offset_target;\n+     *         type_argument_target;\n+     *     } target_info;\n+     *\/\n+    public enum ETargetInfo {\n+        TYPEPARAM           (\"TYPEPARAM\", \"type_parameter\"),\n+        SUPERTYPE           (\"SUPERTYPE\", \"supertype\"),\n+        TYPEPARAM_BOUND     (\"TYPEPARAM_BOUND\", \"type_parameter_bound\"),\n+        EMPTY               (\"EMPTY\", \"empty\"),\n+        METHODPARAM         (\"METHODPARAM\", \"formal_parameter\"),\n+        EXCEPTION           (\"EXCEPTION\", \"throws\"),\n+        LOCALVAR            (\"LOCALVAR\", \"localvar\"),\n+        CATCH               (\"CATCH\", \"catch\"),\n+        OFFSET              (\"OFFSET\", \"offset\"),\n+        TYPEARG             (\"TYPEARG\", \"type_argument\");\n+\n+        private final String parseKey;\n+        private final String printValue;\n+\n+        ETargetInfo(String parse, String printValue) {\n+            parseKey = parse;\n+            this.printValue = printValue;\n+        }\n+        public String parseKey() {\n+            return this.parseKey;\n+        }\n+\n+        public String printValue() {\n+            return this.printValue;\n+        }\n+    }\n+\n+    \/**\n+     *  Interpretation of target_type values (Table 4.7.20-A.\/B.)\n+     *\/\n+    static public enum ETargetType {\n+        class_type_param            (0x00, \"CLASS_TYPE_PARAMETER\",  ETargetInfo.TYPEPARAM, \"class\/interface type parameter\"),\n+        meth_type_param             (0x01, \"METHOD_TYPE_PARAMETER\",  ETargetInfo.TYPEPARAM, \"method\/constructor type parameter\"),\n+        class_exts_impls            (0x10, \"CLASS_EXTENDS\",  ETargetInfo.SUPERTYPE, \"class extends\/implements\"),\n+        class_type_param_bnds       (0x11, \"CLASS_TYPE_PARAMETER_BOUND\",  ETargetInfo.TYPEPARAM_BOUND, \"class\/interface type parameter bounds\"),\n+        meth_type_param_bnds        (0x12, \"METHOD_TYPE_PARAMETER_BOUND\",  ETargetInfo.TYPEPARAM_BOUND, \"method\/constructor type parameter bounds\"),\n+        field                       (0x13, \"FIELD\",  ETargetInfo.EMPTY, \"field\"),\n+        meth_ret_type               (0x14, \"METHOD_RETURN\",  ETargetInfo.EMPTY, \"method return type\"),\n+        meth_receiver               (0x15, \"METHOD_RECEIVER\",  ETargetInfo.EMPTY, \"method receiver\"),\n+        meth_formal_param           (0x16, \"METHOD_FORMAL_PARAMETER\",  ETargetInfo.METHODPARAM, \"method formal parameter type\"),\n+        throws_type                 (0x17, \"THROWS\",  ETargetInfo.EXCEPTION, \"exception type in throws\"),\n+\n+        local_var                   (0x40, \"LOCAL_VARIABLE\",  ETargetInfo.LOCALVAR, \"local variable\"),\n+        resource_var                (0x41, \"RESOURCE_VARIABLE\",  ETargetInfo.LOCALVAR, \"resource variable\"),\n+        exception_param             (0x42, \"EXCEPTION_PARAM\",  ETargetInfo.CATCH, \"exception parameter\"),\n+        type_test                   (0x43, \"INSTANCEOF\",  ETargetInfo.OFFSET, \"type test (instanceof)\"),\n+        obj_creat                   (0x44, \"NEW\",  ETargetInfo.OFFSET, \"object creation (new)\"),\n+        constr_ref_receiver         (0x45, \"CONSTRUCTOR_REFERENCE_RECEIVER\", ETargetInfo.OFFSET, \"constructor reference receiver\"),\n+        meth_ref_receiver           (0x46, \"METHOD_REFERENCE_RECEIVER\", ETargetInfo.OFFSET, \"method reference receiver\"),\n+        cast                        (0x47, \"CAST\",  ETargetInfo.TYPEARG, \"cast\"),\n+        constr_invoc_typearg        (0x48, \"CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\",  ETargetInfo.TYPEARG, \"type argument in constructor call\"),\n+        meth_invoc_typearg          (0x49, \"METHOD_INVOCATION_TYPE_ARGUMENT\", ETargetInfo.TYPEARG, \"type argument in method call\"),\n+        constr_ref_typearg          (0x4A, \"CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT\", ETargetInfo.TYPEARG, \"type argument in constructor reference\"),\n+        meth_ref_typearg            (0x4B, \"METHOD_REFERENCE_TYPE_ARGUMENT\",  ETargetInfo.TYPEARG, \"type argument in method reference\");\n+\n+        public static final int maxTag = 0x9A;\n+        public static final int maxLen = 36;\n+\n+        public final int value;\n+        private final String parseKey;\n+        private final ETargetInfo targetInfo;\n+        private final String printVal;\n+\n+        ETargetType(int val, String parse, ETargetInfo targetInfo, String printVal) {\n+            value = val;\n+            parseKey = parse;\n+            this.targetInfo = targetInfo;\n+            this.printVal = printVal;\n+        }\n+\n+        public String parseKey() {\n+            return parseKey;\n+        }\n+\n+        public String infoKey() {\n+            return targetInfo.parseKey();\n+        }\n+\n+        public ETargetInfo targetInfo() {\n+            return targetInfo;\n+        }\n+\n+        public void print(PrintWriter out) {\n+            out.print(parseKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s[%#x]\", parseKey, value);\n+        }\n+\n+        public static ETargetType getTargetType(int typeCode)  {\n+            for( ETargetType type: ETargetType.values() ) {\n+                if (type.value == typeCode) {\n+                    return type;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        static public ETargetType getTargetType(String typeName) {\n+            for( ETargetType type: ETargetType.values() ) {\n+                if (type.parseKey.equals(typeName)) {\n+                    return type;\n+                }\n+            }\n+            return null;\n+        }\n+    };\n+\n+    \/* TypeAnnotationVisitor Methods *\/\n+    public static class TypeAnnotationTargetVisitor {\n+\n+        public final void visit(ETargetType tt) {\n+            switch (tt) {\n+                case class_type_param:\n+                case meth_type_param:\n+                    visit_type_param_target(tt);\n+                    break;\n+                case class_exts_impls:\n+                    visit_supertype_target(tt);\n+                    break;\n+                case class_type_param_bnds:\n+                case meth_type_param_bnds:\n+                    visit_typeparam_bound_target(tt);\n+                    break;\n+                case field:\n+                case meth_ret_type:\n+                case meth_receiver:\n+                    visit_empty_target(tt);\n+                    break;\n+                case meth_formal_param:\n+                    visit_methodformalparam_target(tt);\n+                    break;\n+                case throws_type:\n+                    visit_throws_target(tt);\n+                    break;\n+                case local_var:\n+                case resource_var:\n+                    visit_localvar_target(tt);\n+                    break;\n+                case exception_param:\n+                    visit_catch_target(tt);\n+                    break;\n+                case type_test:\n+                case obj_creat:\n+                case constr_ref_receiver:\n+                case meth_ref_receiver:\n+                    visit_offset_target(tt);\n+                    break;\n+\n+                case cast:\n+                case constr_invoc_typearg:\n+                case meth_invoc_typearg:\n+                case constr_ref_typearg:\n+                case meth_ref_typearg:\n+\n+                    visit_typearg_target(tt);\n+                    break;\n+            }\n+        }\n+\n+        public void visit_type_param_target(ETargetType tt) {\n+        }\n+\n+        public void visit_supertype_target(ETargetType tt) {\n+        }\n+\n+        public void visit_typeparam_bound_target(ETargetType tt) {\n+        }\n+\n+        public void visit_empty_target(ETargetType tt) {\n+        }\n+\n+        public void visit_methodformalparam_target(ETargetType tt) {\n+        }\n+\n+        public void visit_throws_target(ETargetType tt) {\n+        }\n+\n+        public void visit_localvar_target(ETargetType tt) {\n+        }\n+\n+        public void visit_catch_target(ETargetType tt) {\n+        }\n+\n+        public void visit_offset_target(ETargetType tt) {\n+        }\n+\n+        public void visit_typearg_target(ETargetType tt) {\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/TypeAnnotationTypes.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+jasm.usage=\\\n+Usage: java -jar asmtools.jar jasm [options] file.jasm...\\n\\\n+where possible options include:\n+\n+jasm.opt.d=\\\n+\\     -d destdir  directory to place resulting .class files\n+jasm.opt.v=\\\n+\\     -v          add trace information\n+jasm.opt.g=\\\n+\\     -g          add debug information\n+jasm.opt.version=\\\n+\\     -version    prints the program version\n+jasm.opt.nowrite=\\\n+\\     -nowrite    do not write resulting .class files\n+jasm.opt.strict=\\\n+\\     -strict     consider warnings as errors\n+jasm.opt.nowarn=\\\n+\\     -nowarn     do not print warnings\n+jasm.opt.cv=\\\n+\\     -cv major.minor  set operating class file version (by default {0}.{1})\n+\n+\n+jasm.error.d_requires_argument=-d requires argument\n+jasm.error.does_not_exist={0} does not exist\n+jasm.error.cv_requires_arg=-cv requires argument\n+jasm.error.invalid_major_minor_param=invalid parameter major.minor\n+jasm.error.invalid_option=invalid option: {0}\n+jasm.error.cannot_read=cannot read {0}\n+jasm.error.cannot_write=cannot write {0}\n+jasm.error.fatal_error=fatal error\n+jasm.error.fatal_exception=fatal exception\n+\n+\n+# Scanner:\n+err.invalid.escape.char=Invalid escape character.\n+err.eof.in.comment=Comment not terminated at end of input.\n+err.invalid.number=Invalid character \"{0}\" in number.\n+err.invalid.octal.number=Invalid character in octal number.\n+err.overflow=Numeric overflow.\n+err.float.format=Invalid floating point format.\n+err.eof.in.string=String not terminated at end of input.\n+err.newline.in.string=String not terminated at end of line.\n+err.funny.char=Invalid character in input.\n+err.unbalanced.paren=Unbalanced parentheses.\n+# Parser:\n+err.package.repeated=Package statement repeated.\n+warn.intf.repeated=Interface {0} repeated.\n+warn.exc.repeated=Exception repeated in throws clause.\n+warn.record.repeated=Record attribute repeated.\n+err.multiple.inherit=Multiple inheritance is not supported.\n+err.toplevel.expected=Class, module or interface declaration expected.\n+err.const.def.expected=Constant declaration expected.\n+err.const.undecl=Constant #{0} not declared.\n+err.const.redecl=Constant {0} redeclared.\n+warn.const0.redecl=Re-declaration of Constant #0 cannot be written to the class file.\n+err.field.expected=Field, Method, NestMembers, NestHost or Record declaration expected.\n+err.token.expected={0} expected.\n+err.identifier.expected=Identifier expected.\n+err.extra.nesthost.attribute=There may be at most one NestHost attribute.\n+err.extra.nestmembers.attribute=There may be at most one NestMembers attribute.\n+err.extra.permittedsubclasses.attribute=There may be at most one PermittedSubclasses attribute.\n+err.extra.record.attribute=There may be at most one Record attribute.\n+err.grouped.component.expected=Either an annotation or a record component expected.\n+warn.no.components.in.record.attribute=Record should have at least one component.\n+err.one.of.two.token.expected=Either #{0} or #{1} token expected.\n+\n+err.both.nesthost.nestmembers.found=The attributes table of a ClassFile structure must not contain both a NestMembers attribute and a NestHost attribute.\n+err.name.expected=Name expected, got {0}.\n+err.module.name.expected=Module name expected, got {0}.\n+err.int.expected=Integer expected.\n+err.neg.forbidden=Negative integer is not allowed here.\n+err.value.large=Value doesn't fit in {0}.\n+err.value.expected=Value expected.\n+err.wrong.mnemocode=Invalid mnemocode ({0}).\n+err.default.redecl=Default statement already declared in this table.\n+err.long.switchtable=Switchtable too long: > {0}.\n+err.io.exception=I\/O error in {0}.\n+warn.wrong.tag=Wrong tag: {0} expected.\n+err.wrong.tag=Wrong tag: {0} expected.\n+warn.wrong.tag2=Wrong tag: Either {0} or {1} expected.\n+err.wrong.tag2=Wrong tag: Either {0} or {1} expected.\n+# Code Gen:\n+err.locvar.redecl=Local variable {0} redeclared.\n+err.locvar.undecl=Local variable {0} not declared.\n+#err.locvar.expected=Local variable expected.\n+err.label.redecl=Label {0} redeclared.\n+err.label.undecl=Label {0} not declared.\n+err.label.expected=Label expected.\n+err.subtag.expected=Subtag expected.\n+err.type.expected=Type expected.\n+err.trap.tryredecl=<try {0}> redeclared.\n+err.trap.endtryredecl=<endtry {0}> redeclared.\n+err.trap.notry=No <try {0}> found.\n+err.trap.noendtry=No <endtry {0}> found.\n+warn.trap.notref=No <catch {0}> declared.\n+err.cannot.write=Cannot write to {0}.\n+err.msig.malformed=Malformed method signature at char {0}. [err={1}]\n+err.no.classname=Class name not defined.\n+warn.msig.more255=Number of parameters too large ({0}>255).\n+warn.illslot=Local variable at Illegal slot {0}.\n+warn.repeated.modifier=Repeated modifier.\n+warn.invalid.modifier.init=invalid modifier for <init> method  \\\"{0}\\\".\n+warn.invalid.modifier.fiva=at most one of final and volatile modifiers can be used for a field\n+warn.invalid.modifier.intfield=interface field must be public static final only\n+warn.init.in_int=<init> method cannot be placed in an interface.\n+warn.invalid.modifier.intmth=interface method must be abstract public only  \\\"{0}\\\".\n+warn.invalid.modifier.abst=invalid modifier for abstract method.\n+#\n+warn.invalid.modifier.field=invalid modifier(s) for a field \\\"{0}\\\"\n+warn.invalid.modifier.mth=invalid modifier(s) for a method \\\"{0}\\\"\n+warn.invalid.modifier.innerclass=invalid modifier for an inner class \\\"{0}\\\"\n+#\n+warn.invalid.modifier.class=invalid modifier(s) for a class \\\"{0}\\\"\n+warn.invalid.modifier.int=invalid modifier(s) for an interface \\\"{0}\\\"\n+#\n+warn.invalid.modifier.acc=at most one of public, protected, and private modifiers can be used.\n+warn.invalid.modifier.int.abs=interface class must have abstract modifier.\n+warn.missing.modifier.class=class or enum declaration missing.\n+warn.invalid.modifier.class.finabs=class cannot be both abstract and final.\n+warn.invalid.modifier.class.intenum=cannot be both interface and enum.\n+err.itemtype.expected=StackMap item type expected instead of {0}.\n+err.localsmap.repeated=locals_map redeclared.\n+err.invalid.stack.frame.type=invalid stack frame type.\n+err.invalid.offset.same.frame=offset value more than 64 for the 'same_frame' type frame.\n+err.no.stack.map.same.locals=stack map element for the 'same_locals_1_stack_item_frame' type frame is absent.\n+err.should.be.only.one.stack.map.element=should be only one stack map element for the 'same_locals_1_stack_item_frame' type frame.\n+err.invalid.offset.same.locals=offset value more than 64 for the 'same_locals_1_stack_item_frame' type frame.\n+err.unexpected.stack.maps=there are unexpected stack maps.\n+err.unexpected.locals.maps=there are unexpected locals maps.\n+err.no.locals.map.append=locals map element for the 'append_frame' type frame is absent.\n+err.more.locals.map.elements=there are more than 3 locals map element for the 'append_frame' type frame.\n+err.stackmap.repeated=stack_map redeclared.\n+err.version.expected=class file version expected\n+err.invalid.innerclass=Invalid declaration of Inner Class\n+err.invalid.bootstrapmethod=Invalid declaration of BootstrapMethod Entry\n+err.frametype.repeated=Frametype repeated\n+err.invalid.paramnum=Invalid Parameter Number: {0}.\n+err.duplicate.paramnum=Duplicate Parameter Number: {0}.\n+err.paramname.constnum.invaltype=ParameterName CPX at {0} is not a ConstantString.\n+err.paramname.token.unexpected=Incorrect ParamName, unrecognized token: \\\"{0}\\\".\n+#\n+# annotations Errors\n+#\n+err.incorrect.annot.class=Incorrect Annotation (class), expected class name or CPX), got \\\"{0}\\\".\n+err.incorrect.annot.enum=Incorrect Annotation (enum), expected type field IDENT, \\\"{0}\\\".\n+err.incorrect.annot.enum.cpx==Incorrect Annotation (enum), expected type field CPX.\n+err.incorrect.annot.token=Incorrect Annotation, unrecognized token: \\\"{0}\\\".\n+err.incorrect.annot.bool=Incorrect Annotation (boolean), expected Integer), got \\\"{0}\\\".\n+err.incorrect.annot.byte=Incorrect Annotation (byte), expected Integer), got \\\"{0}\\\".\n+err.incorrect.annot.char=Incorrect Annotation (char), expected Integer), got \\\"{0}\\\".\n+err.incorrect.annot.short=Incorrect Annotation (short), expected Integer), got \\\"{0}\\\".\n+err.incorrect.annot.keyword=Incorrect Annotation keyword \\\"{0}\\\".\n+err.incorrect.typeannot.target=Incorrect TypeAnnotation target \\\"{0}\\\".\n+err.incorrect.typeannot.targtype.string=Incorrect TypeAnnotation \\\"{0}\\\" argument: (expected String),  \\\"{1}\\\".\n+err.incorrect.typeannot.targtype.int=Incorrect TypeAnnotation \\\"{0}\\\" argument: (expected Integer),  \\\"{1}\\\".\n+err.incorrect.typeannot.pathentry=Incorrect TypeAnnotation TargetPath PathEntry \\\"{0}\\\".\n+err.incorrect.typeannot.pathentry.argindex=Incorrect TypeAnnotation  TargetPath PathEntry ArgIndex (expected Integer),  \\\"{0}\\\".\n+#\n+# module Errors\n+err.module.statement.expected= Module statement expected.\n+err.requires.expected=Module statement \\\"requires [transitive] [static] ModuleName;\\\" expected.\n+warn.dot.will.be.converted=Forward slash \\\"\/\\\" expected instead of dot \\\".\\\". The dot is replaced by \\\"\/\\\".\n+#\n+# Compiler Errors\n+#\n+comperr.constcell.nullvalset=\"Cell without value in setCell\"\n+comperr.constcell.nullvalhash=\"Cell without value in cpoolHashByValue\"\n+comperr.constcell.invarg=\"Cell[{0}] has #{1}\"\n+comperr.constcell.nullval=\"ConstCell.value=null??\"\n+comperr.val.noteq=\"Values not eq\"\n+comperr.instr.nullarg=\"null arg for {0}\"\n+comperr.instr.arglong=\"Too long argument of {0}: {1}\"\n+comperr.instr.opclen=\"Wrong opcLength({0})\"\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/i18n.properties","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,957 @@\n+\/*\n+ * Copyright (c) 2009, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcdec;\n+\n+import static org.openjdk.asmtools.jcoder.JcodTokens.*;\n+import org.openjdk.asmtools.jdis.uEscWriter;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+import org.openjdk.asmtools.util.ProductInfo;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ * Main program of the JavaCard DeCoder\n+ *\n+ *\/\n+public class Main {\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Main Fields *\/\n+    \/**\n+     * Name of the program.\n+     *\/\n+    String program;\n+\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+    \/**\n+     * The stream where error message are printed.\n+     *\/\n+    PrintWriter out;\n+    boolean DebugFlag = false;\n+    boolean printDetails = false;\n+    int shift = 0;\n+    private static final char hexTable[] = {\n+        '0', '1', '2', '3', '4', '5', '6', '7',\n+        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n+    \/*-------------------------------------------------------- *\/\n+\n+    static String toHex(long val, int width) {\n+        StringBuffer s = new StringBuffer();\n+        for (int i = width * 2 - 1; i >= 0; i--) {\n+            s.append(hexTable[((int) (val >> (4 * i))) & 0xF]);\n+        }\n+        return \"0x\" + s.toString();\n+    }\n+\n+    static String toHex(long val) {\n+        int width;\n+        for (width = 8; width > 0; width--) {\n+            if ((val >> (width - 1) * 8) != 0) {\n+                break;\n+            }\n+        }\n+        return toHex(val, width);\n+    }\n+\n+    void printByteHex(PrintWriter out, int b) {\n+        out.print(hexTable[(b >> 4) & 0xF]);\n+        out.print(hexTable[b & 0xF]);\n+    }\n+\n+    \/*========================================================*\/\n+    void out_begin(String s) {\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.println(s);\n+        shift++;\n+    }\n+\n+    void out_print(String s) {\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.print(s);\n+    }\n+\n+    void out_println(String s) {\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.println(s);\n+    }\n+\n+    void out_end(String s) {\n+        shift--;\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.println(s);\n+    }\n+\n+    String startArray(int length) {\n+        return \"[\" + (printDetails ? Integer.toString(length) : \"\") + \"]\";\n+    }\n+\n+    void printBytes(DataInputStream in, int len) throws IOException {\n+        try {\n+            for (int i = 0; i < len; i++) {\n+                if (i % 8 == 0) {\n+                    out_print(\"0x\");\n+                }\n+                printByteHex(out, in.readByte());\n+                if (i % 8 == 7) {\n+                    out.println(\";\");\n+                }\n+            }\n+        } finally {\n+            if (len % 8 != 0) {\n+                out.println(\";\");\n+            }\n+        }\n+    }\n+\n+    \/*========================================================*\/\n+    static final int EXPORT_MAGIC = 0x00FACADE;\n+    static final int HEADER_MAGIC = 0xDECAFFED;\n+    static String[] compNames = {\n+        \"Header\",\n+        \"Directory\",\n+        \"Applet\",\n+        \"Import\",\n+        \"ConstantPool\",\n+        \"Class\",\n+        \"Method\",\n+        \"StaticField\",\n+        \"RefLocation\",\n+        \"Export\",\n+        \"Descriptor\"\n+    };\n+\n+    static String compName(int compNum) {\n+        try {\n+            return compNames[compNum - 1];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return \"tag \" + compNum + \"???\";\n+        }\n+    }\n+    String[] cPoolStrings;\n+\n+    void decodeAttr(DataInputStream in) throws IOException {\n+        int name_cpx = in.readUnsignedShort(), len = in.readInt();\n+        String AttrName = null;\n+        String endingComment = \"Attr(#\" + name_cpx + \")\";\n+        try {\n+            endingComment = AttrName = cPoolStrings[name_cpx];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+        }\n+        if (printDetails) {\n+            out_begin(\"Attr(#\" + name_cpx + \", \" + len + \") { \/\/ \" + AttrName);\n+        } else {\n+            out_begin(\"Attr(#\" + name_cpx + \") { \/\/ \" + AttrName);\n+        }\n+        if (AttrName == null) {\n+            printBytes(in, len);\n+        } else if (AttrName.equals(\"ConstantValue\")) {\n+            if (len != 2) {\n+                out_println(\"\/\/ invalid length of ConstantValue attr: \" + len + \" (should be 2)\");\n+                printBytes(in, len);\n+            } else {\n+                out_println(\"#\" + in.readUnsignedShort() + \";\");\n+            }\n+        } else {\n+            printBytes(in, len);\n+        }\n+        out_end(\"} \/\/ end \" + endingComment);\n+    }\n+\n+    void decodeExp(String inpName) throws IOException {\n+        DataInputStream in = new DataInputStream(new FileInputStream(inpName));\n+        out_println(\"file \" + inpName);\n+        out_begin(\"{  \/\/ export file\");\n+\n+        int magic = in.readInt();\n+        out_print(toHex(magic, 4) + \";  \/\/ \");\n+        if (magic != EXPORT_MAGIC) {\n+            out.print(\"wrong magic: 0x\" + Integer.toString(EXPORT_MAGIC, 16) + \" expected\");\n+        } else {\n+            out_print(\"magic\");\n+        }\n+        out.println();\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n+\n+        int cp_count = in.readUnsignedShort();\n+        cPoolStrings = new String[cp_count];\n+        out_begin(startArray(cp_count) + \" { \/\/  Constant Pool\");\n+        for (int i = 0; i < cp_count; i++) {\n+            int tag = in.readUnsignedByte();\n+            ConstType tg = constType(tag);\n+            switch (tg) {\n+                case CONSTANT_UTF8:\n+                    out_print(\"Utf8 \\\"\");\n+\n+                    StringBuffer sb = new StringBuffer();\n+                    String s = in.readUTF();\n+                    cPoolStrings[i] = s;\n+                    for (int k = 0; k < s.length(); k++) {\n+                        char c = s.charAt(k);\n+                        switch (c) {\n+                            case '\\t':\n+                                sb.append('\\\\').append('t');\n+                                break;\n+                            case '\\n':\n+                                sb.append('\\\\').append('n');\n+                                break;\n+                            case '\\r':\n+                                sb.append('\\\\').append('r');\n+                                break;\n+                            case '\\\"':\n+                                sb.append('\\\\').append('\\\"');\n+                                break;\n+                            default:\n+                                sb.append(c);\n+                        }\n+                    }\n+                    out.println(sb.append(\"\\\"; \/\/ #\").append(i).toString());\n+                    break;\n+\n+                case CONSTANT_INTEGER:\n+                    out_println(\"int \" + toHex(in.readInt(), 4) + \"; \/\/ #\" + i);\n+                    break;\n+\n+                case CONSTANT_CLASS:\n+                    out_println(\"class #\" + in.readUnsignedShort() + \"; \/\/ #\" + i);\n+                    break;\n+\n+                case CONSTANT_JAVACARD_PACKAGE:\n+                    out_begin(\"package { \/\/ #\" + i);\n+                    out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/ flags\");\n+                    out_println(\"#\" + in.readUnsignedShort() + \"; \/\/ name\");\n+                    out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n+                    out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n+                    int aid_len = in.readUnsignedByte();\n+                    out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n+                    printBytes(in, aid_len);\n+                    out_end(\"};\"); \/\/ Bytes[]\n+                    out_end(\"};\"); \/\/ package info\n+                    break;\n+\n+                default:\n+                    throw new Error(\"invalid constant type: \" + (int) tag);\n+            }\n+        }\n+        ;\n+        out_end(\"} \/\/ Constant pool\");\n+        out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this package\");\n+        int class_count = in.readUnsignedByte();\n+        out_begin(startArray(class_count) + \"b { \/\/  classes\");\n+        for (int i = 0; i < class_count; i++) {\n+            out_begin(\"{ \/\/ class \" + i);\n+\n+            out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n+\n+            int flags = in.readUnsignedShort();\n+            out_print(\"0x\");\n+            printByteHex(out, flags >> 8);\n+            printByteHex(out, flags);\n+            out.println(\"; \/\/ flags\");\n+\n+            out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this class\");\n+\n+            int sup_count = in.readUnsignedShort();\n+            out_begin(startArray(sup_count) + \" { \/\/ supers\");\n+            for (int k = 0; k < sup_count; k++) {\n+                out_println(\"#\" + in.readUnsignedShort() + \";\");\n+            }\n+            out_end(\"} \/\/ supers\");\n+\n+            int int_count = in.readUnsignedByte();\n+            out_begin(startArray(int_count) + \"b { \/\/ interfaces\");\n+            for (int k = 0; k < int_count; k++) {\n+                out_println(\"#\" + in.readUnsignedShort() + \";\");\n+            }\n+            out_end(\"} \/\/ interfaces\");\n+\n+            int field_count = in.readUnsignedShort();\n+            out_begin(startArray(field_count) + \" { \/\/ fields\");\n+            for (int k = 0; k < field_count; k++) {\n+                out_begin(\"{ \/\/ field \" + k);\n+                out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n+\n+                int f_flags = in.readUnsignedShort();\n+                out_print(\"0x\");\n+                printByteHex(out, f_flags >> 8);\n+                printByteHex(out, f_flags);\n+                out.println(\"; \/\/ flags\");\n+\n+                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this field name\");\n+                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this field descriptor\");\n+\n+                int attr_count = in.readUnsignedShort();\n+                out_begin(startArray(attr_count) + \" { \/\/ Attributes\");\n+                for (int ai = 0; ai < attr_count; ai++) {\n+                    decodeAttr(in);\n+                }\n+                out_end(\"} \/\/ Attributes\");\n+                out_end(\"};\");\n+            }\n+            out_end(\"} \/\/ fields\");\n+\n+            int mth_count = in.readUnsignedShort();\n+            out_begin(startArray(mth_count) + \" { \/\/ methods\");\n+            for (int k = 0; k < mth_count; k++) {\n+                out_begin(\"{ \/\/ method \" + k);\n+                out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n+\n+                int mth_flags = in.readUnsignedShort();\n+                out_print(\"0x\");\n+                printByteHex(out, mth_flags >> 8);\n+                printByteHex(out, mth_flags);\n+                out.println(\"; \/\/ flags\");\n+\n+                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this method name\");\n+                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this method descriptor\");\n+                out_end(\"};\");\n+            }\n+            out_end(\"} \/\/ methods\");\n+            out_end(\"};\");\n+        }\n+        out_end(\"} \/\/ classes\");\n+        endComponent(in);\n+    }\n+\n+    DataInputStream beginComponent(String inpName) throws IOException {\n+        DataInputStream in = new DataInputStream(new FileInputStream(inpName));\n+        out_println(\"file \" + inpName);\n+\n+        int tag = in.readUnsignedByte();\n+        out_print(\"Component(\" + tag);\n+        int size = in.readUnsignedShort();\n+        if (printDetails) {\n+            out.print(\", \" + size);\n+        }\n+        out_begin(\") { \/\/ \" + compName(tag));\n+        return in;\n+    }\n+\n+    void endComponent(DataInputStream in) throws IOException {\n+        out_end(\"};\"); \/\/ Component\n+        int avail = in.available();\n+        if (avail > 0) {\n+            out.println(\"=========== extra bytes:\");\n+            for (int k = 0; k < 8; k++) {\n+                printBytes(in, avail >= 8 ? 8 : avail);\n+                avail = in.available();\n+                if (avail == 0) {\n+                    break;\n+                }\n+            }\n+            if (avail > 0) {\n+                out.println(\"  there is also \" + avail + \" bytes available\");\n+            }\n+        }\n+        in.close();\n+    }\n+\n+    ArrayList<Integer> methodsLengths = null;\n+    ArrayList<Integer> methodsOffsets = null;\n+\n+    void decodeHeader(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int magic = in.readInt();\n+        out_print(toHex(magic, 4) + \";  \/\/ \");\n+        if (magic != HEADER_MAGIC) {\n+            out.print(\"wrong magic: 0x\" + Integer.toString(HEADER_MAGIC, 16) + \" expected\");\n+        } else {\n+            out_print(\"magic\");\n+        }\n+        out.println();\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n+        out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/ flags\");\n+\n+        out_begin(\"{  \/\/ package info\");\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n+        int aid_len = in.readUnsignedByte();\n+        out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n+        printBytes(in, aid_len);\n+        out_end(\"};\"); \/\/ Bytes[]\n+        out_end(\"};\"); \/\/ package info\n+        endComponent(in);\n+    }\n+\n+    void decodeDirectory(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int i;\n+        out_begin(\"{  \/\/ component sizes\");\n+        for (i = 0; i < 11; i++) {\n+            out_println(in.readUnsignedShort() + \";  \/\/ \" + (i + 1));\n+        }\n+        out_end(\"};\");\n+\n+        out_begin(\"{  \/\/ static field size\");\n+        out_println(in.readUnsignedShort() + \";  \/\/ image size\");\n+        out_println(in.readUnsignedShort() + \";  \/\/ array init count\");\n+        out_println(in.readUnsignedShort() + \";  \/\/ array init size\");\n+        out_end(\"};\");\n+\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ import count\");\n+        out_println(in.readUnsignedByte() + \"b;  \/\/ applet count\");\n+\n+        int custom_count = in.readUnsignedByte();\n+        out_begin(startArray(custom_count) + \"b { \/\/ custom components\");\n+        for (i = 0; i < custom_count; i++) {\n+            out_print(\"Comp(\" + in.readUnsignedByte());  \/\/ tag;\n+            int size2 = in.readUnsignedShort();\n+            if (printDetails) {\n+                out_print(\", \" + size2);\n+            }\n+            out_begin(\") {\");\n+            int aid_len = in.readUnsignedByte();\n+            out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n+            printBytes(in, aid_len);\n+            out_end(\"};\");\n+            out_end(\"};\");\n+        }\n+        out_end(\"};\");\n+\n+        endComponent(in);\n+    }\n+\n+    void decodeApplet(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int applet_count = in.readUnsignedByte();\n+        out_begin(startArray(applet_count) + \"b { \/\/ applets\");\n+        for (int i = 0; i < applet_count; i++) {\n+            out_begin(\"{ \/\/ applet \" + i);\n+            int aid_len = in.readUnsignedByte();\n+            out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n+            printBytes(in, aid_len);\n+            out_end(\"};\"); \/\/ Bytes[]\n+            out_println(in.readUnsignedShort() + \";  \/\/ install method offset\");\n+            out_end(\"};\"); \/\/ applet\n+        }\n+        out_end(\"};\"); \/\/ applets\n+        endComponent(in);\n+    }\n+\n+    void decodeImport(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int package_count = in.readUnsignedByte();\n+        out_begin(startArray(package_count) + \"b { \/\/  packages\");\n+        for (int i = 0; i < package_count; i++) {\n+            out_begin(\"{ \/\/ package \" + i);\n+            out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n+            out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n+            int aid_len = in.readUnsignedByte();\n+            out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n+            printBytes(in, aid_len);\n+            out_end(\"};\"); \/\/ Bytes[]\n+            out_end(\"};\"); \/\/ package info\n+        }\n+        out_end(\"};\"); \/\/  package info\n+        endComponent(in);\n+    }\n+\n+    static String[] refNames = {\n+        \"Classref\",\n+        \"InstanceFieldref\",\n+        \"VirtualMethodref\",\n+        \"SuperMethodref\",\n+        \"StaticFieldref\",\n+        \"StaticMethodref\"\n+    };\n+\n+    void decodeConstantPool(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int items_count = in.readUnsignedShort();\n+        out_begin(startArray(items_count) + \" { \/\/  items\");\n+        for (int i = 0; i < items_count; i++) {\n+            int tag = in.readUnsignedByte();\n+            int info1 = in.readUnsignedByte(),\n+                    info2 = in.readUnsignedByte(),\n+                    info3 = in.readUnsignedByte();\n+            out_print(tag + \"b \");\n+            if ((tag > 0) && (tag <= 6)) {\n+                if ((info1 & 0x80) == 0) {\n+                    if (tag <= 4) {\n+                        out_print(((info1 << 8) | info2) + \" \" + info3 + \"b;\");\n+                    } else {\n+                        out_print(info1 + \"b \" + ((info2 << 8) | info3) + \";\");\n+                    }\n+                    out.print(\" \/\/ internal \");\n+                } else {\n+                    out.print(info1 + \"b \" + info2 + \"b \" + info3 + \"b;\");\n+                    out.print(\" \/\/ external \");\n+                }\n+                out.println(refNames[tag - 1]);\n+            } else {\n+                out.print(info1 + \"b \" + info2 + \"b \" + info3 + \"b;\");\n+                out.println(\" \/\/ unknown tag \");\n+            }\n+        }\n+        out_end(\"};\"); \/\/  CP array\n+        endComponent(in);\n+    }\n+\n+    void printClassref(DataInputStream in) throws IOException {\n+        int info1 = in.readUnsignedByte(),\n+                info2 = in.readUnsignedByte();\n+        if ((info1 & 0x80) == 0) {\n+            out_print(((info1 << 8) | info2) + \";\");\n+            out_print(\" \/\/ internal \");\n+        } else {\n+            out_print(info1 + \"b \" + info2 + \"b;\");\n+            out_print(\" \/\/ external \");\n+        }\n+        out_println(\" Classref \");\n+    }\n+\n+    void decodeClass(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        for (int i = 0; in.available() > 0; i++) {\n+            out_begin(\"{ \/\/ class \" + i);\n+            int bitfield = in.readUnsignedByte();\n+            int interface_count = bitfield & 0x0F;\n+            out_print(\"0x\");\n+            printByteHex(out, bitfield);\n+            out.println(\"; \/\/ bitfield\");\n+            if ((bitfield & 0x80) != 0) {\n+                \/\/ interface\n+                for (int k = 0; k < interface_count; k++) {\n+                    printClassref(in);\n+                }\n+            } else {\n+                \/\/ class\n+                printClassref(in);\n+                out_println(in.readUnsignedByte() + \"b;  \/\/ declared instance size\");\n+                out_println(in.readUnsignedByte() + \"b;  \/\/ first reference token\");\n+                out_println(in.readUnsignedByte() + \"b;  \/\/ reference count\");\n+                out_println(in.readUnsignedByte() + \"b;  \/\/ public method table base\");\n+                int pumrc = in.readUnsignedByte();\n+                out_println(pumrc + \"b;  \/\/ public method table count\");\n+                out_println(in.readUnsignedByte() + \"b;  \/\/ package method table base\");\n+                int pamrc = in.readUnsignedByte();\n+                out_println(pamrc + \"b;  \/\/ package method table count\");\n+                out_begin(\"{ \/\/ public method table\");\n+                for (int k = 0; k < pumrc; k++) {\n+                    out_println(in.readUnsignedShort() + \";\");\n+                }\n+                out_end(\"};\");\n+                out_begin(\"{ \/\/ package method table\");\n+                for (int k = 0; k < pamrc; k++) {\n+                    out_println(in.readUnsignedShort() + \";\");\n+                }\n+                out_end(\"};\");\n+                out_begin(\"{ \/\/ implemented interfaces\");\n+                for (int k = 0; k < interface_count; k++) {\n+                    out_begin(\"{ \/\/ interface \" + k);\n+                    printClassref(in);\n+                    int count = in.readUnsignedByte();\n+                    out_begin(\"Bytes\" + startArray(count) + \"b {\");\n+                    printBytes(in, count);\n+                    out_end(\"};\"); \/\/ Bytes[]\n+                    out_end(\"};\");\n+                }\n+                out_end(\"};\");\n+            }\n+            out_end(\"};\");\n+        }\n+        endComponent(in);\n+    }\n+\n+    void decodeDescriptor(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        methodsLengths = new ArrayList<>();\n+        methodsOffsets = new ArrayList<>();\n+        int class_count = in.readUnsignedByte();\n+        out_begin(startArray(class_count) + \"b { \/\/ classes\");\n+        for (int c = 0; c < class_count; c++) {\n+            out_begin(\"{ \/\/ class \" + c);\n+            out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n+            out_print(\"0x\");\n+            printByteHex(out, in.readUnsignedByte());\n+            out.println(\"; \/\/ flags\");\n+            printClassref(in);\n+            int icount = in.readUnsignedByte();\n+            out_println(icount + \"b; \/\/ interface count\");\n+            int fcount = in.readUnsignedShort();\n+            out_println(fcount + \"; \/\/ field count\");\n+            int mcount = in.readUnsignedShort();\n+            out_println(mcount + \"; \/\/ method count\");\n+            if (icount != 0) {\n+                out_begin(\"{ \/\/ interfaces\");\n+                for (int i = 0; i < icount; i++) {\n+                    printClassref(in);\n+                }\n+                out_end(\"};\");\n+            }\n+            for (int i = 0; i < fcount; i++) {\n+                out_begin(\"{ \/\/ field \" + i);\n+                out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n+                int flags = in.readUnsignedByte();\n+                out_print(\"0x\");\n+                printByteHex(out, flags);\n+                out.println(\"; \/\/ flags\");\n+                if ((flags & 0x08) == 0) {\n+                    printClassref(in);\n+                    out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n+                } else { \/\/ static field\n+                    int info1 = in.readUnsignedByte(),\n+                            info2 = in.readUnsignedByte(),\n+                            info3 = in.readUnsignedByte();\n+                    if ((info1 & 0x80) == 0) {\n+                        out_print(info1 + \"b \" + ((info2 << 8) | info3) + \";\");\n+                        out.println(\" \/\/ internal field\");\n+                    } else {\n+                        out.print(info1 + \"b \" + info2 + \"b \" + info3 + \"b;\");\n+                        out.println(\" \/\/ external field\");\n+                    }\n+                }\n+                int type = in.readUnsignedShort();\n+                if ((type & 0x8000) == 0) {\n+                    out_println(type + \"; \/\/ reference type\");\n+                } else {\n+                    out_print(\"0x\");\n+                    printByteHex(out, type >> 8);\n+                    printByteHex(out, type);\n+                    out.println(\"; \/\/ primitive type\");\n+                }\n+                out_end(\"};\");\n+            }\n+            for (int i = 0; i < mcount; i++) {\n+                int token = in.readUnsignedByte();\n+                int flags = in.readUnsignedByte();\n+                int m_offset = in.readUnsignedShort();\n+                int t_offset = in.readUnsignedShort();\n+                int bytecode_count = in.readUnsignedShort();\n+                if (m_offset != 0) {\n+                    out_begin(\"{ \/\/ method \" + i + \" (\" + methodsLengths.size() + \")\");\n+                    methodsLengths.add(bytecode_count);\n+                    methodsOffsets.add(m_offset);\n+                } else {\n+                    out_begin(\"{ \/\/ method \" + i);\n+                }\n+                out_println(token + \"b; \/\/ token\");\n+                out_print(\"0x\");\n+                printByteHex(out, flags);\n+                out.println(\"; \/\/ flags\");\n+                out_println(m_offset + \"; \/\/ method offset\");\n+                out_println(t_offset + \"; \/\/ type offset\");\n+                out_println(bytecode_count + \"; \/\/ bytecode count\");\n+                out_println(in.readUnsignedShort() + \"; \/\/ exception handler count\");\n+                out_println(in.readUnsignedShort() + \"; \/\/ exception handler index\");\n+                out_end(\"};\");\n+            }\n+            out_end(\"};\"); \/\/ class i\n+        }\n+        out_end(\"}; \/\/ classes\");\n+\n+        int cp_count = in.readUnsignedShort();\n+        out_begin(startArray(cp_count) + \" { \/\/ constant pool types\");\n+        for (int i = 0; i < cp_count; i++) {\n+            int type = in.readUnsignedShort();\n+            if (type == 0xFFFF) {\n+                out_println(\"0xFFFF;\");\n+            } else {\n+                out_println(type + \"; \");\n+            }\n+        }\n+        out_end(\"}; \/\/ constant pool types\");\n+\n+        out_begin(\"{ \/\/ type descriptors\");\n+        for (int i = 0; in.available() > 0; i++) {\n+            int nibble_count = in.readUnsignedByte();\n+            out_print(nibble_count + \"b; \");\n+            printBytes(in, (nibble_count + 1) \/ 2);\n+        }\n+        out_end(\"}; \/\/ type descriptors\");\n+        endComponent(in);\n+    }\n+\n+    void decodeMethod(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int handler_count = in.readUnsignedByte();\n+        out_begin(startArray(handler_count) + \"b { \/\/ exception handlers\");\n+        for (int i = 0; i < handler_count; i++) {\n+            out_print(in.readUnsignedShort() + \", \");\n+            int bitfield = in.readUnsignedShort();\n+            out.print(\"0x\");\n+            printByteHex(out, bitfield >> 8);\n+            printByteHex(out, bitfield);\n+            out.print(\", \" + in.readUnsignedShort() + \", \");\n+            out.println(in.readUnsignedShort() + \"; \/\/ handler \" + i);\n+        }\n+        out_end(\"};\"); \/\/ handlers\n+\n+        if (methodsLengths == null) {\n+            out.println(\"\/\/ Descriptor.cap absent - methods not printed\");\n+        } else {\n+            int f_offset = 1 + handler_count * 8;\n+            for (int i = 0; i < methodsLengths.size(); i++) {\n+                out_begin(\"{ \/\/ method \" + i);\n+                int m_offset = methodsOffsets.get(i);\n+                if (m_offset != f_offset) {\n+                    out.println(\"file offset=\" + f_offset + \" but m_offset=\" + m_offset);\n+                    break;\n+                }\n+                int bitfield = in.readUnsignedByte();\n+                if ((bitfield & 0x80) == 0) {\n+                    out_print(\"0x\");\n+                    printByteHex(out, bitfield);\n+                    out.println(\"; \/\/ flags, max_stack\");\n+                    out_print(\"0x\");\n+                    printByteHex(out, in.readUnsignedByte());\n+                    out.println(\"; \/\/ nargs, max_locals\");\n+                    f_offset += 2;\n+                } else {\n+                    out_print(\"0x\");\n+                    printByteHex(out, bitfield);\n+                    out.println(\"; \/\/ flags, padding\");\n+                    out_println(in.readUnsignedByte() + \"b; \/\/ max_stack\");\n+                    out_println(in.readUnsignedByte() + \"b; \/\/ nargs\");\n+                    out_println(in.readUnsignedByte() + \"b; \/\/ max_locals\");\n+                    f_offset += 4;\n+                }\n+                int bytecode_count = methodsLengths.get(i);\n+                out_begin(\"{ \/\/ bytecodes\");\n+                printBytes(in, bytecode_count);\n+                f_offset += bytecode_count;\n+                out_end(\"};\");\n+                out_end(\"};\");\n+            }\n+        }\n+\n+        endComponent(in);\n+    }\n+\n+    void decodeStaticField(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int image_size = in.readUnsignedShort();\n+        out_println(image_size + \"; \/\/ image size\");\n+        int reference_count = in.readUnsignedShort();\n+        out_println(reference_count + \"; \/\/ reference count\");\n+        int array_init_count = in.readUnsignedShort();\n+        out_begin(startArray(array_init_count) + \" { \/\/ array_init_info\");\n+        for (int i = 0; i < array_init_count; i++) {\n+            out_println(in.readUnsignedByte() + \"b \/\/ type \");\n+            int count = in.readUnsignedShort();\n+            out_begin(\"Bytes\" + startArray(count) + \"s { \/\/ values\");\n+            printBytes(in, count);\n+            out_end(\"};\"); \/\/ Bytes[]\n+        }\n+        out_end(\"};\"); \/\/ array_init_info\n+        int default_value_count = in.readUnsignedShort();\n+        out_println(default_value_count + \"; \/\/ default value count\");\n+        int non_default_value_count = in.readUnsignedShort();\n+        out_begin(\"Bytes\" + startArray(non_default_value_count) + \"s { \/\/ non default values\");\n+        printBytes(in, non_default_value_count);\n+        out_end(\"};\"); \/\/ Bytes[]\n+\n+        endComponent(in);\n+    }\n+\n+    void decodeRefLocation(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+\n+        int byte_index_count = in.readUnsignedShort();\n+        out_begin(\"Bytes\" + startArray(byte_index_count) + \"s { \/\/ offsets to byte indices\");\n+        printBytes(in, byte_index_count);\n+        out_end(\"};\"); \/\/ Bytes[]\n+\n+        byte_index_count = in.readUnsignedShort();\n+        out_begin(\"Bytes\" + startArray(byte_index_count) + \"s { \/\/ offsets to byte2 indices\");\n+        printBytes(in, byte_index_count);\n+        out_end(\"};\"); \/\/ Bytes[]\n+\n+        endComponent(in);\n+    }\n+\n+    void decodeExport(String inpName) throws IOException {\n+        DataInputStream in = beginComponent(inpName);\n+        int class_count = in.readUnsignedByte();\n+        out_begin(startArray(class_count) + \"b { \/\/ classes\");\n+        for (int i = 0; i < class_count; i++) {\n+            out_begin(\"{ \/\/ class \" + i);\n+            out_println(in.readUnsignedShort() + \"; \/\/ class offset\");\n+            int fcount = in.readUnsignedByte();\n+            out_println(fcount + \"b; \/\/ static field count\");\n+            int mcount = in.readUnsignedByte();\n+            out_println(mcount + \"b; \/\/ static method count\");\n+            out_begin(\"{ \/\/ static field offsets\");\n+            for (int j = 0; j < fcount; j++) {\n+                out_println(in.readUnsignedShort() + \"; \/\/ field \" + j + \" offset\");\n+            }\n+            out_end(\"};\");\n+            out_begin(\"{ \/\/ static method offsets\");\n+            for (int j = 0; j < mcount; j++) {\n+                out_println(in.readUnsignedShort() + \"; \/\/ method \" + j + \" offset\");\n+            }\n+            out_end(\"};\");\n+            out_end(\"};\"); \/\/ class i\n+        }\n+        out_end(\"};\"); \/\/ classes\n+        endComponent(in);\n+    }\n+    \/*========================================================*\/\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    public Main(PrintWriter out, String program) {\n+        this.out = out;\n+        this.program = program;\n+    }\n+\n+    public void error(String msg) {\n+        out.println(program + \": \" + msg);\n+    }\n+\n+    \/**\n+     * Usage\n+     *\/\n+    public void usage() {\n+        out.println(i18n.getString(\"jcdec.usage\"));\n+        out.println(i18n.getString(\"jcdec.opt.g\"));\n+        out.println(i18n.getString(\"jcdec.opt.version\"));\n+    }\n+\n+    \/**\n+     * Run the decoder\n+     *\/\n+    public synchronized boolean decode(String argv[]) {\n+\/\/      int flags = F_WARNINGS;\n+        long tm = System.currentTimeMillis();\n+        ArrayList<String> vargs = new ArrayList<>();\n+        ArrayList<String> vj = new ArrayList<>();\n+        boolean nowrite = false;\n+        int addOptions = 0;\n+\n+        \/\/ Parse arguments\n+        for (int i = 0; i < argv.length; i++) {\n+            String arg = argv[i];\n+            if (arg.equals(\"-g\")) {\n+                printDetails = true;\n+                vargs.add(arg);\n+            } else if (arg.equals(\"-v\")) {\n+                DebugFlag = true;\n+                vargs.add(arg);\n+                out.println(\"arg[\" + i + \"]=\" + argv[i] + \"\/verbose\");\n+            } else if (arg.equals(\"-version\")) {\n+                out.println(ProductInfo.FULL_VERSION);\n+            } else if (arg.startsWith(\"-\")) {\n+\/\/out.println(\"arg[\"+i+\"]=\"+argv[i]+\"\/invalid flag\");\n+                error(i18n.getString(\"jcdec.error.invalid_flag\", arg));\n+                usage();\n+                return false;\n+            } else {\n+                vargs.add(arg);\n+                vj.add(arg);\n+            }\n+        }\n+\n+        if (vj.isEmpty()) {\n+            usage();\n+            return false;\n+        }\n+\n+\/\/        String[] names = new String[vj.size()];\n+\/\/        vj.copyInto(names);\n+        String[] names = null;\n+        names = vj.toArray(names);\n+decode:\n+        for (int k = 0; k < names.length; k++) {\n+            String inpname = names[k];\n+            try {\n+                if (inpname.endsWith(\".cap\")) {\n+                    String shortName = inpname.substring(0, inpname.length() - 4);\n+                    if (shortName.endsWith(\"Header\")) {\n+                        decodeHeader(inpname);\n+                    } else if (shortName.endsWith(\"Directory\")) {\n+                        decodeDirectory(inpname);\n+                    } else if (shortName.endsWith(\"Applet\")) {\n+                        decodeApplet(inpname);\n+                    } else if (shortName.endsWith(\"Import\")) {\n+                        decodeImport(inpname);\n+                    } else if (shortName.endsWith(\"ConstantPool\")) {\n+                        decodeConstantPool(inpname);\n+                    } else if (shortName.endsWith(\"Class\")) {\n+                        decodeClass(inpname);\n+                    } else if (shortName.endsWith(\"Descriptor\")) {\n+                        decodeDescriptor(inpname);\n+                    } else if (shortName.endsWith(\"Method\")) {\n+                        decodeMethod(inpname);\n+                    } else if (shortName.endsWith(\"StaticField\")) {\n+                        decodeStaticField(inpname);\n+                    } else if (shortName.endsWith(\"RefLocation\")) {\n+                        decodeRefLocation(inpname);\n+                    } else if (shortName.endsWith(\"Export\")) {\n+                        decodeExport(inpname);\n+                    } else {\n+                        continue decode;\n+                    }\n+                    out.println(\"\");\n+                } else if (inpname.endsWith(\".exp\")) {\n+                    decodeExp(inpname);\n+                    out.println(\"\");\n+                }\n+                continue decode;\n+            } catch (FileNotFoundException ee) {\n+                error(i18n.getString(\"jcdec.error.cannot_read\", inpname));\n+            } catch (Error ee) {\n+                ee.printStackTrace();\n+                error(i18n.getString(\"jcdec.error.fatal_error\"));\n+            } catch (Exception ee) {\n+                ee.printStackTrace();\n+                error(i18n.getString(\"jcdec.error.fatal_exception\"));\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Main program\n+     *\/\n+    public static void main(String argv[]) {\n+        Main decoder = new Main(new PrintWriter(new uEscWriter(System.out)), \"jcdec\");\n+        System.exit(decoder.decode(argv) ? 0 : 1);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcdec\/Main.java","additions":957,"deletions":0,"binary":false,"changes":957,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+# Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+jcdec.error.invalid_flag=invalid flag: \" {0}\n+jcdec.error.fatal_error=fatal error\n+jcdec.error.fatal_exception=fatal exception\n+jcdec.error.cannot_read=cannot read {0}\n+jcdec.usage=\\\n+Usage: java -jar asmtools.jar jcdec [options] FILE.class... > FILE.jcod\\n\\\n+where possible options include:\n+\n+jcdec.opt.g=\\\n+\\     -g:  detailed output format\n+jcdec.opt.version=\\\n+\\     -version:  print version number and date\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcdec\/i18n.properties","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+\/**\n+ * Compiles just 1 source file\n+ *\/\n+class ByteBuffer extends java.io.OutputStream {\n+\n+    String myname;\n+    \/**\n+     * The buffer where elements are stored.\n+     *\/\n+    byte data[];\n+    \/**\n+     * The number of elements in the buffer.\n+     *\/\n+    int length;\n+    \/**\n+     * The size of the increment. If it is 0 the size of the the buffer is doubled\n+     * everytime it needs to grow.\n+     *\/\n+    protected int capacityIncrement;\n+\n+    \/**\n+     * Constructs an empty vector with the specified storage capacity and the specified\n+     * capacityIncrement.\n+     *\n+     * @param initialCapacity the initial storage capacity of the vector\n+     * @param capacityIncrement how much to increase the element's size by.\n+     *\/\n+    public ByteBuffer(int initialCapacity, int capacityIncrement) {\n+\/\/      super();\n+        this.data = new byte[initialCapacity];\n+        this.capacityIncrement = capacityIncrement;\n+    }\n+\n+    \/**\n+     * Constructs an empty vector with the specified storage capacity.\n+     *\n+     * @param initialCapacity the initial storage capacity of the vector\n+     *\/\n+    public ByteBuffer(int initialCapacity) {\n+        this(initialCapacity, 0);\n+    }\n+\n+    \/**\n+     * Constructs an empty vector.\n+     *\/\n+    public ByteBuffer() {\n+        this(30);\n+    }\n+\n+    \/**\n+     * Constructs a full vector.\n+     *\/\n+    public ByteBuffer(byte data[], int capacityIncrement) {\n+        this.length = data.length;\n+        this.data = data;\n+        this.capacityIncrement = capacityIncrement;\n+    }\n+\n+    \/**\n+     * Constructs a full vector.\n+     *\/\n+    public ByteBuffer(byte data[]) {\n+        this(data, 0);\n+    }\n+\n+    \/**\n+     * Returns the number of elements in the vector. Note that this is not the same as the\n+     * vector's capacity.\n+     *\/\n+    public final int size() {\n+        return length;\n+    }\n+\n+    \/**\n+     * Ensures that the vector has at least the specified capacity.\n+     *\n+     * @param minCapacity the desired minimum capacity\n+     *\/\n+    public final synchronized void ensureCapacity(int minCapacity) {\n+        int oldCapacity = data.length;\n+        if (minCapacity <= oldCapacity) {\n+            return;\n+        }\n+        byte oldData[] = data;\n+        int newCapacity = (capacityIncrement > 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2);\n+        if (newCapacity < minCapacity) {\n+            newCapacity = minCapacity;\n+        }\n+        data = new byte[newCapacity];\n+        System.arraycopy(oldData, 0, data, 0, length);\n+    }\n+\n+    \/*======================================*\/\n+    public void write(int val) {\n+        ensureCapacity(length + 1);\n+        data[length++] = (byte) val;\n+    }\n+\n+    public void writeAt(int index, long val, int width) {\n+        for (int i = 0; i < width; i++) {\n+            data[index + i] = (byte) (val >> (width - 1 - i) * 8);\n+        }\n+    }\n+\n+    public void append(long val, int width) {\n+        ensureCapacity(length + width);\n+        writeAt(length, val, width);\n+        length += width;\n+    }\n+\n+    \/*======================================================*\/\n+} \/\/ end ByteBuffer\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/ByteBuffer.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+\/**\n+ * A sorted list of error messages\n+ *\/\n+final class ErrorMessage {\n+\n+    int where;\n+    String message;\n+    ErrorMessage next;\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    ErrorMessage(int where, String message) {\n+        this.where = where;\n+        this.message = message;\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/ErrorMessage.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,387 @@\n+\/*\n+ * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+\n+import java.io.PrintWriter;\n+import java.util.HashMap;\n+\n+\/**\n+ *\n+ * JcodTokens\n+ *\n+ * This class contains tokens specific to parsing JCOD syntax.\n+ *\n+ * The classes in JcodTokens are following a Singleton Pattern. These classes are Enums,\n+ * and they are contained in private hash maps (lookup tables and reverse lookup tables).\n+ * These hash maps all have public accessors, which clients use to look-up enums.\n+ *\n+ * Tokens in this table carry no external state, and are typically treated as constants.\n+ * They do not need to be reset.\n+ *\/\n+public class JcodTokens {\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Marker: describes the type of Keyword *\/\n+    static public enum KeywordType {\n+\n+        TOKEN(0, \"TOKEN\"),\n+        KEYWORD(3, \"KEYWORD\");\n+\n+        private final Integer value;\n+        private final String printval;\n+\n+        KeywordType(Integer val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Marker - describes the type of token *\/\n+    \/*    this is rather cosmetic, no function currently. *\/\n+    static public enum TokenType {\n+        VALUE               (0, \"Value\"),\n+        KEYWORDS            (1, \"Keywords\"),\n+        PUNCTUATION         (2, \"Punctuation\"),\n+        JDEC                (3, \"JDec\"),\n+        STACKMAP            (4, \"StackMap\"),\n+        MISC                (5, \"Misc\");\n+\n+        private final Integer value;\n+        private final String printval;\n+\n+        TokenType(Integer val, String print) {\n+            value = val;\n+            printval = print;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+    }\n+\n+  \/*-------------------------------------------------------- *\/\n+  \/** Scanner Tokens (Definitive List) *\/\n+    static public enum Token {\n+        EOF                 (-1, \"EOF\",             \"EOF\",          TokenType.MISC),\n+        IDENT               (60, \"IDENT\",           \"IDENT\",        TokenType.VALUE),\n+        LONGSTRINGVAL       (61, \"LONGSTRINGVAL\",   \"LONGSTRING\",   TokenType.VALUE),\n+        INTVAL              (65, \"INTVAL\",          \"INT\",          TokenType.VALUE),\n+        LONGVAL             (66, \"LONGVAL\",         \"LONG\",         TokenType.VALUE),\n+        STRINGVAL           (69, \"STRINGVAL\",       \"STRING\",       TokenType.VALUE),\n+\n+        CLASS               (70, \"CLASS\",           \"class\",        TokenType.KEYWORDS, KeywordType.KEYWORD),\n+        INTERFACE           (71, \"INTERFACE\",       \"interface\",    TokenType.KEYWORDS, KeywordType.KEYWORD),\n+        DIV                 (72, \"DIV\",             \"div\",          TokenType.KEYWORDS),\n+        EQ                  (73, \"EQ\",              \"eq\",           TokenType.KEYWORDS),\n+        ASSIGN              (74, \"ASSIGN\",          \"assign\",       TokenType.KEYWORDS),\n+        MODULE              (75, \"MODULE\",          \"module\",       TokenType.KEYWORDS, KeywordType.KEYWORD),\n+\n+        COLON               (134, \"COLON\",        \":\",    TokenType.PUNCTUATION),\n+        SEMICOLON           (135, \"SEMICOLON\",    \";\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+        COMMA               (0,   \"COMMA\",        \",\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+        LBRACE              (138, \"LBRACE\",       \"{\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+        RBRACE              (139, \"RBRACE\",       \"}\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+        LPAREN              (140, \"LPAREN\",       \"(\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+        RPAREN              (141, \"RPAREN\",       \")\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+        LSQBRACKET          (142, \"LSQBRACKET\",   \"[\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+        RSQBRACKET          (143, \"RSQBRACKET\",   \"]\",    TokenType.PUNCTUATION, KeywordType.KEYWORD),\n+\n+\n+        BYTEINDEX           (156, \"BYTEINDEX\",   \"b\",       TokenType.JDEC, KeywordType.KEYWORD),\n+        SHORTINDEX          (157, \"SHORTINDEX\",  \"s\",       TokenType.JDEC, KeywordType.KEYWORD),\n+        ATTR                (158, \"ATTR\",        \"Attr\",    TokenType.JDEC, KeywordType.KEYWORD),\n+        BYTES               (159, \"BYTES\",       \"Bytes\",   TokenType.JDEC, KeywordType.KEYWORD),\n+        MACRO               (160, \"MACRO\",        \"Attr\",    TokenType.JDEC),\n+        COMP                (161, \"COMP\",        \"Component\", TokenType.JDEC, KeywordType.KEYWORD),\n+        FILE                (162, \"FILE\",        \"file\",    TokenType.JDEC, KeywordType.KEYWORD),\n+\n+        ZEROINDEX           (163, \"ZEROINDEX\",   \"z\",       TokenType.STACKMAP, KeywordType.KEYWORD);\n+\n+        private Integer value;\n+        private String printval;\n+        private String parsekey;\n+        private TokenType tk_type;\n+        private KeywordType key_type;\n+\n+        \/\/ By default, if a KeywordType is not specified, it has the value 'TOKEN'\n+        Token(Integer val, String print, String op) {\n+            init(val, print, op, TokenType.VALUE, KeywordType.TOKEN);\n+        }\n+\n+        Token(Integer val, String print, String op, TokenType tt) {\n+            init(val, print, op, tt, KeywordType.TOKEN);\n+        }\n+\n+        Token(Integer val, String print, String op, TokenType tt, KeywordType kt) {\n+            init(val, print, op, tt, kt);\n+        }\n+\n+        private void init(Integer val, String print, String op, TokenType tt, KeywordType kt) {\n+            value = val;\n+            printval = print;\n+            parsekey = op;\n+            tk_type = tt;\n+            key_type = kt;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+\n+        public String parsekey() {\n+            return parsekey;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<\" + printval + \"> [\" + value + \"]\";\n+        }\n+\n+    }\n+\n+    \/**\n+     * Initialized keyword and token Hash Maps (and Reverse Tables)\n+     *\/\n+    protected static final int MaxTokens = 172;\n+    private static HashMap<Integer, Token> TagToTokens = new HashMap<>(MaxTokens);\n+    private static HashMap<String, Token> SymbolToTokens = new HashMap<>(MaxTokens);\n+    private static HashMap<String, Token> ParsekeyToTokens = new HashMap<>(MaxTokens);\n+\n+    protected static final int MaxKeywords = 40;\n+    private static HashMap<Integer, Token> TagToKeywords = new HashMap<>(MaxKeywords);\n+    private static HashMap<String, Token> SymbolToKeywords = new HashMap<>(MaxKeywords);\n+    private static HashMap<String, Token> ParsekeyToKeywords = new HashMap<>(MaxKeywords);\n+\n+    static {\n+\n+        \/\/ register all of the tokens\n+        for (Token tk : Token.values()) {\n+            registerToken(tk);\n+        }\n+\n+        SymbolToKeywords.put(Token.INTVAL.printval(), Token.INTVAL);\n+        ParsekeyToKeywords.put(Token.INTVAL.parsekey(), Token.INTVAL);\n+        SymbolToKeywords.put(Token.STRINGVAL.printval(), Token.STRINGVAL);\n+        ParsekeyToKeywords.put(Token.STRINGVAL.parsekey(), Token.STRINGVAL);\n+    }\n+\n+    private static void registerToken(Token tk) {\n+        \/\/ Tag is a keyword\n+        if (tk.key_type == KeywordType.KEYWORD) {\n+            TagToKeywords.put(tk.value, tk);\n+            SymbolToKeywords.put(tk.printval, tk);\n+            if (tk.parsekey != null) {\n+                ParsekeyToKeywords.put(tk.parsekey, tk);\n+            }\n+        }\n+\n+        \/\/ Finally, register all tokens\n+        TagToTokens.put(tk.value, tk);\n+        SymbolToTokens.put(tk.printval, tk);\n+        ParsekeyToTokens.put(tk.printval, tk);\n+    }\n+\n+    \/* Token accessors *\/\n+    public static Token token(int tk) {\n+        return TagToTokens.get(tk);\n+    }\n+\n+    public static Token keyword_token(int tk) {\n+        return TagToKeywords.get(tk);\n+    }\n+\n+    \/* Reverse lookup accessors *\/\n+    public static Token token(String parsekey) {\n+        return ParsekeyToTokens.get(parsekey);\n+    }\n+\n+    public static Token keyword_token(String parsekey) {\n+        return ParsekeyToKeywords.get(parsekey);\n+    }\n+\n+    \/* Reverse lookup by ID accessors *\/\n+    public static Token token_ID(String ID) {\n+        return ParsekeyToTokens.get(ID);\n+    }\n+\n+    public static Token keyword_token_ID(String ID) {\n+        return ParsekeyToKeywords.get(ID);\n+    }\n+\n+    public static String keywordName(int token) {\n+        String retval = \"\";\n+        if (token > TagToTokens.size()) {\n+            retval = null;\n+        } else {\n+            Token tk = keyword_token(token);\n+            if (tk != null) {\n+                retval = tk.parsekey;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    public static Token keyword_token_ident(String idValue) {\n+        Token kwd = keyword_token(idValue);\n+\n+        if (kwd == null) {\n+            kwd = Token.IDENT;\n+        }\n+        return kwd;\n+    }\n+\n+    public static int keyword_token_int(String idValue) {\n+        return keyword_token_ident(idValue).value();\n+    }\n+\n+    private static HashMap<String, ConstType> NameToConstantType = new HashMap<>(ConstType.maxTag);\n+    private static HashMap<Integer, ConstType> ConstantTypes = new HashMap<>(ConstType.maxTag);\n+\n+    static {\n+        \/\/ register all of the tokens\n+        for (ConstType ct : ConstType.values()) {\n+            registerConstantType(ct);\n+        }\n+    }\n+\n+    \/**\n+     * ConstType\n+     *\n+     * A (typed) tag (constant) representing the type of Constant in the Constant Pool.\n+     *\n+     * This is more-or-less a copy of jasm.ConstType. Unfortunately, there's no way to\n+     * sub-class (or slightly alter) the members of an enum. This enum set is slightly\n+     * modified from the Jasm one.\n+     *\/\n+    static public enum ConstType {\n+\/\/        CONSTANT_ZERO                       (-3, \"CONSTANT_ZERO\", \"\"),\n+        CONSTANT_UTF8                       (1, \"CONSTANT_UTF8\", \"Asciz\", \"Utf8\"),\n+        CONSTANT_UNICODE                    (2, \"CONSTANT_UNICODE\", \"\"),\n+        CONSTANT_INTEGER                    (3, \"CONSTANT_INTEGER\", \"int\", \"u4\"),\n+        CONSTANT_FLOAT                      (4, \"CONSTANT_FLOAT\", \"float\"),\n+        CONSTANT_LONG                       (5, \"CONSTANT_LONG\", \"long\"),\n+        CONSTANT_DOUBLE                     (6, \"CONSTANT_DOUBLE\", \"double\"),\n+        \/\/ Class is removed for JavaCard (???)\n+        CONSTANT_CLASS                      (7, \"CONSTANT_CLASS\", \"class\"),\n+        CONSTANT_STRING                     (8, \"CONSTANT_STRING\", \"String\"),\n+        CONSTANT_FIELD                      (9, \"CONSTANT_FIELD\", \"Field\"),\n+        CONSTANT_METHOD                     (10, \"CONSTANT_METHOD\", \"Method\"),\n+        CONSTANT_INTERFACEMETHOD            (11, \"CONSTANT_INTERFACEMETHOD\", \"InterfaceMethod\"),\n+        CONSTANT_NAMEANDTYPE                (12, \"CONSTANT_NAMEANDTYPE\", \"NameAndType\"),\n+        \/\/ added for JavaCard\n+        CONSTANT_JAVACARD_PACKAGE           (13, \"CONSTANT_PACKAGE\", \"package\"),  \/\/ in javacard export file\n+        \/\/ Constant 14 reserved\n+        CONSTANT_METHODHANDLE               (15, \"CONSTANT_METHODHANDLE\", \"MethodHandle\"),\n+        CONSTANT_METHODTYPE                 (16, \"CONSTANT_METHODTYPE\", \"MethodType\"),\n+        CONSTANT_DYNAMIC                    (17, \"CONSTANT_DYNAMIC\", \"Dynamic\"),\n+        CONSTANT_INVOKEDYNAMIC              (18, \"CONSTANT_INVOKEDYNAMIC\", \"InvokeDynamic\"),\n+        CONSTANT_MODULE                     (19, \"CONSTANT_MODULE\",  \"Module\"),\n+        CONSTANT_MODULE_PACKAGE             (20, \"CONSTANT_PACKAGE\", \"Package\");\n+\n+        public static final int maxTag = 20;\n+\n+        private final int value;\n+        private final String parseKey;\n+        private final String printval;\n+        private final String alias;\n+\n+        ConstType(int val, String print, String parse) {\n+            value = val;\n+            parseKey = parse;\n+            printval = print;\n+            alias = null;\n+        }\n+\n+        ConstType(int val, String print, String parse, String als) {\n+            value = val;\n+            parseKey = parse;\n+            printval = print;\n+            alias = als;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public String parseKey() {\n+            return parseKey;\n+        }\n+\n+        public String printval() {\n+            return printval;\n+        }\n+\n+        public void print(PrintWriter out) {\n+            out.print(parseKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<\" + printval + \"> [\" + Integer.toString(value) + \"]\";\n+        }\n+    };\n+\n+    static public ConstType constType(int i) {\n+        return ConstantTypes.get(i);\n+    }\n+\n+    static public ConstType constType(String parsekey) {\n+        return NameToConstantType.get(parsekey);\n+    }\n+\n+    private static void registerConstantType(ConstType tt) {\n+        NameToConstantType.put(tt.parseKey, tt);\n+        if (tt.alias != null) {\n+            NameToConstantType.put(tt.alias, tt);\n+        }\n+        ConstantTypes.put(tt.value, tt);\n+    }\n+\n+    public static int constValue(String stringValue) {\n+        ConstType Val = constType(stringValue);\n+        int val = -1;\n+\n+        if (Val != null) {\n+            val = Val.value();\n+        } else {\n+            StackMapType smt = stackMapTypeKey(stringValue);\n+\n+            if (smt != null) {\n+                val = smt.value();\n+            }\n+        }\n+        return val;\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/JcodTokens.java","additions":387,"deletions":0,"binary":false,"changes":387,"status":"added"},{"patch":"@@ -0,0 +1,766 @@\n+\/*\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Stack;\n+\n+import static org.openjdk.asmtools.jcoder.JcodTokens.ConstType;\n+import static org.openjdk.asmtools.jcoder.JcodTokens.Token;\n+\n+\/**\n+ * Compiles just 1 source file\n+ *\/\n+class Jcoder {\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Jcoder Fields *\/\n+    private ArrayList<ByteBuffer> Classes = new ArrayList<>();\n+    private ByteBuffer buf;\n+    private DataOutputStream bufstream;\n+    private int depth = 0;\n+    private String tabStr = \"\";\n+    private Context context = null;\n+    protected SourceFile env;\n+    protected Scanner scanner;\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Jcoder inner classes *\/\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* ContextTag (marker) - describes the type of token *\/\n+    \/*    this is rather cosmetic, no function currently. *\/\n+    private enum ContextTag {\n+        NULL                ( \"\"),\n+        CLASS               ( \"Class\"),\n+        CONSTANTPOOL        ( \"Constant-Pool\"),\n+        INTERFACES          ( \"Interfaces\"),\n+        INTERFACE           ( \"Interface\"),\n+        METHODS             ( \"Methods\"),\n+        METHOD              ( \"Method\"),\n+        FIELDS              ( \"Fields\"),\n+        FIELD               ( \"Field\"),\n+        ATTRIBUTE           ( \"Attribute\");\n+\n+        private final String  printValue;\n+\n+        ContextTag(String value) {\n+            printValue = value;\n+        }\n+\n+        public String printval() {\n+            return printValue;\n+        }\n+    }\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* ContextVal (marker) - Specific value on a context stack *\/\n+    private class ContextVal {\n+\n+        public ContextTag tag;\n+        int compCount;\n+        ContextVal owner;\n+\n+        ContextVal(ContextTag tg) {\n+            tag = tg;\n+            compCount = 0;\n+            owner = null;\n+        }\n+\n+        ContextVal(ContextTag tg, ContextVal ownr) {\n+            tag = tg;\n+            compCount = 0;\n+            owner = ownr;\n+        }\n+    }\n+\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Context - Context stack *\/\n+    public class Context {\n+\n+        Stack<ContextVal> stack;\n+\n+        private boolean hasCP;\n+        private boolean hasMethods;\n+        private boolean hasInterfaces;\n+        private boolean hasFields;\n+\n+        Context() {\n+            stack = new Stack<>();\n+            init();\n+        }\n+\n+        boolean isConstantPool() {\n+          return !stack.empty() && (stack.peek().tag == ContextTag.CONSTANTPOOL);\n+        }\n+\n+        public void init() {\n+            stack.removeAllElements();\n+            hasCP = false;\n+            hasMethods = false;\n+            hasInterfaces = false;\n+            hasFields = false;\n+        }\n+\n+        void update() {\n+            if (stack.empty()) {\n+                stack.push(new ContextVal(ContextTag.CLASS));\n+                return;\n+            }\n+\n+            ContextVal currentCtx = stack.peek();\n+            switch (currentCtx.tag) {\n+                case CLASS:\n+                    if (!hasCP) {\n+                        stack.push(new ContextVal(ContextTag.CONSTANTPOOL));\n+                        hasCP = true;\n+                    } else if (!hasInterfaces) {\n+                        stack.push(new ContextVal(ContextTag.INTERFACES));\n+                        hasInterfaces = true;\n+                    } else if (!hasFields) {\n+                        stack.push(new ContextVal(ContextTag.FIELDS));\n+                        hasFields = true;\n+                    } else if (!hasMethods) {\n+                        stack.push(new ContextVal(ContextTag.METHODS));\n+                        hasMethods = true;\n+                    } else {\n+                        \/\/ must be class attributes\n+                        currentCtx.compCount += 1;\n+                        stack.push(new ContextVal(ContextTag.ATTRIBUTE, currentCtx));\n+                    }\n+                    break;\n+                case INTERFACES:\n+                    currentCtx.compCount += 1;\n+                    stack.push(new ContextVal(ContextTag.INTERFACE, currentCtx));\n+                    break;\n+                case FIELDS:\n+                    currentCtx.compCount += 1;\n+                    stack.push(new ContextVal(ContextTag.FIELD, currentCtx));\n+                    break;\n+                case METHODS:\n+                    currentCtx.compCount += 1;\n+                    stack.push(new ContextVal(ContextTag.METHOD, currentCtx));\n+                    break;\n+                case FIELD:\n+                case METHOD:\n+                case ATTRIBUTE:\n+                    currentCtx.compCount += 1;\n+                    stack.push(new ContextVal(ContextTag.ATTRIBUTE, currentCtx));\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        void exit() {\n+            if (!stack.isEmpty()) {\n+                stack.pop();\n+            }\n+        }\n+\n+        public String toString() {\n+            if (stack.isEmpty()) {\n+                return \"\";\n+            }\n+            ContextVal currentCtx = stack.peek();\n+            String retval = currentCtx.tag.printval();\n+            switch (currentCtx.tag) {\n+                case INTERFACE:\n+                case METHOD:\n+                case FIELD:\n+                case ATTRIBUTE:\n+                    if (currentCtx.owner != null) {\n+                        retval += \"[\" + currentCtx.owner.compCount + \"]\";\n+                    }\n+            }\n+\n+            return retval;\n+        }\n+    }\n+\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* Jcoder *\/\n+    \/**\n+     * Create a parser\n+     *\/\n+    Jcoder(SourceFile sf, HashMap<String, String> macros) throws IOException {\n+        scanner = new Scanner(sf, macros);\n+        env = sf;\n+        context = new Context();\n+\n+    }\n+    \/*-------------------------------------------------------- *\/\n+\n+    \/**\n+     * Expect a token, return its value, scan the next token or throw an exception.\n+     *\/\n+    private void expect(Token t) throws SyntaxError, IOException {\n+        if (scanner.token != t) {\n+            env.traceln(\"expect:\" + t + \" instead of \" + scanner.token);\n+            switch (t) {\n+                case IDENT:\n+                    env.error(scanner.pos, \"identifier.expected\");\n+                    break;\n+                default:\n+                    env.error(scanner.pos, \"token.expected\", t.toString());\n+                    break;\n+            }\n+            throw new SyntaxError();\n+        }\n+        scanner.scan();\n+    }\n+\n+    private void recoverField() throws SyntaxError, IOException {\n+        while (true) {\n+            switch (scanner.token) {\n+                case LBRACE:\n+                    scanner.match(Token.LBRACE, Token.RBRACE);\n+                    scanner.scan();\n+                    break;\n+\n+                case LPAREN:\n+                    scanner.match(Token.LPAREN, Token.RPAREN);\n+                    scanner.scan();\n+                    break;\n+\n+                case LSQBRACKET:\n+                    scanner.match(Token.LSQBRACKET, Token.RSQBRACKET);\n+                    scanner.scan();\n+                    break;\n+\n+                case RBRACE:\n+                case EOF:\n+                case INTERFACE:\n+                case CLASS:\n+                    \/\/ begin of something outside a class, panic more\n+                    throw new SyntaxError();\n+\n+                default:\n+                    \/\/ don't know what to do, skip\n+                    scanner.scan();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Parse an array of struct.\n+     *\/\n+    private void parseArray() throws IOException {\n+        scanner.scan();\n+        int length0 = buf.length, pos0 = scanner.pos;\n+        int num_expected;\n+        if (scanner.token == Token.INTVAL) {\n+            num_expected = scanner.intValue;\n+            scanner.scan();\n+        } else {\n+            num_expected = -1;\n+        }\n+        expect(Token.RSQBRACKET);\n+        int numSize;\n+        switch (scanner.token) {\n+            case BYTEINDEX:\n+                scanner.scan();\n+                numSize = 1;\n+                break;\n+            case SHORTINDEX:\n+                scanner.scan();\n+                numSize = 2;\n+                break;\n+            case ZEROINDEX:\n+                scanner.scan();\n+                numSize = 0;\n+                break;\n+            default:\n+                numSize = 2;\n+        }\n+\n+        \/\/ skip array size\n+        if (numSize > 0) {\n+            buf.append(num_expected, numSize);\n+        }\n+\n+        int num_present = parseStruct();\n+        if (num_expected == -1) {\n+            env.trace(\" buf.writeAt(\" + length0 + \", \" + num_present + \", \" + numSize + \");  \");\n+            \/\/ skip array size\n+            if (numSize > 0) {\n+                buf.writeAt(length0, num_present, numSize);\n+            }\n+        } else if ( num_expected != num_present) {\n+            if (context.isConstantPool() && num_expected == num_present +1) return;\n+            env.error(pos0, \"warn.array.wronglength\", num_expected, num_present);\n+        }\n+    }\n+\n+    \/**\n+     * Parse a byte array.\n+     *\/\n+    private void parseByteArray() throws IOException {\n+        scanner.scan();\n+        expect(Token.LSQBRACKET);\n+        int length0 = buf.length, pos0 = scanner.pos;\n+        int len_expected;\n+        if (scanner.token == Token.INTVAL) {\n+            len_expected = scanner.intValue;\n+            scanner.scan();\n+        } else {\n+            len_expected = -1;\n+        }\n+        expect(Token.RSQBRACKET);\n+        int lenSize;\n+        switch (scanner.token) {\n+            case BYTEINDEX:\n+                scanner.scan();\n+                lenSize = 1;\n+                break;\n+            case SHORTINDEX:\n+                scanner.scan();\n+                lenSize = 2;\n+                break;\n+            case ZEROINDEX:\n+                scanner.scan();\n+                lenSize = 0;\n+                break;\n+            default:\n+                lenSize = 4;\n+        }\n+\n+        \/\/ skip array size\n+        if (lenSize > 0) {\n+            buf.append(len_expected, lenSize);\n+        }\n+        int length1 = buf.length;\n+        parseStruct();\n+        int len_present = buf.length - length1;\n+        if (len_expected == -1) {\n+            env.trace(\" buf.writeAt(\" + length0 + \", \" + len_present + \", \" + lenSize + \");  \");\n+            \/\/ skip array size\n+            if (lenSize > 0) {\n+                buf.writeAt(length0, len_present, lenSize);\n+            }\n+        } else if (len_expected != len_present) {\n+            env.error(pos0, \"warn.array.wronglength\", len_expected, len_present);\n+        }\n+    }\n+\n+    \/**\n+     * Parse an Attribute.\n+     *\/\n+    private void parseAttr() throws IOException {\n+        scanner.scan();\n+        expect(Token.LPAREN);\n+        int cpx; \/\/ index int const. pool\n+        if (scanner.token == Token.INTVAL) {\n+            cpx = scanner.intValue;\n+            scanner.scan();\n+\n+            \/*  } else if (token==STRINGVAL) {\n+             Integer Val=(Integer)(CP_Strings.get(stringValue));\n+             if (Val == null) {\n+             env.error(pos, \"attrname.notfound\", stringValue);\n+             throw new SyntaxError();\n+             }\n+             cpx=Val.intValue();\n+             *\/        } else {\n+            env.error(scanner.pos, \"attrname.expected\");\n+            throw new SyntaxError();\n+        }\n+        buf.append(cpx, 2);\n+        int pos0 = scanner.pos, length0 = buf.length;\n+        int len_expected;\n+        if (scanner.token == Token.COMMA) {\n+            scanner.scan();\n+            len_expected = scanner.intValue;\n+            expect(Token.INTVAL);\n+        } else {\n+            len_expected = -1;\n+        }\n+        buf.append(len_expected, 4);\n+        expect(Token.RPAREN);\n+        parseStruct();\n+        int len_present = buf.length - (length0 + 4);\n+        if (len_expected == -1) {\n+            buf.writeAt(length0, len_present, 4);\n+        } else if (len_expected != len_present) {\n+            env.error(pos0, \"warn.attr.wronglength\", len_expected, len_present);\n+        }\n+    } \/\/ end parseAttr\n+\n+    \/**\n+     * Parse a Component of JavaCard .cap file.\n+     *\/\n+    private void parseComp() throws IOException {\n+        scanner.scan();\n+        expect(Token.LPAREN);\n+        int tag = scanner.intValue; \/\/ index int const. pool\n+        expect(Token.INTVAL);\n+        buf.append(tag, 1);\n+        int pos0 = scanner.pos, length0 = buf.length;\n+        int len_expected;\n+        if (scanner.token == Token.COMMA) {\n+            scanner.scan();\n+            len_expected = scanner.intValue;\n+            expect(Token.INTVAL);\n+        } else {\n+            len_expected = -1;\n+        }\n+        buf.append(len_expected, 2);\n+        expect(Token.RPAREN);\n+        parseStruct();\n+        int len_present = buf.length - (length0 + 2);\n+        if (len_expected == -1) {\n+            buf.writeAt(length0, len_present, 2);\n+        } else if (len_expected != len_present) {\n+            env.error(pos0, \"warn.attr.wronglength\", len_expected, len_present);\n+        }\n+    } \/\/ end parseComp\n+\n+    private void adjustDepth(boolean up) {\n+        if (up) {\n+            depth += 1;\n+            context.update();\n+            scanner.setDebugCP(context.isConstantPool());\n+        } else {\n+            depth -= 1;\n+            context.exit();\n+        }\n+        StringBuilder bldr = new StringBuilder();\n+        int tabAmt = 4;\n+        int len = depth * tabAmt;\n+        for (int i = 0; i < len; i++) {\n+            bldr.append(\" \");\n+        }\n+        tabStr = bldr.toString();\n+    }\n+\n+    \/**\n+     * Parse a structure.\n+     *\/\n+    private int parseStruct() throws IOException {\n+        adjustDepth(true);\n+        env.traceln(\" \");\n+        env.traceln(tabStr + \"MapStruct { <\" + context + \"> \");\n+        expect(Token.LBRACE);\n+        int num = 0;\n+        int addElem = 0;\n+        while (true) {\n+            try {\n+                switch (scanner.token) {\n+                    case COMMA: \/\/ ignored\n+                        scanner.scan();\n+                        break;\n+                    case SEMICOLON:\n+                        num++;\n+                        addElem = 0;\n+                        scanner.scan();\n+                        break;\n+                    case CLASS:\n+                        scanner.addConstDebug(ConstType.CONSTANT_CLASS);\n+                        env.trace(\"class \");\n+                        scanner.longValue = ConstType.CONSTANT_CLASS.value();\n+                        scanner.intSize = 1;\n+                    case INTVAL:\n+                        env.trace(\"int [\" + scanner.longValue + \"] \");\n+                        buf.append(scanner.longValue, scanner.intSize);\n+                        scanner.scan();\n+                        addElem = 1;\n+                        break;\n+                    case STRINGVAL:\n+                        scanner.scan();\n+                        scanner.addConstDebug(ConstType.CONSTANT_UTF8);\n+                        env.trace(\"UTF8 [\\\"\" + scanner.stringValue + \"\\\"] \");\n+                        bufstream.writeUTF(scanner.stringValue);\n+                        addElem = 1;\n+                        break;\n+                    case LONGSTRINGVAL:\n+                        scanner.scan();\n+                        env.traceln(\"LongString [\\\"\" + Arrays.toString(scanner.longStringValue.data) + \"\\\"] \");\n+                        buf.write(scanner.longStringValue.data, 0, scanner.longStringValue.length);\n+                        addElem = 1;\n+                        break;\n+                    case LBRACE:\n+                        parseStruct();\n+                        addElem = 1;\n+                        break;\n+                    case LSQBRACKET:\n+                        parseArray();\n+                        addElem = 1;\n+                        break;\n+                    case BYTES:\n+                        env.trace(\"bytes \");\n+                        parseByteArray();\n+                        addElem = 1;\n+                        break;\n+                    case ATTR:\n+                        env.trace(\"attr \");\n+                        parseAttr();\n+                        addElem = 1;\n+                        break;\n+                    case COMP:\n+                        env.trace(\"comp \");\n+                        parseComp();\n+                        addElem = 1;\n+                        break;\n+                    case RBRACE:\n+                        scanner.scan();\n+                        env.traceln(\" \");\n+                        env.traceln(tabStr + \"} \/\/ MapStruct  <\" + context + \"> [\");\n+                        adjustDepth(false);\n+                        return num + addElem;\n+                    default:\n+                        env.traceln(\"unexp token=\" + scanner.token);\n+                        env.traceln(\"   scanner.stringval = \\\"\" + scanner.stringValue + \"\\\"\");\n+                        env.error(scanner.pos, \"element.expected\");\n+                        throw new SyntaxError();\n+                }\n+            } catch (SyntaxError e) {\n+                recoverField();\n+            }\n+        }\n+    } \/\/ end parseStruct\n+\n+    \/**\n+     * Recover after a syntax error in the file. This involves discarding tokens until an\n+     * EOF or a possible legal continuation is encountered.\n+     *\/\n+    private void recoverFile() throws IOException {\n+        while (true) {\n+            switch (scanner.token) {\n+                case CLASS:\n+                case INTERFACE:\n+                    \/\/ Start of a new source file statement, continue\n+                    return;\n+\n+                case LBRACE:\n+                    scanner.match(Token.LBRACE, Token.RBRACE);\n+                    scanner.scan();\n+                    break;\n+\n+                case LPAREN:\n+                    scanner.match(Token.LPAREN, Token.RPAREN);\n+                    scanner.scan();\n+                    break;\n+\n+                case LSQBRACKET:\n+                    scanner.match(Token.LSQBRACKET, Token.RSQBRACKET);\n+                    scanner.scan();\n+                    break;\n+\n+                case EOF:\n+                    return;\n+\n+                default:\n+                    \/\/ Don't know what to do, skip\n+                    scanner.scan();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Parse module declaration\n+     *\/\n+    private void parseModule() throws IOException {\n+        \/\/ skip module name as a redundant element\n+        scanner.skipTill(Scanner.LBRACE);\n+        buf = new ByteBuffer();\n+        bufstream = new DataOutputStream(buf);\n+        buf.myname = \"module-info.class\";\n+        scanner.scan();\n+        env.traceln(\"starting \" + buf.myname);\n+        \/\/ Parse the clause\n+        parseClause();\n+        env.traceln(\"ending \" + buf.myname);\n+    }\n+\n+    \/**\n+     * Parse a class or interface declaration.\n+     *\/\n+    private void parseClass(Token prev) throws IOException {\n+        scanner.scan();\n+        buf = new ByteBuffer();\n+        bufstream = new DataOutputStream(buf);\n+        \/\/ Parse the class name\n+        switch (scanner.token) {\n+            case STRINGVAL:\n+                buf.myname = scanner.stringValue;\n+                break;\n+            case BYTEINDEX:\n+            case SHORTINDEX:\n+            case ATTR:\n+            case BYTES:\n+            case MACRO:\n+            case COMP:\n+            case FILE:\n+            case IDENT:\n+                if (prev == Token.FILE) {\n+                    buf.myname = scanner.stringValue;\n+                } else {\n+                    buf.myname = scanner.stringValue + \".class\";\n+                }\n+                break;\n+            default:\n+                env.error(scanner.prevPos, \"name.expected\");\n+                throw new SyntaxError();\n+        }\n+        scanner.scan();\n+        env.traceln(\"starting class \" + buf.myname);\n+        \/\/ Parse the clause\n+        parseClause();\n+        env.traceln(\"ending class \" + buf.myname);\n+\n+    } \/\/ end parseClass\n+\n+    private void parseClause() throws IOException {\n+        switch (scanner.token) {\n+            case LBRACE:\n+                parseStruct();\n+                break;\n+            case LSQBRACKET:\n+                parseArray();\n+                break;\n+            case BYTES:\n+                parseByteArray();\n+                break;\n+            case ATTR:\n+                parseAttr();\n+                break;\n+            case COMP:\n+                parseComp();\n+                break;\n+            default:\n+                env.error(scanner.pos, \"struct.expected\");\n+        }\n+    }\n+\n+    \/**\n+     * Parse an Jcoder file.\n+     *\/\n+    void parseFile() {\n+        env.traceln(\"PARSER\");\n+        context.init();\n+        try {\n+            while (scanner.token != Token.EOF) {\n+                try {\n+                    switch (scanner.token) {\n+                        case CLASS:\n+                        case MODULE:\n+                        case INTERFACE:\n+                        case FILE:\n+                            Token t = scanner.token;\n+                            if ( t == Token.MODULE) {\n+                                parseModule();\n+                            } else {\n+                                parseClass(t);\n+                            }\n+                            \/\/ End of the class,interface or module\n+                            env.flushErrors();\n+                            Classes.add(buf);\n+                            break;\n+                        case SEMICOLON:\n+                            \/\/ Bogus semi colon\n+                            scanner.scan();\n+                            break;\n+\n+                        case EOF:\n+                            \/\/ The end\n+                            return;\n+\n+                        default:\n+                            env.traceln(\"unexpected token=\" + scanner.token.toString());\n+                            env.error(scanner.pos, \"toplevel.expected\");\n+                            throw new SyntaxError();\n+                    }\n+                } catch (SyntaxError e) {\n+                    String msg = e.getMessage();\n+                    env.traceln(\"SyntaxError \" + (msg == null ? \"\" : msg));\n+                    if( env.debugInfoFlag ) {\n+                        e.printStackTrace();\n+                    }\n+                    recoverFile();\n+                }\n+            }\n+        } catch (IOException e) {\n+            env.error(scanner.pos, \"io.exception\", env.getInputFileName());\n+        }\n+    } \/\/end parseFile\n+\n+    \/*---------------------------------------------*\/\n+    private static char fileSeparator; \/\/=System.getProperty(\"file.separator\");\n+\n+    \/**\n+     * write to the directory passed with -d option\n+     *\/\n+    public void write(ByteBuffer cls, File destdir) throws IOException {\n+        String myname = cls.myname;\n+        if (myname == null) {\n+            env.error(\"cannot.write\", null);\n+            return;\n+        }\n+\n+        env.traceln(\"writing \" + myname);\n+        File outfile;\n+        if (destdir == null) {\n+            int startofname = myname.lastIndexOf('\/');\n+            if (startofname != -1) {\n+                myname = myname.substring(startofname + 1);\n+            }\n+            outfile = new File(myname);\n+        } else {\n+            env.traceln(\"writing -d \" + destdir.getPath());\n+            if (fileSeparator == 0) {\n+                fileSeparator = System.getProperty(\"file.separator\").charAt(0);\n+            }\n+            if (fileSeparator != '\/') {\n+                myname = myname.replace('\/', fileSeparator);\n+            }\n+            outfile = new File(destdir, myname);\n+            File outdir = new File(outfile.getParent());\n+            if (!outdir.exists() && !outdir.mkdirs()) {\n+                env.error(\"cannot.write\", outdir.getPath());\n+                return;\n+            }\n+        }\n+\n+        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outfile));\n+        out.write(cls.data, 0, cls.length);\n+        try {\n+            out.close();\n+        } catch (IOException ignored) { }\n+    }\n+\n+    \/**\n+     * Writes the classes\n+     *\/\n+    public void write(File destdir) throws IOException {\n+        for (ByteBuffer cls : Classes) {\n+            write(cls, destdir);\n+        }\n+    }  \/\/ end write()\n+} \/\/ end Jcoder\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/Jcoder.java","additions":766,"deletions":0,"binary":false,"changes":766,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+import org.openjdk.asmtools.common.Tool;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+import org.openjdk.asmtools.util.ProductInfo;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+\/**\n+ *\n+ *\n+ *\/\n+public class Main extends Tool {\n+\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    public Main(PrintWriter out, String programName) {\n+        super(out, programName);\n+        printCannotReadMsg = (fname) -> error(i18n.getString(\"jcoder.error.cannot_read\", fname));\n+    }\n+\n+    public Main(PrintStream out, String program) {\n+        this(new PrintWriter(out), program);\n+    }\n+\n+    @Override\n+    public void usage() {\n+        println(i18n.getString(\"jcoder.usage\"));\n+        println(i18n.getString(\"jcoder.opt.nowrite\"));\n+        println(i18n.getString(\"jcoder.opt.ignore\"));\n+        println(i18n.getString(\"jcoder.opt.d\"));\n+        println(i18n.getString(\"jcoder.opt.version\"));\n+    }\n+\n+    \/**\n+     * Run the compiler\n+     *\/\n+    public synchronized boolean compile(String argv[]) {\n+        File destDir = null;\n+        boolean traceFlag = false;\n+        DebugFlag = () -> false;\n+        long tm = System.currentTimeMillis();\n+        ArrayList<String> v = new ArrayList<>();\n+        boolean nowrite = false;\n+        boolean ignore  = false;\n+        int nwarnings = 0;\n+        HashMap<String, String> macros = new HashMap<>();\n+        macros.put(\"VERSION\", \"3;45\");\n+\n+        \/\/ Parse arguments\n+        for (int i = 0; i < argv.length; i++) {\n+            String arg = argv[i];\n+            if (!arg.startsWith(\"-\")) {\n+                v.add(arg);\n+            } else if (arg.startsWith(\"-D\")) {\n+                int argLength = arg.length();\n+                if (argLength == 2) {\n+                    error(i18n.getString(\"jcoder.error.D_needs_macro\"));\n+                    return false;\n+                }\n+                int index = arg.indexOf('=');\n+                if (index == -1) {\n+                    error(i18n.getString(\"jcoder.error.D_needs_macro\"));\n+                    return false;\n+                }\n+                String macroId = arg.substring(2, index);\n+                index++;\n+                if (argLength == index) {\n+                    error(i18n.getString(\"jcoder.error.D_needs_macro\"));\n+                    return false;\n+                }\n+                String macro;\n+                if (arg.charAt(index) == '\"') {\n+                    index++;\n+                    if (argLength == index || arg.charAt(argLength - 1) != '\"') {\n+                        error(i18n.getString(\"jcoder.error.no_closing_quota\"));\n+                        return false;\n+                    }\n+                    macro = arg.substring(index, argLength - 1);\n+                } else {\n+                    macro = arg.substring(index, argLength);\n+                }\n+                macros.put(macroId, macro);\n+            } else if (arg.equals(\"-vv\")) {\n+                DebugFlag = () -> true;\n+                traceFlag = true;\n+            } else if (arg.equals(\"-v\")) {\n+                traceFlag = true;\n+            } else if (arg.equals(\"-nowrite\")) {\n+                nowrite = true;\n+            } else if (arg.equals(\"-ignore\")) {\n+                ignore = true;\n+            } else if (arg.equals(\"-d\")) {\n+                if ((i + 1) == argv.length) {\n+                    error(i18n.getString(\"jcoder.error.d_requires_argument\"));\n+                    usage();\n+                    return false;\n+                }\n+                destDir = new File(argv[++i]);\n+                if (!destDir.exists()) {\n+                    error(i18n.getString(\"jcoder.error.does_not_exist\", destDir));\n+                    return false;\n+                }\n+            } else if (arg.equals(\"-version\")) {\n+                println(ProductInfo.FULL_VERSION);\n+            } else {\n+                error(i18n.getString(\"jcoder.error.invalid_option\", arg));\n+                usage();\n+                return false;\n+            }\n+        }\n+        if (v.isEmpty()) {\n+            usage();\n+            return false;\n+        }\n+        \/\/ compile all input files\n+        try {\n+            for (String inpname : v) {\n+                SourceFile env;\n+                Jcoder p;\n+\n+                DataInputStream dataInputStream = getDataInputStream(inpname);\n+                if( dataInputStream == null ) {\n+                    nerrors++;\n+                    continue;\n+                }\n+                env = new SourceFile(this, dataInputStream, inpname, out);\n+                env.traceFlag = traceFlag;\n+                env.debugInfoFlag = DebugFlag.getAsBoolean();\n+                p = new Jcoder(env, macros);\n+                p.parseFile();\n+                env.traceln(\"END PARSER\");\n+                env.closeInp();\n+\n+                nerrors += env.nerrors;\n+                nwarnings += env.nwarnings;\n+                if (nowrite || (nerrors > 0 & !ignore)) {\n+                    continue;\n+                }\n+                try {\n+                    env.traceln(\"WRITE\");\n+                    p.write(destDir);\n+                } catch (FileNotFoundException ex) {\n+                    error(i18n.getString(\"jcoder.error.cannot_write\", ex.getMessage()));\n+                }\n+            }\n+        } catch (Error ee) {\n+            ee.printStackTrace();\n+            error(i18n.getString(\"jcoder.error.fatal_error\"));\n+        } catch (Exception ee) {\n+            ee.printStackTrace();\n+            error(i18n.getString(\"jcoder.error.fatal_exception\"));\n+        }\n+\n+        boolean errs = nerrors > 0;\n+        boolean warns = nwarnings > 0;\n+        if (!errs && !warns) {\n+            return true;\n+        }\n+        println(errs ? (nerrors > 1 ? (nerrors + \" errors\") : \"1 error\")\n+                : \"\" + ((errs && warns) ? \", \" : \"\") + (warns ? (nwarnings > 1 ? (nwarnings + \" warnings\") : \"1 warning\") : \"\"));\n+        return !errs;\n+    }\n+\n+    \/**\n+     * main program\n+     *\/\n+    public static void main(String[] argv) {\n+        Main compiler = new Main(new PrintWriter(System.out), \"jcoder\");\n+        System.exit(compiler.compile(argv) ? 0 : 1);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/Main.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,905 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+import static org.openjdk.asmtools.jcoder.JcodTokens.*;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+\n+\/**\n+ * A Scanner for Jcoder tokens. Errors are reported to the environment object.<p>\n+ *\n+ * The scanner keeps track of the current token, the value of the current token (if any),\n+ * and the start position of the current token.<p>\n+ *\n+ * The scan() method advances the scanner to the next token in the input.<p>\n+ *\n+ * The match() method is used to quickly match opening brackets (ie: '(', '{', or '[')\n+ * with their closing counter part. This is useful during error recovery.<p>\n+ *\n+ * The compiler treats either \"\\n\", \"\\r\" or \"\\r\\n\" as the end of a line.<p>\n+ *\/\n+public class Scanner {\n+    \/*-------------------------------------------------------- *\/\n+    \/* Scanner Fields *\/\n+\n+    \/**\n+     * End of input\n+     *\/\n+    public static final int EOF = -1;\n+    public static final int LBRACE = 123; \/\/ \"{\"\n+    private boolean debugCP = false;\n+    private int numCPentrs = 0;\n+\n+    \/**\n+     * Where errors are reported\n+     *\/\n+    protected SourceFile env;\n+\n+    \/**\n+     * Input stream\n+     *\/\n+    protected SourceFile in;\n+    HashMap<String, String> macros;\n+\n+    \/**\n+     * The current character\n+     *\/\n+    protected int ch, prevCh = -1;\n+    protected String macro;\n+    protected int indexMacro;\n+\n+    \/**\n+     * Current token\n+     *\/\n+    protected Token token;\n+\n+    \/**\n+     * The position of the current token\n+     *\/\n+    protected int pos;\n+\n+    \/**\n+     * The position of the previous token\n+     *\/\n+    protected int prevPos;\n+\n+    \/*  Token values. *\/\n+    protected long longValue;\n+    protected int intValue;\n+    protected int intSize;\n+    protected String stringValue;\n+    protected ByteBuffer longStringValue;\n+    protected int sign; \/\/ sign, when reading number\n+\n+    \/*  A doc comment preceding the most recent token *\/\n+    protected String docComment;\n+\n+    \/**\n+     * A growable character buffer.\n+     *\/\n+    private int count;\n+    private char[] buffer = new char[32];\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/**\n+     * Create a scanner to scan an input stream.\n+     *\/\n+    protected Scanner(SourceFile sf, HashMap<String, String> macros)\n+            throws IOException {\n+        this.env = sf;\n+        this.in = sf;\n+        this.macros = macros;\n+\n+        ch = sf.read();\n+        prevPos = sf.pos;\n+\n+        scan();\n+    }\n+\n+    \/**\n+     * for use in jcfront.\n+     *\/\n+    protected Scanner(SourceFile sf)\n+            throws IOException {\n+        this.env = sf;\n+        this.in = sf;\n+        this.macros = new HashMap<>();\n+\n+        ch = sf.read();\n+        prevPos = sf.pos;\n+\n+        scan();\n+    }\n+\n+    \/* *********************************************** *\/\n+    void setDebugCP(boolean enable) {\n+        if (enable) {\n+            numCPentrs = 0;\n+        }\n+        debugCP = enable;\n+\n+    }\n+\n+    void addConstDebug(ConstType ct) {\n+        numCPentrs += 1;\n+        env.traceln(\"\\n Const[\" + numCPentrs + \"] = \" + ct.printval());\n+    }\n+\n+    void setMacro(String macro) {\n+        this.macro = macro;\n+        indexMacro = 0;\n+        prevCh = ch;\n+    }\n+\n+    void readCh() throws IOException {\n+        if (macro != null) {\n+            if (indexMacro < macro.length()) {\n+                ch = macro.charAt(indexMacro);\n+            }\n+            macro = null;\n+        }\n+        if (prevCh >= 0) {\n+            ch = prevCh;\n+            prevCh = -1;\n+        } else {\n+            ch = in.read();\n+        }\n+    }\n+\n+    private void putc(int ch) {\n+        if (count == buffer.length) {\n+            char[] newBuffer = new char[buffer.length * 2];\n+            System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);\n+            buffer = newBuffer;\n+        }\n+        buffer[count++] = (char) ch;\n+    }\n+\n+    private String bufferString() {\n+        char[] buf = new char[count];\n+        System.arraycopy(buffer, 0, buf, 0, count);\n+        return new String(buf);\n+    }\n+\n+    \/**\n+     * Scan a comment. This method should be called once the initial \/, * and the next\n+     * character have been read.\n+     *\/\n+    private void skipComment() throws IOException {\n+        while (true) {\n+            switch (ch) {\n+                case EOF:\n+                    env.error(pos, \"eof.in.comment\");\n+                    return;\n+\n+                case '*':\n+                    readCh();\n+                    if (ch == '\/') {\n+                        readCh();\n+                        return;\n+                    }\n+                    break;\n+\n+                default:\n+                    readCh();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Scan a doc comment. This method should be called once the initial \/, * and * have\n+     * been read. It gathers the content of the comment (witout leading spaces and '*'s)\n+     * in the string buffer.\n+     *\/\n+    private String scanDocComment() throws IOException {\n+        count = 0;\n+\n+        if (ch == '*') {\n+            do {\n+                readCh();\n+            } while (ch == '*');\n+            if (ch == '\/') {\n+                readCh();\n+                return \"\";\n+            }\n+        }\n+        switch (ch) {\n+            case '\\n':\n+            case ' ':\n+                readCh();\n+                break;\n+        }\n+\n+        boolean seenstar = false;\n+        int c = count;\n+        while (true) {\n+            switch (ch) {\n+                case EOF:\n+                    env.error(pos, \"eof.in.comment\");\n+                    return bufferString();\n+\n+                case '\\n':\n+                    putc('\\n');\n+                    readCh();\n+                    seenstar = false;\n+                    c = count;\n+                    break;\n+\n+                case ' ':\n+                case '\\t':\n+                    putc(ch);\n+                    readCh();\n+                    break;\n+\n+                case '*':\n+                    if (seenstar) {\n+                        readCh();\n+                        if (ch == '\/') {\n+                            readCh();\n+                            count = c;\n+                            return bufferString();\n+                        }\n+                        putc('*');\n+                    } else {\n+                        seenstar = true;\n+                        count = c;\n+                        do {\n+                            readCh();\n+                        } while (ch == '*');\n+                        switch (ch) {\n+                            case ' ':\n+                                readCh();\n+                                break;\n+\n+                            case '\/':\n+                                readCh();\n+                                count = c;\n+                                return bufferString();\n+                        }\n+                    }\n+                    break;\n+\n+                default:\n+                    if (!seenstar) {\n+                        seenstar = true;\n+                    }\n+                    putc(ch);\n+                    readCh();\n+                    c = count;\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Scan a decimal number\n+     *\/\n+    private void scanDecNumber() throws IOException {\n+        boolean overflow = false;\n+        long value = ch - '0';\n+        count = 0;\n+        token = Token.INTVAL;\n+        intSize = 2; \/\/ default\n+        putc(ch);    \/\/ save character in buffer\n+numberLoop:\n+        for (;;) {\n+            readCh();\n+            switch (ch) {\n+                case '8':\n+                case '9':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                    putc(ch);\n+                    overflow = overflow || (value * 10) \/ 10 != value;\n+                    value = (value * 10) + (ch - '0');\n+                    overflow = overflow || (value - 1 < -1);\n+                    break;\n+                case 'b':\n+                    readCh();\n+                    intSize = 1;\n+                    break numberLoop;\n+                case 's':\n+                    readCh();\n+                    intSize = 2;\n+                    break numberLoop;\n+                case 'i':\n+                    readCh();\n+                    intSize = 4;\n+                    break numberLoop;\n+                case 'l':\n+                    readCh();\n+                    intSize = 8;\n+                    break numberLoop;\n+                default:\n+                    break numberLoop;\n+            }\n+        }\n+        longValue = value;\n+        intValue = (int) value;\n+        \/\/ we have just finished reading the number.  The next thing better\n+        \/\/ not be a letter or digit.\n+        if (Character.isJavaIdentifierPart((char) ch) || ch == '.') {\n+            env.error(in.pos, \"invalid.number\", Character.toString((char)ch));\n+            do {\n+                readCh();\n+            } while (Character.isJavaIdentifierPart((char) ch) || ch == '.');\n+            return;\n+        }\n+        if (overflow) {\n+            env.error(pos, \"overflow\");\n+        }\n+    } \/\/ scanNumber()\n+\n+    \/**\n+     * Scan a hex number.\n+     *\/\n+    private void scanHexNumber() throws IOException {\n+        boolean overflow = false;\n+        long value = 0;\n+        int cypher;\n+        count = 0;\n+        token = Token.INTVAL;\n+        intSize = 2; \/\/ default\n+        putc(ch);    \/\/ save character in buffer\n+numberLoop:\n+        for (int k = 0;; k++) {\n+            readCh();\n+            switch (ch) {\n+                case '8':\n+                case '9':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                    cypher = (char) ch - '0';\n+                    break;\n+                case 'd':\n+                case 'D':\n+                case 'e':\n+                case 'E':\n+                case 'f':\n+                case 'F':\n+                case 'a':\n+                case 'A':\n+                case 'b':\n+                case 'B':\n+                case 'c':\n+                case 'C':\n+                    cypher = 10 + Character.toLowerCase((char) ch) - 'a';\n+                    break;\n+\n+                default:\n+                    break numberLoop;\n+            }\n+            putc(ch);\n+            overflow = overflow || ((value >>> 60) != 0);\n+            value = (value << 4) + cypher;\n+            intSize = (k + 1) \/ 2;\n+        }\n+        longValue = value;\n+        intValue = (int) value;\n+        \/\/ we have just finished reading the number.  The next thing better\n+        \/\/ not be a letter or digit.\n+        if (Character.isJavaIdentifierPart((char) ch) || ch == '.') {\n+            env.error(in.pos, \"invalid.number\", Character.toString((char)ch));\n+            do {\n+                readCh();\n+            } while (Character.isJavaIdentifierPart((char) ch) || ch == '.');\n+            intValue = 0;\n+\/\/        } else if ( overflow || (intValue - 1 < -1) ) {\n+        } else if (overflow) {\n+            intValue = 0;   \/\/ so we don't get second overflow in Parser\n+            env.error(pos, \"overflow\");\n+        }\n+    } \/\/ scanNumber()\n+\n+    \/**\n+     * Scan an escape character.\n+     *\n+     * @return the character or -1 if it escaped an end-of-line.\n+     *\/\n+    private int scanEscapeChar() throws IOException {\n+        int p = in.pos;\n+\n+        readCh();\n+        switch (ch) {\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7': {\n+                int n = ch - '0';\n+                for (int i = 2; i > 0; i--) {\n+                    readCh();\n+                    switch (ch) {\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                            n = (n << 3) + ch - '0';\n+                            break;\n+\n+                        default:\n+                            if (n > 0xFF) {\n+                                env.error(p, \"invalid.escape.char\");\n+                            }\n+                            return n;\n+                    }\n+                }\n+                readCh();\n+                if (n > 0xFF) {\n+                    env.error(p, \"invalid.escape.char\");\n+                }\n+                return n;\n+            }\n+            case 'r':\n+                readCh();\n+                return '\\r';\n+            case 'n':\n+                readCh();\n+                return '\\n';\n+            case 'f':\n+                readCh();\n+                return '\\f';\n+            case 'b':\n+                readCh();\n+                return '\\b';\n+            case 't':\n+                readCh();\n+                return '\\t';\n+            case '\\\\':\n+                readCh();\n+                return '\\\\';\n+            case '\\\"':\n+                readCh();\n+                return '\\\"';\n+            case '\\'':\n+                readCh();\n+                return '\\'';\n+        }\n+\n+        env.error(p, \"invalid.escape.char\");\n+        readCh();\n+        return -1;\n+    }\n+\n+    \/**\n+     * Scan a string. The current character should be the opening \" of the string.\n+     *\/\n+    private void scanString() throws IOException {\n+        token = Token.STRINGVAL;\n+        count = 0;\n+        readCh();\n+\n+loop:\n+        for (;;) {\n+            switch (ch) {\n+                case EOF:\n+                    env.error(pos, \"eof.in.string\");\n+                    break loop;\n+\n+                case '\\n':\n+                    readCh();\n+                    env.error(pos, \"newline.in.string\");\n+                    break loop;\n+\n+                case '\"':\n+                    readCh();\n+                    break loop;\n+\n+                case '\\\\': {\n+                    int c = scanEscapeChar();\n+                    if (c >= 0) {\n+                        putc((char)c);\n+                    }\n+                    break;\n+                }\n+\n+                default:\n+                    putc(ch);\n+                    readCh();\n+                    break;\n+            }\n+        }\n+        stringValue = bufferString();\n+    }\n+\n+    \/**\n+     * Scan a character array. The current character should be the opening ' of the array.\n+     *\/\n+    private void scanCharArray() throws IOException {\n+        token = Token.LONGSTRINGVAL;\n+        ByteBuffer buf = new ByteBuffer();\n+        count = 0;\n+        readCh();\n+\n+loop:\n+        for (;;) {\n+            int c = ch;\n+            switch (ch) {\n+                case EOF:\n+                    env.error(pos, \"eof.in.string\");\n+                    break loop;\n+\n+                case '\\n':\n+                    readCh();\n+                    env.error(pos, \"newline.in.string\");\n+                    break loop;\n+\n+                case '\\'':\n+                    readCh();\n+                    break loop;\n+\n+                case '\\\\':\n+                    c = scanEscapeChar();\n+                    if (c < 0) {\n+                        break;\n+                    }\n+                \/\/ no break - continue\n+                default:\n+                    \/\/ see  description of java.io.DataOutput.writeUTF()\n+                    if ((c > 0) && (c <= 0x7F)) {\n+                        buf.write(c);\n+                    } else if ((c == 0) || ((c >= 0x80) && (c <= 0x7FF))) {\n+                        buf.write(0xC0 | (0x1F & (c >> 6)));\n+                        buf.write(0x80 | (0x3f & c));\n+                    } else {\n+                        buf.write(0xc0 | (0x0f & (c >> 12)));\n+                        buf.write(0x80 | (0x3f & (c >> 6)));\n+                        buf.write(0x80 | (0x3f & c));\n+                    }\n+                    readCh();\n+            }\n+        }\n+        longStringValue = buf;\n+    }\n+\n+    \/**\n+     * Scan an Identifier. The current character should be the first character of the\n+     * identifier.\n+     *\/\n+    private void scanIdentifier() throws IOException {\n+        count = 0;\n+        boolean compound = false;\n+        for (;;) {\n+            putc(ch);\n+            readCh();\n+            if ((ch == '\/') || (ch == '.') || (ch == '-')) {\n+                compound = true;\n+            } else if (!Character.isJavaIdentifierPart((char) ch)) {\n+                break;\n+            }\n+        }\n+        stringValue = bufferString();\n+        if (compound) {\n+            token = Token.IDENT;\n+        } else {\n+            token = keyword_token_ident(stringValue);\n+            if (token == Token.IDENT) {\n+                intValue = constValue(stringValue);\n+                if (intValue != -1) {\n+                    \/\/ this is a constant\n+                    if (debugCP) {\n+                        ConstType ct = constType(stringValue);\n+                        if (ct != null) {\n+                            addConstDebug(ct);\n+                        }\n+                    }\n+                    token = Token.INTVAL;\n+                    intSize = 1;\n+                    longValue = intValue;\n+                }\n+            }\n+        }\n+    } \/\/ end scanIdentifier\n+\n+    \/\/ skip till symbol\n+    protected void skipTill(int sym) throws IOException {\n+        while (true) {\n+            if( ch == EOF ) {\n+                env.error(pos, \"eof.in.comment\");\n+                return;\n+            } else if (ch == sym) {\n+                return;\n+            }\n+            readCh();\n+        }\n+    }\n+\n+    protected int xscan() throws IOException {\n+        int retPos = pos;\n+        prevPos = in.pos;\n+        docComment = null;\n+        sign = 1;\n+        for (;;) {\n+            pos = in.pos;\n+\n+            switch (ch) {\n+                case EOF:\n+                    token = Token.EOF;\n+                    return retPos;\n+\n+                case '\\n':\n+                case ' ':\n+                case '\\t':\n+                case '\\f':\n+                    readCh();\n+                    break;\n+\n+                case '\/':\n+                    readCh();\n+                    switch (ch) {\n+                        case '\/':\n+                            \/\/ Parse a \/\/ comment\n+                            do {\n+                                readCh();\n+                            } while ((ch != EOF) && (ch != '\\n'));\n+                            break;\n+\n+                        case '*':\n+                            readCh();\n+                            if (ch == '*') {\n+                                docComment = scanDocComment();\n+                            } else {\n+                                skipComment();\n+                            }\n+                            break;\n+\n+                        default:\n+                            token = Token.DIV;\n+                            return retPos;\n+                    }\n+                    break;\n+\n+                case '\"':\n+                    scanString();\n+                    return retPos;\n+\n+                case '\\'':\n+                    scanCharArray();\n+                    return retPos;\n+\n+                case '-':\n+                    sign = -sign; \/\/ hack: no check that numbers only are allowed after\n+                case '+':\n+                    readCh();\n+                    break;\n+\n+                case '0':\n+                    readCh();\n+                    token = Token.INTVAL;\n+                    longValue = intValue = 0;\n+                    switch (ch) {\n+                        case 'x':\n+                        case 'X':\n+                            scanHexNumber();\n+                            break;\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                        case '8':\n+                        case '9':\n+                            scanDecNumber();\n+                            break;\n+                        case 'b':\n+                            readCh();\n+                            intSize = 1;\n+                            break;\n+                        case 's':\n+                            readCh();\n+                            intSize = 2;\n+                            break;\n+                        case 'i':\n+                            readCh();\n+                            intSize = 4;\n+                            break;\n+                        case 'l':\n+                            readCh();\n+                            intSize = 8;\n+                            break;\n+                        default:\n+                            intSize = 2;\n+                    }\n+                    return retPos;\n+\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    scanDecNumber();\n+                    return retPos;\n+\n+                case '{':\n+                    readCh();\n+                    token = Token.LBRACE;\n+                    return retPos;\n+\n+                case '}':\n+                    readCh();\n+                    token = Token.RBRACE;\n+                    return retPos;\n+\n+                case '(':\n+                    readCh();\n+                    token = Token.LPAREN;\n+                    return retPos;\n+\n+                case ')':\n+                    readCh();\n+                    token = Token.RPAREN;\n+                    return retPos;\n+\n+                case '[':\n+                    readCh();\n+                    token = Token.LSQBRACKET;\n+                    return retPos;\n+\n+                case ']':\n+                    readCh();\n+                    token = Token.RSQBRACKET;\n+                    return retPos;\n+\n+                case ',':\n+                    readCh();\n+                    token = Token.COMMA;\n+                    return retPos;\n+\n+                case ';':\n+                    readCh();\n+                    token = Token.SEMICOLON;\n+                    return retPos;\n+\n+                case ':':\n+                    readCh();\n+                    token = Token.COLON;\n+                    return retPos;\n+\n+                case '=':\n+                    readCh();\n+                    if (ch == '=') {\n+                        readCh();\n+                        token = Token.EQ;\n+                        return retPos;\n+                    }\n+                    token = Token.ASSIGN;\n+                    return retPos;\n+\n+                case '\\u001a':\n+                    \/\/ Our one concession to DOS.\n+                    readCh();\n+                    if (ch == EOF) {\n+                        token = Token.EOF;\n+                        return retPos;\n+                    }\n+                    env.error(pos, \"funny.char\");\n+                    readCh();\n+                    break;\n+\n+                case '#':\n+                    readCh();\n+                    scanDecNumber();\n+                    return retPos;\n+\n+                case '&': {\n+                    readCh();\n+                    retPos = pos;\n+                    if (!Character.isJavaIdentifierStart((char) ch)) {\n+                        env.error(pos, \"identifier.expected\");\n+                    }\n+                    scanIdentifier();\n+                    String macroId = stringValue;\n+                    String macro = (String) macros.get(macroId);\n+                    if (macro == null) {\n+                        env.error(pos, \"macro.undecl\", macroId);\n+                        throw new SyntaxError();\n+                    }\n+                    setMacro(macro);\n+                    readCh();\n+                }\n+                break;\n+\n+                default:\n+                    if (Character.isJavaIdentifierStart((char) ch)) {\n+                        scanIdentifier();\n+                        return retPos;\n+                    }\n+                    env.error(pos, \"funny.char\");\n+                    readCh();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Scan to a matching '}', ']' or ')'. The current token must be a '{', '[' or '(';\n+     *\/\n+    protected void match(Token open, Token close) throws IOException {\n+        int depth = 1;\n+\n+        while (true) {\n+            scan();\n+            if (token == open) {\n+                depth++;\n+            } else if (token == close) {\n+                if (--depth == 0) {\n+                    return;\n+                }\n+            } else if (token == Token.EOF) {\n+                env.error(pos, \"unbalanced.paren\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Scan the next token.\n+     *\n+     * @return the position of the previous token.\n+     *\/\n+    protected int scan() throws IOException {\n+        int retPos = xscan();\n+\/\/env.traceln(\"scanned:\"+token+\" (\"+keywordName(token)+\")\");\n+        return retPos;\n+    }\n+\n+    \/**\n+     * Scan the next token.\n+     *\n+     * @return the position of the previous token.\n+     *\/\n+    protected int scanMacro() throws IOException {\n+        int retPos = xscan();\n+\/\/env.traceln(\"scanned:\"+token+\" (\"+keywordName(token)+\")\");\n+        return retPos;\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/Scanner.java","additions":905,"deletions":0,"binary":false,"changes":905,"status":"added"},{"patch":"@@ -0,0 +1,440 @@\n+\/*\n+ * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+import java.io.*;\n+import java.util.Hashtable;\n+\n+import org.openjdk.asmtools.common.Tool;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+\n+\/**\n+ * An input stream for java programs. The stream treats either \"\\n\", \"\\r\" or \"\\r\\n\" as the\n+ * end of a line, it always returns \\n. It also parses UNICODE characters expressed as\n+ * \\uffff. However, if it sees \"\\\\\", the second slash cannot begin a unicode sequence. It\n+ * keeps track of the current position in the input stream.\n+ *\n+ * An position consists of: ((linenr &lt;&lt; OFFSETBITS) | offset) this means that both\n+ * the line number and the exact offset into the file are encoded in each postion\n+ * value.<p>\n+ *\/\n+public class SourceFile implements org.openjdk.asmtools.jasm.Constants {\n+\n+    Tool tool;\n+\n+    boolean traceFlag = false;\n+    boolean debugInfoFlag = false;\n+    \/**\n+     * The increment for each character.\n+     *\/\n+    static final int OFFSETINC = 1;\n+    \/**\n+     * The increment for each line.\n+     *\/\n+    static final int LINEINC = 1 << OFFSETBITS;\n+    String inputFileName;\n+    InputStream in;\n+    PrintWriter out;\n+    int pos;\n+    private int chpos;\n+    private int pushBack = -1;\n+\n+    public SourceFile(Tool tool, DataInputStream dataInputStream, String inputFileName, PrintWriter out) {\n+        this.tool = tool;\n+        this.inputFileName = inputFileName;\n+        this.in = new BufferedInputStream(dataInputStream);\n+        chpos = LINEINC;\n+        this.out = out;\n+    }\n+\n+    public String getInputFileName() {\n+        return inputFileName;\n+    }\n+\n+    public void closeInp() {\n+        try {\n+            in.close();\n+        } catch (IOException e) {\n+        }\n+        flushErrors();\n+    }\n+\n+    public int read() throws IOException {\n+        pos = chpos;\n+        chpos += OFFSETINC;\n+\n+        int c = pushBack;\n+        if (c == -1) {\n+            c = in.read();\n+        } else {\n+            pushBack = -1;\n+        }\n+\n+        \/\/ parse special characters\n+        switch (c) {\n+            case -2:\n+                \/\/ -2 is a special code indicating a pushback of a backslash that\n+                \/\/ definitely isn't the start of a unicode sequence.\n+                return '\\\\';\n+\n+            case '\\\\':\n+                if ((c = in.read()) != 'u') {\n+                    pushBack = (c == '\\\\' ? -2 : c);\n+                    return '\\\\';\n+                }\n+                \/\/ we have a unicode sequence\n+                chpos += OFFSETINC;\n+                while ((c = in.read()) == 'u') {\n+                    chpos += OFFSETINC;\n+                }\n+\n+                \/\/ unicode escape sequence\n+                int d = 0;\n+                for (int i = 0; i < 4; i++, chpos += OFFSETINC, c = in.read()) {\n+                    switch (c) {\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                        case '8':\n+                        case '9':\n+                            d = (d << 4) + c - '0';\n+                            break;\n+\n+                        case 'a':\n+                        case 'b':\n+                        case 'c':\n+                        case 'd':\n+                        case 'e':\n+                        case 'f':\n+                            d = (d << 4) + 10 + c - 'a';\n+                            break;\n+\n+                        case 'A':\n+                        case 'B':\n+                        case 'C':\n+                        case 'D':\n+                        case 'E':\n+                        case 'F':\n+                            d = (d << 4) + 10 + c - 'A';\n+                            break;\n+\n+                        default:\n+                            error(pos, \"invalid.escape.char\");\n+                            pushBack = c;\n+                            return d;\n+                    }\n+                }\n+                pushBack = c;\n+                return d;\n+\n+            case '\\n':\n+                chpos += LINEINC;\n+                return '\\n';\n+\n+            case '\\r':\n+                if ((c = in.read()) != '\\n') {\n+                    pushBack = c;\n+                } else {\n+                    chpos += OFFSETINC;\n+                }\n+                chpos += LINEINC;\n+                return '\\n';\n+\n+            default:\n+                return c;\n+        }\n+    }\n+\n+    public int lineNumber(int pos) {\n+        return pos >>> OFFSETBITS;\n+    }\n+\n+    public int lineNumber() {\n+        return pos >>> OFFSETBITS;\n+    }\n+\n+    \/*==============================================================  Environment *\/\n+    \/**\n+     * The number of errors and warnings\n+     *\/\n+    public int nerrors;\n+    public int nwarnings;\n+\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    \/*\n+     *  Until place for jasm.properties is defind,\n+     *  I have to keep them right here\n+     *\n+     static Hashtable properties = new Hashtable(40);\n+\n+     static {\n+     \/\/ Scanner:\n+     properties.put(\"err.eof.in.comment\", \"Comment not terminated at end of input.\");\n+     properties.put(\"err.invalid.number\", \"Invalid character \\'%s\\' in number.\");\n+     properties.put(\"err.invalid.octal.number\", \"Invalid character in octal number.\");\n+     properties.put(\"err.overflow\", \"Numeric overflow.\");\n+     properties.put(\"err.float.format\", \"Invalid floating point format.\");\n+     properties.put(\"err.eof.in.string\", \"String not terminated at end of input.\");\n+     properties.put(\"err.newline.in.string\", \"String not terminated at end of line.\");\n+     properties.put(\"err.funny.char\", \"Invalid character in input.\");\n+     properties.put(\"err.unbalanced.paren\", \"Unbalanced parentheses.\");\n+     \/\/ Parser:\n+     properties.put(\"err.toplevel.expected\", \"Class or interface declaration expected.\");\n+     properties.put(\"err.token.expected\", \"'%s' expected.\");\n+     properties.put(\"err.identifier.expected\", \"Identifier expected.\");\n+     properties.put(\"err.name.expected\", \"Name expected.\");\n+     properties.put(\"err.io.exception\", \"I\/O error in %s.\");\n+     properties.put(\"err.cannot.write\", \"Cannot write to %s.\");\n+     properties.put(\"warn.array.wronglength\", \"expected array length %s do not match real length %s; expected length written\");\n+     properties.put(\"warn.attr.wronglength\", \"expected attribute length %s do not match real length %s; expected length written\");\n+     properties.put(\"attrname.notfound\", \"Cannot find \\\"%s\\\" in constant pool\");\n+     properties.put(\"err.attrname.expected\", \"Attribute's name or index expected.\");\n+     properties.put(\"err.element.expected\", \"Primary data item expected.\");\n+     properties.put(\"err.struct.expected\", \"Structured data item expected.\");\n+     properties.put(\"err.macro.undecl\", \"Macro %s undefined.\");\n+     }\n+     static String getProperty(String nm) {\n+     return (String) properties.get(nm);\n+     }\n+     *\/\n+    \/**\n+     * Error String\n+     *\/\n+    String errorString(String err, Object arg1, Object arg2, Object arg3) {\n+        String str = null;\n+\n+        if (!err.startsWith(\"warn.\")) {\n+            err = \"err.\" + err;\n+        }\n+        \/\/str = getProperty(err);\n+        str = i18n.getString(err);\n+\n+        if (str == null) {\n+            return \"error message '\" + err + \"' not found\";\n+        }\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (int i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            if ((c == '%') && (i + 1 < str.length())) {\n+                switch (str.charAt(++i)) {\n+                    case 's':\n+                        String arg = arg1.toString();\n+                        for (int j = 0; j < arg.length(); j++) {\n+                            switch (c = arg.charAt(j)) {\n+                                case ' ':\n+                                case '\\t':\n+                                case '\\n':\n+                                case '\\r':\n+                                    buf.append((char) c);\n+                                    break;\n+\n+                                default:\n+                                    if ((c > ' ') && (c <= 255)) {\n+                                        buf.append((char) c);\n+                                    } else {\n+                                        buf.append('\\\\');\n+                                        buf.append('u');\n+                                        buf.append(Integer.toString(c, 16));\n+                                    }\n+                            }\n+                        }\n+                        arg1 = arg2;\n+                        arg2 = arg3;\n+                        break;\n+\n+                    case '%':\n+                        buf.append('%');\n+                        break;\n+\n+                    default:\n+                        buf.append('?');\n+                        break;\n+                }\n+            } else {\n+                buf.append((char) c);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * List of outstanding error messages\n+     *\/\n+    ErrorMessage errors;\n+\n+    \/**\n+     * Insert an error message in the list of outstanding error messages. The list is\n+     * sorted on input position.\n+     *\/\n+    void insertError(int where, String message) {\n+        \/\/output(\"ERR = \" + message);\n+        ErrorMessage msg = new ErrorMessage(where, message);\n+        if (errors == null) {\n+            errors = msg;\n+        } else if (errors.where > where) {\n+            msg.next = errors;\n+            errors = msg;\n+        } else {\n+            ErrorMessage m = errors;\n+            for (; (m.next != null) && (m.next.where <= where); m = m.next) {\n+                ;\n+            }\n+            msg.next = m.next;\n+            m.next = msg;\n+        }\n+    }\n+\n+    \/**\n+     * Flush outstanding errors\n+     *\/\n+    public void flushErrors() {\n+        if (errors == null) {\n+            return;\n+        }\n+\n+        try {\n+            \/\/ Read the file\n+            DataInputStream dataInputStream = tool.getDataInputStream(inputFileName);\n+            if (dataInputStream == null)\n+                return;\n+\n+            byte data[] = new byte[dataInputStream.available()];\n+            dataInputStream.read(data);\n+            dataInputStream.close();\n+\n+            \/\/ Report the errors\n+            for (ErrorMessage msg = errors; msg != null; msg = msg.next) {\n+                int ln = msg.where >>> OFFSETBITS;\n+                int off = msg.where & ((1 << OFFSETBITS) - 1);\n+\n+                int i, j;\n+                for (i = off; (i > 0) && (data[i - 1] != '\\n') && (data[i - 1] != '\\r'); i--) {\n+                    ;\n+                }\n+                for (j = off; (j < data.length) && (data[j] != '\\n') && (data[j] != '\\r'); j++) {\n+                    ;\n+                }\n+\n+                String prefix = inputFileName + \":\" + ln + \":\";\n+                outputln(prefix + \" \" + msg.message);\n+                outputln(new String(data, i, j - i));\n+\n+                char strdata[] = new char[(off - i) + 1];\n+                for (j = i; j < off; j++) {\n+                    strdata[j - i] = (data[j] == '\\t') ? '\\t' : ' ';\n+                }\n+                strdata[off - i] = '^';\n+                outputln(new String(strdata));\n+            }\n+        } catch (IOException e) {\n+            outputln(\"I\/O exception\");\n+        }\n+        errors = null;\n+    }\n+\n+    \/**\n+     * Output a string. This can either be an error message or something for debugging.\n+     * This should be used instead of print.\n+     *\/\n+    public void output(String msg) {\n+        int len = msg.length();\n+        for (int i = 0; i < len; i++) {\n+            out.write(msg.charAt(i));\n+        }\n+        out.flush();\n+    }\n+\n+    \/**\n+     * Output a string. This can either be an error message or something for debugging.\n+     * This should be used instead of println.\n+     *\/\n+    public void outputln(String msg) {\n+        output(msg);\n+        out.write('\\n');\n+        out.flush();\n+    }\n+\n+    \/**\n+     * Issue an error.\n+     * @param where Offset in the source for the error\n+     * @param err Error number (as defined in this interface)\n+     * @param arg1 Optional argument to the error (null if not applicable)\n+     * @param arg2 Optional argument to the error (null if not applicable)\n+     * @param arg3 Optional argument to the error (null if not applicable)\n+     *\/\n+    \/**\n+     * Issue an error\n+     *\/\n+    public void error(int where, String err, Object arg1, Object arg2, Object arg3) {\n+        String msg = errorString(err, arg1, arg2, arg3);\n+        if (err.startsWith(\"warn.\")) {\n+            nwarnings++;\n+        } else {\n+            nerrors++;\n+        }\n+        traceln(\"error:\" + msg);\n+        insertError(where, msg);\n+    }\n+\n+    public final void error(int where, String err, Object arg1, Object arg2) {\n+        error(where, err, arg1, arg2, null);\n+    }\n+\n+    public final void error(int where, String err, Object arg1) {\n+        error(where, err, arg1, null, null);\n+    }\n+\n+    public final void error(int where, String err) {\n+        error(where, err, null, null, null);\n+    }\n+\n+    public final void error(String err) {\n+        error(pos, err, null, null, null);\n+    }\n+\n+    public final void error(String err, Object arg1) {\n+        error(pos, err, arg1, null, null);\n+    }\n+\n+    \/*==============================================================  trace *\/\n+    public void trace(String message) {\n+        if (traceFlag) {\n+            output(message);\n+        }\n+    }\n+\n+    public void traceln(String message) {\n+        if (traceFlag) {\n+            outputln(message);\n+        }\n+    }\n+} \/\/ end SourceFile\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/SourceFile.java","additions":440,"deletions":0,"binary":false,"changes":440,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jcoder;\n+\n+\/**\n+ * Syntax errors, should always be caught inside the parser for error recovery.\n+ *\/\n+class SyntaxError extends Error {\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/SyntaxError.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+# Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+jcoder.usage=\\\n+Usage: java -jar asmtools.jar jcoder [options] file.jcod...\\n\\\n+where possible options include:\n+\n+jcoder.opt.nowrite=\\\n+\\     -nowrite     do not write resulting .class files\n+jcoder.opt.ignore=\\\n+\\     -ignore      ingore non-fatal error(s) that suppress writing .class files\n+jcoder.opt.d=\\\n+\\     -d destdir   directory to place resulting .class files\n+jcoder.opt.version=\\\n+\\     -version     prints the program version\n+\n+jcoder.error.D_needs_macro=-D needs macro declaration\n+jcoder.error.no_closing_quota=no closing quota in macro definition\n+jcoder.error.d_requires_argument=-d requires argument\n+jcoder.error.does_not_exist={0} does not exist\n+jcoder.error.invalid_option=invalid option: {0}\n+jcoder.error.cannot_read=cannot read {0}\n+jcoder.error.cannot_write=cannot write {0}\n+jcoder.error.fatal_error=fatal error\n+jcoder.error.fatal_exception=fatal exception\n+\n+err.eof.in.comment=Comment not terminated at end of input.\n+err.invalid.number=Invalid character '%s' in number.\n+#err.invalid.octal.number=Invalid character in octal number.\n+err.overflow=Numeric overflow.\n+#err.float.format=Invalid floating point format.\n+err.eof.in.string=String not terminated at end of input.\n+err.newline.in.string=String not terminated at end of line.\n+err.funny.char=Invalid character in input.\n+err.unbalanced.paren=Unbalanced parentheses.\n+err.toplevel.expected=Class or interface declaration expected.\n+err.token.expected='{0}' expected.\n+err.identifier.expected=Identifier expected.\n+err.name.expected=Name expected.\n+err.io.exception=I\/O error in {0}.\n+err.cannot.write=Cannot write to {0}.\n+warn.array.wronglength=expected array length %s do not match real length %s; expected length written\n+warn.attr.wronglength=expected attribute length %s do not match real length %s; expected length written\n+#attrname.notfound=Cannot find \"{0}\" in constant pool\n+err.attrname.expected=Attribute's name or index expected.\n+err.element.expected=Primary data item expected.\n+err.struct.expected=Structured data item expected.\n+err.macro.undecl=Macro {0} undefined.\n+err.invalid.escape.char=Invalid escape char\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jcoder\/i18n.properties","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,1291 @@\n+\/*\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdec;\n+\n+import org.openjdk.asmtools.common.Module;\n+import org.openjdk.asmtools.asmutils.StringUtils;\n+import org.openjdk.asmtools.jasm.Modifiers;\n+import org.openjdk.asmtools.jcoder.JcodTokens;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+\n+import java.awt.event.KeyEvent;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import static org.openjdk.asmtools.jasm.Tables.AnnotElemType.AE_UNKNOWN;\n+import static org.openjdk.asmtools.jasm.TypeAnnotationTypes.*;\n+\n+\/**\n+ * Class data of the Java Decoder\n+ *\/\n+class ClassData {\n+\n+    private byte[] types;\n+    private Object[] cpool;\n+    private int CPlen;\n+    private NestedByteArrayInputStream countedin;\n+    private DataInputStream in;\n+    private PrintWriter out;\n+    private int[] cpe_pos;\n+    private boolean printDetails;\n+    private String entityType = \"\";\n+    private String entityName = \"\";\n+\n+    public static I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    ClassData(DataInputStream dis, int printFlags, PrintWriter out) throws IOException {\n+        byte[] buf = new byte[dis.available()];\n+        try {\n+            if (dis.read(buf) <= 0)\n+                throw new IOException(\"The file is empty\");\n+        } finally {\n+            dis.close();\n+        }\n+        countedin = new NestedByteArrayInputStream(buf);\n+        in = new DataInputStream(countedin);\n+        this.out = out;\n+        printDetails = ((printFlags & 1) == 1);\n+    }\n+\n+    \/*========================================================*\/\n+    private static final char[] hexTable = {\n+            '0', '1', '2', '3', '4', '5', '6', '7',\n+            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n+\n+    private String toHex(long val, int width) {\n+        StringBuilder s = new StringBuilder();\n+        for (int i = width * 2 - 1; i >= 0; i--) {\n+            s.append(hexTable[((int) (val >> (4 * i))) & 0xF]);\n+        }\n+        return \"0x\" + s.toString();\n+    }\n+\n+    private String toHex(long val) {\n+        int width;\n+        for (width = 8; width > 0; width--) {\n+            if ((val >> (width - 1) * 8) != 0) {\n+                break;\n+            }\n+        }\n+        return toHex(val, width);\n+    }\n+\n+    private void printByteHex(PrintWriter out, int b) {\n+        out.print(hexTable[(b >> 4) & 0xF]);\n+        out.print(hexTable[b & 0xF]);\n+    }\n+\n+    private void printBytes(PrintWriter out, DataInputStream in, int len)\n+            throws IOException {\n+        try {\n+            for (int i = 0; i < len; i++) {\n+                if (i % 8 == 0) {\n+                    out_print(\"0x\");\n+                }\n+                printByteHex(out, in.readByte());\n+                if (i % 8 == 7) {\n+                    out.println(\";\");\n+                }\n+            }\n+        } finally {\n+            if (len % 8 != 0) {\n+                out.println(\";\");\n+            }\n+        }\n+    }\n+\n+    private void printRestOfBytes() {\n+        for (int i = 0; ; i++) {\n+            try {\n+                byte b = in.readByte();\n+                if (i % 8 == 0) {\n+                    out_print(\"0x\");\n+                }\n+                printByteHex(out, b);\n+                if (i % 8 == 7) {\n+                    out.print(\";\\n\");\n+                }\n+            } catch (IOException e) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void printUtf8InfoIndex(int index, String indexName) {\n+        String name = (String) cpool[index];\n+        out_print(\"#\" + index + \"; \/\/ \");\n+        if (printDetails) {\n+            out.println(String.format(\"%-16s\",indexName) + \" : \" + name);\n+        } else {\n+            out.println(indexName);\n+        }\n+    }\n+\n+    \/*========================================================*\/\n+    private int shift = 0;\n+\n+    private void out_begin(String s) {\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.println(s);\n+        shift++;\n+    }\n+\n+    private void out_print(String s) {\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.print(s);\n+    }\n+\n+    private void out_println(String s) {\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.println(s);\n+    }\n+\n+    private void out_end(String s) {\n+        shift--;\n+        for (int i = 0; i < shift; i++) {\n+            out.print(\"  \");\n+        }\n+        out.println(s);\n+    }\n+\n+    private String startArray(int length) {\n+        return \"[\" + (printDetails ? Integer.toString(length) : \"\") + \"]\";\n+    }\n+\n+    private void startArrayCmt(int length, String comment) {\n+        out_begin(startArray(length) + format(\" {%s\", comment == null ? \"\" : \" \/\/ \" + comment));\n+    }\n+\n+    private void startArrayCmtB(int length, String comment) {\n+        out_begin(startArray(length) + format(\"b {%s\", comment == null ? \"\" : \" \/\/ \" + comment));\n+    }\n+\n+    \/*========================================================*\/\n+    private void readCP(DataInputStream in) throws IOException {\n+        int length = in.readUnsignedShort();\n+        CPlen = length;\n+        traceln(i18n.getString(\"jdec.trace.CP_len\", length));\n+        types = new byte[length];\n+        cpool = new Object[length];\n+        cpe_pos = new int[length];\n+        for (int i = 1; i < length; i++) {\n+            byte btag;\n+            int v1;\n+            long lv;\n+            cpe_pos[i] = countedin.getPos();\n+            btag = in.readByte();\n+            traceln(i18n.getString(\"jdec.trace.CP_entry\", i, btag));\n+            types[i] = btag;\n+            ConstType tg = tag(btag);\n+            switch (tg) {\n+                case CONSTANT_UTF8:\n+                    cpool[i] = in.readUTF();\n+                    break;\n+                case CONSTANT_INTEGER:\n+                    v1 = in.readInt();\n+                    cpool[i] = v1;\n+                    break;\n+                case CONSTANT_FLOAT:\n+                    v1 = Float.floatToIntBits(in.readFloat());\n+                    cpool[i] = v1;\n+                    break;\n+                case CONSTANT_LONG:\n+                    lv = in.readLong();\n+                    cpool[i] = lv;\n+                    i++;\n+                    break;\n+                case CONSTANT_DOUBLE:\n+                    lv = Double.doubleToLongBits(in.readDouble());\n+                    cpool[i] = lv;\n+                    i++;\n+                    break;\n+                case CONSTANT_CLASS:\n+                case CONSTANT_STRING:\n+                case CONSTANT_MODULE:\n+                case CONSTANT_PACKAGE:\n+                    v1 = in.readUnsignedShort();\n+                    cpool[i] = v1;\n+                    break;\n+                case CONSTANT_INTERFACEMETHOD:\n+                case CONSTANT_FIELD:\n+                case CONSTANT_METHOD:\n+                case CONSTANT_NAMEANDTYPE:\n+                    cpool[i] = \"#\" + in.readUnsignedShort() + \" #\" + in.readUnsignedShort();\n+                    break;\n+                case CONSTANT_DYNAMIC:\n+                case CONSTANT_INVOKEDYNAMIC:\n+                    cpool[i] = in.readUnsignedShort() + \"s #\" + in.readUnsignedShort();\n+                    break;\n+                case CONSTANT_METHODHANDLE:\n+                    cpool[i] = in.readUnsignedByte() + \"b #\" + in.readUnsignedShort();\n+                    break;\n+                case CONSTANT_METHODTYPE:\n+                    cpool[i] = \"#\" + in.readUnsignedShort();\n+                    break;\n+                default:\n+                    CPlen = i;\n+                    printCP(out);\n+                    out_println(toHex(btag, 1) + \"; \/\/ invalid constant type: \" + (int) btag + \" for element \" + i);\n+                    throw new ClassFormatError();\n+            }\n+        }\n+    }\n+\n+    private void printCP(PrintWriter out) {\n+        int length = CPlen;\n+        startArrayCmt(length, \"Constant Pool\");\n+        out_println(\"; \/\/ first element is empty\");\n+        try {\n+            int size;\n+            for (int i = 1; i < length; i = i + size) {\n+                size = 1;\n+                byte btag = types[i];\n+                ConstType tg = tag(btag);\n+                int pos = cpe_pos[i];\n+                String tagstr;\n+                String valstr;\n+                int v1;\n+                long lv;\n+                if (tg != null) {\n+                    tagstr = tg.parseKey();\n+                } else {\n+                    throw new Error(\"Can't get a tg representing the type of Constant in the Constant Pool at: \" + i);\n+                }\n+                switch (tg) {\n+                    case CONSTANT_UTF8: {\n+                        tagstr = \"Utf8\";\n+                        valstr = StringUtils.Utf8ToString((String) cpool[i]);\n+                    }\n+                    break;\n+                    case CONSTANT_FLOAT:\n+                    case CONSTANT_INTEGER:\n+                        v1 = (Integer) cpool[i];\n+                        valstr = toHex(v1, 4);\n+                        break;\n+                    case CONSTANT_DOUBLE:\n+                    case CONSTANT_LONG:\n+                        lv = (Long) cpool[i];\n+                        valstr = toHex(lv, 8) + \";\";\n+                        size = 2;\n+                        break;\n+                    case CONSTANT_CLASS:\n+                    case CONSTANT_MODULE:\n+                    case CONSTANT_PACKAGE:\n+                    case CONSTANT_STRING:\n+                        v1 = (Integer) cpool[i];\n+                        valstr = \"#\" + v1;\n+                        break;\n+                    case CONSTANT_INTERFACEMETHOD:\n+                    case CONSTANT_FIELD:\n+                    case CONSTANT_METHOD:\n+                    case CONSTANT_NAMEANDTYPE:\n+                    case CONSTANT_METHODHANDLE:\n+                    case CONSTANT_METHODTYPE:\n+                    case CONSTANT_DYNAMIC:\n+                    case CONSTANT_INVOKEDYNAMIC:\n+                        valstr = (String) cpool[i];\n+                        break;\n+                    default:\n+                        throw new Error(\"invalid constant type: \" + (int) btag);\n+                }\n+                out_print(tagstr + \" \" + valstr + \"; \/\/ #\" + i);\n+                if (printDetails) {\n+                    out_println(\" at \" + toHex(pos));\n+                } else {\n+                    out.println();\n+                }\n+            }\n+        } finally {\n+            out_end(\"} \/\/ Constant Pool\");\n+            out.println();\n+        }\n+    }\n+\n+    private String getStringPos() {\n+        return \" at \" + toHex(countedin.getPos());\n+    }\n+\n+    private String getCommentPosCond() {\n+        if (printDetails) {\n+            return \" \/\/ \" + getStringPos();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    private void decodeCPXAttr(DataInputStream in, int len, String attrname, PrintWriter out) throws IOException {\n+        decodeCPXAttrM(in, len, attrname, out, 1);\n+    }\n+\n+    private void decodeCPXAttrM(DataInputStream in, int len, String attrname, PrintWriter out, int expectedIndices) throws IOException {\n+        if (len != expectedIndices * 2) {\n+            out_println(\"\/\/ invalid length of \" + attrname + \" attr: \" + len + \" (should be \" + (expectedIndices * 2) + \") > \");\n+            printBytes(out, in, len);\n+        } else {\n+            StringBuilder outputString = new StringBuilder();\n+            for (int k = 1; k <= expectedIndices; k++) {\n+                outputString.append(\"#\").append(in.readUnsignedShort()).append(\"; \");\n+                if (k % 16 == 0) {\n+                    out_println(outputString.toString().replaceAll(\"\\\\s+$\",\"\"));\n+                    outputString = new StringBuilder();\n+                }\n+            }\n+            if (outputString.length() > 0) {\n+                out_println(outputString.toString().replaceAll(\"\\\\s+$\",\"\"));\n+            }\n+        }\n+    }\n+\n+    private void printStackMap(DataInputStream in, int elementsNum) throws IOException {\n+        int num;\n+        if (elementsNum > 0) {\n+            num = elementsNum;\n+        } else {\n+            num = in.readUnsignedShort();\n+        }\n+        out.print(startArray(num) + (elementsNum > 0 ? \"z\" : \"\") + \"{\");\n+        try {\n+            for (int k = 0; k < num; k++) {\n+                int maptype = in.readUnsignedByte();\n+                StackMapType mptyp = stackMapType(maptype, out);\n+                String maptypeImg;\n+                if (printDetails) {\n+                    maptypeImg = maptype + \"b\";\n+                } else {\n+                    try {\n+                        maptypeImg = mptyp.parsekey();\n+                    } catch (ArrayIndexOutOfBoundsException e) {\n+                        maptypeImg = \"\/* BAD TYPE: *\/ \" + maptype + \"b\";\n+                    }\n+                }\n+                switch (mptyp) {\n+                    case ITEM_Object:\n+                    case ITEM_NewObject:\n+                        maptypeImg = maptypeImg + \",\" + in.readUnsignedShort();\n+                        break;\n+                    case ITEM_UNKNOWN:\n+                        maptypeImg = maptype + \"b\";\n+                        break;\n+                    default:\n+                }\n+                out.print(maptypeImg);\n+                if (k < num - 1) {\n+                    out.print(\"; \");\n+                }\n+            }\n+        } finally {\n+            out.print(\"}\");\n+        }\n+    }\n+\n+    \/**\n+     * Processes 4.7.20 The RuntimeVisibleTypeAnnotations Attribute, 4.7.21 The RuntimeInvisibleTypeAnnotations Attribute\n+     * <code>type_annotation<\/code> structure.\n+     *\/\n+    private void decodeTargetTypeAndRefInfo(DataInputStream in) throws IOException {\n+        int tt = in.readUnsignedByte(); \/\/ [4.7.20] annotations[], type_annotation { u1 target_type; ...}\n+        ETargetType targetType = ETargetType.getTargetType(tt);\n+        if( targetType == null ) {\n+            throw new Error(\"Type annotation: invalid target_type(u1) \" + tt);\n+        }\n+        ETargetInfo targetInfo = targetType.targetInfo();\n+        out_println(toHex(tt, 1) + \";  \/\/  target_type: \" + targetType.parseKey());\n+        switch (targetInfo) {\n+            case TYPEPARAM:          \/\/[3.3.1] meth_type_param, class_type_param:\n+                out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/  param_index\");\n+                break;\n+            case SUPERTYPE:         \/\/[3.3.2]  class_exts_impls\n+                out_println(toHex(in.readUnsignedShort(), 2) + \";  \/\/  type_index\");\n+                break;\n+            case TYPEPARAM_BOUND:   \/\/[3.3.3]  class_type_param_bnds, meth_type_param_bnds\n+                out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/  param_index\");\n+                out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/  bound_index\");\n+                break;\n+            case EMPTY:             \/\/[3.3.4]  meth_receiver, meth_ret_type, field\n+                \/\/ NOTE: reference_info is empty for this annotation's target\n+                break;\n+            case METHODPARAM:       \/\/[3.3.5]  meth_formal_param:\n+                out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/  parameter_index\");\n+                break;\n+            case EXCEPTION:         \/\/[3.3.61]  throws_type\n+                \/\/KTL:  Updated index to UShort for JSR308 change\n+                out_println(in.readUnsignedShort() + \";  \/\/  type_index\");\n+                break;\n+            case LOCALVAR: \/\/[3.3.7]  local_var, resource_var\n+            {\n+                int lv_num = in.readUnsignedShort();\n+                startArrayCmt(lv_num, \"local_variables\");\n+                try {\n+                    for (int i = 0; i < lv_num; i++) {\n+                        out_println(in.readUnsignedShort() + \" \" + in.readUnsignedShort()\n+                                + \" \" + in.readUnsignedShort() + \";\" + getCommentPosCond());\n+                    }\n+                } finally {\n+                    out_end(\"}\");\n+                }\n+            }\n+            break;\n+            case CATCH:             \/\/[3.3.8]  exception_param\n+                out_println(in.readUnsignedShort() + \";  \/\/  exception_table_index\");\n+                break;\n+            case OFFSET:            \/\/[3.3.9]  type_test (instanceof), obj_creat (new)\n+                \/\/ constr_ref_receiver, meth_ref_receiver\n+                out_println(in.readUnsignedShort() + \";  \/\/  offset\");\n+                break;\n+            case TYPEARG:           \/\/[3.3.10]  cast, constr_ref_typearg, meth_invoc_typearg\n+                \/\/ constr_invoc_typearg, meth_ref_typearg\n+                out_println(in.readUnsignedShort() + \";  \/\/  offset\");\n+                out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/  type_index\");\n+                break;\n+            default:                \/\/ should never happen\n+                out_println(toHex(tt, 1) + \"; \/\/ invalid target_info: \" + tt);\n+                throw new ClassFormatError();\n+        }\n+        \/\/ [4.7.20.2]\n+        int path_length = in.readUnsignedByte();  \/\/ type_path { u1 path_length; ...}\n+        startArrayCmtB(path_length, \"type_paths\");\n+        try {\n+            for (int i = 0; i < path_length; i++) {\n+                \/\/ print the type_path elements\n+                out_println(\"{ \" + toHex(in.readUnsignedByte(), 1)  \/\/ { u1 type_path_kind;\n+                        + \"; \" + toHex(in.readUnsignedByte(), 1)    \/\/   u1 type_argument_index; }\n+                        + \"; } \/\/ type_path[\" + i + \"]\");           \/\/ path[i]\n+            }\n+        } finally {\n+            out_end(\"}\");\n+        }\n+    }\n+\n+    private void decodeElementValue(DataInputStream in, PrintWriter out) throws IOException {\n+        out_begin(\"{  \/\/  element_value\");\n+        try {\n+            char tg = (char) in.readByte();\n+            AnnotElemType tag = annotElemType(tg);\n+            if (tag != AE_UNKNOWN) {\n+                out_println(\"'\" + tg + \"';\");\n+            }\n+            switch (tag) {\n+                case AE_BYTE:\n+                case AE_CHAR:\n+                case AE_DOUBLE:\n+                case AE_FLOAT:\n+                case AE_INT:\n+                case AE_LONG:\n+                case AE_SHORT:\n+                case AE_BOOLEAN:\n+                case AE_STRING:\n+                    decodeCPXAttr(in, 2, \"const_value_index\", out);\n+                    break;\n+                case AE_ENUM:\n+                    out_begin(\"{  \/\/  enum_const_value\");\n+                    decodeCPXAttr(in, 2, \"type_name_index\", out);\n+                    decodeCPXAttr(in, 2, \"const_name_index\", out);\n+                    out_end(\"}  \/\/  enum_const_value\");\n+                    break;\n+                case AE_CLASS:\n+                    decodeCPXAttr(in, 2, \"class_info_index\", out);\n+                    break;\n+                case AE_ANNOTATION:\n+                    decodeAnnotation(in, out);\n+                    break;\n+                case AE_ARRAY:\n+                    int ev_num = in.readUnsignedShort();\n+                    startArrayCmt(ev_num, \"array_value\");\n+                    try {\n+                        for (int i = 0; i < ev_num; i++) {\n+                            decodeElementValue(in, out);\n+                            if (i < ev_num - 1) {\n+                                out_println(\";\");\n+                            }\n+                        }\n+                    } finally {\n+                        out_end(\"}  \/\/  array_value\");\n+                    }\n+                    break;\n+                case AE_UNKNOWN:\n+                default:\n+                    String msg = \"invalid element_value\" + (isPrintableChar(tg) ? \" tag type : \" + tg : \"\");\n+                    out_println(toHex(tg, 1) + \"; \/\/ \" + msg);\n+                    throw new ClassFormatError(msg);\n+            }\n+        } finally {\n+            out_end(\"}  \/\/  element_value\");\n+        }\n+    }\n+\n+    public boolean isPrintableChar(char c) {\n+        Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n+        return (!Character.isISOControl(c)) &&\n+                c != KeyEvent.CHAR_UNDEFINED &&\n+                block != null &&\n+                block != Character.UnicodeBlock.SPECIALS;\n+    }\n+\n+    private void decodeAnnotation(DataInputStream in, PrintWriter out) throws IOException {\n+        out_begin(\"{  \/\/  annotation\");\n+        try {\n+            decodeCPXAttr(in, 2, \"field descriptor\", out);\n+            int evp_num = in.readUnsignedShort();\n+            decodeElementValuePairs(evp_num, in, out);\n+        } finally {\n+            out_end(\"}  \/\/  annotation\");\n+        }\n+    }\n+\n+    private void decodeElementValuePairs(int count, DataInputStream in, PrintWriter out) throws IOException {\n+        startArrayCmt(count, \"element_value_pairs\");\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                out_begin(\"{  \/\/  element value pair\");\n+                try {\n+                    decodeCPXAttr(in, 2, \"name of the annotation type element\", out);\n+                    decodeElementValue(in, out);\n+                } finally {\n+                    out_end(\"}  \/\/  element value pair\");\n+                    if (i < count - 1) {\n+                        out_println(\";\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            out_end(\"}  \/\/  element_value_pairs\");\n+        }\n+    }\n+\n+    \/**\n+     * component_info {     JEP 359 Record(Preview): class file 58.65535\n+     *     u2               name_index;\n+     *     u2               descriptor_index;\n+     *     u2               attributes_count;\n+     *     attribute_info attributes[attributes_count];\n+     * }\n+     *\n+     * or\n+     * field_info {\n+     *     u2             access_flags;\n+     *     u2             name_index;\n+     *     u2             descriptor_index;\n+     *     u2             attributes_count;\n+     *     attribute_info attributes[attributes_count];\n+     * }\n+     * or\n+     * method_info {\n+     *     u2             access_flags;\n+     *     u2             name_index;\n+     *     u2             descriptor_index;\n+     *     u2             attributes_count;\n+     *     attribute_info attributes[attributes_count];\n+     * }\n+     *\n+     *\/\n+    private void decodeInfo(DataInputStream in, PrintWriter out, String elementName, boolean hasAccessFlag) throws IOException {\n+        out_begin(\"{  \/\/ \" + elementName + (printDetails ? getStringPos() : \"\"));\n+        try {\n+            if(hasAccessFlag) {\n+                \/\/  u2 access_flags;\n+                out_println(toHex(in.readShort(), 2) + \"; \/\/ access\");\n+            }\n+            \/\/ u2 name_index\n+            printUtf8InfoIndex(in.readUnsignedShort(), \"name_index\");\n+            \/\/ u2 descriptor_index\n+            printUtf8InfoIndex(in.readUnsignedShort(), \"descriptor_index\");\n+            \/\/ u2 attributes_count;\n+            \/\/ attribute_info attributes[attributes_count]\n+            decodeAttrs(in, out);\n+        } finally {\n+            out_end(\"}\");\n+        }\n+    }\n+\n+    private void decodeTypeAnnotation(DataInputStream in, PrintWriter out) throws IOException {\n+        out_begin(\"{  \/\/  type_annotation\");\n+        try {\n+            decodeTargetTypeAndRefInfo(in);\n+            decodeCPXAttr(in, 2, \"field descriptor\", out);\n+            int evp_num = in.readUnsignedShort();\n+            decodeElementValuePairs(evp_num, in, out);\n+        } finally {\n+            out_end(\"}  \/\/  type_annotation\");\n+        }\n+    }\n+\n+    private void decodeBootstrapMethod(DataInputStream in) throws IOException {\n+        out_begin(\"{  \/\/  bootstrap_method\");\n+        try {\n+            out_println(\"#\" + in.readUnsignedShort() + \"; \/\/ bootstrap_method_ref\");\n+            int bm_args_cnt = in.readUnsignedShort();\n+            startArrayCmt(bm_args_cnt, \"bootstrap_arguments\");\n+            try {\n+                for (int i = 0; i < bm_args_cnt; i++) {\n+                    out_println(\"#\" + in.readUnsignedShort() + \";\" + getCommentPosCond());\n+                }\n+            } finally {\n+                out_end(\"}  \/\/  bootstrap_arguments\");\n+            }\n+        } finally {\n+            out_end(\"}  \/\/  bootstrap_method\");\n+        }\n+    }\n+\n+    private void decodeAttr(DataInputStream in, PrintWriter out) throws IOException {\n+        \/\/ Read one attribute\n+        String posComment = getStringPos();\n+        int name_cpx = in.readUnsignedShort(), btag, len;\n+\n+        String AttrName = \"\";\n+        try {\n+            btag = types[name_cpx];\n+            ConstType tag = tag(btag);\n+\n+            if (tag == ConstType.CONSTANT_UTF8) {\n+                AttrName = (String) cpool[name_cpx];\n+            }\n+        } catch (ArrayIndexOutOfBoundsException ignored) {\n+        }\n+        AttrTag tg = attrtag(AttrName);\n+        String endingComment = AttrName;\n+        len = in.readInt();\n+        countedin.enter(len);\n+        try {\n+            if (printDetails) {\n+                out_begin(\"Attr(#\" + name_cpx + \", \" + len + \") { \/\/ \" + AttrName + posComment);\n+            } else {\n+                out_begin(\"Attr(#\" + name_cpx + \") { \/\/ \" + AttrName);\n+            }\n+\n+            switch (tg) {\n+                case ATT_Code:\n+                    out_println(in.readUnsignedShort() + \"; \/\/ max_stack\");\n+                    out_println(in.readUnsignedShort() + \"; \/\/ max_locals\");\n+                    int code_len = in.readInt();\n+                    out_begin(\"Bytes\" + startArray(code_len) + \"{\");\n+                    try {\n+                        printBytes(out, in, code_len);\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    int trap_num = in.readUnsignedShort();\n+                    startArrayCmt(trap_num, \"Traps\");\n+                    try {\n+                        for (int i = 0; i < trap_num; i++) {\n+                            out_println(in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \";\" +\n+                                    getCommentPosCond());\n+                        }\n+                    } finally {\n+                        out_end(\"} \/\/ end Traps\");\n+                    }\n+                    \/\/ Read the attributes\n+                    decodeAttrs(in, out);\n+                    break;\n+\n+                case ATT_Exceptions:\n+                    int count = in.readUnsignedShort();\n+                    startArrayCmt(count, AttrName);\n+                    try {\n+                        for (int i = 0; i < count; i++) {\n+                            out_println(\"#\" + in.readUnsignedShort() + \";\" +\n+                                    getCommentPosCond());\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_LineNumberTable:\n+                    int ll_num = in.readUnsignedShort();\n+                    startArrayCmt(ll_num, \"line_number_table\");\n+                    try {\n+                        for (int i = 0; i < ll_num; i++) {\n+                            out_println(in.readUnsignedShort() + \"  \" +\n+                                    in.readUnsignedShort() + \";\" +\n+                                    getCommentPosCond());\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_LocalVariableTable:\n+                case ATT_LocalVariableTypeTable:\n+                    int lvt_num = in.readUnsignedShort();\n+                    startArrayCmt(lvt_num, AttrName);\n+                    try {\n+                        for (int i = 0; i < lvt_num; i++) {\n+                            out_println(in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \";\" +\n+                                    getCommentPosCond());\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_InnerClasses:\n+                    int ic_num = in.readUnsignedShort();\n+                    startArrayCmt(ic_num, \"classes\");\n+                    try {\n+                        for (int i = 0; i < ic_num; i++) {\n+                            out_println(\"#\" + in.readUnsignedShort() + \" #\" +\n+                                    in.readUnsignedShort() + \" #\" +\n+                                    in.readUnsignedShort() + \" \" +\n+                                    in.readUnsignedShort() + \";\" + getCommentPosCond());\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_StackMap:\n+                    int e_num = in.readUnsignedShort();\n+                    startArrayCmt(e_num, \"\");\n+                    try {\n+                        for (int k = 0; k < e_num; k++) {\n+                            int start_pc = in.readUnsignedShort();\n+                            out_print(\"\" + start_pc + \", \");\n+                            printStackMap(in, 0);\n+                            out.print(\", \");\n+                            printStackMap(in, 0);\n+                            out.println(\";\");\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_StackMapTable:\n+                    int et_num = in.readUnsignedShort();\n+                    startArrayCmt(et_num, \"\");\n+                    try {\n+                        for (int k = 0; k < et_num; k++) {\n+                            int frame_type = in.readUnsignedByte();\n+                            StackMapFrameType ftype = stackMapFrameType(frame_type);\n+                            switch (ftype) {\n+                                case SAME_FRAME:\n+                                    \/\/ type is same_frame;\n+                                    out_print(\"\" + frame_type + \"b\");\n+                                    out.println(\"; \/\/ same_frame\");\n+                                    break;\n+                                case SAME_LOCALS_1_STACK_ITEM_FRAME:\n+                                    \/\/ type is same_locals_1_stack_item_frame\n+                                    out_print(\"\" + frame_type + \"b, \");\n+                                    \/\/ read additional single stack element\n+                                    printStackMap(in, 1);\n+                                    out.println(\"; \/\/ same_locals_1_stack_item_frame\");\n+                                    break;\n+                                case SAME_LOCALS_1_STACK_ITEM_EXTENDED_FRAME:\n+                                    \/\/ type is same_locals_1_stack_item_frame_extended\n+                                    int noffset = in.readUnsignedShort();\n+                                    out_print(\"\" + frame_type + \"b, \" + noffset + \", \");\n+                                    \/\/ read additional single stack element\n+                                    printStackMap(in, 1);\n+                                    out.println(\"; \/\/ same_locals_1_stack_item_frame_extended\");\n+                                    break;\n+                                case CHOP_1_FRAME:\n+                                case CHOP_2_FRAME:\n+                                case CHOP_3_FRAME:\n+                                    \/\/ type is chop_frame\n+                                    int coffset = in.readUnsignedShort();\n+                                    out_print(\"\" + frame_type + \"b, \" + coffset);\n+                                    out.println(\"; \/\/ chop_frame \" + (251 - frame_type));\n+                                    break;\n+                                case SAME_FRAME_EX:\n+                                    \/\/ type is same_frame_extended;\n+                                    int xoffset = in.readUnsignedShort();\n+                                    out_print(\"\" + frame_type + \"b, \" + xoffset);\n+                                    out.println(\"; \/\/ same_frame_extended\");\n+                                    break;\n+                                case APPEND_FRAME:\n+                                    \/\/ type is append_frame\n+                                    int aoffset = in.readUnsignedShort();\n+                                    out_print(\"\" + frame_type + \"b, \" + aoffset + \", \");\n+                                    \/\/ read additional locals\n+                                    printStackMap(in, frame_type - 251);\n+                                    out.println(\"; \/\/ append_frame \" + (frame_type - 251));\n+                                    break;\n+                                case FULL_FRAME:\n+                                    \/\/ type is full_frame\n+                                    int foffset = in.readUnsignedShort();\n+                                    out_print(\"\" + frame_type + \"b, \" + foffset + \", \");\n+                                    printStackMap(in, 0);\n+                                    out.print(\", \");\n+                                    printStackMap(in, 0);\n+                                    out.println(\"; \/\/ full_frame\");\n+                                    break;\n+                            }\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_EnclosingMethod:\n+                    decodeCPXAttrM(in, len, AttrName, out, 2);\n+                    break;\n+                case ATT_AnnotationDefault:\n+                    decodeElementValue(in, out);\n+                    break;\n+                case ATT_RuntimeInvisibleAnnotations:\n+                case ATT_RuntimeVisibleAnnotations:\n+                    int an_num = in.readUnsignedShort();\n+                    startArrayCmt(an_num, \"annotations\");\n+                    try {\n+                        for (int i = 0; i < an_num; i++) {\n+                            decodeAnnotation(in, out);\n+                            if (i < an_num - 1) {\n+                                out_println(\";\");\n+                            }\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                \/\/ 4.7.20 The RuntimeVisibleTypeAnnotations Attribute\n+                \/\/ 4.7.21 The RuntimeInvisibleTypeAnnotations Attribute\n+                case ATT_RuntimeInvisibleTypeAnnotations:\n+                case ATT_RuntimeVisibleTypeAnnotations:\n+                    int ant_num = in.readUnsignedShort();\n+                    startArrayCmt(ant_num, \"annotations\");\n+                    try {\n+                        for (int i = 0; i < ant_num; i++) {\n+                            decodeTypeAnnotation(in, out);\n+                            if (i < ant_num - 1) {\n+                                out_println(\";\");\n+                            }\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_RuntimeInvisibleParameterAnnotations:\n+                case ATT_RuntimeVisibleParameterAnnotations:\n+                    int pm_num = in.readUnsignedByte();\n+                    startArrayCmtB(pm_num, \"parameters\");\n+                    try {\n+                        for (int k = 0; k < pm_num; k++) {\n+                            int anp_num = in.readUnsignedShort();\n+                            startArrayCmt(anp_num, \"annotations\");\n+                            try {\n+                                for (int i = 0; i < anp_num; i++) {\n+                                    decodeAnnotation(in, out);\n+                                    if (k < anp_num - 1) {\n+                                        out_println(\";\");\n+                                    }\n+                                }\n+                            } finally {\n+                                out_end(\"}\");\n+                            }\n+                            if (k < pm_num - 1) {\n+                                out_println(\";\");\n+                            }\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_BootstrapMethods:\n+                    int bm_num = in.readUnsignedShort();\n+                    startArrayCmt(bm_num, \"bootstrap_methods\");\n+                    try {\n+                        for (int i = 0; i < bm_num; i++) {\n+                            decodeBootstrapMethod(in);\n+                            if (i < bm_num - 1) {\n+                                out_println(\";\");\n+                            }\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_Module:\n+                    decodeModule(in);\n+                    break;\n+                case ATT_TargetPlatform:\n+                    decodeCPXAttrM(in, len, AttrName, out, 3);\n+                    break;\n+                case ATT_ModulePackages:\n+                    int p_num = in.readUnsignedShort();\n+                    startArrayCmt(p_num, null);\n+                    try {\n+                        decodeCPXAttrM(in, len - 2, AttrName, out, p_num);\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                \/\/  MethodParameters_attribute {\n+                \/\/    u2 attribute_name_index;\n+                \/\/    u4 attribute_length;\n+                \/\/    u1 parameters_count;\n+                \/\/    {   u2 name_index;\n+                \/\/        u2 access_flags;\n+                \/\/    } parameters[parameters_count];\n+                \/\/  }\n+                case ATT_MethodParameters:\n+                    int pcount = in.readUnsignedByte();\n+                    startArrayCmtB(pcount, AttrName);\n+                    try {\n+                        for (int i = 0; i < pcount; i++) {\n+                            out_println(\"#\" + in.readUnsignedShort() + \"  \" +\n+                                    toHex(in.readUnsignedShort(), 2) + \";\" +\n+                                    getCommentPosCond());\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                \/\/  JEP 359 Record(Preview): class file 58.65535\n+                \/\/  Record_attribute {\n+                \/\/      u2 attribute_name_index;\n+                \/\/      u4 attribute_length;\n+                \/\/      u2 components_count;\n+                \/\/      component_info components[components_count];\n+                \/\/  }\n+                case ATT_Record:\n+                    int ncomps = in.readUnsignedShort();\n+                    startArrayCmt(ncomps, \"components\");\n+                    try {\n+                        for (int i = 0; i < ncomps; i++) {\n+                            decodeInfo(in,out,\"component\",false);\n+                            if (i < ncomps - 1) {\n+                                out_println(\";\");\n+                            }\n+                        }\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                case ATT_ConstantValue:\n+                case ATT_Signature:\n+                case ATT_SourceFile:\n+                    decodeCPXAttr(in, len, AttrName, out);\n+                    break;\n+                    \/\/  JEP 181 (Nest-based Access Control): class file 55.0\n+                    \/\/  NestHost_attribute {\n+                    \/\/    u2 attribute_name_index;\n+                    \/\/    u4 attribute_length;\n+                    \/\/    u2 host_class_index;\n+                    \/\/  }\n+                case ATT_NestHost:\n+                    decodeTypes(in, out, 1);\n+                    break;\n+                    \/\/  JEP 181 (Nest-based Access Control): class file 55.0\n+                    \/\/  NestMembers_attribute {\n+                    \/\/    u2 attribute_name_index;\n+                    \/\/    u4 attribute_length;\n+                    \/\/    u2 number_of_classes;\n+                    \/\/    u2 classes[number_of_classes];\n+                    \/\/  }\n+                case ATT_NestMembers:\n+                    \/\/  JEP 360 (Sealed types): class file 59.65535\n+                    \/\/  PermittedSubclasses_attribute {\n+                    \/\/    u2 attribute_name_index;\n+                    \/\/    u4 attribute_length;\n+                    \/\/    u2 number_of_classes;\n+                    \/\/    u2 classes[number_of_classes];\n+                    \/\/  }\n+                case ATT_PermittedSubclasses:\n+                    int nsubtypes = in.readUnsignedShort();\n+                    startArrayCmt(nsubtypes, \"classes\");\n+                    try {\n+                        decodeTypes(in, out, nsubtypes);\n+                    } finally {\n+                        out_end(\"}\");\n+                    }\n+                    break;\n+                default:\n+                    printBytes(out, in, len);\n+                    if (AttrName == null) {\n+                        endingComment = \"Attr(#\" + name_cpx + \")\";\n+                    }\n+            }\n+\n+        } catch (EOFException e) {\n+            out.println(\"\/\/ ======== unexpected end of attribute array\");\n+        } finally {\n+            int rest = countedin.available();\n+            if (rest > 0) {\n+                out.println(\"\/\/ ======== attribute array started \" + posComment + \" has \" + rest + \" bytes more:\");\n+                printBytes(out, in, rest);\n+            }\n+            out_end(\"} \/\/ end \" + endingComment);\n+            countedin.leave();\n+        }\n+    }\n+\n+    private void decodeModuleStatement(String statementName, DataInputStream in) throws IOException {\n+        \/\/ u2 {exports|opens}_count\n+        int count = in.readUnsignedShort();\n+        startArrayCmt(count, statementName);\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                \/\/ u2 {exports|opens}_index; u2 {exports|opens}_flags\n+                int index = in.readUnsignedShort();\n+                int nFlags = in.readUnsignedShort();\n+                String sFlags = printDetails ? Module.Modifier.getStatementFlags(nFlags) : \"\";\n+                out_println(\"#\" + index + \" \" + toHex(nFlags, 2) + (sFlags.isEmpty() ? \"\" : \" \/\/ [ \" + sFlags + \" ]\"));\n+                int exports_to_count = in.readUnsignedShort();\n+                startArrayCmt(exports_to_count, null);\n+                try {\n+                    for (int j = 0; j < exports_to_count; j++) {\n+                        out_println(\"#\" + in.readUnsignedShort() + \";\");\n+                    }\n+                } finally {\n+                    out_end(\"};\");\n+                }\n+            }\n+        } finally {\n+            out_end(\"} \/\/ \" + statementName + \"\\n\");\n+        }\n+    }\n+\n+    private void decodeModule(DataInputStream in) throws IOException {\n+        \/\/u2 module_name_index\n+        int index = in.readUnsignedShort();\n+        entityName = (String) cpool[(Integer) cpool[index]];\n+        out_print(\"#\" + index + \"; \/\/ \");\n+        if (printDetails) {\n+            out.println(String.format(\"%-16s\",\"name_index\") + \" : \" + entityName);\n+        } else {\n+            out.println(\"name_index\");\n+        }\n+\n+        \/\/ u2 module_flags\n+        int moduleFlags = in.readUnsignedShort();\n+        out_print(toHex(moduleFlags, 2) + \"; \/\/ flags\");\n+        if (printDetails) {\n+            out_print(\" \" + Module.Modifier.getModuleFlags(moduleFlags));\n+        }\n+        out.println();\n+\n+        \/\/u2 module_version\n+        int versionIndex = in.readUnsignedShort();\n+        out_println(\"#\" + versionIndex + \"; \/\/ version\");\n+\n+        \/\/ u2 requires_count\n+        int count = in.readUnsignedShort();\n+        startArrayCmt(count, \"requires\");\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                \/\/ u2 requires_index; u2 requires_flags; u2 requires_version_index\n+                index = in.readUnsignedShort();\n+                int nFlags = in.readUnsignedShort();\n+                versionIndex = in.readUnsignedShort();\n+                String sFlags = printDetails ? Module.Modifier.getStatementFlags(nFlags) : \"\";\n+                out_println(\"#\" + index + \" \" + toHex(nFlags, 2) + \" #\" + versionIndex + \";\" + (sFlags.isEmpty() ? \"\" : \" \/\/ \" + sFlags));\n+            }\n+        } finally {\n+            out_end(\"} \/\/ requires\\n\");\n+        }\n+\n+        decodeModuleStatement(\"exports\", in);\n+\n+        decodeModuleStatement(\"opens\", in);\n+        \/\/ u2 uses_count\n+        count = in.readUnsignedShort();\n+        startArrayCmt(count, \"uses\");\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                \/\/ u2 uses_index\n+                out_println(\"#\" + in.readUnsignedShort() + \";\");\n+            }\n+        } finally {\n+            out_end(\"} \/\/ uses\\n\");\n+        }\n+        count = in.readUnsignedShort(); \/\/ u2 provides_count\n+        startArrayCmt(count, \"provides\");\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                \/\/ u2 provides_index\n+                out_println(\"#\" + in.readUnsignedShort());\n+                int provides_with_count = in.readUnsignedShort();\n+                \/\/ u2 provides_with_count\n+                startArrayCmt(provides_with_count, null);\n+                try {\n+                    for (int j = 0; j < provides_with_count; j++) {\n+                        \/\/ u2 provides_with_index;\n+                        out_println(\"#\" + in.readUnsignedShort() + \";\");\n+                    }\n+                } finally {\n+                    out_end(\"};\");\n+                }\n+            }\n+        } finally {\n+            out_end(\"} \/\/ provides\\n\");\n+        }\n+    }\n+\n+    private void decodeAttrs(DataInputStream in, PrintWriter out) throws IOException {\n+        \/\/ Read the attributes\n+        int attr_num = in.readUnsignedShort();\n+        startArrayCmt(attr_num, \"Attributes\");\n+        try {\n+            for (int i = 0; i < attr_num; i++) {\n+                decodeAttr(in, out);\n+                if (i + 1 < attr_num) {\n+                    out_println(\";\");\n+                }\n+            }\n+        } finally {\n+            out_end(\"} \/\/ Attributes\");\n+        }\n+    }\n+\n+    private void decodeMembers(DataInputStream in, PrintWriter out, String groupName, String elementName) throws IOException {\n+        int count = in.readUnsignedShort();\n+        traceln(groupName + \"=\" + count);\n+        startArrayCmt(count, groupName);\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                decodeInfo(in,out,elementName,true);\n+                if (i + 1 < count) {\n+                    out_println(\";\");\n+                }\n+            }\n+        } finally {\n+            out_end(\"} \/\/ \" + groupName);\n+            out.println();\n+        }\n+    }\n+\n+    void decodeClass(String fileName) throws IOException {\n+        \/\/ Read the header\n+        try {\n+            int magic = in.readInt();\n+            int min_version = in.readUnsignedShort();\n+            int version = in.readUnsignedShort();\n+\n+            \/\/ Read the constant pool\n+            readCP(in);\n+            short access = in.readShort(); \/\/ don't care about sign\n+            int this_cpx = in.readUnsignedShort();\n+\n+            try {\n+                entityName = (String) cpool[(Integer) cpool[this_cpx]];\n+                if (entityName.equals(\"module-info\")) {\n+                    entityType = \"module\";\n+                    entityName = \"\";\n+                } else {\n+                    entityType = \"class\";\n+                }\n+                if (!entityName.isEmpty() && (JcodTokens.keyword_token_ident(entityName) != JcodTokens.Token.IDENT || JcodTokens.constValue(entityName) != -1)) {\n+                    \/\/ JCod can't parse a entityName matching a keyword or a constant value,\n+                    \/\/ then use the filename instead:\n+                    out_begin(String.format(\"file \\\"%s.class\\\" {\", entityName));\n+                } else {\n+                    out_begin(format(\"%s %s {\", entityType, entityName));\n+                }\n+            } catch (Exception e) {\n+                entityName = fileName;\n+                out.println(\"\/\/ \" + e.getMessage() + \" while accessing entityName\");\n+                out_begin(format(\"%s %s { \/\/ source file name\", entityType, entityName));\n+            }\n+\n+            out_print(toHex(magic, 4) + \";\");\n+            if (magic != JAVA_MAGIC) {\n+                out.print(\" \/\/ wrong magic: 0x\" + Integer.toString(JAVA_MAGIC, 16) + \" expected\");\n+            }\n+            out.println();\n+            out_println(min_version + \"; \/\/ minor version\");\n+            out_println(version + \"; \/\/ version\");\n+\n+            \/\/ Print the constant pool\n+            printCP(out);\n+            out_println(toHex(access, 2) + \"; \/\/ access\" +\n+                    (printDetails ? \" [\" + (\" \" + Modifiers.accessString(access, CF_Context.CTX_CLASS).toUpperCase()).replaceAll(\" (\\\\S)\", \" ACC_$1\") + \"]\" : \"\"));\n+            out_println(\"#\" + this_cpx + \";\/\/ this_cpx\");\n+            int super_cpx = in.readUnsignedShort();\n+            out_println(\"#\" + super_cpx + \";\/\/ super_cpx\");\n+            traceln(i18n.getString(\"jdec.trace.access_thisCpx_superCpx\", access, this_cpx, super_cpx));\n+            out.println();\n+\n+            \/\/ Read the interfaces\n+            int numinterfaces = in.readUnsignedShort();\n+            traceln(i18n.getString(\"jdec.trace.numinterfaces\", numinterfaces));\n+            startArrayCmt(numinterfaces, \"Interfaces\");\n+            try {\n+                decodeTypes(in, out, numinterfaces);\n+            } finally {\n+                out_end(\"} \/\/ Interfaces\\n\");\n+            }\n+            \/\/ Read the fields\n+            decodeMembers(in, out, \"Fields\", \"field\");\n+\n+            \/\/ Read the methods\n+            decodeMembers(in, out, \"Methods\", \"method\");\n+\n+            \/\/ Read the attributes\n+            decodeAttrs(in, out);\n+        } catch (EOFException ignored) {\n+        } catch (ClassFormatError err) {\n+            String msg = err.getMessage();\n+            out.println(\"\/\/------- ClassFormatError\" +\n+                    (msg == null || msg.isEmpty() ? \"\" : \": \" + msg));\n+            printRestOfBytes();\n+        } finally {\n+            out_end(format(\"} \/\/ end %s %s\", entityType, entityName));\n+        }\n+    } \/\/ end decodeClass()\n+\n+    private void decodeTypes(DataInputStream in, PrintWriter out, int count) throws IOException {\n+        for (int i = 0; i < count; i++) {\n+            int type_cpx = in.readUnsignedShort();\n+            traceln(i18n.getString(\"jdec.trace.type\", i, type_cpx));\n+            out_print(\"#\" + type_cpx + \";\");\n+            if (printDetails) {\n+                String name = (String) cpool[(int)cpool[type_cpx]];\n+                out.println(\" \/\/ \" + name + getStringPos());\n+            } else {\n+                out.println();\n+            }\n+        }\n+    }\n+\n+    \/* ====================================================== *\/\n+    boolean DebugFlag = false;\n+\n+    public void trace(String s) {\n+        if (!DebugFlag) {\n+            return;\n+        }\n+        System.out.print(s);\n+    }\n+\n+    public void traceln(String s) {\n+        if (!DebugFlag) {\n+            return;\n+        }\n+        System.out.println(s);\n+    }\n+}\/\/ end class ClassData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdec\/ClassData.java","additions":1291,"deletions":0,"binary":false,"changes":1291,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdec;\n+\n+import org.openjdk.asmtools.common.Tool;\n+import org.openjdk.asmtools.jdis.uEscWriter;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+import org.openjdk.asmtools.util.ProductInfo;\n+\n+import java.io.DataInputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ * Main program of the Java DECoder :: class to jcod\n+ *\/\n+public class Main extends Tool {\n+\n+    int     printFlags = 0;\n+\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    public Main(PrintWriter out, PrintWriter err, String programName) {\n+        super(out, err, programName);\n+        printCannotReadMsg = (fname) ->\n+                error( i18n.getString(\"jdec.error.cannot_read\", fname));\n+    }\n+\n+    public Main(PrintStream out, String program) {\n+        this(new PrintWriter(out), new PrintWriter(System.err), program);\n+    }\n+\n+    @Override\n+    public void usage() {\n+        println(i18n.getString(\"jdec.usage\"));\n+        println(i18n.getString(\"jdec.opt.g\"));\n+        println(i18n.getString(\"jdec.opt.version\"));\n+    }\n+\n+    \/**\n+     * Run the decoder\n+     *\/\n+    public synchronized boolean decode(String argv[]) {\n+        long tm = System.currentTimeMillis();\n+        ArrayList<String> vargs = new ArrayList<>();\n+        ArrayList<String> vj = new ArrayList<>();\n+        boolean nowrite = false;\n+        int addOptions = 0;\n+\n+        \/\/ Parse arguments\n+        int i = 0;\n+        for (String arg : argv) {\n+            \/\/\n+            if (arg.equals(\"-g\")) {\n+                printFlags = printFlags | 1;\n+                vargs.add(arg);\n+            } else if (arg.equals(\"-v\")) {\n+                DebugFlag = () -> true;\n+                vargs.add(arg);\n+                out.println(\"arg[\" + i + \"]=\" + argv[i] + \"\/verbose\");\n+            } else if (arg.equals(\"-version\")) {\n+                out.println(ProductInfo.FULL_VERSION);\n+            } else if (arg.startsWith(\"-\")) {\n+                error(i18n.getString(\"jdec.error.invalid_flag\", arg));\n+                usage();\n+                return false;\n+            } else {\n+                vargs.add(arg);\n+                vj.add(arg);\n+            }\n+            i += 1;\n+        }\n+\n+        if (vj.isEmpty()) {\n+            usage();\n+            return false;\n+        }\n+\n+        String[] names = new String[0];\n+        names = vj.toArray(names);\n+        for (String inpname : names) {\n+            try {\n+                DataInputStream dataInputStream = getDataInputStream(inpname);\n+                if( dataInputStream == null )\n+                    return false;\n+                ClassData cc = new ClassData(dataInputStream, printFlags, out);\n+                cc.DebugFlag = DebugFlag.getAsBoolean();\n+                cc.decodeClass(inpname);\n+                out.flush();\n+                continue;\n+            } catch (Error ee) {\n+                if (DebugFlag.getAsBoolean())\n+                    ee.printStackTrace();\n+                error(i18n.getString(\"jdec.error.fatal_error\"));\n+            } catch (Exception ee) {\n+                if (DebugFlag.getAsBoolean())\n+                    ee.printStackTrace();\n+                error(i18n.getString(\"jdec.error.fatal_exception\"));\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Main program\n+     *\/\n+    public static void main(String argv[]) {\n+        Main decoder = new Main(new PrintWriter(new uEscWriter(System.out)), new PrintWriter(System.err), \"jdec\");\n+        System.exit(decoder.decode(argv) ? 0 : 1);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdec\/Main.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdec;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.Stack;\n+\n+\/**\n+ * this class provides functionality needed to read class files:\n+ * <ul>\n+ * <li>methods to read unsigned integers of various length\n+ * <li>counts bytes read so far\n+ * <\/ul>\n+ *\/\n+public class NestedByteArrayInputStream extends ByteArrayInputStream {\n+\n+    NestedByteArrayInputStream(byte buf[]) {\n+        super(buf);\n+    }\n+\n+    NestedByteArrayInputStream(byte buf[], int offset, int length) {\n+        super(buf, offset, length);\n+    }\n+\n+    public int getPos() {\n+        return pos;\n+    }\n+    Stack savedStates = new Stack();\n+\n+    public void enter(int range) {\n+        savedStates.push(count);\n+        if (pos + range < count) {\n+            count = pos + range;\n+        }\n+    }\n+\n+    public void leave() {\n+        pos = count;\n+        count = ((Integer) savedStates.pop()).intValue();\n+    }\n+} \/\/ end class NestedByteArrayInputStream\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdec\/NestedByteArrayInputStream.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+jdec.error.invalid_flag=invalid flag: \" {0}\n+jdec.error.fatal_error=fatal error\n+jdec.error.fatal_exception=fatal exception\n+jdec.error.cannot_read=cannot read {0}\n+jdec.usage=\\\n+Usage: java -jar asmtools.jar jdec [options] FILE.class... > FILE.jcod\\n\\\n+where possible options include:\n+\n+jdec.opt.g=\\\n+\\     -g:  detailed output format\n+jdec.opt.version=\\\n+\\     -version:  print version number and date\n+\n+\n+jdec.trace.CP_len=CP len= {0}\n+jdec.trace.CP_entry=CP entry # {0} tag= {1}\n+jdec.trace.access_thisCpx_superCpx=access={0} this_cpx={1} super_cpx={2}\n+jdec.trace.numinterfaces=numinterfaces={0}\n+jdec.trace.type=\\\n+\\  type_cpx[{0}]={1}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdec\/i18n.properties","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+import static java.lang.String.format;\n+\n+\/**\n+ *\n+ *\/\n+public class  AnnotationData {\n+    \/*-------------------------------------------------------- *\/\n+    \/* AnnotData Fields *\/\n+\n+    protected String visAnnotToken = \"@+\";\n+    protected String invAnnotToken = \"@-\";\n+    protected String dataName = \"AnnotationData\";\n+    private boolean invisible = false;\n+    private int type_cpx = 0;  \/\/an index into the constant pool indicating the annotation type for this annotation.\n+    private ArrayList<AnnotationElement> array = new ArrayList<>();\n+    private ClassData cls;\n+    \/*-------------------------------------------------------- *\/\n+\n+    public AnnotationData(boolean invisible, ClassData cls) {\n+        this.cls = cls;\n+        this.invisible = invisible;\n+    }\n+\n+    public void read(DataInputStream in) throws IOException {\n+        type_cpx = in.readShort();\n+        int elemValueLength = in.readShort();\n+        TraceUtils.traceln(3, format(\" %s: name[%d]=%s\", dataName, type_cpx, cls.pool.getString(type_cpx)),\n+                format(\" %s: %s  num_elems: %d\", dataName, cls.pool.getString(type_cpx), elemValueLength));\n+        for (int evc = 0; evc < elemValueLength; evc++) {\n+            AnnotationElement elem = new AnnotationElement(cls);\n+            TraceUtils.traceln(3, format(\" %s: %s reading [%d]\", dataName, cls.pool.getString(type_cpx), evc));\n+            elem.read(in, invisible);\n+            array.add(elem);\n+        }\n+    }\n+\n+    public void print(PrintWriter out, String tab) {\n+        printHeader(out, tab);\n+        printBody(out, \"\");\n+    }\n+\n+    protected void printHeader(PrintWriter out, String tab) {\n+        \/\/Print annotation Header, which consists of the\n+        \/\/ Annotation Token ('@'), visibility ('+', '-'),\n+        \/\/ and the annotation name (type index, CPX).\n+\n+        \/\/ Mark whether it is invisible or not.\n+        if (invisible) {\n+            out.print(tab + invAnnotToken);\n+        } else {\n+            out.print(tab + visAnnotToken);\n+        }\n+        String annoName = cls.pool.getString(type_cpx);\n+\n+        \/\/ converts class type to java class name\n+        if (annoName.startsWith(\"L\") && annoName.endsWith(\";\")) {\n+            annoName = annoName.substring(1, annoName.length() - 1);\n+        }\n+\n+        out.print(annoName);\n+    }\n+\n+    protected void printBody(PrintWriter out, String tab) {\n+        \/\/ For a standard annotation, print out brackets,\n+        \/\/ and list the name\/value pairs.\n+        out.print(\" { \");\n+        int i = 0;\n+        for (AnnotationElement elem : array) {\n+            elem.print(out, tab);\n+            if (i++ < array.size() - 1) {\n+                out.print(\", \");\n+            }\n+        }\n+        out.print(\"  }\");\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        String annoName = cls.pool.getString(type_cpx);\n+\n+        \/\/ converts class type to java class name\n+        if (annoName.startsWith(\"L\") && annoName.endsWith(\";\")) {\n+            annoName = annoName.substring(1, annoName.length() - 1);\n+        }\n+\n+        \/\/Print annotation\n+        \/\/ Mark whether it is invisible or not.\n+        if (invisible) {\n+            sb.append(invAnnotToken);\n+        } else {\n+            sb.append(visAnnotToken);\n+        }\n+\n+        sb.append(annoName);\n+        sb.append(\" { \");\n+\n+        int i = 0;\n+        for (AnnotationElement elem : array) {\n+            sb.append(elem.toString());\n+\n+            if (i++ < array.size() - 1) {\n+                sb.append(\", \");\n+            }\n+        }\n+\n+        _toString(sb);\n+\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    protected void _toString(StringBuilder sb) {\n+        \/\/ sub-classes override this\n+    }\n+}\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/AnnotationData.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,390 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ * Base class of all AnnotationElement entries\n+ *\/\n+public class AnnotationElement {\n+\n+    \/**\n+     *\n+     * CPX_AnnotElem\n+     *\n+     * base class for an annotation value.\n+     *\n+     *\/\n+    public static class AnnotValue {\n+\n+        \/**\n+         * tag the descriptor for the constant\n+         *\/\n+        public AnnotElemType tag;\n+\n+        \/\/ internal references\n+        protected ClassData cls;\n+\n+        public AnnotValue(AnnotElemType tagval, ClassData cls) {\n+            tag = tagval;\n+            this.cls = cls;\n+        }\n+\n+        public String stringVal() {\n+            return \"\";\n+        }\n+\n+        public void print(PrintWriter out, String tab) {\n+            out.print(tag.val() + \"  \");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<AnnotValue \" + tag.printval() + \" \" + stringVal() + \">\";\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CPX_AnnotElem\n+     *\n+     * Annotation value which is described by a single CPX entry (ie. String, byte, char,\n+     * int, short, boolean, float, long, double, class reference).\n+     *\n+     *\/\n+    public static class CPX_AnnotValue extends AnnotValue {\n+\n+        \/**\n+         * tag the descriptor for the constant\n+         *\/\n+        public int cpx;\n+\n+        public CPX_AnnotValue(AnnotElemType tag, ClassData cls, int cpx) {\n+            super(tag, cls);\n+            this.cpx = cpx;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            StringBuilder sb = new StringBuilder();\n+            switch (tag) {\n+                case AE_STRING:    \/\/ String\n+                    sb.append('\"' + cls.pool.getString(cpx) + '\"');\n+                    break;\n+                case AE_BYTE:    \/\/ Byte\n+                    sb.append(\"byte \" + cls.pool.getConst(cpx).stringVal());\n+                    break;\n+                case AE_CHAR:    \/\/ Char\n+                    sb.append(\"char \" + cls.pool.getConst(cpx).stringVal());\n+                    break;\n+                case AE_INT:    \/\/ Int  (no need to add keyword)\n+                    sb.append(cls.pool.getConst(cpx).stringVal());\n+                    break;\n+                case AE_SHORT:    \/\/ Short\n+                    sb.append(\"short \" + cls.pool.getConst(cpx).stringVal());\n+                    break;\n+                case AE_BOOLEAN:    \/\/ Boolean\n+                    ConstantPool.CP_Int cns = (ConstantPool.CP_Int) cls.pool.getConst(cpx);\n+                    sb.append(\"boolean \" + (cns.value == 0 ? \"false\" : \"true\"));\n+                    break;\n+                case AE_FLOAT:    \/\/ Float\n+                    sb.append(cls.pool.getConst(cpx).stringVal()); \/\/ + \"f\");\n+                    break;\n+                case AE_DOUBLE:    \/\/ Double\n+                    sb.append(cls.pool.getConst(cpx).stringVal()); \/\/ + \"d\");\n+                    break;\n+                case AE_LONG:    \/\/ Long\n+                    sb.append(cls.pool.getConst(cpx).stringVal()); \/\/ + \"l\");\n+                    break;\n+                case AE_CLASS:    \/\/ Class\n+                    sb.append(\"class \" + cls.pool.decodeClassDescriptor(cpx));\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out, String tab) {\n+            out.print(tab + stringVal());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<CPX_AnnotValue tag: '\" + tag + \"' stringVal=\" + this.stringVal() + \">\";\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CPX_AnnotElem\n+     *\n+     * AnnotElements that contain 2 cpx indices (ie. enums).\n+     *\n+     *\/\n+    public static class CPX2_AnnotValue extends AnnotValue {\n+\n+        \/**\n+         * tag the descriptor for the constant\n+         *\/\n+        public int cpx1;\n+        public int cpx2;\n+\n+        public CPX2_AnnotValue(AnnotElemType tag, ClassData cls, int cpx1, int cpx2) {\n+            super(tag, cls);\n+            this.cpx1 = cpx1;\n+            this.cpx2 = cpx2;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            StringBuilder sb = new StringBuilder();\n+            switch (tag) {\n+\n+                case AE_ENUM:    \/\/ Enum\n+                    \/\/ print the enum type and constant name\n+                    sb.append(\"enum \" + cls.pool.decodeClassDescriptor(cpx1)\n+                            + \" \" + cls.pool.getName(cpx2));\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out, String tab) {\n+            out.print(tab + stringVal());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<CPX2_AnnotValue tag: '\" + tag + \"' stringVal=\" + this.stringVal() + \">\";\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * Array_AnnotElem\n+     *\n+     * Annotation value that is an array of annotation elements.\n+     *\n+     *\/\n+    public static class Array_AnnotValue extends AnnotValue {\n+\n+        \/**\n+         * tag the descriptor for the constant\n+         *\/\n+        public ArrayList<AnnotValue> array = new ArrayList<>();\n+\n+        public Array_AnnotValue(AnnotElemType tagval, ClassData cls) {\n+            super(tagval, cls);\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(super.stringVal() + \" = \");\n+            sb.append(\"{\");\n+            int i = 0;\n+            int cnt = array.size();\n+            for (AnnotValue arrayelem : array) {\n+                sb.append(arrayelem.toString());\n+                if (i < cnt - 1) {\n+                    sb.append(\",\");\n+                }\n+            }\n+            sb.append(\"}\");\n+            return sb.toString();\n+        }\n+\n+        public void add(AnnotValue elem) {\n+            array.add(elem);\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out, String tab) {\n+            out.println(\"{\");\n+            int i = 0;\n+            int cnt = array.size();\n+            for (AnnotValue arrayelem : array) {\n+                arrayelem.print(out, tab + \"  \");\n+                if (i < cnt - 1) {\n+                    out.println(\",\");\n+                }\n+                i += 1;\n+            }\n+            out.println(\"}\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<Array_AnnotValue \" + tag + \" \" + stringVal() + \">\";\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * Annot_AnnotValue\n+     *\n+     * Annotation value that is a reference to an annotation.\n+     *\n+     *\/\n+    public static class Annot_AnnotValue extends AnnotValue {\n+\n+        \/**\n+         * tag the descriptor for the constant\n+         *\/\n+        AnnotationData annot;\n+\n+        public Annot_AnnotValue(AnnotElemType tagval, ClassData cls, AnnotationData annot) {\n+            super(tagval, cls);\n+            this.annot = annot;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            return annot.toString();\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out, String tab) {\n+\/\/            out.print(tag + \"\\t\");\n+            annot.print(out, tab);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<Annot_AnnotValue \" + tag + \" \" + stringVal() + \">\";\n+        }\n+    }\n+\n+    \/*========================================================*\/\n+    \/* Factory Method *\/\n+    \/**\n+     *\n+     * read\n+     *\n+     * Static factory - creates Annotation Elements.\n+     *\n+     *\/\n+    public static AnnotValue readValue(DataInputStream in, ClassData cls, boolean invisible) throws IOException {\n+        AnnotValue val = null;\n+        char tg = (char) in.readByte();\n+        AnnotElemType tag = annotElemType(tg);\n+\n+        switch (tag) {\n+            case AE_STRING:     \/\/ String\n+            case AE_BYTE:       \/\/ Byte\n+            case AE_CHAR:       \/\/ Char\n+            case AE_INT:        \/\/ Int  (no need to add keyword)\n+            case AE_SHORT:      \/\/ Short\n+            case AE_BOOLEAN:    \/\/ Boolean\n+            case AE_FLOAT:      \/\/ Float\n+            case AE_DOUBLE:     \/\/ Double\n+            case AE_LONG:       \/\/ Long\n+            case AE_CLASS:      \/\/ Class\n+                \/\/ CPX based Annotation\n+                int CPX = in.readShort();\n+                val = new CPX_AnnotValue(tag, cls, CPX);\n+                break;\n+            case AE_ENUM:    \/\/ Enum\n+                \/\/ CPX2 based Annotation\n+                int CPX1 = in.readShort();\n+                int CPX2 = in.readShort();\n+                val = new CPX2_AnnotValue(tag, cls, CPX1, CPX2);\n+                break;\n+            case AE_ANNOTATION:    \/\/ Annotation\n+                AnnotationData ad = new AnnotationData(invisible, cls);\n+                ad.read(in);\n+                val = new Annot_AnnotValue(tag, cls, ad);\n+                break;\n+            case AE_ARRAY:    \/\/ Array\n+                Array_AnnotValue aelem = new Array_AnnotValue(tag, cls);\n+                val = aelem;\n+                int cnt = in.readShort();\n+                for (int i = 0; i < cnt; i++) {\n+                    aelem.add(readValue(in, cls, invisible));\n+                }\n+                break;\n+            default:\n+                throw new IOException(\"Unknown tag in annotation '\" + tg + \"' [\" + Integer.toHexString(tg) + \"]\");\n+        }\n+\n+        return val;\n+    }\n+\n+    \/*========================================================*\/\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* AnnotElem Fields *\/\n+    \/**\n+     * constant pool index for the name of the Annotation Element\n+     *\/\n+    public int name_cpx;\n+\n+    public AnnotValue value = null;\n+\n+    \/\/ internal references\n+    protected ClassData cls;\n+    \/*-------------------------------------------------------- *\/\n+\n+    public AnnotationElement(ClassData cls) {\n+        this.cls = cls;\n+    }\n+\n+    \/**\n+     *\n+     * read\n+     *\n+     * read and resolve the method data called from ClassData. precondition: NumFields has\n+     * already been read from the stream.\n+     *\n+     *\/\n+    public void read(DataInputStream in, boolean invisible) throws IOException {\n+        name_cpx = in.readShort();\n+        value = readValue(in, cls, invisible);\n+        TraceUtils.traceln(format(\"                   AnnotElem: name[%d]=%s value=%s\", name_cpx, cls.pool.getString(name_cpx), value.toString()));\n+    }\n+\n+    public String stringVal() {\n+        return cls.pool.getName(name_cpx);\n+    }\n+\n+    public void print(PrintWriter out, String tab) {\n+        out.print(stringVal() + \" = \");\n+        value.print(out, \"\");\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"<AnnotElem \" + stringVal() + \" = \" + value.toString() + \">\";\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/AnnotationElement.java","additions":390,"deletions":0,"binary":false,"changes":390,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.Tables;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+import static java.lang.String.format;\n+\n+\/**\n+ *\n+ *\/\n+public class AttrData {\n+\n+    int name_cpx;\n+    byte data[];\n+    ClassData cls;\n+    public AttrData(ClassData cls) {\n+        this.cls = cls;\n+    }\n+\n+    \/**\n+     * attributeTag\n+     * <p>\n+     * returns either -1 (not found), or the hashed integer tag tag.\n+     *\/\n+    public static int attributeTag(String tagname) {\n+        int intgr = Tables.attrtagValue(tagname);\n+\n+        if (intgr == 0) {\n+            return -1;\n+        }\n+\n+        return intgr;\n+    }\n+\n+    public void read(int name_cpx, int attrlen, DataInputStream in) throws IOException {\n+        this.name_cpx = name_cpx;\n+        data = new byte[attrlen];\n+        TraceUtils.traceln(format(\"AttrData:#%d len=%d\", name_cpx, attrlen));\n+        in.readFully(data);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/AttrData.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.JasmTokens;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ *\n+ *\/\n+public class BootstrapMethodData extends Indenter {\n+\n+    int bsm_index;\n+    ArrayList<Integer> bsm_args_indexes;\n+\n+    \/\/ internal references\n+    private Options options = Options.OptionObject();\n+    private ClassData cls;\n+    private PrintWriter out;\n+\n+    public BootstrapMethodData(ClassData cls) {\n+        this.cls = cls;\n+        out = cls.out;\n+    }\n+\n+\n+    \/*========================================================*\/\n+    \/* Read Methods *\/\n+\n+    \/**\n+     *\n+     * read\n+     *\n+     * read and resolve the bootstrap method data called from ClassData. precondition:\n+     * NumFields has already been read from the stream.\n+     *\n+     *\/\n+    public void read(DataInputStream in) throws IOException {\n+        \/\/ read the Methods CP indexes\n+        bsm_index = in.readUnsignedShort();\n+        int arg_num = in.readUnsignedShort();\n+        bsm_args_indexes = new ArrayList<>(arg_num);\n+        for (int i = 0; i < arg_num; i++) {\n+            bsm_args_indexes.add(in.readUnsignedShort());\n+        }\n+    }\n+\n+\n+    \/*========================================================*\/\n+    \/* Print Methods *\/\n+    public void print() throws IOException {\n+        out.print(getIndentString() + JasmTokens.Token.BOOTSTRAPMETHOD.parseKey() + \" #\" + bsm_index);\n+        for (int i = 0; i < bsm_args_indexes.size(); i++) {\n+            out.print(\" #\" + bsm_args_indexes.get(i));\n+        }\n+        out.println(\";\");\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/BootstrapMethodData.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * Base class of the \"classes[]\" data of attributes\n+ * <p>\n+ * JEP 181 (Nest-based Access Control): class file 55.0\n+ * NestMembers_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ * <p>\n+ * JEP 360 (Sealed types): class file 59.65535\n+ * PermittedSubclasses_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ * <\/p>\n+ *\/\n+public class ClassArrayData extends Indenter {\n+    String name;\n+    ClassData cls;\n+    int[] classes;\n+    private Options options = Options.OptionObject();\n+\n+    protected ClassArrayData(ClassData cls, String attrName) {\n+        this.cls = cls;\n+        this.name = attrName;\n+    }\n+\n+    public ClassArrayData read(DataInputStream in, int attribute_length) throws IOException, ClassFormatError {\n+        int number_of_classes = in.readUnsignedShort();\n+        if (attribute_length != 2 + number_of_classes * 2) {\n+            throw new ClassFormatError(name + \"_attribute: Invalid attribute length\");\n+        }\n+        classes = new int[number_of_classes];\n+        for (int i = 0; i < number_of_classes; i++) {\n+            classes[i] = in.readUnsignedShort();\n+        }\n+        return this;\n+    }\n+\n+    public void print() {\n+        String indexes = \"\";\n+        String names = \"\";\n+        boolean pr_cpx = options.contains(Options.PR.CPX);\n+        cls.out.print(getIndentString() + name + \" \");\n+        for (int i = 0; i < classes.length; i++) {\n+            if (pr_cpx) {\n+                indexes += (indexes.isEmpty() ? \"\" : \", \") + \"#\" + classes[i];\n+            }\n+            names += (names.isEmpty() ? \"\" : \", \") + cls.pool.StringValue(classes[i]);\n+        }\n+        if (pr_cpx) {\n+            cls.out.print(indexes + \"; \/\/ \");\n+        }\n+        cls.out.print(names);\n+        if (pr_cpx) {\n+            cls.out.println();\n+        } else {\n+            cls.out.println(\";\");\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/ClassArrayData.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,529 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.asmutils.HexUtils;\n+import org.openjdk.asmtools.common.Tool;\n+import org.openjdk.asmtools.jasm.Modifiers;\n+\n+import java.io.*;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jasm.RuntimeConstants.*;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+\n+\/**\n+ * Central class data for of the Java Disassembler\n+ *\/\n+public class ClassData extends MemberData {\n+\n+    \/\/ Owner of this ClassData\n+    protected Tool tool;\n+\n+    \/\/ -----------------------------\n+    \/\/ Header Info\n+    \/\/ -----------------------------\n+    \/\/ Version info\n+    protected int minor_version, major_version;\n+\n+    \/\/ Constant Pool index to this class\n+    protected int this_cpx;\n+\n+    \/\/ Constant Pool index to this classes parent (super)\n+    protected int super_cpx;\n+\n+    \/\/ Constant Pool index to a file reference to the Java source\n+    protected int source_cpx = 0;\n+\n+    \/\/ -----------------------------\n+    \/\/ The Constant Pool\n+    \/\/ -----------------------------\n+    protected ConstantPool pool;\n+\n+    \/\/ -----------------------------\n+    \/\/ Interfaces,Fields,Methods && Attributes\n+    \/\/ -----------------------------\n+    \/\/ The interfaces this class implements\n+    protected int[] interfaces;\n+\n+    \/\/ The fields of this class\n+    protected ArrayList<FieldData> fields;\n+\n+    \/\/ The methods of this class\n+    protected ArrayList<MethodData> methods;\n+\n+    \/\/ The record attribute of this class (since class file 58.65535)\n+    protected RecordData record;\n+\n+    \/\/ The inner-classes of this class\n+    protected ArrayList<InnerClassData> innerClasses;\n+\n+    \/\/ The bootstrapmethods this class implements\n+    protected ArrayList<BootstrapMethodData> bootstrapMethods;\n+\n+    \/\/The module this class file presents\n+    protected ModuleData moduleData;\n+\n+    \/\/ The NestHost of this class (since class file: 55.0)\n+    protected NestHostData nestHost;\n+\n+    \/\/ The NestMembers of this class (since class file: 55.0)\n+    protected NestMembersData nestMembers;\n+\n+    \/\/ The PermittedSubclasses of this class (JEP 360 (Sealed types): class file 59.65535)\n+    protected PermittedSubclassesData permittedSubclassesData;\n+\n+    \/\/ other parsing fields\n+    protected PrintWriter out;\n+    protected String pkgPrefix = \"\";\n+    \/\/ source file data\n+    private TextLines sourceLines = null;\n+    private Path classFile = null;\n+\n+    public ClassData(PrintWriter out, Tool tool) {\n+        this.out  = out;\n+        this.tool = tool;\n+        memberType = \"ClassData\";\n+        TraceUtils.traceln(\"printOptions=\" + options.toString());\n+        pool = new ConstantPool(this);\n+        init(this);\n+    }\n+\n+    public void read(File in) throws IOException {\n+        try ( DataInputStream dis = new DataInputStream(new FileInputStream(in))){\n+            read(dis);\n+        }\n+        classFile = in.toPath();\n+    }\n+\n+    public void read(String in) throws IOException {\n+        try ( DataInputStream dis = new DataInputStream(new FileInputStream(in))){\n+            read(dis);\n+        }\n+        classFile = Paths.get(in);\n+    }\n+\n+    \/**\n+     * Read and resolve the field data\n+     *\/\n+    protected void readFields(DataInputStream in) throws IOException {\n+        int nfields = in.readUnsignedShort();\n+        TraceUtils.traceln(\"nfields=\" + nfields);\n+        fields = new ArrayList<>(nfields);\n+        for (int k = 0; k < nfields; k++) {\n+            FieldData field = new FieldData(this);\n+            TraceUtils.traceln(\"  FieldData: #\" + k);\n+            field.read(in);\n+            fields.add(field);\n+        }\n+    }\n+\n+    \/**\n+     * Read and resolve the method data\n+     *\/\n+    protected void readMethods(DataInputStream in) throws IOException {\n+        int nmethods = in.readUnsignedShort();\n+        TraceUtils.traceln(\"nmethods=\" + nmethods);\n+        methods = new ArrayList<>(nmethods);\n+        for (int k = 0; k < nmethods; k++) {\n+            MethodData method = new MethodData(this);\n+            TraceUtils.traceln(\"  MethodData: #\" + k);\n+            method.read(in);\n+            methods.add(method);\n+        }\n+    }\n+\n+    \/**\n+     * Read and resolve the interface data\n+     *\/\n+    protected void readInterfaces(DataInputStream in) throws IOException {\n+        \/\/ Read the interface names\n+        int numinterfaces = in.readUnsignedShort();\n+        TraceUtils.traceln(\"numinterfaces=\" + numinterfaces);\n+        interfaces = new int[numinterfaces];\n+        for (int i = 0; i < numinterfaces; i++) {\n+            int intrf_cpx = in.readShort();\n+            TraceUtils.traceln(\"  intrf_cpx[\" + i + \"]=\" + intrf_cpx);\n+            interfaces[i] = intrf_cpx;\n+        }\n+    }\n+\n+    \/**\n+     * Read and resolve the attribute data\n+     *\/\n+    @Override\n+    protected boolean handleAttributes(DataInputStream in, AttrTag attrtag, int attrlen) throws IOException {\n+        \/\/ Read the Attributes\n+        boolean handled = true;\n+        switch (attrtag) {\n+            case ATT_SourceFile:\n+                \/\/ Read SourceFile Attr\n+                if (attrlen != 2) {\n+                    throw new ClassFormatError(\"ATT_SourceFile: Invalid attribute length\");\n+                }\n+                source_cpx = in.readUnsignedShort();\n+                break;\n+            case ATT_InnerClasses:\n+                \/\/ Read InnerClasses Attr\n+                int num1 = in.readUnsignedShort();\n+                if (2 + num1 * 8 != attrlen) {\n+                    throw new ClassFormatError(\"ATT_InnerClasses: Invalid attribute length\");\n+                }\n+                innerClasses = new ArrayList<>(num1);\n+                for (int j = 0; j < num1; j++) {\n+                    InnerClassData innerClass = new InnerClassData(this);\n+                    innerClass.read(in);\n+                    innerClasses.add(innerClass);\n+                }\n+                break;\n+            case ATT_BootstrapMethods:\n+                \/\/ Read BootstrapMethods Attr\n+                int num2 = in.readUnsignedShort();\n+                bootstrapMethods = new ArrayList<>(num2);\n+                for (int j = 0; j < num2; j++) {\n+                    BootstrapMethodData bsmData = new BootstrapMethodData(this);\n+                    bsmData.read(in);\n+                    bootstrapMethods.add(bsmData);\n+                }\n+                break;\n+            case ATT_Module:\n+                \/\/ Read Module Attribute\n+                moduleData = new ModuleData(this);\n+                moduleData.read(in);\n+                break;\n+            case ATT_NestHost:\n+                \/\/ Read NestHost Attribute (since class file: 55.0)\n+                nestHost = new NestHostData(this).read(in, attrlen);\n+                break;\n+            case ATT_NestMembers:\n+                \/\/ Read NestMembers Attribute (since class file: 55.0)\n+                nestMembers = new NestMembersData(this).read(in, attrlen);\n+                break;\n+            case ATT_Record:\n+                record = new RecordData(this).read(in);\n+                break;\n+            case ATT_PermittedSubclasses:\n+                \/\/ Read PermittedSubclasses Attribute (JEP 360 (Sealed types): class file 59.65535)\n+                permittedSubclassesData = new PermittedSubclassesData(this).read(in, attrlen);\n+                break;\n+            default:\n+                handled = false;\n+                break;\n+        }\n+        return handled;\n+    }\n+\n+    \/**\n+     * Read and resolve the class data\n+     *\/\n+    private void read(DataInputStream in) throws IOException {\n+        \/\/ Read the header\n+        int magic = in.readInt();\n+        if (magic != JAVA_MAGIC) {\n+            throw new ClassFormatError(\"wrong magic: \" + HexUtils.toHex(magic) + \", expected \" + HexUtils.toHex(JAVA_MAGIC));\n+        }\n+        minor_version = in.readUnsignedShort();\n+        major_version = in.readUnsignedShort();\n+\n+        \/\/ Read the constant pool\n+        pool.read(in);\n+        access = in.readUnsignedShort(); \/\/ & MM_CLASS; \/\/ Q\n+        this_cpx = in.readUnsignedShort();\n+        super_cpx = in.readUnsignedShort();\n+        TraceUtils.traceln(\"access=\" + access + \" \" + Modifiers.accessString(access, CF_Context.CTX_INNERCLASS) +\n+                \" this_cpx=\" + this_cpx +\n+                \" super_cpx=\" + super_cpx);\n+\n+        \/\/ Read the interfaces\n+        readInterfaces(in);\n+\n+        \/\/ Read the fields\n+        readFields(in);\n+\n+        \/\/ Read the methods\n+        readMethods(in);\n+\n+        \/\/ Read the attributes\n+        readAttributes(in);\n+        \/\/\n+        TraceUtils.traceln(\"\", \"<< Reading is done >>\", \"\");\n+    }\n+\n+    \/**\n+     * Read and resolve the attribute data\n+     *\/\n+    public String getSrcLine(int lnum) {\n+        if (sourceLines == null) {\n+            return null;  \/\/ impossible call\n+        }\n+        String line;\n+        try {\n+            line = sourceLines.getLine(lnum);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            line = \"Line number \" + lnum + \" is out of bounds\";\n+        }\n+        return line;\n+    }\n+\n+    private <T extends AnnotationData> void printAnnotations(List<T> annotations) {\n+        if (annotations != null) {\n+            for (T ad : annotations) {\n+                ad.print(out, \"\");\n+                out.println();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void print() throws IOException {\n+        int k, l;\n+        String className = \"\";\n+        String sourceName = null;\n+        if( isModuleUnit() ) {\n+            \/\/ Print the Annotations\n+            printAnnotations(visibleAnnotations);\n+            printAnnotations(invisibleAnnotations);\n+        } else {\n+            className = pool.getClassName(this_cpx);\n+            int pkgPrefixLen = className.lastIndexOf(\"\/\") + 1;\n+            \/\/ Write the header\n+            \/\/ package-info compilation unit\n+            if (className.endsWith(\"package-info\")) {\n+                \/\/ Print the Annotations\n+                printAnnotations(visibleAnnotations);\n+                printAnnotations(invisibleAnnotations);\n+                printAnnotations(visibleTypeAnnotations);\n+                printAnnotations(invisibleTypeAnnotations);\n+                if (pkgPrefixLen != 0) {\n+                    pkgPrefix = className.substring(0, pkgPrefixLen);\n+                    out.print(\"package  \" + pkgPrefix.substring(0, pkgPrefixLen - 1) + \" \");\n+                    out.print(\"version \" + major_version + \":\" + minor_version + \";\");\n+                }\n+                out.println();\n+                return;\n+            }\n+            if (pkgPrefixLen != 0) {\n+                pkgPrefix = className.substring(0, pkgPrefixLen);\n+                out.println(\"package  \" + pkgPrefix.substring(0, pkgPrefixLen - 1) + \";\");\n+                className = pool.getShortClassName(this_cpx, pkgPrefix);\n+            }\n+            out.println();\n+            \/\/ Print the Annotations\n+            printAnnotations(visibleAnnotations);\n+            printAnnotations(invisibleAnnotations);\n+            printAnnotations(visibleTypeAnnotations);\n+            printAnnotations(invisibleTypeAnnotations);\n+            if ((access & ACC_SUPER) != 0) {\n+                out.print(\"super \");\n+                access = access & ~ACC_SUPER;\n+            }\n+        }\n+\/\/ see if we are going to print: abstract interface class\n+\/\/ then replace it with just: interface\n+printHeader:\n+        {\n+printSugar:\n+            {\n+                if ((access & ACC_ABSTRACT) == 0) {\n+                    break printSugar;\n+                }\n+                if ((access & ACC_INTERFACE) == 0) {\n+                    break printSugar;\n+                }\n+                if (options.contains(Options.PR.CPX)) {\n+                    break printSugar;\n+                }\n+                if (this_cpx == 0) {\n+                    break printSugar;\n+                }\n+\n+                \/\/ make sure the this_class is a valid class ref\n+                ConstantPool.Constant this_const = pool.getConst(this_cpx);\n+                if (this_const == null || this_const.tag != ConstantPool.TAG.CONSTANT_CLASS) {\n+                    break printSugar;\n+                }\n+\n+                \/\/ all conditions met, print syntactic sugar:\n+                out.print(Modifiers.accessString(access & ~ACC_ABSTRACT, CF_Context.CTX_CLASS));\n+                if (isSynthetic) {\n+                    out.print(\"synthetic \");\n+                }\n+                if (isDeprecated) {\n+                    out.print(\"deprecated \");\n+                }\n+                out.print(\" \" + pool.getShortClassName(this_cpx, pkgPrefix));\n+                break printHeader;\n+            }\n+\n+            if(isModuleUnit()) {\n+                out.print(moduleData.getModuleHeader());\n+            } else {\n+                \/\/ not all conditions met, print header in ordinary way:\n+                out.print(Modifiers.accessString(access, CF_Context.CTX_CLASS));\n+                if (isSynthetic) {\n+                    out.print(\"synthetic \");\n+                }\n+                if (isDeprecated) {\n+                    out.print(\"deprecated \");\n+                }\n+                if (options.contains(Options.PR.CPX)) {\n+                    out.print(\"\\t#\" + this_cpx + \" \/\/\");\n+                }\n+                pool.PrintConstant(out, this_cpx);\n+            }\n+        }\n+        out.println();\n+        if(!isModuleUnit()) {\n+            if (!pool.getClassName(super_cpx).equals(\"java\/lang\/Object\")) {\n+                out.print(\"\\textends \");\n+                pool.printlnClassId(out, super_cpx);\n+                out.println();\n+            }\n+        }\n+        l = interfaces.length;\n+\n+        if (l > 0) {\n+            for (k = 0; k < l; k++) {\n+                if (k == 0) {\n+                    out.print(\"\\timplements \");\n+                } else {\n+                    out.print(\"\\t\\t \");\n+                }\n+                boolean printComma = (l > 1 && k < (l - 1));\n+                pool.printlnClassId(out, interfaces[k], printComma);\n+                out.println();\n+            }\n+        }\n+        out.println(\"\\tversion \" + major_version + \":\" + minor_version);\n+        out.println(\"{\");\n+\n+        if ((options.contains(Options.PR.SRC)) && (source_cpx != 0)) {\n+            sourceName = pool.getString(source_cpx);\n+            if (sourceName != null) {\n+                sourceLines = new TextLines(classFile.getParent(), sourceName);\n+            }\n+        }\n+\n+        \/\/ Print the constant pool\n+        if (options.contains(Options.PR.CP)) {\n+            pool.print(out);\n+        }\n+        \/\/ Don't print fields, methods, inner classes and bootstrap methods if it is module-info entity\n+        if ( !isModuleUnit() ) {\n+\n+            \/\/ Print the fields\n+            printMemberDataList(fields);\n+\n+            \/\/ Print the methods\n+            printMemberDataList(methods);\n+\n+            \/\/ Print the Record (since class file 58.65535 JEP 359)\n+            if( record != null ) {\n+                record.print();\n+            }\n+\n+            \/\/ Print PermittedSubclasses Attribute (JEP 360 (Sealed types): class file 59.65535)\n+            if( permittedSubclassesData != null) {\n+                permittedSubclassesData.print();\n+            }\n+            \/\/ Print the NestHost (since class file: 55.0)\n+            if(nestHost != null) {\n+                nestHost.print();\n+            }\n+            \/\/ Print the NestMembers (since class file: 55.0)\n+            if( nestMembers  != null) {\n+                nestMembers.print();\n+            }\n+            \/\/ Print the inner classes\n+            if (innerClasses != null && !innerClasses.isEmpty()) {\n+                for (InnerClassData icd : innerClasses) {\n+                    icd.print();\n+                }\n+                out.println();\n+            }\n+            \/\/ Print the BootstrapMethods\n+            \/\/\n+            \/\/ Only print these if printing extended constants\n+            if ((options.contains(Options.PR.CPX)) && bootstrapMethods != null && !bootstrapMethods.isEmpty()) {\n+                for (BootstrapMethodData bsmdd : bootstrapMethods) {\n+                    bsmdd.print();\n+                }\n+                out.println();\n+            }\n+            out.println(format(\"} \/\/ end Class %s%s\",\n+                    className,\n+                    sourceName != null ? \" compiled from \\\"\" + sourceName +\"\\\"\" : \"\"));\n+        } else {\n+            \/\/ Print module attributes\n+            moduleData.print();\n+            out.print(\"} \/\/ end Module \");\n+            out.print( moduleData.getModuleName());\n+            if(moduleData.getModuleVersion() != null)\n+                out.print(\" @\" + moduleData.getModuleVersion());\n+            out.println();\n+        }\n+\n+        List<IOException> issues = getIssues();\n+        if( !issues.isEmpty() ) {\n+\n+            throw issues.get(0);\n+        }\n+    } \/\/ end ClassData.print()\n+\n+    \/\/ Gets the type of processed binary\n+    private boolean isModuleUnit() {\n+        return moduleData != null;\n+    }\n+\n+    private void printMemberDataList( List<? extends MemberData> list) throws IOException {\n+        if( list != null ) {\n+            int count = list.size();\n+            if( count > 0 ) {\n+                for( int i=0; i < count; i++ ) {\n+                    MemberData md = list.get(i);\n+                    md.setIndent(Options.BODY_INDENT);\n+                    if( i !=0 && md.getAnnotationsCount() > 0 )\n+                        out.println();\n+                    md.print();\n+                }\n+                out.println();\n+            }\n+        }\n+    }\n+\n+    private List<IOException> getIssues() {\n+        return this.pool.pool.stream().\n+                filter(Objects::nonNull).\n+                filter(c->c.getIssue() != null).\n+                map(ConstantPool.Constant::getIssue).\n+                collect(Collectors.toList());\n+    }\n+\n+}\/\/ end class ClassData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/ClassData.java","additions":529,"deletions":0,"binary":false,"changes":529,"status":"added"},{"patch":"@@ -0,0 +1,743 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.Tables;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import static org.openjdk.asmtools.jasm.OpcodeTables.Opcode;\n+import static org.openjdk.asmtools.jasm.OpcodeTables.opcode;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import static org.openjdk.asmtools.jasm.Tables.AttrTag.ATT_RuntimeInvisibleTypeAnnotations;\n+import static org.openjdk.asmtools.jasm.Tables.AttrTag.ATT_RuntimeVisibleTypeAnnotations;\n+import static org.openjdk.asmtools.jdis.Utils.commentString;\n+\n+\/**\n+ * Code data for a code attribute in method members in a class of the Java Disassembler\n+ *\/\n+public class CodeData extends Indenter {\n+\n+    \/**\n+     * Raw byte array for the byte codes\n+     *\/\n+    protected byte[] code;\n+    \/**\n+     * Limit for the stack size\n+     *\/\n+    protected int max_stack;\n+\n+    \/* CodeData Fields *\/\n+    \/**\n+     * Limit for the number of local vars\n+     *\/\n+    protected int max_locals;\n+    \/**\n+     * The remaining attributes of this class\n+     *\/\n+    protected ArrayList<AttrData> attrs = new ArrayList<>(0);        \/\/ AttrData\n+\n+    \/\/ internal references\n+    protected ClassData cls;\n+    protected MethodData meth;\n+    \/**\n+     * (parsed) Trap table, describes exceptions caught\n+     *\/\n+    private ArrayList<TrapData> trap_table = new ArrayList<>(0);   \/\/ TrapData\n+    \/**\n+     * (parsed) Line Number table, describes source lines associated with ByteCode indexes\n+     *\/\n+    private ArrayList<LineNumData> lin_num_tb = new ArrayList<>(0);   \/\/ LineNumData\n+    \/**\n+     * (parsed) Local Variable table, describes variable scopes associated with ByteCode\n+     * indexes\n+     *\/\n+    private ArrayList<LocVarData> loc_var_tb = new ArrayList<>(0);   \/\/ LocVarData\n+    \/**\n+     * (parsed) stack map table, describes compiler hints for stack rep, associated with\n+     * ByteCode indexes\n+     *\/\n+    private ArrayList<StackMapData> stack_map = null;\n+    \/**\n+     * The visible type annotations for this method\n+     *\/\n+    private ArrayList<TypeAnnotationData> visibleTypeAnnotations;\n+    \/**\n+     * The invisible type annotations for this method\n+     *\/\n+    private ArrayList<TypeAnnotationData> invisibleTypeAnnotations;\n+\n+    \/**\n+     * (parsed) reversed bytecode index hash, associates labels with ByteCode indexes\n+     *\/\n+    private HashMap<Integer, iAtt> iattrs = new HashMap<>();\n+    private PrintWriter out;\n+    public CodeData(MethodData meth) {\n+        this.meth = meth;\n+        this.cls = meth.cls;\n+        this.out = cls.out;\n+    }\n+\n+    private static int align(int n) {\n+        return (n + 3) & ~3;\n+    }\n+    \/*-------------------------------------------------------- *\/\n+\n+    private int getbyte(int pc) {\n+        return code[pc];\n+    }\n+\n+    private int getUbyte(int pc) {\n+        return code[pc] & 0xFF;\n+    }\n+\n+    private int getShort(int pc) {\n+        return (code[pc] << 8) | (code[pc + 1] & 0xFF);\n+    }\n+\n+    private int getUShort(int pc) {\n+        return ((code[pc] << 8) | (code[pc + 1] & 0xFF)) & 0xFFFF;\n+    }\n+\n+    private int getInt(int pc) {\n+        return (getShort(pc) << 16) | (getShort(pc + 2) & 0xFFFF);\n+    }\n+\n+    protected iAtt get_iAtt(int pc) {\n+        Integer PC = pc;\n+        iAtt res = iattrs.get(PC);\n+        if (res == null) {\n+            res = new iAtt(this);\n+            iattrs.put(PC, res);\n+        }\n+        return res;\n+    }\n+\n+    \/*========================================================*\/\n+    \/* Read Methods *\/\n+    private void readLineNumTable(DataInputStream in) throws IOException {\n+        int len = in.readInt(); \/\/ attr_length\n+        int numlines = in.readUnsignedShort();\n+        lin_num_tb = new ArrayList<>(numlines);\n+        TraceUtils.traceln(3,  \"CodeAttr:  LineNumTable[\" + numlines + \"] len=\" + len);\n+        for (int l = 0; l < numlines; l++) {\n+            lin_num_tb.add(new LineNumData(in));\n+        }\n+    }\n+\n+    private void readLocVarTable(DataInputStream in) throws IOException {\n+        int len = in.readInt(); \/\/ attr_length\n+        int numlines = in.readUnsignedShort();\n+        loc_var_tb = new ArrayList<>(numlines);\n+        TraceUtils.traceln(3,  \"CodeAttr:  LocalVariableTable[\" + numlines + \"] len=\" + len);\n+        for (int l = 0; l < numlines; l++) {\n+            loc_var_tb.add(new LocVarData(in));\n+        }\n+    }\n+\n+    private void readTrapTable(DataInputStream in) throws IOException {\n+        int trap_table_len = in.readUnsignedShort();\n+        TraceUtils.traceln(3,  \"CodeAttr:  TrapTable[\" + trap_table_len + \"]\");\n+        trap_table = new ArrayList<>(trap_table_len);\n+        for (int l = 0; l < trap_table_len; l++) {\n+            trap_table.add(new TrapData(in, l));\n+        }\n+    }\n+\n+    private void readStackMap(DataInputStream in) throws IOException {\n+        int len = in.readInt(); \/\/ attr_length\n+        int stack_map_len = in.readUnsignedShort();\n+        TraceUtils.traceln(3,  \"CodeAttr:  Stack_Map: attrlen=\" + len + \" num=\" + stack_map_len);\n+        stack_map = new ArrayList<>(stack_map_len);\n+        StackMapData.prevFramePC = 0;\n+        for (int k = 0; k < stack_map_len; k++) {\n+            stack_map.add(new StackMapData(this, in));\n+        }\n+    }\n+\n+    private void readStackMapTable(DataInputStream in) throws IOException {\n+        int len = in.readInt(); \/\/ attr_length\n+        int stack_map_len = in.readUnsignedShort();\n+        TraceUtils.traceln(3,  \"CodeAttr:  Stack_Map_Table: attrlen=\" + len + \" num=\" + stack_map_len);\n+        stack_map = new ArrayList<>(stack_map_len);\n+        StackMapData.prevFramePC = 0;\n+        for (int k = 0; k < stack_map_len; k++) {\n+            stack_map.add(new StackMapData(this, in, true));\n+        }\n+    }\n+\n+    private void readTypeAnnotations(DataInputStream in, boolean isInvisible) throws IOException  {\n+        int attrLength = in.readInt();\n+        \/\/ Read Type Annotations Attr\n+        int count = in.readShort();\n+        ArrayList<TypeAnnotationData> tannots = new ArrayList<>(count);\n+        TraceUtils.traceln(3,  \"CodeAttr:   Runtime\" +\n+                (isInvisible ? \"Inv\" : \"V\") +\n+                \"isibleTypeAnnotation: attrlen=\" +\n+                attrLength + \" num=\" + count);\n+        for (int index = 0; index < count; index++) {\n+            TraceUtils.traceln(\"\\t\\t\\t[\" + index +\"]:\");\n+            TypeAnnotationData tannot = new TypeAnnotationData(isInvisible, cls);\n+            tannot.read(in);\n+            tannots.add(tannot);\n+        }\n+        if (isInvisible) {\n+            invisibleTypeAnnotations = tannots;\n+        } else {\n+            visibleTypeAnnotations = tannots;\n+        }\n+    }\n+\n+    \/**\n+     * read\n+     * <p>\n+     * read and resolve the code attribute data called from MethodData. precondition:\n+     * NumFields has already been read from the stream.\n+     *\/\n+    public void read(DataInputStream in, int codeattrlen) throws IOException {\n+\n+        \/\/ Read the code in the Code Attribute\n+        max_stack = in.readUnsignedShort();\n+        max_locals = in.readUnsignedShort();\n+        int codelen = in.readInt();\n+        TraceUtils.traceln(3,  \"CodeAttr:  Codelen=\" + codelen +\n+                \" fulllen=\" + codeattrlen +\n+                \" max_stack=\" + max_stack +\n+                \" max_locals=\" + max_locals);\n+\n+        \/\/ read the raw code bytes\n+        code = new byte[codelen];\n+        in.read(code, 0, codelen);\n+\n+        \/\/read the trap table\n+        readTrapTable(in);\n+\n+        \/\/ Read any attributes of the Code Attribute\n+        int nattr = in.readUnsignedShort();\n+        TraceUtils.traceln(3,  \"CodeAttr: add.attr:\" + nattr);\n+        for (int k = 0; k < nattr; k++) {\n+            int name_cpx = in.readUnsignedShort();\n+            \/\/ verify the Attrs name\n+            ConstantPool.Constant name_const = cls.pool.getConst(name_cpx);\n+            if (name_const != null && name_const.tag == ConstantPool.TAG.CONSTANT_UTF8) {\n+                String attrname = cls.pool.getString(name_cpx);\n+                TraceUtils.traceln(3,  \"CodeAttr:  attr: \" + attrname);\n+                \/\/ process the attr\n+                AttrTag attrtag = attrtag(attrname);\n+                switch (attrtag) {\n+                    case ATT_LineNumberTable:\n+                        readLineNumTable(in);\n+                        break;\n+                    case ATT_LocalVariableTable:\n+                        readLocVarTable(in);\n+                        break;\n+                    case ATT_StackMap:\n+                        readStackMap(in);\n+                        break;\n+                    case ATT_StackMapTable:\n+                        readStackMapTable(in);\n+                        break;\n+                    case ATT_RuntimeVisibleTypeAnnotations:\n+                    case ATT_RuntimeInvisibleTypeAnnotations:\n+                        readTypeAnnotations(in, attrtag == ATT_RuntimeInvisibleTypeAnnotations);\n+                        break;\n+                    default:\n+                        AttrData attr = new AttrData(cls);\n+                        int attrlen = in.readInt(); \/\/ attr_length\n+                        attr.read(name_cpx, attrlen, in);\n+                        attrs.add(attr);\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/*========================================================*\/\n+    \/* Code Resolution Methods *\/\n+    private int checkForLabelRef(int pc) {\n+        \/\/         throws IOException {\n+        int opc = getUbyte(pc);\n+        Opcode opcode = opcode(opc);\n+        switch (opcode) {\n+            case opc_tableswitch: {\n+                int tb = align(pc + 1);\n+                int default_skip = getInt(tb); \/* default skip pamount *\/\n+\n+                int low = getInt(tb + 4);\n+                int high = getInt(tb + 8);\n+                int count = high - low;\n+                for (int i = 0; i <= count; i++) {\n+                    get_iAtt(pc + getInt(tb + 12 + 4 * i)).referred = true;\n+                }\n+                get_iAtt(default_skip + pc).referred = true;\n+                return tb - pc + 16 + count * 4;\n+            }\n+            case opc_lookupswitch: {\n+                int tb = align(pc + 1);\n+                int default_skip = getInt(tb); \/* default skip pamount *\/\n+\n+                int npairs = getInt(tb + 4);\n+                for (int i = 1; i <= npairs; i++) {\n+                    get_iAtt(pc + getInt(tb + 4 + i * 8)).referred = true;\n+                }\n+                get_iAtt(default_skip + pc).referred = true;\n+                return tb - pc + (npairs + 1) * 8;\n+            }\n+            case opc_jsr:\n+            case opc_goto:\n+            case opc_ifeq:\n+            case opc_ifge:\n+            case opc_ifgt:\n+            case opc_ifle:\n+            case opc_iflt:\n+            case opc_ifne:\n+            case opc_if_icmpeq:\n+            case opc_if_icmpne:\n+            case opc_if_icmpge:\n+            case opc_if_icmpgt:\n+            case opc_if_icmple:\n+            case opc_if_icmplt:\n+            case opc_if_acmpeq:\n+            case opc_if_acmpne:\n+            case opc_ifnull:\n+            case opc_ifnonnull:\n+                get_iAtt(pc + getShort(pc + 1)).referred = true;\n+                return 3;\n+            case opc_jsr_w:\n+            case opc_goto_w:\n+                get_iAtt(pc + getInt(pc + 1)).referred = true;\n+                return 5;\n+            case opc_wide:\n+            case opc_nonpriv:\n+            case opc_priv:\n+                int opc2 = (opcode.value() << 8) + getUbyte(pc + 1);\n+                opcode = opcode(opc2);\n+        }\n+        try {\n+            int opclen = opcode.length();\n+            return opclen == 0 ? 1 : opclen;  \/\/ bugfix for 4614404\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return 1;\n+        }\n+    } \/\/ end checkForLabelRef\n+\n+    private void loadLabelTable() {\n+        for (int pc = 0; pc < code.length; ) {\n+            pc = pc + checkForLabelRef(pc);\n+        }\n+    }\n+\n+    private void loadLineNumTable() {\n+        for (LineNumData entry : lin_num_tb) {\n+            get_iAtt(entry.start_pc).lnum = entry.line_number;\n+        }\n+    }\n+\n+    private void loadStackMap() {\n+        for (StackMapData entry : stack_map) {\n+            get_iAtt(entry.start_pc).stackMapEntry = entry;\n+        }\n+    }\n+\n+    private void loadLocVarTable() {\n+        for (LocVarData entry : loc_var_tb) {\n+            get_iAtt(entry.start_pc).add_var(entry);\n+            get_iAtt(entry.start_pc + entry.length).add_endvar(entry);\n+        }\n+    }\n+\n+    private void loadTrapTable() {\n+        for (TrapData entry : trap_table) {\n+            get_iAtt(entry.start_pc).add_trap(entry);\n+            get_iAtt(entry.end_pc).add_endtrap(entry);\n+            get_iAtt(entry.handler_pc).add_handler(entry);\n+        }\n+    }\n+\n+    \/*========================================================*\/\n+    \/* Print Methods *\/\n+    private void PrintConstant(int cpx) {\n+        out.print(\"\\t\");\n+        cls.pool.PrintConstant(out, cpx);\n+    }\n+\n+    private void PrintCommentedConstant(int cpx) {\n+        out.print(commentString(cls.pool.ConstantStrValue(cpx)));\n+    }\n+\n+    private int printInstr(int pc) {\n+        boolean pr_cpx = meth.options.contains(Options.PR.CPX);\n+        int opc = getUbyte(pc);\n+        int opc2;\n+        Opcode opcode = opcode(opc);\n+        Opcode opcode2;\n+        String mnem;\n+        switch (opcode) {\n+            case opc_nonpriv:\n+            case opc_priv:\n+                opc2 = getUbyte(pc + 1);\n+                int finalopc = (opc << 8) + opc2;\n+                opcode2 = opcode(finalopc);\n+                if (opcode2 == null) {\n+\/\/ assume all (even nonexistent) priv and nonpriv instructions\n+\/\/ are 2 bytes long\n+                    mnem = opcode.parsekey() + \" \" + opc2;\n+                } else {\n+                    mnem = opcode2.parsekey();\n+                }\n+                out.print(mnem);\n+                return 2;\n+            case opc_wide: {\n+                opc2 = getUbyte(pc + 1);\n+                int finalopcwide = (opc << 8) + opc2;\n+                opcode2 = opcode(finalopcwide);\n+                if (opcode2 == null) {\n+\/\/ nonexistent opcode - but we have to print something\n+                    out.print(\"bytecode \" + opcode);\n+                    return 1;\n+                } else {\n+                    mnem = opcode2.parsekey();\n+                }\n+                out.print(mnem + \" \" + getUShort(pc + 2));\n+                if (opcode2 == Opcode.opc_iinc_w) {\n+                    out.print(\", \" + getShort(pc + 4));\n+                    return 6;\n+                }\n+                return 4;\n+            }\n+        }\n+        mnem = opcode.parsekey();\n+        if (mnem == null) {\n+\/\/ nonexistent opcode - but we have to print something\n+            out.print(\"bytecode \" + opcode);\n+            return 1;\n+        }\n+        if (opcode.value() > Opcode.opc_jsr_w.value()) {\n+\/\/ pseudo opcodes should be printed as bytecodes\n+            out.print(\"bytecode \" + opcode);\n+            return 1;\n+        }\n+        out.print(opcode.parsekey());\n+\/\/ TraceUtils.traceln(\"****** [CodeData.printInstr]: got an '\" + opcode.parseKey() + \"' [\" + opc + \"] instruction ****** \");\n+        switch (opcode) {\n+            case opc_aload:\n+            case opc_astore:\n+            case opc_fload:\n+            case opc_fstore:\n+            case opc_iload:\n+            case opc_istore:\n+            case opc_lload:\n+            case opc_lstore:\n+            case opc_dload:\n+            case opc_dstore:\n+            case opc_ret:\n+                out.print(\"\\t\" + getUbyte(pc + 1));\n+                return 2;\n+            case opc_iinc:\n+                out.print(\"\\t\" + getUbyte(pc + 1) + \", \" + getbyte(pc + 2));\n+                return 3;\n+            case opc_tableswitch: {\n+                int tb = align(pc + 1);\n+                int default_skip = getInt(tb); \/* default skip pamount *\/\n+\n+                int low = getInt(tb + 4);\n+                int high = getInt(tb + 8);\n+                int count = high - low;\n+                out.print(\"{ \/\/\" + low + \" to \" + high);\n+                for (int i = 0; i <= count; i++) {\n+                    out.print(\"\\n\\t\\t\" + (i + low) + \": \" + meth.lP + (pc + getInt(tb + 12 + 4 * i)) + \";\");\n+                }\n+                out.print(\"\\n\\t\\tdefault: \" + meth.lP + (default_skip + pc) + \" }\");\n+                return tb - pc + 16 + count * 4;\n+            }\n+            case opc_lookupswitch: {\n+                int tb = align(pc + 1);\n+                int default_skip = getInt(tb);\n+                int npairs = getInt(tb + 4);\n+                out.print(\"{ \/\/\" + npairs);\n+                for (int i = 1; i <= npairs; i++) {\n+                    out.print(\"\\n\\t\\t\" + getInt(tb + i * 8) + \": \" + meth.lP + (pc + getInt(tb + 4 + i * 8)) + \";\");\n+                }\n+                out.print(\"\\n\\t\\tdefault: \" + meth.lP + (default_skip + pc) + \" }\");\n+                return tb - pc + (npairs + 1) * 8;\n+            }\n+            case opc_newarray:\n+                int tp = getUbyte(pc + 1);\n+                BasicType type = basictype(tp);\n+                switch (type) {\n+                    case T_BOOLEAN:\n+                        out.print(\" boolean\");\n+                        break;\n+                    case T_BYTE:\n+                        out.print(\" byte\");\n+                        break;\n+                    case T_CHAR:\n+                        out.print(\" char\");\n+                        break;\n+                    case T_SHORT:\n+                        out.print(\" short\");\n+                        break;\n+                    case T_INT:\n+                        out.print(\" int\");\n+                        break;\n+                    case T_LONG:\n+                        out.print(\" long\");\n+                        break;\n+                    case T_FLOAT:\n+                        out.print(\" float\");\n+                        break;\n+                    case T_DOUBLE:\n+                        out.print(\" double\");\n+                        break;\n+                    case T_CLASS:\n+                        out.print(\" class\");\n+                        break;\n+                    default:\n+                        out.print(\" BOGUS TYPE:\" + type);\n+                }\n+                return 2;\n+            case opc_ldc_w:\n+            case opc_ldc2_w: {\n+                \/\/ added printing of the tag: Method\/Interface to clarify\n+                \/\/ interpreting CONSTANT_MethodHandle_info:reference_kind\n+                \/\/ Example: ldc_w Dynamic REF_invokeStatic:Method CondyIndy.condy_bsm\n+                cls.pool.setPrintTAG(true);\n+                int index = getUShort(pc + 1);\n+                if (pr_cpx) {\n+                    out.print(\"\\t#\" + index + \"; \/\/\");\n+                }\n+                PrintConstant(index);\n+                cls.pool.setPrintTAG(false);\n+                return 3;\n+            }\n+            case opc_anewarray:\n+            case opc_instanceof:\n+            case opc_checkcast:\n+            case opc_new:\n+            case opc_putstatic:\n+            case opc_getstatic:\n+            case opc_putfield:\n+            case opc_getfield:\n+            case opc_invokevirtual:\n+            case opc_invokespecial:\n+            case opc_invokestatic: {\n+                int index = getUShort(pc + 1);\n+                if (pr_cpx) {\n+                    out.print(\"\\t#\" + index + \"; \/\/\");\n+                }\n+                PrintConstant(index);\n+                return 3;\n+            }\n+            case opc_sipush:\n+                out.print(\"\\t\" + getShort(pc + 1));\n+                return 3;\n+            case opc_bipush:\n+                out.print(\"\\t\" + getbyte(pc + 1));\n+                return 2;\n+            case opc_ldc: {\n+                \/\/ added printing of the tag: Method\/Interface to clarify\n+                \/\/ interpreting CONSTANT_MethodHandle_info:reference_kind\n+                \/\/ Example: ldc Dynamic REF_invokeStatic:Method CondyIndy.condy_bsm\n+                cls.pool.setPrintTAG(true);\n+                int index = getUbyte(pc + 1);\n+                if (pr_cpx) {\n+                    out.print(\"\\t#\" + index + \"; \/\/\");\n+                }\n+                PrintConstant(index);\n+                cls.pool.setPrintTAG(false);\n+                return 2;\n+            }\n+            case opc_invokeinterface: {\n+                int index = getUShort(pc + 1), nargs = getUbyte(pc + 3);\n+                if (pr_cpx) {\n+                    out.print(\"\\t#\" + index + \",  \" + nargs + \"; \/\/\");\n+                    PrintConstant(index);\n+                } else {\n+                    PrintConstant(index);\n+                    out.print(\",  \" + nargs); \/\/ args count\n+                }\n+                return 5;\n+            }\n+            case opc_invokedynamic: { \/\/ JSR-292\n+                cls.pool.setPrintTAG(true);\n+                int index = getUShort(pc + 1);\n+                \/\/ getUbyte(pc + 3); \/\/ reserved byte\n+                \/\/ getUbyte(pc + 4); \/\/ reserved byte\n+                if (pr_cpx) {\n+                    out.print(\"\\t#\" + index + \";\\t\");\n+                    PrintCommentedConstant(index);\n+                } else {\n+                    PrintConstant(index);\n+                }\n+                cls.pool.setPrintTAG(false);\n+                return 5;\n+            }\n+            case opc_multianewarray: {\n+                int index = getUShort(pc + 1), dimensions = getUbyte(pc + 3);\n+                if (pr_cpx) {\n+                    out.print(\"\\t#\" + index + \",  \" + dimensions + \"; \/\/\");\n+                    PrintConstant(index);\n+                } else {\n+                    PrintConstant(index);\n+                    out.print(\",  \" + dimensions); \/\/ dimensions count\n+                }\n+                return 4;\n+            }\n+            case opc_jsr:\n+            case opc_goto:\n+            case opc_ifeq:\n+            case opc_ifge:\n+            case opc_ifgt:\n+            case opc_ifle:\n+            case opc_iflt:\n+            case opc_ifne:\n+            case opc_if_icmpeq:\n+            case opc_if_icmpne:\n+            case opc_if_icmpge:\n+            case opc_if_icmpgt:\n+            case opc_if_icmple:\n+            case opc_if_icmplt:\n+            case opc_if_acmpeq:\n+            case opc_if_acmpne:\n+            case opc_ifnull:\n+            case opc_ifnonnull:\n+                out.print(\"\\t\" + meth.lP + (pc + getShort(pc + 1)));\n+                return 3;\n+            case opc_jsr_w:\n+            case opc_goto_w:\n+                out.print(\"\\t\" + meth.lP + (pc + getInt(pc + 1)));\n+                return 5;\n+            default:\n+                return 1;\n+        }\n+    } \/\/ end printInstr\n+\n+    \/**\n+     * print\n+     * <p>\n+     * prints the code data to the current output stream. called from MethodData.\n+     *\/\n+    public void print() throws IOException {\n+        if (!lin_num_tb.isEmpty()) {\n+            loadLineNumTable();\n+        }\n+        if (stack_map != null) {\n+            loadStackMap();\n+        }\n+        if (!meth.options.contains(Options.PR.PC)) {\n+            loadLabelTable();\n+        }\n+        loadTrapTable();\n+        if (!loc_var_tb.isEmpty()) {\n+            loadLocVarTable();\n+        }\n+\n+        out.println();\n+        out.println(\"\\tstack \" + max_stack + \" locals \" + max_locals);\n+\n+        \/\/ Need to print ParamAnnotations here.\n+        meth.printPAnnotations();\n+\n+        out.println(getIndentString() + \"{\");\n+\n+        iAtt iatt = iattrs.get(0);\n+        for (int pc = 0; pc < code.length; ) {\n+            if (iatt != null) {\n+                iatt.printBegins(); \/\/ equ. print(\"\\t\");\n+            } else {\n+                out.print(\"\\t\");\n+            }\n+            if (meth.options.contains(Options.PR.PC)) {\n+                out.print(pc + \":\\t\");\n+            } else if ((iatt != null) && iatt.referred) {\n+                out.print(meth.lP + pc + \":\\t\");\n+            } else {\n+                out.print(\"\\t\");\n+            }\n+            if (iatt != null) {\n+                iatt.printStackMap();\n+            }\n+            pc = pc + printInstr(pc);\n+            out.println(\";\");\n+            iatt = iattrs.get(pc);\n+            if (iatt != null) {\n+                iatt.printEnds();\n+            }\n+        }\n+        \/\/ the right brace can be labelled:\n+        if (iatt != null) {\n+            iatt.printBegins(); \/\/ equ. print(\"\\t\");\n+            if (iatt.referred) {\n+                out.print(meth.lP + code.length + \":\\t\");\n+            }\n+            iatt.printStackMap();\n+            out.println();\n+        }\n+        \/\/ print TypeAnnotations\n+        if (visibleTypeAnnotations != null) {\n+            out.println();\n+            for (TypeAnnotationData visad : visibleTypeAnnotations) {\n+                visad.print(out, getIndentString());\n+                out.println();\n+            }\n+        }\n+        if (invisibleTypeAnnotations != null) {\n+            for (TypeAnnotationData invisad : invisibleTypeAnnotations) {\n+                invisad.print(out, getIndentString());\n+                out.println();\n+            }\n+        }\n+        \/\/ end of code\n+        out.println(getIndentString() + \"}\");\n+    }\n+\n+\n+    public static class LocVarData {\n+\n+        short start_pc, length, name_cpx, sig_cpx, slot;\n+\n+        public LocVarData(DataInputStream in) throws IOException {\n+            start_pc = in.readShort();\n+            length = in.readShort();\n+            name_cpx = in.readShort();\n+            sig_cpx = in.readShort();\n+            slot = in.readShort();\n+        }\n+    }\n+\n+    \/* Code Data inner classes *\/\n+    class LineNumData {\n+\n+        short start_pc, line_number;\n+\n+        public LineNumData(DataInputStream in) throws IOException {\n+            start_pc = in.readShort();\n+            line_number = in.readShort();\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/CodeData.java","additions":743,"deletions":0,"binary":false,"changes":743,"status":"added"},{"patch":"@@ -0,0 +1,1073 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.asmutils.HexUtils;\n+import org.openjdk.asmtools.asmutils.StringUtils;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Hashtable;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jdis.Utils.commentString;\n+\n+\/**\n+ *\n+ * ConstantPool\n+ *\n+ * Class representing the ConstantPool\n+ *\/\n+public class ConstantPool {\n+\n+    private static final Hashtable<Byte, TAG> taghash = new Hashtable<>();\n+    private static final Hashtable<Byte, SUBTAG> subtaghash = new Hashtable<>();\n+\n+    private boolean printTAG = false;\n+\n+    public void setPrintTAG(boolean value) {\n+        this.printTAG = value;\n+    }\n+\n+    public String getPrintedTAG(TAG tag) {\n+        return (this.printTAG) ? tag.tagname + \" \" : \"\" ;\n+    }\n+\n+    class Indent {\n+        private int length, offset, step;\n+\n+        void inc() {  length+=step; }\n+\n+        void dec() { length-=step; }\n+\n+        Indent(int offset, int step) {\n+            this.length = 0;\n+            this.step = step;\n+            this.offset = offset;\n+        }\n+\n+        int size() { return  offset + length; }\n+\n+        \/**\n+         * Creates indent string based on current indent size.\n+         *\/\n+        private String get() {\n+            return Collections.nCopies(size(), \"\\t\").stream().collect(Collectors.joining());\n+        }\n+    }\n+\n+    private final Indent indent = new Indent(2, 1);\n+\n+    \/**\n+     * TAG\n+     *\n+     * A Tag descriptor of constants in the constant pool\n+     *\n+     *\/\n+    public enum TAG {\n+        CONSTANT_UTF8               ((byte) 1, \"Asciz\", \"CONSTANT_UTF8\"),\n+        CONSTANT_UNICODE            ((byte) 2, \"unicorn\", \"CONSTANT_UNICODE\"),\n+        CONSTANT_INTEGER            ((byte) 3, \"int\", \"CONSTANT_INTEGER\"),\n+        CONSTANT_FLOAT              ((byte) 4, \"float\", \"CONSTANT_FLOAT\"),\n+        CONSTANT_LONG               ((byte) 5, \"long\", \"CONSTANT_LONG\"),\n+        CONSTANT_DOUBLE             ((byte) 6, \"double\", \"CONSTANT_DOUBLE\"),\n+        CONSTANT_CLASS              ((byte) 7, \"class\", \"CONSTANT_CLASS\"),\n+        CONSTANT_STRING             ((byte) 8, \"String\", \"CONSTANT_STRING\"),\n+        CONSTANT_FIELD              ((byte) 9, \"Field\", \"CONSTANT_FIELD\"),\n+        CONSTANT_METHOD             ((byte) 10, \"Method\", \"CONSTANT_METHOD\"),\n+        CONSTANT_INTERFACEMETHOD    ((byte) 11, \"InterfaceMethod\", \"CONSTANT_INTERFACEMETHOD\"),\n+        CONSTANT_NAMEANDTYPE        ((byte) 12, \"NameAndType\", \"CONSTANT_NAMEANDTYPE\"),\n+        CONSTANT_METHODHANDLE       ((byte) 15, \"MethodHandle\", \"CONSTANT_METHODHANDLE\"),\n+        CONSTANT_METHODTYPE         ((byte) 16, \"MethodType\", \"CONSTANT_METHODTYPE\"),\n+        CONSTANT_DYNAMIC            ((byte) 17, \"Dynamic\", \"CONSTANT_DYNAMIC\"),\n+        CONSTANT_INVOKEDYNAMIC      ((byte) 18, \"InvokeDynamic\", \"CONSTANT_INVOKEDYNAMIC\"),\n+        CONSTANT_MODULE             ((byte) 19, \"Module\", \"CONSTANT_MODULE\"),\n+        CONSTANT_PACKAGE            ((byte) 20, \"Package\", \"CONSTANT_PACKAGE\");\n+\n+        private final Byte value;\n+        private final String tagname;\n+        private final String printval;\n+\n+        TAG(byte val, String tgname, String print) {\n+            value = val;\n+            tagname = tgname;\n+            printval = print;\n+        }\n+\n+        public byte value() {\n+            return value;\n+        }\n+\n+        public String tagname() {\n+            return tagname;\n+        }\n+\n+        public String description() {\n+            return printval;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<\" + tagname + \"> \";\n+        }\n+\n+    };\n+\n+\n+    \/**\n+    * SUBTAG\n+    *\n+    * A Tag descriptor of form method-handle constants\n+    *\n+    *\/\n+    static public enum SUBTAG {\n+        REF_GETFIELD            ((byte) 1, \"REF_getField\", \"REF_GETFIELD\"),\n+        REF_GETSTATIC           ((byte) 2, \"REF_getStatic\", \"REF_GETSTATIC\"),\n+        REF_PUTFIELD            ((byte) 3, \"REF_putField\", \"REF_PUTFIELD\"),\n+        REF_PUTSTATIC           ((byte) 4, \"REF_putStatic\", \"REF_PUTSTATIC\"),\n+        REF_INVOKEVIRTUAL       ((byte) 5, \"REF_invokeVirtual\", \"REF_INVOKEVIRTUAL\"),\n+        REF_INVOKESTATIC        ((byte) 6, \"REF_invokeStatic\", \"REF_INVOKESTATIC\"),\n+        REF_INVOKESPECIAL       ((byte) 7, \"REF_invokeSpecial\", \"REF_INVOKESPECIAL\"),\n+        REF_NEWINVOKESPECIAL    ((byte) 8, \"REF_newInvokeSpecial\", \"REF_NEWINVOKESPECIAL\"),\n+        REF_INVOKEINTERFACE     ((byte) 9, \"REF_invokeInterface\", \"REF_INVOKEINTERFACE\");\n+\n+        private final Byte value;\n+        private final String tagname;\n+        private final String printval;\n+\n+        SUBTAG(byte val, String tgname, String print) {\n+            value = val;\n+            tagname = tgname;\n+            printval = print;\n+\/\/            subtaghash.put(new Byte(val), this);\n+        }\n+\n+        public byte value() {\n+            return value;\n+        }\n+\n+        public String tagname() {\n+            return tagname;\n+        }\n+\n+        public String description() {\n+            return printval;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<\" + tagname + \"> \";\n+        }\n+    };\n+\n+    static {\n+\n+        \/\/ Class initializer Code\n+        \/\/\n+        \/\/ Make sure all of the tags get initialized before being used.\n+        taghash.put(TAG.CONSTANT_UTF8.value(), TAG.CONSTANT_UTF8);\n+        taghash.put(TAG.CONSTANT_UNICODE.value(), TAG.CONSTANT_UNICODE);\n+        taghash.put(TAG.CONSTANT_INTEGER.value(), TAG.CONSTANT_INTEGER);\n+        taghash.put(TAG.CONSTANT_FLOAT.value(), TAG.CONSTANT_FLOAT);\n+        taghash.put(TAG.CONSTANT_LONG.value(), TAG.CONSTANT_LONG);\n+        taghash.put(TAG.CONSTANT_DOUBLE.value(), TAG.CONSTANT_DOUBLE);\n+        taghash.put(TAG.CONSTANT_CLASS.value(), TAG.CONSTANT_CLASS);\n+        taghash.put(TAG.CONSTANT_STRING.value(), TAG.CONSTANT_STRING);\n+        taghash.put(TAG.CONSTANT_FIELD.value(), TAG.CONSTANT_FIELD);\n+        taghash.put(TAG.CONSTANT_METHOD.value(), TAG.CONSTANT_METHOD);\n+        taghash.put(TAG.CONSTANT_INTERFACEMETHOD.value(), TAG.CONSTANT_INTERFACEMETHOD);\n+        taghash.put(TAG.CONSTANT_NAMEANDTYPE.value(), TAG.CONSTANT_NAMEANDTYPE);\n+        taghash.put(TAG.CONSTANT_METHODHANDLE.value(), TAG.CONSTANT_METHODHANDLE);\n+        taghash.put(TAG.CONSTANT_METHODTYPE.value(), TAG.CONSTANT_METHODTYPE);\n+        taghash.put(TAG.CONSTANT_DYNAMIC.value(), TAG.CONSTANT_DYNAMIC);\n+        taghash.put(TAG.CONSTANT_INVOKEDYNAMIC.value(), TAG.CONSTANT_INVOKEDYNAMIC);\n+        taghash.put(TAG.CONSTANT_MODULE.value(), TAG.CONSTANT_MODULE);\n+        taghash.put(TAG.CONSTANT_PACKAGE.value(), TAG.CONSTANT_PACKAGE);\n+\n+        subtaghash.put(SUBTAG.REF_GETFIELD.value(), SUBTAG.REF_GETFIELD);\n+        subtaghash.put(SUBTAG.REF_GETSTATIC.value(), SUBTAG.REF_GETSTATIC);\n+        subtaghash.put(SUBTAG.REF_PUTFIELD.value(), SUBTAG.REF_PUTFIELD);\n+        subtaghash.put(SUBTAG.REF_PUTSTATIC.value(), SUBTAG.REF_PUTSTATIC);\n+        subtaghash.put(SUBTAG.REF_INVOKEVIRTUAL.value(), SUBTAG.REF_INVOKEVIRTUAL);\n+        subtaghash.put(SUBTAG.REF_INVOKESTATIC.value(), SUBTAG.REF_INVOKESTATIC);\n+        subtaghash.put(SUBTAG.REF_INVOKESPECIAL.value(), SUBTAG.REF_INVOKESPECIAL);\n+        subtaghash.put(SUBTAG.REF_NEWINVOKESPECIAL.value(), SUBTAG.REF_NEWINVOKESPECIAL);\n+        subtaghash.put(SUBTAG.REF_INVOKEINTERFACE.value(), SUBTAG.REF_INVOKEINTERFACE);\n+\n+    }\n+\n+    \/**\n+     *\n+     * Constant\n+     *\n+     * Base class of all constant entries\n+     *\n+     *\/\n+    public class Constant {\n+\n+        \/**\n+         * tag the descriptor for the constant\n+         *\/\n+        public TAG tag;\n+\n+        public Constant(TAG tagval) {\n+            tag = tagval;\n+        }\n+\n+        public String stringVal() {\n+            return \"\";\n+        }\n+\n+        public void print(PrintWriter out) {\n+            out.print(tag.tagname + \"\\t\");\n+        }\n+\n+        public int size() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<CONSTANT \" + tag.toString() + \" \" + stringVal() + \">\";\n+        }\n+\n+        private IOException issue;\n+\n+        public IOException getIssue() {\n+            return issue;\n+        }\n+\n+        public void setIssue(IOException value) {\n+            issue = value;\n+        }\n+\n+    }\n+\n+    \/* -------------------------------------------------------- *\/\n+    \/* Constant Sub-classes *\/\n+    \/**\n+     *\n+     * CP_Str\n+     *\n+     * Constant entries that contain String data. usually is a CONSTANT_UTF8\n+     *\n+     *\/\n+    class CP_Str extends Constant {\n+\n+        String value;\n+\n+        CP_Str(TAG tagval, String str) {\n+            super(tagval);\n+            this.value = str;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            return StringUtils.Utf8ToString(value);\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out) {\n+            super.print(out);\n+            out.println(stringVal() + \";\");\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CP_Int\n+     *\n+     * Constant entries that contain Integer data. usually is a CONSTANT_INTEGER\n+     *\n+     *\/\n+    class CP_Int extends Constant {\n+\n+        Integer value;\n+\n+        CP_Int(TAG tagval, int intval) {\n+            super(tagval);\n+            this.value = intval;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            if (cd.options.contains(Options.PR.HEX)) {\n+                return HexUtils.toHex(value.intValue());\n+            }\n+            return value.toString();\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out) {\n+            super.print(out);\n+            out.println(stringVal() + \";\");\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CP_Long\n+     *\n+     * Constant entries that contain LongInteger data. usually is a CONSTANT_LONG\n+     *\n+     * These take up 2 slots in the constant pool.\n+     *\n+     *\/\n+    class CP_Long extends Constant {\n+\n+        Long value;\n+\n+        CP_Long(TAG tagval, long intval) {\n+            super(tagval);\n+            this.value = intval;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            if (cd.options.contains(Options.PR.HEX)) {\n+                return HexUtils.toHex(value.longValue()) + 'l';\n+            }\n+            return value.toString() + 'l';\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out) {\n+            super.print(out);\n+            out.println(stringVal() + \";\");\n+        }\n+\n+        @Override\n+        public int size() {\n+            return 2;\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CP_Float\n+     *\n+     * Constant entries that contain Float data. usually is a CONSTANT_FLOAT\n+     *\n+     *\/\n+    class CP_Float extends Constant {\n+\n+        Float value;\n+\n+        CP_Float(TAG tagval, float fltvl) {\n+            super(tagval);\n+            this.value = fltvl;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            if (cd.options.contains(Options.PR.HEX)) {\n+                return \"bits \" + HexUtils.toHex(Float.floatToIntBits(value.floatValue()));\n+            }\n+            String sf = (value).toString();\n+            if (value.isNaN() || value.isInfinite()) {\n+                return sf;\n+            }\n+            return sf + \"f\";\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out) {\n+            super.print(out);\n+            out.println(stringVal() + \";\");\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CP_Double\n+     *\n+     * Constant entries that contain double-precision float data. usually is a\n+     * CONSTANT_DOUBLE\n+     *\n+     * These take up 2 slots in the constant pool.\n+     *\n+     *\/\n+    class CP_Double extends Constant {\n+\n+        Double value;\n+\n+        CP_Double(TAG tagval, double fltvl) {\n+            super(tagval);\n+            this.value = fltvl;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            if (cd.options.contains(Options.PR.HEX)) {\n+                return \"bits \" + HexUtils.toHex(Double.doubleToLongBits(value.doubleValue())) + 'l';\n+            }\n+            String sd = value.toString();\n+            if (value.isNaN() || value.isInfinite()) {\n+                return sd;\n+            }\n+            return sd + \"d\";\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out) {\n+            super.print(out);\n+            out.println(stringVal() + \";\");\n+        }\n+\n+        @Override\n+        public int size() {\n+            return 2;\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CPX\n+     *\n+     * Constant entries that contain a single constant-pool index. Usually, this includes:\n+     * CONSTANT_CLASS CONSTANT_METHODTYPE CONSTANT_STRING CONSTANT_MODULE CONSTANT_PACKAGE\n+     *\n+     *\/\n+    class CPX extends Constant {\n+\n+        int value;\n+\n+        CPX(TAG tagval, int cpx) {\n+            super(tagval);\n+            this.value = cpx;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            String str = \"UnknownTag\";\n+            switch (tag) {\n+                case CONSTANT_CLASS:\n+                    str = getShortClassName(getClassName(this), cd.pkgPrefix);\n+                    break;\n+                case CONSTANT_PACKAGE:\n+                case CONSTANT_MODULE:\n+                    str = getString(value);\n+                    break;\n+                case CONSTANT_METHODTYPE:\n+                case CONSTANT_STRING:\n+                    str = StringValue(value);\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return str;\n+        }\n+\n+        @Override\n+        public void print(PrintWriter out) {\n+            super.print(out);\n+            switch (tag) {\n+                case CONSTANT_CLASS:\n+                case CONSTANT_STRING:\n+                case CONSTANT_METHODTYPE:\n+                case CONSTANT_PACKAGE:\n+                case CONSTANT_MODULE:\n+                    out.println(\"#\" + (value) + \";\\t\/\/  \" + stringVal());\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * CPX2\n+     *\n+     * Constant entries that contain two constant-pool indices. Usually, this includes:\n+     * CONSTANT_FIELD CONSTANT_METHOD CONSTANT_INTERFACEMETHOD CONSTANT_NAMEANDTYPE\n+     * CONSTANT_METHODHANDLE CONSTANT_DYNAMIC CONSTANT_INVOKEDYNAMIC\n+     *\n+     *\/\n+    class CPX2 extends Constant {\n+\n+        int value1, value2;\n+\n+        CPX2(TAG tagval, int cpx1, int cpx2) {\n+            super(tagval);\n+            this.value1 = cpx1;\n+            this.value2 = cpx2;\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+\n+            String str = \"UnknownTag\";\n+            switch (tag) {\n+                case CONSTANT_FIELD:\n+                    \/\/ CODETOOLS-7902660: the tag Field is not necessary while printing static parameters of a bsm\n+                    \/\/ Example: MethodHandle REF_getField:ClassName.FieldName:\"I\"\n+                    str = getShortClassName(getClassName(value1), cd.pkgPrefix) + \".\" + StringValue(value2);\n+                    break;\n+                case CONSTANT_METHOD:\n+                case CONSTANT_INTERFACEMETHOD:\n+                    \/\/ CODETOOLS-7902648: added printing of the tag: Method\/Interface to clarify\n+                    \/\/ interpreting CONSTANT_MethodHandle_info:reference_kind\n+                    \/\/ Example: invokedynamic InvokeDynamic REF_invokeStatic:Method java\/lang\/runtime\/ObjectMethods.bootstrap\n+                    str = getPrintedTAG(tag) + getShortClassName(getClassName(value1), cd.pkgPrefix) + \".\" + StringValue(value2);\n+                    break;\n+                case CONSTANT_NAMEANDTYPE:\n+                    str = getName(value1) + \":\" + StringValue(value2);\n+                    break;\n+                case CONSTANT_METHODHANDLE:\n+                    str = subtagToString(value1) + \":\" + StringValue(value2);\n+                    break;\n+                case CONSTANT_DYNAMIC:\n+                case CONSTANT_INVOKEDYNAMIC:\n+                    int bsm_attr_idx = value1;\n+                    int nape_idx = value2;\n+                    BootstrapMethodData bsmData;\n+                    try {\n+                        bsmData = cd.bootstrapMethods.get(bsm_attr_idx);\n+                    } catch (NullPointerException npe) {\n+                        return \"<Missing BootstrapMethods attribute>\";\n+                    } catch (IndexOutOfBoundsException ioob) {\n+                        return \"<Invalid bootstrap method index:\" + bsm_attr_idx + \">\";\n+                    }\n+                    StringBuilder bsm_args_str = new StringBuilder();\n+                    String offsetParm,offsetBrace;\n+                    int bsm_ref = bsmData.bsm_index;\n+                    int bsm_args_len = bsmData.bsm_args_indexes.size();\n+                    if (bsm_args_len > 0) {\n+                        bsm_args_str.append(\" {\\n\");\n+                        offsetBrace = indent.get();\n+                        indent.inc();\n+                        offsetParm = indent.get();\n+                        for (int i = 0; i < bsm_args_len; i++) {\n+                            int bsm_arg_idx = bsmData.bsm_args_indexes.get(i);\n+                            Constant cnt = pool.get(bsm_arg_idx);\n+                            if (cnt.equals(this)) {\n+                                String s = \"circular reference to \" + cnt.tag.tagname() + \" #\" + bsm_arg_idx;\n+                                bsm_args_str.append(offsetParm).append(\"  <\").append(s).append(\">\");\n+                                cnt.setIssue(new IOException(s));\n+                            } else {\n+                                bsm_args_str.append(offsetParm).append(ConstantStrValue(bsm_arg_idx));\n+                                if (i + 1 < bsm_args_len) {\n+                                    bsm_args_str.append(\",\");\n+                                }\n+                            }\n+                            bsm_args_str.append('\\n');\n+                        }\n+                        indent.dec();\n+                        bsm_args_str.append(offsetBrace).append(\"}\");\n+                    }\n+                    str = StringValue(bsm_ref) + \":\" + StringValue(nape_idx) + bsm_args_str.toString();\n+                default:\n+                    break;\n+            }\n+            return str;\n+        }\n+\n+\n+\n+        @Override\n+        public void print(PrintWriter out) {\n+            super.print(out);\n+            switch (tag) {\n+                case CONSTANT_FIELD:\n+                case CONSTANT_METHOD:\n+                case CONSTANT_INTERFACEMETHOD:\n+                    out.println(\"#\" + value1 + \".#\" + value2 + \";\\t\/\/  \" + stringVal());\n+                    break;\n+                case CONSTANT_METHODHANDLE:\n+                    out.println(value1 + \":#\" + value2 + \";\\t\/\/  \" + stringVal());\n+                    break;\n+                case CONSTANT_NAMEANDTYPE:\n+                    out.println(\"#\" + value1 + \":#\" + value2 + \";\\t\/\/  \" + stringVal());\n+                    break;\n+                case CONSTANT_DYNAMIC:\n+                case CONSTANT_INVOKEDYNAMIC:\n+                    out.println(value1 + \":#\" + value2 + \";\\t\" + commentString(stringVal()));\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        public boolean refersClassMember() {\n+            return tag == TAG.CONSTANT_FIELD || tag == TAG.CONSTANT_METHOD || tag == TAG.CONSTANT_INTERFACEMETHOD;\n+        }\n+    }\n+\n+    \/* -------------------------------------------------------- *\/\n+    \/* ConstantPool Fields *\/\n+    \/**\n+     * The actual pool of Constants\n+     *\/\n+    public ArrayList<Constant> pool;\n+    \/**\n+     * Reference to the class data\n+     *\/\n+    private ClassData cd;\n+\n+\n+    \/* -------------------------------------------------------- *\/\n+    \/* ConstantPool Methods *\/\n+\n+    \/* ConstantPool Constructors *\/\n+    public ConstantPool(ClassData cd) {\n+        pool = null;\n+        this.cd = cd;\n+    }\n+\n+    public ConstantPool(ClassData cd, int size) {\n+        pool = new ArrayList<>(size);\n+        this.cd = cd;\n+    }\n+\n+    \/**\n+     *\n+     * read\n+     *\n+     * decodes a ConstantPool and it's constants from a data stream.\n+     *\n+     *\/\n+    void read(DataInputStream in) throws IOException {\n+        int length = in.readUnsignedShort();\n+        pool = new ArrayList<>(length);\n+        pool.add(0, null);\n+        TraceUtils.traceln(\"CP len=\" + length);\n+        for (int i = 1; i < length; i++) {\n+            byte tag = in.readByte();\n+            TAG tagobj = taghash.get(tag);\n+            TraceUtils.traceln(\"CP entry #\" + i + \" + tagindex=\" + tag + \" tag=\" + tagobj);\n+            switch (tagobj) {\n+                case CONSTANT_UTF8:\n+                    pool.add(i, new CP_Str(tagobj, in.readUTF()));\n+                    break;\n+                case CONSTANT_INTEGER:\n+                    pool.add(i, new CP_Int(tagobj, in.readInt()));\n+                    break;\n+                case CONSTANT_LONG:\n+                    pool.add(i, new CP_Long(tagobj, in.readLong()));\n+                    \/\/ handle null entry to account for Longs taking up 2 CP slots\n+                    i += 1;\n+                    pool.add(null);\n+                    break;\n+                case CONSTANT_FLOAT:\n+                    pool.add(i, new CP_Float(tagobj, in.readFloat()));\n+                    break;\n+                case CONSTANT_DOUBLE:\n+                    pool.add(i, new CP_Double(tagobj, in.readDouble()));\n+                    \/\/ handle null entry to account for Doubles taking up 2 CP slots\n+                    i += 1;\n+                    pool.add(null);\n+                    break;\n+                case CONSTANT_CLASS:\n+                case CONSTANT_STRING:\n+                case CONSTANT_METHODTYPE:\n+                case CONSTANT_PACKAGE:\n+                case CONSTANT_MODULE:\n+                    pool.add(i, new CPX(tagobj, in.readUnsignedShort()));\n+                    break;\n+                case CONSTANT_FIELD:\n+                case CONSTANT_METHOD:\n+                case CONSTANT_INTERFACEMETHOD:\n+                case CONSTANT_NAMEANDTYPE:\n+                case CONSTANT_DYNAMIC:\n+                case CONSTANT_INVOKEDYNAMIC:\n+                    pool.add(i, new CPX2(tagobj, in.readUnsignedShort(), in.readUnsignedShort()));\n+                    break;\n+                case CONSTANT_METHODHANDLE:\n+                    pool.add(i, new CPX2(tagobj, in.readUnsignedByte(), in.readUnsignedShort()));\n+                    break;\n+\n+                default:\n+                    throw new ClassFormatError(\"invalid constant type: \" + (int) tag);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * inbounds\n+     *\n+     * bounds-check a CP index.\n+     *\n+     *\/\n+    private boolean inbounds(int cpx) {\n+        return !(cpx == 0 || cpx >= pool.size());\n+    }\n+\n+    \/**\n+     *\n+     * getConst\n+     *\n+     * Public getter - Safely gets a Constant from the CP at a given index.\n+     *\n+     *\/\n+    public Constant getConst(int cpx) {\n+        if (inbounds(cpx)) {\n+            return pool.get(cpx);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     *\n+     * StringTag\n+     *\n+     * Public string val - Safely gets the string-rep of a Constant from the CP at a given\n+     * index.\n+     *\n+     *\/\n+    public String StringTag(int cpx) {\n+        String str = \"Incorrect CP index:\" + cpx;\n+        if (inbounds(cpx)) {\n+            Constant cns = pool.get(cpx);\n+            if (cns != null) {\n+                str = cns.tag.tagname;\n+            }\n+        }\n+        return str;\n+    }\n+\n+    \/**\n+     *\n+     * getString\n+     *\n+     * Public string val - Safely gets the string-rep of a ConstantUTF8 from the CP at a\n+     * given index.\n+     *\n+     * Returns either null (if invalid), or the string value of the UTF8\n+     *\n+     *\/\n+    public String getString(int cpx) {\n+        String str = null;\n+        if (inbounds(cpx)) {\n+            Constant cns = pool.get(cpx);\n+            if (cns != null && cns.tag == TAG.CONSTANT_UTF8) {\n+                CP_Str cns1 = (CP_Str) cns;\n+                str = cns1.value;\n+            }\n+        }\n+        return str;\n+    }\n+\n+    \/**\n+     *\n+     * getModule\n+     *\n+     * Public string val - Safely gets the string-rep of a ConstantModule from the CP at a\n+     * given index.\n+     *\n+     * Returns either null (if invalid), or the string value of the ConstantModule\n+     *\n+     *\/\n+    public String getModule(int cpx) {\n+        String str = null;\n+        if (inbounds(cpx)) {\n+            Constant cns = pool.get(cpx);\n+            if (cns != null && cns.tag == TAG.CONSTANT_MODULE) {\n+                str = cns.stringVal();\n+            }\n+        }\n+        return str;\n+    }\n+\n+    \/**\n+     *\n+     * getPackage\n+     *\n+     * Public string val - Safely gets the string-rep of a ConstantPackage from the CP at a\n+     * given index.\n+     *\n+     * Returns either null (if invalid), or the string value of the ConstantPackage\n+     *\n+     *\/\n+    public String getPackage(int cpx) {\n+        String str = null;\n+        if (inbounds(cpx)) {\n+            Constant cns = pool.get(cpx);\n+            if (cns != null && cns.tag == TAG.CONSTANT_PACKAGE) {\n+                str = cns.stringVal();\n+            }\n+        }\n+        return str;\n+    }\n+\n+    \/**\n+     *\n+     * getTypeName\n+     *\n+     * Safely gets a Java name from a ConstantUTF8 from the CP at a given index.\n+     *\n+     * Returns either null (if invalid), or the Java name value of the UTF8\n+     *\n+     *\/\n+    public String getName(int cpx) {\n+        String str = getString(cpx);\n+        if (str == null) {\n+            return \"<invalid constant pool index:\" + cpx + \">\";\n+        }\n+\n+        return Utils.javaName(str);\n+    }\n+\n+    \/**\n+     *\n+     * getClassName\n+     *\n+     * Safely gets a Java class name from a ConstantClass from the CP at a given index.\n+     *\n+     * Returns either the Java class name, or a CP index reference string.\n+     *\n+     *\/\n+    public String getClassName(int cpx) {\n+        String res = \"#\" + cpx;\n+        if (cpx == 0) {\n+            return res;\n+        }\n+        if (!inbounds(cpx)) {\n+            return res;\n+        }\n+        Constant cns = pool.get(cpx);\n+        if (cns == null || cns.tag != TAG.CONSTANT_CLASS) {\n+            return res;\n+        }\n+\n+        return getClassName((CPX) cns);\n+    }\n+\n+    \/**\n+     *\n+     * getClassName\n+     *\n+     * Safely gets a Java class name from a ConstantClass from a CPX2 constant pool\n+     * object. (eg. Method\/Field\/Interface Ref)\n+     *\n+     * Returns either the Java class name, or a CP index reference string.\n+     *\n+     *\/\n+    public String getClassName(CPX2 classConst) {\n+        return _getClassName(classConst.value1);\n+    }\n+\n+    \/**\n+     *\n+     * getClassName\n+     *\n+     * Safely gets a Java class name from a ConstantClass from a CPX constant pool object.\n+     * (eg. Class Ref)\n+     *\n+     * Returns either the Java class name, or a CP index reference string.\n+     *\n+     *\/\n+    public String getClassName(CPX classConst) {\n+        return _getClassName(classConst.value);\n+    }\n+\n+    \/**\n+     *\n+     * _getClassName\n+     *\n+     * Helper for getting class name. Checks bounds, does name conversion.\n+     *\n+     *\/\n+    private String _getClassName(int nameIndex) {\n+        String res = \"#\" + nameIndex;\n+        if (!inbounds(nameIndex)) {\n+            return res;\n+        }\n+        Constant nameconst = pool.get(nameIndex);\n+        if (nameconst == null || nameconst.tag != TAG.CONSTANT_UTF8) {\n+            return res;\n+        }\n+        CP_Str name = (CP_Str) nameconst;\n+\n+        String classname = name.value;\n+\n+        if (Utils.isClassArrayDescriptor(classname)) {\n+            classname = \"\\\"\" + classname + \"\\\"\";\n+        }\n+        return classname;\n+    }\n+\n+    \/**\n+     *\n+     * getShortClassName\n+     *\n+     * shortens a class name (if the class is in the given package). works with a\n+     * string-encoded classname.\n+     *\n+     *\/\n+    public String getShortClassName(String className, String pkgPrefix) {\n+        if (className.startsWith(pkgPrefix)) {\n+            return className.substring(pkgPrefix.length());\n+        }\n+        return className;\n+    }\n+\n+    \/**\n+     *\n+     * getShortClassName\n+     *\n+     * shortens a class name (if the class is in the given package). works with a CP index\n+     * to a ConstantClass.\n+     *\n+     *\/\n+    public String getShortClassName(int cpx, String pkgPrefix) {\n+        String name = Utils.javaName(getClassName(cpx));\n+        return getShortClassName(name, pkgPrefix);\n+    }\n+\n+    \/**\n+     *\n+     * decodeClassDescriptor\n+     *\n+     * Pulls the class name out of a string (at the CP index). (drops any array\n+     * descriptors, and the class descriptors (\"L\" and \";\")\n+     *\n+     *\/\n+    public String decodeClassDescriptor(int cpx) {\n+        \/\/ enum type is encoded as a descriptor\n+        \/\/ need to remove '\"'s and L (class descriptor)\n+\n+        \/\/ TODO: might have to count '['s at the beginning for Arrays\n+        String rawEnumName = getName(cpx);\n+        int len = rawEnumName.length();\n+        int begin = (rawEnumName.startsWith(\"\\\"L\")) ? 2 : 0;\n+        int end = (begin > 0) ? len - 2 : len;\n+        return rawEnumName.substring(begin, end);\n+    }\n+\n+    \/**\n+     *\n+     * subtagToString\n+     *\n+     * Getter that safely gets the string descriptor of a subtag\n+     *\n+     *\/\n+    private String subtagToString(int subtag) {\n+        SUBTAG st = subtaghash.get((byte) subtag);\n+        if (st == null) {\n+            return \"BOGUS_SUBTAG:\" + subtag;\n+        }\n+        return st.tagname;\n+    }\n+\n+    \/**\n+     *\n+     * StringValue\n+     *\n+     * Safely gets the string value of any Constant at any CP index.\n+     *\n+     *\/\n+    public String StringValue(int cpx) {\n+        if (cpx == 0) {\n+            return \"#0\";\n+        }\n+        if (!inbounds(cpx)) {\n+            return \"<Incorrect CP index:\" + cpx + \">\";\n+        }\n+        Constant cnst = pool.get(cpx);\n+        if (cnst == null) {\n+            return \"<NULL>\";\n+        }\n+        return cnst.stringVal();\n+    }\n+\n+    \/**\n+     * ConstantStrValue\n+     *\n+     * Safely gets the string value of any Constant at any CP index. This string is either\n+     * a Constant's String value, or a CP index reference string. The Constant string has\n+     * a tag descriptor in the beginning.\n+     *\n+     *\/\n+    public String ConstantStrValue(int cpx) {\n+        if (cpx == 0) {\n+            return \"#0\";\n+        }\n+        if (!inbounds(cpx)) {\n+            return \"#\" + cpx;\n+        }\n+        Constant cns = pool.get(cpx);\n+        if (cns == null) {\n+            return \"#\" + cpx;\n+        }\n+        if (cns instanceof CPX2) {\n+            CPX2 cns2 = (CPX2) cns;\n+            if (cns2.value1 == cd.this_cpx && cns2.refersClassMember()) {\n+                cpx = cns2.value2;\n+            }\n+        }\n+        return cns.tag.tagname + \" \" + StringValue(cpx);\n+    }\n+\n+    \/**\n+     * prints the entire constant pool.\n+     *\/\n+    public void print(PrintWriter out) throws IOException {\n+        int cpx = 0;\n+        for (Constant cns : pool) {\n+            if (cpx == 0) {\n+                cpx += 1;\n+                continue;\n+            }\n+\n+            out.print(\"\\tconst #\" + cpx + \" = \");\n+\n+            if (cns == null) {\n+                \/\/ do something\n+                out.println(\"null\");\n+                cpx += 1;\n+            } else {\n+                cns.print(out);\n+                cpx += cns.size();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * prints the Constant value at a given CP index.\n+     *\/\n+    void PrintConstant(PrintWriter out, int cpx) {\n+        out.print(ConstantStrValue(cpx));\n+    }\n+\n+    \/**\n+     * prints a constant value, with the print format based on the print options.\n+     *\/\n+    public void printlnClassId(PrintWriter out, int cpx) throws IOException {\n+        printlnClassId(out, cpx, false);\n+    }\n+\n+    public void printlnClassId(PrintWriter out, int cpx, boolean addComma) throws IOException {\n+        if (!cd.options.contains(Options.PR.CPX)) {\n+            out.print(getShortClassName(cpx, cd.pkgPrefix) + (addComma ? \",\" : \"\"));\n+        } else {\n+            out.print(\"\\t#\" + cpx + (addComma ? \",\" : \"\") + \" \/\/\");\n+            PrintConstant(out, cpx);\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/ConstantPool.java","additions":1073,"deletions":0,"binary":false,"changes":1073,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.JasmTokens;\n+import org.openjdk.asmtools.jasm.Modifiers;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jasm.Tables.AttrTag;\n+import static org.openjdk.asmtools.jasm.Tables.CF_Context;\n+import static org.openjdk.asmtools.jdis.TraceUtils.traceln;\n+\n+\/**\n+ * Field data for field members in a class of the Java Disassembler\n+ *\/\n+public class FieldData extends MemberData {\n+\n+    \/\/ CP index to the field name\n+    protected int name_cpx;\n+    \/\/ CP index to the field type\n+    protected int type_cpx;\n+    \/\/ CP index to the field value\n+    protected int value_cpx = 0;\n+\n+    public FieldData(ClassData cls) {\n+        super(cls);\n+        memberType = \"FieldData\";\n+    }\n+\n+    @Override\n+    protected boolean handleAttributes(DataInputStream in, AttrTag attrtag, int attrlen) throws IOException {\n+        \/\/ Read the Attributes\n+        boolean handled = true;\n+        switch (attrtag) {\n+            case ATT_Signature:\n+                if( signature != null ) {\n+                    traceln(\"Record attribute:  more than one attribute Signature are in component.attribute_info_attributes[attribute_count]\");\n+                    traceln(\"Last one will be used.\");\n+                }\n+                signature = new SignatureData(cls).read(in, attrlen);\n+                break;\n+            case ATT_ConstantValue:\n+                if (attrlen != 2) {\n+                    throw new ClassFormatError(format(\"%s: Invalid attribute length #%d\", AttrTag.ATT_ConstantValue.printval(), attrlen));\n+                }\n+                value_cpx = in.readUnsignedShort();\n+                break;\n+            default:\n+                handled = false;\n+                break;\n+        }\n+        return handled;\n+    }\n+\n+    \/**\n+     * Read and resolve the field data called from ClassData.\n+     * Precondition: NumFields has already been read from the stream.\n+     *\/\n+    public void read(DataInputStream in) throws IOException {\n+        \/\/ read the Fields CP indexes\n+        access = in.readUnsignedShort();\n+        name_cpx = in.readUnsignedShort();\n+        type_cpx = in.readUnsignedShort();\n+        \/\/ Read the attributes\n+        readAttributes(in);\n+        \/\/\n+        TraceUtils.traceln(2,\n+                format(\"FieldData: name[%d]=%s type[%d]=%s%s\",\n+                        name_cpx, cls.pool.getString(name_cpx),\n+                        type_cpx, cls.pool.getString(type_cpx),\n+                        signature != null ? signature : \"\"));\n+    }\n+\n+\n+    \/**\n+     * Prints the field data to the current output stream. called from ClassData.\n+     *\/\n+    @Override\n+    public void print() throws IOException {\n+        \/\/ Print annotations first\n+        super.printAnnotations(getIndentString());\n+\n+        StringBuilder bodyPrefix = new StringBuilder(getIndentString()).append(Modifiers.accessString(access, CF_Context.CTX_FIELD));\n+        StringBuilder tailPrefix = new StringBuilder();\n+\n+        if (isSynthetic) {\n+            bodyPrefix.append(JasmTokens.Token.SYNTHETIC.parseKey()).append(' ');\n+        }\n+        if (isDeprecated) {\n+            bodyPrefix.append(JasmTokens.Token.DEPRECATED.parseKey()).append(' ');\n+        }\n+\n+        \/\/ field\n+        bodyPrefix.append(JasmTokens.Token.FIELDREF.parseKey()).append(' ');\n+\n+        if (value_cpx != 0) {\n+            tailPrefix.append(\"\\t= \").append(cls.pool.ConstantStrValue(value_cpx));\n+        }\n+\n+        printVar(bodyPrefix, tailPrefix,name_cpx, type_cpx);\n+    }\n+} \/\/ end FieldData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/FieldData.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+public class Indenter {\n+\n+    private int indentLength;\n+\n+    public Indenter(int indentLength) {\n+        this.indentLength = indentLength;\n+    }\n+\n+    public Indenter() {\n+        this.indentLength = Options.BODY_INDENT;\n+    }\n+    \/**\n+     * Returns current indentation length.\n+     *\n+     * @return current indentation length.\n+     *\/\n+    public int indent() {\n+        return indentLength;\n+    }\n+\n+    \/**\n+     * Increases indentation length.\n+     *\n+     * @param indentLength new indent length\n+     *\n+     * @throws IllegalArgumentException if indentLength is negative.\n+     *\/\n+    public Indenter setIndent(int indentLength) {\n+        if (indentLength < 0) {\n+            throw new IllegalArgumentException(\"indent length can't be negative\");\n+        }\n+        this.indentLength = indentLength;\n+        return this;\n+    }\n+\n+    \/**\n+     * Increases indentation length.\n+     *\n+     * @param increase length to increase by.\n+     *\n+     * @throws IllegalArgumentException if increase is negative.\n+     *\/\n+    public Indenter increaseIndent(int increase) {\n+        if (increase < 0) {\n+            throw new IllegalArgumentException(\"indent length can't be negative\");\n+        }\n+        setIndent(indent() + increase);\n+        return this;\n+    }\n+\n+    \/**\n+     * Decreases indentation length.\n+     *\n+     * @param decrease length to decrease by\n+     *\n+     * @throws IllegalArgumentException if decrease is negative, or if decrease is greater than\n+     *                                  {@link #indent() current indentation length}.\n+     *\/\n+    public Indenter decreaseIndent(int decrease) {\n+        if (decrease < 0) {\n+            throw new IllegalArgumentException(\"decrease can't be negative\");\n+        }\n+        setIndent(indent() - decrease);\n+        return this;\n+    }\n+\n+    \/**\n+     * Creates indent string based on current indent size.\n+     *\/\n+    public String getIndentString() {\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < indent(); i++) {\n+            sb.append(' ');\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/Indenter.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import org.openjdk.asmtools.jasm.Modifiers;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+\/**\n+ *\n+ *\/\n+class InnerClassData extends Indenter {\n+\n+    ClassData cls;\n+    int inner_class_info_index;\n+    int outer_class_info_index;\n+    int inner_name_index;\n+    int access;\n+    \/*-------------------------------------------------------- *\/\n+\n+    public InnerClassData(ClassData cls) {\n+        this.cls = cls;\n+    }\n+\n+    public void read(DataInputStream in) throws IOException {\n+        inner_class_info_index = in.readUnsignedShort();\n+        outer_class_info_index = in.readUnsignedShort();\n+        inner_name_index = in.readUnsignedShort();\n+        access = in.readUnsignedShort();\n+    }  \/\/ end read\n+\n+    public void print() throws IOException {\n+        boolean pr_cpx = Options.OptionObject().contains(Options.PR.CPX);\n+        cls.out.print(getIndentString() + Modifiers.accessString(access, CF_Context.CTX_INNERCLASS));\n+        cls.out.print(\"InnerClass \");\n+        if (pr_cpx) {\n+            if (inner_name_index != 0) {\n+                cls.out.print(\"#\" + inner_name_index + \"= \");\n+            }\n+            cls.out.print(\"#\" + inner_class_info_index);\n+            if (outer_class_info_index != 0) {\n+                cls.out.print(\" of #\" + outer_class_info_index);\n+            }\n+            cls.out.print(\"; \/\/ \");\n+        }\n+        if (inner_name_index != 0) {\n+            cls.out.print(cls.pool.getName(inner_name_index) + \"=\");\n+        }\n+        if (inner_class_info_index != 0) {\n+            cls.pool.PrintConstant(cls.out, inner_class_info_index);\n+        }\n+        if (outer_class_info_index != 0) {\n+            cls.out.print(\" of \");\n+            cls.pool.PrintConstant(cls.out, outer_class_info_index);\n+        }\n+        if (pr_cpx) {\n+            cls.out.println();\n+        } else {\n+            cls.out.println(\";\");\n+        }\n+    }\n+} \/\/ end InnerClassData\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/InnerClassData.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.common.Tool;\n+import org.openjdk.asmtools.util.I18NResourceBundle;\n+import org.openjdk.asmtools.util.ProductInfo;\n+\n+import java.io.DataInputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ * Main program of the Java Disassembler :: class to jasm\n+ *\/\n+public class Main extends Tool {\n+\n+    private Options options;\n+\n+    public static final I18NResourceBundle i18n\n+            = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    public  Main(PrintWriter out, PrintWriter err, String programName) {\n+        super(out, err, programName);\n+        \/\/ tool specific initialization\n+        options = Options.OptionObject();\n+        DebugFlag = () -> options.contains(Options.PR.DEBUG);\n+        printCannotReadMsg = (fname) -> error( i18n.getString(\"jdis.error.cannot_read\", fname));\n+    }\n+\n+    public Main(PrintStream out, String program) {\n+        this(new PrintWriter(out), new PrintWriter(System.err), program);\n+    }\n+\n+    @Override\n+    public void usage() {\n+        println(i18n.getString(\"jdis.usage\"));\n+        println(i18n.getString(\"jdis.opt.g\"));\n+        println(i18n.getString(\"jdis.opt.sl\"));\n+        println(i18n.getString(\"jdis.opt.hx\"));\n+        println(i18n.getString(\"jdis.opt.v\"));\n+        println(i18n.getString(\"jdis.opt.version\"));\n+    }\n+\n+    \/**\n+     * Run the disassembler\n+     *\/\n+    public synchronized boolean  disasm(String argv[]) {\n+        ArrayList<String> files = new ArrayList<>();\n+\n+        \/\/ Parse arguments\n+        for (int i = 0; i < argv.length; i++) {\n+            String arg = argv[i];\n+            switch (arg) {\n+                case \"-g\":\n+                    options.setCodeOptions();\n+                    break;\n+                case \"-v\":\n+                    options.set(Options.PR.DEBUG);\n+                    break;\n+                case \"-sl\":\n+                    options.set(Options.PR.SRC);\n+                    break;\n+                case \"-hx\":\n+                    options.set(Options.PR.HEX);\n+                    break;\n+                case \"-version\":\n+                    out.println(ProductInfo.FULL_VERSION);\n+                    break;\n+                default:\n+                    if (arg.startsWith(\"-\")) {\n+                        error(i18n.getString(\"jdis.error.invalid_option\", arg));\n+                        usage();\n+                        return false;\n+                    } else {\n+                        files.add(arg);\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        if (files.isEmpty()) {\n+            usage();\n+            return false;\n+        }\n+\n+        for (String fname : files) {\n+            if (fname == null) {\n+                continue;\n+            } \/\/ cross out by CompilerChoice.compile\n+            try {\n+                ClassData cc = new ClassData(out, this);\n+                cc.read(fname);\n+                cc.print();\n+                out.flush();\n+                continue;\n+            } catch (Error ee) {\n+                if (DebugFlag.getAsBoolean())\n+                    ee.printStackTrace();\n+                error(i18n.getString(\"jdis.error.fatal_error\", fname));\n+            } catch (Exception ee) {\n+                if (DebugFlag.getAsBoolean())\n+                    ee.printStackTrace();\n+                error(i18n.getString(\"jdis.error.fatal_exception\", fname));\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Main program\n+     *\/\n+    public static void main(String argv[]) {\n+        Main disassembler = new Main(new PrintWriter(new uEscWriter(System.out)), new PrintWriter(System.err), \"jdis\");\n+        boolean result = disassembler.disasm(argv);\n+        System.exit(result ? 0 : 1);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/Main.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.Tables;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+import static java.lang.String.format;\n+\n+\/**\n+ * Base class for ClassData, MethodData, FieldData and RecordData(JEP 360)\n+ *\/\n+public abstract class MemberData extends Indenter {\n+\n+    \/\/ access flags (modifiers)\n+    protected int access;\n+\n+    \/\/ flags\n+    protected boolean isSynthetic = false;\n+    protected boolean isDeprecated = false;\n+\n+    \/\/ Signature can be located in ClassFile, field_info, method_info, and component_info\n+    protected SignatureData signature;\n+\n+    \/**\n+     * The visible annotations for this class, member( field or method) or record component\n+     *\/\n+    protected ArrayList<AnnotationData> visibleAnnotations;\n+\n+    \/**\n+     * The invisible annotations for this class, member( field or method) or record component\n+     *\/\n+    protected ArrayList<AnnotationData> invisibleAnnotations;\n+\n+    \/**\n+     * The visible annotations for this class, member( field or method) or record component\n+     *\/\n+    protected ArrayList<TypeAnnotationData> visibleTypeAnnotations;\n+\n+    \/**\n+     * The invisible annotations for this class, member( field or method) or record component\n+     *\/\n+    protected ArrayList<TypeAnnotationData> invisibleTypeAnnotations;\n+\n+    \/**\n+     * The remaining attributes of this class, member( field or method) or record component\n+     *\/\n+    protected ArrayList<AttrData> attrs;\n+\n+    \/\/ internal references\n+    protected final Options options = Options.OptionObject();\n+    protected final  boolean pr_cpx = options.contains(Options.PR.CPX);;\n+    protected ClassData cls;\n+    protected PrintWriter out;\n+    protected String memberType = \"\";\n+\n+    public MemberData(ClassData cls) {\n+        this();\n+        init(cls);\n+    }\n+\n+    public MemberData() {\n+    }\n+\n+    public void init(ClassData cls) {\n+        this.out = cls.out;\n+        this.cls = cls;\n+    }\n+\n+    protected boolean handleAttributes(DataInputStream in, Tables.AttrTag attrtag, int attrlen) throws IOException {\n+        \/\/ sub-classes override\n+        return false;\n+    }\n+\n+    protected abstract void print() throws IOException;\n+\n+    final protected int getAnnotationsCount() {\n+        return  ((visibleAnnotations == null) ? 0 : visibleAnnotations.size()) +\n+                ((invisibleAnnotations == null) ? 0 : invisibleAnnotations.size()) +\n+                ((visibleTypeAnnotations == null) ? 0 : visibleTypeAnnotations.size()) +\n+                ((invisibleTypeAnnotations == null) ? 0 : invisibleTypeAnnotations.size());\n+\n+    }\n+\n+    final protected void printAnnotations(String initialTab) {\n+        if( getAnnotationsCount() > 0 ) {\n+            if (visibleAnnotations != null) {\n+                for (AnnotationData visad : visibleAnnotations) {\n+                    \/\/ out.print(initialTab);\n+                    visad.print(out, initialTab);\n+                    out.println();\n+                }\n+            }\n+            if (invisibleAnnotations != null) {\n+                for (AnnotationData invisad : invisibleAnnotations) {\n+                    invisad.print(out, initialTab);\n+                    out.println();\n+                }\n+            }\n+\n+            if (visibleTypeAnnotations != null) {\n+                for (TypeAnnotationData visad : visibleTypeAnnotations) {\n+                    visad.print(out, initialTab);\n+                    out.println();\n+                }\n+            }\n+            if (invisibleTypeAnnotations != null) {\n+                for (TypeAnnotationData invisad : invisibleTypeAnnotations) {\n+                    invisad.print(out, initialTab);\n+                    out.println();\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void printVar(StringBuilder bodyPrefix, StringBuilder tailPrefix, int name_cpx, int type_cpx) {\n+        if( pr_cpx ) {\n+            bodyPrefix.append('#').append(name_cpx).append(\":#\").append(type_cpx);\n+            tailPrefix.append(\";\\t \/\/ \").append(cls.pool.getName(name_cpx)).append(':').append(cls.pool.getName(type_cpx));\n+\n+        } else {\n+            bodyPrefix.append(cls.pool.getName(name_cpx)).append(':').append(cls.pool.getName(type_cpx));\n+            tailPrefix.append(';');\n+        }\n+\n+        if (signature != null) {\n+            signature.print(bodyPrefix.append(':').toString(), tailPrefix.append( pr_cpx ? \":\" : \"\" ).toString());\n+        } else {\n+            out.print(bodyPrefix);\n+            out.print(tailPrefix);\n+        }\n+        out.println();\n+    }\n+\n+    protected void readAttributes(DataInputStream in) throws IOException {\n+        \/\/ Read the Attributes\n+        int natt = in.readUnsignedShort();\n+        attrs = new ArrayList<>(natt);\n+        TraceUtils.traceln(format(\"%s - Attributes[%d]\", memberType , natt));\n+        AttrData attr;\n+        for (int k = 0; k < natt; k++) {\n+            int name_cpx = in.readUnsignedShort();\n+            attr = new AttrData(cls);\n+            attrs.add(attr);\n+            String attr_name = cls.pool.getString(name_cpx);\n+            TraceUtils.traceln(format(\"   #%d name[%d]=\\\"%s\\\"\", k, name_cpx, attr_name));\n+            Tables.AttrTag tag = Tables.attrtag(attr_name);\n+            int attrlen = in.readInt();\n+            switch (tag) {\n+                case ATT_Synthetic:\n+                    \/\/ Read Synthetic Attr\n+                    if (attrlen != 0) {\n+                        throw new ClassFormatError(\"invalid Synthetic attr length\");\n+                    }\n+                    isSynthetic = true;\n+                    break;\n+                case ATT_Deprecated:\n+                    \/\/ Read Deprecated Attr\n+                    if (attrlen != 0) {\n+                        throw new ClassFormatError(\"invalid Deprecated attr length\");\n+                    }\n+                    isDeprecated = true;\n+                    break;\n+                case ATT_RuntimeVisibleAnnotations:\n+                case ATT_RuntimeInvisibleAnnotations:\n+                    \/\/ Read Annotations Attr\n+                    int cnt = in.readShort();\n+                    ArrayList<AnnotationData> annots = new ArrayList<>(cnt);\n+                    boolean invisible = (tag == Tables.AttrTag.ATT_RuntimeInvisibleAnnotations);\n+                    for (int i = 0; i < cnt; i++) {\n+                        TraceUtils.traceln(\"      AnnotationData: #\" + i);\n+                        AnnotationData annot = new AnnotationData(invisible, cls);\n+                        annot.read(in);\n+                        annots.add(annot);\n+                    }\n+\n+                    if (invisible) {\n+                        invisibleAnnotations = annots;\n+                    } else {\n+                        visibleAnnotations = annots;\n+                    }\n+                    break;\n+                case ATT_RuntimeVisibleTypeAnnotations:\n+                case ATT_RuntimeInvisibleTypeAnnotations:\n+                    \/\/ Read Type Annotations Attr\n+                    int tcnt = in.readShort();\n+                    ArrayList<TypeAnnotationData> tannots = new ArrayList<>(tcnt);\n+                    boolean tinvisible = (tag == Tables.AttrTag.ATT_RuntimeInvisibleTypeAnnotations);\n+                    for (int tindex = 0; tindex < tcnt; tindex++) {\n+                        TraceUtils.traceln(\"      TypeAnnotationData: #\" + tindex);\n+                        TypeAnnotationData tannot = new TypeAnnotationData(tinvisible, cls);\n+                        tannot.read(in);\n+                        tannots.add(tannot);\n+                    }\n+\n+                    if (tinvisible) {\n+                        invisibleTypeAnnotations = tannots;\n+                    } else {\n+                        visibleTypeAnnotations = tannots;\n+                    }\n+                    break;\n+                default:\n+                    boolean handled = handleAttributes(in, tag, attrlen);\n+                    if (!handled) {\n+                        attr.read(name_cpx, attrlen, in);\n+                    }\n+                    break;\n+\n+            }\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/MemberData.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,329 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.Modifiers;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+import static org.openjdk.asmtools.jasm.JasmTokens.Token;\n+import static org.openjdk.asmtools.jasm.Tables.AttrTag;\n+import static org.openjdk.asmtools.jasm.Tables.CF_Context;\n+\n+\/**\n+ * Method data for method members in a class of the Java Disassembler\n+ *\/\n+public class MethodData extends MemberData {\n+\n+    \/**\n+     * CP index to the method name\n+     *\/\n+    protected int name_cpx;\n+\n+    \/**\n+     * CP index to the method type\n+     *\/\n+    protected int sig_cpx;\n+    protected String lP;        \/\/ labelPrefix\n+    \/**\n+     * The parameter names for this method\n+     *\/\n+    protected ArrayList<ParamNameData> paramNames;\n+    \/**\n+     * The visible parameter annotations for this method\n+     *\/\n+    protected ParameterAnnotationData visibleParameterAnnotations;\n+    \/**\n+     * The invisible parameter annotations for this method\n+     *\/\n+    protected ParameterAnnotationData invisibleParameterAnnotations;\n+    \/**\n+     * The invisible parameter annotations for this method\n+     *\/\n+    protected AnnotationElement.AnnotValue defaultAnnotation;\n+    \/**\n+     * The code data for this method. May be null\n+     *\/\n+    private CodeData code;\n+    \/**\n+     * The exception table (thrown exceptions) for this method. May be null\n+     *\/\n+    private int[] exc_table = null;\n+\n+    public MethodData(ClassData cls) {\n+        super(cls);\n+        memberType = \"MethodData\";\n+        lP = (options.contains(Options.PR.LABS)) ? \"L\" : \"\";\n+        paramNames = null;\n+    }\n+\n+    \/*========================================================*\/\n+    \/* Read Methods *\/\n+    @Override\n+    protected boolean handleAttributes(DataInputStream in, AttrTag attrtag, int attrlen) throws IOException {\n+        \/\/ Read the Attributes\n+        boolean handled = true;\n+        switch (attrtag) {\n+            case ATT_Code:\n+                code = new CodeData(this);\n+                code.read(in, attrlen);\n+                break;\n+            case ATT_Exceptions:\n+                readExceptions(in);\n+                break;\n+            case ATT_MethodParameters:\n+                readMethodParameters(in);\n+                break;\n+            case ATT_RuntimeVisibleParameterAnnotations:\n+            case ATT_RuntimeInvisibleParameterAnnotations:\n+                boolean invisible = (attrtag == AttrTag.ATT_RuntimeInvisibleParameterAnnotations);\n+                ParameterAnnotationData pannots = new ParameterAnnotationData(cls, invisible);\n+                pannots.read(in);\n+                if (invisible) {\n+                    invisibleParameterAnnotations = pannots;\n+                } else {\n+                    visibleParameterAnnotations = pannots;\n+                }\n+                break;\n+            case ATT_AnnotationDefault:\n+                defaultAnnotation = AnnotationElement.readValue(in, cls, false);\n+                break;\n+            default:\n+                handled = false;\n+                break;\n+        }\n+        return handled;\n+    }\n+\n+    \/**\n+     * read\n+     * read and resolve the method data called from ClassData.\n+     * Precondition: NumFields has already been read from the stream.\n+     *\/\n+    public void read(DataInputStream in) throws IOException {\n+        \/\/ read the Methods CP indexes\n+        access = in.readUnsignedShort(); \/\/ & MM_METHOD; \/\/ Q\n+        name_cpx = in.readUnsignedShort();\n+        sig_cpx = in.readUnsignedShort();\n+        TraceUtils.traceln(2,\"MethodData: {modifiers}: \" + Modifiers.toString(access, CF_Context.CTX_METHOD),\n+                            \"      MethodData: name[\" + name_cpx + \"]=\" + cls.pool.getString(name_cpx) + \" sig[\" + sig_cpx + \"]=\" + cls.pool.getString(sig_cpx));\n+        \/\/ Read the attributes\n+        readAttributes(in);\n+    }\n+\n+    private void readExceptions(DataInputStream in) throws IOException {\n+        \/\/ this is not really a CodeAttr attribute, it's part of the CodeAttr\n+        int exc_table_len = in.readUnsignedShort();\n+        TraceUtils.traceln(3,\"ExceptionsAttr[\" + exc_table_len + \"]\");\n+        exc_table = new int[exc_table_len];\n+        for (int l = 0; l < exc_table_len; l++) {\n+            int exc = in.readShort();\n+            TraceUtils.traceln(4,\"throws:#\" + exc);\n+            exc_table[l] = exc;\n+        }\n+    }\n+\n+    private void readMethodParameters(DataInputStream in) throws IOException {\n+        \/\/ this is not really a CodeAttr attribute, it's part of the CodeAttr\n+        int num_params = in.readUnsignedByte();\n+        TraceUtils.traceln(3,\"MethodParametersAttr[\" + num_params + \"]\");\n+        paramNames = new ArrayList<>(num_params);\n+        for (int l = 0; l < num_params; l++) {\n+            short pname_cpx = (short) in.readUnsignedShort();\n+            int paccess = in.readUnsignedShort();\n+            TraceUtils.traceln(4,\"P[\" + l + \"] ={ name[\" + pname_cpx + \"]: \" + cls.pool.getString(pname_cpx)\n+                    + \" modifiers [\" + paccess + \"]: \" + Modifiers.toString(paccess, CF_Context.CTX_METHOD) + \"}\");\n+            paramNames.add(l, new ParamNameData(pname_cpx, paccess));\n+        }\n+    }\n+\n+    \/**\n+     * printPAnnotations\n+     * <p>\n+     * prints the parameter annotations for this method. called from CodeAttr (since JASM\n+     * code integrates the PAnnotation Syntax inside the method body).\n+     *\/\n+    \/\/ This is called from the CodeAttr\n+    public void printPAnnotations() throws IOException {\n+        int visSize = 0;\n+        int invisSize = 0;\n+        int pNumSize = 0;\n+\n+        if (visibleParameterAnnotations != null) {\n+            visSize = visibleParameterAnnotations.numParams();\n+        }\n+        if (invisibleParameterAnnotations != null) {\n+            invisSize = invisibleParameterAnnotations.numParams();\n+        }\n+        if (paramNames != null) {\n+            pNumSize = paramNames.size();\n+        }\n+\n+        int maxParams;\n+        maxParams = (pNumSize > invisSize) ? pNumSize : invisSize;\n+        maxParams = (visSize > maxParams) ? visSize : maxParams;\n+\n+        for (int paramNum = 0; paramNum < maxParams; paramNum++) {\n+            ArrayList<AnnotationData> visAnnots = null;\n+            if (visibleParameterAnnotations != null && paramNum < visSize) {\n+                visAnnots = visibleParameterAnnotations.get(paramNum);\n+            }\n+            ArrayList<AnnotationData> invisAnnots = null;\n+            if (invisibleParameterAnnotations != null && paramNum < invisSize) {\n+                invisAnnots = invisibleParameterAnnotations.get(paramNum);\n+            }\n+            ParamNameData pname = (paramNames == null) ? null : paramNames.get(paramNum);\n+\n+            boolean nullAnnots = ((visAnnots == null) && (invisAnnots == null));\n+            if (pname != null && pname.name_cpx == 0) {\n+                pname = null;\n+            }\n+\n+            \/\/ Print the Param number (header)\n+            if ((pname != null) || !nullAnnots) {\n+                out.print(\"\\t\" + paramNum + \": \");\n+            } else {\n+                continue;\n+            }\n+\n+            boolean firstTime = true;\n+\n+            \/\/ Print the Parameter name\n+            if (pname != null) {\n+                out.print(Token.PARAM_NAME.parseKey());\n+                out.print(Token.LBRACE.parseKey());\n+                out.print(cls.pool.getString(pname.name_cpx));\n+                out.print(\" \");\n+                out.print(Modifiers.toString(pname.access, CF_Context.CTX_METHOD));\n+                out.print(Token.RBRACE.parseKey());\n+                out.print(\" \");\n+            }\n+\n+            \/\/ Print any visible param annotations\n+            if (visAnnots != null) {\n+                for (AnnotationData annot : visAnnots) {\n+                    if (!firstTime) {\n+                        out.print(\"\\t   \");\n+                    }\n+                    annot.print(out, getIndentString());\n+\/\/                    out.println();\n+                    firstTime = false;\n+                }\n+            }\n+\n+            \/\/ Print any invisible param annotations\n+            if (invisAnnots != null) {\n+                for (AnnotationData annot : invisAnnots) {\n+                    if (!firstTime) {\n+                        out.print(\"\\t   \");\n+                    }\n+                    annot.print(out, getIndentString());\n+\/\/                    out.println();\n+                    firstTime = false;\n+                }\n+            }\n+\n+            \/\/ Reset the line, if there were parameters\n+            if ((pname != null) || !nullAnnots) {\n+                out.println();\n+            }\n+\n+        }\n+\n+    }\n+\n+    \/**\n+     * Prints the method data to the current output stream. called from ClassData.\n+     *\/\n+    @Override\n+    public void print() throws IOException {\n+\n+        printAnnotations(getIndentString());\n+\n+        out.print(getIndentString() + Modifiers.accessString(access, CF_Context.CTX_METHOD));\n+\n+        if (isSynthetic) {\n+            out.print(Token.SYNTHETIC.parseKey() + \" \");\n+        }\n+        if (isDeprecated) {\n+            out.print(Token.DEPRECATED.parseKey() + \" \");\n+        }\n+        out.print(Token.METHODREF.parseKey() + \" \");\n+\n+        if (pr_cpx) {\n+            \/\/ print the CPX method descriptor\n+            out.print(\"#\" + name_cpx + \":#\" + sig_cpx +\n+                    ((code == null && exc_table == null && defaultAnnotation == null) ? \";\" : \"\") +\n+                    \"\\t \/\/ \" + cls.pool.getName(name_cpx) + \":\" + cls.pool.getName(sig_cpx));\n+        } else {\n+            out.print(cls.pool.getName(name_cpx) + \":\" + cls.pool.getName(sig_cpx) +\n+                    ((code == null && exc_table == null && defaultAnnotation == null) ? \";\" : \"\"));\n+        }\n+        \/\/ followed by default annotation\n+        if (defaultAnnotation != null) {\n+            out.print(\" default { \");\n+            defaultAnnotation.print(out, getIndentString());\n+            out.print(\" }\" + ((code == null && exc_table == null) ? \";\" : \" \"));\n+        }\n+        \/\/ followed by exception table\n+        printExceptionTable();\n+\n+        if (code != null) {\n+            code.print();\n+        } else {\n+            if( exc_table != null ) {\n+                out.print(';');\n+            }\n+            out.println();\n+        }\n+    }\n+\n+    private void printExceptionTable() {\n+        if (exc_table != null) {\n+            out.print(\"\\n\\tthrows \");\n+            int len = exc_table.length;\n+            for (int exceptNum = 0; exceptNum < len; exceptNum++) {\n+                out.print(cls.pool.getClassName(exc_table[exceptNum]));\n+                if (exceptNum < len - 1) {\n+                    out.print(\", \");\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * MethodParamData\n+     *\/\n+    class ParamNameData {\n+\n+        public int access;\n+        public int name_cpx;\n+\n+        public ParamNameData(int name, int access) {\n+            this.access = access;\n+            this.name_cpx = name;\n+        }\n+    }\n+} \/\/ end MethodData\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/MethodData.java","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.*;\n+\n+import org.openjdk.asmtools.common.Module;\n+import org.openjdk.asmtools.common.Tool;\n+import org.openjdk.asmtools.jasm.JasmTokens;\n+\n+import static org.openjdk.asmtools.jdis.Main.i18n;\n+\n+\/**\n+ *  The module attribute data.\n+ *\/\n+public class ModuleData {\n+\n+  \/\/ internal references\n+  private final Tool tool;\n+\n+  private ConstantPool pool;\n+  private PrintWriter out;\n+  private Module module;\n+\n+  public ModuleData(ClassData clsData) {\n+    this.tool = clsData.tool;\n+    this.pool = clsData.pool;\n+    this.out = clsData.out;\n+  }\n+\n+  public String getModuleName() {\n+    return module == null ? \"N\/A\" : module.getModuleName();\n+  }\n+\n+  public String getModuleVersion() { return module.getModuleVersion();  }\n+\n+  public String getModuleHeader() {\n+    if ( module == null ) {\n+      return \"N\/A\";\n+    } else {\n+      StringBuilder sb = new StringBuilder(module.getModuleFlags());\n+      sb.append(JasmTokens.Token.MODULE.parseKey()).append(\" \");\n+      sb.append(module.getModuleName());\n+      if (module.getModuleVersion() != null)\n+        sb.append(\"\/\/ @\").append(module.getModuleVersion());\n+      return sb.toString();\n+    }\n+  }\n+\n+  \/**\n+   * Reads and resolve the method's attribute data called from ClassData.\n+   *\/\n+  public void read(DataInputStream in) throws IOException {\n+    int index, moduleFlags, versionIndex;\n+    String moduleName, version;\n+    Module.Builder builder;\n+    try {\n+    \/\/ u2 module_name_index;\n+    index = in.readUnsignedShort();\n+    moduleName = pool.getModule(index);\n+    \/\/ u2 module_flags;\n+    moduleFlags = in.readUnsignedShort();\n+    \/\/ u2 module_version_index;\n+    versionIndex = in.readUnsignedShort();\n+    version = pool.getString(versionIndex);\n+    builder = new Module.Builder(moduleName, moduleFlags, version);\n+    } catch (IOException ioe) {\n+      tool.error(i18n.getString(\"jdis.error.invalid_header\"));\n+      throw ioe;\n+    }\n+\n+    try {\n+      int requires_count = in.readUnsignedShort();\n+      for (int i = 0; i < requires_count; i++) {\n+        index = in.readUnsignedShort();\n+        int requiresFlags = in.readUnsignedShort();\n+        versionIndex = in.readUnsignedShort();\n+\n+        moduleName = pool.getModule(index);\n+        version = pool.getString(versionIndex);\n+        builder.require(moduleName, requiresFlags, version);\n+      }\n+    } catch (IOException ioe) {\n+      tool.error(i18n.getString(\"jdis.error.invalid_requires\"));\n+      throw ioe;\n+    }\n+\n+    try {\n+      int exports_count = in.readUnsignedShort();\n+      if (exports_count > 0) {\n+        for (int i = 0; i < exports_count; i++) {\n+          index = in.readUnsignedShort();\n+          String packageName = pool.getPackage(index);\n+          int exportsFlags = in.readUnsignedShort();\n+          int exports_to_count = in.readUnsignedShort();\n+          if (exports_to_count > 0) {\n+            Set<String> targets = new HashSet<>(exports_to_count);\n+            for (int j = 0; j < exports_to_count; j++) {\n+              int exports_to_index = in.readUnsignedShort();\n+              targets.add(pool.getModule(exports_to_index));\n+            }\n+            builder.exports(packageName, exportsFlags, targets);\n+          } else {\n+            builder.exports(packageName, exportsFlags);\n+          }\n+        }\n+      }\n+    } catch (IOException ioe) {\n+      tool.error(i18n.getString(\"jdis.error.invalid_exports\"));\n+      throw ioe;\n+    }\n+\n+    try {\n+      int opens_count = in.readUnsignedShort();\n+      if (opens_count > 0) {\n+        for (int i = 0; i < opens_count; i++) {\n+          index = in.readUnsignedShort();\n+          String packageName = pool.getPackage(index);\n+          int opensFlags = in.readUnsignedShort();\n+          int opens_to_count = in.readUnsignedShort();\n+          if (opens_to_count > 0) {\n+            Set<String> targets = new HashSet<>(opens_to_count);\n+            for (int j = 0; j < opens_to_count; j++) {\n+              int opens_to_index = in.readUnsignedShort();\n+              targets.add(pool.getModule(opens_to_index));\n+            }\n+            builder.opens(packageName, opensFlags, targets);\n+          } else {\n+            builder.opens(packageName, opensFlags);\n+          }\n+        }\n+      }\n+    } catch (IOException ioe) {\n+      tool.error(i18n.getString(\"jdis.error.invalid_opens\"));\n+      throw ioe;\n+    }\n+\n+    try {\n+      int uses_count = in.readUnsignedShort();\n+      if (uses_count > 0) {\n+        for (int i = 0; i < uses_count; i++) {\n+          index = in.readUnsignedShort();\n+          String serviceName = pool.getClassName(index);\n+          builder.uses(serviceName);\n+        }\n+      }\n+    } catch (IOException ioe) {\n+      tool.error(i18n.getString(\"jdis.error.invalid_uses\"));\n+      throw ioe;\n+    }\n+\n+    try {\n+      int provides_count = in.readUnsignedShort();\n+      if (provides_count > 0) {\n+        for (int i = 0; i < provides_count; i++) {\n+          index = in.readUnsignedShort();\n+          String serviceName = pool.getClassName(index);\n+          int provides_with_count = in.readUnsignedShort();\n+          Set<String> implNames = new HashSet<>(provides_with_count);\n+          for (int j = 0; j < provides_with_count; j++) {\n+            int provides_with_index = in.readUnsignedShort();\n+            implNames.add(pool.getClassName(provides_with_index));\n+          }\n+          builder.provides(serviceName, implNames);\n+        }\n+      }\n+    } catch (IOException ioe) {\n+      tool.error(i18n.getString(\"jdis.error.invalid_provides\"));\n+      throw ioe;\n+    }\n+    module = builder.build();\n+  }\n+\n+  \/* Print Methods *\/\n+  public void print() {\n+    if (module != null)\n+      out.println(module.toString());\n+  }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/ModuleData.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+\n+import org.openjdk.asmtools.jasm.JasmTokens;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * The NestHost attribute data\n+ * <p>\n+ * since class file 55.0 (JEP 181)\n+ *\/\n+public class NestHostData extends Indenter{\n+    ClassData cls;\n+    int host_class_index;\n+    private Options options = Options.OptionObject();\n+\n+    public NestHostData(ClassData cls) {\n+        this.cls = cls;\n+    }\n+\n+    public NestHostData read(DataInputStream in, int attribute_length) throws IOException, ClassFormatError {\n+        if (attribute_length != 2) {\n+            throw new ClassFormatError(\"ATT_NestHost: Invalid attribute length\");\n+        }\n+        host_class_index = in.readUnsignedShort();\n+        return this;\n+    }\n+\n+    public void print() {\n+        boolean pr_cpx = options.contains(Options.PR.CPX);\n+        cls.out.print(getIndentString() + JasmTokens.Token.NESTHOST.parseKey() + \" \");\n+        if (pr_cpx) {\n+            cls.out.print(\"#\" + host_class_index + \"; \/\/\");\n+        }\n+        if (pr_cpx) {\n+            cls.pool.PrintConstant(cls.out, host_class_index);\n+            cls.out.println();\n+        } else {\n+            cls.out.println(cls.pool.StringValue(host_class_index) + \";\");\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/NestHostData.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.JasmTokens;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * The NestMembers attribute data\n+ * <p>\n+ * JEP 181 (Nest-based Access Control): class file 55.0\n+ * NestMembers_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ *\/\n+public class NestMembersData extends ClassArrayData {\n+    public NestMembersData(ClassData cls) {\n+        super(cls, JasmTokens.Token.NESTMEMBERS.parseKey());\n+    }\n+\n+    public NestMembersData read(DataInputStream in, int attribute_length) throws IOException, ClassFormatError {\n+        return (NestMembersData) super.read(in, attribute_length);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/NestMembersData.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.util.EnumSet;\n+\n+\/**\n+ * The singleton class to share global options among jdis classes.\n+ *\/\n+public class Options {\n+\n+    public static final int BODY_INDENT = 2;\n+\n+    \/* Options Fields *\/\n+    private static Options ref;\n+\n+     public enum PR {\n+\n+        CP, \/\/ print Constant Pool\n+        LNT, \/\/ print Line Number table\n+        PC, \/\/ print Program Counter - for all instr\n+        LABS, \/\/ print Labels (as identifiers)\n+        CPX, \/\/ print CP index along with arguments\n+        SRC, \/\/ print Source Line as comment\n+        HEX, \/\/ print numbers as hexadecimals\n+        VAR, \/\/ print local variables declarations\n+        DEBUG;  \/\/ Debug flag\n+    };\n+\n+    static private final EnumSet<PR> JASM = EnumSet.<PR>of(PR.LABS); \/\/ default options\n+    static private final EnumSet<PR> CODE = EnumSet.<PR>of(\n+            PR.CP,\n+            PR.LNT,\n+            PR.PC,\n+            PR.CPX,\n+            PR.VAR\n+    );\n+\n+    static private EnumSet<PR> printOptions = JASM;\n+    \/*-------------------------------------------------------- *\/\n+\n+    private Options() {\n+    }\n+\n+    public static Options OptionObject() {\n+        if (ref == null) {\n+            ref = new Options();\n+        }\n+        return ref;\n+    }\n+\n+    public void set(PR val) {\n+        printOptions.add(val);\n+    }\n+\n+    public void setCodeOptions() {\n+        printOptions.addAll(CODE);\n+    }\n+\n+    public boolean contains(PR val) {\n+        return printOptions.contains(val);\n+    }\n+\n+    public boolean debug() {\n+        return printOptions.contains(PR.DEBUG);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return printOptions.toString();\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/Options.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ *\n+ *\/\n+public class ParameterAnnotationData {\n+    \/*-------------------------------------------------------- *\/\n+    \/* AnnotData Fields *\/\n+\n+    private boolean invisible = false;\n+    private static final String initialTab = \"\";\n+    private ArrayList<ArrayList<AnnotationData>> array = null;\n+\n+    private ClassData cls;\n+    \/*-------------------------------------------------------- *\/\n+\n+    public ParameterAnnotationData(ClassData cls, boolean invisible) {\n+        this.cls = cls;\n+        this.invisible = invisible;\n+    }\n+\n+    public int numParams() {\n+        if (array == null) {\n+            return 0;\n+        }\n+\n+        return array.size();\n+    }\n+\n+    public ArrayList<AnnotationData> get(int i) {\n+        return array.get(i);\n+    }\n+\n+    public void read(DataInputStream in) throws IOException {\n+        int numParams = in.readByte();\n+        TraceUtils.traceln(\"             ParameterAnnotationData[\" + numParams + \"]\");\n+        array = new ArrayList<>(numParams);\n+        for (int paramNum = 0; paramNum < numParams; paramNum++) {\n+\n+            int numAnnots = in.readShort();\n+            TraceUtils.traceln(\"             Param#[\" + paramNum + \"]: numAnnots=\" + numAnnots);\n+\n+            if (numAnnots > 0) {\n+                \/\/ read annotation\n+                ArrayList<AnnotationData> p_annots = new ArrayList<>(numAnnots);\n+                for (int annotIndex = 0; annotIndex < numAnnots; annotIndex++) {\n+                    AnnotationData annot = new AnnotationData(invisible, cls);\n+                    annot.read(in);\n+                    p_annots.add(annot);\n+                }\n+                array.add(paramNum, p_annots);\n+            } else {\n+                array.add(paramNum, null);\n+            }\n+        }\n+    }\n+\n+    \/\/ Don't need to do this --\n+    \/\/ we need to print annotations (both vis and invisible) per each param number\n+    public void print(PrintWriter out, String tab) {\n+        if (array != null && array.size() > 0) {\n+            out.println();\n+            int paramNum = 0;\n+            for (ArrayList<AnnotationData> p_annot : array) {\n+                if (p_annot != null && p_annot.size() > 0) {\n+                    out.print(\"\\t\" + paramNum + \": \");\n+                    boolean firstTime = true;\n+                    for (AnnotationData annot : p_annot) {\n+                        if (!firstTime) {\n+                            out.print(\"\\t   \");\n+                        }\n+                        annot.print(out, initialTab);\n+                        firstTime = false;\n+                    }\n+                }\n+\n+                paramNum += 1;\n+                out.println();\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/ParameterAnnotationData.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.JasmTokens;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * The PermittedSubclasses attribute data\n+ * <p>\n+ * JEP 360 (Sealed types): class file 59.65535\n+ * PermittedSubclasses_attribute {\n+ * u2 attribute_name_index;\n+ * u4 attribute_length;\n+ * u2 number_of_classes;\n+ * u2 classes[number_of_classes];\n+ * }\n+ *\/\n+public class PermittedSubclassesData extends ClassArrayData {\n+    public PermittedSubclassesData(ClassData cls) {\n+        super(cls, JasmTokens.Token.PERMITTEDSUBCLASSES.parseKey());\n+    }\n+\n+    public PermittedSubclassesData read(DataInputStream in, int attribute_length) throws IOException, ClassFormatError {\n+        return (PermittedSubclassesData) super.read(in, attribute_length);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/PermittedSubclassesData.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.JasmTokens;\n+import org.openjdk.asmtools.jasm.Tables;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jasm.JasmTokens.Token.*;\n+import static org.openjdk.asmtools.jdis.TraceUtils.traceln;\n+\n+\/**\n+ * The Record attribute data\n+ * <p>\n+ * since class file 58.65535 (JEP 359)\n+ *\/\n+public class RecordData extends  Indenter {\n+\n+\n+    private final ClassData cls;\n+    private List<Component> components;\n+\n+    public RecordData(ClassData cls) {\n+        this.cls = cls;\n+    }\n+\n+    public RecordData read(DataInputStream in) throws IOException {\n+        int count = in.readUnsignedShort();\n+        traceln(\"components=\" + count);\n+        components = new ArrayList<>(count);\n+        for (int i = 0; i < count; i++) {\n+            components.add(new Component(cls).read(in));\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Prints the record data to the current output stream. called from ClassData.\n+     *\/\n+    public void print() throws IOException {\n+        int count = components.size();\n+        if (count > 0) {\n+            cls.out.println(getIndentString() + RECORD.parseKey() + getIndentString() + LBRACE.parseKey());\n+            for (int i = 0; i < count; i++) {\n+                Component cn = components.get(i);\n+                cn.setIndent(indent() * 2);\n+                if (i != 0 && cn.getAnnotationsCount() > 0)\n+                    cn.out.println();\n+                cn.print();\n+            }\n+            cls.out.println(getIndentString() + RBRACE.parseKey());\n+            cls.out.println();\n+        }\n+    }\n+\n+    private class Component extends MemberData {\n+        \/\/ CP index to the name\n+        private int name_cpx;\n+        \/\/ CP index to the type descriptor\n+        private int type_cpx;\n+\n+        public Component(ClassData cls) {\n+            super(cls);\n+            memberType = \"RecordData\";\n+        }\n+\n+        @Override\n+        protected boolean handleAttributes(DataInputStream in, Tables.AttrTag attrtag, int attrlen) throws IOException {\n+            \/\/ Read the Attributes\n+            boolean handled = true;\n+            switch (attrtag) {\n+                case ATT_Signature:\n+                    if( signature != null ) {\n+                        traceln(\"Record attribute:  more than one attribute Signature are in component.attribute_info_attributes[attribute_count]\");\n+                        traceln(\"Last one will be used.\");\n+                    }\n+                    signature = new SignatureData(cls).read(in, attrlen);\n+                    break;\n+                default:\n+                    handled = false;\n+                    break;\n+            }\n+            return handled;\n+        }\n+\n+        \/**\n+         * Read and resolve the component data called from ClassData.\n+         *\/\n+        public Component read(DataInputStream in) throws IOException {\n+            \/\/ read the Component CP indexes\n+            name_cpx = in.readUnsignedShort();\n+            type_cpx = in.readUnsignedShort();\n+            traceln(2, \"RecordComponent: name[\" + name_cpx + \"]=\" + cls.pool.getString(name_cpx)\n+                    + \" descriptor[\" + type_cpx + \"]=\" + cls.pool.getString(type_cpx));\n+            \/\/ Read the attributes\n+            readAttributes(in);\n+            return this;\n+        }\n+\n+        \/**\n+         * Prints the component data to the current output stream. called from RecordData.\n+         *\/\n+        public void print() throws IOException {\n+            \/\/ print component's attributes\n+                super.printAnnotations(getIndentString());\n+            \/\/ print component\n+            StringBuilder bodyPrefix = new StringBuilder(getIndentString());\n+            StringBuilder tailPrefix = new StringBuilder();\n+            if (isSynthetic) {\n+                bodyPrefix.append(JasmTokens.Token.SYNTHETIC.parseKey()).append(' ');\n+            }\n+            if (isDeprecated) {\n+                bodyPrefix.append(JasmTokens.Token.DEPRECATED.parseKey()).append(' ');\n+            }\n+            \/\/ component\n+            bodyPrefix.append(JasmTokens.Token.COMPONENT.parseKey()).append(' ');\n+\n+            printVar(bodyPrefix, tailPrefix,name_cpx, type_cpx);\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/RecordData.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+\n+import org.openjdk.asmtools.jasm.Tables;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+import static java.lang.String.format;\n+\n+\/**\n+ * The Signature attribute data\n+ * <p>\n+ * since class file 49.0\n+ *\/\n+public class SignatureData {\n+    ClassData cls;\n+    int signature_index;\n+    private Options options = Options.OptionObject();\n+\n+    public SignatureData(ClassData cls) {\n+        this.cls = cls;\n+    }\n+\n+    public SignatureData read(DataInputStream in, int attribute_length) throws IOException, ClassFormatError {\n+        if (attribute_length != 2) {\n+            throw new ClassFormatError(format(\"%s: Invalid attribute length #%d\", Tables.AttrTag.ATT_Signature.printval(), attribute_length));\n+        }\n+        signature_index = in.readUnsignedShort();\n+        return this;\n+    }\n+\n+    public void print(String bodyPrefix, String commentPrefix) {\n+        boolean pr_cpx = options.contains(Options.PR.CPX);\n+        if (pr_cpx) {\n+            cls.out.print(format(\"%s#%d%s%s\", bodyPrefix, signature_index, commentPrefix, cls.pool.StringValue(signature_index)));\n+        } else {\n+            cls.out.print(format(\"%s%s%s\", bodyPrefix, cls.pool.getName(signature_index), commentPrefix));\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return format(\"signature[%d]=%s\", signature_index, cls.pool.StringValue(signature_index));\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/SignatureData.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import static org.openjdk.asmtools.jdis.TraceUtils.mapToHexString;\n+import static org.openjdk.asmtools.jdis.TraceUtils.traceln;\n+\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+\n+\/**\n+ * represents one entry of StackMap attribute\n+ *\/\n+class StackMapData {\n+    static int prevFramePC = 0;\n+    boolean isStackMapTable = false;\n+    StackMapFrameType stackFrameType = null;\n+    int start_pc;\n+    int[] lockMap;\n+    int[] stackMap;\n+\n+    public StackMapData(CodeData code, DataInputStream in) throws IOException {\n+        start_pc = in.readUnsignedShort();\n+        lockMap = readMap(code, in);\n+        stackMap = readMap(code, in);\n+        traceln(2, format(\"stack_map_entry:pc=%d numloc=%s  numstack=%s\",\n+                start_pc, mapToHexString(lockMap), mapToHexString(stackMap)));\n+    }\n+\n+    public StackMapData(CodeData code, DataInputStream in,\n+            boolean isStackMapTable) throws IOException {\n+        this.isStackMapTable = isStackMapTable;\n+        int ft_val = in.readUnsignedByte();\n+        StackMapFrameType frame_type = stackMapFrameType(ft_val);\n+        int offset = 0;\n+        switch (frame_type) {\n+            case SAME_FRAME:\n+                \/\/ type is same_frame;\n+                offset = ft_val;\n+                traceln(2, format(\"same_frame=%d\", ft_val));\n+                break;\n+            case SAME_FRAME_EX:\n+                \/\/ type is same_frame_extended;\n+                offset = in.readUnsignedShort();\n+                traceln(2, format(\"same_frame_extended=%d, offset=%d\", ft_val, offset));\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_FRAME:\n+                \/\/ type is same_locals_1_stack_item_frame\n+                offset = ft_val - 64;\n+                stackMap = readMapElements(code, in, 1);\n+                traceln(2, format(\"same_locals_1_stack_item_frame=%d, offset=%d, numstack=%s\",\n+                        ft_val, offset, mapToHexString(stackMap)));\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_EXTENDED_FRAME:\n+                \/\/ type is same_locals_1_stack_item_frame_extended\n+                offset = in.readUnsignedShort();\n+                stackMap = readMapElements(code, in, 1);\n+                traceln(2, format(\"same_locals_1_stack_item_frame_extended=%d, offset=%d, numstack=%s\",\n+                        ft_val, offset, mapToHexString(stackMap)));\n+                break;\n+            case CHOP_1_FRAME:\n+            case CHOP_2_FRAME:\n+            case CHOP_3_FRAME:\n+                \/\/ type is chop_frame\n+                offset = in.readUnsignedShort();\n+                traceln(2, format(\"chop_frame=%d offset=%d\", ft_val, offset));\n+                break;\n+            case APPEND_FRAME:\n+                \/\/ type is append_frame\n+                offset = in.readUnsignedShort();\n+                lockMap = readMapElements(code, in, ft_val - 251);\n+                traceln(2, format(\"append_frame=%d offset=%d numlock=%s\",\n+                        ft_val, offset, mapToHexString(lockMap)));\n+                break;\n+            case FULL_FRAME:\n+                \/\/ type is full_frame\n+                offset = in.readUnsignedShort();\n+                lockMap = readMap(code, in);\n+                stackMap = readMap(code, in);\n+                traceln(2, format(\"full_frame=%d offset=%d numloc=%s  numstack=%s\",\n+                        ft_val, offset, mapToHexString(lockMap), mapToHexString(stackMap)));\n+                break;\n+            default:\n+                TraceUtils.traceln(\"incorrect frame_type argument\");\n+\n+        }\n+        stackFrameType = frame_type;\n+        start_pc = prevFramePC == 0 ? offset : prevFramePC + offset + 1;\n+        prevFramePC = start_pc;\n+    }\n+\n+    private int[] readMap(CodeData code, DataInputStream in) throws IOException {\n+        int num = in.readUnsignedShort();\n+        return readMapElements(code, in, num);\n+    }\n+\n+    private int[] readMapElements(CodeData code, DataInputStream in, int num) throws IOException {\n+        int[] map = new int[num];\n+        for (int k = 0; k < num; k++) {\n+            int mt_val = 0;\n+            try {\n+                mt_val = in.readUnsignedByte();\n+            } catch (EOFException eofe) {\n+                throw eofe;\n+            }\n+            StackMapType maptype = stackMapType(mt_val, null);\n+            switch (maptype) {\n+                case ITEM_Object:\n+                    mt_val = mt_val | (in.readUnsignedShort() << 8);\n+                    break;\n+                case ITEM_NewObject: {\n+                    int pc = in.readUnsignedShort();\n+                    code.get_iAtt(pc).referred = true;\n+                    mt_val = mt_val | (pc << 8);\n+                    break;\n+                }\n+            }\n+            map[k] = mt_val;\n+        }\n+        return map;\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/StackMapData.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+\/**\n+ * A container for the java sources tied to an jasm output when -sl in on\n+ *\/\n+public class TextLines {\n+\n+    final Path file;\n+    List<String> lines;\n+\n+    public TextLines(Path directory, String sourceFileName) {\n+        file = directory == null ? Paths.get(sourceFileName) : directory.resolve(sourceFileName);\n+        try {\n+            lines = Files.readAllLines(file, StandardCharsets.UTF_8);\n+        } catch (IOException ignore) {}\n+    }\n+\n+    public String getLine(int index) {\n+        if( lines != null ) {\n+            if (index < 1 || index >= lines.size()) {\n+                return String.format(\"Line number %d is out of range in \\\"%s\\\"\", index, file);\n+            }\n+            return lines.get(index - 1);\n+        }\n+        return String.format(\"\\\"%s\\\" not found\", file);\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/TextLines.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.asmutils.HexUtils;\n+\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+\n+public class TraceUtils {\n+\n+    public static String prefixString = \"\\t\";\n+\n+    public static void trace(String s) {\n+        if (!(Options.OptionObject()).debug()) {\n+            return;\n+        }\n+        System.out.print(s);\n+    }\n+\n+    public static void trace(int prefixLength, String s) {\n+        if (!(Options.OptionObject()).debug()) {\n+            return;\n+        }\n+        System.out.print((prefixLength > 0) ? new String(new char[prefixLength]).replace(\"\\0\", prefixString) + s : s);\n+    }\n+\n+    public static void traceln(String s) {\n+        if (!(Options.OptionObject()).debug()) {\n+            return;\n+        }\n+        System.out.println(s);\n+    }\n+\n+    public static void traceln(String... lines) {\n+        if (!(Options.OptionObject()).debug()) {\n+            return;\n+        }\n+\n+        if (lines.length == 0) {\n+            System.out.println();\n+        } else {\n+            for (String s : lines) {\n+                System.out.println(s);\n+            }\n+        }\n+    }\n+\n+    public static void traceln(int prefixLength, String s) {\n+        if (!(Options.OptionObject()).debug()) {\n+            return;\n+        }\n+        System.out.println((prefixLength > 0) ? new String(new char[prefixLength]).replace(\"\\0\", prefixString) + s : s);\n+    }\n+\n+    public static void traceln(int prefixLength, String... lines) {\n+        if (!(Options.OptionObject()).debug()) {\n+            return;\n+        }\n+        if (lines.length == 0) {\n+            System.out.println();\n+        } else {\n+            String prefix = (prefixLength > 0) ? new String(new char[prefixLength]).replace(\"\\0\", prefixString) : \"\";\n+            for (String s : lines) {\n+                System.out.println(prefix + s);\n+            }\n+        }\n+    }\n+\n+    public static String mapToHexString(int[] array) {\n+        return format(\"%d %s\",\n+                array.length,\n+                Arrays.stream(array).\n+                        mapToObj(val -> HexUtils.toHex(val)).\n+                        collect(Collectors.joining(\" \")));\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/TraceUtils.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * Exception table entry (JVMS 4.7.3 The Code Attribute) describes one exception handler\n+ * in the code array {@link CodeData}.\n+ *\/\n+class TrapData {\n+\n+    int num;\n+\n+    \/\/ exception_table\n+    int start_pc,       \/\/ u2\n+        end_pc,         \/\/ u2\n+        handler_pc,     \/\/ u2\n+        catch_cpx;      \/\/ u2\n+\n+    public TrapData(DataInputStream in, int num) throws IOException {\n+        this.num = num;\n+        start_pc = in.readUnsignedShort();\n+        end_pc = in.readUnsignedShort();\n+        handler_pc = in.readUnsignedShort();\n+        catch_cpx = in.readUnsignedShort();\n+    }\n+\n+    \/* returns recommended identifier\n+     *\/\n+    public String ident() {\n+        return \"t\" + num;\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/TrapData.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.TypeAnnotationTargetInfoData;\n+import org.openjdk.asmtools.jasm.TypeAnnotationTypePathData;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+\n+import static org.openjdk.asmtools.jasm.TypeAnnotationTargetInfoData.*;\n+import static org.openjdk.asmtools.jasm.TypeAnnotationTypes.*;\n+\n+\/**\n+ * Type Annotation data is a specific kind of AnnotationData. As well as the normal data\n+ * items needed to present an annotation, Type annotations require a TargetInfo\n+ * descriptor. This descriptor is based on a TargetType, and it optionally may contain a\n+ * location descriptor (when the Type is embedded in a collection).\n+ * <p>\n+ * The TypeAnnotationData class is based on JDis's AnnotationData class, and contains the\n+ * (jasm) class for representing TargetInfo.\n+ *\/\n+public class TypeAnnotationData extends AnnotationData {\n+\n+    private static TTVis TT_Visitor = new TTVis();\n+    private TypeAnnotationTargetInfoData targetInfo;\n+    private TypeAnnotationTypePathData typePath;\n+\n+    public TypeAnnotationData(boolean invisible, ClassData cls) {\n+        super(invisible, cls);\n+        targetInfo = null;\n+        typePath  = new TypeAnnotationTypePathData();\n+        visAnnotToken = \"@T+\";\n+        invAnnotToken = \"@T-\";\n+        dataName = \"TypeAnnotationData\";\n+    }\n+\n+    @Override\n+    public void read(DataInputStream in) throws IOException {\n+\n+        int ttype = in.readUnsignedByte();\n+        ETargetType targetType = ETargetType.getTargetType(ttype);\n+\n+        if (targetType == null) {\n+            \/\/ Throw some kind of error for bad target type index\n+            throw new IOException(\"Bad target type: \" + ttype + \" in TypeAnnotationData\");\n+        }\n+\n+        \/\/ read the target info\n+        TT_Visitor.init(in);\n+        TT_Visitor.visitExcept(targetType);\n+        targetInfo = TT_Visitor.getTargetInfo();\n+\n+        \/\/ read the target path info\n+        int len = in.readUnsignedByte();\n+        TraceUtils.traceln(4,\"[TypeAnnotationData.read]: Reading Location (length = \" + len + \").\");\n+        TraceUtils.trace(4,\"[TypeAnnotationData.read]: [ \");\n+        for (int i = 0; i < len; i++) {\n+            int pathType = in.readUnsignedByte();\n+            String pk = (getPathKind(pathType)).parseKey();\n+            char pathArgIndex = (char) in.readUnsignedByte();\n+            typePath.addTypePathEntry(new TypePathEntry(pathType, pathArgIndex));\n+            TraceUtils.trace(\" \" + pk + \"(\" + pathType + \",\" + pathArgIndex + \"), \");\n+        }\n+        TraceUtils.traceln(\"] \");\n+        super.read(in);\n+    }\n+\n+    @Override\n+    protected void printBody(PrintWriter out, String tab) {\n+        \/\/ For a type annotation, print out brackets,\n+        \/\/ print out the (regular) annotation name\/value pairs,\n+        \/\/ then print out the target types.\n+        out.print(\" {\");\n+        super.printBody(out, \"\");\n+        targetInfo.print(out, tab);\n+        typePath.print(out, tab);\n+        out.print(tab + \"}\");\n+    }\n+\n+    \/**\n+     * TTVis\n+     * <p>\n+     * Target Type visitor, used for constructing the target-info within a type\n+     * annotation. visitExcept() is the entry point. ti is the constructed target info.\n+     *\/\n+    private static class TTVis extends TypeAnnotationTargetVisitor {\n+\n+        private TypeAnnotationTargetInfoData targetInfo = null;\n+        private IOException IOProb = null;\n+        private DataInputStream in;\n+\n+        public void init(DataInputStream in) {\n+            this.in = in;\n+        }\n+\n+        public int scanByteVal() {\n+            int val = 0;\n+            try {\n+                val = in.readUnsignedByte();\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return val;\n+        }\n+\n+        public int scanShortVal() {\n+            int val = 0;\n+            try {\n+                val = in.readUnsignedShort();\n+            } catch (IOException e) {\n+                IOProb = e;\n+            }\n+            return val;\n+        }\n+\n+        \/\/This is the entry point for a visitor that tunnels exceptions\n+        public void visitExcept(ETargetType tt) throws IOException {\n+            IOProb = null;\n+            targetInfo = null;\n+\n+            TraceUtils.traceln(4,\"Target Type: \" + tt.parseKey());\n+            visit(tt);\n+\n+            if (IOProb != null) {\n+                throw IOProb;\n+            }\n+        }\n+\n+        public TypeAnnotationTargetInfoData getTargetInfo() {\n+            return targetInfo;\n+        }\n+\n+        private boolean error() {\n+            return IOProb != null;\n+        }\n+\n+        @Override\n+        public void visit_type_param_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"Type Param Target: \");\n+            int byteval = scanByteVal(); \/\/ param index\n+            TraceUtils.traceln(\"{ param_index: \" + byteval + \"}\");\n+            if (!error()) {\n+                targetInfo = new type_parameter_target(tt, byteval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_supertype_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"SuperType Target: \");\n+            int shortval = scanShortVal(); \/\/ type index\n+            TraceUtils.traceln(\"{ type_index: \" + shortval + \"}\");\n+            if (!error()) {\n+                targetInfo = new supertype_target(tt, shortval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_typeparam_bound_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"TypeParam Bound Target: \");\n+            int byteval1 = scanByteVal(); \/\/ param index\n+            if (error()) {\n+                return;\n+            }\n+            int byteval2 = scanByteVal(); \/\/ bound index\n+            if (error()) {\n+                return;\n+            }\n+            TraceUtils.traceln(\"{ param_index: \" + byteval1 + \" bound_index: \" + byteval2 + \"}\");\n+            targetInfo = new type_parameter_bound_target(tt, byteval1, byteval2);\n+        }\n+\n+        @Override\n+        public void visit_empty_target(ETargetType tt) {\n+            TraceUtils.traceln(4,\"Empty Target: \");\n+            if (!error()) {\n+                targetInfo = new empty_target(tt);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_methodformalparam_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"MethodFormalParam Target: \");\n+            int byteval = scanByteVal(); \/\/ param index\n+            TraceUtils.traceln(\"{ param_index: \" + byteval + \"}\");\n+            if (!error()) {\n+                targetInfo = new formal_parameter_target(tt, byteval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_throws_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"Throws Target: \");\n+            int shortval = scanShortVal(); \/\/ exception index\n+            TraceUtils.traceln(\"{ exception_index: \" + shortval + \"}\");\n+            if (!error()) {\n+                targetInfo = new throws_target(tt, shortval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_localvar_target(ETargetType tt) {\n+            TraceUtils.traceln(4,\"LocalVar Target: \");\n+            int tblsize = scanShortVal(); \/\/ table length (short)\n+            if (error()) {\n+                return;\n+            }\n+            localvar_target locvartab = new localvar_target(tt, tblsize);\n+            targetInfo = locvartab;\n+\n+            for (int i = 0; i < tblsize; i++) {\n+                int shortval1 = scanShortVal(); \/\/ startPC\n+                if (error()) {\n+                    return;\n+                }\n+                int shortval2 = scanShortVal(); \/\/ length\n+                if (error()) {\n+                    return;\n+                }\n+                int shortval3 = scanShortVal(); \/\/ CPX\n+                TraceUtils.trace(4,\"LocalVar[\" + i + \"]: \");\n+                TraceUtils.traceln(\"{ startPC: \" + shortval1 + \", length: \" + shortval2 + \", CPX: \" + shortval3 + \"}\");\n+                locvartab.addEntry(shortval1, shortval2, shortval3);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_catch_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"Catch Target: \");\n+            int shortval = scanShortVal(); \/\/ catch index\n+            TraceUtils.traceln(\"{ catch_index: \" + shortval + \"}\");\n+            if (!error()) {\n+                targetInfo = new catch_target(tt, shortval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_offset_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"Offset Target: \");\n+            int shortval = scanShortVal(); \/\/ offset index\n+            TraceUtils.traceln(\"{ offset_index: \" + shortval + \"}\");\n+            if (!error()) {\n+                targetInfo = new offset_target(tt, shortval);\n+            }\n+        }\n+\n+        @Override\n+        public void visit_typearg_target(ETargetType tt) {\n+            TraceUtils.trace(4,\"TypeArg Target: \");\n+            int shortval = scanShortVal(); \/\/ offset\n+            if (error()) {\n+                return;\n+            }\n+            int byteval = scanByteVal(); \/\/ type index\n+            if (error()) {\n+                return;\n+            }\n+            TraceUtils.traceln(\"{ offset: \" + shortval + \" type_index: \" + byteval + \"}\");\n+            targetInfo = new type_argument_target(tt, shortval, byteval);\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/TypeAnnotationData.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+\/**\n+ *\n+ *\/\n+public class Utils {\n+\n+    static public String javaName(String name) {\n+        if (name == null) {\n+            return \"null\";\n+        }\n+        int len = name.length();\n+        if (len == 0) {\n+            return \"\\\"\\\"\";\n+        }\n+        char cc = '\/';\n+fullname:\n+        { \/\/ xxx\/yyy\/zzz\n+            for (int k = 0; k < len; k++) {\n+                char c = name.charAt(k);\n+                if (cc == '\/') {\n+                    if (!Character.isJavaIdentifierStart(c) && c != '-') {\n+                        break fullname;\n+                    }\n+                } else if (c != '\/') {\n+                    if (!Character.isJavaIdentifierPart(c) && c != '-') {\n+                        break fullname;\n+                    }\n+                }\n+                cc = c;\n+            }\n+            return name;\n+        }\n+        return \"\\\"\" + name + \"\\\"\";\n+    }\n+\n+    static public boolean isClassArrayDescriptor(String name) {\n+        boolean retval = false;\n+        if (name != null) {\n+            if (name.startsWith(\"[\")) {\n+                retval = true;\n+            }\n+        }\n+\n+        return retval;\n+    }\n+\n+    static public String commentString(String  str) {\n+        return commentString(str,\"\/\/ \");\n+    }\n+\n+    static public String commentString(String  str, String prefix) {\n+        return prefix + str.replace(\"\\n\", \"\\n\" + prefix);\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/Utils.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+# Copyright (c) 2014, 2019 Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+jdis.usage=\\\n+Usage: java -jar asmtools.jar jdis [options] FILE.class... > FILE.jasm\\n\\\n+where possible options include:\n+\n+jdis.opt.g=\\\n+\\     -g   detailed output format\n+jdis.opt.sl=\\\n+\\     -sl  source lines in comments\n+jdis.opt.v=\\\n+\\     -v   debug mode\n+jdis.opt.hx=\\\n+\\     -hx  hexadecimal numbers\n+jdis.opt.version=\\\n+\\     -version   prints the version info\n+\n+jdis.error.invalid_option=invalid option: {0}\n+jdis.error.cannot_read=cannot read {0}\n+jdis.error.fatal_error=fatal error in file: {0}\n+jdis.error.fatal_exception=fatal exception in file: {0}\n+\n+jdis.error.invalid_header=Invalid Module's attributes table\n+jdis.error.invalid_requires=Invalid requires table\n+jdis.error.invalid_exports=Invalid exports table\n+jdis.error.invalid_opens=Invalid opens table\n+jdis.error.invalid_uses=Invalid uses table\n+jdis.error.invalid_provides=Invalid provides table\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/i18n.properties","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import org.openjdk.asmtools.jasm.RuntimeConstants;\n+import static org.openjdk.asmtools.jasm.Tables.*;\n+import static org.openjdk.asmtools.jasm.OpcodeTables.*;\n+import org.openjdk.asmtools.jasm.Tables;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+\n+\/**\n+ * instruction attributes\n+ *\/\n+class iAtt {\n+\n+    \/*-------------------------------------------------------- *\/\n+    \/* iAtt Fields *\/\n+    private Options options;\n+\n+    short lnum = 0;\n+    boolean referred = false; \/\/ from some other instruction\n+    ArrayList<CodeData.LocVarData> vars;\n+    ArrayList<CodeData.LocVarData> endvars;\n+    ArrayList<TrapData> handlers;\n+    ArrayList<TrapData> traps;\n+    ArrayList<TrapData> endtraps;\n+    StackMapData stackMapEntry;\n+    CodeData code;\n+    ClassData cls;\n+    PrintWriter out; \/\/ =cls.out;\n+ \/*-------------------------------------------------------- *\/\n+\n+    public iAtt(CodeData code) {\n+        this.code = code;\n+        this.cls = code.meth.cls;\n+        out = cls.out;\n+        options = cls.options;\n+    }\n+\n+    void add_var(CodeData.LocVarData var) {\n+        if (vars == null) {\n+            vars = new ArrayList<>(4);\n+        }\n+        vars.add(var);\n+    }\n+\n+    void add_endvar(CodeData.LocVarData endvar) {\n+        if (endvars == null) {\n+            endvars = new ArrayList<>(4);\n+        }\n+        endvars.add(endvar);\n+    }\n+\n+    void add_trap(TrapData trap) {\n+        if (traps == null) {\n+            traps = new ArrayList<>(4);\n+        }\n+        traps.add(trap);\n+    }\n+\n+    void add_endtrap(TrapData endtrap) {\n+        if (endtraps == null) {\n+            endtraps = new ArrayList<>(4);\n+        }\n+        endtraps.add(endtrap);\n+    }\n+\n+    void add_handler(TrapData endtrap) {\n+        if (handlers == null) {\n+            handlers = new ArrayList<>(4);\n+        }\n+        handlers.add(endtrap);\n+    }\n+\n+    public void printEnds() throws IOException {\n+\/\/ prints additional information for instruction:\n+\/\/  end of local variable and trap scopes;\n+        int len;\n+        if ((endvars != null) && (options.contains(Options.PR.VAR))) {\n+            len = endvars.size() - 1;\n+            out.print(\"\\t\\tendvar\");\n+            for (CodeData.LocVarData line : endvars) {\n+                out.print(\" \" + line.slot);\n+                if (len-- > 0) {\n+                    out.print(\",\");\n+                }\n+            }\n+            out.println(\";\");\n+        }\n+\n+        if (endtraps != null) {\n+            len = endtraps.size() - 1;\n+            out.print(\"\\t\\tendtry\");\n+            for (TrapData line : endtraps) {\n+                out.print(\" \" + line.ident());\n+                if (len-- > 0) {\n+                    out.print(\",\");\n+                }\n+            }\n+            out.println(\";\");\n+        }\n+    }\n+\n+    public void printBegins()\n+            throws IOException {\n+\/\/ prints additional information for instruction:\n+\/\/ source line number;\n+\/\/ start of exception handler;\n+\/\/ begin of locvar and trap scopes;\n+        boolean eitherOpt = options.contains(Options.PR.LNT) || options.contains(Options.PR.SRC);\n+        boolean bothOpt = options.contains(Options.PR.LNT) && options.contains(Options.PR.SRC);\n+        int k;\n+\n+        if ((lnum != 0) && eitherOpt) {\n+            if (bothOpt) {\n+                out.println(\"\/\/ \" + lnum + \": \" + cls.getSrcLine(lnum));\n+            } else if (options.contains(Options.PR.LNT)) {\n+                out.print(lnum);\n+            } else if (options.contains(Options.PR.SRC)) {\n+                out.println(\"\/\/ \" + cls.getSrcLine(lnum));\n+            }\n+        }\n+        out.print(\"\\t\");\n+        if (handlers != null) {\n+            for (TrapData line : handlers) {\n+                out.print(\"\\tcatch \" + line.ident());\n+                out.print(\" \" + cls.pool.getClassName(line.catch_cpx) + \";\\n\\t\");\n+            }\n+        }\n+        if (traps != null) {\n+            int len = traps.size() - 1;\n+            out.print(\"\\ttry\");\n+            for (TrapData line : traps) {\n+                out.print(\" \" + line.ident());\n+                if (len-- > 0) {\n+                    out.print(\",\");\n+                }\n+            }\n+            out.print(\";\\n\\t\");\n+        }\n+        if ((vars != null) && options.contains(Options.PR.VAR)) {\n+            for (CodeData.LocVarData line : vars) {\n+                out.println(\"\\tvar \" + line.slot + \"; \/\/ \" + cls.pool.getName(line.name_cpx) + \":\" + cls.pool.getName(line.sig_cpx));\n+                out.print(\"\\t\");\n+            }\n+        }\n+    }\n+\n+    public void printMapList(int[] map) throws IOException {\n+        boolean pr_cpx = options.contains(Options.PR.CPX);\n+\n+        for (int k = 0; k < map.length; k++) {\n+            int fullmaptype = map[k];\n+            int mt_val = fullmaptype & 0xFF;\n+            StackMapType maptype = stackMapType(mt_val, out);\n+            int argument = fullmaptype >> 8;\n+            switch (maptype) {\n+                case ITEM_Object:\n+                    if (pr_cpx) {\n+                        out.print(\" #\" + argument);\n+                    } else {\n+                        out.print(\" \");\n+                        cls.pool.PrintConstant(out, argument);\n+                    }\n+                    break;\n+                case ITEM_NewObject:\n+                    if (pr_cpx) {\n+                        out.print(\" \" + mt_val);\n+                    } else {\n+                        out.print(\" \" + maptype.printval());\n+                    }\n+                    out.print(\" \" + code.meth.lP + argument);\n+                    break;\n+                default:\n+                    if (pr_cpx) {\n+                        out.print(\" \" + mt_val);\n+                    } else {\n+                        out.print(\" \" + maptype.printval());\n+                    }\n+            }\n+            out.print((k == (map.length - 1) ? ';' : ','));\n+        }\n+    }\n+\n+    public void printStackMap() throws IOException {\n+        if (stackMapEntry == null) {\n+            return;\n+        }\n+        boolean printed = false;\n+        if (stackMapEntry.stackFrameType != null) {\n+            out.print(Opcode.opc_stack_frame_type.parsekey()); \/\/    opcNamesTab[opc_stackframetype]);\n+            out.print(\" \" + stackMapEntry.stackFrameType.parsekey() + ';');\n+            out.print(\"\\n\\t\\t\");\n+            printed = true;\n+        }\n+        int[] map = stackMapEntry.lockMap;\n+        if ((map != null) && (map.length > 0)) {\n+            out.print(Opcode.opc_locals_map.parsekey());\n+            printMapList(map);\n+            out.print(\"\\n\\t\\t\");\n+            printed = true;\n+        }\n+        map = stackMapEntry.stackMap;\n+        if ((map != null) && (map.length > 0)) {\n+            out.print(Opcode.opc_stack_map.parsekey());\n+            printMapList(map);\n+            out.print(\"\\n\\t\\t\");\n+            printed = true;\n+        }\n+        if (!printed) {\n+\/\/ empty attribute should be printed anyway - it should not\n+\/\/ be eliminated after jdis\/jasm cycle\n+            out.print(Opcode.opc_locals_map.parsekey() + \" ;\\n\\t\\t\");\n+        }\n+    }\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/iAtt.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jdis;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+\n+\/**\n+ *\n+ *\/\n+public class uEscWriter extends Writer {\n+    \/*-------------------------------------------------------- *\/\n+    \/* uEscWriter Fields *\/\n+\n+    static final char[] hexTable = \"0123456789ABCDEF\".toCharArray();\n+    OutputStream out;\n+    byte[] tmpl;\n+    \/*-------------------------------------------------------- *\/\n+\n+    public uEscWriter(OutputStream out) {\n+        this.out = out;\n+        tmpl = new byte[6];\n+        tmpl[0] = (byte) '\\\\';\n+        tmpl[1] = (byte) 'u';\n+    }\n+\n+    @Override\n+    public synchronized void write(int c) throws IOException {\n+        if (c < 128) {\n+            out.write(c);\n+            return;\n+        }\n+        \/\/ write \\udddd\n+        byte[] tmpll = tmpl;\n+        for (int k = 3; k >= 0; k--) {\n+            tmpll[5 - k] = (byte) hexTable[(c >> 4 * k) & 0xF];\n+        }\n+        out.write(tmpll, 0, 6);\n+    }\n+\n+    @Override\n+    public synchronized void write(char[] cc, int ofs, int len) throws IOException {\n+        for (int k = ofs; k < len; k++) {\n+            write(cc[k]);\n+        }\n+    }\n+\n+    @Override\n+    public void flush() {\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+} \/\/ end uEscWriter\n+\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jdis\/uEscWriter.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.util;\n+\n+import java.text.MessageFormat;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+\/**\n+ * A class that lazily opens a package-specific resource bundle containing localization\n+ * data for a class.\n+ *\/\n+public class I18NResourceBundle extends ResourceBundle {\n+\n+    \/**\n+     * Get a package-specific resource bundle for a class containing localization data.\n+     * The bundle is named i18n.properties in the same package as the given class.\n+     *\n+     * @param c the class for which to obtain the resource bundle\n+     * @return the appropriate resource bundle for the class\n+     *\/\n+    public static I18NResourceBundle getBundleForClass(Class c) {\n+        String cn = c.getName();\n+        int dot = cn.lastIndexOf('.');\n+        String rn = (dot == -1 ? \"i18n\" : cn.substring(0, dot) + \".i18n\");\n+        return new I18NResourceBundle(rn, c.getClassLoader());\n+    }\n+\n+    \/**\n+     * Create a resource bundle for the given name. The actual resource bundle will not be\n+     * loaded until it is needed.\n+     *\n+     * @param name The name of the actual resource bundle to use.\n+     *\/\n+    private I18NResourceBundle(String name, ClassLoader cl) {\n+        this.name = name;\n+        this.classLoader = cl;\n+    }\n+\n+    \/**\n+     * Get an entry from the resource bundle. If the resource cannot be found, a message\n+     * is printed to the console and the result will be a string containing the method\n+     * parameters.\n+     *\n+     * @param key the name of the entry to be returned\n+     * @param arg an argument to be formatted into the result using\n+     * {@link java.text.MessageFormat#format}\n+     * @return the formatted string\n+     *\/\n+    public String getString(String key, Object arg) {\n+        return getString(key, new Object[]{arg});\n+    }\n+\n+    \/**\n+     * Get an entry from the resource bundle. If the resource cannot be found, a message\n+     * is printed to the console and the result will be a string containing the method\n+     * parameters.\n+     *\n+     * @param key the name of the entry to be returned\n+     * @param args an array of arguments to be formatted into the result using\n+     * {@link java.text.MessageFormat#format}\n+     * @return the formatted string\n+     *\/\n+    public String getString(String key, Object... args) {\n+        try {\n+            return MessageFormat.format(getString(key), args);\n+        } catch (MissingResourceException e) {\n+            System.err.println(\"WARNING: missing resource: \" + key + \" for \" + name);\n+            StringBuffer sb = new StringBuffer(key);\n+            for (int i = 0; i < args.length; i++) {\n+                sb.append('\\n');\n+                sb.append(args.toString());\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    \/**\n+     * Get an entry from the bundle, returning null if it is not found.\n+     *\n+     * @param key the name of the entry to be returned\n+     * @return the value of the entry, or null if it is not found.\n+     *\/\n+    public String getOptionalString(String key) {\n+        if (delegate == null) {\n+            delegate = ResourceBundle.getBundle(name, Locale.getDefault(), classLoader);\n+        }\n+        try {\n+            String s = (String) (delegate.getObject(key));\n+            if (s != null) {\n+                System.out.println(\"i18n: \" + key);\n+            }\n+            return s;\n+        } catch (MissingResourceException e) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * A required internal method for ResourceBundle. Load the actual resource bundle, if\n+     * it has not yet been loaded, then hand the request off to that bundle. If the\n+     * resource cannot be found, a message is printed to the console and the result will\n+     * be the original tag.\n+     *\/\n+    protected Object handleGetObject(String key) throws MissingResourceException {\n+        try {\n+            if (delegate == null) {\n+                delegate = ResourceBundle.getBundle(name, Locale.getDefault(), classLoader);\n+            }\n+            return delegate.getObject(key);\n+        } catch (MissingResourceException e) {\n+            System.err.println(\"WARNING: missing resource: \" + key + \" for \" + name);\n+            return key;\n+        }\n+    }\n+\n+    \/**\n+     * A required internal method for ResourceBundle. Load the actual resource bundle, if\n+     * it has not yet been loaded, then hand the request off to that bundle.\n+     *\/\n+    public Enumeration getKeys() {\n+        if (delegate == null) {\n+            delegate = ResourceBundle.getBundle(name);\n+        }\n+        return delegate.getKeys();\n+    }\n+\n+    \/**\n+     * Returns the name of this bundle (useful for methods using bundle name instead of\n+     * instance, such as <code>Logger<\/code> creation,\n+     *\n+     * @return the name of this resource bundle\n+     *\/\n+    public String getName() {\n+        return name;\n+    }\n+\n+    private String name;\n+    private ResourceBundle delegate;\n+    private ClassLoader classLoader;\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/util\/I18NResourceBundle.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.util;\n+\n+import java.util.ResourceBundle;\n+\n+\/**\n+ * Class providing an access to the product info.\n+ * <i>productinfo.properties<\/i> will be generated during the build\n+ *\/\n+public class ProductInfo {\n+\n+    static {\n+        init();\n+    }\n+\n+    ;\n+\n+    \/**\n+     * Returns the value of the specified property\n+     *\/\n+    public static String getProperty(String propName) {\n+        try {\n+            return bundle.getString(propName);\n+        } catch (java.util.MissingResourceException e) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Version of the product in the short format, like 5.0\n+     *\/\n+    public static final String VERSION = version();\n+\n+    \/**\n+     * Full version of the product, including build number and date of creation\n+     *\/\n+    public static final String FULL_VERSION = fullVersion();\n+\n+    private static final String BUNDLE_NAME = \"org.openjdk.asmtools.util.productinfo\";\n+\n+    private static ResourceBundle bundle;\n+\n+    \/**\n+     * Initializes the bundle\n+     *\/\n+    private static void init() {\n+        bundle = ResourceBundle.getBundle(BUNDLE_NAME);\n+    }\n+\n+    private static String version() {\n+        return getProperty(\"PRODUCT_VERSION\");\n+    }\n+\n+    private static String fullVersion() {\n+        return getProperty(\"PRODUCT_NAME_LONG\") + \", version \" + version()\n+                + \" \" + getProperty(\"PRODUCT_MILESTONE\")\n+                + \" \" + getProperty(\"PRODUCT_BUILDNUMBER\")\n+                + \" (\" + getProperty(\"PRODUCT_DATE\") + \")\";\n+\n+    }\n+\n+}\n","filename":"test\/lib\/org\/openjdk\/asmtools\/util\/ProductInfo.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+# Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+PRODUCT_NAME        = %%PRODUCT_NAME%%\n+PRODUCT_VERSION     = %%PRODUCT_VERSION%%\n+PRODUCT_MILESTONE   = %%PRODUCT_MILESTONE%%\n+PRODUCT_BUILDNUMBER = %%PRODUCT_BUILDNUMBER%%\n+PRODUCT_NAME_LONG   = %%PRODUCT_NAME_LONG%%\n+PRODUCT_DATE        = %%BUILD_DATE%%\n","filename":"test\/lib\/org\/openjdk\/asmtools\/util\/productinfo.properties","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"}]}