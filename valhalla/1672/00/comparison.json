{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -1397,0 +1398,1 @@\n+    assert(!k->is_loaded() || !k->is_obj_array_klass(), \"Use refined array for a direct pointer comparison\");\n@@ -1419,1 +1421,8 @@\n-        __ cmp(klass_RInfo, k_RInfo);\n+        if (k->is_loaded() && k->is_obj_array_klass()) {\n+          \/\/ For a direct pointer comparison, we need the refined array klass pointer\n+          ciKlass* k_refined = ciObjArrayKlass::make(k->as_obj_array_klass()->element_klass());\n+          __ mov_metadata(rscratch1, k_refined->constant_encoding());\n+          __ cmp(klass_RInfo, rscratch1);\n+        } else {\n+          __ cmp(klass_RInfo, k_RInfo);\n+        }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1207,1 +1207,1 @@\n-  ciKlass* obj = ciArrayKlass::make(x->klass(), false, true, true);\n+  ciKlass* obj = ciObjArrayKlass::make(x->klass());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1059,0 +1059,1 @@\n+        \/\/ TODO 8370341 Wouldn't this fail for arrays?\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1444,0 +1444,1 @@\n+  \/\/ TODO 8370341 For a direct pointer comparison, we need the refined array klass pointer\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -1409,1 +1410,1 @@\n-    \/\/ TODO 8366668 Is this correct? I don't think so. Probably we now always go to the slow path here. Same on AArch64.\n+    assert(!k->is_loaded() || !k->is_obj_array_klass(), \"Use refined array for a direct pointer comparison\");\n@@ -1434,1 +1435,8 @@\n-        __ cmpptr(klass_RInfo, k_RInfo);\n+        if (k->is_loaded() && k->is_obj_array_klass()) {\n+          \/\/ For a direct pointer comparison, we need the refined array klass pointer\n+          ciKlass* k_refined = ciObjArrayKlass::make(k->as_obj_array_klass()->element_klass());\n+          __ mov_metadata(tmp_load_klass, k_refined->constant_encoding());\n+          __ cmpptr(klass_RInfo, tmp_load_klass);\n+        } else {\n+          __ cmpptr(klass_RInfo, k_RInfo);\n+        }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1218,1 +1218,1 @@\n-  ciKlass* obj = ciArrayKlass::make(x->klass(), false, true, true);\n+  ciKlass* obj = ciObjArrayKlass::make(x->klass());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1253,0 +1253,1 @@\n+        \/\/ TODO 8370341 Wouldn't this fail for arrays?\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4181,0 +4181,1 @@\n+  \/\/ TODO 8370341 For a direct pointer comparison, we need the refined array klass pointer\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -774,0 +774,5 @@\n+    if (expected_type != nullptr && expected_type->is_obj_array_klass()) {\n+      \/\/ For a direct pointer comparison, we need the refined array klass pointer\n+      expected_type = ciObjArrayKlass::make(expected_type->as_array_klass()->element_klass());\n+    }\n+\n@@ -899,6 +904,0 @@\n-\n-  \/\/ TODO 8366668\n-  if (expected_type != nullptr && expected_type->is_obj_array_klass()) {\n-    expected_type = ciArrayKlass::make(expected_type->as_array_klass()->element_klass(), false, true, true);\n-  }\n-\n@@ -1904,0 +1903,5 @@\n+  if (GenerateArrayStoreCheck && needs_store_check) {\n+    CodeEmitInfo* store_check_info = new CodeEmitInfo(range_check_info);\n+    array_store_check(value.result(), array.result(), store_check_info, x->profiled_method(), x->profiled_bci());\n+  }\n+\n@@ -1919,1 +1923,1 @@\n-        profile_null_free_array(array, md, store_data);\n+        profile_null_free_array(array, md, data);\n@@ -1924,5 +1928,0 @@\n-  if (GenerateArrayStoreCheck && needs_store_check) {\n-    CodeEmitInfo* store_check_info = new CodeEmitInfo(range_check_info);\n-    array_store_check(value.result(), array.result(), store_check_info, x->profiled_method(), x->profiled_bci());\n-  }\n-\n@@ -2284,1 +2283,1 @@\n-  ciArrayLoadData* load_data = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -2294,1 +2293,1 @@\n-      ciProfileData* data = md->bci_to_data(bci);\n+      data = md->bci_to_data(bci);\n@@ -2296,1 +2295,1 @@\n-      load_data = (ciArrayLoadData*)data;\n+      ciArrayLoadData* load_data = (ciArrayLoadData*)data;\n@@ -2320,1 +2319,1 @@\n-      profile_null_free_array(array, md, load_data);\n+      profile_null_free_array(array, md, data);\n@@ -2346,1 +2345,1 @@\n-    profile_element_type(element, md, load_data);\n+    profile_element_type(element, md, (ciArrayLoadData*)data);\n@@ -2822,10 +2821,0 @@\n-    \/\/ TODO 8366668\n-    if (exact_klass != nullptr && exact_klass->is_obj_array_klass()) {\n-      if (exact_klass->as_obj_array_klass()->element_klass()->is_inlinetype()) {\n-        \/\/ Could be flat, null free etc.\n-        exact_klass = nullptr;\n-      } else {\n-        exact_klass = ciObjArrayKlass::make(exact_klass->as_array_klass()->element_klass(), true);\n-      }\n-    }\n-\n@@ -2869,11 +2858,0 @@\n-\n-    \/\/ TODO 8366668\n-    if (exact_klass != nullptr && exact_klass->is_obj_array_klass()) {\n-      if (exact_klass->as_obj_array_klass()->element_klass()->is_inlinetype()) {\n-        \/\/ Could be flat, null free etc.\n-        exact_klass = nullptr;\n-      } else {\n-        exact_klass = ciObjArrayKlass::make(exact_klass->as_array_klass()->element_klass(), true);\n-      }\n-    }\n-\n@@ -2883,0 +2861,12 @@\n+  if (exact_klass != nullptr && exact_klass->is_obj_array_klass()) {\n+    if (exact_klass->can_be_inline_array_klass()) {\n+      \/\/ Inline type arrays can have additional properties, we need to load the klass\n+      \/\/ TODO 8350865 Can we do better here and track the properties?\n+      exact_klass = nullptr;\n+      do_update = true;\n+    } else {\n+      \/\/ For a direct pointer comparison, we need the refined array klass pointer\n+      exact_klass = ciObjArrayKlass::make(exact_klass->as_array_klass()->element_klass());\n+      do_update = ciTypeEntries::valid_ciklass(profiled_k) != exact_klass;\n+    }\n+  }\n@@ -2943,0 +2933,1 @@\n+  LIR_Opr update;\n@@ -2944,1 +2935,1 @@\n-    LIR_Opr update = new_register(T_INT);\n+    update = new_register(T_INT);\n@@ -2947,1 +2938,1 @@\n-    __ logical_or(flags, LIR_OprFact::intConst(flag), flags);\n+    update = LIR_OprFact::intConst(flag);\n@@ -2949,0 +2940,1 @@\n+  __ logical_or(flags, update, flags);\n@@ -2952,1 +2944,1 @@\n-template <class ArrayData> void LIRGenerator::profile_null_free_array(LIRItem array, ciMethodData* md, ArrayData* load_store) {\n+void LIRGenerator::profile_null_free_array(LIRItem array, ciMethodData* md, ciProfileData* data) {\n@@ -2958,1 +2950,1 @@\n-  profile_flags(md, load_store, ArrayStoreData::null_free_array_byte_constant(), lir_cond_equal);\n+  profile_flags(md, data, ArrayStoreData::null_free_array_byte_constant(), lir_cond_equal);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":34,"deletions":42,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-  template <class ArrayData> void profile_null_free_array(LIRItem array, ciMethodData* md, ArrayData* load_store);\n+  void profile_null_free_array(LIRItem array, ciMethodData* md, ciProfileData* load_store);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,2 @@\n+  } else {\n+    return ciObjArrayKlass::make(element_type->as_klass(), vm_type, null_free, atomic);\n@@ -108,27 +110,0 @@\n-\n-  ciKlass* klass = element_type->as_klass();\n-  assert(!null_free || !klass->is_loaded() || klass->is_inlinetype() || klass->is_abstract() ||\n-         klass->is_java_lang_Object(), \"only value classes are null free\");\n-  if (klass->is_loaded() && klass->is_inlinetype() && vm_type) {\n-    GUARDED_VM_ENTRY(\n-      EXCEPTION_CONTEXT;\n-      InlineKlass* vk = InlineKlass::cast(klass->get_Klass());\n-      ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n-      if (null_free) {\n-        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n-      }\n-      if (!atomic) {\n-        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NON_ATOMIC);\n-      }\n-      ArrayKlass* ak = vk->array_klass(THREAD);\n-      ak = ObjArrayKlass::cast(ak)->klass_with_properties(props, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-      } else if (ak->is_flatArray_klass()) {\n-        return CURRENT_THREAD_ENV->get_flat_array_klass(ak);\n-      } else if (ak->is_refArray_klass()) {\n-        return CURRENT_THREAD_ENV->get_obj_array_klass(ak);\n-      }\n-    )\n-  }\n-  return ciObjArrayKlass::make(klass, vm_type);\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -677,0 +677,8 @@\n+#ifdef ASSERT\n+        if (array_type != nullptr) {\n+          bool flat = array_type->is_flat_array_klass();\n+          bool null_free = array_type->as_array_klass()->is_elem_null_free();\n+          assert(!flat || flat_array, \"inconsistency\");\n+          assert(!null_free || null_free_array, \"inconsistency\");\n+        }\n+#endif\n@@ -696,0 +704,8 @@\n+#ifdef ASSERT\n+        if (array_type != nullptr) {\n+          bool flat = array_type->is_flat_array_klass();\n+          bool null_free = array_type->as_array_klass()->is_elem_null_free();\n+          assert(!flat || flat_array, \"inconsistency\");\n+          assert(!null_free || null_free_array, \"inconsistency\");\n+        }\n+#endif\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1000,0 +1000,1 @@\n+  st->cr();\n@@ -1010,0 +1011,1 @@\n+  st->cr();\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n@@ -137,1 +138,1 @@\n-ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool vm_type) {\n+ciArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool vm_type, bool null_free, bool atomic) {\n@@ -147,3 +148,16 @@\n-    if (array->is_objArray_klass() && vm_type) {\n-      assert(!array->is_refArray_klass() && !array->is_flatArray_klass(), \"Unexpected refined klass\");\n-      array = ObjArrayKlass::cast(array)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+    if (vm_type) {\n+      ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+      if (null_free) {\n+        assert(element_klass->is_inlinetype(), \"Only value class arrays can be null free\");\n+        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n+      }\n+      if (!atomic) {\n+        assert(element_klass->is_inlinetype(), \"Only value class arrays can be non-atomic\");\n+        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+      }\n+      array = ObjArrayKlass::cast(array)->klass_with_properties(props, THREAD);\n+    }\n+    if (array->is_flatArray_klass()) {\n+      return CURRENT_THREAD_ENV->get_flat_array_klass(array);\n+    } else {\n+      return CURRENT_THREAD_ENV->get_obj_array_klass(array);\n@@ -151,1 +165,0 @@\n-    return CURRENT_THREAD_ENV->get_obj_array_klass(array);\n@@ -168,2 +181,2 @@\n-ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool vm_type) {\n-  GUARDED_VM_ENTRY(return make_impl(element_klass, vm_type);)\n+ciArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool vm_type, bool null_free, bool atomic) {\n+  GUARDED_VM_ENTRY(return make_impl(element_klass, vm_type, null_free, atomic);)\n@@ -172,1 +185,1 @@\n-ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, int dims) {\n+ciArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, int dims) {\n@@ -175,1 +188,1 @@\n-    klass = ciObjArrayKlass::make(klass);\n+    klass = ciObjArrayKlass::make(klass, \/* vm_type = *\/ false);\n@@ -177,1 +190,1 @@\n-  return klass->as_obj_array_klass();\n+  return klass->as_array_klass();\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  static ciObjArrayKlass* make_impl(ciKlass* element_klass, bool vm_type = false);\n+  static ciArrayKlass* make_impl(ciKlass* element_klass, bool vm_type = false, bool null_free = false, bool atomic = true);\n@@ -71,2 +71,2 @@\n-  static ciObjArrayKlass* make(ciKlass* element_klass, bool vm_type = false);\n-  static ciObjArrayKlass* make(ciKlass* element_klass, int dims);\n+  static ciArrayKlass* make(ciKlass* element_klass, bool vm_type = true, bool null_free = false, bool atomic = true);\n+  static ciArrayKlass* make(ciKlass* element_klass, int dims);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -271,0 +271,3 @@\n+  case vmIntrinsics::_isFlatArray:\n+  case vmIntrinsics::_isNullRestrictedArray:\n+  case vmIntrinsics::_isAtomicArray:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -336,0 +336,6 @@\n+  do_intrinsic(_isFlatArray, jdk_internal_value_ValueClass, isFlatArray_name, object_boolean_signature, F_SN)           \\\n+   do_name(     isFlatArray_name,                                 \"isFlatArray\")                                        \\\n+  do_intrinsic(_isNullRestrictedArray, jdk_internal_value_ValueClass, isNullRestrictedArray_name, object_boolean_signature, F_SN) \\\n+   do_name(     isNullRestrictedArray_name,                       \"isNullRestrictedArray\")                              \\\n+  do_intrinsic(_isAtomicArray, jdk_internal_value_ValueClass, isAtomicArray_name, object_boolean_signature, F_SN)       \\\n+   do_name(     isAtomicArray_name,                               \"isAtomicArray\")                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  static ByteSize properties_offset() { return byte_offset_of(ArrayKlass, _properties); }\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1995,1 +1995,1 @@\n-class ArrayLoadData : public ProfileData {\n+class ArrayLoadData : public BitData {\n@@ -1998,1 +1998,1 @@\n-    flat_array_flag = DataLayout::first_flag,\n+    flat_array_flag = BitData::last_bit_data_flag,\n@@ -2007,1 +2007,1 @@\n-    ProfileData(layout),\n+    BitData(layout),\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -211,0 +211,19 @@\n+ObjArrayKlass* ObjArrayKlass::allocate_klass_with_properties(ArrayKlass::ArrayProperties props, TRAPS) {\n+  ObjArrayKlass* ak = nullptr;\n+  ArrayDescription ad = ObjArrayKlass::array_layout_selection(element_klass(), props);\n+  switch (ad._kind) {\n+    case Klass::RefArrayKlassKind: {\n+      ak = RefArrayKlass::allocate_refArray_klass(class_loader_data(), dimension(), element_klass(), props, CHECK_NULL);\n+      break;\n+    }\n+    case Klass::FlatArrayKlassKind: {\n+      assert(dimension() == 1, \"Flat arrays can only be dimension 1 arrays\");\n+      ak = FlatArrayKlass::allocate_klass(element_klass(), props, ad._layout_kind, CHECK_NULL);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  return ak;\n+}\n+\n@@ -391,14 +410,7 @@\n-    if (next_refined_array_klass() ==  nullptr) {\n-      ArrayDescription ad = ObjArrayKlass::array_layout_selection(element_klass(), props);\n-      switch (ad._kind) {\n-        case Klass::RefArrayKlassKind: {\n-          ak = RefArrayKlass::allocate_refArray_klass(class_loader_data(), dimension(), element_klass(), props, CHECK_NULL);\n-          break;\n-        }\n-        case Klass::FlatArrayKlassKind: {\n-          assert(dimension() == 1, \"Flat arrays can only be dimension 1 arrays\");\n-          ak = FlatArrayKlass::allocate_klass(element_klass(), props, ad._layout_kind, CHECK_NULL);\n-          break;\n-        }\n-        default:\n-          ShouldNotReachHere();\n+    if (next_refined_array_klass() == nullptr) {\n+      ObjArrayKlass* first = this;\n+      if (!is_refArray_klass() && !is_flatArray_klass() && props != ArrayKlass::ArrayProperties::DEFAULT) {\n+        \/\/ Make sure that the first entry in the linked list is always the default refined klass because\n+        \/\/ C2 relies on this for a fast lookup (see LibraryCallKit::load_default_refined_array_klass).\n+        first = allocate_klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+        release_set_next_refined_klass(first);\n@@ -406,1 +418,2 @@\n-      release_set_next_refined_klass(ak);\n+      ak = allocate_klass_with_properties(props, THREAD);\n+      first->release_set_next_refined_klass(ak);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":28,"deletions":15,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  ObjArrayKlass* allocate_klass_with_properties(ArrayKlass::ArrayProperties props, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -773,0 +773,3 @@\n+  case vmIntrinsics::_isFlatArray:\n+  case vmIntrinsics::_isNullRestrictedArray:\n+  case vmIntrinsics::_isAtomicArray:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2915,1 +2915,1 @@\n-  const TypeAryKlassPtr* ary_klass_t = klass_ptr_type->isa_aryklassptr();\n+  \/\/ For a direct pointer comparison, we need the refined array klass pointer\n@@ -2917,4 +2917,2 @@\n-  \/\/ TODO 8366668 Compute the VM type here for when we do a direct pointer comparison\n-  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n-    ary_klass_t = ary_klass_t->get_vm_type();\n-    vm_superklass = gvn.makecon(ary_klass_t);\n+  if (klass_ptr_type->isa_aryklassptr() && klass_ptr_type->klass_is_exact()) {\n+    vm_superklass = gvn.makecon(klass_ptr_type->is_aryklassptr()->refined_array_klass_ptr());\n@@ -2982,2 +2980,1 @@\n-  \/\/ TODO 8366668 Re-enable. This breaks test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java\n-  bool might_be_cache = true;\/\/(chk_off_con == cacheoff_con);\n+  bool might_be_cache = (chk_off_con == cacheoff_con);\n@@ -3034,1 +3031,0 @@\n-        \/\/ TODO 8366668 Do we need adjustments here??\n@@ -3040,0 +3036,4 @@\n+        if (klass_t->isa_aryklassptr()) {\n+          \/\/ For a direct pointer comparison, we need the refined array klass pointer\n+          klass_t = klass_t->is_aryklassptr()->refined_array_klass_ptr();\n+        }\n@@ -3085,2 +3085,0 @@\n-  \/\/ TODO 8366668 Re-enable\n-\/*\n@@ -3091,1 +3089,1 @@\n-*\/\n+\n@@ -3176,4 +3174,3 @@\n-  const TypeAryKlassPtr* ary_klass_t = tklass->isa_aryklassptr();\n-    \/\/ TODO 8366668 Compute the VM type\n-  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n-    tklass = ary_klass_t->get_vm_type();\n+  if (tklass->isa_aryklassptr()) {\n+    \/\/ For a direct pointer comparison, we need the refined array klass pointer\n+    tklass = tklass->is_aryklassptr()->refined_array_klass_ptr();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  Node* is_buffered_node = PhiNode::make(region, init_with_top ? top : vt->get_is_buffered(), t);;\n+  Node* is_buffered_node = PhiNode::make(region, init_with_top ? top : vt->get_is_buffered(), t);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,0 +539,3 @@\n+  case vmIntrinsics::_isFlatArray:              return inline_getArrayProperties(IsFlat);\n+  case vmIntrinsics::_isNullRestrictedArray:    return inline_getArrayProperties(IsNullRestricted);\n+  case vmIntrinsics::_isAtomicArray:            return inline_getArrayProperties(IsAtomic);\n@@ -4785,3 +4788,3 @@\n-\/\/ public static native Object[] newNullRestrictedAtomicArray(Class<?> componentType, int length, Object initVal);\n-\/\/ public static native Object[] newNullRestrictedNonAtomicArray(Class<?> componentType, int length, Object initVal);\n-\/\/ public static native Object[] newNullableAtomicArray(Class<?> componentType, int length);\n+\/\/ public static native Object[] ValueClass::newNullRestrictedAtomicArray(Class<?> componentType, int length, Object initVal);\n+\/\/ public static native Object[] ValueClass::newNullRestrictedNonAtomicArray(Class<?> componentType, int length, Object initVal);\n+\/\/ public static native Object[] ValueClass::newNullableAtomicArray(Class<?> componentType, int length);\n@@ -4837,16 +4840,23 @@\n-Node* LibraryCallKit::load_default_array_klass(Node* klass_node) {\n-  \/\/ TODO 8366668\n-  \/\/ - Fred suggested that we could just have the first entry in the refined list point to the array with ArrayKlass::ArrayProperties::DEFAULT property\n-  \/\/   For now, we just load from ObjArrayKlass::_next_refined_array_klass, which would always be the refKlass for non-values, and deopt if it's not\n-  \/\/ - Convert this to an IGVN optimization, so it's also folded after parsing\n-  \/\/ - The generate_typeArray_guard is not needed by all callers, double-check that it's folded\n-\n-  const Type* klass_t = _gvn.type(klass_node);\n-  const TypeAryKlassPtr* ary_klass_t = klass_t->isa_aryklassptr();\n-  if (ary_klass_t && ary_klass_t->klass_is_exact()) {\n-    if (ary_klass_t->exact_klass()->is_obj_array_klass()) {\n-      ary_klass_t = ary_klass_t->get_vm_type(false);\n-      return makecon(ary_klass_t);\n-    } else {\n-      return klass_node;\n-    }\n+\/\/ public static native boolean ValueClass::isFlatArray(Object array);\n+\/\/ public static native boolean ValueClass::isNullRestrictedArray(Object array);\n+\/\/ public static native boolean ValueClass::isAtomicArray(Object array);\n+bool LibraryCallKit::inline_getArrayProperties(ArrayPropertiesCheck check) {\n+  Node* array = argument(0);\n+\n+  Node* bol;\n+  switch(check) {\n+    case IsFlat:\n+      \/\/ TODO 8350865 Use the object version here instead of loading the klass\n+      \/\/ The problem is that PhaseMacroExpand::expand_flatarraycheck_node can only handle some IR shapes and will fail, for example, if the bol is directly wired to a ReturnNode\n+      bol = flat_array_test(load_object_klass(array));\n+      break;\n+    case IsNullRestricted:\n+      bol = null_free_array_test(array);\n+      break;\n+    case IsAtomic:\n+      \/\/ TODO 8350865 Implement this. It's a bit more complicated, see conditions in JVM_IsAtomicArray\n+      \/\/ Enable TestIntrinsics::test87\/88 once this is implemented\n+      \/\/ bol = null_free_atomic_array_test\n+      return false;\n+    default:\n+      ShouldNotReachHere();\n@@ -4855,3 +4865,4 @@\n-  \/\/ Load next refined array klass if klass is an ObjArrayKlass\n-  RegionNode* refined_region = new RegionNode(2);\n-  Node* refined_phi = new PhiNode(refined_region, klass_t);\n+  Node* res = gvn().transform(new CMoveINode(bol, intcon(0), intcon(1), TypeInt::BOOL));\n+  set_result(res);\n+  return true;\n+}\n@@ -4859,4 +4870,5 @@\n-  generate_typeArray_guard(klass_node, refined_region);\n-  if (refined_region->req() == 3) {\n-    refined_phi->add_req(klass_node);\n-  }\n+\/\/ Load the default refined array klass from an ObjArrayKlass. This relies on the first entry in the\n+\/\/ '_next_refined_array_klass' linked list being the default (see ObjArrayKlass::klass_with_properties).\n+Node* LibraryCallKit::load_default_refined_array_klass(Node* klass_node, bool type_array_guard) {\n+  RegionNode* region = new RegionNode(2);\n+  Node* phi = new PhiNode(region, TypeInstKlassPtr::OBJECT_OR_NULL);\n@@ -4864,0 +4876,6 @@\n+  if (type_array_guard) {\n+    generate_typeArray_guard(klass_node, region);\n+    if (region->req() == 3) {\n+      phi->add_req(klass_node);\n+    }\n+  }\n@@ -4867,3 +4885,1 @@\n-  RegionNode* refined_region2 = new RegionNode(3);\n-  Node* refined_phi2 = new PhiNode(refined_region2, klass_t);\n-\n+  \/\/ Can be null if not initialized yet, just deopt\n@@ -4871,16 +4887,1 @@\n-  Node* null_free_klass = null_check_common(refined_klass, T_OBJECT, false, &null_ctl);\n-  refined_region2->init_req(1, null_ctl);\n-  refined_phi2->init_req(1, klass_node);\n-\n-  refined_region2->init_req(2, control());\n-  refined_phi2->init_req(2, null_free_klass);\n-\n-  set_control(_gvn.transform(refined_region2));\n-  refined_klass = _gvn.transform(refined_phi2);\n-\n-  Node* adr_properties = basic_plus_adr(refined_klass, in_bytes(ObjArrayKlass::properties_offset()));\n-\n-  Node* properties = _gvn.transform(LoadNode::make(_gvn, control(), immutable_memory(), adr_properties, TypeRawPtr::BOTTOM, TypeInt::INT, T_INT, MemNode::unordered));\n-  Node* default_val = makecon(TypeInt::make(ArrayKlass::ArrayProperties::DEFAULT));\n-  Node* chk = _gvn.transform(new CmpINode(properties, default_val));\n-  Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::eq));\n+  refined_klass = null_check_oop(refined_klass, &null_ctl, \/* never_see_null= *\/ true);\n@@ -4888,10 +4889,2 @@\n-  { \/\/ Deoptimize if not the default property\n-    BuildCutout unless(this, tst, PROB_MAX);\n-    uncommon_trap_exact(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n-  }\n-\n-  refined_region->init_req(1, control());\n-  refined_phi->init_req(1, refined_klass);\n-\n-  set_control(_gvn.transform(refined_region));\n-  klass_node = _gvn.transform(refined_phi);\n+  region->init_req(1, control());\n+  phi->init_req(1, refined_klass);\n@@ -4899,1 +4892,2 @@\n-  return klass_node;\n+  set_control(_gvn.transform(region));\n+  return _gvn.transform(phi);\n@@ -4962,1 +4956,1 @@\n-    klass_node = load_default_array_klass(klass_node);\n+    klass_node = load_default_refined_array_klass(klass_node);\n@@ -5064,1 +5058,0 @@\n-    \/\/ TODO 8366668 generate_non_refArray_guard also passed for ref arrays??\n@@ -5067,1 +5060,1 @@\n-    klass_node = load_default_array_klass(klass_node);\n+    klass_node = load_default_refined_array_klass(klass_node, \/* type_array_guard= *\/ false);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":52,"deletions":59,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-  Node* load_default_array_klass(Node* klass_node);\n+  Node* load_default_refined_array_klass(Node* klass_node, bool type_array_guard = true);\n@@ -286,0 +286,2 @@\n+  typedef enum { IsFlat, IsNullRestricted, IsAtomic } ArrayPropertiesCheck;\n+  bool inline_getArrayProperties(ArrayPropertiesCheck check);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2199,6 +2199,2 @@\n-  \/\/ TODO 8366668 Compute the VM type, is this even needed now that we set it earlier? Should we assert instead?\n-  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n-    ary_klass_t = ary_klass_t->get_vm_type();\n-    klass_node = makecon(ary_klass_t);\n-    _igvn.replace_input_of(alloc, AllocateNode::KlassNode, klass_node);\n-  }\n+  assert(!ary_klass_t || !ary_klass_t->klass_is_exact() || !ary_klass_t->exact_klass()->is_obj_array_klass() ||\n+         ary_klass_t->is_vm_type(), \"Must be a refined array klass\");\n@@ -2956,1 +2952,1 @@\n-    \/\/ The matcher expects the input to If nodes to be produced by a Bool(CmpI..)\n+    \/\/ The matcher expects the input to If\/CMove nodes to be produced by a Bool(CmpI..)\n@@ -2965,1 +2961,1 @@\n-          _igvn.replace_input_of(user, j, user->is_If() ? bol : m2b);\n+          _igvn.replace_input_of(user, j, (user->is_If() || user->is_CMove()) ? bol : m2b);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2317,0 +2317,4 @@\n+      if (tkls->offset() == in_bytes(ObjArrayKlass::next_refined_array_klass_offset()) && klass->is_obj_array_klass()) {\n+        \/\/ Fold loads from LibraryCallKit::load_default_refined_array_klass\n+        return tkls->is_aryklassptr()->refined_array_klass_ptr();\n+      }\n@@ -2321,6 +2325,4 @@\n-      if (UseCompactObjectHeaders) { \/\/ TODO: Should EnableValhalla also take this path ?\n-        if (tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n-          \/\/ The field is Klass::_prototype_header. Return its (constant) value.\n-          assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n-          return TypeX::make(klass->prototype_header());\n-        }\n+      if (UseCompactObjectHeaders && tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n+        \/\/ The field is Klass::_prototype_header. Return its (constant) value.\n+        assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n+        return TypeX::make(klass->prototype_header());\n@@ -2662,1 +2664,3 @@\n-    return tary->as_klass_type(true);\n+    const TypeAryKlassPtr* res = tary->as_klass_type(true)->is_aryklassptr();\n+    \/\/ The klass of an array object must be a refined array klass\n+    return res->refined_array_klass_ptr();\n@@ -2742,0 +2746,4 @@\n+  \/\/\n+  \/\/ This optimization does not apply to arrays because if k is not a\n+  \/\/ constant, it was obtained via load_klass which returns the VM type\n+  \/\/ and '.java_mirror.as_klass' should return the Java type instead.\n@@ -2750,1 +2758,0 @@\n-        \/\/ TODO 8366668 Re-enable this for arrays\n@@ -2752,3 +2759,2 @@\n-            && ((tkls->isa_instklassptr() && !tkls->is_instklassptr()->might_be_an_array()) || (tkls->isa_aryklassptr() && false))\n-            && adr2->is_AddP()\n-           ) {\n+            && ((tkls->isa_instklassptr() && !tkls->is_instklassptr()->might_be_an_array()))\n+            && adr2->is_AddP()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -364,4 +364,2 @@\n-  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n-  if (array_klass_type->exact_klass()->is_obj_array_klass()) {\n-    array_klass_type = array_klass_type->isa_aryklassptr()->get_vm_type();\n-  }\n+  const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces);\n+  array_klass_type = array_klass_type->refined_array_klass_ptr();\n@@ -389,5 +387,3 @@\n-  const TypeKlassPtr* array_klass_ptr = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n-  if (array_klass_ptr->exact_klass()->is_obj_array_klass()) {\n-    array_klass_ptr = array_klass_ptr->isa_aryklassptr()->get_vm_type();\n-  }\n-  Node* array = new_array(makecon(array_klass_ptr), length, nargs);\n+  const TypeAryKlassPtr* array_klass_type = TypeAryKlassPtr::make(array_klass, Type::trust_interfaces);\n+  array_klass_type = array_klass_type->refined_array_klass_ptr();\n+  Node* array = new_array(makecon(array_klass_type), length, nargs);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -217,4 +217,2 @@\n-      \/\/ TODO 8366668 TestLWorld and TestLWorldProfiling are sensitive to this. But this hack just assumes we always have the default properties ...\n-      if (extak->exact_klass()->is_obj_array_klass()) {\n-        extak = extak->get_vm_type();\n-      }\n+      \/\/ For a direct pointer comparison, we need the refined array klass pointer\n+      extak = extak->refined_array_klass_ptr();\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1145,1 +1145,1 @@\n-static inline Node* isa_java_mirror_load(PhaseGVN* phase, Node* n) {\n+static inline Node* isa_java_mirror_load(PhaseGVN* phase, Node* n, bool& might_be_an_array) {\n@@ -1167,0 +1167,1 @@\n+  might_be_an_array |= tkp->isa_aryklassptr() || tkp->is_instklassptr()->might_be_an_array();\n@@ -1172,1 +1173,1 @@\n-static inline Node* isa_const_java_mirror(PhaseGVN* phase, Node* n) {\n+static inline Node* isa_const_java_mirror(PhaseGVN* phase, Node* n, bool& might_be_an_array) {\n@@ -1192,2 +1193,11 @@\n-  assert(mirror_type->is_klass(), \"mirror_type should represent a Klass*\");\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(), Type::trust_interfaces));\n+  ciKlass* mirror_klass = mirror_type->as_klass();\n+\n+  if (mirror_klass->is_array_klass()) {\n+    if (!mirror_klass->can_be_inline_array_klass()) {\n+      \/\/ Special case for non-value arrays: They only have one (default) refined class, use it\n+      return phase->makecon(TypeAryKlassPtr::make(mirror_klass, Type::trust_interfaces, true));\n+    }\n+    might_be_an_array |= true;\n+  }\n+\n+  return phase->makecon(TypeKlassPtr::make(mirror_klass, Type::trust_interfaces));\n@@ -1224,3 +1234,10 @@\n-    Node* k1 = isa_java_mirror_load(phase, in(1));\n-    Node* k2 = isa_java_mirror_load(phase, in(2));\n-    Node* conk2 = isa_const_java_mirror(phase, in(2));\n+    bool might_be_an_array1 = false;\n+    bool might_be_an_array2 = false;\n+    Node* k1 = isa_java_mirror_load(phase, in(1), might_be_an_array1);\n+    Node* k2 = isa_java_mirror_load(phase, in(2), might_be_an_array2);\n+    Node* conk2 = isa_const_java_mirror(phase, in(2), might_be_an_array2);\n+    if (might_be_an_array1 && might_be_an_array2) {\n+      \/\/ Don't optimize if both sides might be an array because arrays with\n+      \/\/ the same Java mirror can have different refined array klasses.\n+      k1 = k2 = nullptr;\n+    }\n@@ -1228,3 +1245,1 @@\n-    \/\/ TODO 8366668 add a test for this. Improve this condition\n-    bool doIt = (conk2 && !phase->type(conk2)->isa_aryklassptr());\n-    if (k1 && (k2 || conk2) && doIt) {\n+    if (k1 && (k2 || conk2)) {\n@@ -1284,7 +1299,0 @@\n-  \/\/ Do not fold the subtype check to an array klass pointer comparison for null-able inline type arrays\n-  \/\/ because null-free [LMyValue <: null-able [LMyValue but the klasses are different. Perform a full test.\n-  if (superklass->is_obj_array_klass() && !superklass->as_array_klass()->is_elem_null_free() &&\n-      superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n-    return nullptr;\n-  }\n-\n@@ -1314,0 +1322,14 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for\n+  \/\/ value class arrays because they can have multiple refined array klasses.\n+  superklass = t2->exact_klass();\n+  assert(!superklass->is_flat_array_klass(), \"Unexpected flat array klass\");\n+  if (superklass->is_obj_array_klass()) {\n+    if (!superklass->as_array_klass()->is_elem_null_free() &&\n+         superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+      return nullptr;\n+    } else {\n+      \/\/ Special case for non-value arrays: They only have one (default) refined class, use it\n+      set_req_X(2, phase->makecon(t2->is_aryklassptr()->refined_array_klass_ptr()), phase);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":39,"deletions":17,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -132,1 +132,2 @@\n-  assert(verify(phase), \"missing Value() optimization\");\n+  \/\/ TODO 8370341 fails with TestArrayCopyAsLoadsStores\n+  \/\/ assert(verify(phase), \"missing Value() optimization\");\n@@ -209,2 +210,1 @@\n-        \/\/ TODO 8366668 Re-enable. This breaks TestArrays.java with -XX:+StressReflectiveCode\n-        bool might_be_cache = true; \/\/ (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+        bool might_be_cache = phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con;\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6627,1 +6627,6 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::get_vm_type(bool vm_type) const {\n+\/\/ Get the refined array klass ptr\n+\/\/ TODO 8370341 We should also evaluate if we can get rid of the _vm_type and if we should split ciObjArrayKlass into ciRefArrayKlass and ciFlatArrayKlass like the runtime now does.\n+const TypeAryKlassPtr* TypeAryKlassPtr::refined_array_klass_ptr() const {\n+  if (!klass_is_exact() || !exact_klass()->is_obj_array_klass()) {\n+    return this;\n+  }\n@@ -6632,2 +6637,2 @@\n-  ciKlass* array_klass = ciArrayKlass::make(eklass, is_null_free(), is_atomic(), true);\n-  return make(_ptr, array_klass, Offset(0), trust_interfaces, vm_type);\n+  ciKlass* array_klass = ciArrayKlass::make(eklass, eklass->is_inlinetype() ? is_null_free() : false, eklass->is_inlinetype() ? is_atomic() : true, true);\n+  return make(_ptr, array_klass, Offset(0), trust_interfaces, true);\n@@ -6945,0 +6950,5 @@\n+    if (res_xk && _vm_type != tap->_vm_type) {\n+      \/\/ This can happen if the phi emitted by LibraryCallKit::load_default_refined_array_klass is folded\n+      \/\/ before the typeArray guard is folded. Keep the information that this is a refined klass pointer.\n+      vm_type = true;\n+    }\n@@ -7134,1 +7144,1 @@\n-    k = ciArrayKlass::make(k, is_null_free(), is_atomic(), _vm_type);\n+    k = ciArrayKlass::make(k, k->is_inlinetype() ? is_null_free() : false, k->is_inlinetype() ? is_atomic() : true, _vm_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2118,1 +2118,1 @@\n-  const TypeAryKlassPtr* get_vm_type(bool vm_type = true) const;\n+  const TypeAryKlassPtr* refined_array_klass_ptr() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1681,1 +1681,1 @@\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT) - InlineKlass::cast(vk)->payload_offset();\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT) - vk->payload_offset();\n@@ -1684,1 +1684,1 @@\n-    ScopeValue* val = sv->field_at(i);\n+    ObjectValue* val = sv->field_at(i)->as_ObjectValue();\n@@ -1687,0 +1687,9 @@\n+    if (!obj->is_null_free_array()) {\n+      jboolean null_marker_value;\n+      if (val->has_properties()) {\n+        null_marker_value = StackValue::create_stack_value(fr, reg_map, val->properties())->get_jint() & 1;\n+      } else {\n+        null_marker_value = 1;\n+      }\n+      obj->bool_field_put(offset + vk->null_marker_offset(), null_marker_value);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -87,0 +87,4 @@\n+    \/**\n+     * {@return true if the given array is a flat array}\n+     *\/\n+    @IntrinsicCandidate\n@@ -98,0 +102,1 @@\n+    @IntrinsicCandidate\n@@ -103,0 +108,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @ignore TODO 8366668\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,2 +59,1 @@\n-        \/\/ TODO 8366668 This currently fails\n-        \/\/ ARRAY_STORE_EXCEPTION(\"array_check\"),\n+        ARRAY_STORE_EXCEPTION(\"array_check\"),\n@@ -106,2 +105,0 @@\n-            \/\/ TODO 8366668 Re-enable\n-            \/*\n@@ -111,1 +108,0 @@\n-            *\/\n@@ -161,2 +157,2 @@\n-        Asserts.assertEQ(trapCount, invocations, \"Trap count must much invocation count.\");\n-        Asserts.assertEQ(trapCountSpecific, invocations, \"Trap count must much invocation count.\");\n+        Asserts.assertEQ(trapCount, invocations, \"Trap count must match invocation count.\");\n+        Asserts.assertEQ(trapCountSpecific, invocations, \"Trap count must match invocation count.\");\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/OptimizeImplicitExceptions.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -102,2 +102,1 @@\n-        \/\/ TODO 8366668 Re-enable IR verification\n-        test.addFlags(\"-DVerifyIR=false\", \"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n+        test.addFlags(\"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,11 @@\n+\/*\n+ * @test id=stress-reflective-code\n+ * @summary Stress test the VM internal metadata for arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm\/timeout=300 -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                               compiler.valhalla.inlinetypes.TestArrayMetadata\n+ *\/\n+\n@@ -107,0 +118,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -215,0 +227,12 @@\n+    static value class MyIntegerValue {\n+        int x = 42;\n+    }\n+\n+    public static Class getArrayClass6() {\n+        return MyIntegerValue[].class;\n+    }\n+\n+    public static boolean testIsInstance6(Object arg) {\n+        return getArrayClass6().isInstance(arg);\n+    }\n+\n@@ -421,0 +445,5 @@\n+            MyIntegerValue[] nullFreeArray6 = (MyIntegerValue[])ValueClass.newNullRestrictedNonAtomicArray(MyIntegerValue.class, 3, new MyIntegerValue());\n+            MyIntegerValue[] nullFreeAtomicArray6 = (MyIntegerValue[])ValueClass.newNullRestrictedAtomicArray(MyIntegerValue.class, 3, new MyIntegerValue());\n+            MyIntegerValue[] nullableArray6 = new MyIntegerValue[3];\n+            MyIntegerValue[] nullableAtomicArray6 = (MyIntegerValue[])ValueClass.newNullableAtomicArray(MyIntegerValue.class, 3);\n+\n@@ -423,0 +452,4 @@\n+            Asserts.assertTrue(testIsInstance1(nullFreeArray6));\n+            Asserts.assertTrue(testIsInstance1(nullFreeAtomicArray6));\n+            Asserts.assertTrue(testIsInstance1(nullableArray6));\n+            Asserts.assertTrue(testIsInstance1(nullableAtomicArray6));\n@@ -441,0 +474,4 @@\n+            Asserts.assertTrue(testIsInstance3(nullFreeArray6));\n+            Asserts.assertTrue(testIsInstance3(nullFreeAtomicArray6));\n+            Asserts.assertTrue(testIsInstance3(nullableArray6));\n+            Asserts.assertTrue(testIsInstance3(nullableAtomicArray6));\n@@ -450,0 +487,4 @@\n+            Asserts.assertTrue(testIsInstance4(nullFreeArray6));\n+            Asserts.assertTrue(testIsInstance4(nullFreeAtomicArray6));\n+            Asserts.assertTrue(testIsInstance4(nullableArray6));\n+            Asserts.assertTrue(testIsInstance4(nullableAtomicArray6));\n@@ -462,0 +503,7 @@\n+            Asserts.assertFalse(testIsInstance6(new Object[0]));\n+            Asserts.assertFalse(testIsInstance6(42));\n+            Asserts.assertTrue(testIsInstance6(nullFreeArray6));\n+            Asserts.assertTrue(testIsInstance6(nullFreeAtomicArray6));\n+            Asserts.assertTrue(testIsInstance6(nullableArray6));\n+            Asserts.assertTrue(testIsInstance6(nullableAtomicArray6));\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayMetadata.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -556,0 +556,1 @@\n+    }\n@@ -557,0 +558,1 @@\n+    public static void testScalarReplacement2(OneByte valNullFree, OneByte val, boolean trap) {\n@@ -564,0 +566,1 @@\n+    }\n@@ -565,0 +568,1 @@\n+    public static void testScalarReplacement3(OneByte valNullFree, OneByte val, boolean trap) {\n@@ -576,0 +580,1 @@\n+    }\n@@ -577,0 +582,1 @@\n+    public static void testScalarReplacement4(OneByte valNullFree, OneByte val, boolean trap) {\n@@ -590,2 +596,1 @@\n-    \/\/ Test support for scalar replaced arrays\n-    public static void testScalarReplacement2(TwoBytes val, boolean trap) {\n+    public static void testScalarReplacement5(TwoBytes val, boolean trap) {\n@@ -597,0 +602,1 @@\n+    }\n@@ -598,0 +604,1 @@\n+    public static void testScalarReplacement6(TwoBytes val, boolean trap) {\n@@ -603,0 +610,1 @@\n+    }\n@@ -604,0 +612,1 @@\n+    public static void testScalarReplacement7(TwoBytes val, boolean trap) {\n@@ -611,0 +620,1 @@\n+    }\n@@ -612,0 +622,1 @@\n+    public static void testScalarReplacement8(TwoBytes val, boolean trap) {\n@@ -1244,1 +1255,7 @@\n-            testScalarReplacement2(val1, false);\n+            testScalarReplacement2(val0, null, false);\n+            testScalarReplacement3(val0, null, false);\n+            testScalarReplacement4(val0, null, false);\n+            testScalarReplacement5(val1, false);\n+            testScalarReplacement6(val1, false);\n+            testScalarReplacement7(val1, false);\n+            testScalarReplacement8(val1, false);\n@@ -1396,1 +1413,7 @@\n-        testScalarReplacement2(CANARY1, true);\n+        testScalarReplacement2(CANARY0, null, true);\n+        testScalarReplacement3(CANARY0, null, true);\n+        testScalarReplacement4(CANARY0, null, true);\n+        testScalarReplacement5(CANARY1, true);\n+        testScalarReplacement6(CANARY1, true);\n+        testScalarReplacement7(CANARY1, true);\n+        testScalarReplacement8(CANARY1, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2841,2 +2841,1 @@\n-    \/\/ TODO 8366668\n-    \/\/ @IR(failOn = {INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP, CLASS_CHECK_TRAP})\n+    @IR(failOn = {INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP, CLASS_CHECK_TRAP})\n@@ -3256,2 +3255,2 @@\n-    \/\/ TODO 8366668\n-    \/\/ @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import static compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD;\n@@ -1693,0 +1694,24 @@\n+    static value class SimpleValue {\n+        byte x = 1;\n+        byte y = 1;\n+\n+        static SimpleValue DEFAULT = new SimpleValue();\n+    }\n+\n+    private static final SimpleValue[] TEST_ARRAY1 = (SimpleValue[])ValueClass.newNullRestrictedNonAtomicArray(SimpleValue.class, 1, SimpleValue.DEFAULT);\n+    private static final SimpleValue[] TEST_ARRAY2 = (SimpleValue[])ValueClass.newNullRestrictedAtomicArray(SimpleValue.class, 1, SimpleValue.DEFAULT);\n+    private static final SimpleValue[] TEST_ARRAY3 = (SimpleValue[])ValueClass.newNullableAtomicArray(SimpleValue.class, 1);\n+    private static final SimpleValue[] TEST_ARRAY4 = new SimpleValue[1];\n+    private static final boolean TEST_ARRAY1_IS_FLAT = ValueClass.isFlatArray(TEST_ARRAY1);\n+    private static final boolean TEST_ARRAY2_IS_FLAT = ValueClass.isFlatArray(TEST_ARRAY2);\n+    private static final boolean TEST_ARRAY3_IS_FLAT = ValueClass.isFlatArray(TEST_ARRAY3);\n+    private static final boolean TEST_ARRAY4_IS_FLAT = ValueClass.isFlatArray(TEST_ARRAY4);\n+    private static final boolean TEST_ARRAY1_IS_NULL_RESTRICTED = ValueClass.isNullRestrictedArray(TEST_ARRAY1);\n+    private static final boolean TEST_ARRAY2_IS_NULL_RESTRICTED = ValueClass.isNullRestrictedArray(TEST_ARRAY2);\n+    private static final boolean TEST_ARRAY3_IS_NULL_RESTRICTED = ValueClass.isNullRestrictedArray(TEST_ARRAY3);\n+    private static final boolean TEST_ARRAY4_IS_NULL_RESTRICTED = ValueClass.isNullRestrictedArray(TEST_ARRAY4);\n+    private static final boolean TEST_ARRAY1_IS_ATOMIC = ValueClass.isAtomicArray(TEST_ARRAY1);\n+    private static final boolean TEST_ARRAY2_IS_ATOMIC = ValueClass.isAtomicArray(TEST_ARRAY2);\n+    private static final boolean TEST_ARRAY3_IS_ATOMIC = ValueClass.isAtomicArray(TEST_ARRAY3);\n+    private static final boolean TEST_ARRAY4_IS_ATOMIC = ValueClass.isAtomicArray(TEST_ARRAY4);\n+\n@@ -1695,0 +1720,1 @@\n+    @IR(failOn = {STATIC_CALL_OF_METHOD, \"jdk.internal.value.ValueClass::isFlatArray\"})\n@@ -1701,4 +1727,7 @@\n-        Asserts.assertEQ(test81(TEST33_ARRAY), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n-        Asserts.assertFalse(test81(new String[0]), \"test81_2 failed\");\n-        Asserts.assertFalse(test81(\"test\"), \"test81_3 failed\");\n-        Asserts.assertFalse(test81(new int[0]), \"test81_4 failed\");\n+        Asserts.assertEQ(test81(TEST_ARRAY1), TEST_ARRAY1_IS_FLAT, \"test81_1 failed\");\n+        Asserts.assertEQ(test81(TEST_ARRAY2), TEST_ARRAY2_IS_FLAT, \"test81_2 failed\");\n+        Asserts.assertEQ(test81(TEST_ARRAY3), TEST_ARRAY3_IS_FLAT, \"test81_3 failed\");\n+        Asserts.assertEQ(test81(TEST_ARRAY4), TEST_ARRAY4_IS_FLAT, \"test81_4 failed\");\n+        Asserts.assertFalse(test81(new String[0]), \"test81_5 failed\");\n+        Asserts.assertFalse(test81(\"test\"), \"test81_6 failed\");\n+        Asserts.assertFalse(test81(new int[0]), \"test81_7 failed\");\n@@ -1707,2 +1736,1 @@\n-    \/\/ Verify that ValueClass::isFlatArray checks with statically known classes\n-    \/\/ are folded\n+    \/\/ Verify that ValueClass::isFlatArray checks with statically known classes are folded\n@@ -1710,1 +1738,1 @@\n-    @IR(failOn = {LOAD_KLASS})\n+    @IR(failOn = {LOAD_KLASS, STATIC_CALL_OF_METHOD, \"jdk.internal.value.ValueClass::isFlatArray\"})\n@@ -1712,2 +1740,2 @@\n-        boolean check1 = ValueClass.isFlatArray(TEST33_ARRAY);\n-        if (!TEST33_FLATTENED_ARRAY) {\n+        boolean check1 = ValueClass.isFlatArray(TEST_ARRAY1);\n+        if (!TEST_ARRAY1_IS_FLAT) {\n@@ -1716,4 +1744,16 @@\n-        boolean check2 = !ValueClass.isFlatArray(new String[0]);\n-        boolean check3 = !ValueClass.isFlatArray(\"test\");\n-        boolean check4 = !ValueClass.isFlatArray(new int[0]);\n-        return check1 && check2 && check3 && check4;\n+        boolean check2 = ValueClass.isFlatArray(TEST_ARRAY2);\n+        if (!TEST_ARRAY2_IS_FLAT) {\n+            check2 = !check2;\n+        }\n+        boolean check3 = ValueClass.isFlatArray(TEST_ARRAY3);\n+        if (!TEST_ARRAY3_IS_FLAT) {\n+            check3 = !check3;\n+        }\n+        boolean check4 = ValueClass.isFlatArray(TEST_ARRAY4);\n+        if (!TEST_ARRAY4_IS_FLAT) {\n+            check4 = !check4;\n+        }\n+        boolean check5 = !ValueClass.isFlatArray(new String[0]);\n+        boolean check6 = !ValueClass.isFlatArray(\"test\");\n+        boolean check7 = !ValueClass.isFlatArray(new int[0]);\n+        return check1 && check2 && check3 && check4 && check5 && check6 && check7;\n@@ -1800,0 +1840,100 @@\n+\n+    \/\/ Test correctness of the ValueClass::isNullRestrictedArray intrinsic\n+    @Test\n+    @IR(failOn = {STATIC_CALL_OF_METHOD, \"jdk.internal.value.ValueClass::isNullRestrictedArray\"})\n+    public boolean test85(Object array) {\n+        return ValueClass.isNullRestrictedArray(array);\n+    }\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier() {\n+        Asserts.assertEQ(test85(TEST_ARRAY1), TEST_ARRAY1_IS_NULL_RESTRICTED, \"test85_1 failed\");\n+        Asserts.assertEQ(test85(TEST_ARRAY2), TEST_ARRAY2_IS_NULL_RESTRICTED, \"test85_2 failed\");\n+        Asserts.assertEQ(test85(TEST_ARRAY3), TEST_ARRAY3_IS_NULL_RESTRICTED, \"test85_3 failed\");\n+        Asserts.assertEQ(test85(TEST_ARRAY4), TEST_ARRAY4_IS_NULL_RESTRICTED, \"test85_4 failed\");\n+        Asserts.assertFalse(test85(new String[0]), \"test85_5 failed\");\n+        Asserts.assertFalse(test85(\"test\"), \"test85_6 failed\");\n+        Asserts.assertFalse(test85(new int[0]), \"test85_7 failed\");\n+    }\n+\n+    \/\/ Verify that ValueClass::isNullRestrictedArray checks with statically known classes are folded\n+    @Test\n+    @IR(failOn = {LOAD_KLASS, STATIC_CALL_OF_METHOD, \"jdk.internal.value.ValueClass::isNullRestrictedArray\"})\n+    public boolean test86() {\n+        boolean check1 = ValueClass.isNullRestrictedArray(TEST_ARRAY1);\n+        if (!TEST_ARRAY1_IS_NULL_RESTRICTED) {\n+            check1 = !check1;\n+        }\n+        boolean check2 = ValueClass.isNullRestrictedArray(TEST_ARRAY2);\n+        if (!TEST_ARRAY2_IS_NULL_RESTRICTED) {\n+            check2 = !check2;\n+        }\n+        boolean check3 = ValueClass.isNullRestrictedArray(TEST_ARRAY3);\n+        if (!TEST_ARRAY3_IS_NULL_RESTRICTED) {\n+            check3 = !check3;\n+        }\n+        boolean check4 = ValueClass.isNullRestrictedArray(TEST_ARRAY4);\n+        if (!TEST_ARRAY4_IS_NULL_RESTRICTED) {\n+            check4 = !check4;\n+        }\n+        boolean check5 = !ValueClass.isNullRestrictedArray(new String[0]);\n+        boolean check6 = !ValueClass.isNullRestrictedArray(\"test\");\n+        boolean check7 = !ValueClass.isNullRestrictedArray(new int[0]);\n+        return check1 && check2 && check3 && check4 && check5 && check6 && check7;\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier() {\n+        Asserts.assertTrue(test86(), \"test86 failed\");\n+    }\n+\n+    \/\/ Test correctness of the ValueClass::isAtomicArray intrinsic\n+    @Test\n+    \/\/ TODO 8350865 Implemented intrinsic\n+    \/\/ @IR(failOn = {STATIC_CALL_OF_METHOD, \"jdk.internal.value.ValueClass::isAtomicArray\"})\n+    public boolean test87(Object array) {\n+        return ValueClass.isAtomicArray(array);\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier() {\n+        Asserts.assertEQ(test87(TEST_ARRAY1), TEST_ARRAY1_IS_ATOMIC, \"test87_1 failed\");\n+        Asserts.assertEQ(test87(TEST_ARRAY2), TEST_ARRAY2_IS_ATOMIC, \"test87_2 failed\");\n+        Asserts.assertEQ(test87(TEST_ARRAY3), TEST_ARRAY3_IS_ATOMIC, \"test87_3 failed\");\n+        Asserts.assertEQ(test87(TEST_ARRAY4), TEST_ARRAY4_IS_ATOMIC, \"test87_4 failed\");\n+        Asserts.assertTrue(test87(new String[0]), \"test87_5 failed\");\n+        Asserts.assertFalse(test87(\"test\"), \"test87_6 failed\");\n+        Asserts.assertFalse(test87(new int[0]), \"test87_7 failed\");\n+    }\n+\n+    \/\/ Verify that ValueClass::isAtomicArray checks with statically known classes are folded\n+    @Test\n+    \/\/ TODO 8350865 Implemented intrinsic\n+    \/\/ @IR(failOn = {LOAD_KLASS, STATIC_CALL_OF_METHOD, \"jdk.internal.value.ValueClass::isAtomicArray\"})\n+    public boolean test88() {\n+        boolean check1 = ValueClass.isAtomicArray(TEST_ARRAY1);\n+        if (!TEST_ARRAY1_IS_ATOMIC) {\n+            check1 = !check1;\n+        }\n+        boolean check2 = ValueClass.isAtomicArray(TEST_ARRAY2);\n+        if (!TEST_ARRAY2_IS_ATOMIC) {\n+            check2 = !check2;\n+        }\n+        boolean check3 = ValueClass.isAtomicArray(TEST_ARRAY3);\n+        if (!TEST_ARRAY3_IS_ATOMIC) {\n+            check3 = !check3;\n+        }\n+        boolean check4 = ValueClass.isAtomicArray(TEST_ARRAY4);\n+        if (!TEST_ARRAY4_IS_ATOMIC) {\n+            check4 = !check4;\n+        }\n+        boolean check5 = ValueClass.isAtomicArray(new String[0]);\n+        boolean check6 = !ValueClass.isAtomicArray(\"test\");\n+        boolean check7 = !ValueClass.isAtomicArray(new int[0]);\n+        return check1 && check2 && check3 && check4 && check5 && check6 && check7;\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier() {\n+        Asserts.assertTrue(test88(), \"test88 failed\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":153,"deletions":13,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import static compiler.lib.ir_framework.IRNode.LOAD_P;\n@@ -3495,2 +3496,1 @@\n-        \/\/ TODO 8366668 Re-enable\n-        \/\/ Asserts.assertEquals(arr1[0], new MyValueEmpty());\n+        Asserts.assertEquals(arr1[0], new MyValueEmpty());\n@@ -3541,1 +3541,1 @@\n-        MyValueEmpty[]   array1 = new MyValueEmpty[] { empty };\n+        MyValueEmpty[]   array1 = new MyValueEmpty[] { empty, null };\n@@ -3550,2 +3550,2 @@\n-        \/\/ TODO 8366668 Re-enable\n-        \/\/ Asserts.assertEquals(array1[0], empty);\n+        Asserts.assertEquals(array1[0], empty);\n+        Asserts.assertEquals(array1[1], null);\n@@ -4683,0 +4683,94 @@\n+\n+    \/\/ Check that comparisons between Java mirrors are optimized to comparisons of the klass\n+    @Test\n+    @IR(failOn = {LOAD_P})\n+    public boolean test168(Object o) {\n+        return o.getClass() == NonValueClass.class;\n+    }\n+\n+    @Run(test = \"test168\")\n+    public void test168_verifier() {\n+        Asserts.assertTrue(test168(new NonValueClass(rI)));\n+        Asserts.assertFalse(test168(new NonValueClass[0]));\n+        Asserts.assertFalse(test168(42));\n+        Asserts.assertFalse(test168(new int[0]));\n+    }\n+\n+    @Test\n+    @IR(failOn = {LOAD_P})\n+    public boolean test169(Object o) {\n+        return o.getClass() == NonValueClass[].class;\n+    }\n+\n+    @Run(test = \"test169\")\n+    public void test169_verifier() {\n+        Asserts.assertFalse(test169(new NonValueClass(rI)));\n+        Asserts.assertTrue(test169(new NonValueClass[0]));\n+        Asserts.assertFalse(test169(42));\n+        Asserts.assertFalse(test169(new int[0]));\n+    }\n+\n+    @Test\n+    @IR(counts = {LOAD_P, \"= 2\"}) \/\/ Can't be optimized because o could be an array\n+    public boolean test170(Object o) {\n+        return o.getClass() == MyValue1[].class;\n+    }\n+\n+    @Run(test = \"test170\")\n+    public void test170_verifier() {\n+        Asserts.assertFalse(test170(new NonValueClass(rI)));\n+        Asserts.assertTrue(test170(new MyValue1[0]));\n+        Asserts.assertTrue(test170(ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT)));\n+        Asserts.assertTrue(test170(ValueClass.newNullRestrictedAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT)));\n+        Asserts.assertTrue(test170(ValueClass.newNullableAtomicArray(MyValue1.class, 0)));\n+        Asserts.assertFalse(test170(42));\n+        Asserts.assertFalse(test170(new int[0]));\n+    }\n+\n+    @Test\n+    @IR(counts = {LOAD_P, \"= 4\"}) \/\/ Can't be optimized because o1 and o2 could be arrays\n+    public boolean test171(Object o1, Object o2) {\n+        return o1.getClass() == o2.getClass();\n+    }\n+\n+    @Run(test = \"test171\")\n+    public void test171_verifier() {\n+        Asserts.assertTrue(test171(new NonValueClass(rI), new NonValueClass(rI)));\n+        Asserts.assertTrue(test171(new NonValueClass[0], new NonValueClass[0]));\n+        Asserts.assertTrue(test171(ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT), new MyValue1[0]));\n+        Asserts.assertTrue(test171(ValueClass.newNullRestrictedAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT), new MyValue1[0]));\n+        Asserts.assertTrue(test171(ValueClass.newNullableAtomicArray(MyValue1.class, 0), new MyValue1[0]));\n+        Asserts.assertTrue(test171(ValueClass.newNullRestrictedAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT), ValueClass.newNullableAtomicArray(MyValue1.class, 0)));\n+        Asserts.assertFalse(test171(42, new int[0]));\n+        Asserts.assertFalse(test171(new NonValueClass(rI), 42));\n+    }\n+\n+    @Test\n+    @IR(failOn = {LOAD_P})\n+    public boolean test172(NonValueClass o1, Object o2) {\n+        return o1.getClass() == o2.getClass();\n+    }\n+\n+    @Run(test = \"test172\")\n+    public void test172_verifier() {\n+        Asserts.assertTrue(test172(new NonValueClass(rI), new NonValueClass(rI)));\n+        Asserts.assertFalse(test172(new NonValueClass(rI), new NonValueClass[0]));\n+        Asserts.assertFalse(test172(new NonValueClass(rI), new MyValue1[0]));\n+        Asserts.assertFalse(test172(new NonValueClass(rI), 42));\n+    }\n+\n+    @Test\n+    @IR(counts = {LOAD_P, \"= 4\"}) \/\/ Can't be optimized because o1 and o2 could be arrays\n+    public boolean test173(Cloneable o1, Object o2) {\n+        return o1.getClass() == o2.getClass();\n+    }\n+\n+    @Run(test = \"test173\")\n+    public void test173_verifier() {\n+        Asserts.assertTrue(test173(new NonValueClass[0], new NonValueClass[0]));\n+        Asserts.assertTrue(test173(ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT), new MyValue1[0]));\n+        Asserts.assertTrue(test173(ValueClass.newNullRestrictedAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT), new MyValue1[0]));\n+        Asserts.assertTrue(test173(ValueClass.newNullableAtomicArray(MyValue1.class, 0), new MyValue1[0]));\n+        Asserts.assertTrue(test173(ValueClass.newNullRestrictedAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT), ValueClass.newNullableAtomicArray(MyValue1.class, 0)));\n+        Asserts.assertFalse(test173(new boolean[0], new int[0]));\n+    }\n@@ -4684,0 +4778,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":100,"deletions":5,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+import jdk.internal.value.ValueClass;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that the correct default refined klass is loaded by intrinsics.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.valhalla.inlinetypes.TestLoadingDefaultRefinedArrayKlass\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*TestLoadingDefaultRefinedArrayKlass::test*\n+ *                   -XX:+UseArrayFlattening -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestLoadingDefaultRefinedArrayKlass\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*TestLoadingDefaultRefinedArrayKlass::test*\n+ *                   -XX:-UseArrayFlattening\n+ *                   compiler.valhalla.inlinetypes.TestLoadingDefaultRefinedArrayKlass\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=compileonly,*TestLoadingDefaultRefinedArrayKlass::test* -XX:-TieredCompilation\n+ *                   compiler.valhalla.inlinetypes.TestLoadingDefaultRefinedArrayKlass\n+ *\/\n+public class TestLoadingDefaultRefinedArrayKlass {\n+\n+    private static final WhiteBox WHITEBOX = WhiteBox.getWhiteBox();\n+    private static final boolean UseArrayFlattening = WHITEBOX.getBooleanVMFlag(\"UseArrayFlattening\");\n+\n+    static value class MyValue1 {\n+        int x = 42;\n+    }\n+\n+    static value class MyValue2 {\n+        int x = 42;\n+    }\n+\n+    static value class MyValue3 {\n+        int x = 42;\n+    }\n+\n+    public static Object[] test1(Object[] array, Class<? extends Object[]> arrayType) {\n+        return Arrays.copyOf(array, 1, arrayType);\n+    }\n+\n+    public static Object[] test2(Class<?> componentType) {\n+        return (Object[])Array.newInstance(componentType, 1);\n+    }\n+\n+    public static Object[] test3(Class<?> componentType) {\n+        return (Object[])Array.newInstance(componentType, 1);\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Make sure that a non-initialized refined array klass is handled\n+\n+        \/\/ Make sure stuff is loaded\n+        Arrays.copyOf(new Object[0], 1, Object[].class);\n+        Array.newInstance(Integer.class, 1);\n+\n+        Object[] res1 = test1(new Object[1], MyValue1[].class);\n+        Asserts.assertEquals(ValueClass.isFlatArray(res1), UseArrayFlattening);\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray(res1));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(res1));\n+\n+        Class c = MyValue2[].class; \/\/ Make sure the array klass mirror is created\n+        Object[] res2 = test2(MyValue2.class);\n+        Asserts.assertEquals(ValueClass.isFlatArray(res2), UseArrayFlattening);\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray(res2));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(res2));\n+\n+        \/\/ Pollute the system with non-default refined array klasses\n+        MyValue3[] tmp1 = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, new MyValue3());\n+        MyValue3[] tmp2 = (MyValue3[])ValueClass.newNullRestrictedAtomicArray(MyValue3.class, 1, new MyValue3());\n+        MyValue3[] tmp3 = (MyValue3[])ValueClass.newNullableAtomicArray(MyValue3.class, 1);\n+\n+        \/\/ Now assert that the default refined array klass is loaded by the intrinsics\n+        MyValue3[] array = new MyValue3[1];\n+        for (int i = 0; i < 50_000; ++i) {\n+            res1 = test1(array, MyValue3[].class);\n+            Asserts.assertEquals(ValueClass.isFlatArray(res1), UseArrayFlattening);\n+            Asserts.assertFalse(ValueClass.isNullRestrictedArray(res1));\n+            Asserts.assertTrue(ValueClass.isAtomicArray(res1));\n+\n+            res2 = test2(MyValue3.class);\n+            Asserts.assertEquals(ValueClass.isFlatArray(res2), UseArrayFlattening);\n+            Asserts.assertFalse(ValueClass.isNullRestrictedArray(res2));\n+            Asserts.assertTrue(ValueClass.isAtomicArray(res2));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLoadingDefaultRefinedArrayKlass.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"}]}