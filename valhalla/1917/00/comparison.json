{"files":[{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * Indicates an integral type that supports:\n+ * <ul>\n+ * <li>{@linkplain Numerical arithmetic operations} ({@code +}, {@code\n+ * -}, {@code*}, {@code \/}, {@code %}) and so on.\n+ *\n+ * <li>{@linkplain Orderable ordered comparison operators}\n+ * ({@code <}, {@code <=}, {@code >}, {@code >=})\n+ *\n+ * <li>integer-related bit-wise operators ({@code &}, {@code |},\n+ * {@code ^}, {@code ~})\n+ *\n+ * <li>shifts ({@code * <<}, {@code >>}, {@code >>>})\n+ *\n+ * <\/ul>\n+ *\n+ * and participates in operator overloading of all those operators.\n+ *\n+ * @param <IT> The integral type\n+ *\/\n+public interface Integral<IT>\n+    extends Numerical<IT>, Orderable<IT> {\n+\n+    \/**\n+     * {@return the AND of the two operands, binary operator \"{@code &}\"}\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+    IT and(IT op1, IT op2);\n+\n+    \/**\n+     * {@return the OR of the two operands, binary operator \"{@code |}\"}\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+    IT or(IT op1, IT op2);\n+\n+    \/**\n+     * {@return the XOR of the two operands, binary operator \"{@code ^}\"}\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+    IT xor(IT op1, IT op2);\n+\n+    \/**\n+     * {@return the complement of the operand, unary operator \"{@code ~}\"}\n+     *\n+     * @param op1 the operand\n+     * @throws UnsupportedOperationException if complement is not supposed\n+     *\/\n+    IT complement(IT op1);\n+\n+    \/**\n+     * {@return the first operand left shifted by the distance\n+     * indicated by the second operand, binary operator \"{@code <<\"}}\n+     *\n+     * @param x the operand to be shifted\n+     * @param shiftDistance the shift distance\n+     *\/\n+    IT shiftLeft(IT x, int shiftDistance);\n+\n+    \/**\n+     * {@return the first operand right shifted by the distance\n+     * indicated by the second operand, operator \"{@code >>}\"}\n+     *\n+     * @param x the operand to be shifted\n+     * @param shiftDistance the shift distance\n+     *\/\n+    IT shiftRight(IT x, int shiftDistance);\n+\n+    \/**\n+     * {@return the first operand right shifted, unsigned, by the\n+     * distance indicated by the second operand, operator \"{@code >>>}\"}\n+     *\n+     * @param x the operand to be shifted\n+     * @param shiftDistance the shift distance\n+     * @throws UnsupportedOperationException if unsigned right shift is not supposed\n+     *\/\n+    IT shiftRightUnsigned(IT x, int shiftDistance);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integral.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * Indicates a type supports the basic binary arithmetic operations of\n+ * addition, subtraction, multiplication, (optionally) division, and\n+ * (optionally) remainder, ({@code +}, {@code -}, {@code *}, {@code\n+ * \/}, {@code %}, respectively), as well as (optionally) negation (unary\n+ * {@code -}), and participates in operator overloading of those\n+ * operators.\n+ *\n+ * <p>In mathematical terms, various kinds of algebraic structures\n+ * support the operations modeled by this interface. For example,\n+ * integers with Euclidean division support the operations in question\n+ * as do <dfn>algebraic fields<\/dfn>. Commonly used algebraic fields\n+ * include rational numbers, real numbers, and complex numbers.  A\n+ * field has a set of values and operations on those values. The\n+ * operations have various properties known as the <dfn>field\n+ * axioms<\/dfn>. These include associativity of addition and\n+ * multiplication, commutativity of addition and multiplication, and\n+ * multiplication distributing over addition. Fields can be\n+ * {@linkplain Orderable ordered} (rational numbers, real\n+ * numbers) or unordered (complex numbers).\n+ *\n+ * <p>Types used to approximate a field, such as a floating-point type\n+ * used to approximate real numbers, will both approximate the set of\n+ * values of the field and the set of properties over the supported\n+ * operations. In particular, properties like associativity of\n+ * addition are <em>not<\/em> expected to hold for a floating-point\n+ * type.\n+ *\n+ * <p>The intention of this interface is to enable types that\n+ * customarily support numerical notions of addition, subtraction,\n+ * multiplication and division to enjoy operator overloading syntax\n+ * even if the underlying algebraic properties do not hold because of\n+ * limitations in approximation. This includes fields and field-like\n+ * numbers as well as rings and ring-links numbers.\n+ *\n+ * @apiNote\n+ * Future work: consider interactions with \/ support from {@link\n+ * java.util.Formatter} and numerical types.\n+ *\n+ * @param <NT> The numerical type\n+ * @see Orderable\n+ *\/\n+public interface Numerical<NT> {\n+    \/**\n+     * Addition operation, binary operator \"{@code +}\".\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\/\n+     NT add(NT addend, NT augend);\n+\n+    \/**\n+     * Subtraction operation, binary operator \"{@code -}\".\n+     *\n+     * @implSpec\n+     * The default implementation returns the sum of the first\n+     * operand with the negation of the second operand.\n+     *\n+     * @param minuend the first operand\n+     * @param  subtrahend the second operand\n+     * @return the difference of the operands\n+     *\/\n+    default NT subtract(NT minuend, NT subtrahend) {\n+        return this.add(minuend, this.negate(subtrahend));\n+    }\n+\n+    \/**\n+     * Multiplication operation, binary operator \"{@code *}\".\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\/\n+     NT multiply(NT multiplier, NT multiplicand);\n+\n+    \/**\n+     * Division operation, binary operator \"{@code \/}\".\n+     *\n+     * @throws ArithmeticException if the divisor is zero\n+     * @throws UnsupportedOperationException if division is not supported\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\/\n+     NT divide(NT dividend, NT divisor);\n+\n+    \/**\n+     * Remainder operation, binary operator \"{@code %}\".\n+     *\n+     * @throws ArithmeticException if the divisor is zero\n+     * @throws UnsupportedOperationException if remainder is not supported\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\/\n+     NT remainder(NT dividend, NT divisor);\n+\n+    \/**\n+     * Unary plus operation, unary operator \"{@code +}\".\n+     *\n+     * @apiNote\n+     * It this needed? Default to returning this\/operand? Or just to\n+     * be be no-op not recognized for overloading?\n+     *\n+     * @implSpec\n+     * The default implementation returns the operand.\n+     *\n+     * @param operand the operand\n+     * @return unary plus of the operand\n+     *\/\n+     default NT plus(NT operand) {\n+         return operand;\n+     }\n+\n+    \/**\n+     * Negation operation, unary operator \"{@code -}\".\n+     *\n+     * @throws UnsupportedOperationException if negation is not supported\n+     * @param operand the operand\n+     * @return the negation of the operand\n+     *\/\n+     NT negate(NT operand);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Numerical.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/\/ TODO: could make this interface sealed and only allow an\n+\/\/ \"OrderedNumerics\" implementation or make this interface extend\n+\/\/ Numerical directly.\n+\n+\/**\n+ * Indicates a type supports ordered comparison operations ({@code\n+ * <}, {@code <=}, {@code >}, {@code >=}) and participates in operator\n+ * overloading of those operators.\n+ *\n+ * @param <OC> The type supporting ordered comparison\n+ * @see Comparable\n+ *\/\n+public interface Orderable<OC> {\n+    \/**\n+     * {@return {@code true} if the first operand is less than the second\n+     * operand and {@code false} otherwise}\n+     *\n+     * The method corresponds to the less than operator, \"{@code <}\".\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+     boolean lessThan(OC op1, OC op2);\n+\n+    \/**\n+     * {@return {@code true} if the first operand is less than or\n+     * equal to the second operand and {@code false} otherwise}\n+     *\n+     * The method corresponds to the less than operator, \"{@code <=}\".\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+     boolean lessThanEqual(OC op1, OC op2);\n+\n+    \/**\n+     * {@return {@code true} if the first operand is greater than the\n+     * second operand and {@code false} otherwise}\n+     *\n+     * The method corresponds to the greater than operator, \"{@code >}\".\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+     boolean greaterThan(OC op1, OC op2);\n+\n+    \/**\n+     * {@return {@code true} if the first operand is greater than or\n+     * equal to the second operand and {@code false} otherwise}\n+     *\n+     * The method corresponds to the greater than operator, \"{@code >=}\".\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+     boolean greaterThanEqual(OC op1, OC op2);\n+\n+    \/**\n+     * {@return the smaller of the two operands}\n+     *\n+     * @apiNote\n+     * Subtypes of this interface can define policies concerning which\n+     * operand to return if they are the same size.\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+     OC min(OC op1, OC op2);\n+\n+    \/**\n+     * {@return the larger of the two operands}\n+     *\n+     * @apiNote\n+     * Subtypes of this interface can define policies concerning which\n+     * operand to return if they are the same size.\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+     OC max(OC op1, OC op2);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Orderable.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * Indicate a floating-point type in the style of an IEEE 754 standard\n+ * floating-point type.\n+ *\n+ * @apiNote\n+ * Possible future work: separate subinterface for decimal IEEE 754\n+ * types.\n+ *\n+ * @param <SFP> The standard floating-point type\n+ *\/\n+public interface StandardFloatingPoint<SFP>\n+    extends Numerical<SFP>, Orderable<SFP> {\n+\n+    \/**\n+     * {@inheritDoc Orderable}\n+     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     * aware one.\n+     *\n+     * @param op1 {@inheritDoc Orderable}\n+     * @param op2 {@inheritDoc Orderable}\n+     *\/\n+     @Override\n+     boolean lessThan(SFP op1, SFP op2);\n+\n+    \/**\n+     * {@inheritDoc Orderable}\n+     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     * aware one.\n+     *\n+     * @apiNote\n+     * Explain all the IEEE 754-isms.\n+     *\n+     * @param op1 the {@inheritDoc Orderable}\n+     * @param op2 the {@inheritDoc Orderable}\n+     *\/\n+     @Override\n+     boolean lessThanEqual(SFP op1, SFP op2);\n+\n+    \/**\n+     * {@inheritDoc Orderable}\n+     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     * aware one.\n+     *\n+     * @apiNote\n+     * Explain all the IEEE 754-isms.\n+     *\n+     * @param op1 {@inheritDoc Orderable}\n+     * @param op2 {@inheritDoc Orderable}\n+     *\/\n+     @Override\n+     boolean greaterThan(SFP op1, SFP op2);\n+\n+    \/**\n+     * {@inheritDoc Orderable}\n+     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     * aware one.\n+     *\n+     * @apiNote\n+     * Explain all the IEEE 754-isms.\n+     *\n+     * @param op1 {@inheritDoc Orderable}\n+     * @param op2 {@inheritDoc Orderable}\n+     *\/\n+     @Override\n+     boolean greaterThanEqual(SFP op1, SFP op2);\n+\n+    \/**\n+     * {@inheritDoc Orderable}\n+     *\n+     * @apiNote\n+     * TODO: Explain all the IEEE 754-isms.\n+     *\n+     * @param op1 {@inheritDoc Orderable}\n+     * @param op2 {@inheritDoc Orderable}\n+     *\/\n+    @Override\n+    SFP min(SFP op1, SFP op2);\n+\n+    \/**\n+     * {@inheritDoc Orderable}\n+     *\n+     * @apiNote\n+     * TODO: Explain all the IEEE 754-isms.\n+     *\n+     * @param op1 {@inheritDoc Orderable}\n+     * @param op2 {@inheritDoc Orderable}\n+     *\/\n+    @Override\n+    SFP max(SFP op1, SFP op2);\n+\n+    \/**\n+     * {@return the square root of the operand} The square root is\n+     * computed using the round to nearest rounding policy.\n+     *\n+     * @apiNote\n+     * This method corresponds to the squareRoot operation defined in\n+     * IEEE 754.\n+     *\n+     * @param radicand the argument to have its square root taken\n+     *\n+     *\/\n+     SFP sqrt(SFP radicand);\n+\n+    \/**\n+     * Returns the fused multiply add of the three arguments; that is,\n+     * returns the exact product of the first two arguments summed\n+     * with the third argument and then rounded once to the nearest\n+     * floating-point value.\n+     *\n+     * @apiNote This method corresponds to the fusedMultiplyAdd\n+     * operation defined in IEEE 754.\n+     *\n+     * @param a a value\n+     * @param b a value\n+     * @param c a value\n+     *\n+     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n+     * computed, as if with unlimited range and precision, and rounded\n+     * once to the nearest floating-point value\n+     *\/\n+     SFP fma(SFP a, SFP b, SFP c);\n+\n+    \/**\n+     * Returns {@code true} if the specified number is a\n+     * Not-a-Number (NaN) value, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isNaN operation defined in IEEE\n+     * 754.\n+     *\n+     * @param   operand   the value to be tested.\n+     * @return  {@code true} if the argument is NaN;\n+     *          {@code false} otherwise.\n+     *\/\n+     boolean isNaN(SFP operand);\n+\n+    \/**\n+     * Returns {@code true} if the specified number is infinitely\n+     * large in magnitude, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isInfinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param   operand   the value to be tested.\n+     * @return  {@code true} if the argument is positive infinity or\n+     *          negative infinity; {@code false} otherwise.\n+     *\/\n+    boolean isInfinite(SFP operand);\n+\n+    \/**\n+     * Returns {@code true} if the argument is a finite floating-point\n+     * value; returns {@code false} otherwise (for NaN and infinity\n+     * arguments).\n+     *\n+     * @apiNote\n+     * This method corresponds to the isFinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param operand the {@code SFP} value to be tested\n+     * @return {@code true} if the argument is a finite\n+     * floating-point value, {@code false} otherwise.\n+     *\/\n+    boolean isFinite(SFP operand);\n+\n+    \/**\n+     * Returns the size of an ulp of the argument.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive or negative infinity, then the\n+     * result is positive infinity.\n+     * <li> If the argument is positive or negative zero, then the result is\n+     * the minimum value of the format.\n+     * <\/ul>\n+     *\n+     * @param operand the floating-point value whose ulp is to be returned\n+     * @return the size of an ulp of the argument\n+     *\/\n+    SFP ulp(SFP operand);\n+\n+    \/**\n+     * Returns a hexadecimal string representation of the argument.\n+     *\n+     * @param   operand   the value to be converted.\n+     * @return a hex string representation of the argument.\n+     *\n+     *\/\n+    String toHexString(SFP operand);\n+\n+    \/\/ Possible TODO:\n+    \/\/ scaleBy\n+    \/\/ nextUp\/nextDown\n+    \/\/ ...\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StandardFloatingPoint.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"}]}