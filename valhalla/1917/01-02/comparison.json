{"files":[{"patch":"@@ -37,0 +37,4 @@\n+ * <p>TOOD: discuss tricotomy of exactly one of less than, greater\n+ * than, and equal to <em>usually<\/em> holding between two operands,\n+ * but not for floating-point types with NaN, etc.\n+ *\n@@ -50,1 +54,1 @@\n-     boolean lessThan(OC op1, OC op2);\n+    boolean lessThan(OC op1, OC op2);\n@@ -58,0 +62,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code (lessThan(op1, op2) || op1.equals(op2))}.\n+     *\n@@ -61,1 +69,3 @@\n-     boolean lessThanEqual(OC op1, OC op2);\n+    default boolean lessThanEqual(OC op1, OC op2) {\n+        return lessThan(op1, op2) || op1.equals(op2);\n+    }\n@@ -69,0 +79,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code !lessThanEqual(op1, op2)}.\n+     *\n@@ -72,1 +86,3 @@\n-     boolean greaterThan(OC op1, OC op2);\n+    default boolean greaterThan(OC op1, OC op2) {\n+         return !lessThanEqual(op1, op2);\n+    }\n@@ -80,0 +96,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code !lessThan(op1, op2)}.\n+     *\n@@ -83,1 +103,3 @@\n-     boolean greaterThanEqual(OC op1, OC op2);\n+    default boolean greaterThanEqual(OC op1, OC op2) {\n+         return !lessThan(op1, op2);\n+    }\n@@ -92,0 +114,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code (lessThanEqual(op1, op2) ? op1 : op2)}.\n+     *\n@@ -95,1 +121,3 @@\n-     OC min(OC op1, OC op2);\n+    default OC min(OC op1, OC op2) {\n+        return lessThanEqual(op1, op2) ? op1 : op2;\n+    }\n@@ -104,0 +132,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code (greaterThanEqual(op1, op2) ? op1 : op2)}.\n+     *\n@@ -107,1 +139,3 @@\n-     OC max(OC op1, OC op2);\n+    default OC max(OC op1, OC op2) {\n+        return greaterThanEqual(op1, op2) ? op1 : op2;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Orderable.java","additions":40,"deletions":6,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     *\n+     * <p>TODO: Need to augment Orderable interface spec with IEEE 754\n@@ -85,1 +86,2 @@\n-     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     *\n+     * <p>TODO: Need to augment Orderable interface spec with IEEE 754\n@@ -91,0 +93,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code Orderable.super.lessThanEqual(op1, op2)}.\n+     *\n@@ -95,1 +101,3 @@\n-     boolean lessThanEqual(SFP op1, SFP op2);\n+     default boolean lessThanEqual(SFP op1, SFP op2) {\n+         return Orderable.super.lessThanEqual(op1, op2);\n+     }\n@@ -99,1 +107,2 @@\n-     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     *\n+     * <p>TODO: Need to augment Orderable interface spec with IEEE 754\n@@ -105,0 +114,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code !lessThanEqual(op1, op2) && !isUnordered(op1, op2)}.\n+     *\n@@ -108,2 +121,4 @@\n-     @Override\n-     boolean greaterThan(SFP op1, SFP op2);\n+    @Override\n+    default boolean greaterThan(SFP op1, SFP op2) {\n+        return !lessThanEqual(op1, op2) && !isUnordered(op1, op2);\n+    }\n@@ -113,1 +128,2 @@\n-     * TODO: Need to replace Orderable interface spec with IEEE 754\n+     *\n+     * <p>TODO: Need to augment Orderable interface spec with IEEE 754\n@@ -119,0 +135,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code !lessThan(op1, op2) && !isUnordered(op1, op2)}.\n+     *\n@@ -123,1 +143,17 @@\n-     boolean greaterThanEqual(SFP op1, SFP op2);\n+     default boolean greaterThanEqual(SFP op1, SFP op2)  {\n+        return !lessThan(op1, op2) && !isUnordered(op1, op2);\n+     }\n+\n+    \/**\n+     * {@return {@code true} if the operands are unordered and {@code false} otherwise}\n+     *\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code isNaN(op1) || isNaN(op2)}.\n+     *\n+     * @param op1 the first operand\n+     * @param op2 the second operand\n+     *\/\n+    default boolean isUnordered(SFP op1, SFP op2) {\n+        return isNaN(op1) || isNaN(op2);\n+    }\n@@ -129,1 +165,1 @@\n-     * TODO: Explain all the IEEE 754-isms.\n+     * TODO: Explain all the IEEE 754-isms, write default method.\n@@ -141,1 +177,1 @@\n-     * TODO: Explain all the IEEE 754-isms.\n+     * TODO: Explain all the IEEE 754-isms, write default method.\n@@ -218,0 +254,4 @@\n+     * @implSpec\n+     * Rough draft: the default implementation returns the result of\n+     * {@code !isInfinite(operand) && !isNaN(operand)}.\n+     *\n@@ -222,1 +262,3 @@\n-    boolean isFinite(SFP operand);\n+    default boolean isFinite(SFP operand) {\n+        return !isInfinite(operand) && !isNaN(operand);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StandardFloatingPoint.java","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"}]}