{"files":[{"patch":"@@ -99,1 +99,1 @@\n-\/\/ JimageFile pointer, or null if exploded JDK build.\n+\/\/ JImageFile pointer, or null if exploded JDK build.\n@@ -102,0 +102,9 @@\n+\/\/ JImageMode status to control preview behaviour. JImage_file is unusable\n+\/\/ for normal lookup until (JImage_mode != JIMAGE_MODE_UNINITIALIZED).\n+enum JImageMode {\n+  JIMAGE_MODE_UNINITIALIZED = 0,\n+  JIMAGE_MODE_DEFAULT = 1,\n+  JIMAGE_MODE_ENABLE_PREVIEW = 2\n+};\n+static JImageMode                      JImage_mode            = JIMAGE_MODE_UNINITIALIZED;\n+\n@@ -156,1 +165,1 @@\n-ClassPathEntry* ClassLoader::_jrt_entry = nullptr;\n+ClassPathImageEntry* ClassLoader::_jrt_entry = nullptr;\n@@ -173,9 +182,0 @@\n-static const char* get_jimage_version_string() {\n-  static char version_string[10] = \"\";\n-  if (version_string[0] == '\\0') {\n-    jio_snprintf(version_string, sizeof(version_string), \"%d.%d\",\n-                 VM_Version::vm_major_version(), VM_Version::vm_minor_version());\n-  }\n-  return (const char*)version_string;\n-}\n-\n@@ -236,0 +236,67 @@\n+\/\/ --------------------------------\n+\/\/ The following jimage_xxx static functions encapsulate all JImage_file and JImage_mode access.\n+\/\/ This is done to make it easy to reason about the JImage file state (exists vs initialized etc.).\n+\n+\/\/ Opens the named JImage file and sets the JImage file reference.\n+\/\/ Returns true if opening the JImage file was successful (see also jimage_exists()).\n+static bool jimage_open(const char* modules_path) {\n+  \/\/ Currently 'error' is not set to anything useful, so ignore it here.\n+  jint error;\n+  JImage_file = (*JImageOpen)(modules_path, &error);\n+  return JImage_file != nullptr;\n+}\n+\n+\/\/ Closes and clears the JImage file reference (this will only be called during shutdown).\n+static void jimage_close() {\n+  if (JImage_file != nullptr) {\n+    (*JImageClose)(JImage_file);\n+    JImage_file = nullptr;\n+  }\n+}\n+\n+\/\/ Returns whether a JImage file was opened (but NOT whether it was initialized yet).\n+static bool jimage_exists() {\n+  return JImage_file != nullptr;\n+}\n+\n+\/\/ Returns the JImage file reference (which may or may not be initialized).\n+static JImageFile* jimage_non_null() {\n+  assert(jimage_exists(), \"should have been opened by ClassLoader::lookup_vm_options \"\n+                          \"and remained throughout normal JVM lifetime\");\n+  return JImage_file;\n+}\n+\n+\/\/ Called once to set the access mode for resource (i.e. preview or non-preview) before\n+\/\/ general resource lookup can occur.\n+static void jimage_init(bool enable_preview) {\n+  assert(JImage_mode == JIMAGE_MODE_UNINITIALIZED, \"jimage_init must not be called twice\");\n+  JImage_mode = enable_preview ? JIMAGE_MODE_ENABLE_PREVIEW : JIMAGE_MODE_DEFAULT;\n+}\n+\n+\/\/ Returns true if jimage_init() has been called. Once the JImage file is initialized,\n+\/\/ jimage_is_preview_enabled() can be called to correctly determine the access mode.\n+static bool jimage_is_initialized() {\n+  return jimage_exists() && JImage_mode != JIMAGE_MODE_UNINITIALIZED;\n+}\n+\n+\/\/ Returns the access mode for an initialized JImage file (reflects --enable-preview).\n+static bool jimage_is_preview_enabled() {\n+  assert(jimage_is_initialized(), \"jimage is not initialized\");\n+  return JImage_mode == JIMAGE_MODE_ENABLE_PREVIEW;\n+}\n+\n+\/\/ Looks up the location of a named JImage resource. This \"raw\" lookup function allows\n+\/\/ the preview mode to be manually specified, so must not be accessible outside this\n+\/\/ class. ClassPathImageEntry manages all calls for resources after startup is complete.\n+static JImageLocationRef jimage_find_resource(const char* module_name,\n+                                              const char* file_name,\n+                                              bool is_preview,\n+                                              jlong *size) {\n+  return ((*JImageFindResource)(jimage_non_null(),\n+                                module_name,\n+                                file_name,\n+                                is_preview,\n+                                size));\n+}\n+\/\/ --------------------------------\n+\n@@ -374,11 +441,0 @@\n-JImageFile* ClassPathImageEntry::jimage() const {\n-  return JImage_file;\n-}\n-\n-JImageFile* ClassPathImageEntry::jimage_non_null() const {\n-  assert(ClassLoader::has_jrt_entry(), \"must be\");\n-  assert(jimage() != nullptr, \"should have been opened by ClassLoader::lookup_vm_options \"\n-                           \"and remained throughout normal JVM lifetime\");\n-  return jimage();\n-}\n-\n@@ -386,4 +442,1 @@\n-  if (jimage() != nullptr) {\n-    (*JImageClose)(jimage());\n-    JImage_file = nullptr;\n-  }\n+  jimage_close();\n@@ -392,1 +445,1 @@\n-ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :\n+ClassPathImageEntry::ClassPathImageEntry(const char* name) :\n@@ -394,1 +447,1 @@\n-  guarantee(jimage != nullptr, \"jimage file is null\");\n+  guarantee(jimage_is_initialized(), \"jimage is not initialized\");\n@@ -396,0 +449,1 @@\n+\n@@ -414,0 +468,2 @@\n+  bool is_preview = jimage_is_preview_enabled();\n+\n@@ -415,1 +471,1 @@\n-  JImageLocationRef location = (*JImageFindResource)(jimage_non_null(), \"\", get_jimage_version_string(), name, &size);\n+  JImageLocationRef location = jimage_find_resource(\"\", name, is_preview, &size);\n@@ -423,1 +479,1 @@\n-        location = (*JImageFindResource)(jimage_non_null(), JAVA_BASE_NAME, get_jimage_version_string(), name, &size);\n+        location = jimage_find_resource(JAVA_BASE_NAME, name, is_preview, &size);\n@@ -434,1 +490,1 @@\n-            location = (*JImageFindResource)(jimage_non_null(), module_name, get_jimage_version_string(), name, &size);\n+            location = jimage_find_resource(module_name, name, is_preview, &size);\n@@ -447,1 +503,1 @@\n-    assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), \"must be\");\n+    assert(this == ClassLoader::get_jrt_entry(), \"must be\");\n@@ -457,7 +513,0 @@\n-JImageLocationRef ClassLoader::jimage_find_resource(JImageFile* jf,\n-                                                    const char* module_name,\n-                                                    const char* file_name,\n-                                                    jlong &size) {\n-  return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &size));\n-}\n-\n@@ -466,1 +515,1 @@\n-  assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), \"must be used for jrt entry\");\n+  assert(this == ClassLoader::get_jrt_entry(), \"must be used for jrt entry\");\n@@ -621,1 +670,1 @@\n-        if (JImage_file != nullptr) {\n+        if (jimage_exists()) {\n@@ -626,1 +675,3 @@\n-          _jrt_entry = new ClassPathImageEntry(JImage_file, canonical_path);\n+          \/\/ Hand over lifecycle control of the JImage file to the _jrt_entry singleton\n+          \/\/ (see ClassPathImageEntry::close_jimage). The image must be initialized by now.\n+          _jrt_entry = new ClassPathImageEntry(canonical_path);\n@@ -628,1 +679,0 @@\n-          assert(_jrt_entry->jimage() != nullptr, \"No java runtime image\");\n@@ -1442,11 +1492,0 @@\n-static char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {\n-  jlong size;\n-  JImageLocationRef location = (*JImageFindResource)(jimage, \"java.base\", jimage_version, path, &size);\n-  if (location == 0)\n-    return nullptr;\n-  char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);\n-  (*JImageGetResource)(jimage, location, val, size);\n-  val[size] = '\\0';\n-  return val;\n-}\n-\n@@ -1455,1 +1494,0 @@\n-  jint error;\n@@ -1463,3 +1501,13 @@\n-  JImage_file =(*JImageOpen)(modules_path, &error);\n-  if (JImage_file == nullptr) {\n-    return nullptr;\n+  if (jimage_open(modules_path)) {\n+    \/\/ Special case where we lookup the options string *before* calling jimage_init().\n+    \/\/ Since VM arguments have not been parsed, and the ClassPathImageEntry singleton\n+    \/\/ has not been created yet, we access the JImage file directly in non-preview mode.\n+    jlong size;\n+    JImageLocationRef location =\n+            jimage_find_resource(JAVA_BASE_NAME, \"jdk\/internal\/vm\/options\", \/* is_preview *\/ false, &size);\n+    if (location != 0) {\n+      char *options = NEW_C_HEAP_ARRAY(char, size+1, mtClass);\n+      (*JImageGetResource)(jimage_non_null(), location, options, size);\n+      options[size] = '\\0';\n+      return options;\n+    }\n@@ -1467,0 +1515,2 @@\n+  return nullptr;\n+}\n@@ -1468,3 +1518,5 @@\n-  const char *jimage_version = get_jimage_version_string();\n-  char *options = lookup_vm_resource(JImage_file, jimage_version, \"jdk\/internal\/vm\/options\");\n-  return options;\n+\/\/ Finishes initializing the JImageFile (if present) by setting the access mode.\n+void ClassLoader::init_jimage(bool enable_preview) {\n+  if (jimage_exists()) {\n+    jimage_init(enable_preview);\n+  }\n@@ -1475,1 +1527,1 @@\n-  if (JImage_file == nullptr) {\n+  if (!jimage_exists()) {\n@@ -1482,0 +1534,1 @@\n+  \/\/ We don't expect preview mode (i.e. --enable-preview) to affect module visibility.\n@@ -1483,2 +1536,1 @@\n-  const char *jimage_version = get_jimage_version_string();\n-  return (*JImageFindResource)(JImage_file, module_name, jimage_version, \"module-info.class\", &size) != 0;\n+  return jimage_find_resource(module_name, \"module-info.class\", \/* is_preview *\/ false, &size) != 0;\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":116,"deletions":64,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -102,1 +102,2 @@\n-\/\/ For java image files\n+\/\/ A singleton path entry which takes ownership of the initialized JImageFile\n+\/\/ reference. Not used for exploded builds.\n@@ -110,2 +111,1 @@\n-  JImageFile* jimage() const;\n-  JImageFile* jimage_non_null() const;\n+  \/\/ Called to close the JImage during os::abort (normally not called).\n@@ -113,1 +113,2 @@\n-  ClassPathImageEntry(JImageFile* jimage, const char* name);\n+  \/\/ Takes effective ownership of the static JImageFile pointer.\n+  ClassPathImageEntry(const char* name);\n@@ -115,0 +116,1 @@\n+\n@@ -203,1 +205,1 @@\n-  \/\/    Contains the ClassPathEntry of the modular java runtime image.\n+  \/\/    Contains the ClassPathImageEntry of the modular java runtime image.\n@@ -206,1 +208,1 @@\n-  static ClassPathEntry* _jrt_entry;\n+  static ClassPathImageEntry* _jrt_entry;\n@@ -353,0 +355,3 @@\n+  \/\/ Retrieves additional VM options prior to flags processing. Options held\n+  \/\/ in the JImage file are retrieved without fully initializing it. (this is\n+  \/\/ the only JImage lookup which can succeed before init_jimage() is called).\n@@ -355,0 +360,5 @@\n+  \/\/ Called once, after all flags are processed, to finish initializing the\n+  \/\/ JImage file. Until this is called, jimage_find_resource(), and any other\n+  \/\/ JImage resource lookups or access will fail.\n+  static void init_jimage(bool enable_preview);\n+\n@@ -359,3 +369,0 @@\n-  static JImageLocationRef jimage_find_resource(JImageFile* jf, const char* module_name,\n-                                                const char* file_name, jlong &size);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2082,0 +2082,12 @@\n+\/\/ Temporary system property to disable preview patching and enable the new preview mode\n+\/\/ feature for testing\/development. Once the preview mode feature is finished, the value\n+\/\/ will be always 'true' and this code, and all related dead-code can be removed.\n+#define DISABLE_PREVIEW_PATCHING_DEFAULT false\n+\n+bool Arguments::disable_preview_patching() {\n+  const char* prop = get_property(\"DISABLE_PREVIEW_PATCHING\");\n+  return (prop != nullptr)\n+      ? strncmp(prop, \"true\", strlen(\"true\")) == 0\n+      : DISABLE_PREVIEW_PATCHING_DEFAULT;\n+}\n+\n@@ -2089,2 +2101,8 @@\n-  \/\/ If --enable-preview and EnableValhalla is true, each module may have value classes that\n-  \/\/ are to be patched into the module.\n+  \/\/ If --enable-preview and EnableValhalla is true, modules may have preview mode resources.\n+  bool enable_valhalla_preview = enable_preview() && EnableValhalla;\n+  \/\/ Whether to use module patching, or the new preview mode feature for preview resources.\n+  bool disable_patching = disable_preview_patching();\n+\n+  \/\/ This must be called, even with 'false', to enable resource lookup from JImage.\n+  ClassLoader::init_jimage(disable_patching && enable_valhalla_preview);\n+\n@@ -2093,1 +2111,1 @@\n-  if (enable_preview() && EnableValhalla) {\n+  if (!disable_patching && enable_valhalla_preview) {\n@@ -2126,1 +2144,1 @@\n-  \/\/ by --patch-module or --enable-preview\n+  \/\/ by --patch-module (or --enable-preview if disable_patching is false).\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -489,0 +489,2 @@\n+  static bool disable_preview_patching();\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,17 @@\n+ * Defines the header and version information for jimage files.\n+ *\n+ * <p>Version number changes must be synced in a single change across all code\n+ * which reads\/writes jimage files, and code which tries to open a jimage file\n+ * with an unexpected version should fail.\n+ *\n+ * <p>Known jimage file code which needs updating on version change:\n+ * <ul>\n+ *     <li>src\/java.base\/share\/native\/libjimage\/imageFile.hpp\n+ * <\/ul>\n+ *\n+ * <p>Version history:\n+ * <ul>\n+ *     <li>{@code 1.0}: Original version.\n+ *     <li>{@code 1.1}: Support preview mode with new flags.\n+ * <\/ul>\n+ *\n@@ -42,1 +59,1 @@\n-    public static final int MINOR_VERSION = 0;\n+    public static final int MINOR_VERSION = 1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageHeader.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.function.Predicate;\n@@ -47,1 +48,88 @@\n-    public static final int ATTRIBUTE_COUNT = 8;\n+    public static final int ATTRIBUTE_PREVIEW_FLAGS = 8;\n+    public static final int ATTRIBUTE_COUNT = 9;\n+\n+    \/\/ Flag masks for the ATTRIBUTE_PREVIEW_FLAGS attribute. Defined so\n+    \/\/ that zero is the overwhelmingly common case for normal resources.\n+\n+    \/**\n+     * Set on a \"normal\" (non-preview) location if a preview version\n+     * of it exists in the same module.\n+     *\n+     * <p>This can apply to both resources and directories in the\n+     * {@code \/modules\/xxx\/...} namespace, as well as {@code \/packages\/xxx}\n+     * directories.\n+     *\n+     * <p>For {@code \/packages\/xxx} directories, it indicates that preview\n+     * resources exist in an associated module.\n+     *\/\n+    public static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n+    \/**\n+     * Set on all preview locations in the {@code \/modules\/xxx\/...} namespace.\n+     *\/\n+    public static final int FLAGS_IS_PREVIEW_VERSION = 0x2;\n+    \/**\n+     * Set on a preview location if no normal (non-preview) version\n+     * of it exists in the same module.\n+     *\n+     * <p>This can apply to both resources and directories in the\n+     * {@code \/modules\/xxx\/...} namespace, as well as {@code \/packages\/xxx}\n+     * directories.\n+     *\n+     * <p>For {@code \/packages\/xxx} directories, it indicates that every module\n+     * associated with the package is preview only.\n+     *\/\n+    public static final int FLAGS_IS_PREVIEW_ONLY = 0x4;\n+    \/**\n+     * This flag identifies the unique {@code \"\/packages\"} location, and\n+     * is used to determine the {@link LocationType} without additional\n+     * string comparison.\n+     *\/\n+    public static final int FLAGS_IS_PACKAGE_ROOT = 0x8;\n+\n+    \/\/ Also used in ImageReader.\n+    static final String MODULES_PREFIX = \"\/modules\";\n+    static final String PACKAGES_PREFIX = \"\/packages\";\n+    static final String PREVIEW_INFIX = \"\/META-INF\/preview\";\n+\n+    \/**\n+     * Helper function to calculate preview flags (ATTRIBUTE_PREVIEW_FLAGS).\n+     *\n+     * <p>Since preview flags are calculated separately for resource nodes and\n+     * directory nodes (in two quite different places) it's useful to have a\n+     * common helper.\n+     *\n+     * @param name the jimage name of the resource or directory.\n+     * @param hasEntry a predicate for jimage names returning whether an entry\n+     *     is present.\n+     * @return flags for the ATTRIBUTE_PREVIEW_FLAGS attribute.\n+     *\/\n+    public static int getFlags(String name, Predicate<String> hasEntry) {\n+        if (name.startsWith(PACKAGES_PREFIX + \"\/\")) {\n+            throw new IllegalArgumentException(\"Package sub-directory flags handled separately: \" + name);\n+        }\n+        String start = name.startsWith(MODULES_PREFIX + \"\/\") ? MODULES_PREFIX + \"\/\" : \"\/\";\n+        int idx = name.indexOf('\/', start.length());\n+        if (idx == -1) {\n+            \/\/ Special case for \"\/packages\" root, but otherwise, no flags.\n+            return name.equals(PACKAGES_PREFIX) ? FLAGS_IS_PACKAGE_ROOT : 0;\n+        }\n+        String prefix = name.substring(0, idx);\n+        String suffix = name.substring(idx);\n+        if (suffix.startsWith(PREVIEW_INFIX + \"\/\")) {\n+            \/\/ Preview resources\/directories.\n+            String nonPreviewName = prefix + suffix.substring(PREVIEW_INFIX.length());\n+            return FLAGS_IS_PREVIEW_VERSION\n+                    | (hasEntry.test(nonPreviewName) ? 0 : FLAGS_IS_PREVIEW_ONLY);\n+        } else if (!suffix.startsWith(\"\/META-INF\/\")) {\n+            \/\/ Non-preview resources\/directories.\n+            String previewName = prefix + PREVIEW_INFIX + suffix;\n+            return hasEntry.test(previewName) ? FLAGS_HAS_PREVIEW_VERSION : 0;\n+        } else {\n+            \/\/ Edge case for things META-INF\/module-info.class etc.\n+            return 0;\n+        }\n+    }\n+\n+    public enum LocationType {\n+        RESOURCE, MODULES_ROOT, MODULES_DIR, PACKAGES_ROOT, PACKAGES_DIR;\n+    }\n@@ -288,0 +376,4 @@\n+    public int getFlags() {\n+        return (int) getAttribute(ATTRIBUTE_PREVIEW_FLAGS);\n+    }\n+\n@@ -297,1 +389,1 @@\n-                builder.append(\"\/modules\");\n+                builder.append(MODULES_PREFIX);\n@@ -320,30 +412,0 @@\n-    String buildName(boolean includeModule, boolean includeParent,\n-            boolean includeName) {\n-        StringBuilder builder = new StringBuilder();\n-\n-        if (includeModule && getModuleOffset() != 0) {\n-            builder.append(\"\/modules\/\");\n-            builder.append(getModule());\n-         }\n-\n-        if (includeParent && getParentOffset() != 0) {\n-            builder.append('\/');\n-            builder.append(getParent());\n-        }\n-\n-        if (includeName) {\n-            if (includeModule || includeParent) {\n-                builder.append('\/');\n-            }\n-\n-            builder.append(getBase());\n-\n-            if (getExtensionOffset() != 0) {\n-                builder.append('.');\n-                builder.append(getExtension());\n-            }\n-        }\n-\n-        return builder.toString();\n-   }\n-\n@@ -362,0 +424,36 @@\n+    \/\/ Fast (zero allocation) type determination for locations.\n+    public LocationType getType() {\n+        switch (getModuleOffset()) {\n+            case ImageStrings.MODULES_STRING_OFFSET:\n+                \/\/ Locations in \/modules\/... namespace are directory entries.\n+                return LocationType.MODULES_DIR;\n+            case ImageStrings.PACKAGES_STRING_OFFSET:\n+                \/\/ Locations in \/packages\/... namespace are always 2-level\n+                \/\/ \"\/packages\/xxx\" directories.\n+                return LocationType.PACKAGES_DIR;\n+            case ImageStrings.EMPTY_STRING_OFFSET:\n+                \/\/ Only 2 choices, either the \"\/modules\" or \"\/packages\" root.\n+                assert isRootDir() : \"Invalid root directory: \" + getFullName();\n+                return (getFlags() & FLAGS_IS_PACKAGE_ROOT) != 0\n+                        ? LocationType.PACKAGES_ROOT\n+                        : LocationType.MODULES_ROOT;\n+            default:\n+                \/\/ Anything else is \/<module>\/<path> and references a resource.\n+                return LocationType.RESOURCE;\n+        }\n+    }\n+\n+    private boolean isRootDir() {\n+        if (getModuleOffset() == 0 && getParentOffset() == 0) {\n+            String name = getFullName();\n+            return name.equals(MODULES_PREFIX) || name.equals(PACKAGES_PREFIX);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Cannot use String.format() (too early in startup for locale code).\n+        return \"ImageLocation[name='\" + getFullName() + \"', type=\" + getType() + \", flags=\" + getFlags() + \"]\";\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageLocation.java","additions":131,"deletions":33,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.ImageLocation.LocationType;\n+\n@@ -37,0 +39,1 @@\n+import java.util.Comparator;\n@@ -43,0 +46,1 @@\n+import java.util.TreeMap;\n@@ -47,0 +51,10 @@\n+import static jdk.internal.jimage.ImageLocation.FLAGS_HAS_PREVIEW_VERSION;\n+import static jdk.internal.jimage.ImageLocation.FLAGS_IS_PREVIEW_ONLY;\n+import static jdk.internal.jimage.ImageLocation.LocationType.MODULES_DIR;\n+import static jdk.internal.jimage.ImageLocation.LocationType.MODULES_ROOT;\n+import static jdk.internal.jimage.ImageLocation.LocationType.PACKAGES_DIR;\n+import static jdk.internal.jimage.ImageLocation.LocationType.RESOURCE;\n+import static jdk.internal.jimage.ImageLocation.MODULES_PREFIX;\n+import static jdk.internal.jimage.ImageLocation.PACKAGES_PREFIX;\n+import static jdk.internal.jimage.ImageLocation.PREVIEW_INFIX;\n+\n@@ -89,2 +103,4 @@\n-     * Opens an image reader for a jimage file at the specified path, using the\n-     * given byte order.\n+     * Opens an image reader for a jimage file at the specified path.\n+     *\n+     * @param imagePath file system path of the jimage file.\n+     * @param mode whether to return preview resources.\n@@ -92,5 +108,2 @@\n-    public static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n-        Objects.requireNonNull(imagePath);\n-        Objects.requireNonNull(byteOrder);\n-\n-        return SharedImageReader.open(imagePath, byteOrder);\n+    public static ImageReader open(Path imagePath, PreviewMode mode) throws IOException {\n+        return open(imagePath, ByteOrder.nativeOrder(), mode);\n@@ -100,2 +113,5 @@\n-     * Opens an image reader for a jimage file at the specified path, using the\n-     * platform native byte order.\n+     * Opens an image reader for a jimage file at the specified path.\n+     *\n+     * @param imagePath file system path of the jimage file.\n+     * @param byteOrder the byte-order to be used when reading the jimage file.\n+     * @param mode controls whether preview resources are visible.\n@@ -103,2 +119,4 @@\n-    public static ImageReader open(Path imagePath) throws IOException {\n-        return open(imagePath, ByteOrder.nativeOrder());\n+    public static ImageReader open(Path imagePath, ByteOrder byteOrder, PreviewMode mode) throws IOException {\n+        Objects.requireNonNull(imagePath);\n+        Objects.requireNonNull(byteOrder);\n+        return SharedImageReader.open(imagePath, byteOrder, mode.resolve());\n@@ -217,3 +235,0 @@\n-        private static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n-        private static final String MODULES_ROOT = \"\/modules\";\n-        private static final String PACKAGES_ROOT = \"\/packages\";\n@@ -225,0 +240,27 @@\n+        static final class ReaderKey {\n+            private final Path imagePath;\n+            private final boolean previewMode;\n+\n+            public ReaderKey(Path imagePath, boolean previewMode) {\n+                this.imagePath = imagePath;\n+                this.previewMode = previewMode;\n+            }\n+\n+            @Override\n+            public boolean equals(Object obj) {\n+                \/\/ No pattern variables here (Java 8 compatible source).\n+                if (obj instanceof ReaderKey) {\n+                    ReaderKey other = (ReaderKey) obj;\n+                    return this.imagePath.equals(other.imagePath) && this.previewMode == other.previewMode;\n+                }\n+                return false;\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return imagePath.hashCode() ^ Boolean.hashCode(previewMode);\n+            }\n+        }\n+\n+        private static final Map<ReaderKey, SharedImageReader> OPEN_FILES = new HashMap<>();\n+\n@@ -235,3 +277,0 @@\n-        \/\/ Used to classify ImageLocation instances without string comparison.\n-        private final int modulesStringOffset;\n-        private final int packagesStringOffset;\n@@ -239,1 +278,8 @@\n-        private SharedImageReader(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        \/\/ Preview mode support.\n+        private final boolean previewMode;\n+        \/\/ A relativized mapping from non-preview name to directories containing\n+        \/\/ preview-only nodes. This is used to add preview-only content to\n+        \/\/ directories as they are completed.\n+        private final HashMap<String, Directory> previewDirectoriesToMerge;\n+\n+        private SharedImageReader(Path imagePath, ByteOrder byteOrder, boolean previewMode) throws IOException {\n@@ -243,4 +289,1 @@\n-            \/\/ Pick stable jimage names from which to extract string offsets (we cannot\n-            \/\/ use \"\/modules\" or \"\/packages\", since those have a module offset of zero).\n-            this.modulesStringOffset = getModuleOffset(\"\/modules\/java.base\");\n-            this.packagesStringOffset = getModuleOffset(\"\/packages\/java.lang\");\n+            this.previewMode = previewMode;\n@@ -250,4 +293,2 @@\n-            Directory packages = newDirectory(PACKAGES_ROOT);\n-            nodes.put(packages.getName(), packages);\n-            Directory modules = newDirectory(MODULES_ROOT);\n-            nodes.put(modules.getName(), modules);\n+            Directory packages = ensureCached(newDirectory(PACKAGES_PREFIX));\n+            Directory modules = ensureCached(newDirectory(MODULES_PREFIX));\n@@ -257,1 +298,8 @@\n-            nodes.put(root.getName(), root);\n+            ensureCached(root);\n+\n+            \/\/ By scanning the \/packages directory information early we can determine\n+            \/\/ which module\/package pairs have preview resources, and build the (small)\n+            \/\/ set of preview nodes early. This also ensures that preview-only entries\n+            \/\/ in the \/packages directory are not present in non-preview mode.\n+            this.previewDirectoriesToMerge = previewMode ? new HashMap<>() : null;\n+            packages.setChildren(processPackagesDirectory(previewMode));\n@@ -261,3 +309,8 @@\n-         * Returns the offset of the string denoting the leading \"module\" segment in\n-         * the given path (e.g. {@code <module>\/<path>}). We can't just pass in the\n-         * {@code \/<module>} string here because that has a module offset of zero.\n+         * Process {@code \"\/packages\/xxx\"} entries to build the child nodes for the\n+         * root {@code \"\/packages\"} node. Preview-only entries will be skipped if\n+         * {@code previewMode == false}.\n+         *\n+         * <p>If {@code previewMode == true}, this method also populates the {@link\n+         * #previewDirectoriesToMerge} map with any preview-only nodes, to be merged\n+         * into directories as they are completed. It also caches preview resources\n+         * and preview-only directories for direct lookup.\n@@ -265,6 +318,79 @@\n-        private int getModuleOffset(String path) {\n-            ImageLocation location = findLocation(path);\n-            assert location != null : \"Cannot find expected jimage location: \" + path;\n-            int offset = location.getModuleOffset();\n-            assert offset != 0 : \"Invalid module offset for jimage location: \" + path;\n-            return offset;\n+        private ArrayList<Node> processPackagesDirectory(boolean previewMode) {\n+            ImageLocation pkgRoot = findLocation(PACKAGES_PREFIX);\n+            assert pkgRoot != null : \"Invalid jimage file\";\n+            IntBuffer offsets = getOffsetBuffer(pkgRoot);\n+            ArrayList<Node> pkgDirs = new ArrayList<>(offsets.capacity());\n+            \/\/ Package path to module map, sorted in reverse order so that\n+            \/\/ longer child paths get processed first.\n+            Map<String, List<String>> previewPackagesToModules =\n+                    new TreeMap<>(Comparator.reverseOrder());\n+            for (int i = 0; i < offsets.capacity(); i++) {\n+                ImageLocation pkgDir = getLocation(offsets.get(i));\n+                int flags = pkgDir.getFlags();\n+                \/\/ A package subdirectory is \"preview only\" if all the modules\n+                \/\/ it references have that package marked as preview only.\n+                \/\/ Skipping these entries avoids empty package subdirectories.\n+                if (previewMode || (flags & FLAGS_IS_PREVIEW_ONLY) == 0) {\n+                    pkgDirs.add(ensureCached(newDirectory(pkgDir.getFullName())));\n+                }\n+                if (!previewMode || (flags & FLAGS_HAS_PREVIEW_VERSION) == 0) {\n+                    continue;\n+                }\n+                \/\/ Only do this in preview mode for the small set of packages with\n+                \/\/ preview versions (the number of preview entries should be small).\n+                List<String> moduleNames = new ArrayList<>();\n+                ModuleReference.readNameOffsets(getOffsetBuffer(pkgDir), \/*normal*\/ false, \/*preview*\/ true)\n+                        .forEachRemaining(n -> moduleNames.add(getString(n)));\n+                previewPackagesToModules.put(pkgDir.getBase().replace('.', '\/'), moduleNames);\n+            }\n+            \/\/ Reverse sorted map means child directories are processed first.\n+            previewPackagesToModules.forEach((pkgPath, modules) ->\n+                    modules.forEach(modName -> processPreviewDir(MODULES_PREFIX + \"\/\" + modName, pkgPath)));\n+            \/\/ We might have skipped some preview-only package entries.\n+            pkgDirs.trimToSize();\n+            return pkgDirs;\n+        }\n+\n+        void processPreviewDir(String namePrefix, String pkgPath) {\n+            String previewDirName = namePrefix + PREVIEW_INFIX + \"\/\" + pkgPath;\n+            ImageLocation previewLoc = findLocation(previewDirName);\n+            assert previewLoc != null : \"Missing preview directory location: \" + previewDirName;\n+            String nonPreviewDirName = namePrefix + \"\/\" + pkgPath;\n+            List<Node> previewOnlyChildren = createChildNodes(previewLoc, 0, childLoc -> {\n+                String baseName = getBaseName(childLoc);\n+                String nonPreviewChildName = nonPreviewDirName + \"\/\" + baseName;\n+                boolean isPreviewOnly = (childLoc.getFlags() & FLAGS_IS_PREVIEW_ONLY) != 0;\n+                LocationType type = childLoc.getType();\n+                if (type == RESOURCE) {\n+                    \/\/ Preview resources are cached to override non-preview versions.\n+                    Node childNode = ensureCached(newResource(nonPreviewChildName, childLoc));\n+                    return isPreviewOnly ? childNode : null;\n+                } else {\n+                    \/\/ Child directories are not cached here (they are either cached\n+                    \/\/ already or have been added to previewDirectoriesToMerge).\n+                    assert type == MODULES_DIR : \"Invalid location type: \" + childLoc;\n+                    Node childNode = nodes.get(nonPreviewChildName);\n+                    assert isPreviewOnly == (childNode != null) :\n+                            \"Inconsistent child node: \" + nonPreviewChildName;\n+                    return childNode;\n+                }\n+            });\n+            Directory previewDir = newDirectory(nonPreviewDirName);\n+            previewDir.setChildren(previewOnlyChildren);\n+            if ((previewLoc.getFlags() & FLAGS_IS_PREVIEW_ONLY) != 0) {\n+                \/\/ If we are preview-only, our children are also preview-only, so\n+                \/\/ this directory is a complete hierarchy and should be cached.\n+                assert !previewOnlyChildren.isEmpty() : \"Invalid empty preview-only directory: \" + nonPreviewDirName;\n+                ensureCached(previewDir);\n+            } else if (!previewOnlyChildren.isEmpty()) {\n+                \/\/ A partial directory containing extra preview-only nodes\n+                \/\/ to be merged when the non-preview directory is completed.\n+                previewDirectoriesToMerge.put(nonPreviewDirName, previewDir);\n+            }\n+        }\n+\n+        \/\/ Adds a node to the cache, ensuring that no matching entry already existed.\n+        private <T extends Node> T ensureCached(T node) {\n+            Node existingNode = nodes.put(node.getName(), node);\n+            assert existingNode == null : \"Unexpected node already cached for: \" + node;\n+            return node;\n@@ -273,1 +399,6 @@\n-        private static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        \/\/ As above but ignores null.\n+        private <T extends Node> T ensureCachedIfNonNull(T node) {\n+            return node != null ? ensureCached(node) : null;\n+        }\n+\n+        private static ImageReader open(Path imagePath, ByteOrder byteOrder, boolean previewMode) throws IOException {\n@@ -278,1 +409,2 @@\n-                SharedImageReader reader = OPEN_FILES.get(imagePath);\n+                ReaderKey key = new ReaderKey(imagePath, previewMode);\n+                SharedImageReader reader = OPEN_FILES.get(key);\n@@ -282,2 +414,2 @@\n-                    reader =  new SharedImageReader(imagePath, byteOrder);\n-                    OPEN_FILES.put(imagePath, reader);\n+                    reader = new SharedImageReader(imagePath, byteOrder, previewMode);\n+                    OPEN_FILES.put(key, reader);\n@@ -307,1 +439,1 @@\n-                    if (!OPEN_FILES.remove(this.getImagePath(), this)) {\n+                    if (!OPEN_FILES.remove(new ReaderKey(getImagePath(), previewMode), this)) {\n@@ -325,0 +457,2 @@\n+            \/\/ Root directories \"\/\", \"\/modules\" and \"\/packages\", as well\n+            \/\/ as all \"\/packages\/xxx\" subdirectories are already cached.\n@@ -327,12 +461,4 @@\n-                \/\/ We cannot get the root paths (\"\/modules\" or \"\/packages\") here\n-                \/\/ because those nodes are already in the nodes cache.\n-                if (name.startsWith(MODULES_ROOT + \"\/\")) {\n-                    \/\/ This may perform two lookups, one for a directory (in\n-                    \/\/ \"\/modules\/...\") and one for a non-prefixed resource\n-                    \/\/ (with \"\/modules\" removed).\n-                    node = buildModulesNode(name);\n-                } else if (name.startsWith(PACKAGES_ROOT + \"\/\")) {\n-                    node = buildPackagesNode(name);\n-                }\n-                if (node != null) {\n-                    nodes.put(node.getName(), node);\n+                if (name.startsWith(MODULES_PREFIX + \"\/\")) {\n+                    node = buildAndCacheModulesNode(name);\n+                } else if (name.startsWith(PACKAGES_PREFIX + \"\/\")) {\n+                    node = buildAndCacheLinkNode(name);\n@@ -362,1 +488,1 @@\n-            String nodeName = MODULES_ROOT + \"\/\" + moduleName + \"\/\" + resourcePath;\n+            String nodeName = MODULES_PREFIX + \"\/\" + moduleName + \"\/\" + resourcePath;\n@@ -368,1 +494,1 @@\n-                    if (loc != null && isResource(loc)) {\n+                    if (loc != null && loc.getType() == RESOURCE) {\n@@ -384,3 +510,4 @@\n-         * search). As such, it skips checking the nodes cache and only checks\n-         * for an entry in the jimage file, as this is faster if the resource\n-         * is not present. This also means it doesn't need synchronization.\n+         * search). As such, it skips checking the nodes cache if possible, and\n+         * only checks for an entry in the jimage file, as this is faster if the\n+         * resource is not present. This also means it doesn't need\n+         * synchronization most of the time.\n@@ -392,2 +519,12 @@\n-            \/\/ If the given module name is 'modules', then 'isResource()'\n-            \/\/ returns false to prevent false positives.\n+            \/\/ In preview mode, preview-only resources are eagerly added to the\n+            \/\/ cache, so we must check that first.\n+            if (previewMode) {\n+                String nodeName = MODULES_PREFIX + \"\/\" + moduleName + \"\/\" + resourcePath;\n+                \/\/ Synchronize as tightly as possible to reduce locking contention.\n+                synchronized (this) {\n+                    Node node = nodes.get(nodeName);\n+                    if (node != null) {\n+                        return node.isResource();\n+                    }\n+                }\n+            }\n@@ -395,1 +532,1 @@\n-            return loc != null && isResource(loc);\n+            return loc != null && loc.getType() == RESOURCE;\n@@ -404,2 +541,5 @@\n-        private Node buildModulesNode(String name) {\n-            assert name.startsWith(MODULES_ROOT + \"\/\") : \"Invalid module node name: \" + name;\n+        private Node buildAndCacheModulesNode(String name) {\n+            assert name.startsWith(MODULES_PREFIX + \"\/\") : \"Invalid module node name: \" + name;\n+            if (isPreviewName(name)) {\n+                return null;\n+            }\n@@ -411,2 +551,2 @@\n-                assert isModulesSubdirectory(loc) : \"Invalid modules directory: \" + name;\n-                return completeModuleDirectory(newDirectory(name), loc);\n+                assert loc.getType() == MODULES_DIR : \"Invalid modules directory: \" + name;\n+                return ensureCached(completeModuleDirectory(newDirectory(name), loc));\n@@ -417,2 +557,3 @@\n-            loc = findLocation(name.substring(MODULES_ROOT.length()));\n-            return loc != null && isResource(loc) ? newResource(name, loc) : null;\n+            loc = findLocation(name.substring(MODULES_PREFIX.length()));\n+            return ensureCachedIfNonNull(\n+                    loc != null && loc.getType() == RESOURCE ? newResource(name, loc) : null);\n@@ -422,1 +563,31 @@\n-         * Builds a node in the \"\/packages\/...\" namespace.\n+         * Returns whether a directory name in the \"\/modules\/\" directory could be referencing\n+         * the \"META-INF\" directory\".\n+         *\/\n+        private boolean isMetaInf(Directory dir) {\n+            String name = dir.getName();\n+            int pathStart = name.indexOf('\/', MODULES_PREFIX.length() + 1);\n+            return name.length() == pathStart + \"\/META-INF\".length()\n+                    && name.endsWith(\"\/META-INF\");\n+        }\n+\n+        \/**\n+         * Returns whether a node name in the \"\/modules\/\" directory could be referencing\n+         * a preview resource or directory under \"META-INF\/preview\".\n+         *\/\n+        private boolean isPreviewName(String name) {\n+            int pathStart = name.indexOf('\/', MODULES_PREFIX.length() + 1);\n+            int previewEnd = pathStart + PREVIEW_INFIX.length();\n+            return pathStart > 0\n+                    && name.regionMatches(pathStart, PREVIEW_INFIX, 0, PREVIEW_INFIX.length())\n+                    && (name.length() == previewEnd || name.charAt(previewEnd) == '\/');\n+        }\n+\n+        private String getBaseName(ImageLocation loc) {\n+            \/\/ Matches logic in ImageLocation#getFullName() regarding extensions.\n+            String trailingParts = loc.getBase()\n+                    + ((loc.getExtensionOffset() != 0) ? \".\" + loc.getExtension() : \"\");\n+            return trailingParts.substring(trailingParts.lastIndexOf('\/') + 1);\n+        }\n+\n+        \/**\n+         * Builds a link node of the form \"\/packages\/xxx\/yyy\".\n@@ -424,2 +595,2 @@\n-         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...} node\n-         * is not present in the cache.\n+         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...}\n+         * node is not present in the cache (the name is not trusted).\n@@ -427,7 +598,5 @@\n-        private Node buildPackagesNode(String name) {\n-            \/\/ There are only locations for the root \"\/packages\" or \"\/packages\/xxx\"\n-            \/\/ directories, but not the symbolic links below them (the links can be\n-            \/\/ entirely derived from the name information in the parent directory).\n-            \/\/ However, unlike resources this means that we do not have a constant\n-            \/\/ time lookup for link nodes when creating them.\n-            int packageStart = PACKAGES_ROOT.length() + 1;\n+        private Node buildAndCacheLinkNode(String name) {\n+            \/\/ There are only locations for \"\/packages\" or \"\/packages\/xxx\"\n+            \/\/ directories, but not the symbolic links below them (links are\n+            \/\/ derived from the name information in the parent directory).\n+            int packageStart = PACKAGES_PREFIX.length() + 1;\n@@ -435,8 +604,3 @@\n-            if (packageEnd == -1) {\n-                ImageLocation loc = findLocation(name);\n-                return loc != null ? completePackageDirectory(newDirectory(name), loc) : null;\n-            } else {\n-                \/\/ We cannot assume that the parent directory exists for a link node, since\n-                \/\/ the given name is untrusted and could reference a non-existent link.\n-                \/\/ However, if the parent directory is present, we can conclude that the\n-                \/\/ given name was not a valid link (or else it would already be cached).\n+            \/\/ We already built the 2-level \"\/packages\/xxx\" directories,\n+            \/\/ so if this is a 2-level name, it cannot reference a node.\n+            if (packageEnd >= 0) {\n@@ -444,8 +608,6 @@\n-                if (!nodes.containsKey(dirName)) {\n-                    ImageLocation loc = findLocation(dirName);\n-                    \/\/ If the parent location doesn't exist, the link node cannot exist.\n-                    if (loc != null) {\n-                        nodes.put(dirName, completePackageDirectory(newDirectory(dirName), loc));\n-                        \/\/ When the parent is created its child nodes are created and cached,\n-                        \/\/ but this can still return null if given name wasn't a valid link.\n-                        return nodes.get(name);\n+                \/\/ If no parent exists here, the name cannot be valid.\n+                Directory parent = (Directory) nodes.get(dirName);\n+                if (parent != null) {\n+                    if (!parent.isCompleted()) {\n+                        \/\/ This caches all child links of the parent directory.\n+                        completePackageSubdirectory(parent, findLocation(dirName));\n@@ -453,0 +615,1 @@\n+                    return nodes.get(name);\n@@ -464,1 +627,1 @@\n-            assert name.startsWith(MODULES_ROOT) || name.startsWith(PACKAGES_ROOT);\n+            assert name.startsWith(MODULES_PREFIX) || name.startsWith(PACKAGES_PREFIX);\n@@ -467,4 +630,2 @@\n-            \/\/ We cannot use 'isXxxSubdirectory()' methods here since we could\n-            \/\/ be given a top-level directory (for which that test doesn't work).\n-            \/\/ The string MUST start \"\/modules\" or \"\/packages\" here.\n-            if (name.charAt(1) == 'm') {\n+            LocationType type = loc.getType();\n+            if (type == MODULES_DIR || type == MODULES_ROOT) {\n@@ -473,1 +634,2 @@\n-                completePackageDirectory(dir, loc);\n+                assert type == PACKAGES_DIR : \"Invalid location type: \" + loc;\n+                completePackageSubdirectory(dir, loc);\n@@ -478,6 +640,1 @@\n-        \/**\n-         * Completes a modules directory by setting the list of child nodes.\n-         *\n-         * <p>The given directory can be the top level {@code \/modules} directory,\n-         * so it is NOT safe to use {@code isModulesSubdirectory(loc)} here.\n-         *\/\n+        \/** Completes a modules directory by setting the list of child nodes. *\/\n@@ -486,3 +643,11 @@\n-            List<Node> children = createChildNodes(loc, childLoc -> {\n-                if (isModulesSubdirectory(childLoc)) {\n-                    return nodes.computeIfAbsent(childLoc.getFullName(), this::newDirectory);\n+            List<Node> previewOnlyNodes = getPreviewNodesToMerge(dir);\n+            \/\/ We hide preview names from direct lookup, but must also prevent\n+            \/\/ the preview directory from appearing in any META-INF directories.\n+            boolean parentIsMetaInfDir = isMetaInf(dir);\n+            List<Node> children = createChildNodes(loc, previewOnlyNodes.size(), childLoc -> {\n+                LocationType type = childLoc.getType();\n+                if (type == MODULES_DIR) {\n+                    String name = childLoc.getFullName();\n+                    return parentIsMetaInfDir && name.endsWith(\"\/preview\")\n+                            ? null\n+                            : nodes.computeIfAbsent(name, this::newDirectory);\n@@ -490,0 +655,1 @@\n+                    assert type == RESOURCE : \"Invalid location type: \" + loc;\n@@ -495,0 +661,1 @@\n+            children.addAll(previewOnlyNodes);\n@@ -499,7 +666,2 @@\n-        \/**\n-         * Completes a package directory by setting the list of child nodes.\n-         *\n-         * <p>The given directory can be the top level {@code \/packages} directory,\n-         * so it is NOT safe to use {@code isPackagesSubdirectory(loc)} here.\n-         *\/\n-        private Directory completePackageDirectory(Directory dir, ImageLocation loc) {\n+        \/** Completes a package directory by setting the list of child nodes. *\/\n+        private void completePackageSubdirectory(Directory dir, ImageLocation loc) {\n@@ -507,20 +669,24 @@\n-            \/\/ The only directories in the \"\/packages\" namespace are \"\/packages\" or\n-            \/\/ \"\/packages\/<package>\". However, unlike \"\/modules\" directories, the\n-            \/\/ location offsets mean different things.\n-            List<Node> children;\n-            if (dir.getName().equals(PACKAGES_ROOT)) {\n-                \/\/ Top-level directory just contains a list of subdirectories.\n-                children = createChildNodes(loc, c -> nodes.computeIfAbsent(c.getFullName(), this::newDirectory));\n-            } else {\n-                \/\/ A package directory's content is array of offset PAIRS in the\n-                \/\/ Strings table, but we only need the 2nd value of each pair.\n-                IntBuffer intBuffer = getOffsetBuffer(loc);\n-                int offsetCount = intBuffer.capacity();\n-                assert (offsetCount & 0x1) == 0 : \"Offset count must be even: \" + offsetCount;\n-                children = new ArrayList<>(offsetCount \/ 2);\n-                \/\/ Iterate the 2nd offset in each pair (odd indices).\n-                for (int i = 1; i < offsetCount; i += 2) {\n-                    String moduleName = getString(intBuffer.get(i));\n-                    children.add(nodes.computeIfAbsent(\n-                            dir.getName() + \"\/\" + moduleName,\n-                            n -> newLinkNode(n, MODULES_ROOT + \"\/\" + moduleName)));\n+            assert !dir.isCompleted() : \"Directory already completed: \" + dir;\n+            assert loc.getType() == PACKAGES_DIR : \"Invalid location type: \" + loc.getType();\n+\n+            \/\/ In non-preview mode we might skip a very small number of preview-only\n+            \/\/ entries, but it's not worth \"right-sizing\" the array for that.\n+            IntBuffer offsets = getOffsetBuffer(loc);\n+            List<Node> children = new ArrayList<>(offsets.capacity() \/ 2);\n+            ModuleReference.readNameOffsets(offsets, \/*normal*\/ true, previewMode)\n+                    .forEachRemaining(n -> {\n+                        String modName = getString(n);\n+                        Node link = newLinkNode(dir.getName() + \"\/\" + modName, MODULES_PREFIX + \"\/\" + modName);\n+                        children.add(ensureCached(link));\n+                    });\n+            \/\/ If the parent directory exists, there must be at least one child node.\n+            assert !children.isEmpty() : \"Invalid empty package directory: \" + dir;\n+            dir.setChildren(children);\n+        }\n+\n+        \/** Returns the list of child preview nodes to be merged into the given directory. *\/\n+        List<Node> getPreviewNodesToMerge(Directory dir) {\n+            if (previewDirectoriesToMerge != null) {\n+                Directory mergeDir = previewDirectoriesToMerge.get(dir.getName());\n+                if (mergeDir != null) {\n+                    return mergeDir.children;\n@@ -529,3 +695,1 @@\n-            \/\/ This only happens once and \"completes\" the directory.\n-            dir.setChildren(children);\n-            return dir;\n+            return Collections.emptyList();\n@@ -535,1 +699,7 @@\n-         * Creates the list of child nodes for a {@code Directory} based on a given\n+         * Creates the list of child nodes for a modules {@code Directory} from\n+         * its parent location.\n+         *\n+         * <p>The {@code getChildFn} may return existing cached nodes rather\n+         * than creating them, and if newly created nodes are to be cached,\n+         * it is the job of {@code getChildFn}, or the caller of this method,\n+         * to do that.\n@@ -537,2 +707,7 @@\n-         * <p>Note: This cannot be used for package subdirectories as they have\n-         * child offsets stored differently to other directories.\n+         * @param loc a location relating to a \"\/modules\" directory.\n+         * @param extraNodesCount a known number of preview-only child nodes\n+         *     which will be merged onto the end of the returned list later.\n+         * @param getChildFn a function to return a node for each child location\n+         *     (or null to skip putting anything in the list).\n+         * @return the list of the non-null child nodes, returned by\n+         *     {@code getChildFn}, in the order of the locations entries.\n@@ -540,1 +715,3 @@\n-        private List<Node> createChildNodes(ImageLocation loc, Function<ImageLocation, Node> newChildFn) {\n+        private List<Node> createChildNodes(ImageLocation loc, int extraNodesCount, Function<ImageLocation, Node> getChildFn) {\n+            LocationType type = loc.getType();\n+            assert type == MODULES_DIR || type == MODULES_ROOT : \"Invalid location type: \" + loc;\n@@ -543,1 +720,1 @@\n-            List<Node> children = new ArrayList<>(childCount);\n+            List<Node> children = new ArrayList<>(childCount + extraNodesCount);\n@@ -545,1 +722,4 @@\n-                children.add(newChildFn.apply(getLocation(offsets.get(i))));\n+                Node childNode = getChildFn.apply(getLocation(offsets.get(i)));\n+                if (childNode != null) {\n+                    children.add(childNode);\n+                }\n@@ -552,1 +732,1 @@\n-            assert !isResource(dir) : \"Not a directory: \" + dir.getFullName();\n+            assert dir.getType() != RESOURCE : \"Not a directory: \" + dir.getFullName();\n@@ -559,26 +739,0 @@\n-        \/**\n-         * Efficiently determines if an image location is a resource.\n-         *\n-         * <p>A resource must have a valid module associated with it, so its\n-         * module offset must be non-zero, and not equal to the offsets for\n-         * \"\/modules\/...\" or \"\/packages\/...\" entries.\n-         *\/\n-        private boolean isResource(ImageLocation loc) {\n-            int moduleOffset = loc.getModuleOffset();\n-            return moduleOffset != 0\n-                    && moduleOffset != modulesStringOffset\n-                    && moduleOffset != packagesStringOffset;\n-        }\n-\n-        \/**\n-         * Determines if an image location is a directory in the {@code \/modules}\n-         * namespace (if so, the location name is the node name).\n-         *\n-         * <p>In jimage, every {@code ImageLocation} under {@code \/modules\/} is a\n-         * directory and has the same value for {@code getModule()}, and {@code\n-         * getModuleOffset()}.\n-         *\/\n-        private boolean isModulesSubdirectory(ImageLocation loc) {\n-            return loc.getModuleOffset() == modulesStringOffset;\n-        }\n-\n@@ -600,1 +754,0 @@\n-            assert name.equals(loc.getFullName(true)) : \"Mismatched location for resource: \" + name;\n@@ -832,1 +985,1 @@\n-        private void setChildren(List<Node> children) {\n+        private void setChildren(List<? extends Node> children) {\n@@ -837,0 +990,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":327,"deletions":173,"binary":false,"changes":500,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,13 @@\n+    \/\/ String offset constants are useful for efficient classification\n+    \/\/ of location entries without string comparison. These may change\n+    \/\/ between jimage versions (they are checked during initialization).\n+\n+    \/** Fixed offset for the empty string in the strings table. *\/\n+    int EMPTY_STRING_OFFSET = 0;\n+    \/** Fixed offset for the string \"class\" in the strings table. *\/\n+    int CLASS_STRING_OFFSET = 1;\n+    \/** Fixed offset for the string \"modules\" in the strings table. *\/\n+    int MODULES_STRING_OFFSET = 7;\n+    \/** Fixed offset for the string \"packages\" in the strings table. *\/\n+    int PACKAGES_STRING_OFFSET = 15;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageStrings.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jimage;\n+\n+import java.nio.IntBuffer;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.IntPredicate;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Represents the module entries stored in the buffer of {@code \"\/packages\/xxx\"}\n+ * image locations (package subdirectories). These entries use flags which are\n+ * similar to, but distinct from, the {@link ImageLocation} flags, so\n+ * encapsulating them here helps avoid confusion.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ *\/\n+public final class ModuleReference implements Comparable<ModuleReference> {\n+    \/\/ The following flags are designed to be additive (hence \"has-resources\"\n+    \/\/ rather than \"is-empty\", even though \"isEmpty()\" is whats in the API).\n+    \/\/ API methods like \"isEmpty()\" and \"hasPreviewVersion()\" are designed to\n+    \/\/ match the semantics of ImageLocation flags to avoid having business\n+    \/\/ logic need to reason about two different flag regimes.\n+\n+    \/** If set, the associated module has resources (in normal or preview mode). *\/\n+    private static final int FLAGS_HAS_CONTENT = 0x1;\n+    \/** If set, this package exists in non-preview mode. *\/\n+    private static final int FLAGS_HAS_NORMAL_VERSION = 0x2;\n+    \/** If set, this package exists in preview mode. *\/\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x4;\n+\n+    \/**\n+     * References are ordered with preview versions first which permits early\n+     * exit when processing preview entries (it's reversed because the default\n+     * order for a boolean is {@code false < true}).\n+     *\/\n+    private static final Comparator<ModuleReference> PREVIEW_FIRST =\n+            Comparator.comparing(ModuleReference::hasPreviewVersion).reversed()\n+                    .thenComparing(ModuleReference::name);\n+\n+    \/** Creates a reference for an empty package (one without content in). *\/\n+    public static ModuleReference forEmptyPackage(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, previewFlag(isPreview));\n+    }\n+\n+    \/** Creates a reference for a preview only module. *\/\n+    public static ModuleReference forResource(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, FLAGS_HAS_CONTENT | previewFlag(isPreview));\n+    }\n+\n+    private static int previewFlag(boolean isPreview) {\n+        return isPreview ? FLAGS_HAS_PREVIEW_VERSION : FLAGS_HAS_NORMAL_VERSION;\n+    }\n+\n+    \/** Merges two references for the same module (combining their flags). *\/\n+    public ModuleReference merge(ModuleReference other) {\n+        if (!name.equals(other.name)) {\n+            throw new IllegalArgumentException(\"Cannot merge \" + other + \" with \" + this);\n+        }\n+        \/\/ Because flags are additive, we can just OR them here.\n+        return new ModuleReference(name, flags | other.flags);\n+    }\n+\n+    private final String name;\n+    private final int flags;\n+\n+    private ModuleReference(String moduleName, int flags) {\n+        this.name = Objects.requireNonNull(moduleName);\n+        this.flags = flags;\n+    }\n+\n+    \/** Returns the module name of this reference. *\/\n+    public String name() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns whether the package associated with this reference contains\n+     * resources in this reference's module.\n+     *\n+     * <p>An invariant of the module system is that while a package may exist\n+     * under many modules, it is only non-empty in one.\n+     *\/\n+    public boolean hasContent() {\n+        return ((flags & FLAGS_HAS_CONTENT) != 0);\n+    }\n+\n+    \/**\n+     * Returns whether the package associated with this reference has a preview\n+     * version (empty or otherwise) in this reference's module.\n+     *\/\n+    public boolean hasPreviewVersion() {\n+        return (flags & FLAGS_HAS_PREVIEW_VERSION) != 0;\n+    }\n+\n+    \/** Returns whether this reference exists only in preview mode. *\/\n+    public boolean isPreviewOnly() {\n+        return !hasNormalVersion(flags);\n+    }\n+\n+    private static boolean hasNormalVersion(int flags) {\n+        return (flags & FLAGS_HAS_NORMAL_VERSION) != 0;\n+    }\n+\n+    @Override\n+    public int compareTo(ModuleReference rhs) {\n+        return PREVIEW_FIRST.compare(this, rhs);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ModuleReference{ module=\" + name + \", flags=\" + flags + \" }\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof ModuleReference)) {\n+            return false;\n+        }\n+        ModuleReference other = (ModuleReference) obj;\n+        return name.equals(other.name) && flags == other.flags;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, flags);\n+    }\n+\n+    \/**\n+     * Reads the content buffer of a package subdirectory to return a sequence\n+     * of module name offsets in the jimage.\n+     *\n+     * @param buffer the content buffer of an {@link ImageLocation} with type\n+     *     {@link ImageLocation.LocationType#PACKAGES_DIR PACKAGES_DIR}.\n+     * @param includeNormal whether to include name offsets for modules present\n+     *     in normal (non-preview) mode.\n+     * @param includePreview whether to include name offsets for modules present\n+     *     in preview mode.\n+     * @return an iterator of module name offsets.\n+     *\/\n+    public static Iterator<Integer> readNameOffsets(\n+            IntBuffer buffer, boolean includeNormal, boolean includePreview) {\n+        int bufferSize = buffer.capacity();\n+        if (bufferSize == 0 || (bufferSize & 0x1) != 0) {\n+            throw new IllegalArgumentException(\"Invalid buffer size\");\n+        }\n+        int testFlags = (includeNormal ? FLAGS_HAS_NORMAL_VERSION : 0)\n+                + (includePreview ? FLAGS_HAS_PREVIEW_VERSION : 0);\n+        if (testFlags == 0) {\n+            throw new IllegalArgumentException(\"Invalid flags\");\n+        }\n+\n+        return new Iterator<Integer>() {\n+            private int idx = nextIdx(0);\n+\n+            int nextIdx(int idx) {\n+                for (; idx < bufferSize; idx += 2) {\n+                    \/\/ If any of the test flags are set, include this entry.\n+\n+                    \/\/ Temporarily allow for *neither* flag to be set. This is what would\n+                    \/\/ be written by a 1.0 version of the jimage flag, and indicates a\n+                    \/\/ normal resource without a preview version.\n+                    \/\/ TODO: Remove the zero-check below once image writer code is updated.\n+                    int previewFlags =\n+                            buffer.get(idx) & (FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION);\n+                    if (previewFlags == 0 || (previewFlags & testFlags) != 0) {\n+                        return idx;\n+                    } else if (!includeNormal) {\n+                        \/\/ Preview entries are first in the offset buffer, so we\n+                        \/\/ can exit early (by returning the end index) if we are\n+                        \/\/ only iterating preview entries, and have run out.\n+                        break;\n+                    }\n+                }\n+                return bufferSize;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return idx < bufferSize;\n+            }\n+\n+            @Override\n+            public Integer next() {\n+                if (idx < bufferSize) {\n+                    int nameOffset = buffer.get(idx + 1);\n+                    idx = nextIdx(idx + 2);\n+                    return nameOffset;\n+                }\n+                throw new NoSuchElementException();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Writes a list of module references to a given buffer. The given references\n+     * list is checked carefully to ensure the written buffer will be valid.\n+     *\n+     * <p>Entries are written in order, taking two integer slots per entry as\n+     * {@code [<flags>, <encoded-name>]}.\n+     *\n+     * @param refs the references to write, correctly ordered.\n+     * @param buffer destination buffer.\n+     * @param nameEncoder encoder for module names.\n+     * @throws IllegalArgumentException in the references are invalid in any way.\n+     *\/\n+    public static void write(\n+            List<ModuleReference> refs, IntBuffer buffer, Function<String, Integer> nameEncoder) {\n+        if (refs.isEmpty()) {\n+            throw new IllegalArgumentException(\"References list must be non-empty\");\n+        }\n+        int expectedCapacity = 2 * refs.size();\n+        if (buffer.capacity() != expectedCapacity) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid buffer capacity: expected \" + expectedCapacity + \", got \" + buffer.capacity());\n+        }\n+        \/\/ This catches exact duplicates in the list.\n+        refs.stream().reduce((lhs, rhs) -> {\n+            if (lhs.compareTo(rhs) >= 0) {\n+                throw new IllegalArgumentException(\"References must be strictly ordered: \" + refs);\n+            }\n+            return rhs;\n+        });\n+        \/\/ Distinct references can have the same name (but we don't allow this).\n+        if (refs.stream().map(ModuleReference::name).distinct().count() != refs.size()) {\n+            throw new IllegalArgumentException(\"Reference names must be unique: \" + refs);\n+        }\n+        if (refs.stream().filter(ModuleReference::hasContent).count() > 1) {\n+            throw new IllegalArgumentException(\"At most one reference can have content: \" + refs);\n+        }\n+        for (ModuleReference modRef : refs) {\n+            buffer.put(modRef.flags);\n+            buffer.put(nameEncoder.apply(modRef.name));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ModuleReference.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jimage;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+\/**\n+ * Specifies the preview mode used to open a jimage file via {@link ImageReader}.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ * *\/\n+public enum PreviewMode {\n+    \/**\n+     * Preview mode is disabled. No preview classes or resources will be available\n+     * in this mode.\n+     *\/\n+    DISABLED() {\n+        @Override\n+        boolean resolve() {\n+            return false;\n+        }\n+    },\n+    \/**\n+     * Preview mode is enabled. If preview classes or resources exist in the jimage file,\n+     * they will be made available.\n+     *\/\n+    ENABLED() {\n+        @Override\n+        boolean resolve() {\n+            return true;\n+        }\n+    },\n+    \/**\n+     * The preview mode of the current run-time, typically determined by the\n+     * {@code --enable-preview} flag.\n+     *\/\n+    FOR_RUNTIME() {\n+        @Override\n+        boolean resolve() {\n+            \/\/ We want to call jdk.internal.misc.PreviewFeatures.isEnabled(), but\n+            \/\/ is not available in older JREs, so we must look to it reflectively.\n+            Class<?> clazz;\n+            try {\n+                clazz = Class.forName(\"jdk.internal.misc.PreviewFeatures\");\n+            } catch (ClassNotFoundException e) {\n+                \/\/ It is valid and expected that the class might not exist (JDK-8).\n+                return false;\n+            }\n+            try {\n+                return (Boolean) clazz.getDeclaredMethod(\"isEnabled\").invoke(null);\n+            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+                \/\/ But if the class exists, the method must exist and be callable.\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+    };\n+\n+    \/**\n+     * Resolves whether preview mode should be enabled for an {@link ImageReader}.\n+     *\/\n+    abstract boolean resolve();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/PreviewMode.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jimage;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+\n+\/**\n+ * Static holder class for singleton {@link ImageReader} instance.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ *\/\n+public class SystemImageReader {\n+    private static final ImageReader SYSTEM_IMAGE_READER;\n+\n+    static {\n+        String javaHome = System.getProperty(\"java.home\");\n+        FileSystem fs;\n+        if (SystemImageReader.class.getClassLoader() == null) {\n+            try {\n+                fs = (FileSystem) Class.forName(\"sun.nio.fs.DefaultFileSystemProvider\")\n+                        .getMethod(\"theFileSystem\")\n+                        .invoke(null);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        } else {\n+            fs = FileSystems.getDefault();\n+        }\n+        try {\n+            SYSTEM_IMAGE_READER = ImageReader.open(fs.getPath(javaHome, \"lib\", \"modules\"), PreviewMode.FOR_RUNTIME);\n+        } catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the singleton {@code ImageReader} to read the image file in this\n+     * run-time image. The returned instance must not be closed.\n+     *\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public static ImageReader get() {\n+        return SYSTEM_IMAGE_READER;\n+    }\n+\n+    private SystemImageReader() {}\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/SystemImageReader.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -61,1 +61,0 @@\n-import java.util.Map;\n@@ -66,0 +65,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -84,3 +84,9 @@\n-    JrtFileSystem(JrtFileSystemProvider provider, Map<String, ?> env)\n-            throws IOException\n-    {\n+    \/**\n+     * Special constructor for the singleton system jrt file system. This creates\n+     * a non-closable instance, and should only be called once by {@link\n+     * JrtFileSystemProvider}.\n+     *\n+     * @param provider the provider opening the file system.\n+     *\/\n+    JrtFileSystem(JrtFileSystemProvider provider)\n+            throws IOException {\n@@ -88,1 +94,1 @@\n-        this.image = SystemImage.open();  \/\/ open image file\n+        this.image = SystemImage.open(PreviewMode.FOR_RUNTIME);  \/\/ open image file\n@@ -90,1 +96,16 @@\n-        this.isClosable = env != null;\n+        \/\/ Only the system singleton jrt file system is \"unclosable\".\n+        this.isClosable = false;\n+    }\n+\n+    \/**\n+     * Creates a new, non-system, instance of the jrt file system.\n+     *\n+     * @param provider the provider opening the file system.\n+     * @param mode controls whether preview resources are visible.\n+     *\/\n+    JrtFileSystem(JrtFileSystemProvider provider, PreviewMode mode)\n+            throws IOException {\n+        this.provider = provider;\n+        this.image = SystemImage.open(mode);  \/\/ open image file\n+        this.isOpen = true;\n+        this.isClosable = true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.PreviewMode;\n+\n@@ -47,1 +49,1 @@\n- * .jimage file or exploded modules directory of underlying JDK.\n+ * a jimage file, or exploded modules directory of underlying JDK.\n@@ -110,1 +112,13 @@\n-            return new JrtFileSystem(this, env);\n+            return new JrtFileSystem(this, parsePreviewMode(env.get(\"previewMode\")));\n+        }\n+    }\n+\n+    \/\/ Currently this does not support specifying \"for runtime\", because it is\n+    \/\/ expected that callers creating non-standard image readers will not be\n+    \/\/ using them to read resources for the current runtime (they would just\n+    \/\/ use \"jrt:\" URLs if they were doing that).\n+    private static PreviewMode parsePreviewMode(Object envValue) {\n+        if (envValue instanceof Boolean && (Boolean) envValue) {\n+            return PreviewMode.ENABLED;\n+        } else if (envValue instanceof String && Boolean.parseBoolean((String) envValue)) {\n+            return PreviewMode.ENABLED;\n@@ -112,0 +126,2 @@\n+        \/\/ Default (unspecified\/null or bad parameter) is to not use preview mode.\n+        return PreviewMode.DISABLED;\n@@ -211,1 +227,2 @@\n-                        this.theFileSystem = fs = new JrtFileSystem(this, null);\n+                        \/\/ Special constructor call for singleton instance.\n+                        this.theFileSystem = fs = new JrtFileSystem(this);\n@@ -229,1 +246,1 @@\n-    static final JrtPath toJrtPath(Path path) {\n+    static JrtPath toJrtPath(Path path) {\n@@ -260,1 +277,1 @@\n-    public final void delete(Path path) throws IOException {\n+    public void delete(Path path) throws IOException {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystemProvider.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -57,1 +58,1 @@\n-    static SystemImage open() throws IOException {\n+    static SystemImage open(PreviewMode mode) throws IOException {\n@@ -60,1 +61,1 @@\n-            final ImageReader image = ImageReader.open(moduleImageFile);\n+            final ImageReader image = ImageReader.open(moduleImageFile, mode);\n@@ -76,0 +77,3 @@\n+\n+        \/\/ TODO: Maybe throw if enablePreview attempted for exploded image?\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-import jdk.internal.jimage.ImageReaderFactory;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -395,1 +395,1 @@\n-        static final ImageReader READER = ImageReaderFactory.getImageReader();\n+        static final ImageReader READER = SystemImageReader.get();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.internal.jimage.ImageReaderFactory;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -51,1 +51,1 @@\n-    private static final ImageReader READER = ImageReaderFactory.getImageReader();\n+    private static final ImageReader READER = SystemImageReader.get();\n@@ -112,0 +112,2 @@\n+        \/\/ Note: UncheckedIOException is thrown by the Node subclass in\n+        \/\/ ExplodedImage (this not obvious, so worth calling out).\n@@ -114,1 +116,1 @@\n-        } catch (IOException ioe) {\n+        } catch (IOException | UncheckedIOException ioe) {\n@@ -127,0 +129,4 @@\n+        if (path.indexOf('%') == -1) {\n+            \/\/ Nothing to decode (overwhelmingly common case).\n+            return path;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jrt\/JavaRuntimeURLConnection.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -322,1 +322,6 @@\n-        _header.minor_version(_endian) != MINOR_VERSION) {\n+        \/\/ Temporarily, we allow either version (1.1 or 1.0) of the file to\n+        \/\/ be read so this code can be committed before image writing changes\n+        \/\/ for preview mode. Preview mode changes do not modify any structure,\n+        \/\/ so a 1.0 file will look like a jimage without any preview resources.\n+        \/\/ TODO: Restore equality check for MINOR_VERSION.\n+        _header.minor_version(_endian) > MINOR_VERSION) {\n@@ -407,1 +412,1 @@\n-                return offset;\n+            return offset;\n@@ -438,1 +443,1 @@\n-    \/\/ Compare with basne name.\n+    \/\/ Compare with base name.\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-        ATTRIBUTE_EXTENSION,        \/\/ String table offset of resource path extension\n+        ATTRIBUTE_EXTENSION,            \/\/ String table offset of resource path extension\n@@ -242,2 +242,3 @@\n-        ATTRIBUTE_COMPRESSED,       \/\/ In image byte size of the compressed resource\n-        ATTRIBUTE_UNCOMPRESSED, \/\/ In memory byte size of the uncompressed resource\n+        ATTRIBUTE_COMPRESSED,           \/\/ In-image byte size of the compressed resource\n+        ATTRIBUTE_UNCOMPRESSED,         \/\/ In-memory byte size of the uncompressed resource\n+        ATTRIBUTE_PREVIEW_FLAGS,        \/\/ Flags relating to preview mode resources.\n@@ -247,0 +248,13 @@\n+    \/\/ Flag masks for the ATTRIBUTE_PREVIEW_FLAGS attribute. Defined so\n+    \/\/ that zero is the overwhelmingly common case for normal resources.\n+    enum {\n+        \/\/ Set on a \"normal\" (non-preview) location if a preview version of\n+        \/\/ it exists in the same module.\n+        FLAGS_HAS_PREVIEW_VERSION = 0x1,\n+        \/\/ Set on all preview locations in \"\/modules\/xxx\/META-INF\/preview\/...\"\n+        FLAGS_IS_PREVIEW_VERSION = 0x2,\n+        \/\/ Set on a preview location if no normal (non-preview) version of\n+        \/\/ it exists in the same module.\n+        FLAGS_IS_PREVIEW_ONLY = 0x4\n+    };\n+\n@@ -303,0 +317,5 @@\n+\n+    \/\/ Retrieve flags from the ATTRIBUTE_PREVIEW_FLAGS attribute.\n+    inline u4 get_preview_flags() const {\n+        return (u4) get_attribute(ATTRIBUTE_PREVIEW_FLAGS);\n+    }\n@@ -397,0 +416,1 @@\n+friend class PackageFlags;\n@@ -436,1 +456,1 @@\n-        MINOR_VERSION = 0\n+        MINOR_VERSION = 1\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n- * The version number should be \"9.0\" and is not used in locating the resource.\n@@ -101,1 +100,1 @@\n- *                                 \"java.base\", \"9.0\", \"java\/lang\/String.class\", &size);\n+ *           \"java.base\", \"java\/lang\/String.class\", is_preview_mode, &size);\n@@ -105,1 +104,1 @@\n-        const char* module_name, const char* version, const char* name,\n+        const char* module_name, const char* name, bool is_preview_mode,\n@@ -107,0 +106,22 @@\n+    static const char str_modules[] = \"modules\";\n+    static const char str_packages[] = \"packages\";\n+    static const char preview_infix[] = \"\/META-INF\/preview\";\n+\n+    size_t module_name_len = strlen(module_name);\n+    size_t name_len = strlen(name);\n+    size_t preview_infix_len = strlen(preview_infix);\n+\n+    \/\/ TBD:   assert(module_name_len > 0 && \"module name must be non-empty\");\n+    assert(name_len > 0 && \"name must non-empty\");\n+\n+    \/\/ Do not attempt to lookup anything of the form \/modules\/... or \/packages\/...\n+    if (strncmp(module_name, str_modules, sizeof(str_modules)) == 0\n+            || strncmp(module_name, str_packages, sizeof(str_packages)) == 0) {\n+        return 0L;\n+    }\n+    \/\/ If the preview mode version of the path string is too long for the buffer,\n+    \/\/ return not found (even when not in preview mode).\n+    if (1 + module_name_len + preview_infix_len + 1 + name_len + 1 > IMAGE_MAX_PATH) {\n+        return 0L;\n+    }\n+\n@@ -108,4 +129,15 @@\n-    char fullpath[IMAGE_MAX_PATH];\n-    size_t moduleNameLen = strlen(module_name);\n-    size_t nameLen = strlen(name);\n-    size_t index;\n+    char name_buffer[IMAGE_MAX_PATH];\n+    char* path;\n+    {   \/\/ Write the buffer with room to prepend the preview mode infix\n+        \/\/ at the start (saves copying the trailing name part twice).\n+        size_t index = preview_infix_len;\n+        name_buffer[index++] = '\/';\n+        memcpy(&name_buffer[index], module_name, module_name_len);\n+        index += module_name_len;\n+        name_buffer[index++] = '\/';\n+        memcpy(&name_buffer[index], name, name_len);\n+        index += name_len;\n+        name_buffer[index++] = '\\0';\n+        \/\/ Path begins at the leading '\/' (not the start of the buffer).\n+        path = &name_buffer[preview_infix_len];\n+    }\n@@ -113,2 +145,8 @@\n-    \/\/ TBD:   assert(moduleNameLen > 0 && \"module name must be non-empty\");\n-    assert(nameLen > 0 && \"name must non-empty\");\n+    \/\/ find_location_index() returns the data \"offset\", not an index.\n+    const ImageFileReader* image_file = (ImageFileReader*) image;\n+    u4 locOffset = image_file->find_location_index(path, (u8*) size);\n+    if (locOffset == 0) {\n+        return 0L;\n+    }\n+    ImageLocation loc;\n+    loc.set_data(image_file->get_location_offset_data(locOffset));\n@@ -116,2 +154,9 @@\n-    \/\/ If the concatenated string is too long for the buffer, return not found\n-    if (1 + moduleNameLen + 1 + nameLen + 1 > IMAGE_MAX_PATH) {\n+    u4 flags = loc.get_preview_flags();\n+    \/\/ No preview flags means \"a normal resource, without a preview version\".\n+    \/\/ This is the overwhelmingly common case, with or without preview mode.\n+    if (flags == 0) {\n+        return locOffset;\n+    }\n+    \/\/ Regardless of preview mode, don't return resources requested directly\n+    \/\/ via their preview path.\n+    if ((flags & ImageLocation::FLAGS_IS_PREVIEW_VERSION) != 0) {\n@@ -120,0 +165,17 @@\n+    \/\/ Even if there is a preview version, we might not want to return it.\n+    if (!is_preview_mode || (flags & ImageLocation::FLAGS_HAS_PREVIEW_VERSION) == 0) {\n+        return locOffset;\n+    }\n+\n+    {   \/\/ Rewrite the front of the name buffer to make it a preview path.\n+        size_t index = 0;\n+        name_buffer[index++] = '\/';\n+        memcpy(&name_buffer[index], module_name, module_name_len);\n+        index += module_name_len;\n+        memcpy(&name_buffer[index], preview_infix, preview_infix_len);\n+        index += preview_infix_len;\n+        \/\/ Check we copied up to the expected '\/' separator.\n+        assert(name_buffer[index] == '\/' && \"bad string concatenation\");\n+        \/\/ The preview path now begins at the start of the buffer.\n+        path = &name_buffer[0];\n+    }\n@@ -121,12 +183,2 @@\n-    index = 0;\n-    fullpath[index++] = '\/';\n-    memcpy(&fullpath[index], module_name, moduleNameLen);\n-    index += moduleNameLen;\n-    fullpath[index++] = '\/';\n-    memcpy(&fullpath[index], name, nameLen);\n-    index += nameLen;\n-    fullpath[index++] = '\\0';\n-\n-    JImageLocationRef loc =\n-            (JImageLocationRef) ((ImageFileReader*) image)->find_location_index(fullpath, (u8*) size);\n-    return loc;\n+    \/\/ Lookup the preview version (which *should* exist).\n+    return image_file->find_location_index(path, (u8*) size);\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":75,"deletions":23,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n- * The version number should be \"9.0\" and is not used in locating the resource.\n@@ -108,1 +107,1 @@\n- *                                \"java.base\", \"9.0\", \"java\/lang\/String.class\", &size);\n+ *           \"java.base\", \"java\/lang\/String.class\", is_preview_mode, &size);\n@@ -111,1 +110,1 @@\n-        const char* module_name, const char* version, const char* name,\n+        const char* module_name, const char* name, bool is_preview_mode,\n@@ -115,1 +114,1 @@\n-        const char* module_name, const char* version, const char* name,\n+        const char* module_name, const char* name, bool is_preview_mode,\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    static final int EMPTY_OFFSET = 0;\n@@ -45,5 +44,6 @@\n-        \/\/ Reserve 0 offset for empty string.\n-        int offset = addString(\"\");\n-        if (offset != 0) {\n-            throw new InternalError(\"Empty string not offset zero\");\n-        }\n+        \/\/ Frequently used\/special strings for which the offset is useful.\n+        reserveString(\"\", ImageStrings.EMPTY_STRING_OFFSET);\n+        reserveString(\"class\", ImageStrings.CLASS_STRING_OFFSET);\n+        reserveString(\"modules\", ImageStrings.MODULES_STRING_OFFSET);\n+        reserveString(\"packages\", ImageStrings.PACKAGES_STRING_OFFSET);\n+    }\n@@ -51,4 +51,4 @@\n-        \/\/ Reserve 1 offset for frequently used \".class\".\n-        offset = addString(\"class\");\n-        if (offset != 1) {\n-            throw new InternalError(\"'class' string not offset one\");\n+    private void reserveString(String value, int expectedOffset) {\n+        int offset = addString(value);\n+        if (offset != expectedOffset) {\n+            throw new InternalError(\"Reserved string \\\"\" + value + \"\\\" not at expected offset \" + expectedOffset + \"[was \" + offset + \"]\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageStringsWriter.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -340,1 +341,1 @@\n-        try (ImageReader nativeReader = ImageReader.open(imageFile)) {\n+        try (ImageReader nativeReader = ImageReader.open(imageFile, PreviewMode.DISABLED)) {\n@@ -343,1 +344,1 @@\n-        } catch (IOException expected) {\n+        } catch (IOException unexpected) {\n@@ -349,1 +350,1 @@\n-        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder));\n+        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder, PreviewMode.DISABLED));\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ModuleReference;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.nio.IntBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static java.util.function.Predicate.not;\n+import static jdk.internal.jimage.ModuleReference.forEmptyPackage;\n+import static jdk.internal.jimage.ModuleReference.forResource;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ModuleReference.\n+ * @modules java.base\/jdk.internal.jimage\n+ * @run junit\/othervm -esa ModuleReferenceTest\n+ *\/\n+public final class ModuleReferenceTest {\n+    \/\/ Copied (not referenced) for testing.\n+    private static final int FLAGS_HAS_CONTENT = 0x1;\n+    private static final int FLAGS_HAS_NORMAL_VERSION = 0x2;\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x4;\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void emptyRefs(boolean isPreview) {\n+        ModuleReference ref = forEmptyPackage(\"module\", isPreview);\n+\n+        assertEquals(\"module\", ref.name());\n+        assertFalse(ref.hasContent());\n+        assertEquals(isPreview, ref.hasPreviewVersion());\n+        assertEquals(isPreview, ref.isPreviewOnly());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void resourceRefs(boolean isPreview) {\n+        ModuleReference ref = forResource(\"module\", isPreview);\n+\n+        assertEquals(\"module\", ref.name());\n+        assertTrue(ref.hasContent());\n+        assertEquals(isPreview, ref.hasPreviewVersion());\n+        assertEquals(isPreview, ref.isPreviewOnly());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void mergedRefs(boolean isPreview) {\n+        ModuleReference emptyRef = forEmptyPackage(\"module\", true);\n+        ModuleReference resourceRef = forResource(\"module\", isPreview);\n+        ModuleReference merged = emptyRef.merge(resourceRef);\n+\n+        \/\/ Merging preserves whether there's content.\n+        assertTrue(merged.hasContent());\n+        \/\/ And clears the preview-only status unless it was set in both.\n+        assertEquals(isPreview, merged.isPreviewOnly());\n+    }\n+\n+    @Test\n+    public void writeBuffer() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"alpha\", true),\n+                forEmptyPackage(\"beta\", false).merge(forEmptyPackage(\"beta\", true)),\n+                forResource(\"gamma\", false),\n+                forEmptyPackage(\"zeta\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        ModuleReference.write(refs, buffer, testEncoder());\n+        assertArrayEquals(\n+                new int[]{\n+                        FLAGS_HAS_PREVIEW_VERSION, 100,\n+                        FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION, 101,\n+                        FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_CONTENT, 102,\n+                        FLAGS_HAS_NORMAL_VERSION, 103},\n+                buffer.array());\n+    }\n+\n+    @Test\n+    public void writeBuffer_emptyList() {\n+        IntBuffer buffer = IntBuffer.allocate(0);\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(List.of(), buffer, null));\n+        assertTrue(err.getMessage().contains(\"non-empty\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_badCapacity() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forResource(\"first\", false),\n+                forEmptyPackage(\"alpha\", false));\n+        IntBuffer buffer = IntBuffer.allocate(10);\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"buffer capacity\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_multipleContent() {\n+        \/\/ Only one module reference (at most) can have resources.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forResource(\"alpha\", false),\n+                forResource(\"beta\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"content\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_badOrdering() {\n+        \/\/ Badly ordered because preview references should come first.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"alpha\", false),\n+                forEmptyPackage(\"beta\", true));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"strictly ordered\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_duplicateRef() {\n+        \/\/ Technically distinct, and correctly sorted, but with duplicate names.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"duplicate\", true),\n+                forEmptyPackage(\"duplicate\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"unique\"));\n+    }\n+\n+    @Test\n+    public void readNameOffsets() {\n+        \/\/ Preview versions must be first (important for early exit).\n+        IntBuffer buffer = IntBuffer.wrap(new int[]{\n+                FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION, 100,\n+                FLAGS_HAS_PREVIEW_VERSION, 101,\n+                FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_CONTENT, 102,\n+                FLAGS_HAS_NORMAL_VERSION, 103});\n+\n+        List<Integer> normalOffsets = asList(ModuleReference.readNameOffsets(buffer, true, false));\n+        List<Integer> previewOffsets = asList(ModuleReference.readNameOffsets(buffer, false, true));\n+        List<Integer> allOffsets = asList(ModuleReference.readNameOffsets(buffer, true, true));\n+\n+        assertEquals(List.of(100, 102, 103), normalOffsets);\n+        assertEquals(List.of(100, 101), previewOffsets);\n+        assertEquals(List.of(100, 101, 102, 103), allOffsets);\n+    }\n+\n+    @Test\n+    public void readNameOffsets_badBufferSize() {\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.readNameOffsets(IntBuffer.allocate(3), true, false));\n+        assertTrue(err.getMessage().contains(\"buffer size\"));\n+    }\n+\n+    @Test\n+    public void readNameOffsets_badFlags() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[]{FLAGS_HAS_CONTENT, 100});\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.readNameOffsets(buffer, false, false));\n+        assertTrue(err.getMessage().contains(\"flags\"));\n+    }\n+\n+    @Test\n+    public void sortOrder_previewFirst() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"normal.beta\", false),\n+                forResource(\"preview.beta\", true),\n+                forEmptyPackage(\"preview.alpha\", true),\n+                forEmptyPackage(\"normal.alpha\", false));\n+        refs.sort(Comparator.naturalOrder());\n+        \/\/ Non-empty first with remaining sorted by name.\n+        assertEquals(\n+                List.of(\"preview.alpha\", \"preview.beta\", \"normal.alpha\", \"normal.beta\"),\n+                refs.stream().map(ModuleReference::name).toList());\n+    }\n+\n+    private static <T> List<T> asList(Iterator<T> src) {\n+        List<T> list = new ArrayList<>();\n+        src.forEachRemaining(list::add);\n+        return list;\n+    }\n+\n+    \/\/ Encodes strings sequentially starting from index 100.\n+    private static Function<String, Integer> testEncoder() {\n+        List<String> cache = new ArrayList<>();\n+        return s -> {\n+            int i = cache.indexOf(s);\n+            if (i == -1) {\n+                cache.add(s);\n+                return 100 + (cache.size() - 1);\n+            } else {\n+                return 100 + i;\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ModuleReferenceTest.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-        try (final ImageReader reader = ImageReader.open(imagePath)) {\n+        try (final ImageReader reader = ImageReader.open(imagePath, \/* previewMode *\/ false)) {\n","filename":"test\/jdk\/tools\/jimage\/ImageReaderDuplicateChildNodesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -42,1 +43,0 @@\n-import java.nio.ByteOrder;\n@@ -74,1 +74,0 @@\n-        protected ByteOrder byteOrder;\n@@ -79,1 +78,0 @@\n-            byteOrder = ByteOrder.nativeOrder();\n@@ -96,1 +94,1 @@\n-            reader = ImageReader.open(copiedImageFile, byteOrder);\n+            reader = ImageReader.open(copiedImageFile, PreviewMode.DISABLED);\n@@ -125,1 +123,1 @@\n-            reader = ImageReader.open(copiedImageFile, byteOrder);\n+            reader = ImageReader.open(copiedImageFile, PreviewMode.DISABLED);\n@@ -152,1 +150,1 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, PreviewMode.DISABLED)) {\n@@ -176,1 +174,1 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, PreviewMode.DISABLED)) {\n@@ -213,1 +211,1 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, PreviewMode.DISABLED)) {\n@@ -510,1 +508,1 @@\n-            \"\/modules\/java.base\/java\/nio\/ByteOrder.class\",\n+            \"\/modules\/java.base\/java\/nio\/PreviewMode.DISABLED.class\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}