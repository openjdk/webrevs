{"files":[{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.constant.Constable;\n-import java.lang.constant.ConstantDesc;\n@@ -32,1 +29,0 @@\n-import java.util.Optional;\n@@ -34,3 +30,1 @@\n-import jdk.internal.math.FloatConsts;\n-import jdk.internal.math.FloatingDecimal;\n-import jdk.internal.math.FloatToDecimal;\n+import jdk.internal.math.*;\n@@ -1204,0 +1198,122 @@\n+\n+    \/**\n+     * Returns the floating-point value adjacent to {@code v} in\n+     * the direction of positive infinity.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, the result is NaN.\n+     *\n+     * <li> If the argument is positive infinity, the result is\n+     * positive infinity.\n+     *\n+     * <li> If the argument is zero, the result is\n+     * {@link #MIN_VALUE}\n+     *\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the nextUp\n+     * operation defined in IEEE 754.\n+     *\n+     * @param v starting floating-point value\n+     * @return The adjacent floating-point value closer to positive\n+     * infinity.\n+     *\/\n+    public static Float16 nextUp(Float16 v) {\n+        float f = v.floatValue();\n+        if (f < Float.POSITIVE_INFINITY) {\n+            if (f != 0) {\n+                int bits = float16ToRawShortBits(v);\n+                return shortBitsToFloat16((short) (bits + ((bits >= 0) ? 1 : -1)));\n+            }\n+            return MIN_VALUE;\n+        }\n+        return v; \/\/ v is NaN or +Infinity\n+    }\n+\n+    \/**\n+     * Returns the floating-point value adjacent to {@code v} in\n+     * the direction of negative infinity.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, the result is NaN.\n+     *\n+     * <li> If the argument is negative infinity, the result is\n+     * negative infinity.\n+     *\n+     * <li> If the argument is zero, the result is\n+     * -{@link #MIN_VALUE}\n+     *\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the nextDown\n+     * operation defined in IEEE 754.\n+     *\n+     * @param v  starting floating-point value\n+     * @return The adjacent floating-point value closer to negative\n+     * infinity.\n+     *\/\n+    public static Float16 nextDown(Float16 v) {\n+        float f = v.floatValue();\n+        if (f > Float.NEGATIVE_INFINITY) {\n+            if (f != 0) {\n+                int bits = float16ToRawShortBits(v);\n+                return shortBitsToFloat16((short) (bits - ((bits >= 0) ? 1 : -1)));\n+            }\n+            return negate(MIN_VALUE);\n+        }\n+        return v; \/\/ v is NaN or -Infinity\n+    }\n+\n+    \/**\n+     * Returns {@code v} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     * rounded as if performed by a single correctly rounded\n+     * floating-point multiply.  If the exponent of the result is\n+     * between {@link Float16#MIN_EXPONENT} and {@link\n+     * Float16#MAX_EXPONENT}, the answer is calculated exactly.  If the\n+     * exponent of the result would be larger than {@code\n+     * Float16.MAX_EXPONENT}, an infinity is returned.  Note that if the\n+     * result is subnormal, precision may be lost; that is, when\n+     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n+     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n+     * result has the same sign as {@code v}.\n+     *\n+     * <p>Special cases:\n+     * <ul>\n+     * <li> If the first argument is NaN, NaN is returned.\n+     * <li> If the first argument is infinite, then an infinity of the\n+     * same sign is returned.\n+     * <li> If the first argument is zero, then a zero of the same\n+     * sign is returned.\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the scaleB operation\n+     * defined in IEEE 754.\n+     *\n+     * @param v number to be scaled by a power of two.\n+     * @param scaleFactor power of 2 used to scale {@code v}\n+     * @return {@code v} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     *\/\n+    public static Float16 scalb(Float16 v, int scaleFactor) {\n+        \/\/ magnitude of a power of two so large that scaling a finite\n+        \/\/ nonzero value by it would be guaranteed to over or\n+        \/\/ underflow; due to rounding, scaling down takes an\n+        \/\/ additional power of two which is reflected here\n+        final int MAX_SCALE = Float16.MAX_EXPONENT + -Float16.MIN_EXPONENT +\n+                Float16Consts.SIGNIFICAND_WIDTH + 1;\n+\n+        \/\/ Make sure scaling factor is in a reasonable range\n+        scaleFactor = Math.max(Math.min(scaleFactor, MAX_SCALE), -MAX_SCALE);\n+\n+        \/*\n+         * Since + MAX_SCALE for Float16 fits well within the double\n+         * exponent range and + Float16 -> double conversion is exact\n+         * the multiplication below will be exact. Therefore, the\n+         * rounding that occurs when the double product is cast to\n+         * Float16 will be the correctly rounded Float16 result.\n+         *\/\n+        return valueOf(v.doubleValue()\n+                * Double.longBitsToDouble((long) (scaleFactor + DoubleConsts.EXP_BIAS) << Double.PRECISION - 1));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":123,"deletions":7,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-package jdk.internal.math;\n-\n","filename":"test\/jdk\/java\/lang\/Math\/Float16Consts.java","additions":0,"deletions":2,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/Float16Consts.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,4 +39,10 @@\n-    static final float  NaNf = Float.NaN;\n-    static final double NaNd = Double.NaN;\n-    static final float  infinityF = Float.POSITIVE_INFINITY;\n-    static final double infinityD = Double.POSITIVE_INFINITY;\n+    static final Float16  NaNf16 = Float16.NaN;\n+    static final float    NaNf = Float.NaN;\n+    static final double   NaNd = Double.NaN;\n+    static final Float16  infinityF16 = Float16.POSITIVE_INFINITY;\n+    static final float    infinityF = Float.POSITIVE_INFINITY;\n+    static final double   infinityD = Double.POSITIVE_INFINITY;\n+\n+    static final Float16  Float16_MAX_VALUEmm       = Float16.valueOf(0x1.ff8P+15f);\n+    static final Float16  Float16_MAX_SUBNORMAL     = Float16.valueOf(0x0.ffcP-14f);\n+    static final Float16  Float16_MAX_SUBNORMALmm   = Float16.valueOf(0x0.ff8P-14f);\n@@ -55,0 +61,4 @@\n+    static Float16 copySign(Float16 magnitude, Float16 sign) {\n+        return Float16.valueOf(Math.copySign(magnitude.floatValue(), sign.floatValue()));\n+    }\n+\n@@ -73,0 +83,9 @@\n+    \/**\n+     * Returns a floating-point power of two in the normal range.\n+     *\/\n+    static Float16 powerOfTwoF16(int n) {\n+        return Float16.shortBitsToFloat16((short) (((n + Float16.MAX_EXPONENT) <<\n+                        (Float16Consts.SIGNIFICAND_WIDTH-1))\n+                        & Float16Consts.EXP_BIT_MASK));\n+    }\n+\n@@ -522,0 +541,35 @@\n+    public static int testFloat16NextUp() {\n+        int failures=0;\n+\n+        \/*\n+         * Each row of testCases represents one test case for nextUp;\n+         * the first column is the input and the second column is the\n+         * expected result.\n+         *\/\n+        Float16 testCases [][] = {\n+                {NaNf16,                      NaNf16},\n+                {Float16.negate(infinityF16),   Float16.negate(Float16.MAX_VALUE)},\n+                {Float16.negate(Float16.MAX_VALUE),          Float16.negate(Float16_MAX_VALUEmm)},\n+                {Float16.negate(Float16.MIN_NORMAL),         Float16.negate(Float16_MAX_SUBNORMAL)},\n+                {Float16.negate(Float16_MAX_SUBNORMAL),         Float16.negate(Float16_MAX_SUBNORMALmm)},\n+                {Float16.negate(Float16.MIN_VALUE),         Float16.valueOf(-0.0f)},\n+                {Float16.valueOf(-0.0f),         Float16.MIN_VALUE},\n+                {Float16.valueOf(0.0f),         Float16.MIN_VALUE},\n+                {Float16.MIN_VALUE,           Float16.multiply(Float16.MIN_VALUE, Float16.valueOf(2))},\n+\n+                {Float16_MAX_SUBNORMALmm,     Float16_MAX_SUBNORMAL},\n+                {Float16_MAX_SUBNORMAL,       Float16.MIN_NORMAL},\n+                {Float16.MIN_NORMAL,          Float16.add(Float16.MIN_NORMAL, Float16.MIN_VALUE)},\n+                {Float16_MAX_VALUEmm,         Float16.MAX_VALUE},\n+                {Float16.MAX_VALUE,           infinityF16},\n+                {infinityF16,                 infinityF16}\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures+=Tests.test(\"Float16.nextUp(Float16)\",\n+                    testCases[i][0], Float16.nextUp(testCases[i][0]), testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -599,0 +653,35 @@\n+    public static int testFloat16NextDown() {\n+        int failures=0;\n+\n+        \/*\n+         * Each row of testCases represents one test case for nextDown;\n+         * the first column is the input and the second column is the\n+         * expected result.\n+         *\/\n+        Float16 testCases [][] = {\n+                {NaNf16,                      NaNf16},\n+                {Float16.negate(infinityF16),                Float16.negate(infinityF16)},\n+                {Float16.negate(Float16.MAX_VALUE),          Float16.negate(infinityF16)},\n+                {Float16.negate(Float16_MAX_VALUEmm),        Float16.negate(Float16.MAX_VALUE)},\n+                {Float16.negate(Float16_MAX_SUBNORMAL),      Float16.negate(Float16.MIN_NORMAL)},\n+                {Float16.negate(Float16_MAX_SUBNORMALmm),    Float16.negate(Float16_MAX_SUBNORMAL)},\n+                {Float16.valueOf(-0.0f),                     Float16.negate(Float16.MIN_VALUE)},\n+                {Float16.valueOf(+0.0f),                     Float16.negate(Float16.MIN_VALUE)},\n+                {Float16.MIN_VALUE,           Float16.valueOf(0.0f)},\n+                {Float16.multiply(Float16.MIN_VALUE, Float16.valueOf(2)),         Float16.MIN_VALUE},\n+                {Float16_MAX_SUBNORMAL,       Float16_MAX_SUBNORMALmm},\n+                {Float16.MIN_NORMAL,          Float16_MAX_SUBNORMAL},\n+                {Float16.add(Float16.MIN_NORMAL, Float16.MIN_VALUE),           Float16.MIN_NORMAL},\n+                {Float16.MAX_VALUE,           Float16_MAX_VALUEmm},\n+                {infinityF16,                 Float16.MAX_VALUE},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures+=Tests.test(\"Float16.nextDown(Float16)\",\n+                    testCases[i][0], Float16.nextDown(testCases[i][0]), testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+\n@@ -785,1 +874,1 @@\n-   public static int testFloatCopySign() {\n+    public static int testFloatCopySign() {\n@@ -946,0 +1035,200 @@\n+    static int testScalbCase(Float16 value, int scale_factor, Float16 expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Float16.scalb(Float16,int)\",\n+                value, scale_factor,\n+                Float16.scalb(value, scale_factor), expected);\n+\n+        failures+=Tests.test(\"Float16.scalb(Float16,int)\",\n+                Float16.negate(value), scale_factor,\n+                Float16.scalb(Float16.negate(value), scale_factor), Float16.negate(expected));\n+        return failures;\n+    }\n+\n+    public static int testFloat16Scalb() {\n+        int failures=0;\n+        int MAX_SCALE = Float16.MAX_EXPONENT + -Float16.MIN_EXPONENT +\n+                Float16Consts.SIGNIFICAND_WIDTH + 1;\n+\n+\n+        \/\/ Arguments x, where scalb(x,n) is x for any n.\n+        Float16 [] identityTestCases = {NaNf16,\n+                Float16.valueOf(-0.0f),\n+                Float16.valueOf(+0.0f),\n+                infinityF16,\n+                Float16.negate(infinityF16)\n+        };\n+\n+        Float16 [] subnormalTestCases = {\n+                Float16.MIN_VALUE,\n+                Float16.multiply(Float16.valueOf(3), Float16.MIN_VALUE),\n+                Float16_MAX_SUBNORMALmm,\n+                Float16_MAX_SUBNORMAL\n+        };\n+\n+        Float16 [] someTestCases = {\n+                Float16.MIN_VALUE,\n+                Float16.multiply(Float16.valueOf(3), Float16.MIN_VALUE),\n+                Float16_MAX_SUBNORMALmm,\n+                Float16_MAX_SUBNORMAL,\n+                Float16.MIN_NORMAL,\n+                Float16.valueOf(1),\n+                Float16.valueOf(2),\n+                Float16.valueOf(3),\n+                Float16.valueOf(Math.PI),\n+                Float16_MAX_VALUEmm,\n+                Float16.MAX_VALUE\n+        };\n+\n+        int [] oneMultiplyScalingFactors = {\n+                Float16.MIN_EXPONENT,\n+                Float16.MIN_EXPONENT+1,\n+                -3,\n+                -2,\n+                -1,\n+                0,\n+                1,\n+                2,\n+                3,\n+                Float16.MAX_EXPONENT-1,\n+                Float16.MAX_EXPONENT\n+        };\n+\n+        int [] manyScalingFactors = {\n+                Integer.MIN_VALUE,\n+                Integer.MIN_VALUE+1,\n+                -MAX_SCALE -1,\n+                -MAX_SCALE,\n+                -MAX_SCALE+1,\n+\n+                2*Float16.MIN_EXPONENT-1,       \/\/ -29\n+                2*Float16.MIN_EXPONENT,         \/\/ -28\n+                2*Float16.MIN_EXPONENT+1,       \/\/ -27\n+\n+                Float16.MIN_EXPONENT - Float16Consts.SIGNIFICAND_WIDTH,\n+                Float16Consts.MIN_SUB_EXPONENT,\n+                -Float16.MAX_EXPONENT,          \/\/ -15\n+                Float16.MIN_EXPONENT,           \/\/ -14\n+\n+                -2,\n+                -1,\n+                0,\n+                1,\n+                2,\n+\n+                Float16.MAX_EXPONENT-1,         \/\/ 14\n+                Float16.MAX_EXPONENT,           \/\/ 15\n+                Float16.MAX_EXPONENT+1,         \/\/ 16\n+\n+                2*Float16.MAX_EXPONENT-1,       \/\/ 29\n+                2*Float16.MAX_EXPONENT,         \/\/ 30\n+                2*Float16.MAX_EXPONENT+1,       \/\/ 31\n+\n+                MAX_SCALE-1,\n+                MAX_SCALE,\n+                MAX_SCALE+1,\n+                Integer.MAX_VALUE-1,\n+                Integer.MAX_VALUE\n+        };\n+\n+        \/\/ Test cases where scaling is always a no-op\n+        for(int i=0; i < identityTestCases.length; i++) {\n+            for(int j=0; j < manyScalingFactors.length; j++) {\n+                failures += testScalbCase(identityTestCases[i],\n+                        manyScalingFactors[j],\n+                        identityTestCases[i]);\n+            }\n+        }\n+\n+        \/\/ Test cases where result is 0.0 or infinity due to magnitude\n+        \/\/ of the scaling factor\n+        for(int i=0; i < someTestCases.length; i++) {\n+            for(int j=0; j < manyScalingFactors.length; j++) {\n+                int scaleFactor = manyScalingFactors[j];\n+                if (Math.abs(scaleFactor) >= MAX_SCALE) {\n+                    Float16 value = someTestCases[i];\n+                    failures+=testScalbCase(value,\n+                            scaleFactor,\n+                            copySign( (scaleFactor>0?infinityF16:Float16.valueOf(0)), value) );\n+                }\n+            }\n+        }\n+\n+        \/\/ Test cases that could be done with one floating-point\n+        \/\/ multiply.\n+        for(int i=0; i < someTestCases.length; i++) {\n+            for(int j=0; j < oneMultiplyScalingFactors.length; j++) {\n+                int scaleFactor = oneMultiplyScalingFactors[j];\n+                Float16 value = someTestCases[i];\n+\n+                failures+=testScalbCase(value,\n+                        scaleFactor,\n+                        Float16.multiply(value, powerOfTwoF16(scaleFactor)));\n+            }\n+        }\n+\n+        \/\/ Create 2^MAX_EXPONENT\n+        Float16 twoToTheMaxExp = Float16.valueOf(1); \/\/ 2^0\n+        for(int i = 0; i < Float16.MAX_EXPONENT; i++)\n+            twoToTheMaxExp = Float16.multiply(Float16.valueOf(2), twoToTheMaxExp);\n+\n+        \/\/ Scale-up subnormal values until they all overflow\n+        for(int i=0; i < subnormalTestCases.length; i++) {\n+            Float16 scale = Float16.valueOf(1); \/\/ 2^j\n+            Float16 value = subnormalTestCases[i];\n+\n+            for(int j=Float16.MAX_EXPONENT*2; j < MAX_SCALE; j++) { \/\/ MAX_SCALE -1 should cause overflow\n+                int scaleFactor = j;\n+\n+                failures+=testScalbCase(value,\n+                        scaleFactor,\n+                        (Tests.ilogb(value) +j > Float16.MAX_EXPONENT ) ?\n+                                copySign(infinityF16, value) : \/\/ overflow\n+                                \/\/ calculate right answer\n+                                Float16.multiply(twoToTheMaxExp,\n+                                        Float16.multiply(twoToTheMaxExp,\n+                                                Float16.multiply(scale, value))) );\n+                scale = Float16.multiply(scale, Float16.valueOf(2));\n+            }\n+        }\n+\n+        \/\/ Scale down a large number until it underflows.  By scaling\n+        \/\/ down MAX_NORMALmm, the first subnormal result will be exact\n+        \/\/ but the next one will round -- all those results can be\n+        \/\/ checked by halving a separate value in the loop.  Actually,\n+        \/\/ we can keep halving and checking until the product is zero\n+        \/\/ since:\n+        \/\/\n+        \/\/ 1. If the scalb of MAX_VALUEmm is subnormal and *not* exact\n+        \/\/ it will round *up*\n+        \/\/\n+        \/\/ 2. When rounding first occurs in the expected product, it\n+        \/\/ too rounds up, to 2^-MAX_EXPONENT.\n+        \/\/\n+        \/\/ Halving expected after rounding happends to give the same\n+        \/\/ result as the scalb operation.\n+        Float16 expected = Float16.multiply(Float16_MAX_VALUEmm, Float16.valueOf(0.5f));\n+        for(int i = -1; i > -MAX_SCALE; i--) {\n+            failures+=testScalbCase(Float16_MAX_VALUEmm, i, expected);\n+\n+            expected = Float16.multiply(expected, Float16.valueOf(0.5f));\n+        }\n+\n+        \/\/ Tricky rounding tests:\n+        \/\/ Scale down a large number into subnormal range such that if\n+        \/\/ scalb is being implemented with multiple floating-point\n+        \/\/ multiplies, the value would round twice if the multiplies\n+        \/\/ were done in the wrong order.\n+\n+        Float16 value = Float16.valueOf(0x1.02cP-1);\n+        expected     = Float16.valueOf(0x1.02p-17);\n+        for(int i = 0; i < Float16.MAX_EXPONENT+2; i++) {\n+            failures+=testScalbCase(value,\n+                    -16-i,\n+                    expected);\n+            value = Float16.multiply(value, Float16.valueOf(2));\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -1684,0 +1973,1 @@\n+        failures += testFloat16NextUp();\n@@ -1687,0 +1977,1 @@\n+        failures += testFloat16NextDown();\n@@ -1696,0 +1987,1 @@\n+        failures += testFloat16Scalb();\n","filename":"test\/jdk\/java\/lang\/Math\/IeeeRecommendedTests.java","additions":298,"deletions":6,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -73,0 +73,7 @@\n+    public static String toHexString(Float16 f) {\n+        if (!Float16.isNaN(f))\n+            return Float16.toHexString(f);\n+        else\n+            return \"NaN(0x\" + Integer.toHexString(Float16.float16ToRawShortBits(f) & 0xffff) + \")\";\n+    }\n+\n@@ -235,0 +242,32 @@\n+    \/**\n+     * Returns unbiased exponent of a {@code Float16}; for\n+     * subnormal values, the number is treated as if it were\n+     * normalized.  That is for all finite, non-zero, positive numbers\n+     * <i>x<\/i>, <code>scalb(<i>x<\/i>, -ilogb(<i>x<\/i>))<\/code> is\n+     * always in the range [1, 2).\n+     * <p>\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is 2<sup>30<\/sup>.\n+     * <li> If the argument is infinite, then the result is 2<sup>28<\/sup>.\n+     * <li> If the argument is zero, then the result is -(2<sup>28<\/sup>).\n+     * <\/ul>\n+     *\n+     * @param f floating-point number whose exponent is to be extracted\n+     * @return unbiased exponent of the argument.\n+     *\/\n+    public static int ilogb(Float16 f) {\n+        int bits = Float16.float16ToRawShortBits(f);\n+        int be = (bits & Float16Consts.EXP_BIT_MASK) >>> Float16Consts.SIGNIFICAND_WIDTH - 1;\n+        int t = bits & Float16Consts.SIGNIF_BIT_MASK;\n+        return be == 0  \/\/ zeros or subnormals\n+                ? t != 0\n+                    ? Float16Consts.MIN_SUB_EXPONENT + Integer.SIZE - 1 - Integer.numberOfLeadingZeros(t)  \/\/ subnormals\n+                    : -(1 << 28)  \/\/ zeros\n+                : be < 2 * Float16Consts.EXP_BIAS + 1\n+                ? be - Float16Consts.EXP_BIAS  \/\/ normals\n+                : t == 0\n+                ? 1 << 28   \/\/ infinities\n+                : 1 << 30;  \/\/ NaNs\n+    }\n+\n@@ -364,0 +403,13 @@\n+    public static int test(String testName, Float16 input,\n+            Float16 result, Float16 expected) {\n+        if (Float16.compare(expected, result) != 0 ) {\n+            System.err.println(\"Failure for \" + testName + \":\\n\" +\n+                    \"\\tFor input \" + input    + \"\\t(\" + toHexString(input) + \")\\n\" +\n+                    \"\\texpected  \" + expected + \"\\t(\" + toHexString(expected) + \")\\n\" +\n+                    \"\\tgot       \" + result   + \"\\t(\" + toHexString(result) + \").\");\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n@@ -430,0 +482,15 @@\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public static int test(String testName,\n+            Float16 input1, int input2,\n+            Float16 result, Float16 expected) {\n+        if (Float16.compare(expected, result ) != 0) {\n+            System.err.println(\"Failure for \"  + testName + \":\\n\" +\n+                    \"\\tFor inputs \" + input1   + \"\\t(\" + toHexString(input1) + \") and \"\n+                    + input2   + \"\\n\"  +\n+                    \"\\texpected  \"  + expected + \"\\t(\" + toHexString(expected) + \")\\n\" +\n+                    \"\\tgot       \"  + result   + \"\\t(\" + toHexString(result) + \").\");\n","filename":"test\/jdk\/java\/lang\/Math\/Tests.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"}]}