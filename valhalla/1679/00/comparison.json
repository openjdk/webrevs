{"files":[{"patch":"@@ -345,6 +345,0 @@\n-    if (field_holder != this) {\n-      \/\/ Inherited field, add an empty wrapper to this to distinguish it from a \"local\" field\n-      \/\/ with a different offset and avoid false adapter sharing. TODO 8348547 Is this sufficient?\n-      SigEntry::add_entry(sig, T_METADATA, name(), base_off);\n-      SigEntry::add_entry(sig, T_VOID, name(), offset);\n-    }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -2283,5 +2284,30 @@\n- private:\n-  enum {\n-    _basic_type_bits = 5,\n-    _basic_type_mask = right_n_bits(_basic_type_bits),\n-    _basic_types_per_int = BitsPerInt \/ _basic_type_bits,\n+public:\n+  class Element {\n+  private:\n+    \/\/ The highest byte is the type of the argument. The remaining bytes contain the offset of the\n+    \/\/ field if it is flattened in the calling convention, -1 otherwise.\n+    juint _payload;\n+\n+    static constexpr int offset_bit_width = 24;\n+    static constexpr juint offset_bit_mask = (1 << offset_bit_width) - 1;\n+  public:\n+    Element(BasicType bt, int offset) : _payload((static_cast<juint>(bt) << offset_bit_width) | (juint(offset) & offset_bit_mask)) {\n+      assert(offset >= -1 && offset < jint(offset_bit_mask), \"invalid offset %d\", offset);\n+    }\n+\n+    BasicType bt() const {\n+      return static_cast<BasicType>(_payload >> offset_bit_width);\n+    }\n+\n+    int offset() const {\n+      juint res = _payload & offset_bit_mask;\n+      return res == offset_bit_mask ? -1 : res;\n+    }\n+\n+    juint hash() const {\n+      return _payload;\n+    }\n+\n+    bool operator!=(const Element& other) const {\n+      return _payload != other._payload;\n+    }\n@@ -2289,2 +2315,0 @@\n-  \/\/ TO DO:  Consider integrating this with a more global scheme for compressing signatures.\n-  \/\/ For now, 4 bits per components (plus T_VOID gaps after double\/long) is not excessive.\n@@ -2292,1 +2316,3 @@\n-  int _length;\n+private:\n+  const bool _has_ro_adapter;\n+  const int _length;\n@@ -2295,2 +2321,8 @@\n-  int* data_pointer() {\n-    return (int*)((address)this + data_offset());\n+  Element* data_pointer() {\n+    return reinterpret_cast<Element*>(reinterpret_cast<address>(this) + data_offset());\n+  }\n+\n+  const Element& element_at(int index) {\n+    assert(index < length(), \"index %d out of bounds for length %d\", index, length());\n+    Element* data = data_pointer();\n+    return data[index];\n@@ -2300,6 +2332,3 @@\n-  AdapterFingerPrint(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n-    int* data = data_pointer();\n-    \/\/ Pack the BasicTypes with 8 per int\n-    int total_args_passed = total_args_passed_in_sig(sig);\n-    _length = length(total_args_passed);\n-    int sig_index = 0;\n+  AdapterFingerPrint(const GrowableArray<SigEntry>* sig, bool has_ro_adapter)\n+    : _has_ro_adapter(has_ro_adapter), _length(total_args_passed_in_sig(sig)) {\n+    Element* data = data_pointer();\n@@ -2309,28 +2338,15 @@\n-      int value = 0;\n-      for (int byte = 0; byte < _basic_types_per_int; byte++) {\n-        BasicType bt = T_ILLEGAL;\n-        if (sig_index < total_args_passed) {\n-          bt = sig->at(sig_index++)._bt;\n-          if (bt == T_METADATA) {\n-            \/\/ Found start of inline type in signature\n-            assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n-            if (sig_index == 1 && has_ro_adapter) {\n-              \/\/ With a ro_adapter, replace receiver inline type delimiter by T_VOID to prevent matching\n-              \/\/ with other adapters that have the same inline type as first argument and no receiver.\n-              bt = T_VOID;\n-            }\n-            vt_count++;\n-          } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n-            \/\/ Found end of inline type in signature\n-            assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n-            vt_count--;\n-            assert(vt_count >= 0, \"invalid vt_count\");\n-          } else if (vt_count == 0) {\n-            \/\/ Widen fields that are not part of a scalarized inline type argument\n-            bt = adapter_encoding(bt);\n-          }\n-          prev_bt = bt;\n-        }\n-        int bt_val = (bt == T_ILLEGAL) ? 0 : bt;\n-        assert((bt_val & _basic_type_mask) == bt_val, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt_val;\n+      const SigEntry& sig_entry = sig->at(index);\n+      BasicType bt = sig_entry._bt;\n+      if (bt == T_METADATA) {\n+        \/\/ Found start of inline type in signature\n+        assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+        vt_count++;\n+      } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+        \/\/ Found end of inline type in signature\n+        assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n+        vt_count--;\n+        assert(vt_count >= 0, \"invalid vt_count\");\n+      } else if (vt_count == 0) {\n+        \/\/ Widen fields that are not part of a scalarized inline type argument\n+        assert(sig_entry._offset == -1, \"invalid offset for argument that is not a flattened field %d\", sig_entry._offset);\n+        bt = adapter_encoding(bt);\n@@ -2338,1 +2354,3 @@\n-      data[index] = value;\n+\n+      ::new(&data[index]) Element(bt, sig_entry._offset);\n+      prev_bt = bt;\n@@ -2352,4 +2370,0 @@\n-  static int length(int total_args) {\n-    return (total_args + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n-  }\n-\n@@ -2357,1 +2371,1 @@\n-    return (int)heap_word_size(sizeof(AdapterFingerPrint) + (len * sizeof(int)));\n+    return (int)heap_word_size(sizeof(AdapterFingerPrint) + (len * sizeof(Element)));\n@@ -2406,11 +2420,1 @@\n-      unsigned val = (unsigned)value(i);\n-      \/\/ args are packed so that first\/lower arguments are in the highest\n-      \/\/ bits of each int value, so iterate from highest to the lowest\n-      int first_entry = _basic_types_per_int * _basic_type_bits;\n-      for (int j = first_entry; j >= 0; j -= _basic_type_bits) {\n-        unsigned v = (val >> j) & _basic_type_mask;\n-        if (v == 0) {\n-          continue;\n-        }\n-        function(v);\n-      }\n+      function(element_at(i));\n@@ -2421,2 +2425,1 @@\n-    int total_args_passed = total_args_passed_in_sig(sig);\n-    int len = length(total_args_passed);\n+    int len = total_args_passed_in_sig(sig);\n@@ -2433,3 +2436,2 @@\n-  int value(int index) {\n-    int* data = data_pointer();\n-    return data[index];\n+  bool has_ro_adapter() const {\n+    return _has_ro_adapter;\n@@ -2438,1 +2440,1 @@\n-  int length() {\n+  int length() const {\n@@ -2445,1 +2447,1 @@\n-      int v = value(i);\n+      const Element& v = element_at(i);\n@@ -2447,1 +2449,1 @@\n-      hash = ((hash << 8) ^ v ^ (hash >> 5)) + 3;\n+      hash = ((hash << 8) ^ v.hash() ^ (hash >> 5)) + 3;\n@@ -2454,1 +2456,6 @@\n-    st.print(\"0x\");\n+    st.print(\"{\");\n+    if (_has_ro_adapter) {\n+      st.print(\"has_ro_adapter\");\n+    } else {\n+      st.print(\"no_ro_adapter\");\n+    }\n@@ -2456,1 +2463,3 @@\n-      st.print(\"%x\", value(i));\n+      st.print(\", \");\n+      const Element& elem = element_at(i);\n+      st.print(\"{%s, %d}\", type2name(elem.bt()), elem.offset());\n@@ -2458,0 +2467,1 @@\n+    st.print(\"}\");\n@@ -2464,1 +2474,1 @@\n-    iterate_args([&] (int arg) {\n+    iterate_args([&] (const Element& arg) {\n@@ -2467,1 +2477,1 @@\n-        if (arg == T_VOID) {\n+        if (arg.bt() == T_VOID) {\n@@ -2473,1 +2483,1 @@\n-      if (arg == T_LONG) {\n+      if (arg.bt() == T_LONG) {\n@@ -2475,2 +2485,2 @@\n-      } else if (arg != T_VOID) {\n-        st.print(\"%c\", type2char((BasicType)arg));\n+      } else if (arg.bt() != T_VOID) {\n+        st.print(\"%c\", type2char(arg.bt()));\n@@ -2486,1 +2496,3 @@\n-    if (other->_length != _length) {\n+    if (other->_has_ro_adapter != _has_ro_adapter) {\n+      return false;\n+    } else if (other->_length != _length) {\n@@ -2490,1 +2502,1 @@\n-        if (value(i) != other->value(i)) {\n+        if (element_at(i) != other->element_at(i)) {\n@@ -2997,0 +3009,2 @@\n+  _has_inline_recv = fingerprint->has_ro_adapter();\n+\n@@ -2998,1 +3012,0 @@\n-  bool is_receiver = true;\n@@ -3000,1 +3013,0 @@\n-  bool long_prev = false;\n@@ -3002,0 +3014,6 @@\n+  bool long_prev = false;\n+  int long_prev_offset = -1;\n+\n+  fingerprint->iterate_args([&] (const AdapterFingerPrint::Element& arg) {\n+    BasicType bt = arg.bt();\n+    int offset = arg.offset();\n@@ -3003,2 +3021,0 @@\n-  fingerprint->iterate_args([&] (int arg) {\n-    BasicType bt = (BasicType)arg;\n@@ -3011,1 +3027,1 @@\n-        bt_to_add = T_OBJECT; \/\/ it could be T_ARRAY; it shouldn't matter\n+        bt_to_add = T_OBJECT;\n@@ -3013,2 +3029,0 @@\n-      SigEntry::add_entry(_sig_cc, bt_to_add);\n-      SigEntry::add_entry(_sig_cc_ro, bt_to_add);\n@@ -3018,0 +3032,2 @@\n+      SigEntry::add_entry(_sig_cc, bt_to_add, nullptr, long_prev_offset);\n+      SigEntry::add_entry(_sig_cc_ro, bt_to_add, nullptr, long_prev_offset);\n@@ -3019,0 +3035,1 @@\n+\n@@ -3021,10 +3038,1 @@\n-        if (is_receiver) {\n-          \/\/ 'this' when ro adapter is available\n-          assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n-          value_object_count++;\n-          has_scalarized_arguments = true;\n-          _has_inline_recv = true;\n-          SigEntry::add_entry(_sig, T_OBJECT);\n-          SigEntry::add_entry(_sig_cc, T_METADATA);\n-          SigEntry::add_entry(_sig_cc_ro, T_METADATA);\n-        } else if (prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+        if (prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n@@ -3033,2 +3041,2 @@\n-          SigEntry::add_entry(_sig_cc, T_VOID);\n-          SigEntry::add_entry(_sig_cc_ro, T_VOID);\n+          SigEntry::add_entry(_sig_cc, T_VOID, nullptr, offset);\n+          SigEntry::add_entry(_sig_cc_ro, T_VOID, nullptr, offset);\n@@ -3046,2 +3054,2 @@\n-        SigEntry::add_entry(_sig_cc, bt);\n-        SigEntry::add_entry(_sig_cc_ro, bt);\n+        SigEntry::add_entry(_sig_cc, bt, nullptr, offset);\n+        SigEntry::add_entry(_sig_cc_ro, bt, nullptr, offset);\n@@ -3051,0 +3059,1 @@\n+        long_prev_offset = offset;\n@@ -3058,3 +3067,3 @@\n-        assert(value_object_count > 0 && !is_receiver, \"must be value object field\");\n-        SigEntry::add_entry(_sig_cc, bt);\n-        SigEntry::add_entry(_sig_cc_ro, bt);\n+        assert(value_object_count > 0, \"must be value object field\");\n+        SigEntry::add_entry(_sig_cc, bt, nullptr, offset);\n+        SigEntry::add_entry(_sig_cc_ro, bt, nullptr, offset);\n@@ -3064,0 +3073,5 @@\n+        if (value_object_count == 0) {\n+          SigEntry::add_entry(_sig, T_OBJECT);\n+        }\n+        SigEntry::add_entry(_sig_cc, T_METADATA, nullptr, offset);\n+        SigEntry::add_entry(_sig_cc_ro, T_METADATA, nullptr, offset);\n@@ -3066,3 +3080,0 @@\n-        SigEntry::add_entry(_sig, T_OBJECT);\n-        SigEntry::add_entry(_sig_cc, T_METADATA);\n-        SigEntry::add_entry(_sig_cc_ro, T_METADATA);\n@@ -3075,1 +3086,0 @@\n-    is_receiver = false;\n@@ -3113,1 +3123,1 @@\n-    assert(fingerprint->equals(compare_fp), \"sanity check\");\n+    assert(fingerprint->equals(compare_fp), \"%s - %s\", fingerprint->as_string(), compare_fp->as_string());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":117,"deletions":107,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+\/**\n+ * @test\n+ * @bug 8348547\n+ * @summary Test that adapters are not shared between calls with different shapes\n+ * @requires vm.debug == true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -XX:+VerifyAdapterSharing compiler.valhalla.inlinetypes.TestAdapterSharing\n+ *\/\n+public class TestAdapterSharing {\n+    static abstract value class MyAbstract {\n+        int i;\n+\n+        MyAbstract(int i) {\n+            this.i = i;\n+        }\n+    }\n+    static value class MyValue1 extends MyAbstract {\n+        MyValue1(int i) {\n+            super(i);\n+        }\n+\n+        void test() {}\n+    }\n+\n+    static value class Empty {\n+    }\n+\n+    public static value class MyValue2 {\n+        @NullRestricted\n+        @Strict\n+        Empty e;\n+        int i;\n+\n+        MyValue2(int i) {\n+            this.e = new Empty();\n+            this.i = i;\n+        }\n+\n+        void test() {}\n+    }\n+\n+    public static void main(String[] args) {\n+        MyValue1 v1 = new MyValue1(0);\n+        v1.test();\n+        MyValue2 v2 = new MyValue2(0);\n+        v2.test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAdapterSharing.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}