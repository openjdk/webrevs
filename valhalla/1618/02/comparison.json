{"files":[{"patch":"@@ -99,1 +99,1 @@\n-\/\/ JimageFile pointer, or null if exploded JDK build.\n+\/\/ JImageFile pointer, or null if exploded JDK build.\n@@ -102,0 +102,9 @@\n+\/\/ JImageMode status to control preview behaviour. JImage_file is unusable\n+\/\/ for normal lookup until (JImage_mode != JIMAGE_MODE_UNINITIALIZED).\n+enum JImageMode {\n+  JIMAGE_MODE_UNINITIALIZED = 0,\n+  JIMAGE_MODE_DEFAULT = 1,\n+  JIMAGE_MODE_ENABLE_PREVIEW = 2\n+};\n+static JImageMode                      JImage_mode            = JIMAGE_MODE_UNINITIALIZED;\n+\n@@ -156,1 +165,1 @@\n-ClassPathEntry* ClassLoader::_jrt_entry = nullptr;\n+ClassPathImageEntry* ClassLoader::_jrt_entry = nullptr;\n@@ -173,9 +182,0 @@\n-static const char* get_jimage_version_string() {\n-  static char version_string[10] = \"\";\n-  if (version_string[0] == '\\0') {\n-    jio_snprintf(version_string, sizeof(version_string), \"%d.%d\",\n-                 VM_Version::vm_major_version(), VM_Version::vm_minor_version());\n-  }\n-  return (const char*)version_string;\n-}\n-\n@@ -236,0 +236,67 @@\n+\/\/ --------------------------------\n+\/\/ The following jimage_xxx static functions encapsulate all JImage_file and JImage_mode access.\n+\/\/ This is done to make it easy to reason about the JImage file state (exists vs initialized etc.).\n+\n+\/\/ Opens the named JImage file and sets the JImage file reference.\n+\/\/ Returns true if opening the JImage file was successful (see also jimage_exists()).\n+static bool jimage_open(const char* modules_path) {\n+  \/\/ Currently 'error' is not set to anything useful, so ignore it here.\n+  jint error;\n+  JImage_file = (*JImageOpen)(modules_path, &error);\n+  return JImage_file != nullptr;\n+}\n+\n+\/\/ Closes and clears the JImage file reference (this will only be called during shutdown).\n+static void jimage_close() {\n+  if (JImage_file != nullptr) {\n+    (*JImageClose)(JImage_file);\n+    JImage_file = nullptr;\n+  }\n+}\n+\n+\/\/ Returns whether a JImage file was opened (but NOT whether it was initialized yet).\n+static bool jimage_exists() {\n+  return JImage_file != nullptr;\n+}\n+\n+\/\/ Returns the JImage file reference (which may or may not be initialized).\n+static JImageFile* jimage_non_null() {\n+  assert(jimage_exists(), \"should have been opened by ClassLoader::lookup_vm_options \"\n+                          \"and remained throughout normal JVM lifetime\");\n+  return JImage_file;\n+}\n+\n+\/\/ Called once to set the access mode for resource (i.e. preview or non-preview) before\n+\/\/ general resource lookup can occur.\n+static void jimage_init(bool enable_preview) {\n+  assert(JImage_mode == JIMAGE_MODE_UNINITIALIZED, \"jimage_init must not be called twice\");\n+  JImage_mode = enable_preview ? JIMAGE_MODE_ENABLE_PREVIEW : JIMAGE_MODE_DEFAULT;\n+}\n+\n+\/\/ Returns true if jimage_init() has been called. Once the JImage file is initialized,\n+\/\/ jimage_is_preview_enabled() can be called to correctly determine the access mode.\n+static bool jimage_is_initialized() {\n+  return jimage_exists() && JImage_mode != JIMAGE_MODE_UNINITIALIZED;\n+}\n+\n+\/\/ Returns the access mode for an initialized JImage file (reflects --enable-preview).\n+static bool jimage_is_preview_enabled() {\n+  assert(jimage_is_initialized(), \"jimage is not initialized\");\n+  return JImage_mode == JIMAGE_MODE_ENABLE_PREVIEW;\n+}\n+\n+\/\/ Looks up the location of a named JImage resource. This \"raw\" lookup function allows\n+\/\/ the preview mode to be manually specified, so must not be accessible outside this\n+\/\/ class. ClassPathImageEntry manages all calls for resources after startup is complete.\n+static JImageLocationRef jimage_find_resource(const char* module_name,\n+                                              const char* file_name,\n+                                              bool is_preview,\n+                                              jlong *size) {\n+  return ((*JImageFindResource)(jimage_non_null(),\n+                                module_name,\n+                                file_name,\n+                                is_preview,\n+                                size));\n+}\n+\/\/ --------------------------------\n+\n@@ -374,11 +441,0 @@\n-JImageFile* ClassPathImageEntry::jimage() const {\n-  return JImage_file;\n-}\n-\n-JImageFile* ClassPathImageEntry::jimage_non_null() const {\n-  assert(ClassLoader::has_jrt_entry(), \"must be\");\n-  assert(jimage() != nullptr, \"should have been opened by ClassLoader::lookup_vm_options \"\n-                           \"and remained throughout normal JVM lifetime\");\n-  return jimage();\n-}\n-\n@@ -386,4 +442,1 @@\n-  if (jimage() != nullptr) {\n-    (*JImageClose)(jimage());\n-    JImage_file = nullptr;\n-  }\n+  jimage_close();\n@@ -392,1 +445,1 @@\n-ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :\n+ClassPathImageEntry::ClassPathImageEntry(const char* name) :\n@@ -394,1 +447,1 @@\n-  guarantee(jimage != nullptr, \"jimage file is null\");\n+  guarantee(jimage_is_initialized(), \"jimage is not initialized\");\n@@ -396,0 +449,1 @@\n+\n@@ -414,0 +468,2 @@\n+  bool is_preview = jimage_is_preview_enabled();\n+\n@@ -415,1 +471,1 @@\n-  JImageLocationRef location = (*JImageFindResource)(jimage_non_null(), \"\", get_jimage_version_string(), name, &size);\n+  JImageLocationRef location = jimage_find_resource(\"\", name, is_preview, &size);\n@@ -423,1 +479,1 @@\n-        location = (*JImageFindResource)(jimage_non_null(), JAVA_BASE_NAME, get_jimage_version_string(), name, &size);\n+        location = jimage_find_resource(JAVA_BASE_NAME, name, is_preview, &size);\n@@ -434,1 +490,1 @@\n-            location = (*JImageFindResource)(jimage_non_null(), module_name, get_jimage_version_string(), name, &size);\n+            location = jimage_find_resource(module_name, name, is_preview, &size);\n@@ -447,1 +503,1 @@\n-    assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), \"must be\");\n+    assert(this == ClassLoader::get_jrt_entry(), \"must be\");\n@@ -457,7 +513,0 @@\n-JImageLocationRef ClassLoader::jimage_find_resource(JImageFile* jf,\n-                                                    const char* module_name,\n-                                                    const char* file_name,\n-                                                    jlong &size) {\n-  return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &size));\n-}\n-\n@@ -466,1 +515,1 @@\n-  assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), \"must be used for jrt entry\");\n+  assert(this == ClassLoader::get_jrt_entry(), \"must be used for jrt entry\");\n@@ -621,1 +670,1 @@\n-        if (JImage_file != nullptr) {\n+        if (jimage_exists()) {\n@@ -626,1 +675,3 @@\n-          _jrt_entry = new ClassPathImageEntry(JImage_file, canonical_path);\n+          \/\/ Hand over lifecycle control of the JImage file to the _jrt_entry singleton\n+          \/\/ (see ClassPathImageEntry::close_jimage). The image must be initialized by now.\n+          _jrt_entry = new ClassPathImageEntry(canonical_path);\n@@ -628,1 +679,0 @@\n-          assert(_jrt_entry->jimage() != nullptr, \"No java runtime image\");\n@@ -1442,11 +1492,0 @@\n-static char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {\n-  jlong size;\n-  JImageLocationRef location = (*JImageFindResource)(jimage, \"java.base\", jimage_version, path, &size);\n-  if (location == 0)\n-    return nullptr;\n-  char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);\n-  (*JImageGetResource)(jimage, location, val, size);\n-  val[size] = '\\0';\n-  return val;\n-}\n-\n@@ -1455,1 +1494,0 @@\n-  jint error;\n@@ -1463,3 +1501,13 @@\n-  JImage_file =(*JImageOpen)(modules_path, &error);\n-  if (JImage_file == nullptr) {\n-    return nullptr;\n+  if (jimage_open(modules_path)) {\n+    \/\/ Special case where we lookup the options string *before* calling jimage_init().\n+    \/\/ Since VM arguments have not been parsed, and the ClassPathImageEntry singleton\n+    \/\/ has not been created yet, we access the JImage file directly in non-preview mode.\n+    jlong size;\n+    JImageLocationRef location =\n+            jimage_find_resource(JAVA_BASE_NAME, \"jdk\/internal\/vm\/options\", \/* is_preview *\/ false, &size);\n+    if (location != 0) {\n+      char *options = NEW_C_HEAP_ARRAY(char, size+1, mtClass);\n+      (*JImageGetResource)(jimage_non_null(), location, options, size);\n+      options[size] = '\\0';\n+      return options;\n+    }\n@@ -1467,0 +1515,2 @@\n+  return nullptr;\n+}\n@@ -1468,3 +1518,5 @@\n-  const char *jimage_version = get_jimage_version_string();\n-  char *options = lookup_vm_resource(JImage_file, jimage_version, \"jdk\/internal\/vm\/options\");\n-  return options;\n+\/\/ Finishes initializing the JImageFile (if present) by setting the access mode.\n+void ClassLoader::init_jimage(bool enable_preview) {\n+  if (jimage_exists()) {\n+    jimage_init(enable_preview);\n+  }\n@@ -1475,1 +1527,1 @@\n-  if (JImage_file == nullptr) {\n+  if (!jimage_exists()) {\n@@ -1482,0 +1534,1 @@\n+  \/\/ We don't expect preview mode (i.e. --enable-preview) to affect module visibility.\n@@ -1483,2 +1536,1 @@\n-  const char *jimage_version = get_jimage_version_string();\n-  return (*JImageFindResource)(JImage_file, module_name, jimage_version, \"module-info.class\", &size) != 0;\n+  return jimage_find_resource(module_name, \"module-info.class\", \/* is_preview *\/ false, &size) != 0;\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":116,"deletions":64,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -102,1 +102,2 @@\n-\/\/ For java image files\n+\/\/ A singleton path entry which takes ownership of the initialized JImageFile\n+\/\/ reference. Not used for exploded builds.\n@@ -110,2 +111,1 @@\n-  JImageFile* jimage() const;\n-  JImageFile* jimage_non_null() const;\n+  \/\/ Called to close the JImage during os::abort (normally not called).\n@@ -113,1 +113,2 @@\n-  ClassPathImageEntry(JImageFile* jimage, const char* name);\n+  \/\/ Takes effective ownership of the static JImageFile pointer.\n+  ClassPathImageEntry(const char* name);\n@@ -115,0 +116,1 @@\n+\n@@ -203,1 +205,1 @@\n-  \/\/    Contains the ClassPathEntry of the modular java runtime image.\n+  \/\/    Contains the ClassPathImageEntry of the modular java runtime image.\n@@ -206,1 +208,1 @@\n-  static ClassPathEntry* _jrt_entry;\n+  static ClassPathImageEntry* _jrt_entry;\n@@ -353,0 +355,3 @@\n+  \/\/ Retrieves additional VM options prior to flags processing. Options held\n+  \/\/ in the JImage file are retrieved without fully initializing it. (this is\n+  \/\/ the only JImage lookup which can succeed before init_jimage() is called).\n@@ -355,0 +360,5 @@\n+  \/\/ Called once, after all flags are processed, to finish initializing the\n+  \/\/ JImage file. Until this is called, jimage_find_resource(), and any other\n+  \/\/ JImage resource lookups or access will fail.\n+  static void init_jimage(bool enable_preview);\n+\n@@ -359,3 +369,0 @@\n-  static JImageLocationRef jimage_find_resource(JImageFile* jf, const char* module_name,\n-                                                const char* file_name, jlong &size);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2082,0 +2082,12 @@\n+\/\/ Temporary system property to disable preview patching and enable the new preview mode\n+\/\/ feature for testing\/development. Once the preview mode feature is finished, the value\n+\/\/ will be always 'true' and this code, and all related dead-code can be removed.\n+#define DISABLE_PREVIEW_PATCHING_DEFAULT false\n+\n+bool Arguments::disable_preview_patching() {\n+  const char* prop = get_property(\"DISABLE_PREVIEW_PATCHING\");\n+  return (prop != nullptr)\n+      ? strncmp(prop, \"true\", strlen(\"true\")) == 0\n+      : DISABLE_PREVIEW_PATCHING_DEFAULT;\n+}\n+\n@@ -2089,2 +2101,8 @@\n-  \/\/ If --enable-preview and EnableValhalla is true, each module may have value classes that\n-  \/\/ are to be patched into the module.\n+  \/\/ If --enable-preview and EnableValhalla is true, modules may have preview mode resources.\n+  bool enable_valhalla_preview = enable_preview() && EnableValhalla;\n+  \/\/ Whether to use module patching, or the new preview mode feature for preview resources.\n+  bool disable_patching = disable_preview_patching();\n+\n+  \/\/ This must be called, even with 'false', to enable resource lookup from JImage.\n+  ClassLoader::init_jimage(disable_patching && enable_valhalla_preview);\n+\n@@ -2093,1 +2111,1 @@\n-  if (enable_preview() && EnableValhalla) {\n+  if (!disable_patching && enable_valhalla_preview) {\n@@ -2126,1 +2144,1 @@\n-  \/\/ by --patch-module or --enable-preview\n+  \/\/ by --patch-module (or --enable-preview if disable_patching is false).\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -489,0 +489,2 @@\n+  static bool disable_preview_patching();\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -322,1 +322,6 @@\n-        _header.minor_version(_endian) != MINOR_VERSION) {\n+        \/\/ Temporarily, we allow either version (1.1 or 1.0) of the file to\n+        \/\/ be read so this code can be committed before image writing changes\n+        \/\/ for preview mode. Preview mode changes do not modify any structure,\n+        \/\/ so a 1.0 file will look like a jimage without any preview resources.\n+        \/\/ TODO: Restore equality check for MINOR_VERSION.\n+        _header.minor_version(_endian) > MINOR_VERSION) {\n@@ -407,1 +412,1 @@\n-                return offset;\n+            return offset;\n@@ -438,1 +443,1 @@\n-    \/\/ Compare with basne name.\n+    \/\/ Compare with base name.\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -235,0 +235,1 @@\n+    \/\/ See also src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageLocation.java\n@@ -240,1 +241,1 @@\n-        ATTRIBUTE_EXTENSION,        \/\/ String table offset of resource path extension\n+        ATTRIBUTE_EXTENSION,            \/\/ String table offset of resource path extension\n@@ -242,2 +243,3 @@\n-        ATTRIBUTE_COMPRESSED,       \/\/ In image byte size of the compressed resource\n-        ATTRIBUTE_UNCOMPRESSED, \/\/ In memory byte size of the uncompressed resource\n+        ATTRIBUTE_COMPRESSED,           \/\/ In-image byte size of the compressed resource\n+        ATTRIBUTE_UNCOMPRESSED,         \/\/ In-memory byte size of the uncompressed resource\n+        ATTRIBUTE_PREVIEW_FLAGS,        \/\/ Flags relating to preview mode resources.\n@@ -247,0 +249,14 @@\n+    \/\/ Flag masks for the ATTRIBUTE_PREVIEW_FLAGS attribute. Defined so\n+    \/\/ that zero is the overwhelmingly common case for normal resources.\n+    \/\/ See also src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageLocation.java\n+    enum {\n+        \/\/ Set on a \"normal\" (non-preview) location if a preview version of\n+        \/\/ it exists in the same module.\n+        FLAGS_HAS_PREVIEW_VERSION = 0x1,\n+        \/\/ Set on all preview locations in \"\/modules\/xxx\/META-INF\/preview\/...\"\n+        FLAGS_IS_PREVIEW_VERSION = 0x2,\n+        \/\/ Set on a preview location if no normal (non-preview) version of\n+        \/\/ it exists in the same module.\n+        FLAGS_IS_PREVIEW_ONLY = 0x4\n+    };\n+\n@@ -303,0 +319,5 @@\n+\n+    \/\/ Retrieve flags from the ATTRIBUTE_PREVIEW_FLAGS attribute.\n+    inline u4 get_preview_flags() const {\n+        return (u4) get_attribute(ATTRIBUTE_PREVIEW_FLAGS);\n+    }\n@@ -397,0 +418,1 @@\n+friend class PackageFlags;\n@@ -436,1 +458,1 @@\n-        MINOR_VERSION = 0\n+        MINOR_VERSION = 1\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n- * The version number should be \"9.0\" and is not used in locating the resource.\n@@ -101,1 +100,1 @@\n- *                                 \"java.base\", \"9.0\", \"java\/lang\/String.class\", &size);\n+ *           \"java.base\", \"java\/lang\/String.class\", is_preview_mode, &size);\n@@ -105,1 +104,1 @@\n-        const char* module_name, const char* version, const char* name,\n+        const char* module_name, const char* name, bool is_preview_mode,\n@@ -107,0 +106,22 @@\n+    static const char str_modules[] = \"modules\";\n+    static const char str_packages[] = \"packages\";\n+    static const char preview_infix[] = \"\/META-INF\/preview\";\n+\n+    size_t module_name_len = strlen(module_name);\n+    size_t name_len = strlen(name);\n+    size_t preview_infix_len = strlen(preview_infix);\n+\n+    \/\/ TBD:   assert(module_name_len > 0, \"module name must be non-empty\");\n+    assert(name_len > 0, \"resource name must be non-empty\");\n+\n+    \/\/ Do not attempt to lookup anything of the form \/modules\/... or \/packages\/...\n+    if (strncmp(module_name, str_modules, sizeof(str_modules)) == 0\n+            || strncmp(module_name, str_packages, sizeof(str_packages)) == 0) {\n+        return 0L;\n+    }\n+    \/\/ If the preview mode version of the path string is too long for the buffer,\n+    \/\/ return not found (even when not in preview mode).\n+    if (1 + module_name_len + preview_infix_len + 1 + name_len + 1 > IMAGE_MAX_PATH) {\n+        return 0L;\n+    }\n+\n@@ -108,4 +129,15 @@\n-    char fullpath[IMAGE_MAX_PATH];\n-    size_t moduleNameLen = strlen(module_name);\n-    size_t nameLen = strlen(name);\n-    size_t index;\n+    char name_buffer[IMAGE_MAX_PATH];\n+    char* path;\n+    {   \/\/ Write the buffer with room to prepend the preview mode infix\n+        \/\/ at the start (saves copying the trailing name part twice).\n+        size_t index = preview_infix_len;\n+        name_buffer[index++] = '\/';\n+        memcpy(&name_buffer[index], module_name, module_name_len);\n+        index += module_name_len;\n+        name_buffer[index++] = '\/';\n+        memcpy(&name_buffer[index], name, name_len);\n+        index += name_len;\n+        name_buffer[index++] = '\\0';\n+        \/\/ Path begins at the leading '\/' (not the start of the buffer).\n+        path = &name_buffer[preview_infix_len];\n+    }\n@@ -113,2 +145,6 @@\n-    \/\/ TBD:   assert(moduleNameLen > 0 && \"module name must be non-empty\");\n-    assert(nameLen > 0 && \"name must non-empty\");\n+    \/\/ find_location_index() returns the data \"offset\", not an index.\n+    const ImageFileReader* image_file = (ImageFileReader*) image;\n+    u4 locOffset = image_file->find_location_index(path, (u8*) size);\n+    if (locOffset != 0) {\n+        ImageLocation loc;\n+        loc.set_data(image_file->get_location_offset_data(locOffset));\n@@ -116,2 +152,17 @@\n-    \/\/ If the concatenated string is too long for the buffer, return not found\n-    if (1 + moduleNameLen + 1 + nameLen + 1 > IMAGE_MAX_PATH) {\n+        u4 flags = loc.get_preview_flags();\n+        \/\/ No preview flags means \"a normal resource, without a preview version\".\n+        \/\/ This is the overwhelmingly common case, with or without preview mode.\n+        if (flags == 0) {\n+            return locOffset;\n+        }\n+        \/\/ Regardless of preview mode, don't return resources requested directly\n+        \/\/ via their preview path.\n+        if ((flags & ImageLocation::FLAGS_IS_PREVIEW_VERSION) != 0) {\n+            return 0L;\n+        }\n+        \/\/ Even if there is a preview version, we might not want to return it.\n+        if (!is_preview_mode || (flags & ImageLocation::FLAGS_HAS_PREVIEW_VERSION) == 0) {\n+            return locOffset;\n+        }\n+    } else if (!is_preview_mode) {\n+        \/\/ No normal resource found, and not in preview mode.\n@@ -121,12 +172,23 @@\n-    index = 0;\n-    fullpath[index++] = '\/';\n-    memcpy(&fullpath[index], module_name, moduleNameLen);\n-    index += moduleNameLen;\n-    fullpath[index++] = '\/';\n-    memcpy(&fullpath[index], name, nameLen);\n-    index += nameLen;\n-    fullpath[index++] = '\\0';\n-\n-    JImageLocationRef loc =\n-            (JImageLocationRef) ((ImageFileReader*) image)->find_location_index(fullpath, (u8*) size);\n-    return loc;\n+    \/\/ We are in preview mode, and the preview version of the resource is needed.\n+    \/\/ This is either because:\n+    \/\/ 1. The normal resource was flagged as having a preview version (rare)\n+    \/\/ 2. This is a preview-only resource (there was no normal resource, very rare)\n+    \/\/ 3. The requested resource doesn't exist (this should typically not happen)\n+    \/\/\n+    \/\/ Since we only expect requests for resources which exist in jimage files, we\n+    \/\/ expect this 2nd lookup to succeed (this is contrary to the expectations for\n+    \/\/ the JRT file system, where non-existent resource lookups are common).\n+\n+    {   \/\/ Rewrite the front of the name buffer to make it a preview path.\n+        size_t index = 0;\n+        name_buffer[index++] = '\/';\n+        memcpy(&name_buffer[index], module_name, module_name_len);\n+        index += module_name_len;\n+        memcpy(&name_buffer[index], preview_infix, preview_infix_len);\n+        index += preview_infix_len;\n+        \/\/ Check we copied up to the expected '\/' separator.\n+        assert(name_buffer[index] == '\/', \"bad string concatenation\");\n+        \/\/ The preview path now begins at the start of the buffer.\n+        path = &name_buffer[0];\n+    }\n+    return image_file->find_location_index(path, (u8*) size);\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":85,"deletions":23,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n- * The version number should be \"9.0\" and is not used in locating the resource.\n@@ -108,1 +107,1 @@\n- *                                \"java.base\", \"9.0\", \"java\/lang\/String.class\", &size);\n+ *           \"java.base\", \"java\/lang\/String.class\", is_preview_mode, &size);\n@@ -111,1 +110,1 @@\n-        const char* module_name, const char* version, const char* name,\n+        const char* module_name, const char* name, bool is_preview_mode,\n@@ -115,1 +114,1 @@\n-        const char* module_name, const char* version, const char* name,\n+        const char* module_name, const char* name, bool is_preview_mode,\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}