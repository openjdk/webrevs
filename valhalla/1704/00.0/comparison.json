{"files":[{"patch":"@@ -390,2 +390,2 @@\n-    common.boot_jdk_version = \"24\";\n-    common.boot_jdk_build_number = \"36\";\n+    common.boot_jdk_version = \"25\";\n+    common.boot_jdk_build_number = \"37\";\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"24 25 26\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"25 26\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1269,2 +1269,2 @@\n-    _ANY_REG32_mask = _ALL_REG32_mask;\n-    _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp->as_VMReg()));\n+    _ANY_REG32_mask.assignFrom(_ALL_REG32_mask);\n+    _ANY_REG32_mask.remove(OptoReg::as_OptoReg(r31_sp->as_VMReg()));\n@@ -1272,1 +1272,1 @@\n-    _ANY_REG_mask = _ALL_REG_mask;\n+    _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n@@ -1274,1 +1274,1 @@\n-    _PTR_REG_mask = _ALL_REG_mask;\n+    _PTR_REG_mask.assignFrom(_ALL_REG_mask);\n@@ -1276,2 +1276,2 @@\n-    _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;\n-    _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);\n+    _NO_SPECIAL_REG32_mask.assignFrom(_ALL_REG32_mask);\n+    _NO_SPECIAL_REG32_mask.subtract(_NON_ALLOCATABLE_REG32_mask);\n@@ -1279,2 +1279,2 @@\n-    _NO_SPECIAL_REG_mask = _ALL_REG_mask;\n-    _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n+    _NO_SPECIAL_REG_mask.assignFrom(_ALL_REG_mask);\n+    _NO_SPECIAL_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n@@ -1282,2 +1282,2 @@\n-    _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;\n-    _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n+    _NO_SPECIAL_PTR_REG_mask.assignFrom(_ALL_REG_mask);\n+    _NO_SPECIAL_PTR_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n@@ -1288,3 +1288,3 @@\n-      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n-      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n-      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n@@ -1295,3 +1295,3 @@\n-      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n-      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n-      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -1300,2 +1300,2 @@\n-    _NO_SPECIAL_NO_RFP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n-    _NO_SPECIAL_NO_RFP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask.assignFrom(_NO_SPECIAL_PTR_REG_mask);\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -1740,1 +1740,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n@@ -2514,1 +2514,1 @@\n-  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ (_NO_SPECIAL_REG32_mask.size() minus 1) forces CallNode to become\n@@ -2517,1 +2517,1 @@\n-  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.size() - 1;\n@@ -2532,1 +2532,1 @@\n-  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.size() : FLOATPRESSURE;\n@@ -2539,1 +2539,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -2541,1 +2541,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2545,1 +2545,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -2547,1 +2547,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2551,1 +2551,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -2553,1 +2553,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2557,1 +2557,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n@@ -2559,1 +2559,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2227,1 +2227,1 @@\n-\/\/ Preserves: src, mask\n+\/\/ Preserves: mask, vzr\n@@ -2229,2 +2229,2 @@\n-                                           FloatRegister vtmp1, FloatRegister vtmp2,\n-                                           PRegister pgtmp) {\n+                                           FloatRegister vzr, FloatRegister vtmp,\n+                                           PRegister pgtmp, unsigned vector_length_in_bytes) {\n@@ -2232,1 +2232,3 @@\n-  assert_different_registers(dst, src, vtmp1, vtmp2);\n+  \/\/ When called by sve_compress_byte, src and vtmp may be the same register.\n+  assert_different_registers(dst, src, vzr);\n+  assert_different_registers(dst, vtmp, vzr);\n@@ -2234,5 +2236,4 @@\n-\n-  \/\/ Example input:   src   = 8888 7777 6666 5555 4444 3333 2222 1111\n-  \/\/                  mask  = 0001 0000 0000 0001 0001 0000 0001 0001\n-  \/\/ Expected result: dst   = 0000 0000 0000 8888 5555 4444 2222 1111\n-  sve_dup(vtmp2, H, 0);\n+  \/\/ high <-- low\n+  \/\/ Example input:   src   = hh gg ff ee dd cc bb aa, one character is 8 bits.\n+  \/\/                  mask  = 01 00 00 01 01 00 01 01, one character is 1 bit.\n+  \/\/ Expected result: dst   = 00 00 00 hh ee dd bb aa\n@@ -2241,1 +2242,1 @@\n-  \/\/ dst = 00004444 00003333 00002222 00001111\n+  \/\/ dst   =  00dd  00cc  00bb  00aa\n@@ -2243,1 +2244,1 @@\n-  \/\/ pgtmp = 00000001 00000000 00000001 00000001\n+  \/\/ pgtmp =  0001  0000  0001  0001\n@@ -2247,1 +2248,1 @@\n-  \/\/ dst = 00000000 00004444 00002222 00001111\n+  \/\/ dst   =  0000  00dd  00bb  00aa\n@@ -2250,2 +2251,9 @@\n-  \/\/ dst = 0000 0000 0000 0000 0000 4444 2222 1111\n-  sve_uzp1(dst, H, dst, vtmp2);\n+  \/\/ dst   = 00 00 00 00 00 dd bb aa\n+  sve_uzp1(dst, H, dst, vzr);\n+\n+  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n+  \/\/ highest half is invalid.\n+  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n+    return;\n+  }\n+\n@@ -2257,1 +2265,1 @@\n-  \/\/ pgtmp = 00000001 00000000 00000000 00000001\n+  \/\/ pgtmp =  0001  0000  0000  0001\n@@ -2259,20 +2267,14 @@\n-  \/\/ vtmp1 = 00008888 00007777 00006666 00005555\n-  sve_uunpkhi(vtmp1, S, src);\n-  \/\/ vtmp1 = 00000000 00000000 00008888 00005555\n-  sve_compact(vtmp1, S, vtmp1, pgtmp);\n-  \/\/ vtmp1 = 0000 0000 0000 0000 0000 0000 8888 5555\n-  sve_uzp1(vtmp1, H, vtmp1, vtmp2);\n-\n-  \/\/ Compressed low:   dst   = 0000 0000 0000 0000 0000 4444 2222 1111\n-  \/\/ Compressed high:  vtmp1 = 0000 0000 0000 0000 0000 0000 8888  5555\n-  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n-  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n-  neg(rscratch1, rscratch1);\n-  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n-  sve_index(vtmp2, H, rscratch1, 1);\n-  \/\/ vtmp1 = 0000 0000 0000 8888 5555 0000 0000 0000\n-  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n-\n-  \/\/ Combine the compressed high(after shifted) with the compressed low.\n-  \/\/ dst = 0000 0000 0000 8888 5555 4444 2222 1111\n-  sve_orr(dst, dst, vtmp1);\n+  \/\/ vtmp  =  00hh  00gg  00ff  00ee\n+  sve_uunpkhi(vtmp, S, src);\n+  \/\/ vtmp  =  0000  0000  00hh  00ee\n+  sve_compact(vtmp, S, vtmp, pgtmp);\n+  \/\/ vtmp  = 00 00 00 00 00 00 hh ee\n+  sve_uzp1(vtmp, H, vtmp, vzr);\n+\n+  \/\/ pgtmp = 00 00 00 00 00 01 01 01\n+  sve_whilelt(pgtmp, H, zr, rscratch1);\n+  \/\/ Compressed low:  dst  = 00 00 00 00 00 dd bb aa\n+  \/\/ Compressed high: vtmp = 00 00 00 00 00 00 hh ee\n+  \/\/ Combine the compressed low with the compressed high:\n+  \/\/                  dst  = 00 00 00 hh ee dd bb aa\n+  sve_splice(dst, H, pgtmp, vtmp);\n@@ -2284,3 +2286,2 @@\n-                                          FloatRegister vtmp1, FloatRegister vtmp2,\n-                                          FloatRegister vtmp3, FloatRegister vtmp4,\n-                                          PRegister ptmp, PRegister pgtmp) {\n+                                          FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+                                          PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes) {\n@@ -2288,1 +2289,1 @@\n-  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3, vtmp4);\n+  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3);\n@@ -2290,3 +2291,6 @@\n-  \/\/ Example input:   src   = 88 77 66 55 44 33 22 11\n-  \/\/                  mask  = 01 00 00 01 01 00 01 01\n-  \/\/ Expected result: dst   = 00 00 00 88 55 44 22 11\n+  \/\/ high <-- low\n+  \/\/ Example input:   src   = q p n m l k j i h g f e d c b a, one character is 8 bits.\n+  \/\/                  mask  = 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 1, one character is 1 bit.\n+  \/\/ Expected result: dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n+  FloatRegister vzr = vtmp3;\n+  sve_dup(vzr, B, 0);\n@@ -2294,2 +2298,1 @@\n-  sve_dup(vtmp4, B, 0);\n-  \/\/ vtmp1 = 0044 0033 0022 0011\n+  \/\/ vtmp1 =  0h  0g  0f  0e  0d  0c  0b  0a\n@@ -2298,1 +2301,1 @@\n-  \/\/ ptmp = 0001 0000 0001 0001\n+  \/\/ ptmp  =  00  01  00  00  00  01  00  01\n@@ -2300,3 +2303,0 @@\n-  \/\/ Count the active elements of lowest half.\n-  \/\/ rscratch2 = 3\n-  sve_cntp(rscratch2, H, ptrue, ptmp);\n@@ -2305,2 +2305,3 @@\n-  \/\/ dst = 0000 0044 0022 0011\n-  sve_compress_short(dst, vtmp1, ptmp, vtmp2, vtmp3, pgtmp);\n+  \/\/ dst   =  00  00  00  00  00  0g  0c  0a\n+  unsigned extended_size = vector_length_in_bytes << 1;\n+  sve_compress_short(dst, vtmp1, ptmp, vzr, vtmp2, pgtmp, extended_size > MaxVectorSize ? MaxVectorSize : extended_size);\n@@ -2308,2 +2309,11 @@\n-  \/\/ dst = 00 00 00 00 00 44 22 11\n-  sve_uzp1(dst, B, dst, vtmp4);\n+  \/\/ dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n+  sve_uzp1(dst, B, dst, vzr);\n+\n+  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n+  \/\/ highest half is invalid.\n+  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n+    return;\n+  }\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch2 = 3\n+  sve_cntp(rscratch2, H, ptrue, ptmp);\n@@ -2312,1 +2322,1 @@\n-  \/\/ ptmp = 0001 0000 0000 0001\n+  \/\/ ptmp  =  00  01  00  00  00  00  00  01\n@@ -2314,1 +2324,1 @@\n-  \/\/ vtmp1 = 0088 0077 0066 0055\n+  \/\/ vtmp2 =  0q  0p  0n  0m  0l  0k  0j  0i\n@@ -2316,19 +2326,12 @@\n-  \/\/ vtmp1 = 0000 0000 0088 0055\n-  sve_compress_short(vtmp1, vtmp2, ptmp, vtmp3, vtmp4, pgtmp);\n-\n-  sve_dup(vtmp4, B, 0);\n-  \/\/ vtmp1 = 00 00 00 00 00 00 88 55\n-  sve_uzp1(vtmp1, B, vtmp1, vtmp4);\n-\n-  \/\/ Compressed low:   dst   = 00 00 00 00 00 44 22 11\n-  \/\/ Compressed high:  vtmp1 = 00 00 00 00 00 00 88 55\n-  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n-  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n-  neg(rscratch2, rscratch2);\n-  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n-  sve_index(vtmp2, B, rscratch2, 1);\n-  \/\/ vtmp1 = 00 00 00 88 55 00 00 00\n-  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n-  \/\/ Combine the compressed high(after shifted) with the compressed low.\n-  \/\/ dst = 00 00 00 88 55 44 22 11\n-  sve_orr(dst, dst, vtmp1);\n+  \/\/ vtmp1 =  00  00  00  00  00  00  0p  0i\n+  sve_compress_short(vtmp1, vtmp2, ptmp, vzr, vtmp2, pgtmp, extended_size - MaxVectorSize);\n+  \/\/ vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n+  sve_uzp1(vtmp1, B, vtmp1, vzr);\n+\n+  \/\/ ptmp  = 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1\n+  sve_whilelt(ptmp, B, zr, rscratch2);\n+  \/\/ Compressed low:  dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n+  \/\/ Compressed high: vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n+  \/\/ Combine the compressed low with the compressed high:\n+  \/\/                  dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n+  sve_splice(dst, B, ptmp, vtmp1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":76,"deletions":73,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -178,3 +178,2 @@\n-                         FloatRegister vtmp1, FloatRegister vtmp2,\n-                         FloatRegister vtmp3, FloatRegister vtmp4,\n-                         PRegister ptmp, PRegister pgtmp);\n+                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+                         PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes);\n@@ -183,2 +182,2 @@\n-                          FloatRegister vtmp1, FloatRegister vtmp2,\n-                          PRegister pgtmp);\n+                          FloatRegister vzr, FloatRegister vtmp,\n+                          PRegister pgtmp, unsigned vector_length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1957,0 +1957,11 @@\n+\n+#ifdef ASSERT\n+void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n+  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n+  Label L;\n+  subs(zr, reg, oopDesc::base_offset_in_bytes());\n+  br(Assembler::GE, L);\n+  stop(\"bad field offset\");\n+  bind(L);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -352,0 +352,2 @@\n+\n+  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,9 +156,3 @@\n-class RelocActions {\n-protected:\n-  typedef int (*reloc_insn)(address insn_addr, address &target);\n-  virtual reloc_insn adrpMem() = 0;\n-  virtual reloc_insn adrpAdd() = 0;\n-  virtual reloc_insn adrpMovk() = 0;\n-\n-  const address _insn_addr;\n-  const uint32_t _insn;\n+static uint32_t insn_at(address insn_addr, int n) {\n+  return ((uint32_t*)insn_addr)[n];\n+}\n@@ -167,6 +161,2 @@\n-  static uint32_t insn_at(address insn_addr, int n) {\n-    return ((uint32_t*)insn_addr)[n];\n-  }\n-  uint32_t insn_at(int n) const {\n-    return insn_at(_insn_addr, n);\n-  }\n+template<typename T>\n+class RelocActions : public AllStatic {\n@@ -176,14 +166,1 @@\n-  RelocActions(address insn_addr) : _insn_addr(insn_addr), _insn(insn_at(insn_addr, 0)) {}\n-  RelocActions(address insn_addr, uint32_t insn)\n-    :  _insn_addr(insn_addr), _insn(insn) {}\n-\n-  virtual int unconditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int conditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int testAndBranch(address insn_addr, address &target) = 0;\n-  virtual int loadStore(address insn_addr, address &target) = 0;\n-  virtual int adr(address insn_addr, address &target) = 0;\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) = 0;\n-  virtual int immediate(address insn_addr, address &target) = 0;\n-  virtual void verify(address insn_addr, address &target) = 0;\n-\n-  int ALWAYSINLINE run(address insn_addr, address &target) {\n+  static int ALWAYSINLINE run(address insn_addr, address &target) {\n@@ -191,0 +168,1 @@\n+    uint32_t insn = insn_at(insn_addr, 0);\n@@ -192,1 +170,1 @@\n-    uint32_t dispatch = Instruction_aarch64::extract(_insn, 30, 25);\n+    uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n@@ -196,1 +174,1 @@\n-        instructions = unconditionalBranch(insn_addr, target);\n+        instructions = T::unconditionalBranch(insn_addr, target);\n@@ -201,2 +179,2 @@\n-        instructions = conditionalBranch(insn_addr, target);\n-          break;\n+        instructions = T::conditionalBranch(insn_addr, target);\n+        break;\n@@ -205,1 +183,1 @@\n-        instructions = testAndBranch(insn_addr, target);\n+        instructions = T::testAndBranch(insn_addr, target);\n@@ -217,1 +195,1 @@\n-        if ((Instruction_aarch64::extract(_insn, 29, 24) & 0b111011) == 0b011000) {\n+        if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n@@ -219,1 +197,1 @@\n-          instructions = loadStore(insn_addr, target);\n+          instructions = T::loadStore(insn_addr, target);\n@@ -232,2 +210,2 @@\n-        assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n-        int shift = Instruction_aarch64::extract(_insn, 31, 31);\n+        assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+        int shift = Instruction_aarch64::extract(insn, 31, 31);\n@@ -235,1 +213,1 @@\n-          uint32_t insn2 = insn_at(1);\n+          uint32_t insn2 = insn_at(insn_addr, 1);\n@@ -237,1 +215,1 @@\n-              Instruction_aarch64::extract(_insn, 4, 0) ==\n+              Instruction_aarch64::extract(insn, 4, 0) ==\n@@ -239,1 +217,1 @@\n-            instructions = adrp(insn_addr, target, adrpMem());\n+            instructions = T::adrp(insn_addr, target, T::adrpMem);\n@@ -241,1 +219,1 @@\n-                     Instruction_aarch64::extract(_insn, 4, 0) ==\n+                     Instruction_aarch64::extract(insn, 4, 0) ==\n@@ -243,1 +221,1 @@\n-            instructions = adrp(insn_addr, target, adrpAdd());\n+            instructions = T::adrp(insn_addr, target, T::adrpAdd);\n@@ -245,1 +223,1 @@\n-                     Instruction_aarch64::extract(_insn, 4, 0) ==\n+                     Instruction_aarch64::extract(insn, 4, 0) ==\n@@ -247,1 +225,1 @@\n-            instructions = adrp(insn_addr, target, adrpMovk());\n+            instructions = T::adrp(insn_addr, target, T::adrpMovk);\n@@ -252,1 +230,1 @@\n-          instructions = adr(insn_addr, target);\n+          instructions = T::adr(insn_addr, target);\n@@ -260,1 +238,1 @@\n-        instructions = immediate(insn_addr, target);\n+        instructions = T::immediate(insn_addr, target);\n@@ -268,1 +246,1 @@\n-    verify(insn_addr, target);\n+    T::verify(insn_addr, target);\n@@ -273,5 +251,1 @@\n-class Patcher : public RelocActions {\n-  virtual reloc_insn adrpMem() { return &Patcher::adrpMem_impl; }\n-  virtual reloc_insn adrpAdd() { return &Patcher::adrpAdd_impl; }\n-  virtual reloc_insn adrpMovk() { return &Patcher::adrpMovk_impl; }\n-\n+class Patcher : public AllStatic {\n@@ -279,3 +253,1 @@\n-  Patcher(address insn_addr) : RelocActions(insn_addr) {}\n-\n-  virtual int unconditionalBranch(address insn_addr, address &target) {\n+  static int unconditionalBranch(address insn_addr, address &target) {\n@@ -286,1 +258,1 @@\n-  virtual int conditionalBranch(address insn_addr, address &target) {\n+  static int conditionalBranch(address insn_addr, address &target) {\n@@ -291,1 +263,1 @@\n-  virtual int testAndBranch(address insn_addr, address &target) {\n+  static int testAndBranch(address insn_addr, address &target) {\n@@ -296,1 +268,1 @@\n-  virtual int loadStore(address insn_addr, address &target) {\n+  static int loadStore(address insn_addr, address &target) {\n@@ -301,1 +273,1 @@\n-  virtual int adr(address insn_addr, address &target) {\n+  static int adr(address insn_addr, address &target) {\n@@ -303,1 +275,1 @@\n-    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n+    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 28, 24) == 0b10000, \"must be\");\n@@ -313,1 +285,2 @@\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n+  template<typename U>\n+  static int adrp(address insn_addr, address &target, U inner) {\n@@ -316,1 +289,1 @@\n-    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n+    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 28, 24) == 0b10000, \"must be\");\n@@ -323,1 +296,1 @@\n-    instructions = (*inner)(insn_addr, adjusted_target);\n+    instructions = inner(insn_addr, adjusted_target);\n@@ -333,1 +306,1 @@\n-  static int adrpMem_impl(address insn_addr, address &target) {\n+  static int adrpMem(address insn_addr, address &target) {\n@@ -342,1 +315,1 @@\n-  static int adrpAdd_impl(address insn_addr, address &target) {\n+  static int adrpAdd(address insn_addr, address &target) {\n@@ -348,1 +321,1 @@\n-  static int adrpMovk_impl(address insn_addr, address &target) {\n+  static int adrpMovk(address insn_addr, address &target) {\n@@ -355,2 +328,2 @@\n-  virtual int immediate(address insn_addr, address &target) {\n-    assert(Instruction_aarch64::extract(_insn, 31, 21) == 0b11010010100, \"must be\");\n+  static int immediate(address insn_addr, address &target) {\n+    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 31, 21) == 0b11010010100, \"must be\");\n@@ -366,1 +339,1 @@\n-  virtual void verify(address insn_addr, address &target) {\n+  static void verify(address insn_addr, address &target) {\n@@ -400,5 +373,1 @@\n-class AArch64Decoder : public RelocActions {\n-  virtual reloc_insn adrpMem() { return &AArch64Decoder::adrpMem_impl; }\n-  virtual reloc_insn adrpAdd() { return &AArch64Decoder::adrpAdd_impl; }\n-  virtual reloc_insn adrpMovk() { return &AArch64Decoder::adrpMovk_impl; }\n-\n+class AArch64Decoder : public AllStatic {\n@@ -406,3 +375,2 @@\n-  AArch64Decoder(address insn_addr, uint32_t insn) : RelocActions(insn_addr, insn) {}\n-  virtual int loadStore(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 23, 5);\n+  static int loadStore(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 23, 5);\n@@ -413,2 +381,2 @@\n-  virtual int unconditionalBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 25, 0);\n+  static int unconditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 25, 0);\n@@ -418,2 +386,2 @@\n-  virtual int conditionalBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 23, 5);\n+  static int conditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 23, 5);\n@@ -423,2 +391,2 @@\n-  virtual int testAndBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 18, 5);\n+  static int testAndBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 18, 5);\n@@ -428,1 +396,1 @@\n-  virtual int adr(address insn_addr, address &target) {\n+  static int adr(address insn_addr, address &target) {\n@@ -430,2 +398,3 @@\n-    intptr_t offset = Instruction_aarch64::extract(_insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(_insn, 23, 5) << 2;\n+    uint32_t insn = insn_at(insn_addr, 0);\n+    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n@@ -435,4 +404,6 @@\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n-    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n-    intptr_t offset = Instruction_aarch64::extract(_insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(_insn, 23, 5) << 2;\n+  template<typename U>\n+  static int adrp(address insn_addr, address &target, U inner) {\n+    uint32_t insn = insn_at(insn_addr, 0);\n+    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n@@ -443,1 +414,1 @@\n-    uint32_t insn2 = insn_at(1);\n+    uint32_t insn2 = insn_at(insn_addr, 1);\n@@ -446,1 +417,1 @@\n-    (*inner)(insn_addr, target);\n+    inner(insn_addr, target);\n@@ -449,1 +420,1 @@\n-  static int adrpMem_impl(address insn_addr, address &target) {\n+  static int adrpMem(address insn_addr, address &target) {\n@@ -458,1 +429,1 @@\n-  static int adrpAdd_impl(address insn_addr, address &target) {\n+  static int adrpAdd(address insn_addr, address &target) {\n@@ -465,1 +436,1 @@\n-  static int adrpMovk_impl(address insn_addr, address &target) {\n+  static int adrpMovk(address insn_addr, address &target) {\n@@ -484,1 +455,1 @@\n-  virtual int immediate(address insn_addr, address &target) {\n+  static int immediate(address insn_addr, address &target) {\n@@ -486,1 +457,1 @@\n-    assert(Instruction_aarch64::extract(_insn, 31, 21) == 0b11010010100, \"must be\");\n+    assert(Instruction_aarch64::extract(insns[0], 31, 21) == 0b11010010100, \"must be\");\n@@ -490,3 +461,3 @@\n-    target = address(uint64_t(Instruction_aarch64::extract(_insn, 20, 5))\n-                 + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n-                 + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n+    target = address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n+                  + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n+                  + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n@@ -497,1 +468,1 @@\n-  virtual void verify(address insn_addr, address &target) {\n+  static void verify(address insn_addr, address &target) {\n@@ -501,2 +472,1 @@\n-address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n-  AArch64Decoder decoder(insn_addr, insn);\n+address MacroAssembler::target_addr_for_insn(address insn_addr) {\n@@ -504,1 +474,1 @@\n-  decoder.run(insn_addr, target);\n+  RelocActions<AArch64Decoder>::run(insn_addr, target);\n@@ -511,2 +481,1 @@\n-  Patcher patcher(insn_addr);\n-  return patcher.run(insn_addr, target);\n+  return RelocActions<Patcher>::run(insn_addr, target);\n@@ -554,2 +523,2 @@\n-address MacroAssembler::target_addr_for_insn_or_null(address insn_addr, unsigned insn) {\n-  if (NativeInstruction::is_ldrw_to_zr(address(&insn))) {\n+address MacroAssembler::target_addr_for_insn_or_null(address insn_addr) {\n+  if (NativeInstruction::is_ldrw_to_zr(insn_addr)) {\n@@ -558,1 +527,1 @@\n-  return MacroAssembler::target_addr_for_insn(insn_addr, insn);\n+  return MacroAssembler::target_addr_for_insn(insn_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":79,"deletions":110,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -706,10 +706,2 @@\n-  static address target_addr_for_insn(address insn_addr, unsigned insn);\n-  static address target_addr_for_insn_or_null(address insn_addr, unsigned insn);\n-  static address target_addr_for_insn(address insn_addr) {\n-    unsigned insn = *(unsigned*)insn_addr;\n-    return target_addr_for_insn(insn_addr, insn);\n-  }\n-  static address target_addr_for_insn_or_null(address insn_addr) {\n-    unsigned insn = *(unsigned*)insn_addr;\n-    return target_addr_for_insn_or_null(insn_addr, insn);\n-  }\n+  static address target_addr_for_insn(address insn_addr);\n+  static address target_addr_for_insn_or_null(address insn_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  assert_different_registers(bc_reg, temp_reg);\n@@ -235,3 +236,6 @@\n-\n-  \/\/ patch bytecode\n-  __ strb(bc_reg, at_bcp(0));\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n+  __ lea(temp_reg, at_bcp(0));\n+  __ stlrb(bc_reg, temp_reg);\n@@ -3278,0 +3282,1 @@\n+  __ verify_field_offset(r1);\n@@ -3383,0 +3388,2 @@\n+  __ verify_field_offset(r1);\n+\n@@ -3458,0 +3465,1 @@\n+\n@@ -3459,0 +3467,1 @@\n+  __ verify_field_offset(r1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -471,1 +471,5 @@\n-void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+void InterpreterMacroAssembler::load_field_or_method_entry(bool is_method, Register cache, Register index, int bcp_offset, bool for_fast_bytecode) {\n+  const int entry_size     = is_method ? sizeof(ResolvedMethodEntry) : sizeof(ResolvedFieldEntry),\n+            base_offset    = is_method ? Array<ResolvedMethodEntry>::base_offset_in_bytes() : Array<ResolvedFieldEntry>::base_offset_in_bytes(),\n+            entries_offset = is_method ? in_bytes(ConstantPoolCache::method_entries_offset()) : in_bytes(ConstantPoolCache::field_entries_offset());\n+\n@@ -475,1 +479,1 @@\n-  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+  if (is_power_of_2(entry_size)) {\n@@ -477,1 +481,1 @@\n-    sldi(index, index, log2i_exact(sizeof(ResolvedFieldEntry)));\n+    sldi(index, index, log2i_exact(entry_size));\n@@ -480,1 +484,1 @@\n-    mulli(index, index, sizeof(ResolvedFieldEntry));\n+    mulli(index, index, entry_size);\n@@ -483,2 +487,2 @@\n-  ld_ptr(cache, in_bytes(ConstantPoolCache::field_entries_offset()), R27_constPoolCache);\n-  addi(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+  ld_ptr(cache, entries_offset, R27_constPoolCache);\n+  addi(cache, cache, base_offset);\n@@ -486,11 +490,7 @@\n-}\n-void InterpreterMacroAssembler::load_method_entry(Register cache, Register index, int bcp_offset) {\n-  \/\/ Get index out of bytecode pointer\n-  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedMethodEntry)\n-  mulli(index, index, sizeof(ResolvedMethodEntry));\n-\n-  \/\/ Get address of field entries array\n-  ld_ptr(cache, ConstantPoolCache::method_entries_offset(), R27_constPoolCache);\n-  addi(cache, cache, Array<ResolvedMethodEntry>::base_offset_in_bytes());\n-  add(cache, cache, index); \/\/ method_entries + base_offset + scaled index\n+  if (for_fast_bytecode) {\n+    \/\/ Prevent speculative loading from ResolvedFieldEntry\/ResolvedMethodEntry as it can miss the info written by another thread.\n+    \/\/ TemplateTable::patch_bytecode uses release-store.\n+    \/\/ We reached here via control dependency (Bytecode dispatch has used the rewritten Bytecode).\n+    \/\/ So, we can use control-isync based ordering.\n+    isync();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1076,2 +1076,0 @@\n-#ifdef ASSERT\n-#endif\n@@ -1550,2 +1548,0 @@\n-#ifdef ASSERT\n-#endif\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  assert_different_registers(bc_reg, temp_reg);\n@@ -199,1 +200,5 @@\n-  \/\/ patch bytecode\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n+  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n@@ -3032,0 +3037,1 @@\n+  __ verify_field_offset(x11);\n@@ -3119,0 +3125,2 @@\n+  __ verify_field_offset(x11);\n+\n@@ -3174,0 +3182,1 @@\n+\n@@ -3175,0 +3184,1 @@\n+  __ verify_field_offset(x11);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -489,9 +489,9 @@\n-  caller_saved.Insert(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rsi->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rdi->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r8->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r9->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r10->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r11->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rsi->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rdi->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r8->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r9->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r10->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r11->as_VMReg()));\n@@ -500,16 +500,16 @@\n-    caller_saved.Insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n@@ -529,1 +529,1 @@\n-      if (caller_saved.Member(opto_reg)) {\n+      if (caller_saved.member(opto_reg)) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-  _ANY_REG_mask = _ALL_REG_mask;\n+  _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n@@ -503,2 +503,2 @@\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n@@ -507,2 +507,2 @@\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n@@ -511,5 +511,5 @@\n-  _PTR_REG_mask = _ANY_REG_mask;\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n+  _PTR_REG_mask.assignFrom(_ANY_REG_mask);\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n@@ -518,2 +518,2 @@\n-      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n-      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n+      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n@@ -523,2 +523,2 @@\n-  _STACK_OR_PTR_REG_mask = _PTR_REG_mask;\n-  _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+  _STACK_OR_PTR_REG_mask.assignFrom(_PTR_REG_mask);\n+  _STACK_OR_PTR_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n@@ -526,3 +526,3 @@\n-  _PTR_REG_NO_RBP_mask = _PTR_REG_mask;\n-  _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _PTR_REG_NO_RBP_mask.assignFrom(_PTR_REG_mask);\n+  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n@@ -530,3 +530,3 @@\n-  _PTR_NO_RAX_REG_mask = _PTR_REG_mask;\n-  _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+  _PTR_NO_RAX_REG_mask.assignFrom(_PTR_REG_mask);\n+  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n@@ -534,3 +534,3 @@\n-  _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;\n-  _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n-  _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n+  _PTR_NO_RAX_RBX_REG_mask.assignFrom(_PTR_NO_RAX_REG_mask);\n+  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n+  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n@@ -539,3 +539,3 @@\n-  _LONG_REG_mask = _PTR_REG_mask;\n-  _STACK_OR_LONG_REG_mask = _LONG_REG_mask;\n-  _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+  _LONG_REG_mask.assignFrom(_PTR_REG_mask);\n+  _STACK_OR_LONG_REG_mask.assignFrom(_LONG_REG_mask);\n+  _STACK_OR_LONG_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n@@ -543,5 +543,5 @@\n-  _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n+  _LONG_NO_RAX_RDX_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n@@ -549,3 +549,3 @@\n-  _LONG_NO_RCX_REG_mask = _LONG_REG_mask;\n-  _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-  _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n+  _LONG_NO_RCX_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n@@ -553,5 +553,5 @@\n-  _LONG_NO_RBP_R13_REG_mask = _LONG_REG_mask;\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n@@ -559,1 +559,1 @@\n-  _INT_REG_mask = _ALL_INT_REG_mask;\n+  _INT_REG_mask.assignFrom(_ALL_INT_REG_mask);\n@@ -562,1 +562,1 @@\n-      _INT_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _INT_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n@@ -567,1 +567,1 @@\n-    _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+    _INT_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n@@ -570,1 +570,1 @@\n-    _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+    _INT_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n@@ -573,2 +573,2 @@\n-  _STACK_OR_INT_REG_mask = _INT_REG_mask;\n-  _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+  _STACK_OR_INT_REG_mask.assignFrom(_INT_REG_mask);\n+  _STACK_OR_INT_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n@@ -576,3 +576,3 @@\n-  _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;\n-  _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  _INT_NO_RAX_RDX_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n@@ -580,2 +580,2 @@\n-  _INT_NO_RCX_REG_mask = _INT_REG_mask;\n-  _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  _INT_NO_RCX_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n@@ -583,3 +583,3 @@\n-  _INT_NO_RBP_R13_REG_mask = _INT_REG_mask;\n-  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n@@ -589,1 +589,1 @@\n-  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n+  _FLOAT_REG_mask.assignFrom(VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask);\n@@ -764,1 +764,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n@@ -1670,1 +1670,1 @@\n-  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.size() : INTPRESSURE;\n@@ -1678,1 +1678,1 @@\n-  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.size() - dec_count;\n@@ -1690,1 +1690,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -1695,1 +1695,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -1700,1 +1700,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -1705,1 +1705,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2427,1 +2427,1 @@\n-  const char *reg_class = nullptr; \/\/ \"RegMask::Empty\";\n+  const char* reg_class = nullptr; \/\/ \"RegMask::EMPTY\";\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -967,0 +967,2 @@\n+  } else if (is_dumping_classic_static_archive()) {\n+    return is_dumping_aot_linked_classes();\n@@ -968,1 +970,0 @@\n-    \/\/ For simplicity, we don't support this optimization with the old CDS workflow.\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    StackMapFrame* frame, int32_t target, TRAPS) const {\n+    StackMapFrame* frame, int bci, int offset, TRAPS) const {\n@@ -138,0 +138,8 @@\n+  \/\/ Jump targets must be within the method and the method size is limited. See JVMS 4.11\n+  int min_offset = -1 * max_method_code_size;\n+  if (offset < min_offset || offset > max_method_code_size) {\n+    frame->verifier()->verify_error(ErrorContext::bad_stackmap(bci, frame),\n+        \"Illegal target of jump or branch (bci %d + offset %d)\", bci, offset);\n+    return;\n+  }\n+  int target = bci + offset;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  void check_jump_target(StackMapFrame* frame, int32_t target, TRAPS) const;\n+  void check_jump_target(StackMapFrame* frame, int bci, int offset, TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -819,1 +819,0 @@\n-      int target;\n@@ -1644,2 +1643,1 @@\n-          target = bcs.dest();\n-            &current_frame, target, CHECK_VERIFY(this));\n+            &current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n@@ -1657,2 +1655,1 @@\n-          target = bcs.dest();\n-            (&current_frame, target, CHECK_VERIFY(this));\n+            (&current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n@@ -1662,2 +1659,1 @@\n-          target = bcs.dest();\n-            &current_frame, target, CHECK_VERIFY(this));\n+            &current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n@@ -1667,2 +1663,1 @@\n-          target = bcs.dest_w();\n-            &current_frame, target, CHECK_VERIFY(this));\n+            &current_frame, bcs.bci(), bcs.get_offset_s4(), CHECK_VERIFY(this));\n@@ -2315,2 +2310,1 @@\n-  int target = bci + default_offset;\n-  stackmap_table->check_jump_target(current_frame, target, CHECK_VERIFY(this));\n+  stackmap_table->check_jump_target(current_frame, bci, default_offset, CHECK_VERIFY(this));\n@@ -2321,1 +2315,1 @@\n-    target = bci + (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n+    int offset = (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n@@ -2323,1 +2317,1 @@\n-      current_frame, target, CHECK_VERIFY(this));\n+      current_frame, bci, offset, CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1161,1 +1162,1 @@\n-    + align_up(ImmutableDataReferencesCounterSize, oopSize);\n+    + ImmutableDataReferencesCounterSize;\n@@ -1340,0 +1341,1 @@\n+    _immutable_data_reference_counter_offset = 0;\n@@ -1438,9 +1440,0 @@\n-  \/\/ Increment number of references to immutable data to share it between nmethods\n-  _immutable_data_size          = nm._immutable_data_size;\n-  if (_immutable_data_size > 0) {\n-    _immutable_data             = nm._immutable_data;\n-    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n-  } else {\n-    _immutable_data             = blob_end();\n-  }\n-\n@@ -1462,0 +1455,1 @@\n+  _immutable_data_size          = nm._immutable_data_size;\n@@ -1480,0 +1474,9 @@\n+  _immutable_data_reference_counter_offset = nm._immutable_data_reference_counter_offset;\n+\n+  \/\/ Increment number of references to immutable data to share it between nmethods\n+  if (_immutable_data_size > 0) {\n+    _immutable_data             = nm._immutable_data;\n+    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n+  } else {\n+    _immutable_data             = blob_end();\n+  }\n@@ -1773,1 +1776,2 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n+    _immutable_data_reference_counter_offset = _speculations_offset + align_up(speculations_len, oopSize);\n+    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n@@ -1775,1 +1779,2 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n+    _immutable_data_reference_counter_offset =  _scopes_data_offset + align_up(debug_info->data_size(), oopSize);\n+    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n@@ -2522,0 +2527,27 @@\n+#if INCLUDE_CDS\n+static GrowableArrayCHeap<nmethod*, mtClassShared>* _delayed_compiled_method_load_events = nullptr;\n+\n+void nmethod::add_delayed_compiled_method_load_event(nmethod* nm) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+  precond(!ServiceThread::has_started());\n+\n+  \/\/ We are still in single threaded stage of VM bootstrap. No need to lock.\n+  if (_delayed_compiled_method_load_events == nullptr) {\n+    _delayed_compiled_method_load_events = new GrowableArrayCHeap<nmethod*, mtClassShared>();\n+  }\n+  _delayed_compiled_method_load_events->append(nm);\n+}\n+\n+void nmethod::post_delayed_compiled_method_load_events() {\n+  precond(ServiceThread::has_started());\n+  if (_delayed_compiled_method_load_events != nullptr) {\n+    for (int i = 0; i < _delayed_compiled_method_load_events->length(); i++) {\n+      nmethod* nm = _delayed_compiled_method_load_events->at(i);\n+      nm->post_compiled_method_load_event();\n+    }\n+    delete _delayed_compiled_method_load_events;\n+    _delayed_compiled_method_load_events = nullptr;\n+  }\n+}\n+#endif\n+\n@@ -2527,0 +2559,10 @@\n+#if INCLUDE_CDS\n+  if (!ServiceThread::has_started()) {\n+    \/\/ With AOT-linked classes, we could compile wrappers for native methods before the\n+    \/\/ ServiceThread has been started, so we must delay the events to be posted later.\n+    assert(state == nullptr, \"must be\");\n+    add_delayed_compiled_method_load_event(this);\n+    return;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+  int      _immutable_data_reference_counter_offset;\n@@ -654,1 +655,1 @@\n-  address speculations_end      () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+  address speculations_end      () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n@@ -656,1 +657,1 @@\n-  address scopes_data_end       () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+  address scopes_data_end       () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n@@ -658,2 +659,1 @@\n-\n-  address immutable_data_references_counter_begin () const { return immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+  address immutable_data_references_counter_begin () const { return _immutable_data + _immutable_data_reference_counter_offset ; }\n@@ -986,0 +986,2 @@\n+  static void add_delayed_compiled_method_load_event(nmethod* nm) NOT_CDS_RETURN;\n+\n@@ -1020,0 +1022,3 @@\n+  \/\/ AOT cache support\n+  static void post_delayed_compiled_method_load_events() NOT_CDS_RETURN;\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,4 +63,0 @@\n-inline void ParCompactionManager::push(PartialArrayState* stat) {\n-  marking_stack()->push(ScannerTask(stat));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  _preserve.Insert(OptoReg::as_OptoReg(vm_reg));\n+  _preserve.insert(OptoReg::as_OptoReg(vm_reg));\n@@ -131,1 +131,1 @@\n-    _preserve.Remove(OptoReg::as_OptoReg(vm_reg));\n+    _preserve.remove(OptoReg::as_OptoReg(vm_reg));\n@@ -1178,1 +1178,1 @@\n-      new_live.OR(live[succ_id]);\n+      new_live.or_with(live[succ_id]);\n@@ -1189,1 +1189,1 @@\n-          regs->OR(new_live);\n+          regs->or_with(new_live);\n@@ -1197,1 +1197,1 @@\n-        new_live.Remove(first);\n+        new_live.remove(first);\n@@ -1200,1 +1200,1 @@\n-        new_live.Remove(second);\n+        new_live.remove(second);\n@@ -1209,1 +1209,1 @@\n-          new_live.Insert(first);\n+          new_live.insert(first);\n@@ -1212,1 +1212,1 @@\n-          new_live.Insert(second);\n+          new_live.insert(second);\n@@ -1220,1 +1220,1 @@\n-          regs->OR(new_live);\n+          regs->or_with(new_live);\n@@ -1226,2 +1226,2 @@\n-    new_live.SUBTRACT(old_live);\n-    if (!new_live.is_Empty()) {\n+    new_live.subtract(old_live);\n+    if (!new_live.is_empty()) {\n@@ -1229,1 +1229,1 @@\n-      old_live.OR(new_live);\n+      old_live.or_with(new_live);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-  \/\/ Causes all refs in \"mr\" to be assumed to be modified by the given JavaThread.\n-  virtual void write_region(JavaThread* thread, MemRegion mr) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -346,3 +346,3 @@\n-  log_debug(gc)(\"Remembered set scan processing Region %zu, from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n-                region->index(), p2i(start_of_range), p2i(end_of_range),\n-                use_write_table? \"read\/write (updating)\": \"read (marking)\");\n+  log_debug(gc, remset)(\"Remembered set scan processing Region %zu, from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n+                        region->index(), p2i(start_of_range), p2i(end_of_range),\n+                        use_write_table? \"read\/write (updating)\": \"read (marking)\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -267,1 +267,2 @@\n-        return cpool->resolved_indy_entry_at(method_index)->is_resolved();\n+        bool is_resolved = cpool->resolved_indy_entry_at(method_index)->is_resolved();\n+        return !is_resolved;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {\n+ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size) {\n@@ -972,3 +972,7 @@\n-  size_t page_size = os::vm_page_size();\n-  if (UseLargePages && is_aligned(alignment, os::large_page_size())) {\n-    page_size = os::large_page_size();\n+  size_t page_size;\n+  if (desired_page_size == 0) {\n+    if (UseLargePages) {\n+      page_size = os::large_page_size();\n+    } else {\n+      page_size = os::vm_page_size();\n+    }\n@@ -978,1 +982,3 @@\n-    assert(!UseLargePages || UseParallelGC , \"Wrong alignment to use large pages\");\n+    assert(UseParallelGC , \"only Parallel\");\n+    \/\/ Use caller provided value.\n+    page_size = desired_page_size;\n@@ -980,1 +986,1 @@\n-\n+  assert(is_aligned(heap_size, page_size), \"inv\");\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment);\n+  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size = 0);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-  Klass* k = resolved_klass_at(cp_index);\n+  Klass* k = nullptr;\n@@ -547,5 +547,1 @@\n-  if (k == nullptr) {\n-    \/\/ We'd come here if the referenced class has been excluded via\n-    \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n-    \/\/ has cleared the resolved_klasses()->at(...) pointer to null. Thus, we\n-    \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n@@ -554,2 +550,11 @@\n-    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n-    can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n+    k = resolved_klass_at(cp_index);\n+    if (k == nullptr) {\n+      \/\/ We'd come here if the referenced class has been excluded via\n+      \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n+      \/\/ has cleared the resolved_klasses()->at(...) pointer to null. Thus, we\n+      \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n+      can_archive = false;\n+    } else {\n+      ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+      can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n+    }\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -434,1 +434,2 @@\n-    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n+        && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -440,14 +441,12 @@\n-    if (resolved) {\n-      LogStreamHandle(Trace, aot, resolve) log;\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n-        Symbol* name = cp->uncached_name_ref_at(cp_index);\n-        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n-        log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n-                  (archived ? \"archived\" : \"reverted\"),\n-                  cp_index,\n-                  cp->pool_holder()->name()->as_C_string(),\n-                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n-      }\n+    LogStreamHandle(Trace, aot, resolve) log;\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+      Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+      Symbol* name = cp->uncached_name_ref_at(cp_index);\n+      Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+      log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n+                (archived ? \"archived\" : \"reverted\"),\n+                cp_index,\n+                cp->pool_holder()->name()->as_C_string(),\n+                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n@@ -474,1 +473,2 @@\n-    if (resolved && can_archive_resolved_method(src_cp, rme)) {\n+    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n+        && can_archive_resolved_method(src_cp, rme)) {\n@@ -480,20 +480,18 @@\n-    if (resolved) {\n-      LogStreamHandle(Trace, aot, resolve) log;\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n-        Symbol* name = cp->uncached_name_ref_at(cp_index);\n-        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n-        log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n-                  (archived ? \"archived\" : \"reverted\"),\n-                  (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n-                  cp_index,\n-                  cp->pool_holder()->name()->as_C_string(),\n-                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n-        if (archived) {\n-          Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n-          log.print(\" => %s%s\",\n-                    resolved_klass->name()->as_C_string(),\n-                    (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n-        }\n+    LogStreamHandle(Trace, aot, resolve) log;\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+      Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+      Symbol* name = cp->uncached_name_ref_at(cp_index);\n+      Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+      log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n+                (archived ? \"archived\" : \"reverted\"),\n+                (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n+                cp_index,\n+                cp->pool_holder()->name()->as_C_string(),\n+                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+      if (archived) {\n+        Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n+        log.print(\" => %s%s\",\n+                  resolved_klass->name()->as_C_string(),\n+                  (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n@@ -514,1 +512,2 @@\n-    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n+        && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -520,16 +519,13 @@\n-    if (resolved) {\n-      LogStreamHandle(Trace, aot, resolve) log;\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n-        int bsm_ref = cp->method_handle_index_at(bsm);\n-        Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n-        Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n-        Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n-        log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n-                  (archived ? \"archived\" : \"reverted\"),\n-                  cp_index, cp->pool_holder()->name()->as_C_string(), i);\n-        log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n-                  bsm_name->as_C_string(), bsm_signature->as_C_string());\n-      }\n-      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n+    LogStreamHandle(Trace, aot, resolve) log;\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+      int bsm_ref = cp->method_handle_index_at(bsm);\n+      Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+      Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+      Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+      log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n+                (archived ? \"archived\" : \"reverted\"),\n+                cp_index, cp->pool_holder()->name()->as_C_string(), i);\n+      log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n+                bsm_name->as_C_string(), bsm_signature->as_C_string());\n@@ -537,0 +533,1 @@\n+    ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":50,"deletions":53,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -88,1 +88,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this,proj->_con,RegMask::EMPTY,MachProjNode::unmatched_proj);\n@@ -809,1 +809,1 @@\n-                rm.Insert(r);\n+                rm.insert(r);\n@@ -816,1 +816,1 @@\n-          rm.Insert(regs.second());\n+          rm.insert(regs.second());\n@@ -822,1 +822,1 @@\n-        return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);\n+        return new MachProjNode(this,con, RegMask::EMPTY, (uint)OptoReg::Bad);\n@@ -831,1 +831,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this,proj->_con,RegMask::EMPTY,MachProjNode::unmatched_proj);\n@@ -1696,1 +1696,3 @@\n-  if( idx < TypeFunc::Parms ) return RegMask::Empty;\n+  if (idx < TypeFunc::Parms) {\n+    return RegMask::EMPTY;\n+  }\n@@ -1701,1 +1703,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -1812,1 +1814,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -1863,1 +1865,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1020,1 +1020,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3075,1 +3075,1 @@\n-  return i ? out_RegMask() : RegMask::Empty;\n+  return i ? out_RegMask() : RegMask::EMPTY;\n@@ -3081,1 +3081,3 @@\n-  if( ideal_reg == 0 ) return RegMask::Empty;\n+  if (ideal_reg == 0) {\n+    return RegMask::EMPTY;\n+  }\n@@ -3108,1 +3110,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3113,1 +3115,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3118,1 +3120,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3123,1 +3125,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-    return RegMask::All;\n+    return RegMask::ALL;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-    else tty->print(\", #!!!_%d_vs_%d \",_mask_size,_mask.Size());\n+    else {\n+      tty->print(\", #!!!_%d_vs_%d \", _mask_size, _mask.size());\n+    }\n@@ -54,1 +56,1 @@\n-    tty->print(\", #?(%d) \",_mask.Size());\n+    tty->print(\", #?(%d) \", _mask.size());\n@@ -744,1 +746,1 @@\n-          lrg.Remove(hi);       \/\/ Yank from mask\n+          lrg.remove(hi);               \/\/ Yank from mask\n@@ -776,1 +778,1 @@\n-      _lrg_map.map(n->_idx, !rm.is_Empty() ? lr_counter++ : 0);\n+      _lrg_map.map(n->_idx, !rm.is_empty() ? lr_counter++ : 0);\n@@ -797,1 +799,1 @@\n-      _lrg_map.map(n->_idx, !rm.is_Empty() ? n->_idx : 0);\n+      _lrg_map.map(n->_idx, !rm.is_empty() ? n->_idx : 0);\n@@ -882,1 +884,1 @@\n-        lrg.AND( rm );\n+        lrg.and_with(rm);\n@@ -938,1 +940,1 @@\n-          lrg.set_num_regs(rm.Size());\n+          lrg.set_num_regs(rm.size());\n@@ -1129,1 +1131,1 @@\n-          lrg.AND( rm );\n+          lrg.and_with(rm);\n@@ -1167,1 +1169,1 @@\n-          lrg.Clear();\n+          lrg.clear();\n@@ -1408,1 +1410,1 @@\n-  if (lrg.mask().can_represent(reg) && lrg.mask().Member(reg)) {\n+  if (lrg.mask().can_represent(reg) && lrg.mask().member(reg)) {\n@@ -1462,1 +1464,1 @@\n-          mask.Remove(assigned - num_regs + 1); \/\/ Unmask the lowest reg\n+          mask.remove(assigned - num_regs + 1);      \/\/ Unmask the lowest reg\n@@ -1513,1 +1515,1 @@\n-      tempmask.AND(lrgs(copy_lrg).mask());\n+      tempmask.and_with(lrgs(copy_lrg).mask());\n@@ -1536,1 +1538,1 @@\n-    lrg.Remove(reg);\n+    lrg.remove(reg);\n@@ -1538,1 +1540,1 @@\n-    lrg.Insert(reg);\n+    lrg.insert(reg);\n@@ -1548,2 +1550,2 @@\n-  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n-  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n@@ -1625,1 +1627,1 @@\n-          uint size = lrg->mask().Size();\n+          uint size = lrg->mask().size();\n@@ -1629,1 +1631,1 @@\n-          lrg->SUBTRACT_inner(nlrg.mask());\n+          lrg->subtract_inner(nlrg.mask());\n@@ -1631,1 +1633,1 @@\n-          if (trace_spilling() && lrg->mask().Size() != size) {\n+          if (trace_spilling() && lrg->mask().size() != size) {\n@@ -1638,1 +1640,1 @@\n-            trace_mask.SUBTRACT(lrg->mask());\n+            trace_mask.subtract(lrg->mask());\n@@ -1704,2 +1706,2 @@\n-        lrg->Clear();           \/\/ Clear the mask\n-        lrg->Insert(reg);       \/\/ Set regmask to match selected reg\n+        lrg->clear();     \/\/ Clear the mask\n+        lrg->insert(reg); \/\/ Set regmask to match selected reg\n@@ -1712,1 +1714,1 @@\n-          lrg->Insert(OptoReg::add(reg,-i));\n+          lrg->insert(OptoReg::add(reg, -i));\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1671,1 +1671,1 @@\n-    rm = match->divI_proj_mask();\n+    rm.assignFrom(match->divI_proj_mask());\n@@ -1674,1 +1674,1 @@\n-    rm = match->modI_proj_mask();\n+    rm.assignFrom(match->modI_proj_mask());\n@@ -1686,1 +1686,1 @@\n-    rm = match->divL_proj_mask();\n+    rm.assignFrom(match->divL_proj_mask());\n@@ -1689,1 +1689,1 @@\n-    rm = match->modL_proj_mask();\n+    rm.assignFrom(match->modL_proj_mask());\n@@ -1724,1 +1724,1 @@\n-    rm = match->divI_proj_mask();\n+    rm.assignFrom(match->divI_proj_mask());\n@@ -1727,1 +1727,1 @@\n-    rm = match->modI_proj_mask();\n+    rm.assignFrom(match->modI_proj_mask());\n@@ -1739,1 +1739,1 @@\n-    rm = match->divL_proj_mask();\n+    rm.assignFrom(match->divL_proj_mask());\n@@ -1742,1 +1742,1 @@\n-    rm = match->modL_proj_mask();\n+    rm.assignFrom(match->modL_proj_mask());\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1337,2 +1337,1 @@\n-    } else if (use->is_SafePoint()) {\n-      \/\/ processed later\n+      \/\/ Safepoints to be processed later; other users aren't expected here\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_Empty())\n+  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_empty()) {\n@@ -1454,0 +1454,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -885,1 +885,1 @@\n-    if( !regs.Member(r) ) {     \/\/ Not already defined by the call\n+    if (!regs.member(r)) { \/\/ Not already defined by the call\n@@ -890,1 +890,1 @@\n-        proj->_rout.Insert(r);\n+        proj->_rout.insert(r);\n@@ -914,1 +914,1 @@\n-    regs.OR(n->out_RegMask());\n+    regs.or_with(n->out_RegMask());\n@@ -937,1 +937,1 @@\n-  regs.Insert(_matcher.c_frame_pointer());\n+  regs.insert(_matcher.c_frame_pointer());\n@@ -942,1 +942,1 @@\n-  MachProjNode *proj = new MachProjNode( mcall, r_cnt+1, RegMask::Empty, MachProjNode::fat_proj );\n+  MachProjNode* proj = new MachProjNode(mcall, r_cnt + 1, RegMask::EMPTY, MachProjNode::fat_proj);\n@@ -1194,2 +1194,2 @@\n-      regs.Insert(_matcher.c_frame_pointer());\n-      regs.OR(n->out_RegMask());\n+      regs.insert(_matcher.c_frame_pointer());\n+      regs.or_with(n->out_RegMask());\n@@ -1197,1 +1197,1 @@\n-      MachProjNode *proj = new MachProjNode( n, 1, RegMask::Empty, MachProjNode::fat_proj );\n+      MachProjNode* proj = new MachProjNode(n, 1, RegMask::EMPTY, MachProjNode::fat_proj);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -706,1 +706,3 @@\n-  _igvn.replace_node(multiversion_slow_proj, region);\n+  \/\/ The lazy_replace ensures that any get_ctrl that used to have multiversion_slow_proj\n+  \/\/ as their control are forwarded to the new region node as their control.\n+  lazy_replace(multiversion_slow_proj, region);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -549,1 +549,1 @@\n-    if (!rm.is_Empty() && rm.is_bound(ideal_reg())) {\n+    if (!rm.is_empty() && rm.is_bound(ideal_reg())) {\n@@ -643,2 +643,5 @@\n-  if( idx == 0 ) return RegMask::Empty;\n-  else return in(1)->as_Mach()->out_RegMask();\n+  if (idx == 0) {\n+    return RegMask::EMPTY;\n+  } else {\n+    return in(1)->as_Mach()->out_RegMask();\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -776,1 +776,1 @@\n-  virtual const RegMask &out_RegMask() const { return RegMask::Empty; }\n+  virtual const RegMask& out_RegMask() const { return RegMask::EMPTY; }\n@@ -808,1 +808,1 @@\n-  virtual const RegMask &in_RegMask(uint) const { return RegMask::Empty; }\n+  virtual const RegMask& in_RegMask(uint) const { return RegMask::EMPTY; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-    mask[--cnt].Clear();\n-    mask[cnt].Insert(OptoReg::stack2reg(slot));\n+    mask[--cnt].clear();\n+    mask[cnt].insert(OptoReg::stack2reg(slot));\n@@ -198,1 +198,1 @@\n-    mask[i].Clear();\n+    mask[i].clear();\n@@ -202,1 +202,1 @@\n-      mask[i].Insert(reg1);\n+      mask[i].insert(reg1);\n@@ -206,1 +206,1 @@\n-      mask[i].Insert(reg2);\n+      mask[i].insert(reg2);\n@@ -224,1 +224,1 @@\n-  assert(_return_addr_mask.is_Empty(),\n+  assert(_return_addr_mask.is_empty(),\n@@ -226,1 +226,1 @@\n-  _return_addr_mask.Insert(return_addr());\n+  _return_addr_mask.insert(return_addr());\n@@ -229,1 +229,1 @@\n-  _return_addr_mask.Insert(OptoReg::add(return_addr(),1));\n+  _return_addr_mask.insert(OptoReg::add(return_addr(), 1));\n@@ -297,1 +297,1 @@\n-    _calling_convention_mask[i].Clear();\n+    _calling_convention_mask[i].clear();\n@@ -309,1 +309,1 @@\n-      _calling_convention_mask[i].Insert(reg1);\n+      _calling_convention_mask[i].insert(reg1);\n@@ -313,1 +313,1 @@\n-      _calling_convention_mask[i].Insert(reg2);\n+      _calling_convention_mask[i].insert(reg2);\n@@ -458,5 +458,5 @@\n-  rms[TypeFunc::Control  ] = RegMask::Empty;\n-  rms[TypeFunc::I_O      ] = RegMask::Empty;\n-  rms[TypeFunc::Memory   ] = RegMask::Empty;\n-  rms[TypeFunc::ReturnAdr] = ret_adr;\n-  rms[TypeFunc::FramePtr ] = fp;\n+  rms[TypeFunc::Control  ].assignFrom(RegMask::EMPTY);\n+  rms[TypeFunc::I_O      ].assignFrom(RegMask::EMPTY);\n+  rms[TypeFunc::Memory   ].assignFrom(RegMask::EMPTY);\n+  rms[TypeFunc::ReturnAdr].assignFrom(ret_adr);\n+  rms[TypeFunc::FramePtr ].assignFrom(fp);\n@@ -507,1 +507,1 @@\n-  C->FIRST_STACK_mask().Clear();\n+  C->FIRST_STACK_mask().clear();\n@@ -512,1 +512,1 @@\n-    C->FIRST_STACK_mask().Insert(i);\n+    C->FIRST_STACK_mask().insert(i);\n@@ -516,1 +516,1 @@\n-  C->FIRST_STACK_mask().Set_All_From(_out_arg_limit);\n+  C->FIRST_STACK_mask().set_all_from(_out_arg_limit);\n@@ -525,1 +525,1 @@\n-  *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];\n+  idealreg2spillmask[Op_RegP]->assignFrom(*idealreg2regmask[Op_RegP]);\n@@ -527,3 +527,3 @@\n-  *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];\n-   idealreg2spillmask[Op_RegN]->OR(C->FIRST_STACK_mask());\n-   idealreg2spillmask[Op_RegP]->OR(aligned_stack_mask);\n+  idealreg2spillmask[Op_RegN]->assignFrom(*idealreg2regmask[Op_RegN]);\n+  idealreg2spillmask[Op_RegN]->or_with(C->FIRST_STACK_mask());\n+  idealreg2spillmask[Op_RegP]->or_with(aligned_stack_mask);\n@@ -531,1 +531,1 @@\n-   idealreg2spillmask[Op_RegP]->OR(C->FIRST_STACK_mask());\n+   idealreg2spillmask[Op_RegP]->or_with(C->FIRST_STACK_mask());\n@@ -533,8 +533,8 @@\n-  *idealreg2spillmask[Op_RegI] = *idealreg2regmask[Op_RegI];\n-   idealreg2spillmask[Op_RegI]->OR(C->FIRST_STACK_mask());\n-  *idealreg2spillmask[Op_RegL] = *idealreg2regmask[Op_RegL];\n-   idealreg2spillmask[Op_RegL]->OR(aligned_stack_mask);\n-  *idealreg2spillmask[Op_RegF] = *idealreg2regmask[Op_RegF];\n-   idealreg2spillmask[Op_RegF]->OR(C->FIRST_STACK_mask());\n-  *idealreg2spillmask[Op_RegD] = *idealreg2regmask[Op_RegD];\n-   idealreg2spillmask[Op_RegD]->OR(aligned_stack_mask);\n+  idealreg2spillmask[Op_RegI]->assignFrom(*idealreg2regmask[Op_RegI]);\n+  idealreg2spillmask[Op_RegI]->or_with(C->FIRST_STACK_mask());\n+  idealreg2spillmask[Op_RegL]->assignFrom(*idealreg2regmask[Op_RegL]);\n+  idealreg2spillmask[Op_RegL]->or_with(aligned_stack_mask);\n+  idealreg2spillmask[Op_RegF]->assignFrom(*idealreg2regmask[Op_RegF]);\n+  idealreg2spillmask[Op_RegF]->or_with(C->FIRST_STACK_mask());\n+  idealreg2spillmask[Op_RegD]->assignFrom(*idealreg2regmask[Op_RegD]);\n+  idealreg2spillmask[Op_RegD]->or_with(aligned_stack_mask);\n@@ -543,2 +543,2 @@\n-    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-     idealreg2spillmask[Op_RegVectMask]->OR(aligned_stack_mask);\n+    idealreg2spillmask[Op_RegVectMask]->assignFrom(*idealreg2regmask[Op_RegVectMask]);\n+    idealreg2spillmask[Op_RegVectMask]->or_with(aligned_stack_mask);\n@@ -546,1 +546,1 @@\n-    *idealreg2spillmask[Op_RegVectMask] = RegMask::Empty;\n+    idealreg2spillmask[Op_RegVectMask]->assignFrom(RegMask::EMPTY);\n@@ -550,2 +550,2 @@\n-    *idealreg2spillmask[Op_VecS] = *idealreg2regmask[Op_VecS];\n-     idealreg2spillmask[Op_VecS]->OR(C->FIRST_STACK_mask());\n+    idealreg2spillmask[Op_VecS]->assignFrom(*idealreg2regmask[Op_VecS]);\n+    idealreg2spillmask[Op_VecS]->or_with(C->FIRST_STACK_mask());\n@@ -553,1 +553,1 @@\n-    *idealreg2spillmask[Op_VecS] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecS]->assignFrom(RegMask::EMPTY);\n@@ -559,2 +559,2 @@\n-    *idealreg2spillmask[Op_VecD] = *idealreg2regmask[Op_VecD];\n-     idealreg2spillmask[Op_VecD]->OR(aligned_stack_mask);\n+    idealreg2spillmask[Op_VecD]->assignFrom(*idealreg2regmask[Op_VecD]);\n+    idealreg2spillmask[Op_VecD]->or_with(aligned_stack_mask);\n@@ -562,1 +562,1 @@\n-    *idealreg2spillmask[Op_VecD] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecD]->assignFrom(RegMask::EMPTY);\n@@ -575,1 +575,1 @@\n-      aligned_stack_mask.Remove(in);\n+      aligned_stack_mask.remove(in);\n@@ -578,4 +578,4 @@\n-     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);\n-     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecX] = *idealreg2regmask[Op_VecX];\n-     idealreg2spillmask[Op_VecX]->OR(aligned_stack_mask);\n+    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);\n+    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecX]->assignFrom(*idealreg2regmask[Op_VecX]);\n+    idealreg2spillmask[Op_VecX]->or_with(aligned_stack_mask);\n@@ -583,1 +583,1 @@\n-    *idealreg2spillmask[Op_VecX] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecX]->assignFrom(RegMask::EMPTY);\n@@ -590,1 +590,1 @@\n-      aligned_stack_mask.Remove(in);\n+      aligned_stack_mask.remove(in);\n@@ -593,4 +593,4 @@\n-     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);\n-     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecY] = *idealreg2regmask[Op_VecY];\n-     idealreg2spillmask[Op_VecY]->OR(aligned_stack_mask);\n+    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);\n+    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecY]->assignFrom(*idealreg2regmask[Op_VecY]);\n+    idealreg2spillmask[Op_VecY]->or_with(aligned_stack_mask);\n@@ -598,1 +598,1 @@\n-    *idealreg2spillmask[Op_VecY] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecY]->assignFrom(RegMask::EMPTY);\n@@ -605,1 +605,1 @@\n-      aligned_stack_mask.Remove(in);\n+      aligned_stack_mask.remove(in);\n@@ -608,4 +608,4 @@\n-     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);\n-     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecZ] = *idealreg2regmask[Op_VecZ];\n-     idealreg2spillmask[Op_VecZ]->OR(aligned_stack_mask);\n+    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);\n+    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecZ]->assignFrom(*idealreg2regmask[Op_VecZ]);\n+    idealreg2spillmask[Op_VecZ]->or_with(aligned_stack_mask);\n@@ -613,1 +613,1 @@\n-    *idealreg2spillmask[Op_VecZ] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecZ]->assignFrom(RegMask::EMPTY);\n@@ -623,1 +623,1 @@\n-        scalable_stack_mask.Remove(in);\n+        scalable_stack_mask.remove(in);\n@@ -630,2 +630,2 @@\n-      *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-      idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+      idealreg2spillmask[Op_RegVectMask]->assignFrom(*idealreg2regmask[Op_RegVectMask]);\n+      idealreg2spillmask[Op_RegVectMask]->or_with(scalable_stack_mask);\n@@ -637,1 +637,1 @@\n-      scalable_stack_mask.Remove(in);\n+      scalable_stack_mask.remove(in);\n@@ -642,4 +642,4 @@\n-     scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n-     assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecA] = *idealreg2regmask[Op_VecA];\n-     idealreg2spillmask[Op_VecA]->OR(scalable_stack_mask);\n+    scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n+    assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecA]->assignFrom(*idealreg2regmask[Op_VecA]);\n+    idealreg2spillmask[Op_VecA]->or_with(scalable_stack_mask);\n@@ -647,1 +647,1 @@\n-    *idealreg2spillmask[Op_VecA] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecA]->assignFrom(RegMask::EMPTY);\n@@ -655,2 +655,2 @@\n-    idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n-    idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n+    idealreg2spillmask[Op_RegI]->or_with(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegF]->or_with(*idealreg2regmask[Op_RegI]);\n@@ -658,4 +658,4 @@\n-    idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n-    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n-    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegN]->or_with(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegL]->or_with(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->or_with(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegP]->or_with(*idealreg2regmask[Op_RegD]);\n@@ -663,1 +663,1 @@\n-    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegP]->or_with(*idealreg2regmask[Op_RegF]);\n@@ -667,2 +667,2 @@\n-    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegL]->or_with(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->or_with(*idealreg2regmask[Op_RegL]);\n@@ -676,14 +676,14 @@\n-  *idealreg2debugmask  [Op_RegN] = *idealreg2spillmask[Op_RegN];\n-  *idealreg2debugmask  [Op_RegI] = *idealreg2spillmask[Op_RegI];\n-  *idealreg2debugmask  [Op_RegL] = *idealreg2spillmask[Op_RegL];\n-  *idealreg2debugmask  [Op_RegF] = *idealreg2spillmask[Op_RegF];\n-  *idealreg2debugmask  [Op_RegD] = *idealreg2spillmask[Op_RegD];\n-  *idealreg2debugmask  [Op_RegP] = *idealreg2spillmask[Op_RegP];\n-  *idealreg2debugmask  [Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n-\n-  *idealreg2debugmask  [Op_VecA] = *idealreg2spillmask[Op_VecA];\n-  *idealreg2debugmask  [Op_VecS] = *idealreg2spillmask[Op_VecS];\n-  *idealreg2debugmask  [Op_VecD] = *idealreg2spillmask[Op_VecD];\n-  *idealreg2debugmask  [Op_VecX] = *idealreg2spillmask[Op_VecX];\n-  *idealreg2debugmask  [Op_VecY] = *idealreg2spillmask[Op_VecY];\n-  *idealreg2debugmask  [Op_VecZ] = *idealreg2spillmask[Op_VecZ];\n+  idealreg2debugmask[Op_RegN]->assignFrom(*idealreg2spillmask[Op_RegN]);\n+  idealreg2debugmask[Op_RegI]->assignFrom(*idealreg2spillmask[Op_RegI]);\n+  idealreg2debugmask[Op_RegL]->assignFrom(*idealreg2spillmask[Op_RegL]);\n+  idealreg2debugmask[Op_RegF]->assignFrom(*idealreg2spillmask[Op_RegF]);\n+  idealreg2debugmask[Op_RegD]->assignFrom(*idealreg2spillmask[Op_RegD]);\n+  idealreg2debugmask[Op_RegP]->assignFrom(*idealreg2spillmask[Op_RegP]);\n+  idealreg2debugmask[Op_RegVectMask]->assignFrom(*idealreg2spillmask[Op_RegVectMask]);\n+\n+  idealreg2debugmask[Op_VecA]->assignFrom(*idealreg2spillmask[Op_VecA]);\n+  idealreg2debugmask[Op_VecS]->assignFrom(*idealreg2spillmask[Op_VecS]);\n+  idealreg2debugmask[Op_VecD]->assignFrom(*idealreg2spillmask[Op_VecD]);\n+  idealreg2debugmask[Op_VecX]->assignFrom(*idealreg2spillmask[Op_VecX]);\n+  idealreg2debugmask[Op_VecY]->assignFrom(*idealreg2spillmask[Op_VecY]);\n+  idealreg2debugmask[Op_VecZ]->assignFrom(*idealreg2spillmask[Op_VecZ]);\n@@ -696,14 +696,14 @@\n-  idealreg2debugmask[Op_RegN]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegI]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegL]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegF]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegD]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegP]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegVectMask]->SUBTRACT(*caller_save_mask);\n-\n-  idealreg2debugmask[Op_VecA]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecS]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecD]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecX]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecY]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecZ]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegN]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegI]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegL]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegF]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegD]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegP]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegVectMask]->subtract(*caller_save_mask);\n+\n+  idealreg2debugmask[Op_VecA]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecS]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecD]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecX]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecY]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecZ]->subtract(*caller_save_mask);\n@@ -738,1 +738,1 @@\n-    ret_rms[i] = _return_values_mask[i-TypeFunc::Parms];\n+    ret_rms[i].assignFrom(_return_values_mask[i-TypeFunc::Parms]);\n@@ -751,1 +751,1 @@\n-    reth_rms[TypeFunc::Parms] = mreg2regmask[reg];\n+    reth_rms[TypeFunc::Parms].assignFrom(mreg2regmask[reg]);\n@@ -754,1 +754,1 @@\n-    reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));\n+    reth_rms[TypeFunc::Parms].insert(OptoReg::add(OptoReg::Name(reg), 1));\n@@ -773,2 +773,2 @@\n-      tail_call_rms[TypeFunc::Parms+0] = m->MachNode::in_RegMask(TypeFunc::Parms+0);\n-      tail_call_rms[TypeFunc::Parms+1] = m->MachNode::in_RegMask(TypeFunc::Parms+1);\n+      tail_call_rms[TypeFunc::Parms + 0].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 0));\n+      tail_call_rms[TypeFunc::Parms + 1].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 1));\n@@ -786,2 +786,2 @@\n-      tail_jump_rms[TypeFunc::Parms+0] = m->MachNode::in_RegMask(TypeFunc::Parms+0);\n-      tail_jump_rms[TypeFunc::Parms+1] = m->MachNode::in_RegMask(TypeFunc::Parms+1);\n+      tail_jump_rms[TypeFunc::Parms + 0].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 0));\n+      tail_jump_rms[TypeFunc::Parms + 1].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 1));\n@@ -820,5 +820,5 @@\n-      ret_rms      [      ret_edge_cnt] = mreg2regmask[i];\n-      reth_rms     [     reth_edge_cnt] = mreg2regmask[i];\n-      tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];\n-      tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];\n-      forw_exc_rms [ forw_exc_edge_cnt] = mreg2regmask[i];\n+      ret_rms      [      ret_edge_cnt].assignFrom(mreg2regmask[i]);\n+      reth_rms     [     reth_edge_cnt].assignFrom(mreg2regmask[i]);\n+      tail_call_rms[tail_call_edge_cnt].assignFrom(mreg2regmask[i]);\n+      tail_jump_rms[tail_jump_edge_cnt].assignFrom(mreg2regmask[i]);\n+      forw_exc_rms [ forw_exc_edge_cnt].assignFrom(mreg2regmask[i]);\n@@ -827,1 +827,1 @@\n-      halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];\n+      halt_rms     [     halt_edge_cnt].assignFrom(*idealreg2spillmask[_register_save_type[i]]);\n@@ -838,6 +838,6 @@\n-        ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));\n-        reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));\n-        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n-        halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));\n+        ret_rms      [      ret_edge_cnt].insert(OptoReg::Name(i+1));\n+        reth_rms     [     reth_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_call_rms[tail_call_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_jump_rms[tail_jump_edge_cnt].insert(OptoReg::Name(i+1));\n+        forw_exc_rms [ forw_exc_edge_cnt].insert(OptoReg::Name(i+1));\n+        halt_rms     [     halt_edge_cnt].insert(OptoReg::Name(i+1));\n@@ -851,6 +851,6 @@\n-        ret_rms      [      ret_edge_cnt] = RegMask::Empty;\n-        reth_rms     [     reth_edge_cnt] = RegMask::Empty;\n-        tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;\n-        tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;\n-        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n-        halt_rms     [     halt_edge_cnt] = RegMask::Empty;\n+        ret_rms      [      ret_edge_cnt].assignFrom(RegMask::EMPTY);\n+        reth_rms     [     reth_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_call_rms[tail_call_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_jump_rms[tail_jump_edge_cnt].assignFrom(RegMask::EMPTY);\n+        forw_exc_rms [ forw_exc_edge_cnt].assignFrom(RegMask::EMPTY);\n+        halt_rms     [     halt_edge_cnt].assignFrom(RegMask::EMPTY);\n@@ -866,6 +866,6 @@\n-        ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));\n-        reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));\n-        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n-        halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));\n+        ret_rms      [      ret_edge_cnt].insert(OptoReg::Name(i+1));\n+        reth_rms     [     reth_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_call_rms[tail_call_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_jump_rms[tail_jump_edge_cnt].insert(OptoReg::Name(i+1));\n+        forw_exc_rms [ forw_exc_edge_cnt].insert(OptoReg::Name(i+1));\n+        halt_rms     [     halt_edge_cnt].insert(OptoReg::Name(i+1));\n@@ -879,6 +879,6 @@\n-        ret_rms      [      ret_edge_cnt] = RegMask::Empty;\n-        reth_rms     [     reth_edge_cnt] = RegMask::Empty;\n-        tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;\n-        tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;\n-        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n-        halt_rms     [     halt_edge_cnt] = RegMask::Empty;\n+        ret_rms      [      ret_edge_cnt].assignFrom(RegMask::EMPTY);\n+        reth_rms     [     reth_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_call_rms[tail_call_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_jump_rms[tail_jump_edge_cnt].assignFrom(RegMask::EMPTY);\n+        forw_exc_rms [ forw_exc_edge_cnt].assignFrom(RegMask::EMPTY);\n+        halt_rms     [     halt_edge_cnt].assignFrom(RegMask::EMPTY);\n@@ -911,1 +911,1 @@\n-  c_frame_ptr_mask = RegMask(c_frame_pointer());\n+  c_frame_ptr_mask.assignFrom(RegMask(c_frame_pointer()));\n@@ -914,1 +914,1 @@\n-  c_frame_ptr_mask.Insert(OptoReg::add(c_frame_pointer(),1));\n+  c_frame_ptr_mask.insert(OptoReg::add(c_frame_pointer(), 1));\n@@ -918,1 +918,1 @@\n-  STACK_ONLY_mask.Clear();\n+  STACK_ONLY_mask.clear();\n@@ -920,1 +920,1 @@\n-  STACK_ONLY_mask.Set_All_From(OptoReg::stack2reg(0));\n+  STACK_ONLY_mask.set_all_from(OptoReg::stack2reg(0));\n@@ -927,1 +927,1 @@\n-    mreg2regmask[i].Insert(i);\n+    mreg2regmask[i].insert(i);\n@@ -932,1 +932,1 @@\n-      caller_save_regmask.Insert(i);\n+      caller_save_regmask.insert(i);\n@@ -938,1 +938,1 @@\n-      caller_save_regmask_exclude_soe.Insert(i);\n+      caller_save_regmask_exclude_soe.insert(i);\n@@ -1280,2 +1280,2 @@\n-  msfpt->_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;\n-  msfpt->_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;\n+  msfpt->_in_rms[TypeFunc::ReturnAdr].assignFrom(_return_addr_mask);\n+  msfpt->_in_rms[TypeFunc::FramePtr ].assignFrom(c_frame_ptr_mask);\n@@ -1358,1 +1358,1 @@\n-          rm->Insert(r);\n+          rm->insert(r);\n@@ -1364,1 +1364,1 @@\n-        rm->Insert( reg1 );\n+        rm->insert( reg1 );\n@@ -1369,1 +1369,1 @@\n-        rm->Insert( reg2 );\n+        rm->insert( reg2 );\n@@ -1387,1 +1387,1 @@\n-    MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );\n+    MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::EMPTY, MachProjNode::fat_proj );\n@@ -1389,1 +1389,1 @@\n-      proj->_rout.Insert(OptoReg::Name(i));\n+      proj->_rout.insert(OptoReg::Name(i));\n@@ -1391,1 +1391,1 @@\n-    if (!proj->_rout.is_Empty()) {\n+    if (!proj->_rout.is_empty()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":157,"deletions":157,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-  static RegMask divI_proj_mask();\n+  static const RegMask& divI_proj_mask();\n@@ -415,1 +415,1 @@\n-  static RegMask modI_proj_mask();\n+  static const RegMask& modI_proj_mask();\n@@ -418,1 +418,1 @@\n-  static RegMask divL_proj_mask();\n+  static const RegMask& divL_proj_mask();\n@@ -420,1 +420,1 @@\n-  static RegMask modL_proj_mask();\n+  static const RegMask& modL_proj_mask();\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4552,1 +4552,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this, proj->_con, RegMask::EMPTY, MachProjNode::unmatched_proj);\n@@ -4799,1 +4799,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -6023,1 +6023,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -188,1 +188,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2813,1 +2813,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -2818,1 +2818,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -564,0 +564,1 @@\n+  { \"ShenandoahPacing\",             JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1936,2 +1936,1 @@\n-#if INCLUDE_JVMCI\n-address Deoptimization::deoptimize_for_missing_exception_handler(nmethod* nm) {\n+address Deoptimization::deoptimize_for_missing_exception_handler(nmethod* nm, bool make_not_entrant) {\n@@ -1939,1 +1938,3 @@\n-  nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n+  if (make_not_entrant) {\n+    nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n+  }\n@@ -1953,0 +1954,9 @@\n+\n+  Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);\n+\n+  if (!nm->is_compiled_by_jvmci()) {\n+    return SharedRuntime::deopt_blob()->unpack_with_exception_in_tls();\n+  }\n+\n+#if INCLUDE_JVMCI\n+  \/\/ JVMCI support\n@@ -1968,1 +1978,0 @@\n-  Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);\n@@ -1974,0 +1983,1 @@\n+#endif\n@@ -1977,1 +1987,0 @@\n-#endif\n@@ -2880,0 +2889,1 @@\n+  \"not_compiled_exception_handler\",\n@@ -2883,1 +2893,0 @@\n-  \"not_compiled_exception_handler\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,1 @@\n+    Reason_not_compiled_exception_handler, \/\/ missing compiled exception handler\n@@ -124,1 +125,0 @@\n-    Reason_not_compiled_exception_handler,\n@@ -187,0 +187,1 @@\n+  static address deoptimize_for_missing_exception_handler(nmethod* nm, bool make_not_entrant);\n@@ -188,1 +189,0 @@\n-  static address deoptimize_for_missing_exception_handler(nmethod* nm);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -539,1 +539,0 @@\n-  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n@@ -1363,3 +1362,0 @@\n-  \/\/ Verify that the deferred card marks have been flushed.\n-  assert(deferred_card_mark().is_empty(), \"Should be empty during GC\");\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,5 +153,0 @@\n-  \/\/ See ReduceInitialCardMarks: this holds the precise space interval of\n-  \/\/ the most recent slow path allocation for which compiled code has\n-  \/\/ elided card-marks for performance along the fast-path.\n-  MemRegion     _deferred_card_mark;\n-\n@@ -783,3 +778,0 @@\n-  MemRegion deferred_card_mark() const           { return _deferred_card_mark; }\n-  void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -800,1 +800,2 @@\n-      return Deoptimization::deoptimize_for_missing_exception_handler(nm);\n+      bool make_not_entrant = true;\n+      return Deoptimization::deoptimize_for_missing_exception_handler(nm, make_not_entrant);\n@@ -856,0 +857,9 @@\n+\n+  \/\/ If the compiler did not anticipate a recursive exception, resulting in an exception\n+  \/\/ thrown from the catch bci, then the compiled exception handler might be missing.\n+  \/\/ This is rare.  Just deoptimize and let the interpreter handle it.\n+  if (t == nullptr && recursive_exception_occurred) {\n+    bool make_not_entrant = false;\n+    return Deoptimization::deoptimize_for_missing_exception_handler(nm, make_not_entrant);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -392,4 +392,0 @@\n-  static bool handle_ic_miss_helper_internal(Handle receiver, nmethod* caller_nm, const frame& caller_frame,\n-                                             methodHandle callee_method, Bytecodes::Code bc, CallInfo& call_info,\n-                                             bool& needs_ic_stub_refill, bool& is_optimized, bool caller_is_c1, TRAPS);\n-\n@@ -569,1 +565,0 @@\n-  static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -346,0 +346,5 @@\n+  \/\/ This is before the execution of the very first Java bytecode.\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::link_classes(THREAD);\n+  }\n+\n@@ -746,0 +751,4 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    nmethod::post_delayed_compiled_method_load_events();\n+  }\n+\n@@ -778,1 +787,1 @@\n-    AOTLinkedClassBulkLoader::link_or_init_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::init_javabase_classes(THREAD);\n@@ -797,1 +806,1 @@\n-    AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::init_non_javabase_classes(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -801,1 +802,2 @@\n-  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)\n+  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)                               \\\n+  static_field(ContinuationEntry,              _return_pc,                                    address)\n@@ -1278,0 +1280,1 @@\n+  declare_toplevel_type(ContinuationEntry)                                \\\n@@ -1586,0 +1589,1 @@\n+  declare_constant(Deoptimization::Reason_not_compiled_exception_handler) \\\n@@ -1587,1 +1591,0 @@\n-  NOT_ZERO(JVMCI_ONLY(declare_constant(Deoptimization::Reason_not_compiled_exception_handler))) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -379,1 +379,3 @@\n-    return \"Print all threads with stacktraces.\";\n+    return \"Print all platform threads, and mounted virtual threads, \"\n+           \"with stack traces. The Thread.dump_to_file command will \"\n+           \"print all threads to a file.\";\n@@ -791,1 +793,2 @@\n-    return \"Dump threads, with stack traces, to a file in plain text or JSON format.\";\n+    return \"Dump all threads, with stack traces, \"\n+           \"to a file in plain text or JSON format.\";\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n- * @author  Nakul Saraiya\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,3 +364,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Joseph D. Darcy\n@@ -708,1 +705,0 @@\n-     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,3 +82,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Joseph D. Darcy\n@@ -424,1 +421,0 @@\n-     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Josh Bloch\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,4 +82,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Josh Bloch\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n- * @author  Nakul Saraiya\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.Opcode;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +39,1 @@\n+import java.lang.reflect.Modifier;\n@@ -40,0 +46,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -61,3 +69,3 @@\n-    private static final MethodHandle OBJECTS_EQUALS;\n-    private static final MethodHandle OBJECTS_HASHCODE;\n-    private static final MethodHandle OBJECTS_TOSTRING;\n+    private static final MethodHandle IS_NULL;\n+    private static final MethodHandle IS_ARG0_NULL;\n+    private static final MethodHandle IS_ARG1_NULL;\n@@ -66,0 +74,4 @@\n+    private static final MethodType MT_OBJECT_BOOLEAN = MethodType.methodType(boolean.class, Object.class);\n+    private static final MethodType MT_INT = MethodType.methodType(int.class);\n+    private static final MethodTypeDesc MTD_OBJECT_BOOLEAN = MethodTypeDesc.of(CD_boolean, CD_Object);\n+    private static final MethodTypeDesc MTD_INT = MethodTypeDesc.of(CD_int);\n@@ -71,1 +83,0 @@\n-    private static final HashMap<Class<?>, MethodHandle> primitiveToString = new HashMap<>();\n@@ -81,6 +92,6 @@\n-            OBJECTS_EQUALS = publicLookup.findStatic(Objects.class, \"equals\",\n-                                                     MethodType.methodType(boolean.class, Object.class, Object.class));\n-            OBJECTS_HASHCODE = publicLookup.findStatic(Objects.class, \"hashCode\",\n-                                                       MethodType.methodType(int.class, Object.class));\n-            OBJECTS_TOSTRING = publicLookup.findStatic(Objects.class, \"toString\",\n-                                                       MethodType.methodType(String.class, Object.class));\n+\n+            var objectsIsNull = publicLookup.findStatic(Objects.class, \"isNull\",\n+                                                        MethodType.methodType(boolean.class, Object.class));\n+            IS_NULL = objectsIsNull;\n+            IS_ARG0_NULL = MethodHandles.dropArguments(objectsIsNull, 1, Object.class);\n+            IS_ARG1_NULL = MethodHandles.dropArguments(objectsIsNull, 0, Object.class);\n@@ -126,17 +137,0 @@\n-\n-            primitiveToString.put(byte.class, lookup.findStatic(Byte.class, \"toString\",\n-                                                                MethodType.methodType(String.class, byte.class)));\n-            primitiveToString.put(short.class, lookup.findStatic(Short.class, \"toString\",\n-                                                                 MethodType.methodType(String.class, short.class)));\n-            primitiveToString.put(char.class, lookup.findStatic(Character.class, \"toString\",\n-                                                                MethodType.methodType(String.class, char.class)));\n-            primitiveToString.put(int.class, lookup.findStatic(Integer.class, \"toString\",\n-                                                               MethodType.methodType(String.class, int.class)));\n-            primitiveToString.put(long.class, lookup.findStatic(Long.class, \"toString\",\n-                                                                MethodType.methodType(String.class, long.class)));\n-            primitiveToString.put(float.class, lookup.findStatic(Float.class, \"toString\",\n-                                                                 MethodType.methodType(String.class, float.class)));\n-            primitiveToString.put(double.class, lookup.findStatic(Double.class, \"toString\",\n-                                                                  MethodType.methodType(String.class, double.class)));\n-            primitiveToString.put(boolean.class, lookup.findStatic(Boolean.class, \"toString\",\n-                                                                   MethodType.methodType(String.class, boolean.class)));\n@@ -164,4 +158,7 @@\n-    private static MethodHandle equalator(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveEquals.get(clazz)\n-                : OBJECTS_EQUALS.asType(MethodType.methodType(boolean.class, clazz, clazz)));\n+    private static MethodHandle equalator(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n+        if (clazz.isPrimitive())\n+            return primitiveEquals.get(clazz);\n+        MethodType mt = MethodType.methodType(boolean.class, clazz, clazz);\n+        return MethodHandles.guardWithTest(IS_ARG0_NULL.asType(mt),\n+                                           IS_ARG1_NULL.asType(mt),\n+                                           lookup.findVirtual(clazz, \"equals\", MT_OBJECT_BOOLEAN).asType(mt));\n@@ -171,4 +168,7 @@\n-    private static MethodHandle hasher(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveHashers.get(clazz)\n-                : OBJECTS_HASHCODE.asType(MethodType.methodType(int.class, clazz)));\n+    private static MethodHandle hasher(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n+        if (clazz.isPrimitive())\n+            return primitiveHashers.get(clazz);\n+        MethodType mt = MethodType.methodType(int.class, clazz);\n+        return MethodHandles.guardWithTest(IS_NULL.asType(MethodType.methodType(boolean.class, clazz)),\n+                                           MethodHandles.dropArguments(MethodHandles.zero(int.class), 0, clazz),\n+                                           lookup.findVirtual(clazz, \"hashCode\", MT_INT).asType(mt));\n@@ -177,5 +177,16 @@\n-    \/** Get the stringifier for a value of a given type *\/\n-    private static MethodHandle stringifier(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveToString.get(clazz)\n-                : OBJECTS_TOSTRING.asType(MethodType.methodType(String.class, clazz)));\n+    \/\/ If this type must be a monomorphic receiver, that is, one that has no\n+    \/\/ subtypes in the JVM.  For example, Object-typed fields may have a more\n+    \/\/ specific one type at runtime and thus need optimizations.\n+    private static boolean isMonomorphic(Class<?> type) {\n+        \/\/ Includes primitives and final classes, but not arrays.\n+        \/\/ All array classes are reported to be final, but Object[] can have subtypes like String[]\n+        return Modifier.isFinal(type.getModifiers()) && !type.isArray();\n+    }\n+\n+    private static String specializerClassName(Class<?> targetClass, String kind) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$\" + kind + \"Specializer\";\n@@ -190,2 +201,2 @@\n-    private static MethodHandle makeEquals(Class<?> receiverClass,\n-                                          List<MethodHandle> getters) {\n+    private static MethodHandle makeEquals(MethodHandles.Lookup lookup, Class<?> receiverClass,\n+                                           List<MethodHandle> getters) throws Throwable {\n@@ -200,2 +211,64 @@\n-        for (MethodHandle getter : getters) {\n-            MethodHandle equalator = equalator(getter.type().returnType()); \/\/ (TT)Z\n+        int size = getters.size();\n+        MethodHandle[] equalators = new MethodHandle[size];\n+        boolean hasPolymorphism = false;\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            var type = getter.type().returnType();\n+            if (isMonomorphic(type)) {\n+                equalators[i] = equalator(lookup, type);\n+            } else {\n+                hasPolymorphism = true;\n+            }\n+        }\n+\n+        \/\/ Currently, hotspot does not support polymorphic inlining.\n+        \/\/ As a result, if we have a MethodHandle to Object.equals,\n+        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n+        \/\/ and we must spin bytecode to accomplish separate profiling.\n+        if (hasPolymorphism) {\n+            String[] names = new String[size];\n+\n+            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n+            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Equalator\")), clb -> {\n+                for (int i = 0; i < size; i++) {\n+                    if (equalators[i] == null) {\n+                        var name = \"equalator\".concat(Integer.toString(i));\n+                        names[i] = name;\n+                        var type = getters.get(i).type().returnType();\n+                        boolean isInterface = type.isInterface();\n+                        var typeDesc = type.describeConstable().orElseThrow();\n+                        clb.withMethodBody(name, MethodTypeDesc.of(CD_boolean, typeDesc, typeDesc), ACC_STATIC, cob -> {\n+                            var nonNullPath = cob.newLabel();\n+                            var fail = cob.newLabel();\n+                            cob.aload(0)\n+                               .ifnonnull(nonNullPath)\n+                               .aload(1)\n+                               .ifnonnull(fail)\n+                               .iconst_1() \/\/ arg0 null, arg1 null\n+                               .ireturn()\n+                               .labelBinding(fail)\n+                               .iconst_0() \/\/ arg0 null, arg1 non-null\n+                               .ireturn()\n+                               .labelBinding(nonNullPath)\n+                               .aload(0) \/\/ arg0.equals(arg1) - bytecode subject to customized profiling\n+                               .aload(1)\n+                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"equals\", MTD_OBJECT_BOOLEAN, isInterface)\n+                               .ireturn();\n+                        });\n+                    }\n+                }\n+            });\n+\n+            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n+\n+            for (int i = 0; i < size; i++) {\n+                if (equalators[i] == null) {\n+                    var type = getters.get(i).type().returnType();\n+                    equalators[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(boolean.class, type, type));\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            MethodHandle equalator = equalators[i]; \/\/ (TT)Z\n@@ -217,2 +290,2 @@\n-    private static MethodHandle makeHashCode(Class<?> receiverClass,\n-                                            List<MethodHandle> getters) {\n+    private static MethodHandle makeHashCode(MethodHandles.Lookup lookup, Class<?> receiverClass,\n+                                             List<MethodHandle> getters) throws Throwable {\n@@ -221,0 +294,54 @@\n+        int size = getters.size();\n+        MethodHandle[] hashers = new MethodHandle[size];\n+        boolean hasPolymorphism = false;\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            var type = getter.type().returnType();\n+            if (isMonomorphic(type)) {\n+                hashers[i] = hasher(lookup, type);\n+            } else {\n+                hasPolymorphism = true;\n+            }\n+        }\n+\n+        \/\/ Currently, hotspot does not support polymorphic inlining.\n+        \/\/ As a result, if we have a MethodHandle to Object.hashCode,\n+        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n+        \/\/ and we must spin bytecode to accomplish separate profiling.\n+        if (hasPolymorphism) {\n+            String[] names = new String[size];\n+\n+            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n+            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Hasher\")), clb -> {\n+                for (int i = 0; i < size; i++) {\n+                    if (hashers[i] == null) {\n+                        var name = \"hasher\".concat(Integer.toString(i));\n+                        names[i] = name;\n+                        var type = getters.get(i).type().returnType();\n+                        boolean isInterface = type.isInterface();\n+                        var typeDesc = type.describeConstable().orElseThrow();\n+                        clb.withMethodBody(name, MethodTypeDesc.of(CD_int, typeDesc), ACC_STATIC, cob -> {\n+                            var nonNullPath = cob.newLabel();\n+                            cob.aload(0)\n+                               .ifnonnull(nonNullPath)\n+                               .iconst_0() \/\/ null hash is 0\n+                               .ireturn()\n+                               .labelBinding(nonNullPath)\n+                               .aload(0) \/\/ arg0.hashCode() - bytecode subject to customized profiling\n+                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"hashCode\", MTD_INT, isInterface)\n+                               .ireturn();\n+                        });\n+                    }\n+                }\n+            });\n+\n+            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n+\n+            for (int i = 0; i < size; i++) {\n+                if (hashers[i] == null) {\n+                    var type = getters.get(i).type().returnType();\n+                    hashers[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(int.class, type));\n+                }\n+            }\n+        }\n+\n@@ -222,2 +349,3 @@\n-        for (MethodHandle getter : getters) {\n-            MethodHandle hasher = hasher(getter.type().returnType()); \/\/ (T)I\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            MethodHandle hasher = hashers[i]; \/\/ (T)I\n@@ -416,1 +544,1 @@\n-                yield makeEquals(recordClass, getterList);\n+                yield makeEquals(lookup, recordClass, getterList);\n@@ -421,1 +549,1 @@\n-                yield makeHashCode(recordClass, getterList);\n+                yield makeHashCode(lookup, recordClass, getterList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":178,"deletions":50,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -149,0 +149,31 @@\n+    \/**\n+     * The minimum supported {@code Duration}, which is {@link Long#MIN_VALUE}\n+     * seconds.\n+     *\n+     * @apiNote This constant represents the smallest possible instance of\n+     * {@code Duration}. Since {@code Duration} is directed, the smallest\n+     * possible duration is negative.\n+     *\n+     * The constant is intended to be used as a sentinel value or in tests.\n+     * Care should be taken when performing arithmetic on {@code MIN} as there\n+     * is a high risk that {@link ArithmeticException} or {@link DateTimeException}\n+     * will be thrown.\n+     *\n+     * @since 26\n+     *\/\n+    public static final Duration MIN = new Duration(Long.MIN_VALUE, 0);\n+    \/**\n+     * The maximum supported {@code Duration}, which is {@link Long#MAX_VALUE}\n+     * seconds and {@code 999,999,999} nanoseconds.\n+     *\n+     * @apiNote This constant represents the largest possible instance of\n+     * {@code Duration}.\n+     *\n+     * The constant is intended to be used as a sentinel value or in tests.\n+     * Care should be taken when performing arithmetic on {@code MAX} as there\n+     * is a high risk that {@link ArithmeticException} or {@link DateTimeException}\n+     * will be thrown.\n+     *\n+     * @since 26\n+     *\/\n+    public static final Duration MAX = new Duration(Long.MAX_VALUE, 999_999_999);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -398,1 +398,2 @@\n-static jboolean isLegalTarget(context_type *, int offset);\n+static jboolean isLegalOffset(context_type *, int bci, int offset);\n+static jboolean isLegalTarget(context_type *, int target);\n@@ -1157,2 +1158,1 @@\n-        int target = offset + jump;\n-        if (!isLegalTarget(context, target))\n+        if (!isLegalOffset(context, offset, jump))\n@@ -1160,0 +1160,1 @@\n+        int target = offset + jump;\n@@ -1173,2 +1174,1 @@\n-        int target = offset + jump;\n-        if (!isLegalTarget(context, target))\n+        if (!isLegalOffset(context, offset, jump))\n@@ -1176,0 +1176,1 @@\n+        int target = offset + jump;\n@@ -1214,1 +1215,2 @@\n-        if (!isLegalTarget(context, offset + _ck_ntohl(lpc[0])))\n+        int jump = _ck_ntohl(lpc[0]);\n+        if (!isLegalOffset(context, offset, jump))\n@@ -1216,1 +1218,2 @@\n-        saved_operand[keys + 1] = code_data[offset + _ck_ntohl(lpc[0])];\n+        int target = offset + jump;\n+        saved_operand[keys + 1] = code_data[target];\n@@ -1218,2 +1221,2 @@\n-            int target = offset + _ck_ntohl(lptr[0]);\n-            if (!isLegalTarget(context, target))\n+            jump = _ck_ntohl(lptr[0]);\n+            if (!isLegalOffset(context, offset, jump))\n@@ -1221,0 +1224,1 @@\n+            target = offset + jump;\n@@ -1749,1 +1753,10 @@\n-isLegalTarget(context_type *context, int offset)\n+isLegalTarget(context_type *context, int target)\n+{\n+    int code_length = context->code_length;\n+    int *code_data = context->code_data;\n+    return (target >= 0 && target < code_length && code_data[target] >= 0);\n+}\n+\n+\/* Given a bci and offset, make sure the offset is valid and the target is legal *\/\n+static jboolean\n+isLegalOffset(context_type *context, int bci, int offset)\n@@ -1753,1 +1766,5 @@\n-    return (offset >= 0 && offset < code_length && code_data[offset] >= 0);\n+    int max_offset = 65535; \/\/ JVMS 4.11\n+    int min_offset = -65535;\n+    if (offset < min_offset || offset > max_offset) return JNI_FALSE;\n+    int target = bci + offset;\n+    return (target >= 0 && target < code_length && code_data[target] >= 0);\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n-import java.util.LinkedHashSet;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.HashSet;\n+import java.util.LinkedHashSet;\n@@ -55,2 +52,0 @@\n-import com.sun.tools.javac.code.Kinds.Kind;\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -63,6 +58,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import static java.util.stream.Collectors.groupingBy;\n@@ -217,0 +206,1 @@\n+    private final ExhaustivenessComputer exhaustiveness;\n@@ -218,1 +208,0 @@\n-    private final Infer infer;\n@@ -342,1 +331,0 @@\n-        infer = Infer.instance(context);\n@@ -350,0 +338,1 @@\n+        exhaustiveness = ExhaustivenessComputer.instance(context);\n@@ -739,1 +728,1 @@\n-                tree.isExhaustive |= exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive |= exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -778,1 +767,1 @@\n-                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive = exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -788,423 +777,0 @@\n-        private boolean exhausts(JCExpression selector, List<JCCase> cases) {\n-            Set<PatternDescription> patternSet = new HashSet<>();\n-            Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n-            Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n-            for (JCCase c : cases) {\n-                if (!TreeInfo.unguardedCase(c))\n-                    continue;\n-\n-                for (var l : c.labels) {\n-                    if (l instanceof JCPatternCaseLabel patternLabel) {\n-                        for (Type component : components(selector.type)) {\n-                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n-                        }\n-                    } else if (l instanceof JCConstantCaseLabel constantLabel) {\n-                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n-                            Object value = ((JCLiteral) constantLabel.expr).value;\n-                            booleanLiterals.remove(value);\n-                        } else {\n-                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                            if (s != null && s.isEnum()) {\n-                                enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                    Set<Symbol> result = new HashSet<>();\n-                                    s.owner.members()\n-                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                            .forEach(result::add);\n-                                    return result;\n-                                }).remove(s);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n-                return true;\n-            }\n-\n-            for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n-                if (e.getValue().isEmpty()) {\n-                    patternSet.add(new BindingPattern(e.getKey().type));\n-                }\n-            }\n-            Set<PatternDescription> patterns = patternSet;\n-            boolean useHashes = true;\n-            try {\n-                boolean repeat = true;\n-                while (repeat) {\n-                    Set<PatternDescription> updatedPatterns;\n-                    updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                    repeat = !updatedPatterns.equals(patterns);\n-                    if (checkCovered(selector.type, patterns)) {\n-                        return true;\n-                    }\n-                    if (!repeat) {\n-                        \/\/there may be situation like:\n-                        \/\/class B permits S1, S2\n-                        \/\/patterns: R(S1, B), R(S2, S2)\n-                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n-                        \/\/but hashing in reduceNestedPatterns will not allow that\n-                        \/\/disable the use of hashing, and use subtyping in\n-                        \/\/reduceNestedPatterns to handle situations like this:\n-                        repeat = useHashes;\n-                        useHashes = false;\n-                    } else {\n-                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n-                        \/\/is enabled, as the hashing speeds up the process significantly:\n-                        useHashes = true;\n-                    }\n-                    patterns = updatedPatterns;\n-                }\n-                return checkCovered(selector.type, patterns);\n-            } catch (CompletionFailure cf) {\n-                chk.completionError(selector.pos(), cf);\n-                return true; \/\/error recovery\n-            }\n-        }\n-\n-        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n-            for (Type seltypeComponent : components(seltype)) {\n-                for (PatternDescription pd : patterns) {\n-                    if(isBpCovered(seltypeComponent, pd)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        private List<Type> components(Type seltype) {\n-            return switch (seltype.getTag()) {\n-                case CLASS -> {\n-                    if (seltype.isCompound()) {\n-                        if (seltype.isIntersection()) {\n-                            yield ((Type.IntersectionClassType) seltype).getComponents()\n-                                                                        .stream()\n-                                                                        .flatMap(t -> components(t).stream())\n-                                                                        .collect(List.collector());\n-                        }\n-                        yield List.nil();\n-                    }\n-                    yield List.of(types.erasure(seltype));\n-                }\n-                case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n-                default -> List.of(types.erasure(seltype));\n-            };\n-        }\n-\n-        \/* In a set of patterns, search for a sub-set of binding patterns that\n-         * in combination exhaust their sealed supertype. If such a sub-set\n-         * is found, it is removed, and replaced with a binding pattern\n-         * for the sealed supertype.\n-         *\/\n-        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-\n-            for (PatternDescription pdOne : patterns) {\n-                if (pdOne instanceof BindingPattern bpOne) {\n-                    Set<PatternDescription> toAdd = new HashSet<>();\n-\n-                    for (Type sup : types.directSupertypes(bpOne.type)) {\n-                        ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n-\n-                        clazz.complete();\n-\n-                        if (clazz.isSealed() && clazz.isAbstract() &&\n-                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n-                            !existingBindings.contains(clazz)) {\n-                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n-                            \/\/do not reduce to types unrelated to the selector type:\n-                            Type clazzErasure = types.erasure(clazz.type);\n-                            if (components(selectorType).stream()\n-                                                        .map(types::erasure)\n-                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n-                                continue;\n-                            }\n-\n-                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n-                                Type instantiated;\n-                                if (csym.type.allparams().isEmpty()) {\n-                                    instantiated = csym.type;\n-                                } else {\n-                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n-                                }\n-\n-                                return instantiated != null && types.isCastable(selectorType, instantiated);\n-                            });\n-\n-                            for (PatternDescription pdOther : patterns) {\n-                                if (pdOther instanceof BindingPattern bpOther) {\n-                                    Set<Symbol> currentPermittedSubTypes =\n-                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n-\n-                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n-                                        Symbol perm = it.next();\n-\n-                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n-                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                                types.erasure(perm.type))) {\n-                                                it.remove();\n-                                                continue PERMITTED;\n-                                            }\n-                                        }\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n-                                            it.remove();\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            if (permitted.isEmpty()) {\n-                                toAdd.add(new BindingPattern(clazz.type));\n-                            }\n-                        }\n-                    }\n-\n-                    if (!toAdd.isEmpty()) {\n-                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n-                        newPatterns.addAll(toAdd);\n-                        return newPatterns;\n-                    }\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n-            Set<Symbol> permitted = new HashSet<>();\n-            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n-\n-            while (permittedSubtypesClosure.nonEmpty()) {\n-                ClassSymbol current = permittedSubtypesClosure.head;\n-\n-                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n-\n-                current.complete();\n-\n-                if (current.isSealed() && current.isAbstract()) {\n-                    for (Type t : current.getPermittedSubclasses()) {\n-                        ClassSymbol csym = (ClassSymbol) t.tsym;\n-\n-                        if (accept.test(csym)) {\n-                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n-                            permitted.add(csym);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            return permitted;\n-        }\n-\n-        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n-            if (root instanceof ClassSymbol clazz) {\n-                return List.of(clazz);\n-            } else if (root instanceof TypeVariableSymbol tvar) {\n-                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n-                for (Type bound : tvar.getBounds()) {\n-                    result.appendList(baseClasses(bound.tsym));\n-                }\n-                return result.toList();\n-            } else {\n-                return List.nil();\n-            }\n-        }\n-\n-        \/* Among the set of patterns, find sub-set of patterns such:\n-         * $record($prefix$, $nested, $suffix$)\n-         * Where $record, $prefix$ and $suffix$ is the same for each pattern\n-         * in the set, and the patterns only differ in one \"column\" in\n-         * the $nested pattern.\n-         * Then, the set of $nested patterns is taken, and passed recursively\n-         * to reduceNestedPatterns and to reduceBindingPatterns, to\n-         * simplify the pattern. If that succeeds, the original found sub-set\n-         * of patterns is replaced with a new set of patterns of the form:\n-         * $record($prefix$, $resultOfReduction, $suffix$)\n-         *\n-         * useHashes: when true, patterns will be subject to exact equivalence;\n-         *            when false, two binding patterns will be considered equivalent\n-         *            if one of them is more generic than the other one;\n-         *            when false, the processing will be significantly slower,\n-         *            as pattern hashes cannot be used to speed up the matching process\n-         *\/\n-        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n-                                                             boolean useHashes) {\n-            \/* implementation note:\n-             * finding a sub-set of patterns that only differ in a single\n-             * column is time-consuming task, so this method speeds it up by:\n-             * - group the patterns by their record class\n-             * - for each column (nested pattern) do:\n-             * -- group patterns by their hash\n-             * -- in each such by-hash group, find sub-sets that only differ in\n-             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n-             *    on patterns in the chosen column, as described above\n-             *\/\n-            var groupByRecordClass =\n-                    patterns.stream()\n-                            .filter(pd -> pd instanceof RecordPattern)\n-                            .map(pd -> (RecordPattern) pd)\n-                            .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n-\n-            for (var e : groupByRecordClass.entrySet()) {\n-                int nestedPatternsCount = e.getKey().getRecordComponents().size();\n-                Set<RecordPattern> current = new HashSet<>(e.getValue());\n-\n-                for (int mismatchingCandidate = 0;\n-                     mismatchingCandidate < nestedPatternsCount;\n-                     mismatchingCandidate++) {\n-                    int mismatchingCandidateFin = mismatchingCandidate;\n-                    var groupEquivalenceCandidates =\n-                            current\n-                             .stream()\n-                             \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                             .filter(pd -> pd.nested.length == nestedPatternsCount)\n-                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n-                    for (var candidates : groupEquivalenceCandidates.values()) {\n-                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n-\n-                        for (int firstCandidate = 0;\n-                             firstCandidate < candidatesArr.length;\n-                             firstCandidate++) {\n-                            RecordPattern rpOne = candidatesArr[firstCandidate];\n-                            ListBuffer<RecordPattern> join = new ListBuffer<>();\n-\n-                            join.append(rpOne);\n-\n-                            NEXT_PATTERN: for (int nextCandidate = 0;\n-                                               nextCandidate < candidatesArr.length;\n-                                               nextCandidate++) {\n-                                if (firstCandidate == nextCandidate) {\n-                                    continue;\n-                                }\n-\n-                                RecordPattern rpOther = candidatesArr[nextCandidate];\n-                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                    for (int i = 0; i < rpOne.nested.length; i++) {\n-                                        if (i != mismatchingCandidate) {\n-                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                                if (useHashes ||\n-                                                    \/\/when not using hashes,\n-                                                    \/\/check if rpOne.nested[i] is\n-                                                    \/\/a subtype of rpOther.nested[i]:\n-                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                    join.append(rpOther);\n-                                }\n-                            }\n-\n-                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n-\n-                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                            updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n-\n-                            if (!nestedPatterns.equals(updatedPatterns)) {\n-                                if (useHashes) {\n-                                    current.removeAll(join);\n-                                }\n-\n-                                for (PatternDescription nested : updatedPatterns) {\n-                                    PatternDescription[] newNested =\n-                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    newNested[mismatchingCandidateFin] = nested;\n-                                    current.add(new RecordPattern(rpOne.recordType(),\n-                                                                    rpOne.fullComponentTypes(),\n-                                                                    newNested));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (!current.equals(new HashSet<>(e.getValue()))) {\n-                    Set<PatternDescription> result = new HashSet<>(patterns);\n-                    result.removeAll(e.getValue());\n-                    result.addAll(current);\n-                    return result;\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        \/* In the set of patterns, find those for which, given:\n-         * $record($nested1, $nested2, ...)\n-         * all the $nestedX pattern cover the given record component,\n-         * and replace those with a simple binding pattern over $record.\n-         *\/\n-        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n-            var newPatterns = new HashSet<PatternDescription>();\n-            boolean modified = false;\n-            for (PatternDescription pd : patterns) {\n-                if (pd instanceof RecordPattern rpOne) {\n-                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n-                    if (reducedPattern != rpOne) {\n-                        newPatterns.add(reducedPattern);\n-                        modified = true;\n-                        continue;\n-                    }\n-                }\n-                newPatterns.add(pd);\n-            }\n-            return modified ? newPatterns : patterns;\n-        }\n-\n-        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n-            if (pattern instanceof RecordPattern rpOne) {\n-                Type[] componentType = rpOne.fullComponentTypes();\n-                \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                if (componentType.length != rpOne.nested.length) {\n-                    return pattern;\n-                }\n-                PatternDescription[] reducedNestedPatterns = null;\n-                boolean covered = true;\n-                for (int i = 0; i < componentType.length; i++) {\n-                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n-                    if (newNested != rpOne.nested[i]) {\n-                        if (reducedNestedPatterns == null) {\n-                            reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                        }\n-                        reducedNestedPatterns[i] = newNested;\n-                    }\n-\n-                    covered &= checkCovered(componentType[i], List.of(newNested));\n-                }\n-                if (covered) {\n-                    return new BindingPattern(rpOne.recordType);\n-                } else if (reducedNestedPatterns != null) {\n-                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n-                }\n-            }\n-            return pattern;\n-        }\n-\n-        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-            Set<PatternDescription> result = new HashSet<>(patterns);\n-\n-            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n-                PatternDescription pd = it.next();\n-                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n-                    it.remove();\n-                }\n-            }\n-\n-            return result;\n-        }\n-\n@@ -1356,12 +922,0 @@\n-    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n-        if (newNested instanceof BindingPattern bp) {\n-            Type seltype = types.erasure(componentType);\n-            Type pattype = types.erasure(bp.type);\n-\n-            return seltype.isPrimitive() ?\n-                    types.isUnconditionallyExact(seltype, pattype) :\n-                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n-        }\n-        return false;\n-    }\n-\n@@ -3551,89 +3105,0 @@\n-    sealed interface PatternDescription { }\n-    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n-        if (pattern instanceof JCBindingPattern binding) {\n-            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n-                    ? selectorType : binding.type;\n-            return new BindingPattern(type);\n-        } else if (pattern instanceof JCRecordPattern record) {\n-            Type[] componentTypes;\n-\n-            if (!record.type.isErroneous()) {\n-                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                        .map(r -> types.memberType(record.type, r))\n-                        .toArray(s -> new Type[s]);\n-            }\n-            else {\n-                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n-            }\n-\n-            PatternDescription[] nestedDescriptions =\n-                    new PatternDescription[record.nested.size()];\n-            int i = 0;\n-            for (List<JCPattern> it = record.nested;\n-                 it.nonEmpty();\n-                 it = it.tail, i++) {\n-                Type componentType = i < componentTypes.length ? componentTypes[i]\n-                                                               : syms.errType;\n-                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n-            }\n-            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n-        } else if (pattern instanceof JCAnyPattern) {\n-            return new BindingPattern(selectorType);\n-        } else {\n-            throw Assert.error();\n-        }\n-    }\n-    record BindingPattern(Type type) implements PatternDescription {\n-        @Override\n-        public int hashCode() {\n-            return type.tsym.hashCode();\n-        }\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof BindingPattern other &&\n-                    type.tsym == other.type.tsym;\n-        }\n-        @Override\n-        public String toString() {\n-            return type.tsym + \" _\";\n-        }\n-    }\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n-\n-        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return _hashCode;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof RecordPattern other &&\n-                    recordType.tsym == other.recordType.tsym &&\n-                    Arrays.equals(nested, other.nested);\n-        }\n-\n-        public int hashCode(int excludeComponent) {\n-            return hashCode(excludeComponent, recordType, nested);\n-        }\n-\n-        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n-            int hash = 5;\n-            hash =  41 * hash + recordType.tsym.hashCode();\n-            for (int  i = 0; i < nested.length; i++) {\n-                if (i != excludeComponent) {\n-                    hash = 41 * hash + nested[i].hashCode();\n-                }\n-            }\n-            return hash;\n-        }\n-        @Override\n-        public String toString() {\n-            return recordType.tsym + \"(\" + Arrays.stream(nested)\n-                    .map(pd -> pd.toString())\n-                    .collect(Collectors.joining(\", \")) + \")\";\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":5,"deletions":540,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2732,4 +2732,0 @@\n-\/* Two different cbObjectCounter's, one for FollowReferences, one for\n- *    IterateThroughHeap. Pick a card, any card.\n- *\/\n-\n@@ -2797,32 +2793,0 @@\n-\/* Callback for instance count heap traversal (heap_iteration_callback) *\/\n-static jint JNICALL\n-cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,\n-                        void* user_data)\n-{\n-    ClassCountData  *data;\n-    int              index;\n-\n-    \/* Check data structure *\/\n-    data = (ClassCountData*)user_data;\n-    if (data == NULL) {\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Classes with no tag should be filtered out. *\/\n-    if ( class_tag == (jlong)0 ) {\n-        data->error = AGENT_ERROR_INTERNAL;\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Class tag is actually an index into data arrays *\/\n-    index = CLASSTAG2INDEX(class_tag);\n-    if (index < 0 || index >= data->classCount) {\n-        data->error = AGENT_ERROR_ILLEGAL_ARGUMENT;\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Bump instance count on this class *\/\n-    data->counts[index]++;\n-    return JVMTI_VISIT_OBJECTS;\n-}\n-\n@@ -2881,39 +2845,13 @@\n-        \/* Check debug flags to see how to do this. *\/\n-        if ( (gdata->debugflags & USE_ITERATE_THROUGH_HEAP) == 0 ) {\n-\n-            \/* Using FollowReferences only gives us live objects, but we\n-             *   need to tag the objects to avoid counting them twice since\n-             *   the callback is per reference.\n-             *   The jclass objects have been tagged with their index in the\n-             *   supplied list, and that tag may flip to negative if it\n-             *   is also an object of interest.\n-             *   All other objects being counted that weren't in the\n-             *   supplied classes list will have a negative classCount\n-             *   tag value. So all objects counted will have negative tags.\n-             *   If the absolute tag value is an index in the supplied\n-             *   list, then it's one of the supplied classes.\n-             *\/\n-            data.negObjTag = -INDEX2CLASSTAG(classCount);\n-\n-            \/* Setup callbacks, only using object reference callback *\/\n-            heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n-\n-            \/* Follow references, no initiating object, tagged classes only *\/\n-            error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n-                          (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n-                           NULL, NULL, &heap_callbacks, &data);\n-\n-        } else {\n-\n-            \/* Using IterateThroughHeap means that we will visit each object\n-             *   once, so no special tag tricks here. Just simple counting.\n-             *   However in this case the object might not be live, so we do\n-             *   a GC beforehand to make sure we minimize this.\n-             *\/\n-\n-            \/* FIXUP: Need some kind of trigger here to avoid excessive GC's? *\/\n-            error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);\n-            if ( error != JVMTI_ERROR_NONE ) {\n-\n-                \/* Setup callbacks, just need object callback *\/\n-                heap_callbacks.heap_iteration_callback = &cbObjectCounter;\n+        \/* Using FollowReferences only gives us live objects, but we\n+         *   need to tag the objects to avoid counting them twice since\n+         *   the callback is per reference.\n+         *   The jclass objects have been tagged with their index in the\n+         *   supplied list, and that tag may flip to negative if it\n+         *   is also an object of interest.\n+         *   All other objects being counted that weren't in the\n+         *   supplied classes list will have a negative classCount\n+         *   tag value. So all objects counted will have negative tags.\n+         *   If the absolute tag value is an index in the supplied\n+         *   list, then it's one of the supplied classes.\n+         *\/\n+        data.negObjTag = -INDEX2CLASSTAG(classCount);\n@@ -2921,4 +2859,2 @@\n-                \/* Iterate through entire heap, tagged classes only *\/\n-                error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)\n-                              (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n-                               NULL, &heap_callbacks, &data);\n+        \/* Setup callbacks, only using object reference callback *\/\n+        heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n@@ -2926,2 +2862,4 @@\n-            }\n-        }\n+        \/* Follow references, no initiating object, tagged classes only *\/\n+        error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n+                      (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n+                       NULL, NULL, &heap_callbacks, &data);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":20,"deletions":82,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8270326,8344261 generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8270326 generic-all\n@@ -185,3 +185,0 @@\n-serviceability\/sa\/JhsdbThreadInfoTest.java              8344261 generic-all\n-serviceability\/sa\/TestJhsdbJstackLock.java              8344261 generic-all\n-serviceability\/attach\/RemovingUnixDomainSocketTest.java 8344261 generic-all\n@@ -229,0 +226,1 @@\n+serviceability\/sa\/TestJhsdbJstackWithVirtualThread.java 8365722 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -593,0 +593,1 @@\n+ -runtime\/cds\/appcds\/VerifyObjArrayCloneTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -884,0 +884,10 @@\n+        {\n+            Outer o = new Outer();\n+            Object oldVal = new Object();\n+            o.f = oldVal;\n+            Object cmpVal = new Object();\n+            Object newVal = new Object();\n+            Object oldVal2 = testCompareAndExchange(o, cmpVal, newVal);\n+            Asserts.assertEquals(oldVal2, oldVal);\n+            Asserts.assertEquals(o.f, oldVal);\n+        }\n@@ -893,0 +903,10 @@\n+        {\n+            Outer o = new Outer();\n+            Object oldVal = new Object();\n+            o.f = oldVal;\n+            Object cmpVal = new Object();\n+            Object newVal = new Object();\n+            boolean b = testCompareAndSwap(o, cmpVal, newVal);\n+            Asserts.assertFalse(b);\n+            Asserts.assertEquals(o.f, oldVal);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestG1BarrierGeneration.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2900,0 +2900,30 @@\n+    public static final String COMPRESS_VB = VECTOR_PREFIX + \"COMPRESS_VB\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VB, \"CompressV\", TYPE_BYTE);\n+    }\n+\n+    public static final String COMPRESS_VS = VECTOR_PREFIX + \"COMPRESS_VS\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VS, \"CompressV\", TYPE_SHORT);\n+    }\n+\n+    public static final String COMPRESS_VI = VECTOR_PREFIX + \"COMPRESS_VI\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VI, \"CompressV\", TYPE_INT);\n+    }\n+\n+    public static final String COMPRESS_VL = VECTOR_PREFIX + \"COMPRESS_VL\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VL, \"CompressV\", TYPE_LONG);\n+    }\n+\n+    public static final String COMPRESS_VF = VECTOR_PREFIX + \"COMPRESS_VF\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VF, \"CompressV\", TYPE_FLOAT);\n+    }\n+\n+    public static final String COMPRESS_VD = VECTOR_PREFIX + \"COMPRESS_VD\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VD, \"CompressV\", TYPE_DOUBLE);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -330,2 +330,4 @@\n-            TestFormat.checkNoThrow(scenarioIndices.add(scenarioIndex),\n-                             \"Cannot define two scenarios with the same index \" + scenarioIndex);\n+            if (!scenarioIndices.add(scenarioIndex)) {\n+                TestFormat.failNoThrow(\"Cannot define two scenarios with the same index \" + scenarioIndex);\n+                continue;\n+            }\n@@ -339,1 +341,1 @@\n-     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when when constructing\n+     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when constructing\n@@ -341,1 +343,4 @@\n-     * flags that have to be specified togeher. Further, an empty string in a set stands in for \"no flag\".\n+     * flags that have to be specified together. Further, an empty string in a set stands in for \"no flag\".\n+     * <p>\n+     * Passing a single set will create a scenario for each of the provided flags in the set (i.e. the same as\n+     * passing an additional set with an empty string only).\n@@ -358,1 +363,1 @@\n-     * @param sets sets of flags to generate the cross product for.\n+     * @param flagSets sets of flags to generate the cross product for.\n@@ -379,1 +384,1 @@\n-                Stream.of(Collections.<String>emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n+                Stream.of(Collections.emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n@@ -387,2 +392,2 @@\n-                    ), \/\/ ...that get flattend into one big List<List<String>>.\n-                (a, b) -> Stream.concat(a, b)); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n+                    ), \/\/ ...that get flattened into one big List<List<String>>.\n+                Stream::concat); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n@@ -394,1 +399,1 @@\n-                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split muliple flags in the same string into separate strings.\n+                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split multiple flags in the same string into separate strings.\n@@ -397,1 +402,1 @@\n-                     .collect(Collectors.toList())\n+                     .toList()\n@@ -399,1 +404,1 @@\n-            .collect(Collectors.toList()).toArray(new Scenario[0]);\n+            .toList().toArray(new Scenario[0]);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-javax\/management\/remote\/mandatory\/loading\/MissingClassTest.java 8145413 windows-x64\n-\n@@ -43,21 +41,0 @@\n-##########\n-## Tests incompatible with virtual test thread factory.\n-## There is no goal to run all test with virtual test thread factory.\n-## So any test might be added as incompatible, the bug id is not required.\n-\n-# Incorrect stack\/threadgroup\/exception expectations for main thread\n-java\/lang\/StackWalker\/DumpStackTest.java 0000000 generic-all\n-java\/lang\/StackWalker\/StackWalkTest.java 0000000 generic-all\n-java\/lang\/StackWalker\/CallerFromMain.java 0000000 generic-all\n-java\/lang\/Thread\/MainThreadTest.java 0000000 generic-all\n-java\/lang\/Thread\/UncaughtExceptionsTest.java 0000000 generic-all\n-java\/lang\/invoke\/condy\/CondyNestedResolutionTest.java 0000000 generic-all\n-java\/lang\/ref\/OOMEInReferenceHandler.java 0000000 generic-all\n-java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 0000000 generic-all\n-jdk\/internal\/vm\/Continuation\/Scoped.java 0000000 generic-all\n-\n-# The problems with permissions\n-jdk\/jfr\/startupargs\/TestDumpOnExit.java 0000000 generic-all\n-java\/util\/Properties\/StoreReproducibilityTest.java 0000000 generic-all\n-javax\/management\/ImplementationVersion\/ImplVersionTest.java 0000000 generic-all\n-javax\/management\/remote\/mandatory\/version\/ImplVersionTest.java 0000000 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -687,1 +687,0 @@\n-javax\/swing\/JTabbedPane\/4624207\/bug4624207.java 8064922 macosx-all\n@@ -766,0 +765,1 @@\n+jdk\/jfr\/jvm\/TestWaste.java                                      8369949 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+        vmOptFinalIntxFlags(map);\n@@ -393,0 +394,20 @@\n+    \/**\n+     * Selected final flag of type intx.\n+     *\n+     * @param map - property-value pairs\n+     * @param flagName - flag name\n+     *\/\n+    private void vmOptFinalIntxFlag(SafeMap map, String flagName) {\n+        map.put(\"vm.opt.final.\" + flagName,\n+                () -> String.valueOf(WB.getIntxVMFlag(flagName)));\n+    }\n+\n+    \/**\n+     * Selected sets of final flags of type intx.\n+     *\n+     * @param map - property-value pairs\n+     *\/\n+    protected void vmOptFinalIntxFlags(SafeMap map) {\n+        vmOptFinalIntxFlag(map, \"MaxVectorSize\");\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}