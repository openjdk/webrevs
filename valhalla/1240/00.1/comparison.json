{"files":[{"patch":"@@ -359,0 +359,8 @@\n+        \/*if (isValueClassConst()) {\n+            \/\/ previously we had vnew methods which had a return type, not `void`, and we were attaching metadata to it\n+            \/\/ like nullness for example. Type `void` doesn't accept metadata so if we need to state that the result of\n+            \/\/ invoking a value class constructor is never null, we will need another way.\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }*\/\n@@ -474,0 +482,6 @@\n+    \/** Is this symbol an implicit constructor?\n+     *\/\n+    public boolean isImplicitConstructor() {\n+        return isConstructor() && ((flags() & IMPLICIT) != 0);\n+    }\n+\n@@ -1318,0 +1332,2 @@\n+        private boolean hasImplicitConstructor = false;\n+\n@@ -1689,0 +1705,29 @@\n+\n+        public boolean hasImplicitConstructor() {\n+            if (hasImplicitConstructor) {\n+                return true;\n+            } else {\n+                if (getImplicitConstructor() != null) {\n+                    hasImplicitConstructor = true;\n+                }\n+                return hasImplicitConstructor;\n+            }\n+        }\n+\n+        public void implicitConstructorFound() {\n+            hasImplicitConstructor = true;\n+        }\n+\n+        private MethodSymbol getImplicitConstructor() {\n+            for (Symbol s : members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case MTH:\n+                        if (s.isConstructor()) {\n+                            if (s.isImplicitConstructor()) {\n+                                return (MethodSymbol) s;\n+                            }\n+                        }\n+                }\n+            }\n+            return null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -185,0 +186,3 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n+        allowNullRestrictedTypesForValueClassesOnly = options.isSet(\"allowNullRestrictedTypesForValueClassesOnly\");\n@@ -214,0 +218,8 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n+    \/** Are null-restricted types allowed for value classes only\n+     *\/\n+    private final boolean allowNullRestrictedTypesForValueClassesOnly;\n+\n@@ -310,2 +322,3 @@\n-                v.owner.isValueClass() &&\n-                !env.info.instanceInitializerBlock && \/\/ it is OK instance initializer blocks will go after super() anyways\n+                \/\/ it is OK, in value classes, instance initializer blocks will go after super() anyways\n+                ((v.owner.isValueClass() && !env.info.instanceInitializerBlock) ||\n+                        types.isNonNullable(v.type)) &&\n@@ -733,0 +746,4 @@\n+        if (allowNullRestrictedTypes && tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -1168,0 +1185,8 @@\n+            if (allowNullRestrictedTypes && tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1339,0 +1364,14 @@\n+            if (allowNullRestrictedTypes) {\n+                Type elemOrType = result;\n+                while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                    elemOrType = types.elemtype(elemOrType);\n+                }\n+                if (allowNullRestrictedTypesForValueClassesOnly &&\n+                        ((types.isNonNullable(result) || types.isNonNullable(elemOrType)) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor()))) {\n+                    log.error(tree.pos(),\n+                            types.elemtype(result) == null?\n+                                    Errors.TypeCantBeNullRestricted(result) :\n+                                    Errors.TypeCantBeNullRestricted2(result)\n+                    );\n+                }\n+            }\n@@ -1438,0 +1477,3 @@\n+                if (tree.stats.size() > 0) {\n+                    env.info.scope.owner.flags_field |= HASINITBLOCK;\n+                }\n@@ -2919,1 +2961,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -2921,0 +2963,4 @@\n+                if (allowNullRestrictedTypes && owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -3103,0 +3149,1 @@\n+            List<NullMarker> nullMarkers = tree.nullMarkers.reverse();\n@@ -3105,1 +3152,3 @@\n-                owntype = new ArrayType(owntype, syms.arrayClass);\n+                owntype = new ArrayType(owntype, syms.arrayClass)\n+                        .asNullMarked(nullMarkers.head);\n+                nullMarkers = nullMarkers.tail;\n@@ -4415,0 +4464,10 @@\n+        \/\/ check nullness of site\n+        if (types.isNullable(site)) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (types.isParametric(site)) {\n+            \/\/ see JDK-8339087\n+            \/\/chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -4727,0 +4786,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5374,0 +5438,5 @@\n+            if (c.type.isValueClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (allowNullRestrictedTypes && env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n@@ -5555,0 +5624,1 @@\n+                chk.checkConstraintsOfValueClassesWithImplicitConst((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":74,"deletions":4,"binary":false,"changes":78,"status":"modified"}]}