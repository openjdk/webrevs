{"files":[{"patch":"@@ -127,0 +127,1 @@\n+    final LocalProxyVarsGen localProxyVarsGen;\n@@ -166,0 +167,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -320,1 +322,1 @@\n-        \/\/ Check instance field assignments that appear in constructor prologues\n+        \/\/ Check instance field assignments that appear in constructor prologues, like: `this.field = value;`\n@@ -328,6 +330,0 @@\n-\n-            \/\/ Field may not have an initializer\n-            if ((v.flags() & HASINIT) != 0) {\n-                log.error(pos, Errors.CantAssignInitializedBeforeCtorCalled(v));\n-                return;\n-            }\n@@ -961,0 +957,1 @@\n+        JCClassDecl localClassPrev = env.info.localClass;\n@@ -962,0 +959,1 @@\n+            env.info.localClass = env.enclMethod != null ? tree : null;\n@@ -995,0 +993,1 @@\n+            env.info.localClass = localClassPrev;\n@@ -4394,0 +4393,1 @@\n+        checkIfAllowedInPrologue(tree);\n@@ -4395,0 +4395,23 @@\n+    \/\/ where\n+        void checkIfAllowedInPrologue(JCTree tree) {\n+            Assert.check(tree.hasTag(IDENT) || tree.hasTag(SELECT));\n+            Symbol sym = TreeInfo.symbolFor(tree);\n+            if (env.info.ctorPrologue && allowValueClasses) {\n+                JCFieldAccess enclosingSelect = rs.new FindEnclosingSelect().scan(tree, env.tree);\n+                if (enclosingSelect == null) { \/\/ this tree is standalone, not part of a more complex name\n+                    if (localProxyVarsGen.hasAST(env.enclMethod, tree)) {\n+                        if (sym.owner != env.enclClass.sym ||\n+                            TreeInfo.isExplicitThisOrSuperReference(types, (ClassType)env.enclClass.type, tree)) {\n+                            \/* in this case we are seeing something like `super.field` or accessing a field of a\n+                             * super class while in the prologue of a subclass, at Resolve javac just didn't have enough\n+                             * information to determine this\n+                             *\/\n+                            localProxyVarsGen.removeASTReadInPrologue(env.enclMethod, tree);\n+                            log.error(tree, Errors.CantRefBeforeCtorCalled(sym));\n+                        } else if (!sym.isFinal() && !sym.isStrict()) {\n+                            localProxyVarsGen.removeASTReadInPrologue(env.enclMethod, tree);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n@@ -4530,0 +4553,1 @@\n+        checkIfAllowedInPrologue(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -135,0 +135,5 @@\n+    \/**\n+     *  Local class being attributed if any\n+     *\/\n+    JCTree.JCClassDecl localClass = null;\n+\n@@ -160,0 +165,1 @@\n+        info.localClass = localClass;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        STRICT_FIELDS_PROXIES(11),\n+        FIELDS_PROXIES(11),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+    private final LocalProxyVarsGen localProxyVarsGen;\n@@ -348,0 +349,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -490,1 +492,7 @@\n-            forEachInitializer(classDef, isStatic, false, handler);\n+            forEachInitializer(classDef, isStatic, InitializerDisc.PROCESS_ALL, handler);\n+        }\n+\n+        enum InitializerDisc {\n+            PROCESS_ALL,\n+            EARLY_ONLY,\n+            LATE_ONLY\n@@ -494,1 +502,1 @@\n-         * the `earlyOnly` argument will determine if we will deal or not with early variable instance\n+         * the `discriminator` argument will determine if we will deal or not with early variable instance\n@@ -498,1 +506,1 @@\n-        protected void forEachInitializer(JCClassDecl classDef, boolean isStatic, boolean earlyOnly,\n+        protected void forEachInitializer(JCClassDecl classDef, boolean isStatic, InitializerDisc discriminator,\n@@ -518,5 +526,10 @@\n-                        if (def instanceof JCVariableDecl varDecl) {\n-                            boolean isEarly = varDecl.init != null &&\n-                                    varDecl.sym.isStrict() &&\n-                                    !varDecl.sym.isStatic();\n-                            if (isEarly == earlyOnly) {\n+                        if (discriminator == InitializerDisc.PROCESS_ALL) {\n+                            handler.accept(def);\n+                        } else {\n+                            if (def instanceof JCVariableDecl varDecl) {\n+                                boolean isEarly = varDecl.init != null &&\n+                                        !varDecl.sym.isStatic();\n+                                if (isEarly && discriminator == InitializerDisc.EARLY_ONLY) {\n+                                    handler.accept(def);\n+                                }\n+                            } else if (discriminator == InitializerDisc.LATE_ONLY) {\n@@ -525,2 +538,0 @@\n-                        } else if (!earlyOnly) {\n-                            handler.accept(def);\n@@ -2208,0 +2219,1 @@\n+        private JCMethodDecl currentMethod;\n@@ -2224,1 +2236,1 @@\n-                isFinalOrStrictUninitializedField(sym)));\n+                isTrackableField(sym)));\n@@ -2227,1 +2239,5 @@\n-        boolean isFinalOrStrictUninitializedField(VarSymbol sym) {\n+        \/* we want to track fields that are:\n+         *     - final regardless of \"staticness\"\n+         *     - non-final instance fields that lack an initializer\n+         *\/\n+        boolean isTrackableField(VarSymbol sym) {\n@@ -2230,1 +2246,1 @@\n-                     (sym.flags() & (STRICT | HASINIT | PARAMETER)) == STRICT) &&\n+                   (sym.flags() & (STRICT | HASINIT | PARAMETER)) == STRICT) &&\n@@ -2531,0 +2547,1 @@\n+                JCMethodDecl currentMethodPrev = currentMethod;\n@@ -2535,0 +2552,1 @@\n+                    currentMethod = tree;\n@@ -2563,2 +2581,1 @@\n-                        boolean isSynthesized = (tree.sym.flags() &\n-                                                 GENERATEDCONSTR) != 0;\n+                        boolean isAGeneratedConstructor = (tree.sym.flags() & GENERATEDCONSTR) != 0;\n@@ -2569,0 +2586,4 @@\n+                                \/\/ ignore non-final instance fields\n+                                if (allowValueClasses && var.owner.kind == TYP && !var.isFinal()) {\n+                                    continue;\n+                                }\n@@ -2570,2 +2591,2 @@\n-                                \/\/ the ctor is default(synthesized) or not\n-                                if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n+                                \/\/ the ctor is default(generated) or not\n+                                if (isAGeneratedConstructor && !isCompactOrGeneratedRecordConstructor) {\n@@ -2606,0 +2627,1 @@\n+                    currentMethod = currentMethodPrev;\n@@ -3089,1 +3111,1 @@\n-                forEachInitializer(classDef, false, true, def -> {\n+                forEachInitializer(classDef, false, InitializerDisc.EARLY_ONLY, def -> {\n@@ -3111,1 +3133,1 @@\n-                    forEachInitializer(classDef, false, def -> {\n+                    forEachInitializer(classDef, false, InitializerDisc.LATE_ONLY, def -> {\n@@ -3121,1 +3143,1 @@\n-                        if (isFinalOrStrictUninitializedField(sym) && !sym.isStatic())\n+                        if (isTrackableField(sym) && !sym.isStatic())\n@@ -3202,2 +3224,6 @@\n-            if (TreeInfo.isThisQualifier(tree.selected) &&\n-                tree.sym.kind == VAR) {\n+            if (TreeInfo.isThisQualifier(tree.selected) && tree.sym.kind == VAR) {\n+                if (trackable((VarSymbol)tree.sym)) {\n+                    checkInit(tree.pos(), (VarSymbol) tree.sym);\n+                }\n+            }\n+            if (localProxyVarsGen.hasAST(currentMethod, tree)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":48,"deletions":22,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.LinkedHashSet;\n@@ -34,0 +35,1 @@\n+import java.util.stream.Collectors;\n@@ -91,2 +93,2 @@\n-    private java.util.List<JCVariableDecl> strictInstanceFields;\n-    private Map<JCMethodDecl, Set<Symbol>> strictFieldsReadInPrologue = new HashMap<>();\n+    private java.util.List<JCVariableDecl> instanceFields;\n+    private Map<JCMethodDecl, Set<JCTree>> ASTsReferencedInPrologue = new HashMap<>();\n@@ -108,4 +110,21 @@\n-    public void addStrictFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n-        Set<Symbol> fieldSet = strictFieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n-        fieldSet.add(sym);\n-        strictFieldsReadInPrologue.put(constructor, fieldSet);\n+    public void addASTReadInPrologue(JCMethodDecl constructor, JCTree tree) {\n+        \/\/ better to have order for this one\n+        Set<JCTree> treeSet = ASTsReferencedInPrologue.getOrDefault(constructor, new LinkedHashSet<>());\n+        treeSet.add(tree);\n+        ASTsReferencedInPrologue.put(constructor, treeSet);\n+    }\n+\n+    public boolean removeASTReadInPrologue(JCMethodDecl constructor, JCTree tree) {\n+        Set<JCTree> treeSet = ASTsReferencedInPrologue.get(constructor);\n+        if (treeSet != null) {\n+            return treeSet.remove(tree);\n+        }\n+        return false;\n+    }\n+\n+    public boolean hasAST(JCMethodDecl constructor, JCTree tree) {\n+        Set<JCTree> treeSet = ASTsReferencedInPrologue.get(constructor);\n+        if (treeSet != null) {\n+            return treeSet.contains(tree);\n+        }\n+        return false;\n@@ -131,1 +150,1 @@\n-        java.util.List<JCVariableDecl> prevStrictInstanceFields = strictInstanceFields;\n+        java.util.List<JCVariableDecl> instanceFieldsPrev = instanceFields;\n@@ -134,1 +153,1 @@\n-            strictInstanceFields = tree.defs.stream()\n+            instanceFields = tree.defs.stream()\n@@ -137,1 +156,1 @@\n-                    .filter(vd -> vd.sym.isStrict() && !vd.sym.isStatic())\n+                    .filter(vd -> !vd.sym.isStatic())\n@@ -142,1 +161,1 @@\n-            strictInstanceFields = prevStrictInstanceFields;\n+            instanceFields = instanceFieldsPrev;\n@@ -147,2 +166,2 @@\n-        if (strictFieldsReadInPrologue.get(tree) != null) {\n-            Set<Symbol> fieldSet = strictFieldsReadInPrologue.get(tree);\n+        if (ASTsReferencedInPrologue.get(tree) != null) {\n+            Set<JCTree> ASTSet = ASTsReferencedInPrologue.get(tree);\n@@ -150,2 +169,3 @@\n-            for (JCVariableDecl sfield : strictInstanceFields) {\n-                if (fieldSet.contains(sfield.sym)) {\n+            Set<Symbol> symbols = ASTSet.stream().map(t -> TreeInfo.symbolFor(t)).collect(Collectors.toSet());\n+            for (JCVariableDecl sfield : instanceFields) {\n+                if (symbols.contains(sfield.sym)) {\n@@ -156,1 +176,1 @@\n-            strictFieldsReadInPrologue.remove(tree);\n+            ASTsReferencedInPrologue.remove(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    private final LocalProxyVarsGen localProxyVarsGen;\n@@ -118,1 +119,1 @@\n-    private final LocalProxyVarsGen localProxyVarsGen;\n+    private final boolean allowValueClasses;\n@@ -144,0 +145,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -158,1 +160,2 @@\n-        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n+        allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -1540,3 +1543,11 @@\n-                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n-                        if (!env.tree.hasTag(ASSIGN) || !TreeInfo.isIdentOrThisDotIdent(((JCAssign)env.tree).lhs)) {\n-                            if (!sym.isStrictInstance()) {\n+                    if (env1.info.ctorPrologue) {\n+                        EarlyReferenceKind erk =  isAllowedEarlyReference(pos, env1, (VarSymbol)sym);\n+                        switch (erk) {\n+                            case UNDEFINED:\n+                                if (allowValueClasses) {\n+                                    processUndefinedEarlyReference(pos.getTree(), env1, sym);\n+                                    return sym;\n+                                } else {\n+                                    return new RefBeforeCtorCalledError(sym);\n+                                }\n+                            case NOT_ACCEPTABLE:\n@@ -1544,2 +1555,8 @@\n-                            } else {\n-                                localProxyVarsGen.addStrictFieldReadInPrologue(env.enclMethod, sym);\n+                            case FIELD_HAS_INIT:\n+                                if (!allowValueClasses) {\n+                                    return new RefBeforeCtorCalledError(sym, true);\n+                                } else {\n+                                    \/\/ acceptable in valhalla\n+                                    return sym;\n+                                }\n+                            default:\n@@ -1547,1 +1564,0 @@\n-                            }\n@@ -1589,0 +1605,10 @@\n+    void processUndefinedEarlyReference(JCTree tree, Env<AttrContext> env, Symbol sym) {\n+        \/* at this point we don't have enough info, we could be seeing a sub tree which could\n+         * be part of a select or something bigger\n+         *\/\n+        JCTree originalTree = tree;\n+        JCFieldAccess enclosingSelect = new FindEnclosingSelect().scan(tree, env.tree);\n+        tree = enclosingSelect == null ? originalTree : enclosingSelect;\n+        localProxyVarsGen.addASTReadInPrologue(env.enclMethod, tree);\n+    }\n+\n@@ -3829,1 +3855,1 @@\n-                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n+                    } else if (env1.info.ctorPrologue && isAllowedEarlyReference(pos, env1, (VarSymbol)sym) != EarlyReferenceKind.ACCEPTABLE) {\n@@ -3890,2 +3916,21 @@\n-                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n-                        sym = new RefBeforeCtorCalledError(sym);\n+                    else if (env1.info.ctorPrologue) {\n+                        EarlyReferenceKind erk = isAllowedEarlyReference(pos, env1, (VarSymbol)sym);\n+                        switch (erk) {\n+                            case UNDEFINED:\n+                                if (allowValueClasses) {\n+                                    processUndefinedEarlyReference(pos.getTree(), env1, sym);\n+                                } else {\n+                                    sym = new RefBeforeCtorCalledError(sym);\n+                                }\n+                                break;\n+                            case NOT_ACCEPTABLE:\n+                                sym = new RefBeforeCtorCalledError(sym);\n+                                break;\n+                            case FIELD_HAS_INIT:\n+                                if (!allowValueClasses) {\n+                                    sym = new RefBeforeCtorCalledError(sym, true);\n+                                }\n+                                break;\n+                            default: \/\/ do nothing\n+                        }\n+                    }\n@@ -3927,0 +3972,22 @@\n+    public class FindEnclosingSelect extends TreeScanner {\n+        JCTree treeToLookFor;\n+        JCFieldAccess enclosingSelect = null;\n+\n+        public JCFieldAccess scan(JCTree treeToLookFor, JCTree tree) {\n+            this.treeToLookFor = treeToLookFor;\n+            super.scan(tree);\n+            return enclosingSelect;\n+        }\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            if (tree.selected == treeToLookFor) {\n+                enclosingSelect = tree;\n+                \/\/ this select could be part of an enclosing select\n+                treeToLookFor = tree;\n+            } else {\n+                scan(tree.selected);\n+            }\n+        }\n+    }\n+\n@@ -3959,2 +4026,1 @@\n-    private boolean isAllowedEarlyReference(DiagnosticPosition pos, Env<AttrContext> env, VarSymbol v) {\n-\n+    private EarlyReferenceKind isAllowedEarlyReference(DiagnosticPosition pos, Env<AttrContext> env, VarSymbol v) {\n@@ -3965,0 +4031,14 @@\n+        \/\/ The assignment statement must not be within a lambda or a local class\n+        if (env.info.isLambda) {\n+            return EarlyReferenceKind.NOT_ACCEPTABLE;\n+        }\n+        if (env.info.localClass != null) {\n+            Symbol sym = env.info.localClass.sym;\n+            for (; sym != null && sym.kind != PCK; sym = sym.owner.kind == TYP ? sym.owner : null) {\n+                if (sym == v.owner) break;\n+            }\n+            if (sym == null) {\n+                return EarlyReferenceKind.NOT_ACCEPTABLE;\n+            }\n+        }\n+\n@@ -3967,5 +4047,1 @@\n-            return false;\n-\n-        \/\/ The assignment statement must not be within a lambda\n-        if (env.info.isLambda)\n-            return false;\n+            return EarlyReferenceKind.UNDEFINED;\n@@ -3983,2 +4059,2 @@\n-            if (!TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))\n-                return false;\n+            if (!TreeInfo.isExplicitThisOrSuperReference(types, (ClassType)env.enclClass.type, base))\n+                return EarlyReferenceKind.NOT_ACCEPTABLE;\n@@ -3987,1 +4063,1 @@\n-            return false;\n+            return EarlyReferenceKind.NOT_ACCEPTABLE;\n@@ -3992,1 +4068,1 @@\n-            return false;\n+            return EarlyReferenceKind.NOT_ACCEPTABLE;\n@@ -3997,2 +4073,16 @@\n-        \/\/ OK\n-        return true;\n+        \/* Field may not have an initializer, example:\n+         *  class C {\n+         *      int x = 1;\n+         *      public C() {\n+         *          x = 2;\n+         *          super();\n+         *      }\n+         *  }\n+         * in valhalla we want to allow for this as we execute initializers before the super invocation\n+         *\/\n+        if ((v.flags() & HASINIT) != 0) {\n+            return EarlyReferenceKind.FIELD_HAS_INIT;\n+        } else {\n+            \/\/ Acceptable\n+            return EarlyReferenceKind.ACCEPTABLE;\n+        }\n@@ -4000,0 +4090,7 @@\n+    \/\/ where\n+        enum EarlyReferenceKind {\n+            ACCEPTABLE,\n+            UNDEFINED,                            \/\/ can't tell with the current info\n+            FIELD_HAS_INIT,                       \/\/ this is an error in JDK, acceptable in valhalla\n+            NOT_ACCEPTABLE,                       \/\/ this is a not acceptable state for the method above\n+        }\n@@ -4021,1 +4118,1 @@\n-            (base == null || TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base));\n+            (base == null || TreeInfo.isExplicitThisOrSuperReference(types, (ClassType)env.enclClass.type, base));\n@@ -4774,0 +4871,2 @@\n+        boolean hasInitializer;\n+\n@@ -4775,0 +4874,4 @@\n+            this(sym, false);\n+        }\n+\n+        RefBeforeCtorCalledError(Symbol sym, boolean hasInitializer) {\n@@ -4776,0 +4879,1 @@\n+            this.hasInitializer = hasInitializer;\n@@ -4789,2 +4893,7 @@\n-            return diags.create(dkind, log.currentSource(), pos,\n-                    \"cant.ref.before.ctor.called\", errSym);\n+            return diags.create(dkind,\n+                    log.currentSource(),\n+                    pos,\n+                    !hasInitializer ?\n+                            \"cant.ref.before.ctor.called\" :\n+                            \"cant.assign.initialized.before.ctor.called\",\n+                    errSym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":136,"deletions":27,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -978,1 +977,1 @@\n-        if (TreeInfo.isExplicitThisReference(types, currentClassType, tree)) {\n+        if (TreeInfo.isExplicitThisOrSuperReference(types, currentClassType, tree)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -83,1 +82,0 @@\n-import com.sun.tools.javac.util.Log.DiscardDiagnosticHandler;\n@@ -487,1 +485,2 @@\n-\n+        allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -575,0 +574,3 @@\n+    \/** Switch: are value classes allowed *\/\n+    private final boolean allowValueClasses;\n+\n@@ -1549,2 +1551,0 @@\n-            protected boolean hasValueClasses;\n-            protected boolean hasStrictFields;\n@@ -1562,1 +1562,0 @@\n-                            boolean prevHasStrictFields = hasStrictFields;\n@@ -1575,1 +1574,0 @@\n-                                hasStrictFields = prevHasStrictFields;\n@@ -1582,1 +1580,0 @@\n-                hasValueClasses = node.sym.isValueClass();\n@@ -1622,6 +1619,0 @@\n-\n-            @Override\n-            public void visitVarDef(JCVariableDecl tree) {\n-                hasStrictFields |= tree.sym.isStrict();\n-                super.visitVarDef(tree);\n-            }\n@@ -1713,2 +1704,2 @@\n-            if (scanner.hasValueClasses || scanner.hasStrictFields) {\n-                if (shouldStop(CompileState.STRICT_FIELDS_PROXIES))\n+            if (allowValueClasses) {\n+                if (shouldStop(CompileState.FIELDS_PROXIES))\n@@ -1719,1 +1710,1 @@\n-                compileStates.put(env, CompileState.STRICT_FIELDS_PROXIES);\n+                compileStates.put(env, CompileState.FIELDS_PROXIES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.tools.javac.comp.AttrContext;\n@@ -192,1 +191,1 @@\n-    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+    public static boolean isExplicitThisOrSuperReference(Types types, Type.ClassType currentClass, JCTree tree) {\n@@ -195,1 +194,1 @@\n-                return isExplicitThisReference(types, currentClass, skipParens(tree));\n+                return isExplicitThisOrSuperReference(types, currentClass, skipParens(tree));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -13,0 +13,20 @@\n+        public Inner1(int y) {\n+            y = x;                          \/\/ OK mutable field\n+            super();\n+        }\n+\n+        public Inner1(int y, int ignore1) {\n+            y = this.x;                     \/\/ OK mutable field\n+            super();\n+        }\n+\n+        public Inner1(int y, boolean ignore2) {\n+            y = Inner1.this.x;              \/\/ OK mutable field\n+            super();\n+        }\n+\n+        public Inner1(short[] x) {\n+            this.x++;                       \/\/ OK mutable field\n+            super();\n+        }\n+\n@@ -20,7 +40,0 @@\n-        public Inner1(int y) {\n-            y = x;                          \/\/ FAIL - early 'this' reference\n-            y = this.x;                     \/\/ FAIL - early 'this' reference\n-            y = Inner1.this.x;              \/\/ FAIL - early 'this' reference\n-            super();\n-        }\n-\n@@ -98,1 +111,1 @@\n-            x = x + 1;                          \/\/ FAIL - illegal early access\n+            x = x + 1;                          \/\/ OK\n@@ -104,1 +117,1 @@\n-            this.x = this.x + 1;                \/\/ FAIL - illegal early access\n+            this.x = this.x + 1;                \/\/ OK\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,26 +1,19 @@\n-EarlyAssignments.java:21:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:22:17: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:23:23: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:31:21: compiler.err.cant.ref.before.ctor.called: super\n-EarlyAssignments.java:32:21: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:33:26: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:34:34: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:36:36: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:40:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:44:21: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:48:22: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:66:13: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:67:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:68:25: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:69:31: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:98:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:104:22: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:110:35: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:119:17: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:124:22: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:129:29: compiler.err.cant.ref.before.ctor.called: x\n-EarlyAssignments.java:134:17: compiler.err.cant.ref.before.ctor.called: super\n-EarlyAssignments.java:139:23: compiler.err.cant.ref.before.ctor.called: this\n-EarlyAssignments.java:148:13: compiler.err.cant.assign.initialized.before.ctor.called: x\n-EarlyAssignments.java:157:13: compiler.err.cant.assign.val.to.var: final, x\n-EarlyAssignments.java:168:13: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:44:26: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:45:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:46:26: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:47:34: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:49:36: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:53:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:57:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:61:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:79:13: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:80:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:81:25: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:82:31: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:132:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:137:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:142:29: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:147:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:152:28: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:170:13: compiler.err.cant.assign.val.to.var: final, x\n+EarlyAssignments.java:181:13: compiler.err.cant.ref.before.ctor.called: this\n@@ -29,1 +22,1 @@\n-26 errors\n+19 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -93,5 +93,0 @@\n-    public SuperInitFails(short[] x) {\n-        this.x++;                       \/\/ this should FAIL\n-        super();\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,22 +2,22 @@\n-SuperInitFails.java:62:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:67:9: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:72:23: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:77:23: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:94:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:99:33: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:104:14: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:108:20: compiler.err.not.encl.class: java.lang.Object\n-SuperInitFails.java:112:17: compiler.err.cant.ref.before.ctor.called: super\n-SuperInitFails.java:119:22: compiler.err.call.must.only.appear.in.ctor\n-SuperInitFails.java:125:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:133:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record1\n-SuperInitFails.java:138:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record2\n-SuperInitFails.java:155:31: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:159:15: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:168:13: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:172:17: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:176:24: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:180:18: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:195:25: compiler.err.return.before.superclass.initialized\n-SuperInitFails.java:200:33: compiler.err.ctor.calls.not.allowed.here\n-SuperInitFails.java:205:29: compiler.err.redundant.superclass.init\n+SuperInitFails.java:62:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:67:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:72:28: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:77:29: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:94:33: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:99:14: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:103:20: compiler.err.not.encl.class: java.lang.Object\n+SuperInitFails.java:107:17: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:114:22: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:120:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:128:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record1\n+SuperInitFails.java:133:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record2\n+SuperInitFails.java:150:31: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:154:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:163:13: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:167:17: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:171:24: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:175:18: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:181:28: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:190:25: compiler.err.return.before.superclass.initialized\n+SuperInitFails.java:195:33: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:200:29: compiler.err.redundant.superclass.init\n@@ -32,1 +32,1 @@\n-SuperInitFails.java:150:18: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:145:18: compiler.err.call.must.only.appear.in.ctor\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,4 +2,4 @@\n-ValueClassSuperInitFails.java:72:9: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:77:9: compiler.err.cant.ref.before.ctor.called: super\n-ValueClassSuperInitFails.java:82:33: compiler.err.cant.ref.before.ctor.called: this\n-ValueClassSuperInitFails.java:87:33: compiler.err.cant.ref.before.ctor.called: super\n+ValueClassSuperInitFails.java:72:13: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:77:14: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:82:38: compiler.err.cant.ref.before.ctor.called: hashCode()\n+ValueClassSuperInitFails.java:87:39: compiler.err.cant.ref.before.ctor.called: hashCode()\n@@ -15,0 +15,1 @@\n+ValueClassSuperInitFails.java:175:49: compiler.err.cant.ref.before.ctor.called: x\n@@ -27,1 +28,1 @@\n-24 errors\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/T7093325.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/T8222949\/TestConstantDynamic.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+compiler.err.cant.assign.initialized.before.ctor.called\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.note.preview.filename\n- \/\/ key: compiler.note.preview.recompile\n- \/\/ key: compiler.err.cant.assign.initialized.before.ctor.called\n- \/\/ options: --enable-preview  -source ${jdk.version}\n-\n-class CantAssignInitializedBeforeCtorCalled {\n-    int x = 1;\n-    CantAssignInitializedBeforeCtorCalled() {\n-        x = 2;\n-        super();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantAssignInitializedBeforeCtorCalled.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.cant.ref.before.ctor.called\n+ \/\/ options: --enable-preview  -source ${jdk.version}\n+\n+class CantWriteFieldFromLocalInPrologue {\n+    int x;\n+    CantWriteFieldFromLocalInPrologue() {\n+        class Local {\n+            {\n+                x++;\n+            }\n+        }\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantWriteFieldFromLocalInPrologue.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/lambda\/TestInvokeDynamic.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecodeTargetRelease14.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-        assertOK(\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -926,1 +926,2 @@\n-                    Runnable r = () -> { System.err.println(t); }; \/\/ compiler will generate a local proxy for `t`\n+                    \/\/ can't reference instance field from a lambda before super constructor has been invoked\n+                    Runnable r = () -> { System.err.println(t); };\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javac\/varargs\/7042566\/T7042566.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}