{"files":[{"patch":"@@ -2302,4 +2302,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -6918,30 +6914,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeimmCM0(immI0 zero, memory1 mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST);\n-  format %{ \"storestore (elided)\\n\\t\"\n-            \"strb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n-\/\/ Store CMS card-mark Immediate with intervening StoreStore\n-\/\/ needed when using CMS with no conditional card marking\n-instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"storestore\\n\\t\"\n-            \"dmb ishst\"\n-            \"\\n\\tstrb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0_ordered(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -5184,1 +5184,1 @@\n-    if (CompressedOops::shift() != 0 || d != s) {\n+    if (CompressedOops::shift() != 0) {\n@@ -5186,0 +5186,2 @@\n+    } else if (d != s) {\n+      mov(d, s);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,5 @@\n-    __ unlock_object(R5, R6, R4, *stub->entry());\n+    if (LockingMode == LM_MONITOR) {\n+      __ b(*stub->entry());\n+    } else {\n+      __ unlock_object(R5, R6, R4, *stub->entry());\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6507,0 +6507,27 @@\n+\n+void C2_MacroAssembler::select_from_two_vectors_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                     XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      evpermi2b(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_SHORT:\n+      evpermi2w(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_INT:\n+      evpermi2d(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_LONG:\n+      evpermi2q(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_FLOAT:\n+      evpermi2ps(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_DOUBLE:\n+      evpermi2pd(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -509,0 +509,2 @@\n+  void select_from_two_vectors_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1938,0 +1938,14 @@\n+    case Op_SelectFromTwoVector:\n+       if (size_in_bits < 128 || (size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n+         return false;\n+       }\n+       if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n+         return false;\n+       }\n+       if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n+         return false;\n+       }\n+       if ((bt == T_INT || bt == T_FLOAT || bt == T_DOUBLE) && !VM_Version::supports_evex()) {\n+         return false;\n+       }\n+       break;\n@@ -2234,4 +2248,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -10508,0 +10518,13 @@\n+\n+\n+instruct vector_selectfrom_twovectors_reg_evex(vec index, vec src1, vec src2)\n+%{\n+  match(Set index (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"select_from_two_vector $index, $src1, $src2 \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ select_from_two_vectors_evex(bt, $index$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -6322,11 +6322,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM(memory mem, immI8 src) %{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150);\n-  format %{ \"MOV8   $mem,$src\\t! CMS card-mark imm0\" %}\n-  opcode(0xC6);               \/* C6 \/0 *\/\n-  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n-  ins_pipe( ialu_mem_imm );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5324,26 +5324,0 @@\n-%}\n-\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM0_reg(memory mem, immI_0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movb    $mem, R12\\t# CMS card-mark byte 0 (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmCM0(memory mem, immI_0 src)\n-%{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movb    $mem, $src\\t# CMS card-mark byte 0\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3658,1 +3658,0 @@\n-    \"StoreCM\",\n@@ -4360,1 +4359,1 @@\n-    \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n+    \"SelectFromTwoVector\", \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1035,1 +1035,1 @@\n-\/\/ patch_stub: jmp Runtim1::patch_code (through a runtime stub)\n+\/\/ patch_stub: jmp Runtime1::patch_code (through a runtime stub)\n@@ -1269,1 +1269,1 @@\n-    MutexLocker ml_patch (current, Patching_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -1434,6 +1434,2 @@\n-  }\n-\n-  \/\/ If we are patching in a non-perm oop, make sure the nmethod\n-  \/\/ is on the right list.\n-  {\n-    MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ If we are patching in a non-perm oop, make sure the nmethod\n+    \/\/ is on the right list.\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,3 +126,2 @@\n-#ifdef _WINDOWS\n-    \/\/ qsort() on Windows reverse the order of fields with the same size\n-    \/\/ the extension of the comparison function below preserves this order\n+    \/\/ qsort() may reverse the order of fields with the same size.\n+    \/\/ The extension is to ensure stable sort.\n@@ -134,3 +133,0 @@\n-#else\n-    return (*y)->size() - (*x)->size();\n-#endif \/\/ _WINDOWS\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -216,0 +217,5 @@\n+      \/\/ Exclude any classes that fail over during dynamic dumping\n+      if (CDSConfig::is_dumping_dynamic_archive()) {\n+        SystemDictionaryShared::warn_excluded(klass, \"Failed over class verification while dynamic dumping\");\n+        SystemDictionaryShared::set_excluded(klass);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -475,0 +475,2 @@\n+  do_intrinsic(_Reference_clear0,           java_lang_ref_Reference, clear0_name,    void_method_signature, F_RN)       \\\n+  do_intrinsic(_PhantomReference_clear0,    java_lang_ref_PhantomReference, clear0_name, void_method_signature, F_RN)   \\\n@@ -997,0 +999,11 @@\n+  do_intrinsic(_VectorSelectFromTwoVectorOp, jdk_internal_vm_vector_VectorSupport, vector_select_from_op_name, vector_select_from_op_sig, F_S) \\\n+   do_signature(vector_select_from_op_sig, \"(Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"I\"                                                                                                \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$SelectFromTwoVector;)\"                                      \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                   \\\n+   do_name(vector_select_from_op_name,     \"selectFromTwoVectorOp\")                                                                            \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -433,0 +433,1 @@\n+  template(clear0_name,                               \"clear0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2069,1 +2069,1 @@\n-  \/\/ Invalidate can't occur while holding the Patching lock\n+  \/\/ Invalidate can't occur while holding the NMethodState_lock\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -329,0 +329,1 @@\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n@@ -338,0 +339,4 @@\n+  if (no_keepalive) {\n+    \/\/ No keep-alive means no need for the pre-barrier.\n+    access.set_barrier_data(access.barrier_data() & ~G1C2BarrierPre);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -483,0 +483,2 @@\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+\n@@ -487,0 +489,5 @@\n+  if (no_keepalive) {\n+    \/\/ No keep-alive means no need for the pre-barrier.\n+    return BarrierSetC2::store_at_resolved(access, val);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-ZStoreBarrierStubC2* ZStoreBarrierStubC2::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic) {\n+ZStoreBarrierStubC2* ZStoreBarrierStubC2::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive) {\n@@ -244,1 +244,1 @@\n-  ZStoreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic);\n+  ZStoreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic, is_nokeepalive);\n@@ -250,1 +250,2 @@\n-ZStoreBarrierStubC2::ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic)\n+ZStoreBarrierStubC2::ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer,\n+                                         bool is_native, bool is_atomic, bool is_nokeepalive)\n@@ -256,1 +257,2 @@\n-    _is_atomic(is_atomic) {}\n+    _is_atomic(is_atomic),\n+    _is_nokeepalive(is_nokeepalive) {}\n@@ -278,0 +280,4 @@\n+bool ZStoreBarrierStubC2::is_nokeepalive() const {\n+  return _is_nokeepalive;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  const bool     _is_nokeepalive;\n@@ -84,1 +85,1 @@\n-  ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -87,1 +88,1 @@\n-  static ZStoreBarrierStubC2* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  static ZStoreBarrierStubC2* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -94,0 +95,1 @@\n+  bool is_nokeepalive() const;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  static_field(CompilerToVM::Data,             dtanh,                                  address)                                      \\\n@@ -244,1 +245,0 @@\n-  nonstatic_field(JavaThread,                  _poll_data,                                    SafepointMechanism::ThreadData)        \\\n@@ -412,0 +412,1 @@\n+  nonstatic_field(Thread,                   _poll_data,                                       SafepointMechanism::ThreadData)        \\\n@@ -853,0 +854,1 @@\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing))  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -776,0 +776,2 @@\n+  case vmIntrinsics::_Reference_clear0:\n+  case vmIntrinsics::_PhantomReference_clear0:\n@@ -826,0 +828,1 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -653,1 +653,4 @@\n-  CallProjections* callprojs = call->extract_projections(true);\n+  \/\/ Similar to incremental inlining, don't assert that all call\n+  \/\/ projections are still there for post-parse call devirtualization.\n+  bool do_asserts = !is_mh_late_inline() && !is_virtual_late_inline();\n+  CallProjections* callprojs = call->extract_projections(true, do_asserts);\n@@ -687,1 +690,1 @@\n-    kit.replace_call(call, C->top(), true);\n+    kit.replace_call(call, C->top(), true, do_asserts);\n@@ -859,1 +862,1 @@\n-    kit.replace_call(call, result, true);\n+    kit.replace_call(call, result, true, do_asserts);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -345,1 +345,0 @@\n-macro(StoreCM)\n@@ -488,0 +487,1 @@\n+macro(SelectFromTwoVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2101,5 +2101,1 @@\n-      if (n->Opcode() == Op_StoreCM) {\n-        adr_type = get_adr_type(get_alias_index(n->in(MemNode::OopStore)->adr_type()));\n-      } else {\n-        adr_type = get_adr_type(get_alias_index(n->adr_type()));\n-      }\n+      adr_type = get_adr_type(get_alias_index(n->adr_type()));\n@@ -2145,12 +2141,1 @@\n-      if (m->Opcode() == Op_StoreCM) {\n-        adr_type = m->in(MemNode::OopStore)->adr_type();\n-        if (adr_type != TypeAryPtr::INLINES) {\n-          \/\/ store was optimized out and we lost track of the adr_type\n-          Node* clone = new StoreCMNode(m->in(MemNode::Control), m->in(MemNode::Memory), m->in(MemNode::Address),\n-                                        m->adr_type(), m->in(MemNode::ValueIn), m->in(MemNode::OopStore),\n-                                        get_alias_index(adr_type));\n-          igvn.register_new_node_with_optimizer(clone);\n-          igvn.replace_node(m, clone);\n-        }\n-      } else {\n-        adr_type = m->adr_type();\n+      adr_type = m->adr_type();\n@@ -2158,1 +2143,1 @@\n-        m->as_Mem()->set_adr_type(adr_type);\n+      m->as_Mem()->set_adr_type(adr_type);\n@@ -2160,1 +2145,0 @@\n-      }\n@@ -3561,47 +3545,0 @@\n-\/\/ Eliminate trivially redundant StoreCMs and accumulate their\n-\/\/ precedence edges.\n-void Compile::eliminate_redundant_card_marks(Node* n) {\n-  assert(n->Opcode() == Op_StoreCM, \"expected StoreCM\");\n-  if (n->in(MemNode::Address)->outcnt() > 1) {\n-    \/\/ There are multiple users of the same address so it might be\n-    \/\/ possible to eliminate some of the StoreCMs\n-    Node* mem = n->in(MemNode::Memory);\n-    Node* adr = n->in(MemNode::Address);\n-    Node* val = n->in(MemNode::ValueIn);\n-    Node* prev = n;\n-    bool done = false;\n-    \/\/ Walk the chain of StoreCMs eliminating ones that match.  As\n-    \/\/ long as it's a chain of single users then the optimization is\n-    \/\/ safe.  Eliminating partially redundant StoreCMs would require\n-    \/\/ cloning copies down the other paths.\n-    while (mem->Opcode() == Op_StoreCM && mem->outcnt() == 1 && !done) {\n-      if (adr == mem->in(MemNode::Address) &&\n-          val == mem->in(MemNode::ValueIn)) {\n-        \/\/ redundant StoreCM\n-        if (mem->req() > MemNode::OopStore) {\n-          \/\/ Hasn't been processed by this code yet.\n-          n->add_prec(mem->in(MemNode::OopStore));\n-        } else {\n-          \/\/ Already converted to precedence edge\n-          for (uint i = mem->req(); i < mem->len(); i++) {\n-            \/\/ Accumulate any precedence edges\n-            if (mem->in(i) != nullptr) {\n-              n->add_prec(mem->in(i));\n-            }\n-          }\n-          \/\/ Everything above this point has been processed.\n-          done = true;\n-        }\n-        \/\/ Eliminate the previous StoreCM\n-        prev->set_req(MemNode::Memory, mem->in(MemNode::Memory));\n-        assert(mem->outcnt() == 0, \"should be dead\");\n-        mem->disconnect_inputs(this);\n-      } else {\n-        prev = mem;\n-      }\n-      mem = prev->in(MemNode::Memory);\n-    }\n-  }\n-}\n-\n-\n@@ -3777,27 +3714,0 @@\n-\n-  case Op_StoreCM:\n-    {\n-      \/\/ Convert OopStore dependence into precedence edge\n-      Node* prec = n->in(MemNode::OopStore);\n-      n->del_req(MemNode::OopStore);\n-      if (prec->is_MergeMem()) {\n-        MergeMemNode* mm = prec->as_MergeMem();\n-        Node* base = mm->base_memory();\n-        for (int i = AliasIdxRaw + 1; i < num_alias_types(); i++) {\n-          const TypePtr* adr_type = get_adr_type(i);\n-          if (adr_type->is_flat()) {\n-            Node* m = mm->memory_at(i);\n-            n->add_prec(m);\n-          }\n-        }\n-        if (mm->outcnt() == 0) {\n-          mm->disconnect_inputs(this);\n-        }\n-      } else {\n-        n->add_prec(prec);\n-      }\n-      eliminate_redundant_card_marks(n);\n-    }\n-\n-    \/\/ fall through\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":93,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1273,1 +1273,0 @@\n-  void eliminate_redundant_card_marks(Node* n);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4103,4 +4103,0 @@\n-      if (use->Opcode() == Op_StoreCM && use->in(MemNode::OopStore) == n) {\n-        \/\/ Don't move related cardmark.\n-        continue;\n-      }\n@@ -4668,1 +4664,1 @@\n-              op == Op_CastP2X || op == Op_StoreCM ||\n+              op == Op_CastP2X ||\n@@ -4810,3 +4806,0 @@\n-        if (use->Opcode() == Op_StoreCM) { \/\/ Ignore cardmark stores\n-          continue;\n-        }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -219,10 +219,4 @@\n-\n-        \/\/ Only process precedence edges that are CFG nodes. Safepoints and control projections can be in the middle of a block\n-        if (is_CFG(m)) {\n-          node->rm_prec(i);\n-          if (n == nullptr) {\n-            n = m;\n-          } else {\n-            assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n-            n = is_dominator(n, m) ? m : n;\n-          }\n+        assert(is_CFG(m), \"must be a CFG node\");\n+        node->rm_prec(i);\n+        if (n == nullptr) {\n+          n = m;\n@@ -230,2 +224,2 @@\n-          assert(node->is_Mach(), \"sanity\");\n-          assert(node->as_Mach()->ideal_Opcode() == Op_StoreCM, \"must be StoreCM node\");\n+          assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n+          n = is_dominator(n, m) ? m : n;\n@@ -772,1 +766,11 @@\n-    assert(!use_mem_state->needs_anti_dependence_check(), \"no loads\");\n+\n+#ifdef ASSERT\n+    \/\/ CacheWB nodes are peculiar in a sense that they both are anti-dependent and produce memory.\n+    \/\/ Allow them to be treated as a store.\n+    bool is_cache_wb = false;\n+    if (use_mem_state->is_Mach()) {\n+      int ideal_op = use_mem_state->as_Mach()->ideal_Opcode();\n+      is_cache_wb = (ideal_op == Op_CacheWB);\n+    }\n+    assert(!use_mem_state->needs_anti_dependence_check() || is_cache_wb, \"no loads\");\n+#endif\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2095,1 +2095,1 @@\n-void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes) {\n+void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes, bool do_asserts) {\n@@ -2108,1 +2108,1 @@\n-  CallProjections* callprojs = call->extract_projections(true);\n+  CallProjections* callprojs = call->extract_projections(true, do_asserts);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-  void replace_call(CallNode* call, Node* result, bool do_replaced_nodes = false);\n+  void replace_call(CallNode* call, Node* result, bool do_replaced_nodes = false, bool do_asserts = true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,20 +386,0 @@\n-\/\/ Card mark store. Must be ordered so that it will come after the store of\n-\/\/ the oop.\n-Node* IdealKit::storeCM(Node* ctl, Node* adr, Node *val, Node* oop_store, int oop_adr_idx,\n-                        BasicType bt,\n-                        int adr_idx) {\n-  assert(adr_idx != Compile::AliasIdxTop, \"use other store_to_memory factory\" );\n-  const TypePtr* adr_type = nullptr;\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n-  Node *mem = memory(adr_idx);\n-\n-  \/\/ Add required edge to oop_store, optimizer does not support precedence edges.\n-  \/\/ Convert required edge to precedence edge before allocation.\n-  Node* st = new StoreCMNode(ctl, mem, adr, adr_type, val, oop_store, oop_adr_idx);\n-\n-  st = transform(st);\n-  set_memory(st, adr_idx);\n-\n-  return st;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -238,9 +238,0 @@\n-  \/\/ Store a card mark ordered after store_oop\n-  Node* storeCM(Node* ctl,\n-                Node* adr,\n-                Node* val,\n-                Node* oop_store,\n-                int oop_adr_idx,\n-                BasicType bt,\n-                int adr_idx);\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1868,0 +1868,3 @@\n+      break;\n+    case AssertionPredicateType::FinalIv:\n+      st->print(\"#Final IV Assertion Predicate  \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    case Op_StoreCM:\n@@ -751,1 +750,0 @@\n-        case Op_StoreCM:\n@@ -1032,15 +1030,0 @@\n-\n-#ifdef ASSERT\n-      if (UseG1GC) {\n-        if( n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_StoreCM ) {\n-          \/\/ Check the precedence edges\n-          for (uint prec = n->req(); prec < n->len(); prec++) {\n-            Node* oop_store = n->in(prec);\n-            if (oop_store != nullptr) {\n-              assert(get_block_for_node(oop_store)->_dom_depth <= block->_dom_depth, \"oop_store must dominate card-mark\");\n-            }\n-          }\n-        }\n-      }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -590,0 +590,2 @@\n+  case vmIntrinsics::_Reference_clear0:         return inline_reference_clear0(false);\n+  case vmIntrinsics::_PhantomReference_clear0:  return inline_reference_clear0(true);\n@@ -763,0 +765,2 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n+    return inline_vector_select_from_two_vectors();\n@@ -7353,0 +7357,42 @@\n+\/\/----------------------------inline_reference_clear0----------------------------\n+\/\/ void java.lang.ref.Reference.clear0();\n+\/\/ void java.lang.ref.PhantomReference.clear0();\n+bool LibraryCallKit::inline_reference_clear0(bool is_phantom) {\n+  \/\/ This matches the implementation in JVM_ReferenceClear, see the comments there.\n+\n+  \/\/ Get arguments\n+  Node* reference_obj = null_check_receiver();\n+  if (stopped()) return true;\n+\n+  \/\/ Common access parameters\n+  DecoratorSet decorators = IN_HEAP | AS_NO_KEEPALIVE;\n+  decorators |= (is_phantom ? ON_PHANTOM_OOP_REF : ON_WEAK_OOP_REF);\n+  Node* referent_field_addr = basic_plus_adr(reference_obj, java_lang_ref_Reference::referent_offset());\n+  const TypePtr* referent_field_addr_type = _gvn.type(referent_field_addr)->isa_ptr();\n+  const Type* val_type = TypeOopPtr::make_from_klass(env()->Object_klass());\n+\n+  Node* referent = access_load_at(reference_obj,\n+                                  referent_field_addr,\n+                                  referent_field_addr_type,\n+                                  val_type,\n+                                  T_OBJECT,\n+                                  decorators);\n+\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  __ if_then(referent, BoolTest::ne, null());\n+    sync_kit(ideal);\n+    access_store_at(reference_obj,\n+                    referent_field_addr,\n+                    referent_field_addr_type,\n+                    null(),\n+                    val_type,\n+                    T_OBJECT,\n+                    decorators);\n+    __ sync_kit(this);\n+  __ end_if();\n+  final_sync(ideal);\n+#undef __\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+  bool inline_reference_clear0(bool is_phantom);\n@@ -401,0 +402,1 @@\n+  bool inline_vector_select_from_two_vectors();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -959,1 +959,1 @@\n-                                           IdealLoopTree* outer_loop, Node* input_proj);\n+                                           IdealLoopTree* outer_loop, Node* new_control);\n@@ -1392,1 +1392,1 @@\n-                                    Invariance& invar, Deoptimization::DeoptReason reason);\n+                                    Invariance& invar, Deoptimization::DeoptReason deopt_reason);\n@@ -1398,4 +1398,4 @@\n-  IfTrueNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n-                                               ParsePredicateSuccessProj* parse_predicate_proj,\n-                                               IfProjNode* upper_bound_proj, int scale, Node* offset, Node* init, Node* limit,\n-                                               jint stride, Node* rng, bool& overflow, Deoptimization::DeoptReason reason);\n+  IfTrueNode* create_template_assertion_predicate(int if_opcode, CountedLoopNode* loop_head,\n+                                                  ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                  IfProjNode* new_control, int scale, Node* offset,\n+                                                  Node* range, Deoptimization::DeoptReason deopt_reason);\n@@ -1403,3 +1403,0 @@\n-  Node* add_range_check_elimination_assertion_predicate(\n-      IdealLoopTree* loop, Node* predicate_proj, int scale_con, Node* offset, Node* limit, int stride_con, Node* value,\n-      bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4731,1 +4731,0 @@\n-    const Type* bt_t      = Type::get_const_basic_type(bt);\n@@ -4811,1 +4810,1 @@\n-    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt_t);\n+    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2480,0 +2480,1 @@\n+    case Op_SelectFromTwoVector:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-  static const TypeVectMask* predicate_reg_type(const Type* elemTy, int length);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3515,3 +3515,1 @@\n-  \/\/ unsafe if I have intervening uses...  Also disallowed for StoreCM\n-  \/\/ since they must follow each StoreP operation.  Redundant StoreCMs\n-  \/\/ are eliminated just before matching in final_graph_reshape.\n+  \/\/ unsafe if I have intervening uses...\n@@ -3527,1 +3525,1 @@\n-    while (st->is_Store() && st->outcnt() == 1 && st->Opcode() != Op_StoreCM) {\n+    while (st->is_Store() && st->outcnt() == 1) {\n@@ -3835,46 +3833,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* StoreCMNode::Identity(PhaseGVN* phase) {\n-  \/\/ No need to card mark when storing a null ptr\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_Store()) {\n-    const Type *t1 = phase->type( my_store->in(MemNode::ValueIn) );\n-    if( t1 == TypePtr::NULL_PTR ) {\n-      return in(MemNode::Memory);\n-    }\n-  }\n-  return this;\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Ideal---------------------------------------\n-Node *StoreCMNode::Ideal(PhaseGVN *phase, bool can_reshape){\n-  Node* progress = StoreNode::Ideal(phase, can_reshape);\n-  if (progress != nullptr) return progress;\n-\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_MergeMem()) {\n-    if (oop_alias_idx() != phase->C->get_alias_index(TypeAryPtr::INLINES) ||\n-        phase->C->flat_accesses_share_alias()) {\n-      \/\/ The alias that was recorded is no longer accurate enough.\n-      Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n-      set_req_X(MemNode::OopStore, mem, phase);\n-      return this;\n-    }\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/------------------------------Value-----------------------------------------\n-const Type* StoreCMNode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP (checked in StoreNode::Value).\n-  \/\/ If extra input is TOP ==> the result is TOP\n-  const Type* t = phase->type(in(MemNode::OopStore));\n-  if (t == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  return StoreNode::Value(phase);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":50,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-         ValueIn,               \/\/ Value to store\n-         OopStore               \/\/ Preceding oop store, only in StoreCM\n+         ValueIn                \/\/ Value to store\n@@ -783,30 +782,0 @@\n-\/\/------------------------------StoreCMNode-----------------------------------\n-\/\/ Store card-mark byte to memory for CM\n-\/\/ The last StoreCM before a SafePoint must be preserved and occur after its \"oop\" store\n-\/\/ Preceding equivalent StoreCMs may be eliminated.\n-class StoreCMNode : public StoreNode {\n- private:\n-  virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }\n-  virtual bool cmp( const Node &n ) const {\n-    return _oop_alias_idx == ((StoreCMNode&)n)._oop_alias_idx\n-      && StoreNode::cmp(n);\n-  }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  int _oop_alias_idx;   \/\/ The alias_idx of OopStore\n-\n-public:\n-  StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :\n-    StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),\n-    _oop_alias_idx(oop_alias_idx) {\n-    assert(_oop_alias_idx >= Compile::AliasIdxRaw ||\n-           (_oop_alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing()),\n-           \"bad oop alias idx\");\n-  }\n-  virtual int Opcode() const;\n-  virtual Node* Identity(PhaseGVN* phase);\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual BasicType memory_type() const { return T_VOID; } \/\/ unspecific\n-  int oop_alias_idx() const { return _oop_alias_idx; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1737,24 +1737,1 @@\n-        }\n-#ifdef ASSERT\n-          \/\/ Check that oop-store precedes the card-mark\n-        else if (mach->ideal_Opcode() == Op_StoreCM) {\n-          uint storeCM_idx = j;\n-          int count = 0;\n-          for (uint prec = mach->req(); prec < mach->len(); prec++) {\n-            Node *oop_store = mach->in(prec);  \/\/ Precedence edge\n-            if (oop_store == nullptr) continue;\n-            count++;\n-            uint i4;\n-            for (i4 = 0; i4 < last_inst; ++i4) {\n-              if (block->get_node(i4) == oop_store) {\n-                break;\n-              }\n-            }\n-            \/\/ Note: This test can provide a false failure if other precedence\n-            \/\/ edges have been added to the storeCMNode.\n-            assert(i4 == last_inst || i4 < storeCM_idx, \"CM card-mark executes before oop-store\");\n-          }\n-          assert(count > 0, \"storeCM expects at least one precedence edge\");\n-        }\n-#endif\n-        else if (!n->is_Proj()) {\n+        } else if (!n->is_Proj()) {\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -737,1 +737,1 @@\n-  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(TypeInt::BOOL, MaxVectorSize))->hashcons();\n+  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(T_BOOLEAN, MaxVectorSize))->hashcons();\n@@ -745,2 +745,2 @@\n-  if (Matcher::vector_size_supported(T_BYTE,4)) {\n-    TypeVect::VECTS = TypeVect::make(T_BYTE,4);\n+  if (Matcher::vector_size_supported(T_BYTE, 4)) {\n+    TypeVect::VECTS = TypeVect::make(T_BYTE, 4);\n@@ -748,2 +748,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,2)) {\n-    TypeVect::VECTD = TypeVect::make(T_FLOAT,2);\n+  if (Matcher::vector_size_supported(T_FLOAT, 2)) {\n+    TypeVect::VECTD = TypeVect::make(T_FLOAT, 2);\n@@ -751,2 +751,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,4)) {\n-    TypeVect::VECTX = TypeVect::make(T_FLOAT,4);\n+  if (Matcher::vector_size_supported(T_FLOAT, 4)) {\n+    TypeVect::VECTX = TypeVect::make(T_FLOAT, 4);\n@@ -754,2 +754,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,8)) {\n-    TypeVect::VECTY = TypeVect::make(T_FLOAT,8);\n+  if (Matcher::vector_size_supported(T_FLOAT, 8)) {\n+    TypeVect::VECTY = TypeVect::make(T_FLOAT, 8);\n@@ -757,2 +757,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,16)) {\n-    TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);\n+  if (Matcher::vector_size_supported(T_FLOAT, 16)) {\n+    TypeVect::VECTZ = TypeVect::make(T_FLOAT, 16);\n@@ -2617,7 +2617,7 @@\n-const TypeVect *TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n-const TypeVect *TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n-const TypeVect *TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n-const TypeVect *TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n-const TypeVect *TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n-const TypeVect *TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n-const TypeVect *TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n+const TypeVect* TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n+const TypeVect* TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n+const TypeVect* TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n+const TypeVect* TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n+const TypeVect* TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n+const TypeVect* TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n+const TypeVect* TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n@@ -2626,1 +2626,1 @@\n-const TypeVect* TypeVect::make(const Type *elem, uint length, bool is_mask) {\n+const TypeVect* TypeVect::make(BasicType elem_bt, uint length, bool is_mask) {\n@@ -2628,1 +2628,1 @@\n-    return makemask(elem, length);\n+    return makemask(elem_bt, length);\n@@ -2630,1 +2630,0 @@\n-  BasicType elem_bt = elem->array_element_basic_type();\n@@ -2636,1 +2635,1 @@\n-    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectA(elem_bt, length))->hashcons();\n@@ -2638,1 +2637,1 @@\n-    return (TypeVect*)(new TypeVectS(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectS(elem_bt, length))->hashcons();\n@@ -2642,1 +2641,1 @@\n-    return (TypeVect*)(new TypeVectD(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectD(elem_bt, length))->hashcons();\n@@ -2644,1 +2643,1 @@\n-    return (TypeVect*)(new TypeVectX(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectX(elem_bt, length))->hashcons();\n@@ -2646,1 +2645,1 @@\n-    return (TypeVect*)(new TypeVectY(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectY(elem_bt, length))->hashcons();\n@@ -2648,1 +2647,1 @@\n-    return (TypeVect*)(new TypeVectZ(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectZ(elem_bt, length))->hashcons();\n@@ -2654,2 +2653,1 @@\n-const TypeVect *TypeVect::makemask(const Type* elem, uint length) {\n-  BasicType elem_bt = elem->array_element_basic_type();\n+const TypeVect* TypeVect::makemask(BasicType elem_bt, uint length) {\n@@ -2658,1 +2656,1 @@\n-    return TypeVectMask::make(elem, length);\n+    return TypeVectMask::make(elem_bt, length);\n@@ -2660,1 +2658,1 @@\n-    return make(elem, length);\n+    return make(elem_bt, length);\n@@ -2665,2 +2663,3 @@\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeVect::xmeet( const Type *t ) const {\n+\/\/ Compute the MEET of two types. Since each TypeVect is the only instance of\n+\/\/ its species, meeting often returns itself\n+const Type* TypeVect::xmeet(const Type* t) const {\n@@ -2668,1 +2667,3 @@\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (this == t) {\n+    return this;\n+  }\n@@ -2678,7 +2679,1 @@\n-  case VectorMask: {\n-    const TypeVectMask* v = t->is_vectmask();\n-    assert(  base() == v->base(), \"\");\n-    assert(length() == v->length(), \"\");\n-    assert(element_basic_type() == v->element_basic_type(), \"\");\n-    return TypeVect::makemask(_elem->xmeet(v->_elem), _length);\n-  }\n+  case VectorMask:\n@@ -2692,1 +2687,1 @@\n-    assert(  base() == v->base(), \"\");\n+    assert(base() == v->base(), \"\");\n@@ -2695,1 +2690,1 @@\n-    return TypeVect::make(_elem->xmeet(v->_elem), _length);\n+    return this;\n@@ -2704,3 +2699,3 @@\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeVect::xdual() const {\n-  return new TypeVect(base(), _elem->dual(), _length);\n+\/\/ Since each TypeVect is the only instance of its species, it is self-dual\n+const Type* TypeVect::xdual() const {\n+  return this;\n@@ -2711,3 +2706,3 @@\n-bool TypeVect::eq(const Type *t) const {\n-  const TypeVect *v = t->is_vect();\n-  return (_elem == v->_elem) && (_length == v->_length);\n+bool TypeVect::eq(const Type* t) const {\n+  const TypeVect* v = t->is_vect();\n+  return (element_basic_type() == v->element_basic_type()) && (length() == v->length());\n@@ -2719,1 +2714,1 @@\n-  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_length;\n+  return (uint)base() + (uint)(uintptr_t)_elem_bt + (uint)(uintptr_t)_length;\n@@ -2723,1 +2718,1 @@\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple\n@@ -2733,1 +2728,1 @@\n-  return _elem->empty();\n+  return false;\n@@ -2738,1 +2733,1 @@\n-void TypeVect::dump2(Dict &d, uint depth, outputStream *st) const {\n+void TypeVect::dump2(Dict& d, uint depth, outputStream* st) const {\n@@ -2741,1 +2736,1 @@\n-    st->print(\"vectora[\"); break;\n+    st->print(\"vectora\"); break;\n@@ -2743,1 +2738,1 @@\n-    st->print(\"vectors[\"); break;\n+    st->print(\"vectors\"); break;\n@@ -2745,1 +2740,1 @@\n-    st->print(\"vectord[\"); break;\n+    st->print(\"vectord\"); break;\n@@ -2747,1 +2742,1 @@\n-    st->print(\"vectorx[\"); break;\n+    st->print(\"vectorx\"); break;\n@@ -2749,1 +2744,1 @@\n-    st->print(\"vectory[\"); break;\n+    st->print(\"vectory\"); break;\n@@ -2751,1 +2746,1 @@\n-    st->print(\"vectorz[\"); break;\n+    st->print(\"vectorz\"); break;\n@@ -2753,1 +2748,1 @@\n-    st->print(\"vectormask[\"); break;\n+    st->print(\"vectormask\"); break;\n@@ -2757,3 +2752,1 @@\n-  st->print(\"%d]:{\", _length);\n-  _elem->dump2(d, depth, st);\n-  st->print(\"}\");\n+  st->print(\"<%c,%u>\", type2char(element_basic_type()), length());\n@@ -2763,16 +2756,2 @@\n-bool TypeVectMask::eq(const Type *t) const {\n-  const TypeVectMask *v = t->is_vectmask();\n-  return (element_type() == v->element_type()) && (length() == v->length());\n-}\n-\n-const Type *TypeVectMask::xdual() const {\n-  return new TypeVectMask(element_type()->dual(), length());\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const BasicType elem_bt, uint length) {\n-  return make(get_const_basic_type(elem_bt), length);\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const Type* elem, uint length) {\n-  const TypeVectMask* mtype = Matcher::predicate_reg_type(elem, length);\n-  return (TypeVectMask*) const_cast<TypeVectMask*>(mtype)->hashcons();\n+const TypeVectMask* TypeVectMask::make(const BasicType elem_bt, uint length) {\n+  return (TypeVectMask*) (new TypeVectMask(elem_bt, length))->hashcons();\n@@ -3247,2 +3226,2 @@\n-const TypeRawPtr *TypeRawPtr::make( address bits ) {\n-  assert( bits, \"Use TypePtr for null\" );\n+const TypeRawPtr *TypeRawPtr::make(address bits) {\n+  assert(bits != nullptr, \"Use TypePtr for null\");\n@@ -3337,4 +3316,11 @@\n-  case TypePtr::Null:\n-    address bits = _bits+offset;\n-    if ( bits == 0 ) return TypePtr::NULL_PTR;\n-    return make( bits );\n+    uintptr_t bits = (uintptr_t)_bits;\n+    uintptr_t sum = bits + offset;\n+    if (( offset < 0 )\n+        ? ( sum > bits )        \/\/ Underflow?\n+        : ( sum < bits )) {     \/\/ Overflow?\n+      return BOTTOM;\n+    } else if ( sum == 0 ) {\n+      return TypePtr::NULL_PTR;\n+    } else {\n+      return make( (address)sum );\n+    }\n@@ -3345,1 +3331,0 @@\n-  return nullptr;                  \/\/ Lint noise\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":71,"deletions":86,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -823,2 +823,2 @@\n-  const Type*   _elem;  \/\/ Vector's element type\n-  const uint  _length;  \/\/ Elements in vector (power of 2)\n+  const BasicType _elem_bt;  \/\/ Vector's element type\n+  const uint _length;  \/\/ Elements in vector (power of 2)\n@@ -827,2 +827,2 @@\n-  TypeVect(TYPES t, const Type* elem, uint length) : Type(t),\n-    _elem(elem), _length(length) {}\n+  TypeVect(TYPES t, BasicType elem_bt, uint length) : Type(t),\n+    _elem_bt(elem_bt), _length(length) {}\n@@ -831,2 +831,1 @@\n-  const Type* element_type() const { return _elem; }\n-  BasicType element_basic_type() const { return _elem->array_element_basic_type(); }\n+  BasicType element_basic_type() const { return _elem_bt; }\n@@ -835,1 +834,1 @@\n-   return _length * type2aelembytes(element_basic_type());\n+    return _length * type2aelembytes(element_basic_type());\n@@ -838,1 +837,1 @@\n-  virtual bool eq(const Type *t) const;\n+  virtual bool eq(const Type* t) const;\n@@ -843,13 +842,2 @@\n-  static const TypeVect *make(const BasicType elem_bt, uint length, bool is_mask = false) {\n-    \/\/ Use bottom primitive type.\n-    return make(get_const_basic_type(elem_bt), length, is_mask);\n-  }\n-  \/\/ Used directly by Replicate nodes to construct singleton vector.\n-  static const TypeVect *make(const Type* elem, uint length, bool is_mask = false);\n-\n-  static const TypeVect *makemask(const BasicType elem_bt, uint length) {\n-    \/\/ Use bottom primitive type.\n-    return makemask(get_const_basic_type(elem_bt), length);\n-  }\n-  static const TypeVect *makemask(const Type* elem, uint length);\n-\n+  static const TypeVect* make(const BasicType elem_bt, uint length, bool is_mask = false);\n+  static const TypeVect* makemask(const BasicType elem_bt, uint length);\n@@ -857,2 +845,2 @@\n-  virtual const Type *xmeet( const Type *t) const;\n-  virtual const Type *xdual() const;     \/\/ Compute dual right now.\n+  virtual const Type* xmeet( const Type *t) const;\n+  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n@@ -860,7 +848,7 @@\n-  static const TypeVect *VECTA;\n-  static const TypeVect *VECTS;\n-  static const TypeVect *VECTD;\n-  static const TypeVect *VECTX;\n-  static const TypeVect *VECTY;\n-  static const TypeVect *VECTZ;\n-  static const TypeVect *VECTMASK;\n+  static const TypeVect* VECTA;\n+  static const TypeVect* VECTS;\n+  static const TypeVect* VECTD;\n+  static const TypeVect* VECTX;\n+  static const TypeVect* VECTY;\n+  static const TypeVect* VECTZ;\n+  static const TypeVect* VECTMASK;\n@@ -869,1 +857,1 @@\n-  virtual void dump2(Dict &d, uint, outputStream *st) const; \/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n@@ -875,1 +863,1 @@\n-  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+  TypeVectA(BasicType elem_bt, uint length) : TypeVect(VectorA, elem_bt, length) {}\n@@ -880,1 +868,1 @@\n-  TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}\n+  TypeVectS(BasicType elem_bt, uint length) : TypeVect(VectorS, elem_bt, length) {}\n@@ -885,1 +873,1 @@\n-  TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}\n+  TypeVectD(BasicType elem_bt, uint length) : TypeVect(VectorD, elem_bt, length) {}\n@@ -890,1 +878,1 @@\n-  TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}\n+  TypeVectX(BasicType elem_bt, uint length) : TypeVect(VectorX, elem_bt, length) {}\n@@ -895,1 +883,1 @@\n-  TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}\n+  TypeVectY(BasicType elem_bt, uint length) : TypeVect(VectorY, elem_bt, length) {}\n@@ -900,1 +888,1 @@\n-  TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}\n+  TypeVectZ(BasicType elem_bt, uint length) : TypeVect(VectorZ, elem_bt, length) {}\n@@ -906,3 +894,1 @@\n-  TypeVectMask(const Type* elem, uint length) : TypeVect(VectorMask, elem, length) {}\n-  virtual bool eq(const Type *t) const;\n-  virtual const Type *xdual() const;\n+  TypeVectMask(BasicType elem_bt, uint length) : TypeVect(VectorMask, elem_bt, length) {}\n@@ -910,1 +896,0 @@\n-  static const TypeVectMask* make(const Type* elem, uint length);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":26,"deletions":41,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -242,2 +242,0 @@\n- private:\n-  SafepointMechanism::ThreadData _poll_data;\n@@ -602,0 +600,16 @@\n+  static ByteSize polling_word_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_word);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n+  static ByteSize polling_page_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_page);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n@@ -795,2 +809,0 @@\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -669,0 +670,5 @@\n+  if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && CreateCoredumpOnCrash) {\n+    char buffer[2*JVM_MAXPATHLEN];\n+    os::check_core_dump_prerequisites(buffer, sizeof(buffer), true);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1598,1 +1598,0 @@\n-  declare_c2_type(StoreCMNode, StoreNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1229,1 +1229,0 @@\n-#ifndef _WIN64\n@@ -1232,1 +1231,1 @@\n-    const char* absname = os::Posix::realpath(name, tmp, sizeof(tmp));\n+    const char* absname = os::realpath(name, tmp, sizeof(tmp));\n@@ -1234,1 +1233,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-FORBID_C_FUNCTION(char* realpath(const char* path, char* resolved_path), \"use os::Posix::realpath\");\n+FORBID_C_FUNCTION(char* realpath(const char* path, char* resolved_path), \"use os::realpath\");\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.internal.loader.ClassLoaders;\n@@ -375,1 +376,2 @@\n-        return ClassFile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n+        return ClassFile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader == null ?\n+                        ClassLoaders.platformClassLoader() : loader)))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,13 @@\n+    \/* Override the implementation of Reference.clear.\n+     * Phantom references are weaker than finalization, so the referent\n+     * access needs to be handled differently for garbage collectors that\n+     * do reference processing concurrently.\n+     *\/\n+    @Override\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n+    private native void clear0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-        clear0();\n+        clearImpl();\n@@ -414,3 +414,8 @@\n-    \/* Implementation of clear(), also used by enqueue().  A simple\n-     * assignment of the referent field won't do for some garbage\n-     * collectors.\n+    \/* Implementation of clear(). A simple assignment of the referent field\n+     * won't do for some garbage collectors. There is the override for phantom\n+     * references, which requires different semantics. This method is also\n+     * used by enqueue().\n+     *\n+     * <p>This method exists only to avoid making clear0() virtual. Making\n+     * clear0() virtual has the undesirable effect of C2 often preferring\n+     * to call the native implementation over the intrinsic.\n@@ -418,0 +423,5 @@\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n@@ -519,1 +529,1 @@\n-        clear0();               \/\/ Intentionally clear0() rather than clear()\n+        clearImpl(); \/\/ Intentionally clearImpl() to dispatch to overridden method, if needed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-        protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, CharacterRangeTableAttribute attr) {\n@@ -145,0 +145,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -147,4 +148,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.endPc());\n-                buf.writeInt(info.characterRangeStart());\n-                buf.writeInt(info.characterRangeEnd());\n+                buf.writeU2U2(info.startPc(), info.endPc());\n+                buf.writeIntInt(info.characterRangeStart(), info.characterRangeEnd());\n@@ -241,3 +240,4 @@\n-        protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n-            buf.writeIndex(attr.enclosingClass());\n-            buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n+        protected void writeBody(BufWriter bufWriter, EnclosingMethodAttribute attr) {\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2(buf.cpIndex(attr.enclosingClass()),\n+                    buf.cpIndexOrZero(attr.enclosingMethod().orElse(null)));\n@@ -278,1 +278,1 @@\n-        protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, InnerClassesAttribute attr) {\n@@ -280,0 +280,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -282,3 +283,3 @@\n-                buf.writeIndex(ic.innerClass());\n-                buf.writeIndexOrZero(ic.outerClass().orElse(null));\n-                buf.writeIndexOrZero(ic.innerName().orElse(null));\n+                buf.writeU2U2U2(buf.cpIndex(ic.innerClass()),\n+                        buf.cpIndexOrZero(ic.outerClass().orElse(null)),\n+                        buf.cpIndexOrZero(ic.innerName().orElse(null)));\n@@ -303,1 +304,1 @@\n-        protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LineNumberTableAttribute attr) {\n@@ -305,0 +306,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -307,2 +309,1 @@\n-                buf.writeU2(line.startPc());\n-                buf.writeU2(line.lineNumber());\n+                buf.writeU2U2(line.startPc(), line.lineNumber());\n@@ -344,1 +345,1 @@\n-        protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LocalVariableTableAttribute attr) {\n@@ -346,0 +347,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -348,5 +350,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.length());\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.type());\n-                buf.writeU2(info.slot());\n+                buf.writeU2U2(info.startPc(), info.length());\n+                buf.writeU2U2U2(buf.cpIndex(info.name()), buf.cpIndex(info.type()), info.slot());\n@@ -370,1 +369,1 @@\n-        protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LocalVariableTypeTableAttribute attr) {\n@@ -372,0 +371,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -374,5 +374,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.length());\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.signature());\n-                buf.writeU2(info.slot());\n+                buf.writeU2U2(info.startPc(), info.length());\n+                buf.writeU2U2U2(buf.cpIndex(info.name()), buf.cpIndex(info.signature()), info.slot());\n@@ -396,1 +393,1 @@\n-        protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, MethodParametersAttribute attr) {\n@@ -398,0 +395,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -400,2 +398,2 @@\n-                buf.writeIndexOrZero(info.name().orElse(null));\n-                buf.writeU2(info.flagsMask());\n+                buf.writeU2U2(buf.cpIndexOrZero(info.name().orElse(null)),\n+                        info.flagsMask());\n@@ -419,4 +417,5 @@\n-        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n-            buf.writeIndex(attr.moduleName());\n-            buf.writeU2(attr.moduleFlagsMask());\n-            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+        protected void writeBody(BufWriter bufWriter, ModuleAttribute attr) {\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2U2(buf.cpIndex(attr.moduleName()),\n+                    attr.moduleFlagsMask(),\n+                    buf.cpIndexOrZero(attr.moduleVersion().orElse(null)));\n@@ -425,3 +424,3 @@\n-                buf.writeIndex(require.requires());\n-                buf.writeU2(require.requiresFlagsMask());\n-                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+                buf.writeU2U2U2(buf.cpIndex(require.requires()),\n+                        require.requiresFlagsMask(),\n+                        buf.cpIndexOrZero(require.requiresVersion().orElse(null)));\n@@ -431,2 +430,2 @@\n-                buf.writeIndex(export.exportedPackage());\n-                buf.writeU2(export.exportsFlagsMask());\n+                buf.writeU2U2(buf.cpIndex(export.exportedPackage()),\n+                        export.exportsFlagsMask());\n@@ -437,2 +436,2 @@\n-                buf.writeIndex(open.openedPackage());\n-                buf.writeU2(open.opensFlagsMask());\n+                buf.writeU2U2(buf.cpIndex(open.openedPackage()),\n+                        open.opensFlagsMask());\n@@ -463,2 +462,1 @@\n-        protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n-            buf.writeIndex(attr.algorithm());\n+        protected void writeBody(BufWriter bufWriter, ModuleHashesAttribute attr) {\n@@ -466,1 +464,2 @@\n-            buf.writeU2(hashes.size());\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2(buf.cpIndex(attr.algorithm()), hashes.size());\n@@ -468,2 +467,2 @@\n-                buf.writeIndex(hash.moduleName());\n-                buf.writeU2(hash.hash().length);\n+                buf.writeU2U2(buf.cpIndex(hash.moduleName()),\n+                        hash.hash().length);\n@@ -614,1 +613,1 @@\n-        protected void writeBody(BufWriter buf, RecordAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, RecordAttribute attr) {\n@@ -616,0 +615,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -618,3 +618,3 @@\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.descriptor());\n-                Util.writeAttributes((BufWriterImpl) buf, info.attributes());\n+                buf.writeU2U2(buf.cpIndex(info.name()),\n+                        buf.cpIndex(info.descriptor()));\n+                Util.writeAttributes(buf, info.attributes());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -567,0 +568,1 @@\n+        requireNonNull(verbosity); \/\/ we are using == checks in implementations\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -153,1 +155,1 @@\n-            this.entry = entry;\n+            this.entry = requireNonNull(entry);\n@@ -186,1 +188,1 @@\n-            this.signature = signature;\n+            this.signature = requireNonNull(signature);\n@@ -218,1 +220,1 @@\n-            this.annotationDefault = annotationDefault;\n+            this.annotationDefault = requireNonNull(annotationDefault);\n@@ -233,1 +235,1 @@\n-            this.sourceFile = sourceFile;\n+            this.sourceFile = requireNonNull(sourceFile);\n@@ -298,1 +300,1 @@\n-            this.classEntry = classEntry;\n+            this.classEntry = requireNonNull(classEntry);\n@@ -336,1 +338,1 @@\n-            this.moduleTarget = moduleTarget;\n+            this.moduleTarget = requireNonNull(moduleTarget);\n@@ -352,1 +354,1 @@\n-            this.mainClass = mainClass;\n+            this.mainClass = requireNonNull(mainClass);\n@@ -369,1 +371,1 @@\n-            this.algorithm = algorithm;\n+            this.algorithm = requireNonNull(algorithm);\n@@ -471,1 +473,1 @@\n-            this.hostEntry = hostEntry;\n+            this.hostEntry = requireNonNull(hostEntry);\n@@ -487,1 +489,1 @@\n-            this.idEntry = idEntry;\n+            this.idEntry = requireNonNull(idEntry);\n@@ -503,1 +505,1 @@\n-            this.idEntry = idEntry;\n+            this.idEntry = requireNonNull(idEntry);\n@@ -519,1 +521,1 @@\n-            this.contents = contents;\n+            this.contents = requireNonNull(contents);\n@@ -631,1 +633,7 @@\n-            this.elements = List.copyOf(elements);\n+            \/\/ deep copy\n+            var array = elements.toArray().clone();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = List.copyOf((List<?>) array[i]);\n+            }\n+\n+            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n@@ -704,1 +712,7 @@\n-            implements InnerClassInfo {}\n+            implements InnerClassInfo {\n+        public UnboundInnerClassInfo {\n+            requireNonNull(innerClass);\n+            requireNonNull(outerClass);\n+            requireNonNull(innerName);\n+        }\n+    }\n@@ -713,1 +727,6 @@\n-            implements LocalVariableInfo { }\n+            implements LocalVariableInfo {\n+        public UnboundLocalVariableInfo {\n+            requireNonNull(name);\n+            requireNonNull(type);\n+        }\n+    }\n@@ -719,1 +738,6 @@\n-            implements LocalVariableTypeInfo { }\n+            implements LocalVariableTypeInfo {\n+        public UnboundLocalVariableTypeInfo {\n+            requireNonNull(name);\n+            requireNonNull(signature);\n+        }\n+    }\n@@ -722,1 +746,5 @@\n-            implements MethodParameterInfo {}\n+            implements MethodParameterInfo {\n+        public UnboundMethodParameterInfo {\n+            requireNonNull(name);\n+        }\n+    }\n@@ -728,5 +756,3 @@\n-        public UnboundModuleExportInfo(PackageEntry exportedPackage, int exportsFlagsMask,\n-                                       List<ModuleEntry> exportsTo) {\n-            this.exportedPackage = exportedPackage;\n-            this.exportsFlagsMask = exportsFlagsMask;\n-            this.exportsTo = List.copyOf(exportsTo);\n+        public UnboundModuleExportInfo {\n+            requireNonNull(exportedPackage);\n+            exportsTo = List.copyOf(exportsTo);\n@@ -737,1 +763,6 @@\n-                                        byte[] hash) implements ModuleHashInfo { }\n+                                        byte[] hash) implements ModuleHashInfo {\n+        public UnboundModuleHashInfo {\n+            requireNonNull(moduleName);\n+            requireNonNull(hash);\n+        }\n+    }\n@@ -742,5 +773,3 @@\n-        public UnboundModuleOpenInfo(PackageEntry openedPackage, int opensFlagsMask,\n-                                     List<ModuleEntry> opensTo) {\n-            this.openedPackage = openedPackage;\n-            this.opensFlagsMask = opensFlagsMask;\n-            this.opensTo = List.copyOf(opensTo);\n+        public UnboundModuleOpenInfo {\n+            requireNonNull(openedPackage);\n+            opensTo = List.copyOf(opensTo);\n@@ -753,3 +782,3 @@\n-        public UnboundModuleProvideInfo(ClassEntry provides, List<ClassEntry> providesWith) {\n-            this.provides = provides;\n-            this.providesWith = List.copyOf(providesWith);\n+        public UnboundModuleProvideInfo {\n+            requireNonNull(provides);\n+            providesWith = List.copyOf(providesWith);\n@@ -761,1 +790,6 @@\n-            implements ModuleRequireInfo {}\n+            implements ModuleRequireInfo {\n+        public UnboundModuleRequiresInfo {\n+            requireNonNull(requires);\n+            requireNonNull(requiresVersion);\n+        }\n+    }\n@@ -767,4 +801,4 @@\n-        public UnboundRecordComponentInfo(Utf8Entry name, Utf8Entry descriptor, List<Attribute<?>> attributes) {\n-            this.name = name;\n-            this.descriptor = descriptor;\n-            this.attributes = List.copyOf(attributes);\n+        public UnboundRecordComponentInfo {\n+            requireNonNull(name);\n+            requireNonNull(descriptor);\n+            attributes = List.copyOf(attributes);\n@@ -779,0 +813,1 @@\n+            requireNonNull(targetInfo);\n@@ -780,0 +815,1 @@\n+            requireNonNull(annotation);\n@@ -806,1 +842,1 @@\n-            this.moduleName = moduleName;\n+            this.moduleName = requireNonNull(moduleName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":73,"deletions":37,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -431,0 +431,17 @@\n+        noModule = new ModuleSymbol(names.empty, null) {\n+            @Override public boolean isNoModule() {\n+                return true;\n+            }\n+        };\n+        addRootPackageFor(noModule);\n+\n+        Source source = Source.instance(context);\n+        if (Feature.MODULES.allowedInSource(source)) {\n+            java_base = enterModule(names.java_base);\n+            \/\/avoid completing java.base during the Symtab initialization\n+            java_base.completer = Completer.NULL_COMPLETER;\n+            java_base.visiblePackages = Collections.emptyMap();\n+        } else {\n+            java_base = noModule;\n+        }\n+\n@@ -438,1 +455,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -458,1 +474,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -467,7 +482,0 @@\n-        noModule = new ModuleSymbol(names.empty, null) {\n-            @Override public boolean isNoModule() {\n-                return true;\n-            }\n-        };\n-        addRootPackageFor(noModule);\n-\n@@ -537,10 +545,0 @@\n-        Source source = Source.instance(context);\n-        if (Feature.MODULES.allowedInSource(source)) {\n-            java_base = enterModule(names.java_base);\n-            \/\/avoid completing java.base during the Symtab initialization\n-            java_base.completer = Completer.NULL_COMPLETER;\n-            java_base.visiblePackages = Collections.emptyMap();\n-        } else {\n-            java_base = noModule;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-applications\/ctw\/modules\/java_base_2.java 8341831 linux-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,7 +123,7 @@\n-    private static final String TYPE_BYTE   = \"byte\";\n-    private static final String TYPE_CHAR   = \"char\";\n-    private static final String TYPE_SHORT  = \"short\";\n-    private static final String TYPE_INT    = \"int\";\n-    private static final String TYPE_LONG   = \"long\";\n-    private static final String TYPE_FLOAT  = \"float\";\n-    private static final String TYPE_DOUBLE = \"double\";\n+    private static final String TYPE_BYTE   = \"B\";\n+    private static final String TYPE_CHAR   = \"C\";\n+    private static final String TYPE_SHORT  = \"S\";\n+    private static final String TYPE_INT    = \"I\";\n+    private static final String TYPE_LONG   = \"J\";\n+    private static final String TYPE_FLOAT  = \"F\";\n+    private static final String TYPE_DOUBLE = \"D\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2433,0 +2433,1 @@\n+    \/* FIX: JDK-8344532\n@@ -2437,0 +2438,1 @@\n+    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+java\/awt\/dnd\/CustomDragCursorTest.java 8242805 macosx-all\n@@ -146,0 +147,1 @@\n+java\/awt\/EventQueue\/PushPopDeadlock\/PushPopDeadlock.java 8024034 generic-all\n@@ -202,0 +204,3 @@\n+java\/awt\/dnd\/DnDRemoveFocusOwnerCrashTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DnDCursorCrashTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DnDClipboardDeadlockTest.java 8079553 linux-all\n@@ -476,0 +481,5 @@\n+java\/awt\/Dialog\/PrintToFileTest\/PrintToFileRevoked.java 8029249 macosx-all\n+java\/awt\/Dialog\/PrintToFileTest\/PrintToFileGranted.java 8029249 macosx-all\n+java\/awt\/Dialog\/ChoiceModalDialogTest.java 8161475 macosx-all\n+java\/awt\/Dialog\/FileDialogUserFilterTest.java 8001142 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,2 @@\n-    :jdk_jpackage\n+    :jdk_jpackage \\\n+    :jdk_since_checks\n@@ -677,0 +678,4 @@\n+\n+# Set of tests for `@since` checks in source code documentation\n+jdk_since_checks = \\\n+   tools\/sincechecker\/modules\/java_base\/CheckSince_javaBase.java\n","filename":"test\/jdk\/TEST.groups","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-        map.put(\"docker.support\", this::dockerSupport);\n+        map.put(\"container.support\", this::containerSupport);\n@@ -589,1 +589,1 @@\n-     * A simple check for docker support\n+     * A simple check for container support\n@@ -591,1 +591,1 @@\n-     * @return true if docker is supported in a given environment\n+     * @return true if container is supported in a given environment\n@@ -593,2 +593,2 @@\n-    protected String dockerSupport() {\n-        log(\"Entering dockerSupport()\");\n+    protected String containerSupport() {\n+        log(\"Entering containerSupport()\");\n@@ -598,1 +598,1 @@\n-           \/\/ currently docker testing is only supported for Linux,\n+           \/\/ currently container testing is only supported for Linux,\n@@ -614,1 +614,1 @@\n-        log(\"dockerSupport(): platform check: isSupported = \" + isSupported);\n+        log(\"containerSupport(): platform check: isSupported = \" + isSupported);\n@@ -618,1 +618,1 @@\n-              isSupported = checkProgramSupport(\"checkDockerSupport()\", Container.ENGINE_COMMAND);\n+              isSupported = checkProgramSupport(\"checkContainerSupport()\", Container.ENGINE_COMMAND);\n@@ -624,1 +624,1 @@\n-        log(\"dockerSupport(): returning isSupported = \" + isSupported);\n+        log(\"containerSupport(): returning isSupported = \" + isSupported);\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}