{"files":[{"patch":"@@ -611,1 +611,1 @@\n-      java.base-copy jdk.jdeps-launchers\n+      java.base-copy jdk.jdeps-launchers jdk.compiler-launchers\n@@ -614,2 +614,2 @@\n-BUILDJDK_MODULES := $(sort $(foreach m, jdk.jlink $(INTERIM_IMAGE_MODULES), \\\n-    $(call FindTransitiveDepsForModule, $m) $m))\n+BUILDJDK_MODULES := $(sort $(foreach m, jdk.jlink jdk.compiler \\\n+    $(INTERIM_IMAGE_MODULES), $(call FindTransitiveDepsForModule, $m) $m))\n@@ -869,8 +869,0 @@\n-################################################################################\n-# Install targets\n-\n-$(eval $(call SetupTarget, install, \\\n-    MAKEFILE := Install, \\\n-    DEPS := product-images, \\\n-))\n-\n@@ -974,1 +966,14 @@\n-  jdk.compiler-gendata: $(GENSRC_MODULEINFO_TARGETS)\n+  jdk.compiler-gendata: $(GENSRC_MODULEINFO_TARGETS) $(JAVA_TARGETS)\n+  # jdk.compiler-gendata needs the BUILD_JDK. If the BUILD_JDK was supplied\n+  # externally, no extra prerequisites are needed.\n+  ifeq ($(CREATE_BUILDJDK), true)\n+    ifneq ($(CREATING_BUILDJDK), true)\n+      # When cross compiling and an external BUILD_JDK wasn't supplied, it's\n+      # produced by the create-buildjdk target.\n+      jdk.compiler-gendata: create-buildjdk\n+    endif\n+  else ifeq ($(EXTERNAL_BUILDJDK), false)\n+    # When not cross compiling, the BUILD_JDK is the interim jdk image, and\n+    # the javac launcher is needed.\n+    jdk.compiler-gendata: jdk.compiler-launchers\n+  endif\n","filename":"make\/Main.gmk","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -410,0 +410,2 @@\n+    var cross_compiling = input.build_platform != input.target_platform;\n+\n@@ -487,1 +489,0 @@\n-            build_cpu: \"x64\",\n@@ -490,1 +491,0 @@\n-                \"--openjdk-target=aarch64-linux-gnu\",\n@@ -494,1 +494,1 @@\n-            ],\n+\t    ].concat(cross_compiling ? [\"--openjdk-target=aarch64-linux-gnu\"] : []),\n","filename":"make\/conf\/jib-profiles.js","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -211,1 +211,0 @@\n-JVM_SupportsCX8\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+import java.nio.file.DirectoryStream;\n@@ -154,0 +155,1 @@\n+import java.util.function.Consumer;\n@@ -231,1 +233,1 @@\n-                              long timestamp, String currentVersion, String systemModules) throws IOException {\n+                              long timestamp, String currentVersion, String preReleaseTag, String moduleClasses) throws IOException {\n@@ -236,0 +238,14 @@\n+        int currentVersionParsed = Integer.parseInt(currentVersion);\n+\n+        currentVersion = Integer.toString(currentVersionParsed, Character.MAX_RADIX);\n+        currentVersion = currentVersion.toUpperCase(Locale.ROOT);\n+\n+        String previousVersion = Integer.toString(currentVersionParsed - 1, Character.MAX_RADIX);\n+\n+        previousVersion = previousVersion.toUpperCase(Locale.ROOT);\n+\n+        \/\/load current version classes:\n+        Path moduleClassPath = Paths.get(moduleClasses);\n+\n+        loadVersionClassesFromDirectory(data.classes, data.modules, moduleClassPath, currentVersion, previousVersion);\n+\n@@ -244,2 +260,0 @@\n-                List<String> versionsList =\n-                        Collections.singletonList(mhd.versions);\n@@ -249,1 +263,10 @@\n-                                        versionsList);\n+                                        mhd.versions,\n+                                        version -> {\n+                                            String versionString = Character.toString(version);\n+                                            int versionNumber = Integer.parseInt(versionString, Character.MAX_RADIX);\n+                                            versionString = Integer.toString(versionNumber);\n+                                            if (versionNumber == currentVersionParsed && !preReleaseTag.isEmpty()) {\n+                                                versionString = versionString + \"-\" + preReleaseTag;\n+                                            }\n+                                            return versionString;\n+                                        });\n@@ -296,7 +319,0 @@\n-        currentVersion = Integer.toString(Integer.parseInt(currentVersion), Character.MAX_RADIX);\n-        currentVersion = currentVersion.toUpperCase(Locale.ROOT);\n-\n-        openDirectory(directory2FileData, currentVersion + \"\/\")\n-                .add(new FileData(currentVersion + \"\/system-modules\",\n-                                  Files.readAllBytes(Paths.get(systemModules))));\n-\n@@ -791,1 +807,2 @@\n-                                 Iterable<String> versions)\n+                                 String versions,\n+                                 Function<Character, String> version2ModuleVersion)\n@@ -793,2 +810,5 @@\n-        for (String ver : versions) {\n-            writeModule(directory2FileData, moduleDescription, header, ver);\n+        \/\/ensure every module-info.class is written separatelly,\n+        \/\/so that the correct version is used for it:\n+        for (char ver : versions.toCharArray()) {\n+            writeModule(directory2FileData, moduleDescription, header, ver,\n+                        version2ModuleVersion);\n@@ -802,1 +822,2 @@\n-                    String version) throws IOException {\n+                    char version,\n+                    Function<Character, String> version2ModuleVersion) throws IOException {\n@@ -810,1 +831,3 @@\n-        addAttributes(moduleDescription, header, constantPool, attributesMap);\n+        String versionString = Character.toString(version);\n+        addAttributes(moduleDescription, header, constantPool, attributesMap,\n+                      version2ModuleVersion.apply(version));\n@@ -826,1 +849,1 @@\n-        doWrite(directory2FileData, version, moduleDescription.name, \"module-info\" + EXTENSION, classFile);\n+        doWrite(directory2FileData, versionString, moduleDescription.name, \"module-info\" + EXTENSION, classFile);\n@@ -927,1 +950,2 @@\n-                               Map<String, Attribute> attributes) {\n+                               Map<String, Attribute> attributes,\n+                               String moduleVersion) {\n@@ -948,0 +972,1 @@\n+        int versionIdx = addString(cp, moduleVersion);\n@@ -953,1 +978,1 @@\n-                             0,\n+                             versionIdx,\n@@ -1126,2 +1151,3 @@\n-                        .map(p -> new MethodParameters_attribute.Entry(addString(constantPool, p.name),\n-                                                                        p.flags))\n+                        .map(p -> new MethodParameters_attribute.Entry(p.name == null || p.name.isEmpty() ? 0\n+                                                                                                          : addString(constantPool, p.name),\n+                                                                       p.flags))\n@@ -1495,1 +1521,1 @@\n-        ExcludeIncludeList currentEIList = excludesIncludes;\n+        ExcludeIncludeList currentEIList;\n@@ -1512,0 +1538,2 @@\n+        } else {\n+            currentEIList = excludesIncludes;\n@@ -1515,0 +1543,1 @@\n+        Map<String, String> extraModulesPackagesToDerive = new HashMap<>();\n@@ -1519,1 +1548,20 @@\n-                                 currentEIList, version);\n+                                 currentEIList, version,\n+                                 cf -> {\n+                                     PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+                                     if (permitted != null) {\n+                                         try {\n+                                             String currentPack = cf.getName().substring(0, cf.getName().lastIndexOf('\/'));\n+\n+                                             for (int i = 0; i < permitted.subtypes.length; i++) {\n+                                                 String permittedClassName = cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName();\n+                                                 if (!currentEIList.accepts(permittedClassName, false)) {\n+                                                     String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n+\n+                                                     extraModulesPackagesToDerive.put(permittedPack, currentPack);\n+                                                 }\n+                                             }\n+                                         } catch (ConstantPoolException ex) {\n+                                             throw new IllegalStateException(ex);\n+                                         }\n+                                     }\n+                                 });\n@@ -1525,0 +1573,141 @@\n+        \/\/derive extra module packages for permitted types based on on their supertypes:\n+        boolean modified;\n+\n+        do {\n+            modified = false;\n+\n+            for (Iterator<Entry<String, String>> it = extraModulesPackagesToDerive.entrySet().iterator(); it.hasNext();) {\n+                Entry<String, String> e = it.next();\n+                Optional<ModuleHeaderDescription> module = currentVersionModules.values().stream().map(md -> md.header.get(0)).filter(d -> containsPackage(d, e.getValue())).findAny();\n+                if (module.isPresent()) {\n+                    if (!module.get().extraModulePackages.contains(e.getKey())) {\n+                        module.get().extraModulePackages.add(e.getKey());\n+                    }\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+        } while (modified);\n+\n+        if (!extraModulesPackagesToDerive.isEmpty()) {\n+            throw new AssertionError(\"Cannot derive some owning modules: \" + extraModulesPackagesToDerive);\n+        }\n+\n+        finishClassLoading(classes, modules, currentVersionModules, currentVersionClasses, currentEIList, version, baseline);\n+    }\n+\n+    private boolean containsPackage(ModuleHeaderDescription module, String pack) {\n+        return module.exports.stream().filter(ed -> ed.packageName().equals(pack)).findAny().isPresent() ||\n+               module.extraModulePackages.contains(pack);\n+    }\n+\n+    private void loadVersionClassesFromDirectory(ClassList classes,\n+                                    Map<String, ModuleDescription> modules,\n+                                    Path modulesDirectory,\n+                                    String version,\n+                                    String baseline) {\n+        Map<String, ModuleDescription> currentVersionModules =\n+                new HashMap<>();\n+        ClassList currentVersionClasses = new ClassList();\n+        Set<String> privateIncludes = new HashSet<>();\n+        Set<String> includes = new HashSet<>();\n+        ExcludeIncludeList currentEIList = new ExcludeIncludeList(includes,\n+                privateIncludes,\n+                Collections.emptySet());\n+\n+        try {\n+            Map<Path, ModuleHeaderDescription> modulePath2Header = new HashMap<>();\n+            List<Path> pendingExportedDirectories = new ArrayList<>();\n+\n+            try (DirectoryStream<Path> ds = Files.newDirectoryStream(modulesDirectory)) {\n+                for (Path p : ds) {\n+                    Path moduleInfo = p.resolve(\"module-info.class\");\n+\n+                    if (Files.isReadable(moduleInfo)) {\n+                        ModuleDescription md;\n+\n+                        try (InputStream in = Files.newInputStream(moduleInfo)) {\n+                            md = inspectModuleInfoClassFile(in,\n+                                    currentVersionModules, version);\n+                        }\n+                        if (md == null) {\n+                            continue;\n+                        }\n+\n+                        modulePath2Header.put(p, md.header.get(0));\n+\n+                        Set<String> currentModuleExports =\n+                                md.header.get(0).exports.stream()\n+                                                        .filter(e -> !e.isQualified())\n+                                                        .map(e -> e.packageName + '\/')\n+                                                        .collect(Collectors.toSet());\n+\n+                        for (String dir : currentModuleExports) {\n+                            includes.add(dir);\n+                            pendingExportedDirectories.add(p.resolve(dir));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            List<String> pendingExtraClasses = new ArrayList<>();\n+\n+            for (Path exported : pendingExportedDirectories) {\n+                try (DirectoryStream<Path> ds = Files.newDirectoryStream(exported)) {\n+                    for (Path p2 : ds) {\n+                        if (!Files.isRegularFile(p2) || !p2.getFileName().toString().endsWith(\".class\")) {\n+                            continue;\n+                        }\n+\n+                        loadFromDirectoryHandleClassFile(p2, currentVersionClasses,\n+                                                         currentEIList, version,\n+                                                         pendingExtraClasses);\n+                    }\n+                }\n+            }\n+\n+            while (!pendingExtraClasses.isEmpty()) {\n+                String current = pendingExtraClasses.remove(pendingExtraClasses.size() - 1);\n+\n+                if (currentVersionClasses.find(current, true) != null) {\n+                    continue;\n+                }\n+\n+                for (Entry<Path, ModuleHeaderDescription> e : modulePath2Header.entrySet()) {\n+                    Path currentPath = e.getKey().resolve(current + \".class\");\n+\n+                    if (Files.isReadable(currentPath)) {\n+                        String pack = current.substring(0, current.lastIndexOf('\/'));\n+\n+                        e.getValue().extraModulePackages.add(pack);\n+\n+                        loadFromDirectoryHandleClassFile(currentPath, currentVersionClasses,\n+                                                         currentEIList, version,\n+                                                         pendingExtraClasses);\n+                    }\n+                }\n+            }\n+        } catch (IOException | ConstantPoolException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+\n+        finishClassLoading(classes, modules, currentVersionModules, currentVersionClasses, currentEIList, version, baseline);\n+    }\n+\n+    private void loadFromDirectoryHandleClassFile(Path path, ClassList currentVersionClasses,\n+                                                  ExcludeIncludeList currentEIList, String version,\n+                                                  List<String> todo) throws IOException, ConstantPoolException {\n+        try (InputStream in = Files.newInputStream(path)) {\n+            inspectClassFile(in, currentVersionClasses,\n+                             currentEIList, version,\n+                             cf -> {\n+                                 Set<String> superTypes = otherRelevantTypesWithOwners(cf);\n+\n+                                 currentEIList.privateIncludeList.addAll(superTypes);\n+                                 todo.addAll(superTypes);\n+                             });\n+        }\n+    }\n+\n+    private void finishClassLoading(ClassList classes, Map<String, ModuleDescription> modules, Map<String, ModuleDescription> currentVersionModules, ClassList currentVersionClasses, ExcludeIncludeList currentEIList, String version,\n+                                    String baseline) {\n@@ -1566,0 +1755,5 @@\n+                    if (header.permittedSubclasses != null) {\n+                        for (String i : header.permittedSubclasses) {\n+                            modified |= include(includedClasses, currentVersionClasses, i);\n+                        }\n+                    }\n@@ -1965,0 +2159,5 @@\n+        inspectClassFile(in, classes, excludesIncludes, version, cf -> {});\n+    }\n+\n+    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version,\n+                                  Consumer<ClassFile> extraTask) throws IOException, ConstantPoolException {\n@@ -1975,0 +2174,2 @@\n+        extraTask.accept(cf);\n+\n@@ -2035,1 +2236,1 @@\n-    private void inspectModuleInfoClassFile(InputStream in,\n+    private ModuleDescription inspectModuleInfoClassFile(InputStream in,\n@@ -2041,1 +2242,1 @@\n-            return ;\n+            return null;\n@@ -2051,1 +2252,1 @@\n-                return ;\n+                return null;\n@@ -2065,0 +2266,2 @@\n+\n+        return moduleDesc;\n@@ -2075,3 +2278,5 @@\n-                if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n-                    continue;\n-                }\n+                additionalIncludes.addAll(otherRelevantTypesWithOwners(cf));\n+            } catch (IOException | ConstantPoolException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n@@ -2079,1 +2284,2 @@\n-                Set<String> additionalClasses = new HashSet<>();\n+        return additionalIncludes;\n+    }\n@@ -2081,5 +2287,20 @@\n-                if (cf.super_class != 0) {\n-                    additionalClasses.add(cf.getSuperclassName());\n-                }\n-                for (int i = 0; i < cf.interfaces.length; i++) {\n-                    additionalClasses.add(cf.getInterfaceName(i));\n+    private Set<String> otherRelevantTypesWithOwners(ClassFile cf) {\n+        Set<String> supertypes = new HashSet<>();\n+\n+        try {\n+            if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+                return supertypes;\n+            }\n+\n+            Set<String> additionalClasses = new HashSet<>();\n+\n+            if (cf.super_class != 0) {\n+                additionalClasses.add(cf.getSuperclassName());\n+            }\n+            for (int i = 0; i < cf.interfaces.length; i++) {\n+                additionalClasses.add(cf.getInterfaceName(i));\n+            }\n+            PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+            if (permitted != null) {\n+                for (int i = 0; i < permitted.subtypes.length; i++) {\n+                    additionalClasses.add(cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName());\n@@ -2087,0 +2308,1 @@\n+            }\n@@ -2088,2 +2310,2 @@\n-                for (String additional : additionalClasses) {\n-                    int dollar;\n+            for (String additional : additionalClasses) {\n+                int dollar;\n@@ -2091,1 +2313,1 @@\n-                    additionalIncludes.add(additional);\n+                supertypes.add(additional);\n@@ -2093,4 +2315,3 @@\n-                    while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n-                        additional = additional.substring(0, dollar);\n-                        additionalIncludes.add(additional);\n-                    }\n+                while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n+                    additional = additional.substring(0, dollar);\n+                    supertypes.add(additional);\n@@ -2098,4 +2319,4 @@\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n-        }\n-        return additionalIncludes;\n+            return supertypes;\n+        } catch (ConstantPoolException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n@@ -2118,1 +2339,3 @@\n-        headerDesc.versions += version;\n+        if (!headerDesc.versions.contains(version)) {\n+            headerDesc.versions += version;\n+        }\n@@ -2162,1 +2385,3 @@\n-        headerDesc.versions += version;\n+        if (!headerDesc.versions.contains(version)) {\n+            headerDesc.versions += version;\n+        }\n@@ -4419,1 +4644,2 @@\n-                String systemModules;\n+                String preReleaseTag;\n+                String moduleClasses;\n@@ -4421,1 +4647,1 @@\n-                if (args.length == 6) {\n+                if (args.length == 7) {\n@@ -4427,2 +4653,3 @@\n-                    systemModules = args[5];\n-                } else if (args.length == 7) {\n+                    preReleaseTag = args[5];\n+                    moduleClasses = args[6];\n+                } else if (args.length == 8) {\n@@ -4434,1 +4661,2 @@\n-                    systemModules = args[6];\n+                    preReleaseTag = args[6];\n+                    moduleClasses = args[7];\n@@ -4450,1 +4678,2 @@\n-                                                  systemModules);\n+                                                  preReleaseTag,\n+                                                  moduleClasses);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":283,"deletions":54,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.base\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1693,1 +1693,0 @@\n-  assert(VM_Version::supports_cx8(), \"wrong machine\");\n@@ -2919,0 +2918,1 @@\n+    assert_different_registers(obj, tmp, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2920,0 +2920,2 @@\n+  } else {\n+    assert_different_registers(obj, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2976,2 +2978,2 @@\n-          \/\/ There is a chance that the checks above (re-reading profiling\n-          \/\/ data from memory) fail if another thread has just set the\n+          \/\/ There is a chance that the checks above\n+          \/\/ fail if another thread has just set the\n@@ -2980,0 +2982,1 @@\n+          __ eor(tmp, tmp, rscratch2); \/\/ get back original value before XOR\n@@ -3004,0 +3007,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3035,0 +3042,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1783,1 +1783,1 @@\n-  assert_different_registers(obj, rscratch1);\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n@@ -1805,1 +1805,0 @@\n-  ldr(rscratch1, mdo_addr);\n@@ -1809,2 +1808,2 @@\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1812,0 +1811,1 @@\n+  eor(obj, obj, rscratch1); \/\/ get back original value before XOR\n@@ -1824,0 +1824,4 @@\n+#ifdef ASSERT\n+  andr(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1388,1 +1388,0 @@\n-    assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3109,1 +3109,1 @@\n-        __ andi_(R0, klass, TypeEntries::type_unknown);\n+        __ andi_(R0, tmp, TypeEntries::type_unknown);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1777,1 +1777,1 @@\n-  andi_(R0, klass, TypeEntries::type_unknown);\n+  andi_(R0, tmp, TypeEntries::type_unknown);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2673,1 +2673,0 @@\n-    assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1618,0 +1618,3 @@\n+  void evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evmovntdquq(Address dst, XMMRegister src, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2095,1 +2095,1 @@\n-  if (LP64_ONLY(false &&) op->code() == lir_cas_long && VM_Version::supports_cx8()) {\n+  if (LP64_ONLY(false &&) op->code() == lir_cas_long) {\n@@ -3850,2 +3850,13 @@\n-  if (tmp != obj) {\n-    __ mov(tmp, obj);\n+#ifdef ASSERT\n+  if (obj == tmp) {\n+#ifdef _LP64\n+    assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+  } else {\n+#ifdef _LP64\n+    assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());\n+#endif\n@@ -3853,0 +3864,1 @@\n+#endif\n@@ -3854,1 +3866,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3857,0 +3869,8 @@\n+      __ testptr(mdo_addr, TypeEntries::null_seen);\n+#ifndef ASSERT\n+      __ jccb(Assembler::notZero, next); \/\/ already set\n+#else\n+      __ jcc(Assembler::notZero, next); \/\/ already set\n+#endif\n+      \/\/ atomic update to prevent overwriting Klass* with 0\n+      __ lock();\n@@ -3867,1 +3887,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3879,1 +3899,1 @@\n-      __ load_klass(tmp, tmp, tmp_load_klass);\n+      __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3894,1 +3914,1 @@\n-          __ load_klass(tmp, tmp, tmp_load_klass);\n+          __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3896,1 +3916,3 @@\n-\n+#ifdef _LP64\n+        __ mov(rscratch1, tmp); \/\/ save original value before XOR\n+#endif\n@@ -3907,4 +3929,3 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jccb(Assembler::equal, none);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jccb(Assembler::equal, none);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jccb(Assembler::zero, none);\n+#ifdef _LP64\n@@ -3914,0 +3935,1 @@\n+          __ mov(tmp, rscratch1); \/\/ get back original value before XOR\n@@ -3917,0 +3939,1 @@\n+#endif\n@@ -3922,2 +3945,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3936,0 +3958,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3950,4 +3976,2 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jcc(Assembler::equal, ok);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jcc(Assembler::equal, ok);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jcc(Assembler::zero, ok);\n@@ -3969,0 +3993,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3973,2 +4001,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3980,2 +4007,1 @@\n-\n-    __ bind(next);\n+  __ bind(next);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":48,"deletions":22,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -59,0 +59,6 @@\n+#ifdef _LP64\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+\n@@ -63,0 +69,4 @@\n+  testptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::notZero, next); \/\/ null already seen. Nothing to do anymore.\n+  \/\/ atomic update to prevent overwriting Klass* with 0\n+  lock();\n@@ -68,0 +78,3 @@\n+#ifdef _LP64\n+  mov(rscratch1, obj);\n+#endif\n@@ -82,0 +95,1 @@\n+#ifdef _LP64\n@@ -85,0 +99,1 @@\n+  mov(obj, rscratch1);\n@@ -88,0 +103,1 @@\n+#endif\n@@ -96,0 +112,4 @@\n+#ifdef ASSERT\n+  andptr(obj, TypeEntries::type_klass_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -957,0 +957,1 @@\n+  void testptr(Address src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -190,0 +190,4 @@\n+  void arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                    Register to, Register count, int shift,\n+                                    Register index, Register temp, Label& L_exit);\n+\n@@ -195,0 +199,5 @@\n+  void arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                            Register temp3, Register temp4, Register count,\n+                            XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                            XMMRegister xmm4, int shift);\n+\n@@ -202,0 +211,3 @@\n+  void copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1, XMMRegister xmm2,\n+                                XMMRegister xmm3, XMMRegister xmm4, int shift, int offset = 0);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+  const int large_threshold = 2621440; \/\/ 2.5 MB\n@@ -520,0 +521,1 @@\n+  Label L_copy_large, L_finish;\n@@ -580,0 +582,6 @@\n+    if (MaxVectorSize == 64) {\n+      __ movq(temp2, temp1);\n+      __ shlq(temp2, shift);\n+      __ cmpq(temp2, large_threshold);\n+      __ jcc(Assembler::greaterEqual, L_copy_large);\n+    }\n@@ -706,0 +714,1 @@\n+  __ BIND(L_finish);\n@@ -720,0 +729,5 @@\n+  if (MaxVectorSize == 64) {\n+    __ BIND(L_copy_large);\n+    arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n+    __ jmp(L_finish);\n+  }\n@@ -723,0 +737,63 @@\n+void StubGenerator::arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                                         Register temp3, Register temp4, Register count,\n+                                         XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                         XMMRegister xmm4, int shift) {\n+\n+  \/\/ Type(shift)           byte(0), short(1), int(2),   long(3)\n+  int loop_size[]        = { 256,     128,       64,      32};\n+  int threshold[]        = { 4096,    2048,     1024,    512};\n+\n+  Label L_main_loop_large;\n+  Label L_tail_large;\n+  Label L_exit_large;\n+  Label L_entry_large;\n+  Label L_main_pre_loop_large;\n+  Label L_pre_main_post_large;\n+\n+  assert(MaxVectorSize == 64, \"vector length != 64\");\n+  __ BIND(L_entry_large);\n+\n+  __ BIND(L_pre_main_post_large);\n+  \/\/ Partial copy to make dst address 64 byte aligned.\n+  __ movq(temp2, to);\n+  __ andq(temp2, 63);\n+  __ jcc(Assembler::equal, L_main_pre_loop_large);\n+\n+  __ negptr(temp2);\n+  __ addq(temp2, 64);\n+  if (shift) {\n+    __ shrq(temp2, shift);\n+  }\n+  __ movq(temp3, temp2);\n+  copy64_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift, 0, true);\n+  __ movq(temp4, temp2);\n+  __ movq(temp1, count);\n+  __ subq(temp1, temp2);\n+\n+  __ cmpq(temp1, loop_size[shift]);\n+  __ jcc(Assembler::less, L_tail_large);\n+\n+  __ BIND(L_main_pre_loop_large);\n+  __ subq(temp1, loop_size[shift]);\n+\n+  \/\/ Main loop with aligned copy block size of 256 bytes at 64 byte copy granularity.\n+  __ align32();\n+  __ BIND(L_main_loop_large);\n+  copy256_avx3(to, from, temp4, xmm1, xmm2, xmm3, xmm4, shift, 0);\n+  __ addptr(temp4, loop_size[shift]);\n+  __ subq(temp1, loop_size[shift]);\n+  __ jcc(Assembler::greater, L_main_loop_large);\n+  \/\/ fence needed because copy256_avx3 uses non-temporal stores\n+  __ sfence();\n+\n+  __ addq(temp1, loop_size[shift]);\n+  \/\/ Zero length check.\n+  __ jcc(Assembler::lessEqual, L_exit_large);\n+  __ BIND(L_tail_large);\n+  \/\/ Tail handling using 64 byte [masked] vector copy operations.\n+  __ cmpq(temp1, 0);\n+  __ jcc(Assembler::lessEqual, L_exit_large);\n+  arraycopy_avx3_special_cases_256(xmm1, k2, from, to, temp1, shift,\n+                               temp4, temp3, L_exit_large);\n+  __ BIND(L_exit_large);\n+}\n@@ -968,0 +1045,49 @@\n+void StubGenerator::arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                                     Register to, Register count, int shift, Register index,\n+                                                     Register temp, Label& L_exit) {\n+  Label L_entry_64, L_entry_128, L_entry_192, L_entry_256;\n+\n+  int size_mat[][4] = {\n+  \/* T_BYTE *\/ {64, 128, 192, 256},\n+  \/* T_SHORT*\/ {32, 64 , 96 , 128},\n+  \/* T_INT  *\/ {16, 32 , 48 ,  64},\n+  \/* T_LONG *\/ { 8, 16 , 24 ,  32}\n+  };\n+\n+  assert(MaxVectorSize == 64, \"vector length != 64\");\n+  \/\/ Case A) Special case for length less than or equal to 64 bytes.\n+  __ BIND(L_entry_64);\n+  __ cmpq(count, size_mat[shift][0]);\n+  __ jccb(Assembler::greater, L_entry_128);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 0, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case B) Special case for length less than or equal to 128 bytes.\n+  __ BIND(L_entry_128);\n+  __ cmpq(count, size_mat[shift][1]);\n+  __ jccb(Assembler::greater, L_entry_192);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  __ subq(count, 64 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 64, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case C) Special case for length less than or equal to 192 bytes.\n+  __ BIND(L_entry_192);\n+  __ cmpq(count, size_mat[shift][2]);\n+  __ jcc(Assembler::greater, L_entry_256);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+  __ subq(count, 128 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 128, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case D) Special case for length less than or equal to 256 bytes.\n+  __ BIND(L_entry_256);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 128, true);\n+  __ subq(count, 192 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 192, true);\n+  __ jmp(L_exit);\n+}\n+\n@@ -1043,0 +1169,27 @@\n+void StubGenerator::copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1,\n+                                XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                int shift, int offset) {\n+  if (MaxVectorSize == 64) {\n+    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+    __ prefetcht0(Address(src, index, scale, offset + 0x200));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x240));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x280));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x2C0));\n+\n+    __ prefetcht0(Address(src, index, scale, offset + 0x400));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x440));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x480));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x4C0));\n+\n+    __ evmovdquq(xmm1, Address(src, index, scale, offset), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm2, Address(src, index, scale, offset + 0x40), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm3, Address(src, index, scale, offset + 0x80), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm4, Address(src, index, scale, offset + 0xC0), Assembler::AVX_512bit);\n+\n+    __ evmovntdquq(Address(dst, index, scale, offset), xmm1, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x40), xmm2, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x80), xmm3, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0xC0), xmm4, Assembler::AVX_512bit);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -819,1 +819,0 @@\n-  _supports_cx8 = supports_cmpxchg8();\n@@ -3239,1 +3238,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1513,3 +1513,0 @@\n-      if (!VM_Version::supports_cx8()) {\n-        return false;\n-      }\n@@ -10156,2 +10153,0 @@\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7281,1 +7281,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7350,1 +7349,0 @@\n-  predicate(VM_Version::supports_cx8());\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7221,1 +7221,1 @@\n-  predicate(VM_Version::supports_cx8() && n->as_LoadStore()->barrier_data() == 0);\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7244,1 +7244,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7405,1 +7404,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7439,1 +7437,1 @@\n-  predicate(VM_Version::supports_cx8() && n->as_LoadStore()->barrier_data() == 0);\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2787,0 +2787,2 @@\n+          \/\/ locals are preserved\n+          \/\/ stack will be truncated\n@@ -2836,5 +2838,1 @@\n-      if (_compilation->env()->should_retain_local_variables()) {\n-        cur_state = cur_state->copy(ValueStack::ExceptionState, cur_state->bci());\n-      } else {\n-        cur_state = cur_state->copy(ValueStack::EmptyExceptionState, cur_state->bci());\n-      }\n+      \/\/ Stack and locals are invalidated but not truncated in caller state.\n@@ -2842,0 +2840,4 @@\n+        assert(instruction->exception_state() != nullptr, \"missed set?\");\n+        ValueStack::Kind exc_kind = ValueStack::empty_exception_kind(true \/* caller *\/);\n+        cur_state = cur_state->copy(exc_kind, cur_state->bci());\n+        \/\/ reset caller exception state\n@@ -2843,2 +2845,6 @@\n-      }\n-      if (instruction->exception_state() == nullptr) {\n+      } else {\n+        assert(instruction->exception_state() == nullptr, \"already set\");\n+        \/\/ set instruction exception state\n+        \/\/ truncate stack\n+        ValueStack::Kind exc_kind = ValueStack::empty_exception_kind();\n+        cur_state = cur_state->copy(exc_kind, cur_state->bci());\n@@ -3760,5 +3766,3 @@\n-    if (_compilation->env()->should_retain_local_variables()) {\n-      s = state()->copy(ValueStack::ExceptionState, bci);\n-    } else {\n-      s = state()->copy(ValueStack::EmptyExceptionState, bci);\n-    }\n+    \/\/ no handler, no need to retain locals\n+    ValueStack::Kind exc_kind = ValueStack::empty_exception_kind();\n+    s = state()->copy(exc_kind, bci);\n@@ -3779,1 +3783,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -410,2 +410,14 @@\n-    if (s->kind() == ValueStack::EmptyExceptionState) {\n-      assert(s->stack_size() == 0 && s->locals_size() == 0 && (s->locks_size() == 0 || s->locks_size() == 1), \"state must be empty\");\n+    if (s->kind() == ValueStack::EmptyExceptionState ||\n+        s->kind() == ValueStack::CallerEmptyExceptionState)\n+    {\n+#ifdef ASSERT\n+      int index;\n+      Value value;\n+      for_each_stack_value(s, index, value) {\n+        fatal(\"state must be empty\");\n+      }\n+      for_each_local_value(s, index, value) {\n+        fatal(\"state must be empty\");\n+      }\n+#endif\n+      assert(s->locks_size() == 0 || s->locks_size() == 1, \"state must be empty\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2924,9 +2924,1 @@\n-    assert(locals->length() == cur_scope->method()->max_locals(), \"wrong number of locals\");\n-    assert(locals->length() == cur_state->locals_size(), \"wrong number of locals\");\n-  } else if (cur_scope->method()->max_locals() > 0) {\n-    assert(cur_state->kind() == ValueStack::EmptyExceptionState, \"should be\");\n-    nof_locals = cur_scope->method()->max_locals();\n-    locals = new GrowableArray<ScopeValue*>(nof_locals);\n-    for(int i = 0; i < nof_locals; i++) {\n-      locals->append(_illegal_value);\n-    }\n+    assert(locals->length() == nof_locals, \"wrong number of locals\");\n@@ -2934,0 +2926,2 @@\n+  assert(nof_locals == cur_scope->method()->max_locals(), \"wrong number of locals\");\n+  assert(nof_locals == cur_state->locals_size(), \"wrong number of locals\");\n@@ -2942,2 +2936,2 @@\n-      Value expression = cur_state->stack_at_inc(pos);\n-      append_scope_value(op_id, expression, expressions);\n+      Value expression = cur_state->stack_at(pos);\n+      pos += append_scope_value(op_id, expression, expressions);\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,2 +56,10 @@\n-  assert(kind != EmptyExceptionState || !Compilation::current()->env()->should_retain_local_variables(), \"need locals\");\n-  if (kind != EmptyExceptionState) {\n+  switch (kind) {\n+  case EmptyExceptionState:\n+  case CallerEmptyExceptionState:\n+    assert(!Compilation::current()->env()->should_retain_local_variables(), \"need locals\");\n+    \/\/ set to all nulls, like clear_locals()\n+    for (int i = 0; i < copy_from->locals_size(); ++i) {\n+      _locals.append(nullptr);\n+    }\n+    break;\n+  default:\n@@ -61,1 +69,13 @@\n-  if (kind != ExceptionState && kind != EmptyExceptionState) {\n+  switch (kind) {\n+  case ExceptionState:\n+  case EmptyExceptionState:\n+    assert(stack_size() == 0, \"fix stack_size_for_copy\");\n+    break;\n+  case CallerExceptionState:\n+  case CallerEmptyExceptionState:\n+    \/\/ set to all nulls\n+    for (int i = 0; i < copy_from->stack_size(); ++i) {\n+      _stack.append(nullptr);\n+    }\n+    break;\n+  default:\n@@ -73,4 +93,1 @@\n-  if (kind != EmptyExceptionState) {\n-    return locals_size();\n-  }\n-  return 0;\n+  return locals_size();\n@@ -225,0 +242,1 @@\n+      tty->print(\"stack %d \", i);\n@@ -226,3 +244,7 @@\n-      tty->print(\"%2d  \", i);\n-      tty->print(\"%c%d \", t->type()->tchar(), t->id());\n-      ip.print_instr(t);\n+      if (t == nullptr) {\n+        tty->print(\"null\");\n+      } else {\n+        tty->print(\"%2d  \", i);\n+        tty->print(\"%c%d \", t->type()->tchar(), t->id());\n+        ip.print_instr(t);\n+      }\n@@ -288,1 +310,3 @@\n-    if (v == nullptr) {\n+    if (kind() == empty_exception_kind(true \/* caller *\/)) {\n+      assert(v == nullptr, \"should be empty\");\n+    } else if (v == nullptr) {\n@@ -297,1 +321,3 @@\n-    if (v != nullptr && v->type()->is_double_word()) {\n+    if (kind() == EmptyExceptionState) {\n+      assert(v == nullptr, \"should be empty\");\n+    } else if (v != nullptr && v->type()->is_double_word()) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.cpp","additions":38,"deletions":12,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,2 +37,12 @@\n-    ExceptionState,      \/\/ Exception handling of instruction\n-    EmptyExceptionState, \/\/ Exception handling of instructions not covered by an xhandler\n+    \/\/ Exception states for an instruction.\n+    \/\/ Dead stack items or locals may be invalidated or cleared\/removed.\n+    \/\/ Locals are retained if needed for JVMTI.\n+    \/\/ \"empty\" exception states are used when there is no handler,\n+    \/\/ and invalidate the locals.\n+    \/\/ \"leaf\" exception states clear the stack.\n+    \/\/ \"caller\" exception states are used for the parent\/caller,\n+    \/\/ and invalidate the stack.\n+    ExceptionState,      \/\/ Exception state for leaf with handler, stack cleared\n+    EmptyExceptionState, \/\/ Exception state for leaf w\/o handler, stack cleared, locals invalidated\n+    CallerExceptionState, \/\/ Exception state for parent with handler, stack invalidated\n+    CallerEmptyExceptionState, \/\/ Exception state for parent w\/o handler, stack+locals invalidated\n@@ -79,0 +89,7 @@\n+  \/\/ Used when no exception handler is found\n+  static Kind empty_exception_kind(bool caller = false) {\n+    return Compilation::current()->env()->should_retain_local_variables() ?\n+      (caller ? CallerExceptionState : ExceptionState) : \/\/ retain locals\n+      (caller ? CallerEmptyExceptionState : EmptyExceptionState);   \/\/ clear locals\n+  }\n+\n@@ -80,3 +97,2 @@\n-    assert(kind() == EmptyExceptionState ||\n-           (Compilation::current()->env()->should_retain_local_variables() && kind() == ExceptionState),\n-           \"only EmptyExceptionStates can be modified\");\n+    assert(kind() == empty_exception_kind(false) || kind() == empty_exception_kind(true),\n+           \"only empty exception states can be modified\");\n@@ -139,1 +155,1 @@\n-    assert(!x->type()->is_double_word() ||\n+    assert(x == nullptr || !x->type()->is_double_word() ||\n@@ -146,1 +162,1 @@\n-    i += x->type()->size();\n+    i += ((x == nullptr) ? 1 : x->type()->size());\n@@ -266,1 +282,2 @@\n-       index += value->type()->size())\n+       index += (value == nullptr ? 1 : value->type()->size()))                                \\\n+    if (value != nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -146,5 +146,10 @@\n-#ifdef _LP64\n-  return CompressedKlassPointers::is_valid_base((address)shared_base);\n-#else\n-  return true;\n-#endif\n+  \/\/ We check user input for SharedBaseAddress at dump time. We must weed out values\n+  \/\/ we already know to be invalid later.\n+\n+  \/\/ At CDS runtime, \"shared_base\" will be the (attempted) mapping start. It will also\n+  \/\/ be the encoding base, since the the headers of archived base objects (and with Lilliput,\n+  \/\/ the prototype mark words) carry pre-computed narrow Klass IDs that refer to the mapping\n+  \/\/ start as base.\n+  \/\/\n+  \/\/ Therefore, \"shared_base\" must be later usable as encoding base.\n+  return AARCH64_ONLY(is_aligned(shared_base, 4 * G)) NOT_AARCH64(true);\n@@ -1266,6 +1271,0 @@\n-#ifdef _LP64\n-    if (Metaspace::using_class_space()) {\n-      assert(CompressedKlassPointers::is_valid_base(base_address),\n-             \"Archive base address invalid: \" PTR_FORMAT \".\", p2i(base_address));\n-    }\n-#endif\n@@ -1341,2 +1340,2 @@\n-      \/\/ case we reserve whereever possible, but the start address needs to be encodable as narrow Klass\n-      \/\/ encoding base since the archived heap objects contain nKlass IDs precalculated toward the start\n+      \/\/ case we reserve wherever possible, but the start address needs to be encodable as narrow Klass\n+      \/\/ encoding base since the archived heap objects contain nKlass IDs pre-calculated toward the start\n@@ -1345,1 +1344,1 @@\n-      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, false \/* try_in_low_address_ranges *\/);\n+      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, false \/* optimize_for_zero_base *\/);\n@@ -1357,1 +1356,0 @@\n-    assert(CompressedKlassPointers::is_valid_base((address)total_space_rs.base()), \"Sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  _parameters_data_offset(0),\n+  _exception_handlers_data_offset(0),\n@@ -53,2 +55,1 @@\n-  _orig(),\n-  _parameters(nullptr) {}\n+  _orig() {}\n@@ -137,2 +138,10 @@\n-                              (HeapWord*)((address) _data + _data_size),\n-                              (_extra_data_size - mdo->parameters_size_in_bytes()) \/ HeapWordSize);\n+                              (HeapWord*) extra_data_base(),\n+                              \/\/ copy everything from extra_data_base() up to parameters_data_base()\n+                              pointer_delta(parameters_data_base(), extra_data_base(), HeapWordSize));\n+\n+  \/\/ skip parameter data copying. Already done in 'load_data'\n+\n+  \/\/ copy exception handler data\n+  Copy::disjoint_words_atomic((HeapWord*) mdo->exception_handler_data_base(),\n+                              (HeapWord*) exception_handler_data_base(),\n+                              exception_handler_data_size() \/ HeapWordSize);\n@@ -198,0 +207,3 @@\n+  \/\/  param_data_limit: ---------------------------\n+  \/\/                    | ex handler data entries |\n+  \/\/                    |           ...           |\n@@ -203,1 +215,3 @@\n-  \/\/ args_data_limit = data_base + total_size - parameter_data_size\n+  \/\/ args_data_limit = param_data_base\n+  \/\/ param_data_limit = exception_handler_data_base\n+  \/\/ extra_data_limit = extra_data_limit\n@@ -221,0 +235,3 @@\n+  \/\/ Copy offsets. This is used below\n+  _parameters_data_offset = mdo->parameters_type_data_di();\n+  _exception_handlers_data_offset = mdo->exception_handlers_data_di();\n@@ -225,2 +242,2 @@\n-    Copy::disjoint_words_atomic((HeapWord*) mdo->args_data_limit(),\n-                                (HeapWord*) ((address)_data + total_size - parameters_data_size),\n+    Copy::disjoint_words_atomic((HeapWord*) mdo->parameters_data_base(),\n+                                (HeapWord*) parameters_data_base(),\n@@ -240,2 +257,2 @@\n-    _parameters = data_layout_at(mdo->parameters_type_data_di());\n-    ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);\n+    DataLayout* parameters_data = data_layout_at(_parameters_data_offset);\n+    ciParametersTypeData* parameters = new ciParametersTypeData(parameters_data);\n@@ -245,1 +262,1 @@\n-  assert((DataLayout*) ((address)_data + total_size - parameters_data_size) == args_data_limit(),\n+  assert((DataLayout*) ((address)_data + total_size - parameters_data_size - exception_handler_data_size()) == args_data_limit(),\n@@ -376,1 +393,1 @@\n-DataLayout* ciMethodData::next_data_layout(DataLayout* current) {\n+DataLayout* ciMethodData::next_data_layout_helper(DataLayout* current, bool extra) {\n@@ -379,1 +396,1 @@\n-  if (out_of_bounds(next_index)) {\n+  if (extra ? out_of_bounds_extra(next_index) : out_of_bounds(next_index)) {\n@@ -386,0 +403,8 @@\n+DataLayout* ciMethodData::next_data_layout(DataLayout* current) {\n+  return next_data_layout_helper(current, false);\n+}\n+\n+DataLayout* ciMethodData::next_extra_data_layout(DataLayout* current) {\n+  return next_data_layout_helper(current, true);\n+}\n+\n@@ -447,0 +472,13 @@\n+ciBitData ciMethodData::exception_handler_bci_to_data(int bci) {\n+  assert(ProfileExceptionHandlers, \"not profiling\");\n+  assert(_data != nullptr, \"must be initialized\");\n+  for (DataLayout* data = exception_handler_data_base(); data < exception_handler_data_limit(); data = next_extra_data_layout(data)) {\n+    assert(data != nullptr, \"out of bounds?\");\n+    if (data->bci() == bci) {\n+      return ciBitData(data);\n+    }\n+  }\n+  \/\/ called with invalid bci or wrong Method\/MethodData\n+  ShouldNotReachHere();\n+}\n+\n@@ -621,1 +659,1 @@\n-  return _parameters != nullptr ? new ciParametersTypeData(_parameters) : nullptr;\n+  return parameter_data_size() != 0 ? new ciParametersTypeData(data_layout_at(_parameters_data_offset)) : nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":51,"deletions":13,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -439,0 +439,4 @@\n+  \/\/ layout of _data\n+  int _parameters_data_offset;\n+  int _exception_handlers_data_offset;\n+\n@@ -463,6 +467,0 @@\n-  \/\/ Area dedicated to parameters. null if no parameter profiling for this method.\n-  DataLayout* _parameters;\n-  int parameters_size() const {\n-    return _parameters == nullptr ? 0 : parameters_type_data()->size_in_bytes();\n-  }\n-\n@@ -474,0 +472,2 @@\n+  int parameter_data_size() const { return _exception_handlers_data_offset - _parameters_data_offset; }\n+  int exception_handler_data_size() const { return dp_to_di((address) exception_handler_data_limit()) - _exception_handlers_data_offset; }\n@@ -485,1 +485,1 @@\n-    assert(data_index % sizeof(intptr_t) == 0, \"unaligned\");\n+    assert(data_index % sizeof(intptr_t) == 0, \"unaligned: %d\", data_index);\n@@ -493,0 +493,6 @@\n+  bool out_of_bounds_extra(int data_index) {\n+    return data_index < data_size() || data_index >= data_size() + extra_data_size();\n+  }\n+\n+  DataLayout* next_data_layout_helper(DataLayout* current, bool extra);\n+\n@@ -560,1 +566,1 @@\n-  int dp_to_di(address dp) {\n+  int dp_to_di(address dp) const {\n@@ -571,0 +577,1 @@\n+  DataLayout* next_extra_data_layout(DataLayout* current);\n@@ -574,0 +581,3 @@\n+  \/\/ pointers to sections in _data\n+  \/\/ NOTE: these may be called before ciMethodData::load_data\n+  \/\/       this works out since everything is initialized to 0 (i.e. there will appear to be no data)\n@@ -575,2 +585,7 @@\n-  DataLayout* args_data_limit() const  { return data_layout_at(data_size() + extra_data_size() -\n-                                                               parameters_size()); }\n+  DataLayout* extra_data_limit() const { return data_layout_at(data_size() + extra_data_size()); }\n+  \/\/ pointers to sections in extra data\n+  DataLayout* args_data_limit() const  { return parameters_data_base(); }\n+  DataLayout* parameters_data_base() const { return data_layout_at(_parameters_data_offset); }\n+  DataLayout* parameters_data_limit() const { return exception_handler_data_base(); }\n+  DataLayout* exception_handler_data_base() const { return data_layout_at(_exception_handlers_data_offset); }\n+  DataLayout* exception_handler_data_limit() const { return extra_data_limit(); }\n@@ -582,0 +597,2 @@\n+  ciBitData exception_handler_bci_to_data(int bci);\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-static GrowableArray<const char*>* phase_names = nullptr;\n+static GrowableArray<const char*>* _phase_names = nullptr;\n@@ -66,3 +66,3 @@\n-    assert(phase_names != nullptr, \"invariant\");\n-    assert(phase_names->is_nonempty(), \"invariant\");\n-    const u4 nof_entries = phase_names->length();\n+    assert(_phase_names != nullptr, \"invariant\");\n+    assert(_phase_names->is_nonempty(), \"invariant\");\n+    const u4 nof_entries = _phase_names->length();\n@@ -72,1 +72,1 @@\n-      writer.write(phase_names->at(i));\n+      writer.write(_phase_names->at(i));\n@@ -78,2 +78,2 @@\n-  for (int i = 0; i < phase_names->length(); i++) {\n-    const char* name = phase_names->at(i);\n+  for (int i = 0; i < _phase_names->length(); i++) {\n+    const char* name = _phase_names->at(i);\n@@ -92,2 +92,2 @@\n-    if (phase_names == nullptr) {\n-      phase_names = new (mtInternal) GrowableArray<const char*>(100, mtCompiler);\n+    if (_phase_names == nullptr) {\n+      _phase_names = new (mtInternal) GrowableArray<const char*>(100, mtCompiler);\n@@ -104,2 +104,2 @@\n-    index = phase_names->length();\n-    phase_names->append(use_strdup ? os::strdup(phase_name) : phase_name);\n+    index = _phase_names->length();\n+    _phase_names->append(use_strdup ? os::strdup(phase_name) : phase_name);\n","filename":"src\/hotspot\/share\/compiler\/compilerEvent.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-bool G1ParScanThreadState::inject_evacuation_failure(uint region_idx) {\n+bool G1ParScanThreadState::inject_allocation_failure(uint region_idx) {\n@@ -464,0 +464,5 @@\n+  \/\/ JNI only allows pinning of typeArrays, so we only need to keep those in place.\n+  if (region_attr.is_pinned() && klass->is_typeArray_klass()) {\n+    return handle_evacuation_failure_par(old, old_mark, word_sz, true \/* cause_pinned *\/);\n+  }\n+\n@@ -478,1 +483,1 @@\n-      return handle_evacuation_failure_par(old, old_mark, word_sz);\n+      return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n@@ -486,1 +491,1 @@\n-  if (inject_evacuation_failure(from_region->hrm_index())) {\n+  if (inject_allocation_failure(from_region->hrm_index())) {\n@@ -490,1 +495,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz);\n+    return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n@@ -628,1 +633,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz, bool cause_pinned) {\n@@ -636,1 +641,1 @@\n-    if (_evac_failure_regions->record(r->hrm_index())) {\n+    if (_evac_failure_regions->record(_worker_id, r->hrm_index(), cause_pinned)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -168,1 +168,3 @@\n-  static inline size_t filler_array_min_size();\n+  static size_t filler_array_min_size();\n+\n+protected:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1392,1 +1392,1 @@\n-    if (ShenandoahSelfFixing) {\n+    {\n@@ -1395,2 +1395,0 @@\n-    } else {\n-      addr = phase->igvn().zerocon(T_OBJECT);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  if (ShenandoahSelfFixing && load_addr != nullptr && fwd != obj) {\n+  if (load_addr != nullptr && fwd != obj) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -229,0 +230,1 @@\n+  AARCH64_ONLY(fatal(\"Should use ZLoadBarrierStubC2Aarch64::create\"));\n@@ -278,0 +280,1 @@\n+  AARCH64_ONLY(fatal(\"Should use ZStoreBarrierStubC2Aarch64::create\"));\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-public:\n@@ -58,0 +57,1 @@\n+public:\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -793,6 +793,0 @@\n-\/*\n- * java.util.concurrent.atomic.AtomicLong\n- *\/\n-JNIEXPORT jboolean JNICALL\n-JVM_SupportsCX8(void);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -569,0 +569,1 @@\n+\/\/ Note that the implementation of this method assumes it's only called when an exception has actually occured\n@@ -683,0 +684,1 @@\n+    h_method->set_exception_handler_entered(handler_bci); \/\/ profiling\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,9 +93,0 @@\n-  \/\/ This metafunction returns whether it is possible for a type T to require\n-  \/\/ locking to support wide atomics or not.\n-  template <typename T>\n-#ifdef SUPPORTS_NATIVE_CX8\n-  struct PossiblyLockedAccess: public std::false_type {};\n-#else\n-  struct PossiblyLockedAccess: public std::integral_constant<bool, (sizeof(T) > 4)> {};\n-#endif\n-\n@@ -154,7 +145,0 @@\n-  class AccessLocker {\n-  public:\n-    AccessLocker();\n-    ~AccessLocker();\n-  };\n-  bool wide_atomic_needs_locking();\n-\n@@ -295,28 +279,0 @@\n-  \/\/ The following *_locked mechanisms serve the purpose of handling atomic operations\n-  \/\/ that are larger than a machine can handle, and then possibly opt for using\n-  \/\/ a slower path using a mutex to perform the operation.\n-\n-  template <DecoratorSet ds, typename T>\n-  static inline typename EnableIf<\n-    !AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {\n-    return atomic_cmpxchg_internal<ds>(addr, compare_value, new_value);\n-  }\n-\n-  template <DecoratorSet ds, typename T>\n-  static typename EnableIf<\n-    AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);\n-\n-  template <DecoratorSet ds, typename T>\n-  static inline typename EnableIf<\n-    !AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_xchg_maybe_locked(void* addr, T new_value) {\n-    return atomic_xchg_internal<ds>(addr, new_value);\n-  }\n-\n-  template <DecoratorSet ds, typename T>\n-  static typename EnableIf<\n-    AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_xchg_maybe_locked(void* addr, T new_value);\n-\n@@ -336,1 +292,1 @@\n-    return atomic_cmpxchg_maybe_locked<decorators>(addr, compare_value, new_value);\n+    return atomic_cmpxchg_internal<decorators>(addr, compare_value, new_value);\n@@ -341,1 +297,1 @@\n-    return atomic_xchg_maybe_locked<decorators>(addr, new_value);\n+    return atomic_xchg_internal<decorators>(addr, new_value);\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -218,38 +218,0 @@\n-\/\/ For platforms that do not have native support for wide atomics,\n-\/\/ we can emulate the atomicity using a lock. So here we check\n-\/\/ whether that is necessary or not.\n-\n-template <DecoratorSet ds>\n-template <DecoratorSet decorators, typename T>\n-inline typename EnableIf<\n-  AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-RawAccessBarrier<ds>::atomic_xchg_maybe_locked(void* addr, T new_value) {\n-  if (!AccessInternal::wide_atomic_needs_locking()) {\n-    return atomic_xchg_internal<ds>(addr, new_value);\n-  } else {\n-    AccessInternal::AccessLocker access_lock;\n-    volatile T* p = reinterpret_cast<volatile T*>(addr);\n-    T old_val = RawAccess<>::load(p);\n-    RawAccess<>::store(p, new_value);\n-    return old_val;\n-  }\n-}\n-\n-template <DecoratorSet ds>\n-template <DecoratorSet decorators, typename T>\n-inline typename EnableIf<\n-  AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-RawAccessBarrier<ds>::atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {\n-  if (!AccessInternal::wide_atomic_needs_locking()) {\n-    return atomic_cmpxchg_internal<ds>(addr, compare_value, new_value);\n-  } else {\n-    AccessInternal::AccessLocker access_lock;\n-    volatile T* p = reinterpret_cast<volatile T*>(addr);\n-    T old_val = RawAccess<>::load(p);\n-    if (old_val == compare_value) {\n-      RawAccess<>::store(p, new_value);\n-    }\n-    return old_val;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -4485,0 +4485,17 @@\n+\/\/ This nulls out jmethodIDs for all methods in 'klass'\n+\/\/ It needs to be called explicitly for all previous versions of a class because these may not be cleaned up\n+\/\/ during class unloading.\n+\/\/ We can not use the jmethodID cache associated with klass directly because the 'previous' versions\n+\/\/ do not have the jmethodID cache filled in. Instead, we need to lookup jmethodID for each method and this\n+\/\/ is expensive - O(n) for one jmethodID lookup. For all contained methods it is O(n^2).\n+\/\/ The reason for expensive jmethodID lookup for each method is that there is no direct link between method and jmethodID.\n+void InstanceKlass::clear_jmethod_ids(InstanceKlass* klass) {\n+  Array<Method*>* method_refs = klass->methods();\n+  for (int k = 0; k < method_refs->length(); k++) {\n+    Method* method = method_refs->at(k);\n+    if (method != nullptr && method->is_obsolete()) {\n+      method->clear_jmethod_id();\n+    }\n+  }\n+}\n+\n@@ -4528,0 +4545,1 @@\n+      clear_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1158,0 +1158,2 @@\n+  \/\/ This nulls out jmethodIDs for all methods in 'klass'\n+  static void clear_jmethod_ids(InstanceKlass* klass);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -661,0 +661,10 @@\n+void Method::set_exception_handler_entered(int handler_bci) {\n+  if (ProfileExceptionHandlers) {\n+    MethodData* mdo = method_data();\n+    if (mdo != nullptr) {\n+      BitData handler_data = mdo->exception_handler_bci_to_data(handler_bci);\n+      handler_data.set_exception_handler_entered();\n+    }\n+  }\n+}\n+\n@@ -2321,0 +2331,14 @@\n+void Method::clear_jmethod_id() {\n+  \/\/ Being at a safepoint prevents racing against other class redefinitions\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n+  \/\/ The jmethodID is not stored in the Method instance, we need to look it up first\n+  jmethodID methodid = find_jmethod_id_or_null();\n+  \/\/ We need to make sure that jmethodID actually resolves to this method\n+  \/\/ - multiple redefined versions may share jmethodID slots and if a method\n+  \/\/   has already been rewired to a newer version we could be removing reference\n+  \/\/   to a still existing method instance\n+  if (methodid != nullptr && *((Method**)methodid) == this) {\n+    *((Method**)methodid) = nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -315,0 +315,3 @@\n+  \/\/ mark an exception handler as entered (used to prune dead catch blocks in C2)\n+  void set_exception_handler_entered(int handler_bci);\n+\n@@ -729,0 +732,1 @@\n+  void clear_jmethod_id();\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1013,0 +1013,6 @@\n+\n+  if (ProfileExceptionHandlers && method()->has_exception_handler()) {\n+    int num_exception_handlers = method()->exception_table_length();\n+    object_size += num_exception_handlers * single_exception_handler_data_size();\n+  }\n+\n@@ -1345,0 +1351,1 @@\n+  int parm_data_size = 0;\n@@ -1346,1 +1353,2 @@\n-    object_size += DataLayout::compute_size_in_bytes(parms_cell);\n+    parm_data_size = DataLayout::compute_size_in_bytes(parms_cell);\n+    object_size += parm_data_size;\n@@ -1354,0 +1362,11 @@\n+  _exception_handler_data_di = data_size + extra_size + arg_data_size + parm_data_size;\n+  if (ProfileExceptionHandlers && method()->has_exception_handler()) {\n+    int num_exception_handlers = method()->exception_table_length();\n+    object_size += num_exception_handlers * single_exception_handler_data_size();\n+    ExceptionTableElement* exception_handlers = method()->exception_table_start();\n+    for (int i = 0; i < num_exception_handlers; i++) {\n+      DataLayout *dp = exception_handler_data_at(i);\n+      dp->initialize(DataLayout::bit_data_tag, exception_handlers[i].handler_pc, single_exception_handler_data_cell_count());\n+    }\n+  }\n+\n@@ -1448,0 +1467,22 @@\n+DataLayout* MethodData::exception_handler_bci_to_data_helper(int bci) {\n+  assert(ProfileExceptionHandlers, \"not profiling\");\n+  for (int i = 0; i < num_exception_handler_data(); i++) {\n+    DataLayout* exception_handler_data = exception_handler_data_at(i);\n+    if (exception_handler_data->bci() == bci) {\n+      return exception_handler_data;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+BitData* MethodData::exception_handler_bci_to_data_or_null(int bci) {\n+  DataLayout* data = exception_handler_bci_to_data_helper(bci);\n+  return data != nullptr ? new BitData(data) : nullptr;\n+}\n+\n+BitData MethodData::exception_handler_bci_to_data(int bci) {\n+  DataLayout* data = exception_handler_bci_to_data_helper(bci);\n+  assert(data != nullptr, \"invalid bci\");\n+  return BitData(data);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -516,0 +516,1 @@\n+      exception_handler_entered_flag     = null_seen_flag + 1,\n@@ -518,1 +519,1 @@\n-      exception_seen_flag         = null_seen_flag + 1,\n+      exception_seen_flag         = exception_handler_entered_flag + 1,\n@@ -550,0 +551,4 @@\n+  \/\/ true if a ex handler block at this bci was entered\n+  bool exception_handler_entered() { return flag_at(exception_handler_entered_flag); }\n+  void set_exception_handler_entered() { set_flag_at(exception_handler_entered_flag); }\n+\n@@ -2298,0 +2303,3 @@\n+  \/\/ data index of exception handler profiling data\n+  int _exception_handler_data_di;\n+\n@@ -2299,0 +2307,1 @@\n+  \/\/ See comment in ciMethodData::load_data\n@@ -2313,0 +2322,16 @@\n+  static int single_exception_handler_data_cell_count() {\n+    return BitData::static_cell_count();\n+  }\n+\n+  static int single_exception_handler_data_size() {\n+    return DataLayout::compute_size_in_bytes(single_exception_handler_data_cell_count());\n+  }\n+\n+  DataLayout* exception_handler_data_at(int exception_handler_index) const {\n+    return data_layout_at(_exception_handler_data_di + (exception_handler_index * single_exception_handler_data_size()));\n+  }\n+\n+  int num_exception_handler_data() const {\n+    return exception_handlers_data_size() \/ single_exception_handler_data_size();\n+  }\n+\n@@ -2378,0 +2403,2 @@\n+  DataLayout* exception_handler_bci_to_data_helper(int bci);\n+\n@@ -2514,2 +2541,5 @@\n-    ParametersTypeData* param = parameters_type_data();\n-    return param == nullptr ? 0 : param->size_in_bytes();\n+    return pointer_delta_as_int((address) parameters_data_limit(), (address) parameters_data_base());\n+  }\n+\n+  int exception_handlers_data_size() const {\n+    return pointer_delta_as_int((address) exception_handler_data_limit(), (address) exception_handler_data_base());\n@@ -2568,0 +2598,3 @@\n+  BitData* exception_handler_bci_to_data_or_null(int bci);\n+  BitData exception_handler_bci_to_data(int bci);\n+\n@@ -2569,0 +2602,1 @@\n+  \/\/ Only valid after 'set_size' is called at the end of MethodData::initialize\n@@ -2571,2 +2605,13 @@\n-  DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -\n-                                                              parameters_size_in_bytes()); }\n+  \/\/ pointers to sections in extra data\n+  DataLayout* args_data_limit() const  { return parameters_data_base(); }\n+  DataLayout* parameters_data_base() const {\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di) : parameters_data_limit();\n+  }\n+  DataLayout* parameters_data_limit() const {\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return exception_handler_data_base();\n+  }\n+  DataLayout* exception_handler_data_base() const { return data_layout_at(_exception_handler_data_di); }\n+  DataLayout* exception_handler_data_limit() const { return extra_data_limit(); }\n+\n@@ -2620,2 +2665,6 @@\n-    assert(_parameters_type_data_di != parameters_uninitialized && _parameters_type_data_di != no_parameters, \"no args type data\");\n-    return _parameters_type_data_di;\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return _parameters_type_data_di != no_parameters ? _parameters_type_data_di : exception_handlers_data_di();\n+  }\n+\n+  int exception_handlers_data_di() const {\n+    return _exception_handler_data_di;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -792,0 +792,2 @@\n+  develop(bool, StressPrunedExceptionHandlers, false,                       \\\n+          \"Always prune exception handlers\")                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -606,1 +606,5 @@\n-    xtty->print(\"%s\", ss.as_string()); \/\/ print to tty would use xml escape encoding\n+  }\n+\n+  tty->print(\"%s\", ss.as_string());\n+\n+  if (xtty != nullptr) {\n@@ -608,2 +612,0 @@\n-  } else {\n-    tty->print(\"%s\", ss.as_string());\n@@ -5693,1 +5695,1 @@\n-  if ((_directive->ideal_phase_mask() & CompilerPhaseTypeHelper::to_bitmask(cpt)) != 0) {\n+  if (_directive->should_print_phase(cpt)) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -981,1 +981,1 @@\n-  if (has_ex_handler() && !ex_type->klass_is_exact()) {\n+  if (has_exception_handler() && !ex_type->klass_is_exact()) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-\/\/-----------------------------has_ex_handler----------------------------------\n+\/\/-----------------------------has_exception_handler----------------------------------\n@@ -198,1 +198,1 @@\n-bool GraphKit::has_ex_handler() {\n+bool GraphKit::has_exception_handler() {\n@@ -563,1 +563,1 @@\n-        && has_ex_handler()) {\n+        && has_exception_handler()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  bool has_ex_handler();\n+  bool has_exception_handler();\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1320,3 +1320,0 @@\n-  if (t2 == TypeInt::INT)\n-    return TypeInt::INT;\n-\n@@ -1328,1 +1325,1 @@\n-  if (r2->is_con()) {\n+  if (!r1->is_con() && r2->is_con()) {\n@@ -1350,1 +1347,11 @@\n-  if( !r1->is_con() || !r2->is_con() )\n+  if (!r1->is_con() || !r2->is_con()) {\n+    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n+    if (r1->_lo >= 0) {\n+      return TypeInt::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n+    \/\/ Conversely, if the left input is negative then the result must be negative.\n+    if (r1->_hi <= -1) {\n+      return TypeInt::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n@@ -1352,0 +1359,1 @@\n+  }\n@@ -1354,1 +1362,1 @@\n-  return TypeInt::make( r1->get_con() >> (r2->get_con()&31) );\n+  return TypeInt::make(r1->get_con() >> (r2->get_con() & 31));\n@@ -1382,3 +1390,0 @@\n-  if (t2 == TypeInt::INT)\n-    return TypeLong::LONG;\n-\n@@ -1390,1 +1395,1 @@\n-  if (r2->is_con()) {\n+  if (!r1->is_con() && r2->is_con()) {\n@@ -1412,1 +1417,15 @@\n-  return TypeLong::LONG;                \/\/ Give up\n+  if (!r1->is_con() || !r2->is_con()) {\n+    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n+    if (r1->_lo >= 0) {\n+      return TypeLong::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n+    \/\/ Conversely, if the left input is negative then the result must be negative.\n+    if (r1->_hi <= -1) {\n+      return TypeLong::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n+    return TypeLong::LONG;\n+  }\n+\n+  return TypeLong::make(r1->get_con() >> (r2->get_con() & 63));\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -173,0 +173,5 @@\n+  \/\/ Return an integer less than, equal to, or greater than zero\n+  \/\/ if the stack offset of the first argument is respectively\n+  \/\/ less than, equal to, or greater than the second.\n+  int compare_two_spill_nodes(Node* first, Node* second);\n+\n@@ -2342,0 +2347,23 @@\n+int Scheduling::compare_two_spill_nodes(Node* first, Node* second) {\n+  assert(first->is_MachSpillCopy() && second->is_MachSpillCopy(), \"\");\n+\n+  OptoReg::Name first_src_lo = _regalloc->get_reg_first(first->in(1));\n+  OptoReg::Name first_dst_lo = _regalloc->get_reg_first(first);\n+  OptoReg::Name second_src_lo = _regalloc->get_reg_first(second->in(1));\n+  OptoReg::Name second_dst_lo = _regalloc->get_reg_first(second);\n+\n+  \/\/ Comparison between stack -> reg and stack -> reg\n+  if (OptoReg::is_stack(first_src_lo) && OptoReg::is_stack(second_src_lo) &&\n+      OptoReg::is_reg(first_dst_lo) && OptoReg::is_reg(second_dst_lo)) {\n+    return _regalloc->reg2offset(first_src_lo) - _regalloc->reg2offset(second_src_lo);\n+  }\n+\n+  \/\/ Comparison between reg -> stack and reg -> stack\n+  if (OptoReg::is_stack(first_dst_lo) && OptoReg::is_stack(second_dst_lo) &&\n+      OptoReg::is_reg(first_src_lo) && OptoReg::is_reg(second_src_lo)) {\n+    return _regalloc->reg2offset(first_dst_lo) - _regalloc->reg2offset(second_dst_lo);\n+  }\n+\n+  return 0; \/\/ Not comparable\n+}\n+\n@@ -2353,1 +2381,4 @@\n-  \/\/ Insert in latency order (insertion sort)\n+  \/\/ Insert in latency order (insertion sort). If two MachSpillCopyNodes\n+  \/\/ for stack spilling or unspilling have the same latency, we sort\n+  \/\/ them in the order of stack offset. Some ports (e.g. aarch64) may also\n+  \/\/ have more opportunities to do ld\/st merging\n@@ -2355,2 +2386,2 @@\n-  for ( i=0; i < _available.size(); i++ )\n-    if (_current_latency[_available[i]->_idx] > latency)\n+  for (i = 0; i < _available.size(); i++) {\n+    if (_current_latency[_available[i]->_idx] > latency) {\n@@ -2358,0 +2389,6 @@\n+    } else if (_current_latency[_available[i]->_idx] == latency &&\n+               n->is_MachSpillCopy() && _available[i]->is_MachSpillCopy() &&\n+               compare_two_spill_nodes(n, _available[i]) > 0) {\n+      break;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1612,0 +1612,16 @@\n+  if (ProfileExceptionHandlers && block()->is_handler()) {\n+    ciMethodData* methodData = method()->method_data();\n+    if (methodData->is_mature()) {\n+      ciBitData data = methodData->exception_handler_bci_to_data(block()->start());\n+      if (!data.exception_handler_entered() || StressPrunedExceptionHandlers) {\n+        \/\/ dead catch block\n+        \/\/ Emit an uncommon trap instead of processing the block.\n+        set_parse_bci(block()->start());\n+        uncommon_trap(Deoptimization::Reason_unreached,\n+                      Deoptimization::Action_reinterpret,\n+                      nullptr, \"dead catch block\");\n+        return;\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n@@ -105,3 +107,0 @@\n-  static uint64_t to_bitmask(CompilerPhaseType cpt) {\n-    return (UINT64_C(1) << cpt);\n-  }\n@@ -162,0 +161,1 @@\n+  CHeapBitMap _phase_name_set;\n@@ -166,1 +166,5 @@\n-  PhaseNameValidator(ccstrlist option, uint64_t& mask) : _valid(true), _bad(nullptr) {\n+  PhaseNameValidator(ccstrlist option) :\n+    _phase_name_set(PHASE_NUM_TYPES, mtCompiler),\n+    _valid(true),\n+    _bad(nullptr)\n+  {\n@@ -177,1 +181,1 @@\n-        mask = ~(UINT64_C(0));\n+        _phase_name_set.set_range(0, PHASE_NUM_TYPES);\n@@ -179,2 +183,2 @@\n-        assert(cpt < 64, \"out of bounds\");\n-        mask |= CompilerPhaseTypeHelper::to_bitmask(cpt);\n+        assert(cpt < PHASE_NUM_TYPES, \"out of bounds\");\n+        _phase_name_set.set_bit(cpt);\n@@ -191,0 +195,5 @@\n+  const BitMap& phase_name_set() const {\n+    assert(is_valid(), \"Use of invalid phase name set\");\n+    return _phase_name_set;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3700,6 +3700,0 @@\n-\/\/ Atomic \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-JVM_LEAF(jboolean, JVM_SupportsCX8())\n-  return VM_Version::supports_cx8();\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-\n@@ -86,0 +85,24 @@\n+\/\/ Note that scoped accesses (cf. scopedMemoryAccess.cpp) can install\n+\/\/ an async handshake on the entry to an Unsafe method. When that happens,\n+\/\/ it is expected that we are not allowed to touch the underlying memory\n+\/\/ that might have gotten unmapped. Therefore, we check at the entry\n+\/\/ to unsafe functions, if we have such async exception conditions,\n+\/\/ and return immediately if that is the case.\n+\/\/\n+\/\/ We also use NoSafepointVerifier to block potential safepoints.\n+\/\/ It would be problematic if an async exception handshake were installed later on\n+\/\/ during another safepoint in the function, but before the memory access happens,\n+\/\/ as the memory will be freed after the handshake is installed. We must notice\n+\/\/ the installed handshake and return early before doing the memory access to prevent\n+\/\/ accesses to freed memory.\n+\/\/\n+\/\/ Note also that we MUST do a scoped memory access in the VM (or Java) thread\n+\/\/ state. Since we rely on a handshake to check for threads that are accessing\n+\/\/ scoped memory, and we need the handshaking thread to wait until we get to a\n+\/\/ safepoint, in order to make sure we are not in the middle of accessing memory\n+\/\/ that is about to be freed. (i.e. there can be no UNSAFE_LEAF_SCOPED)\n+#define UNSAFE_ENTRY_SCOPED(result_type, header) \\\n+  JVM_ENTRY(static result_type, header) \\\n+  if (thread->has_async_exception_condition()) {return (result_type)0;} \\\n+  NoSafepointVerifier nsv;\n+\n@@ -415,1 +438,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -419,1 +442,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -438,1 +461,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -442,1 +465,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -498,1 +521,1 @@\n-UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n@@ -507,1 +530,1 @@\n-UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n@@ -526,5 +549,1 @@\n-\/\/ This function is a leaf since if the source and destination are both in native memory\n-\/\/ the copy may potentially be very large, and we don't want to disable GC if we can avoid it.\n-\/\/ If either source or destination (or both) are on the heap, the function will enter VM using\n-\/\/ JVM_ENTRY_FROM_LEAF\n-UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n@@ -534,16 +553,2 @@\n-  if (srcObj == nullptr && dstObj == nullptr) {\n-    \/\/ Both src & dst are in native memory\n-    address src = (address)srcOffset;\n-    address dst = (address)dstOffset;\n-\n-    {\n-      JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n-      GuardUnsafeAccess guard(thread);\n-      Copy::conjoint_swap(src, dst, sz, esz);\n-    }\n-  } else {\n-    \/\/ At least one of src\/dst are on heap, transition to VM to access raw pointers\n-\n-    JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {\n-      oop srcp = JNIHandles::resolve(srcObj);\n-      oop dstp = JNIHandles::resolve(dstObj);\n+  oop srcp = JNIHandles::resolve(srcObj);\n+  oop dstp = JNIHandles::resolve(dstObj);\n@@ -551,2 +556,2 @@\n-      address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n-      address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n+  address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n+  address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n@@ -554,5 +559,3 @@\n-      {\n-        GuardUnsafeAccess guard(thread);\n-        Copy::conjoint_swap(src, dst, sz, esz);\n-      }\n-    } JVM_END\n+  {\n+    GuardUnsafeAccess guard(thread);\n+    Copy::conjoint_swap(src, dst, sz, esz);\n@@ -865,1 +868,1 @@\n-UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -871,1 +874,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n@@ -886,1 +889,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -892,1 +895,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":42,"deletions":39,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-    return !(hr->is_young());\n+    return hr->is_old_or_humongous();\n@@ -2686,0 +2686,26 @@\n+WB_ENTRY(void, WB_PinObject(JNIEnv* env, jobject wb, jobject o))\n+#if INCLUDE_G1GC\n+  if (!UseG1GC) {\n+    ShouldNotReachHere();\n+    return;\n+  }\n+  oop obj = JNIHandles::resolve(o);\n+  G1CollectedHeap::heap()->pin_object(thread, obj);\n+#else\n+  ShouldNotReachHere();\n+#endif \/\/ INCLUDE_G1GC\n+WB_END\n+\n+WB_ENTRY(void, WB_UnpinObject(JNIEnv* env, jobject wb, jobject o))\n+#if INCLUDE_G1GC\n+  if (!UseG1GC) {\n+    ShouldNotReachHere();\n+    return;\n+  }\n+  oop obj = JNIHandles::resolve(o);\n+  G1CollectedHeap::heap()->unpin_object(thread, obj);\n+#else\n+  ShouldNotReachHere();\n+#endif \/\/ INCLUDE_G1GC\n+WB_END\n+\n@@ -2710,0 +2736,4 @@\n+WB_ENTRY(void, WB_CleanMetaspaces(JNIEnv* env, jobject target))\n+  ClassLoaderDataGraph::safepoint_and_clean_metaspaces();\n+WB_END\n+\n@@ -2998,0 +3028,2 @@\n+  {CC\"pinObject\",       CC\"(Ljava\/lang\/Object;)V\",    (void*)&WB_PinObject},\n+  {CC\"unpinObject\",     CC\"(Ljava\/lang\/Object;)V\",    (void*)&WB_UnpinObject},\n@@ -3000,0 +3032,1 @@\n+  {CC\"cleanMetaspaces\", CC\"()V\",                      (void*)&WB_CleanMetaspaces},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -514,0 +514,1 @@\n+  { \"RegisterFinalizersAtInit\",     JDK_Version::jdk(22), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n@@ -2994,4 +2995,0 @@\n-bool match_module(void *module_name, ModulePatchPath *patch) {\n-  return (strcmp((char *)module_name, patch->module_name()) == 0);\n-}\n-\n@@ -3017,1 +3014,3 @@\n-  int i = _patch_mod_prefix->find((void*)module_name, match_module);\n+  int i = _patch_mod_prefix->find_if([&](ModulePatchPath* patch) {\n+    return (strcmp(module_name, patch->module_name()) == 0);\n+  });\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2541,0 +2541,11 @@\n+    if (ProfileExceptionHandlers && trap_mdo != nullptr) {\n+      BitData* exception_handler_data = trap_mdo->exception_handler_bci_to_data_or_null(trap_bci);\n+      if (exception_handler_data != nullptr) {\n+        \/\/ uncommon trap at the start of an exception handler.\n+        \/\/ C2 generates these for un-entered exception handlers.\n+        \/\/ mark the handler as entered to avoid generating\n+        \/\/ another uncommon trap the next time the handler is compiled\n+        exception_handler_data->set_exception_handler_entered();\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -298,0 +298,3 @@\n+  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n+          \"InlineCacheBuffer size\")                                         \\\n+                                                                            \\\n@@ -670,2 +673,2 @@\n-          \"Register finalizable objects at end of Object.<init> or \"        \\\n-          \"after allocation\")                                               \\\n+          \"(Deprecated) Register finalizable objects at end of \"            \\\n+          \"Object.<init> or after allocation\")                              \\\n@@ -736,0 +739,4 @@\n+  product(intx, MonitorUnlinkBatch, 500, DIAGNOSTIC,                        \\\n+          \"The maximum number of monitors to unlink in one batch. \")        \\\n+          range(1, max_jint)                                                \\\n+                                                                            \\\n@@ -856,0 +863,7 @@\n+  product(intx, UserThreadWaitAttemptsAtExit, 30,                           \\\n+          \"The number of times to wait for user threads to stop executing \" \\\n+          \"native code during JVM exit. Each wait lasts 10 milliseconds. \"  \\\n+          \"The maximum number of waits is 1000, to wait at most 10 \"        \\\n+          \"seconds.\")                                                       \\\n+          range(0, 1000)                                                    \\\n+                                                                            \\\n@@ -2025,0 +2039,7 @@\n+                                                                            \\\n+  develop(bool, SimulateFullAddressSpace, false,                            \\\n+          \"Simulates a very populated, fragmented address space; no \"       \\\n+          \"targeted reservations will succeed.\")                            \\\n+                                                                            \\\n+  product(bool, ProfileExceptionHandlers, true,                             \\\n+          \"Profile exception handlers\")                                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -232,0 +231,1 @@\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -683,0 +683,1 @@\n+\/\/ Note that the implementation of this method assumes it's only called when an exception has actually occured\n@@ -785,0 +786,3 @@\n+  if (handler_bci != -1) { \/\/ did we find a handler in this method?\n+    sd->method()->set_exception_handler_entered(handler_bci); \/\/ profile\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-\/\/ Walk the in-use list and unlink (at most MonitorDeflationMax) deflated\n-\/\/ ObjectMonitors. Returns the number of unlinked ObjectMonitors.\n+\/\/ Walk the in-use list and unlink deflated ObjectMonitors.\n+\/\/ Returns the number of unlinked ObjectMonitors.\n@@ -91,0 +91,1 @@\n+                                    size_t deflated_count,\n@@ -94,2 +95,2 @@\n-  ObjectMonitor* head = Atomic::load_acquire(&_head);\n-  ObjectMonitor* m = head;\n+  ObjectMonitor* m = Atomic::load_acquire(&_head);\n+\n@@ -99,1 +100,3 @@\n-      \/\/ Find next live ObjectMonitor.\n+      \/\/ Find next live ObjectMonitor. Batch up the unlinkable monitors, so we can\n+      \/\/ modify the list once per batch. The batch starts at \"m\".\n+      size_t unlinked_batch = 0;\n@@ -101,0 +104,4 @@\n+      \/\/ Look for at most MonitorUnlinkBatch monitors, or the number of\n+      \/\/ deflated and not unlinked monitors, whatever comes first.\n+      assert(deflated_count >= unlinked_count, \"Sanity: underflow\");\n+      size_t unlinked_batch_limit = MIN2<size_t>(deflated_count - unlinked_count, MonitorUnlinkBatch);\n@@ -103,1 +110,1 @@\n-        unlinked_count++;\n+        unlinked_batch++;\n@@ -106,2 +113,8 @@\n-        if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-          \/\/ Reached the max so bail out on the gathering loop.\n+        if (unlinked_batch >= unlinked_batch_limit) {\n+          \/\/ Reached the max batch, so bail out of the gathering loop.\n+          break;\n+        }\n+        if (prev == nullptr && Atomic::load(&_head) != m) {\n+          \/\/ Current batch used to be at head, but it is not at head anymore.\n+          \/\/ Bail out and figure out where we currently are. This avoids long\n+          \/\/ walks searching for new prev during unlink under heavy list inserts.\n@@ -111,0 +124,2 @@\n+\n+      \/\/ Unlink the found batch.\n@@ -112,3 +127,5 @@\n-        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, head, next);\n-        if (prev_head != head) {\n-          \/\/ Find new prev ObjectMonitor that just got inserted.\n+        \/\/ The current batch is the first batch, so there is a chance that it starts at head.\n+        \/\/ Optimistically assume no inserts happened, and try to unlink the entire batch from the head.\n+        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, m, next);\n+        if (prev_head != m) {\n+          \/\/ Something must have updated the head. Figure out the actual prev for this batch.\n@@ -118,0 +135,1 @@\n+          assert(prev != nullptr, \"Should have found the prev for the current batch\");\n@@ -121,0 +139,3 @@\n+        \/\/ The current batch is preceded by another batch. This guarantees the current batch\n+        \/\/ does not start at head. Unlink the entire current batch without updating the head.\n+        assert(Atomic::load(&_head) != m, \"Sanity\");\n@@ -123,2 +144,5 @@\n-      if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-        \/\/ Reached the max so bail out on the searching loop.\n+\n+      unlinked_count += unlinked_batch;\n+      if (unlinked_count >= deflated_count) {\n+        \/\/ Reached the max so bail out of the searching loop.\n+        \/\/ There should be no more deflated monitors left.\n@@ -140,0 +164,14 @@\n+\n+#ifdef ASSERT\n+  \/\/ Invariant: the code above should unlink all deflated monitors.\n+  \/\/ The code that runs after this unlinking does not expect deflated monitors.\n+  \/\/ Notably, attempting to deflate the already deflated monitor would break.\n+  {\n+    ObjectMonitor* m = Atomic::load_acquire(&_head);\n+    while (m != nullptr) {\n+      assert(!m->is_being_async_deflated(), \"All deflated monitors should be unlinked\");\n+      m = m->next_om();\n+    }\n+  }\n+#endif\n+\n@@ -622,7 +660,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && monitor->is_owner_anonymous()) {\n-    \/\/ It must be owned by us. Pop lock object from lock stack.\n-    LockStack& lock_stack = current->lock_stack();\n-    oop popped = lock_stack.pop();\n-    assert(popped == object, \"must be owned by this thread\");\n-    monitor->set_owner_from_anonymous(current);\n-  }\n+  assert(!monitor->is_owner_anonymous(), \"must not be\");\n@@ -1620,1 +1652,2 @@\n-static size_t delete_monitors(GrowableArray<ObjectMonitor*>* delete_list) {\n+static size_t delete_monitors(JavaThread* current, GrowableArray<ObjectMonitor*>* delete_list,\n+                              LogStream* ls, elapsedTimer* timer_p) {\n@@ -1622,1 +1655,1 @@\n-  size_t count = 0;\n+  size_t deleted_count = 0;\n@@ -1625,1 +1658,4 @@\n-    count++;\n+    deleted_count++;\n+    \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n+    ObjectSynchronizer::chk_for_block_req(current, \"deletion\", \"deleted_count\",\n+                                          deleted_count, ls, timer_p);\n@@ -1627,1 +1663,1 @@\n-  return count;\n+  return deleted_count;\n@@ -1666,1 +1702,1 @@\n-    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, &delete_list);\n+    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, deflated_count, &delete_list);\n@@ -1701,24 +1737,1 @@\n-    if (current->is_Java_thread()) {\n-      if (ls != nullptr) {\n-        timer.stop();\n-        ls->print_cr(\"before setting blocked: unlinked_count=\" SIZE_FORMAT\n-                     \", in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\"\n-                     SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     unlinked_count, in_use_list_ceiling(),\n-                     _in_use_list.count(), _in_use_list.max());\n-      }\n-      \/\/ Mark the calling JavaThread blocked (safepoint safe) while we free\n-      \/\/ the ObjectMonitors so we don't delay safepoints whilst doing that.\n-      ThreadBlockInVM tbivm(JavaThread::cast(current));\n-      if (ls != nullptr) {\n-        ls->print_cr(\"after setting blocked: in_use_list stats: ceiling=\"\n-                     SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-        timer.start();\n-      }\n-      deleted_count = delete_monitors(&delete_list);\n-      \/\/ ThreadBlockInVM is destroyed here\n-    } else {\n-      \/\/ A non-JavaThread can just free the ObjectMonitors:\n-      deleted_count = delete_monitors(&delete_list);\n-    }\n+    deleted_count = delete_monitors(JavaThread::cast(current), &delete_list, ls, &timer);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":62,"deletions":49,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -497,4 +497,3 @@\n-  int max_wait_user_thread = 30;                  \/\/ at least 300 milliseconds\n-  int max_wait_compiler_thread = 1000;            \/\/ at least 10 seconds\n-\n-  int max_wait = max_wait_compiler_thread;\n+  int wait_time_per_attempt = 10;               \/\/ in milliseconds\n+  int max_wait_attempts_user_thread = UserThreadWaitAttemptsAtExit;\n+  int max_wait_attempts_compiler_thread = 1000; \/\/ at least 10 seconds\n@@ -533,1 +532,1 @@\n-    } else if (attempts > max_wait) {\n+    } else if (attempts >= max_wait_attempts_compiler_thread) {\n@@ -535,1 +534,2 @@\n-    } else if (num_active_compiler_thread == 0 && attempts > max_wait_user_thread) {\n+    } else if (num_active_compiler_thread == 0 &&\n+               attempts >= max_wait_attempts_user_thread) {\n@@ -542,1 +542,1 @@\n-    ml.wait(10);\n+    ml.wait(wait_time_per_attempt);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1113,0 +1113,1 @@\n+  declare_unsigned_integer_type(volatile uint)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -214,1 +214,7 @@\n-  int  find(void* token, bool f(void*, E)) const {\n+  \/\/ Find first element that matches the given predicate.\n+  \/\/\n+  \/\/ Predicate: bool predicate(const E& elem)\n+  \/\/\n+  \/\/ Returns the index of the element or -1 if no element matches the predicate\n+  template<typename Predicate>\n+  int find_if(Predicate predicate) const {\n@@ -216,1 +222,1 @@\n-      if (f(token, _data[i])) return i;\n+      if (predicate(_data[i])) return i;\n@@ -221,1 +227,7 @@\n-  int  find_from_end(void* token, bool f(void*, E)) const {\n+  \/\/ Find last element that matches the given predicate.\n+  \/\/\n+  \/\/ Predicate: bool predicate(const E& elem)\n+  \/\/\n+  \/\/ Returns the index of the element or -1 if no element matches the predicate\n+  template<typename Predicate>\n+  int find_from_end_if(Predicate predicate) const {\n@@ -224,1 +236,1 @@\n-      if (f(token, _data[i])) return i;\n+      if (predicate(_data[i])) return i;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +37,2 @@\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -36,0 +41,2 @@\n+import java.util.Optional;\n+import java.util.function.BiPredicate;\n@@ -38,0 +45,3 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.instruction.SwitchCase;\n@@ -40,0 +50,2 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -57,4 +69,0 @@\n-    private static final MethodHandle INSTANCEOF_CHECK;\n-    private static final MethodHandle INTEGER_EQ_CHECK;\n-    private static final MethodHandle OBJECT_EQ_CHECK;\n-    private static final MethodHandle ENUM_EQ_CHECK;\n@@ -66,0 +74,3 @@\n+    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n+            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n+\n@@ -68,9 +79,0 @@\n-            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isInstance\",\n-                                                                                 MethodType.methodType(boolean.class, Object.class)),\n-                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);\n-            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n-            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n-                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n-            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"enumEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));\n@@ -158,1 +160,3 @@\n-        MethodHandle target = createMethodHandleSwitch(lookup, labels);\n+        MethodHandle target = generateInnerClass(lookup, labels);\n+\n+        target = withIndexCheck(target, labels.length);\n@@ -176,73 +180,0 @@\n-    \/*\n-     * Construct test chains for labels inside switch, to handle switch repeats:\n-     * switch (idx) {\n-     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n-     *     case 1 -> if (selector matches label[1]) return 1; else ...\n-     *     ...\n-     * }\n-     *\/\n-    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        MethodHandle[] testChains = new MethodHandle[labels.length];\n-        List<Object> labelsList = List.of(labels).reversed();\n-\n-        for (int i = 0; i < labels.length; i++) {\n-            MethodHandle test = def;\n-            int idx = labels.length - 1;\n-            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n-\n-            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n-                Object currentLabel = currentLabels.get(j);\n-                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n-                MethodHandle currentTest;\n-                if (currentLabel instanceof Class<?>) {\n-                    currentTest = INSTANCEOF_CHECK;\n-                } else if (currentLabel instanceof Integer) {\n-                    currentTest = INTEGER_EQ_CHECK;\n-                } else if (currentLabel instanceof EnumDesc) {\n-                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());\n-                } else {\n-                    currentTest = OBJECT_EQ_CHECK;\n-                }\n-                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n-                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n-                                                   test);\n-            }\n-            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n-        }\n-\n-        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n-    }\n-\n-    \/*\n-     * Construct code that maps the given selector and repeat index to a case label number:\n-     * if (selector == null) return -1;\n-     * else return \"createRepeatIndexSwitch(labels)\"\n-     *\/\n-    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle mainTest;\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        if (labels.length > 0) {\n-            mainTest = createRepeatIndexSwitch(lookup, labels);\n-        } else {\n-            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n-        }\n-        MethodHandle body =\n-                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n-                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n-                                            mainTest);\n-        MethodHandle switchImpl =\n-                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n-        return withIndexCheck(switchImpl, labels.length);\n-    }\n-\n-    private static boolean integerEqCheck(Object value, Integer constant) {\n-        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n-            return true;\n-        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n@@ -333,1 +264,1 @@\n-            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            \/\/else return \"typeSwitch(labels)\"\n@@ -338,1 +269,1 @@\n-                                                                            createRepeatIndexSwitch(lookup, labels),\n+                                                                            generateInnerClass(lookup, labels),\n@@ -342,1 +273,1 @@\n-            target = createMethodHandleSwitch(lookup, labels);\n+            target = generateInnerClass(lookup, labels);\n@@ -363,1 +294,1 @@\n-            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);\n+            return EnumDesc.of(enumClassTemplate.describeConstable().orElseThrow(), (String) label);\n@@ -392,8 +323,2 @@\n-    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {\n-        if (resolvedEnum.resolvedEnum == null) {\n-            Object resolved;\n-\n-            try {\n-                if (!(value instanceof Enum<?> enumValue)) {\n-                    return false;\n-                }\n+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n@@ -401,1 +326,2 @@\n-                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n+        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    }\n@@ -403,3 +329,1 @@\n-                if (enumValue.getDeclaringClass() != clazz) {\n-                    return false;\n-                }\n+    private static final class ResolvedEnumLabels implements BiPredicate<Integer, Object> {\n@@ -407,4 +331,4 @@\n-                resolved = label.resolveConstantDesc(lookup);\n-            } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n-                resolved = SENTINEL;\n-            }\n+        private final MethodHandles.Lookup lookup;\n+        private final EnumDesc<?>[] enumDescs;\n+        @Stable\n+        private Object[] resolvedEnum;\n@@ -412,1 +336,4 @@\n-            resolvedEnum.resolvedEnum = resolved;\n+        public ResolvedEnumLabels(MethodHandles.Lookup lookup, EnumDesc<?>[] enumDescs) {\n+            this.lookup = lookup;\n+            this.enumDescs = enumDescs;\n+            this.resolvedEnum = new Object[enumDescs.length];\n@@ -415,2 +342,3 @@\n-        return value == resolvedEnum.resolvedEnum;\n-    }\n+        @Override\n+        public boolean test(Integer labelIndex, Object value) {\n+            Object result = resolvedEnum[labelIndex];\n@@ -418,2 +346,5 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n+            if (result == null) {\n+                try {\n+                    if (!(value instanceof Enum<?> enumValue)) {\n+                        return false;\n+                    }\n@@ -421,2 +352,2 @@\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n-    }\n+                    EnumDesc<?> label = enumDescs[labelIndex];\n+                    Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n@@ -424,3 +355,14 @@\n-    private static final class ResolvedEnumLabel {\n-        @Stable\n-        public Object resolvedEnum;\n+                    if (enumValue.getDeclaringClass() != clazz) {\n+                        return false;\n+                    }\n+\n+                    result = label.resolveConstantDesc(lookup);\n+                } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n+                    result = SENTINEL;\n+                }\n+\n+                resolvedEnum[labelIndex] = result;\n+            }\n+\n+            return result == value;\n+        }\n@@ -433,0 +375,169 @@\n+\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0;\n+     *     case 1 -> if (selector matches label[1]) return 1;\n+     *     ...\n+     * }\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Object[] labels) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = Classfile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n+            clb.withFlags(AccessFlag.FINAL, AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"typeSwitch\",\n+                               TYPES_SWITCH_DESCRIPTOR,\n+                               Classfile.ACC_FINAL | Classfile.ACC_PUBLIC | Classfile.ACC_STATIC,\n+                               cb -> {\n+                    cb.aload(0);\n+                    Label nonNullLabel = cb.newLabel();\n+                    cb.if_nonnull(nonNullLabel);\n+                    cb.iconst_m1();\n+                    cb.ireturn();\n+                    cb.labelBinding(nonNullLabel);\n+                    if (labels.length == 0) {\n+                        cb.constantInstruction(0)\n+                          .ireturn();\n+                        return ;\n+                    }\n+                    cb.iload(1);\n+                    Label dflt = cb.newLabel();\n+                    record Element(Label target, Label next, Object caseLabel) {}\n+                    List<Element> cases = new ArrayList<>();\n+                    List<SwitchCase> switchCases = new ArrayList<>();\n+                    Object lastLabel = null;\n+                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n+                        Object currentLabel = labels[idx];\n+                        Label target = cb.newLabel();\n+                        Label next;\n+                        if (lastLabel == null) {\n+                            next = dflt;\n+                        } else if (lastLabel.equals(currentLabel)) {\n+                            next = cases.getLast().next();\n+                        } else {\n+                            next = cases.getLast().target();\n+                        }\n+                        lastLabel = currentLabel;\n+                        cases.add(new Element(target, next, currentLabel));\n+                        switchCases.add(SwitchCase.of(idx, target));\n+                    }\n+                    cases = cases.reversed();\n+                    switchCases = switchCases.reversed();\n+                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n+                    for (int idx = 0; idx < cases.size(); idx++) {\n+                        Element element = cases.get(idx);\n+                        Label next = element.next();\n+                        cb.labelBinding(element.target());\n+                        if (element.caseLabel() instanceof Class<?> classLabel) {\n+                            Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                            if (classLabelConstableOpt.isPresent()) {\n+                                cb.aload(0);\n+                                cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+                                cb.ifeq(next);\n+                            } else {\n+                                cb.aload(3);\n+                                cb.constantInstruction(extraClassLabels.size());\n+                                cb.invokeinterface(ConstantDescs.CD_List,\n+                                                   \"get\",\n+                                                   MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                                                     ConstantDescs.CD_int));\n+                                cb.checkcast(ConstantDescs.CD_Class);\n+                                cb.aload(0);\n+                                cb.invokevirtual(ConstantDescs.CD_Class,\n+                                                 \"isInstance\",\n+                                                 MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                   ConstantDescs.CD_Object));\n+                                cb.ifeq(next);\n+                                extraClassLabels.add(classLabel);\n+                            }\n+                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                            int enumIdx = enumDescs.size();\n+                            enumDescs.add(enumLabel);\n+                            cb.aload(2);\n+                            cb.constantInstruction(enumIdx);\n+                            cb.invokestatic(ConstantDescs.CD_Integer,\n+                                            \"valueOf\",\n+                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                                              ConstantDescs.CD_int));\n+                            cb.aload(0);\n+                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                                               \"test\",\n+                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                 ConstantDescs.CD_Object,\n+                                                                 ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof String stringLabel) {\n+                            cb.ldc(stringLabel);\n+                            cb.aload(0);\n+                            cb.invokevirtual(ConstantDescs.CD_Object,\n+                                             \"equals\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                               ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                            Label compare = cb.newLabel();\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            cb.ifeq(notNumber);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            cb.invokevirtual(ConstantDescs.CD_Number,\n+                                             \"intValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n+                            cb.goto_(compare);\n+                            cb.labelBinding(notNumber);\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Character);\n+                            cb.ifeq(next);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Character);\n+                            cb.invokevirtual(ConstantDescs.CD_Character,\n+                                             \"charValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n+                            cb.labelBinding(compare);\n+                            cb.ldc(integerLabel);\n+                            cb.if_icmpne(next);\n+                        } else {\n+                            throw new InternalError(\"Unsupported label type: \" +\n+                                                    element.caseLabel().getClass());\n+                        }\n+                        cb.constantInstruction(idx);\n+                        cb.ireturn();\n+                    }\n+                    cb.labelBinding(dflt);\n+                    cb.constantInstruction(cases.size());\n+                    cb.ireturn();\n+                });\n+        });\n+\n+        try {\n+            \/\/ this class is linked at the indy callsite; so define a hidden nestmate\n+            MethodHandles.Lookup lookup;\n+            lookup = caller.defineHiddenClass(classBytes, true, NESTMATE, STRONG);\n+            MethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(),\n+                                                        \"typeSwitch\",\n+                                                        MethodType.methodType(int.class,\n+                                                                              Object.class,\n+                                                                              int.class,\n+                                                                              BiPredicate.class,\n+                                                                              List.class));\n+            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                                List.copyOf(extraClassLabels));\n+        } catch (Throwable t) {\n+            throw new IllegalArgumentException(t);\n+        }\n+    }\n+\n+    \/\/based on src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java:\n+    private static String typeSwitchClassName(Class<?> targetClass) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$TypeSwitch\";\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":228,"deletions":117,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -357,5 +357,0 @@\n-            this(option, false);\n-        }\n-\n-        LintCategory(String option, boolean hidden) {\n-            this.hidden = hidden;\n@@ -371,1 +366,0 @@\n-        public final boolean hidden;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2347,1 +2347,6 @@\n-            mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            \/* possible information loss if the type of the method is void then we can't add type\n+             * annotations to it\n+             *\/\n+            if (!mt.restype.hasTag(TypeTag.VOID)) {\n+                mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2122,1 +2122,1 @@\n-# 0: string\n+# 0: string, 1: fragment\n@@ -2124,1 +2124,1 @@\n-    bootstrap class path not set in conjunction with -source {0}\n+    bootstrap class path is not set in conjunction with -source {0}\\n{1}\n@@ -2126,1 +2126,1 @@\n-# 0: string\n+# 0: string, 1: fragment\n@@ -2128,1 +2128,21 @@\n-    system modules path not set in conjunction with -source {0}\n+    location of system modules is not set in conjunction with -source {0}\\n{1}\n+\n+# 0: string\n+compiler.misc.source.no.bootclasspath=\\\n+  not setting the bootstrap class path may lead to class files that cannot run on JDK {0}\\n\\\n+  --release {0} is recommended instead of -source {0} because it sets the bootstrap class path automatically\n+\n+# 0: string\n+compiler.misc.source.no.system.modules.path=\\\n+  not setting the location of system modules may lead to class files that cannot run on JDK {0}\\n\\\n+  --release {0} is recommended instead of -source {0} because it sets the location of system modules automatically\n+\n+# 0: string, 1: string\n+compiler.misc.source.no.bootclasspath.with.target=\\\n+  not setting the bootstrap class path may lead to class files that cannot run on JDK 8\\n\\\n+  --release {0} is recommended instead of -source {0} -target {1} because it sets the bootstrap class path automatically\n+\n+# 0: string, 1: string\n+compiler.misc.source.no.system.modules.path.with.target=\\\n+  not setting the location of system modules may lead to class files that cannot run on JDK {0}\\n\\\n+  --release {0} is recommended instead of -source {0} -target {1} because it sets the location of system modules automatically\n@@ -3981,3 +4001,4 @@\n-# 0: string, 1: target\n-compiler.warn.source.target.conflict=\\\n-    source release {0} requires target release {1}\n+# 0: string, 1: string\n+compiler.err.source.target.conflict=\\\n+    specified target release {1} is too old for the specified source release {0}\\n\\\n+    --release {1} is recommended when compiling code to run on JDK {1}\n@@ -3985,3 +4006,4 @@\n-# 0: string, 1: target\n-compiler.warn.target.default.source.conflict=\\\n-    target release {0} conflicts with default source release {1}\n+# 0: string, 1: string\n+compiler.err.target.default.source.conflict=\\\n+    specified target release {1} is too old for the default source release {0}\\n\\\n+    --release {1} is recommended when compiling code to run on JDK {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+compiler\/vectorapi\/reshape\/TestVectorReinterpret.java 8320897 aix-ppc64,linux-ppc64le\n@@ -91,2 +92,2 @@\n-gc\/stress\/gclocker\/TestGCLockerWithG1.java 8180622 generic-all\n-gc\/stress\/TestJNIBlockFullGC\/TestJNIBlockFullGC.java 8192647 generic-all\n+gc\/stress\/gclocker\/TestGCLockerWithSerial.java 8180622 generic-all\n+gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java 8180622 generic-all\n@@ -145,1 +146,1 @@\n-serviceability\/attach\/ConcAttachTest.java 8290043 linux-all\n+serviceability\/attach\/ConcAttachTest.java 8290043,8318866 linux-all,macosx-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\"intrinsic_or_type_checked_inlining\");\n+        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP, \"intrinsic_or_type_checked_inlining\");\n@@ -562,1 +562,1 @@\n-        trapNodes(INTRINSIC_TRAP,\"intrinsic\");\n+        trapNodes(INTRINSIC_TRAP, \"intrinsic\");\n@@ -1048,1 +1048,1 @@\n-        trapNodes(NULL_ASSERT_TRAP,\"null_assert\");\n+        trapNodes(NULL_ASSERT_TRAP, \"null_assert\");\n@@ -1053,1 +1053,1 @@\n-        trapNodes(NULL_CHECK_TRAP,\"null_check\");\n+        trapNodes(NULL_CHECK_TRAP, \"null_check\");\n@@ -1137,1 +1137,1 @@\n-        trapNodes(PREDICATE_TRAP,\"predicate\");\n+        trapNodes(PREDICATE_TRAP, \"predicate\");\n@@ -1142,1 +1142,1 @@\n-        trapNodes(RANGE_CHECK_TRAP,\"range_check\");\n+        trapNodes(RANGE_CHECK_TRAP, \"range_check\");\n@@ -1494,1 +1494,1 @@\n-        trapNodes(TRAP,\"reason\");\n+        trapNodes(TRAP, \"reason\");\n@@ -1529,1 +1529,1 @@\n-        trapNodes(UNHANDLED_TRAP,\"unhandled\");\n+        trapNodes(UNHANDLED_TRAP, \"unhandled\");\n@@ -1534,1 +1534,6 @@\n-        trapNodes(UNSTABLE_IF_TRAP,\"unstable_if\");\n+        trapNodes(UNSTABLE_IF_TRAP, \"unstable_if\");\n+    }\n+\n+    public static final String UNREACHED_TRAP = PREFIX + \"UNREACHED_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(UNREACHED_TRAP, \"unreached\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-java\/lang\/invoke\/lambda\/LambdaFileEncodingSerialization.java    8249079 linux-x64\n+java\/lang\/invoke\/lambda\/LambdaFileEncodingSerialization.java    8249079 linux-all\n@@ -573,0 +573,1 @@\n+java\/nio\/file\/Files\/probeContentType\/Basic.java                 8320943 windows-all\n@@ -625,6 +626,0 @@\n-sun\/security\/tools\/keytool\/NssTest.java                         8295343 generic-all\n-sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 generic-all\n-sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 generic-all\n-sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 generic-all\n-sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 generic-all\n-sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 generic-all\n@@ -669,0 +664,1 @@\n+javax\/swing\/JFileChooser\/8194044\/FileSystemRootTest.java 8320944 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    -:jdk_vector_sanity \\\n@@ -80,3 +81,3 @@\n-   -:jdk_svc_sanity \\\n-   -:jdk_vector_sanity \\\n-   -:svc_tools\n+    -:jdk_svc_sanity \\\n+    -:svc_tools \\\n+    :jdk_jpackage\n@@ -294,1 +295,1 @@\n-# Tool (and tool API) tests are split into core and svc groups\n+# Tool (and tool API) tests are mostly split into core and svc groups\n@@ -298,0 +299,1 @@\n+    -tools\/jpackage \\\n@@ -309,1 +311,2 @@\n-    :svc_tools\n+    :svc_tools \\\n+    :jdk_jpackage\n@@ -314,0 +317,3 @@\n+jdk_jpackage = \\\n+    tools\/jpackage\n+\n@@ -589,1 +595,3 @@\n-    :jdk_core_manual_no_input_security\n+    :jdk_security_manual_no_input \\\n+    :jdk_core_manual_interactive \\\n+    :jdk_security_manual_interactive\n@@ -608,1 +616,1 @@\n-jdk_core_manual_no_input_security = \\\n+jdk_security_manual_no_input = \\\n@@ -635,1 +643,0 @@\n-    sun\/security\/tools\/keytool\/i18n.java \\\n@@ -638,1 +645,4 @@\n-    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java \\\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java\n+\n+jdk_security_manual_interactive = \\\n+    sun\/security\/tools\/keytool\/i18n.java \\\n@@ -642,1 +652,0 @@\n-\n","filename":"test\/jdk\/TEST.groups","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -210,2 +210,2 @@\n-compiler.warn.source.target.conflict\n-compiler.warn.target.default.source.conflict\n+compiler.err.source.target.conflict\n+compiler.err.target.default.source.conflict\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -754,1 +754,1 @@\n-        Path systemModules = ctSym.resolve(\"systemModules\");\n+        Path modules = ctSym.resolve(\"modules\");\n@@ -756,1 +756,1 @@\n-        Files.newBufferedWriter(systemModules).close();\n+        Files.createDirectories(modules);\n@@ -761,1 +761,1 @@\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", systemModules.toString());\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", \"\", modules.toString());\n@@ -1040,1 +1040,1 @@\n-        Path systemModules = descDest.resolve(\"systemModules\");\n+        Path modules = descDest.resolve(\"modules\");\n@@ -1042,1 +1042,1 @@\n-        Files.newBufferedWriter(systemModules).close();\n+        Files.createDirectories(modules);\n@@ -1045,1 +1045,1 @@\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", systemModules.toString());\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", \"\", modules.toString());\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -539,0 +539,2 @@\n+  public native void cleanMetaspaces();\n+\n@@ -802,0 +804,4 @@\n+  public native void pinObject(Object o);\n+\n+  public native void unpinObject(Object o);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}