{"files":[{"patch":"@@ -60,1 +60,1 @@\n-    \/\/ Test handling of errors during the initialization of a primitive class\n+    \/\/ Test handling of errors during the initialization of a value class\n@@ -62,1 +62,1 @@\n-    \/\/ of all its primitive class typed fields, in this case BadOne\n+    \/\/ of all its value class typed fields, in this case BadOne\n@@ -114,1 +114,1 @@\n-    \/\/ Same test as above, but for arrays of primitive objects\n+    \/\/ Same test as above, but for arrays of value objects\n@@ -116,1 +116,1 @@\n-        \/\/ Testing anewarray when the primitive element class fails to initialize properly\n+        \/\/ Testing anewarray when the value element class fails to initialize properly\n@@ -137,1 +137,1 @@\n-        Testing multianewarray when the primitive element class fails to initialize properly\n+        Testing multianewarray when the value element class fails to initialize properly\n@@ -170,1 +170,1 @@\n-    \/\/ Even if a primitive class fails to initialize properly, some instances\n+    \/\/ Even if a value class fails to initialize properly, some instances\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ClassInitializationFailuresTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    static primitive class InlineClass {\n+    static value class InlineClass {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CreationErrorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,6 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+\n@@ -33,2 +39,2 @@\n- * @compile -XDenablePrimitiveClasses EmptyInlineTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=128 runtime.valhalla.inlinetypes.EmptyInlineTest\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED EmptyInlineTest.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:InlineFieldMaxFlatSize=128 --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.EmptyInlineTest\n@@ -39,1 +45,3 @@\n-    static primitive class EmptyInline {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyInline {\n@@ -45,1 +53,4 @@\n-    static primitive class EmptyField {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class EmptyField {\n+        @NullRestricted\n@@ -62,0 +73,1 @@\n+        @NullRestricted\n@@ -72,1 +84,1 @@\n-        Asserts.assertEquals(emptyField.empty.getClass(), EmptyInline.ref.class);\n+        Asserts.assertEquals(emptyField.empty.getClass(), EmptyInline.class);\n@@ -78,1 +90,1 @@\n-        Asserts.assertEquals(w.empty.getClass(), EmptyInline.ref.class);\n+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);\n@@ -81,1 +93,1 @@\n-        Asserts.assertEquals(w.empty.getClass(), EmptyInline.ref.class);\n+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);\n@@ -85,1 +97,1 @@\n-        EmptyInline[] emptyArray = new EmptyInline[100];\n+        EmptyInline[] emptyArray = (EmptyInline[])VM.newNullRestrictedArray(EmptyInline.class, 100);\n@@ -87,1 +99,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n@@ -92,1 +104,1 @@\n-        EmptyInline[] array2 = new EmptyInline[100];\n+        EmptyInline[] array2 = (EmptyInline[])VM.newNullRestrictedArray(EmptyInline.class, 100);\n@@ -96,1 +108,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n@@ -102,1 +114,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n@@ -108,1 +120,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n@@ -132,1 +144,1 @@\n-            Asserts.assertEquals(e.getClass(), EmptyInline.ref.class);\n+            Asserts.assertEquals(e.getClass(), EmptyInline.class);\n@@ -136,1 +148,1 @@\n-            Asserts.assertEquals(e.getClass(), EmptyInline.ref.class);\n+            Asserts.assertEquals(e.getClass(), EmptyInline.class);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/EmptyInlineTest.java","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -34,2 +35,3 @@\n- * @compile -XDenablePrimitiveClasses Ifacmp.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xms16m -Xmx16m -XX:+UseSerialGC\n+ * @compile --source 22 --enable-preview --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Ifacmp.java\n+ * @run main\/othervm --enable-preview --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla -Xms16m -Xmx16m -XX:+UseSerialGC\n@@ -40,1 +42,3 @@\n-    static primitive class MyValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue {\n@@ -44,1 +48,3 @@\n-    static primitive class MyValue2 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue2 {\n@@ -181,1 +187,1 @@\n-        return acmpModeInlineAlwaysFalse ? (!(a != null && PrimitiveClass.isPrimitiveClass(a.getClass()))) : true;\n+        return acmpModeInlineAlwaysFalse ? (!(a != null && a.getClass().isValue())) : true;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Ifacmp.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,4 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -35,0 +38,1 @@\n+import runtime.valhalla.inlinetypes.InlineOops.FooValue;\n@@ -44,1 +48,1 @@\n- * @compile -XDenablePrimitiveClasses Person.java InlineOops.java\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Person.java InlineOops.java\n@@ -47,1 +51,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -60,1 +65,1 @@\n- * @compile -XDenablePrimitiveClasses Person.java InlineOops.java\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Person.java InlineOops.java\n@@ -63,1 +68,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -76,1 +82,1 @@\n- * @compile -XDenablePrimitiveClasses Person.java InlineOops.java\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Person.java InlineOops.java\n@@ -79,1 +85,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -92,1 +99,1 @@\n- * @compile -XDenablePrimitiveClasses Person.java InlineOops.java\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Person.java InlineOops.java\n@@ -95,1 +102,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -109,1 +117,1 @@\n- * @compile -XDenablePrimitiveClasses Person.java InlineOops.java\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Person.java InlineOops.java\n@@ -112,1 +120,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -168,0 +177,1 @@\n+        @NullRestricted\n@@ -169,0 +179,1 @@\n+        @NullRestricted\n@@ -172,3 +183,7 @@\n-    static final primitive class Composition {\n-        public final Person onePerson;\n-        public final Person otherPerson;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Composition {\n+        @NullRestricted\n+        public Person onePerson;\n+        @NullRestricted\n+        public Person otherPerson;\n@@ -191,1 +206,1 @@\n-        Person[] array =  new Person[NOF_PEOPLE];\n+        Person[] array = (Person[])VM.newNullRestrictedArray(Person.class, NOF_PEOPLE);\n@@ -354,1 +369,1 @@\n-            Class<?> vtClass = PrimitiveClass.asValueType(Person.class);\n+            Class<?> vtClass = Person.class;\n@@ -487,1 +502,1 @@\n-        return Person.default;\n+        return (Person)VM.newNullRestrictedArray(Person.class, 1)[0];\n@@ -533,1 +548,3 @@\n-    static final primitive class ObjectValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ObjectValue {\n@@ -567,1 +584,3 @@\n-    public static final primitive class FooValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public static value class FooValue {\n@@ -594,1 +613,1 @@\n-                            .aconst_init(PrimitiveClass.asValueType(FooValue.class))\n+                            .aconst_init(FooValue.class)\n@@ -604,1 +623,1 @@\n-                            .aconst_init(PrimitiveClass.asValueType(FooValue.class))\n+                            .aconst_init(FooValue.class)\n@@ -625,1 +644,2 @@\n-            FooValue[] fa = new FooValue[] { f };\n+            FooValue[] fa = (FooValue[])VM.newNullRestrictedArray(FooValue.class, 1);\n+            fa[0] = f;\n@@ -655,6 +675,9 @@\n-    static final primitive class BarValue {\n-        final FooValue foo;\n-        final long extendedId;\n-        final String moreNotes;\n-        final int count;\n-        final String otherStuff;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class BarValue {\n+        @NullRestricted\n+        FooValue foo;\n+        long extendedId;\n+        String moreNotes;\n+        int count;\n+        String otherStuff;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":51,"deletions":28,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -26,0 +26,5 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n@@ -31,2 +36,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n@@ -40,4 +43,4 @@\n- * @compile -XDenablePrimitiveClasses InlineTypeArray.java Point.java Long8Inline.java Person.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=-1 runtime.valhalla.inlinetypes.InlineTypeArray\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=0  runtime.valhalla.inlinetypes.InlineTypeArray\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @compile --source 22 --enable-preview --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED InlineTypeArray.java Point.java Long8Inline.java Person.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:FlatArrayElementMaxSize=-1 --enable-preview --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @run main\/othervm -XX:+EnableValhalla -XX:FlatArrayElementMaxSize=0 --enable-preview --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+UnlockDiagnosticVMOptions --enable-preview -XX:ForceNonTearable=* --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.InlineTypeArray\n@@ -70,1 +73,0 @@\n-        String qarrayClsName = \"[Qruntime.valhalla.inlinetypes.Point;\";\n@@ -72,1 +74,0 @@\n-            \/\/ L-type..\n@@ -80,13 +81,0 @@\n-\n-            \/\/ Q-type...\n-            arrayCls = Class.forName(qarrayClsName);\n-            assertTrue(arrayCls.isArray(), \"Expected an array class\");\n-\n-            assertTrue(arrayCls.getComponentType() == PrimitiveClass.asValueType(Point.class),\n-                       arrayCls +\n-                       \" Expected component type of Point.class got: \" + arrayCls.getComponentType());\n-\n-            qarrayClsName = \"[\" + qarrayClsName;\n-            mulArrayCls = Class.forName(qarrayClsName);\n-            assertTrue(mulArrayCls.isArray());\n-            assertTrue(mulArrayCls.getComponentType() == arrayCls);\n@@ -100,1 +88,1 @@\n-        Point[] defaultPoint = new Point[1];\n+        Point[] defaultPoint = (Point[])VM.newNullRestrictedArray(Point.class, 1);\n@@ -121,1 +109,1 @@\n-        Point[] pointsCopy = new Point[points.length];\n+        Point[] pointsCopy = (Point[])VM.newNullRestrictedArray(Point.class, points.length);\n@@ -139,1 +127,1 @@\n-        Point[] pointsCopy = new Point[points.length];\n+        Point[] pointsCopy = (Point[])VM.newNullRestrictedArray(Point.class, points.length);\n@@ -154,1 +142,1 @@\n-        Point[] ps = new Point[4];\n+        Point[] ps = (Point[])VM.newNullRestrictedArray(Point.class, 4);\n@@ -181,1 +169,1 @@\n-        Long8Inline[] values = new Long8Inline[3];\n+        Long8Inline[] values = (Long8Inline[])VM.newNullRestrictedArray(Long8Inline.class, 3);\n@@ -191,1 +179,1 @@\n-        Long8Inline[] copy = new Long8Inline[values.length];\n+        Long8Inline[] copy = (Long8Inline[])VM.newNullRestrictedArray(Long8Inline.class, values.length);\n@@ -198,1 +186,1 @@\n-        Person[] people = new Person[3];\n+        Person[] people = (Person[])VM.newNullRestrictedArray(Person.class, 3);\n@@ -208,1 +196,1 @@\n-        Person[] peopleCopy = new Person[people.length];\n+        Person[] peopleCopy = (Person[])VM.newNullRestrictedArray(Person.class, people.length);\n@@ -216,0 +204,1 @@\n+        \/*\n@@ -224,0 +213,1 @@\n+        *\/\n@@ -239,1 +229,1 @@\n-        Point.ref[][] barray = (Point.ref[][]) Array.newInstance(Point.ref.class, 1, 2);\n+        Point[][] barray = (Point[][]) Array.newInstance(Point.class, 1, 2);\n@@ -243,1 +233,1 @@\n-        Point.ref pb = barray[0][1];\n+        Point pb = barray[0][1];\n@@ -248,2 +238,4 @@\n-    static final primitive class MyInt implements Comparable<MyInt.ref> {\n-        final int value;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyInt implements Comparable<MyInt> {\n+        int value;\n@@ -255,1 +247,1 @@\n-        public int compareTo(MyInt.ref that) { return Integer.compare(this.getValue(), that.getValue()); }\n+        public int compareTo(MyInt that) { return Integer.compare(this.getValue(), that.getValue()); }\n@@ -268,3 +260,3 @@\n-        public static final MyInt.ref MIN = MyInt.create(Integer.MIN_VALUE);\n-        public static final MyInt.ref ZERO = MyInt.create(0);\n-        public static final MyInt.ref MAX = MyInt.create(Integer.MAX_VALUE);\n+        public static final MyInt MIN = MyInt.create(Integer.MIN_VALUE);\n+        public static final MyInt ZERO = MyInt.create(0);\n+        public static final MyInt MAX = MyInt.create(Integer.MAX_VALUE);\n@@ -273,3 +265,10 @@\n-    static MyInt staticMyInt = MyInt.create(-1);\n-    static MyInt[] staticMyIntArray = new MyInt[] { staticMyInt };\n-    static MyInt[][] staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };\n+    static MyInt staticMyInt;\n+    static MyInt[] staticMyIntArray;\n+    static MyInt[][] staticMyIntArrayArray;\n+\n+    static {\n+        staticMyInt = MyInt.create(-1);\n+        staticMyIntArray = (MyInt[])VM.newNullRestrictedArray(MyInt.class, 1);\n+        staticMyIntArray[0] = staticMyInt;\n+        staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };\n+    }\n@@ -281,1 +280,3 @@\n-    static final primitive class MyOtherInt implements SomeSecondaryType {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyOtherInt implements SomeSecondaryType {\n@@ -287,1 +288,1 @@\n-        MyInt[] myInts = new MyInt[1];\n+        MyInt[] myInts = (MyInt[])VM.newNullRestrictedArray(MyInt.class, 1);\n@@ -292,2 +293,2 @@\n-        Class<?> cls = PrimitiveClass.asValueType(MyInt.class);\n-        assertTrue(PrimitiveClass.isPrimitiveValueType(cls));\n+        Class<?> cls = MyInt.class;\n+        assertTrue(cls.isValue());\n@@ -309,1 +310,1 @@\n-        assertTrue(matrix[0] instanceof MyOtherInt.ref[]);\n+        assertTrue(matrix[0] instanceof MyOtherInt[]);\n@@ -312,2 +313,2 @@\n-        MyInt.ref[] myValueRefs = new MyInt.ref[1];\n-        assertTrue(myValueRefs instanceof MyInt.ref[]);\n+        MyInt[] myValueRefs = new MyInt[1];\n+        assertTrue(myValueRefs instanceof MyInt[]);\n@@ -316,1 +317,0 @@\n-        assertFalse(myValueRefs instanceof MyInt[]);\n@@ -318,2 +318,2 @@\n-        MyInt.ref[][] myMdValueRefs = new MyInt.ref[1][1];\n-        assertTrue(myMdValueRefs[0] instanceof MyInt.ref[]);\n+        MyInt[][] myMdValueRefs = new MyInt[1][1];\n+        assertTrue(myMdValueRefs[0] instanceof MyInt[]);\n@@ -322,1 +322,0 @@\n-        assertFalse(myMdValueRefs[0] instanceof MyInt[]);\n@@ -325,8 +324,4 @@\n-        MyInt.ref[]     va1 = (MyInt.ref[])null;\n-        MyInt.ref[]     va2 = null;\n-        MyInt.ref[][]   va3 = (MyInt.ref[][])null;\n-        MyInt.ref[][][] va4 = (MyInt.ref[][][])null;\n-        MyInt[]      va5 = null;\n-        MyInt[]      va6 = (MyInt[])null;\n-        MyInt[][]    va7 = (MyInt[][])null;\n-        MyInt[][][]  va8 = (MyInt[][][])null;\n+        MyInt[]     va1 = (MyInt[])null;\n+        MyInt[]     va2 = null;\n+        MyInt[][]   va3 = (MyInt[][])null;\n+        MyInt[][][] va4 = (MyInt[][][])null;\n@@ -340,1 +335,3 @@\n-        MyInt[] myInts = new MyInt[] { (MyInt) MyInt.MAX, (MyInt) MyInt.MIN };\n+        MyInt[] myInts = (MyInt[])VM.newNullRestrictedArray(MyInt.class, 2);\n+        myInts[0] = (MyInt) MyInt.MAX;\n+        myInts[1] = (MyInt) MyInt.MIN;\n@@ -343,1 +340,5 @@\n-        checkArrayElementsEqual(copyMyInts, new MyInt[] { myInts[0], myInts[1], (MyInt) MyInt.ZERO});\n+        MyInt[] expected = (MyInt[])VM.newNullRestrictedArray(MyInt.class, 3);\n+        expected[0] = myInts[0];\n+        expected[1] = myInts[1];\n+        expected[2] = (MyInt) MyInt.ZERO;\n+        checkArrayElementsEqual(copyMyInts, expected);\n@@ -346,1 +347,5 @@\n-        checkArrayElementsEqual(copyMyInts, new MyInt[] { (MyInt) MyInt.MIN, (MyInt) MyInt.ZERO, (MyInt) MyInt.MAX });\n+        expected = (MyInt[])VM.newNullRestrictedArray(MyInt.class, 3);\n+        expected[0] = (MyInt) MyInt.MIN;\n+        expected[1] = (MyInt) MyInt.ZERO;\n+        expected[2] = (MyInt) MyInt.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n@@ -349,1 +354,3 @@\n-        checkArrayElementsEqual(copyMyInts, myIntList.toArray(new MyInt[copyMyInts.length]));\n+\n+        MyInt[] dest = (MyInt[])VM.newNullRestrictedArray(MyInt.class, copyMyInts.length);\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n@@ -354,1 +361,1 @@\n-        ArrayList<MyInt.ref> aList = new ArrayList<MyInt.ref>(Arrays.asList(copyMyInts));\n+        ArrayList<MyInt> aList = new ArrayList<MyInt>(Arrays.asList(copyMyInts));\n@@ -401,1 +408,1 @@\n-        MyInt.ref[] myIntRefArray = new MyInt.ref[1];\n+        MyInt[] myIntRefArray = new MyInt[1];\n@@ -405,2 +412,2 @@\n-        MyInt.ref[] srcNulls = new MyInt.ref[2];\n-        MyInt.ref[] dstNulls = new MyInt.ref[2];\n+        MyInt[] srcNulls = new MyInt[2];\n+        MyInt[] dstNulls = new MyInt[2];\n@@ -440,1 +447,4 @@\n-        valArray = new MyInt[] { (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO };\n+        valArray = (MyInt[])VM.newNullRestrictedArray(MyInt.class, 3);\n+        valArray[0] = (MyInt) MyInt.ZERO;\n+        valArray[1] = (MyInt) MyInt.ZERO;\n+        valArray[2] = (MyInt) MyInt.ZERO;\n@@ -444,1 +454,4 @@\n-        valArray = new MyInt[] { (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO, (MyInt) MyInt.ZERO };\n+        valArray = (MyInt[])VM.newNullRestrictedArray(MyInt.class, 3);\n+        valArray[0] = (MyInt) MyInt.ZERO;\n+        valArray[1] = (MyInt) MyInt.ZERO;\n+        valArray[2] = (MyInt) MyInt.ZERO;\n@@ -458,1 +471,1 @@\n-        MyInt.ref[] myIntRefArray = new MyInt.ref[3];\n+        MyInt[] myIntRefArray = new MyInt[3];\n@@ -469,3 +482,7 @@\n-    static final primitive class MyPoint {\n-        final               MyInt x;\n-        final               MyInt y;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyPoint {\n+        @NullRestricted\n+        MyInt x;\n+        @NullRestricted\n+        MyInt y;\n@@ -491,1 +508,2 @@\n-        static final MyPoint.ref ORIGIN = create(0);\n+        @NullRestricted\n+        static final MyPoint ORIGIN = create(0);\n@@ -500,1 +518,1 @@\n-        MyPoint[] pts = new MyPoint[3];\n+        MyPoint[] pts = (MyPoint[])VM.newNullRestrictedArray(MyPoint.class, 3);\n@@ -504,1 +522,4 @@\n-        pts = new MyPoint[] { a, b, c };\n+        pts = (MyPoint[])VM.newNullRestrictedArray(MyPoint.class, 3);\n+        pts[0] = a;\n+        pts[1] = b;\n+        pts[2] = c;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":97,"deletions":76,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -31,2 +34,2 @@\n- * @compile -XDallowFlattenabilityModifiers -XDenablePrimitiveClasses InlineTypeCreation.java Point.java Long8Inline.java Person.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.InlineTypeCreation\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED InlineTypeCreation.java Point.java Long8Inline.java Person.java\n+ * @run main\/othervm -XX:+EnableValhalla --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.InlineTypeCreation\n@@ -75,1 +78,3 @@\n-    static final primitive class StaticSelf {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class StaticSelf {\n@@ -77,2 +82,2 @@\n-        static final StaticSelf.ref DEFAULT = new StaticSelf(0);\n-        final int f1;\n+        static final StaticSelf DEFAULT = new StaticSelf(0);\n+        int f1;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeCreation.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,6 @@\n-import jdk.test.whitebox.WhiteBox;\n+import com.sun.jdi.NativeMethodException;\n+\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -29,0 +34,2 @@\n+import jdk.test.whitebox.WhiteBox;\n+\n@@ -34,1 +41,1 @@\n- * @compile -XDenablePrimitiveClasses InlineTypeDensity.java\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED InlineTypeDensity.java\n@@ -36,1 +43,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -40,1 +48,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -44,1 +53,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -48,1 +58,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -80,1 +91,3 @@\n-    static final primitive class LocalDateValue implements LocalDate {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class LocalDateValue implements LocalDate {\n@@ -97,1 +110,3 @@\n-    static final primitive class LocalTimeValue implements LocalTime {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class LocalTimeValue implements LocalTime {\n@@ -117,3 +132,7 @@\n-    static final primitive class LocalDateTimeValue implements LocalDateTime {\n-        final LocalDateValue date;\n-        final LocalTimeValue time;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class LocalDateTimeValue implements LocalDateTime {\n+        @NullRestricted\n+        LocalDateValue date;\n+        @NullRestricted\n+        LocalTimeValue time;\n@@ -218,4 +237,12 @@\n-    static primitive class MyByte  { byte  v = 0; }\n-    static primitive class MyShort { short v = 0; }\n-    static primitive class MyInt   { int   v = 0; }\n-    static primitive class MyLong  { long  v = 0; }\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyByte  { byte  v = 0; }\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyShort { short v = 0; }\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyInt   { int   v = 0; }\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyLong  { long  v = 0; }\n@@ -235,1 +262,1 @@\n-            MyByte[] mba = new MyByte[testSize];\n+            MyByte[] mba = (MyByte[])VM.newNullRestrictedArray(MyByte.class, testSize);\n@@ -243,1 +270,1 @@\n-            MyShort[] msa = new MyShort[testSize];\n+            MyShort[] msa = (MyShort[])VM.newNullRestrictedArray(MyShort.class, testSize);\n@@ -251,1 +278,1 @@\n-            MyInt[] mia = new MyInt[testSize];\n+            MyInt[] mia = (MyInt[])VM.newNullRestrictedArray(MyInt.class, testSize);\n@@ -259,1 +286,1 @@\n-            MyLong[] mla = new MyLong[testSize];\n+            MyLong[] mla = (MyLong[])VM.newNullRestrictedArray(MyLong.class, testSize);\n@@ -272,5 +299,15 @@\n-    static primitive class bbValue { byte b = 0; byte b2 = 0;}\n-    static primitive class bsValue { byte b = 0; short s = 0;}\n-    static primitive class siValue { short s = 0; int i = 0;}\n-    static primitive class ssiValue { short s = 0; short s2 = 0; int i = 0;}\n-    static primitive class blValue { byte b = 0; long l = 0; }\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class bbValue { byte b = 0; byte b2 = 0;}\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class bsValue { byte b = 0; short s = 0;}\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class siValue { short s = 0; int i = 0;}\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ssiValue { short s = 0; short s2 = 0; int i = 0;}\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class blValue { byte b = 0; long l = 0; }\n@@ -281,5 +318,5 @@\n-        assertArraySameSize(new short[testSize], new bbValue[testSize], testSize);\n-        assertArraySameSize(new long[testSize], new siValue[testSize], testSize);\n-        assertArraySameSize(new long[testSize], new ssiValue[testSize], testSize);\n-        assertArraySameSize(new long[testSize*2], new blValue[testSize], testSize);\n-        assertArraySameSize(new int[testSize], new bsValue[testSize], testSize);\n+        assertArraySameSize(new short[testSize], VM.newNullRestrictedArray(bbValue.class, testSize), testSize);\n+        assertArraySameSize(new long[testSize], VM.newNullRestrictedArray(siValue.class, testSize), testSize);\n+        assertArraySameSize(new long[testSize], VM.newNullRestrictedArray(ssiValue.class, testSize), testSize);\n+        assertArraySameSize(new long[testSize*2], VM.newNullRestrictedArray(blValue.class, testSize), testSize);\n+        assertArraySameSize(new int[testSize], VM.newNullRestrictedArray(bsValue.class, testSize), testSize);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeDensity.java","additions":66,"deletions":29,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -31,2 +32,2 @@\n- * @compile -XDenablePrimitiveClasses Point.java InlineTypeGetField.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.InlineTypeGetField\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED  Point.java InlineTypeGetField.java\n+ * @run main\/othervm -XX:+EnableValhalla --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.InlineTypeGetField\n@@ -36,0 +37,1 @@\n+    @NullRestricted\n@@ -37,0 +39,1 @@\n+    @NullRestricted\n@@ -38,0 +41,1 @@\n+    @NullRestricted\n@@ -39,0 +43,1 @@\n+    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeGetField.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.ByteBuffer;\n@@ -38,0 +39,1 @@\n+\n@@ -41,0 +43,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -53,2 +58,3 @@\n- * @compile -XDenablePrimitiveClasses TestValue1.java TestValue2.java TestValue3.java TestValue4.java InlineTypesTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED InlineTypesTest.java\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -59,1 +65,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *                   -XX:+EnableValhalla\n@@ -66,0 +73,196 @@\n+\n+ final class ContainerValue1 {\n+    static TestValue1 staticInlineField;\n+    @NullRestricted\n+    TestValue1 nonStaticInlineField;\n+    TestValue1[] inlineArray;\n+}\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class TestValue1 {\n+\n+    static TestValue1 staticValue = getInstance();\n+\n+    final int i;\n+    final String name;\n+\n+    public TestValue1() {\n+        i = (int)System.nanoTime();\n+        name = Integer.valueOf(i).toString();\n+    }\n+\n+    public TestValue1(int i) {\n+        this.i = i;\n+        name = Integer.valueOf(i).toString();\n+    }\n+\n+    public static TestValue1 getInstance() {\n+        return new TestValue1();\n+    }\n+\n+    public static TestValue1 getNonBufferedInstance() {\n+        return (TestValue1) staticValue;\n+    }\n+\n+    public boolean verify() {\n+        if (name == null) return i == 0;\n+        return Integer.valueOf(i).toString().compareTo(name) == 0;\n+    }\n+}\n+\n+final class ContainerValue2 {\n+    static TestValue2 staticInlineField;\n+    @NullRestricted\n+    TestValue2 nonStaticInlineField;\n+    TestValue2[] valueArray;\n+}\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class TestValue2 {\n+    static TestValue2 staticValue = getInstance();\n+\n+    final long l;\n+    final double d;\n+    final String s;\n+\n+    public TestValue2() {\n+        l = System.nanoTime();\n+        s = Long.valueOf(l).toString();\n+        d = Double.parseDouble(s);\n+    }\n+\n+    public TestValue2(long l) {\n+        this.l = l;\n+        s = Long.valueOf(l).toString();\n+        d = Double.parseDouble(s);\n+    }\n+\n+    public static TestValue2 getInstance() {\n+        return new TestValue2();\n+    }\n+\n+    public static TestValue2 getNonBufferedInstance() {\n+        return (TestValue2) staticValue;\n+    }\n+\n+    public boolean verify() {\n+        if (s == null) {\n+            return d == 0 && l == 0;\n+        }\n+        return Long.valueOf(l).toString().compareTo(s) == 0\n+                && Double.parseDouble(s) == d;\n+    }\n+}\n+\n+final class ContainerValue3 {\n+    static TestValue3 staticInlineField;\n+    @NullRestricted\n+    TestValue3 nonStaticInlineField;\n+    TestValue3[] valueArray;\n+}\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class TestValue3 {\n+\n+    static TestValue3 staticValue = getInstance();\n+\n+    final byte b;\n+\n+    public TestValue3() {\n+        b = 123;\n+    }\n+\n+    public TestValue3(byte b) {\n+        this.b = b;\n+    }\n+\n+    public static TestValue3 getInstance() {\n+        return new TestValue3();\n+    }\n+\n+    public static TestValue3 getNonBufferedInstance() {\n+        return (TestValue3) staticValue;\n+    }\n+\n+    public boolean verify() {\n+        return b == 0 || b == 123;\n+    }\n+}\n+\n+final class ContainerValue4 {\n+    static TestValue4 staticInlineField;\n+    @NullRestricted\n+    TestValue4 nonStaticInlineField;\n+    TestValue4[] valueArray;\n+}\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class TestValue4 {\n+\n+    static TestValue4 staticValue = getInstance();\n+\n+    final byte b1;\n+    final byte b2;\n+    final byte b3;\n+    final byte b4;\n+    final short s1;\n+    final short s2;\n+    final int i;\n+    final long l;\n+    final String val;\n+\n+    public TestValue4() {\n+        this((int) System.nanoTime());\n+    }\n+\n+    public TestValue4(int i) {\n+        this.i = i;\n+        val = Integer.valueOf(i).toString();\n+        ByteBuffer bf = ByteBuffer.allocate(8);\n+        bf.putInt(0, i);\n+        bf.putInt(4, i);\n+        l = bf.getLong(0);\n+        s1 = bf.getShort(2);\n+        s2 = bf.getShort(0);\n+        b1 = bf.get(3);\n+        b2 = bf.get(2);\n+        b3 = bf.get(1);\n+        b4 = bf.get(0);\n+    }\n+\n+    public static TestValue4 getInstance() {\n+        return new TestValue4();\n+    }\n+\n+    public static TestValue4 getNonBufferedInstance() {\n+        return (TestValue4) staticValue;\n+    }\n+\n+    public boolean verify() {\n+        if (val == null) {\n+            return i == 0 && l == 0 && b1 == 0 && b2 == 0 && b3 == 0 && b4 == 0\n+                    && s1 == 0 && s2 == 0;\n+        }\n+        ByteBuffer bf = ByteBuffer.allocate(8);\n+        bf.putInt(0, i);\n+        bf.putInt(4, i);\n+        long nl =  bf.getLong(0);\n+        bf.clear();\n+        bf.putShort(0, s2);\n+        bf.putShort(2, s1);\n+        int from_s = bf.getInt(0);\n+        bf.clear();\n+        bf.put(0, b4);\n+        bf.put(1, b3);\n+        bf.put(2, b2);\n+        bf.put(3, b1);\n+        int from_b = bf.getInt(0);\n+        return l == nl && Integer.valueOf(i).toString().compareTo(val) == 0\n+                && from_s == i && from_b == i;\n+    }\n+}\n+\n@@ -98,1 +301,1 @@\n-        String sig = \"()Q\" + inlineClass.getName() + \";\";\n+        String sig = \"()L\" + inlineClass.getName() + \";\";\n@@ -140,1 +343,1 @@\n-        String sig = \"()Q\" + inlineClass.getName() + \";\";\n+        String sig = \"()L\" + inlineClass.getName() + \";\";\n@@ -142,1 +345,0 @@\n-        final String fieldQSignature = \"Q\" + inlineClass.getName().replace('.', '\/') + \";\";\n@@ -164,1 +366,1 @@\n-                    .putfield(containerClass, \"nonStaticInlineField\", fieldQSignature)\n+                    .putfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n@@ -167,1 +369,1 @@\n-                    .getfield(containerClass, \"nonStaticInlineField\", fieldQSignature)\n+                    .getfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n@@ -173,1 +375,1 @@\n-                    .putfield(containerClass, \"nonStaticInlineField\", fieldQSignature)\n+                    .putfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n@@ -176,1 +378,1 @@\n-                    .getfield(containerClass, \"nonStaticInlineField\", fieldQSignature)\n+                    .getfield(containerClass, \"nonStaticInlineField\", fieldLSignature)\n@@ -212,1 +414,1 @@\n-        String sig = \"()Q\" + inlineClass.getName() + \";\";\n+        String sig = \"()L\" + inlineClass.getName() + \";\";\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":213,"deletions":11,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package runtime.valhalla.inlinetypes;\n-\n-public primitive class IntValue {\n-    int val;\n-    public IntValue()       { this(0); }\n-    public IntValue(int v)  { val = v; }\n-    public int getInt()     { return val; }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/IntValue.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -25,1 +25,6 @@\n-public primitive class JumboInline {\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public value class JumboInline {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/JumboInline.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -28,1 +30,3 @@\n-public final primitive class Long8Inline {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public final value class Long8Inline {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Long8Inline.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package runtime.valhalla.inlinetypes;\n-\n-public class NewInstanceFromConstructor {\n-\n-    int value;\n-    static int consCalls = 0;\n-\n-    public NewInstanceFromConstructor() {\n-        this(0);\n-    }\n-\n-    public NewInstanceFromConstructor(int v) {\n-        value = v;\n-        consCalls++;\n-    }\n-\n-    public NewInstanceFromConstructor(IntValue v) {\n-        this(v.getInt());\n-    }\n-\n-    public NewInstanceFromConstructor(IntValue v1,\n-                                      IntValue v2) {\n-        this(v1.getInt() + v2.getInt());\n-    }\n-\n-    public NewInstanceFromConstructor(IntValue v1,\n-                                      String s) {\n-        this(v1);\n-        throw new RuntimeException(s);\n-    }\n-\n-    public int getValue() { return value; }\n-\n-    public static int getConsCalls() { return consCalls; }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NewInstanceFromConstructor.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -26,1 +26,6 @@\n-public final primitive class Person {\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public value class Person {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Person.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,6 @@\n-public primitive final class Point {\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+public value class Point {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Point.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -32,2 +35,2 @@\n- * @compile -XDenablePrimitiveClasses Point.java JumboInline.java QuickeningTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.QuickeningTest\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED QuickeningTest.java\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED -XX:+EnableValhalla runtime.valhalla.inlinetypes.QuickeningTest\n@@ -38,0 +41,60 @@\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Point {\n+        final int x;\n+        final int y;\n+\n+        public Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class JumboInline {\n+        final long l0;\n+        final long l1;\n+        final long l2;\n+        final long l3;\n+        final long l4;\n+        final long l5;\n+        final long l6;\n+        final long l7;\n+        final long l8;\n+        final long l9;\n+        final long l10;\n+        final long l11;\n+        final long l12;\n+        final long l13;\n+        final long l14;\n+        final long l15;\n+        final long l16;\n+        final long l17;\n+        final long l18;\n+        final long l19;\n+\n+        public JumboInline(long l0Val, long l1Val) {\n+            l0 = l0Val;\n+            l1 = l1Val;\n+            l2 = l0+l1;\n+            l3 = l1+l2;\n+            l4 = l2+l3;\n+            l5 = l3+l4;\n+            l6 = l4+l5;\n+            l7 = l5+l6;\n+            l8 = l6+l7;\n+            l9 = l7+l8;\n+            l10 = l8+l9;\n+            l11 = l9+l10;\n+            l12 = l10+l11;\n+            l13 = l11+l12;\n+            l14 = l12+l13;\n+            l15 = l13+l14;\n+            l16 = l14+l15;\n+            l17 = l15+l16;\n+            l18 = l16+l17;\n+            l19 = l17+l18;\n+        }\n+    }\n+\n@@ -39,1 +102,2 @@\n-    Point.ref nfp;       \/* Not flattenable inline field *\/\n+    Point nfp;       \/* Not flattenable inline field *\/\n+    @NullRestricted\n@@ -41,0 +105,1 @@\n+    @NullRestricted\n@@ -50,1 +115,2 @@\n-        Point.ref nfp2;      \/* Not flattenable inline field *\/\n+        Point nfp2;      \/* Not flattenable inline field *\/\n+        @NullRestricted\n@@ -52,0 +118,1 @@\n+        @NullRestricted\n@@ -59,2 +126,5 @@\n-    static final primitive class Value {\n-        final Point.ref nfp;       \/* Not flattenable inline field *\/\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Value {\n+        final Point nfp;       \/* Not flattenable inline field *\/\n+        @NullRestricted\n@@ -62,0 +132,1 @@\n+        @NullRestricted\n@@ -65,3 +136,3 @@\n-            nfp = Point.default;\n-            fp = Point.default;\n-            fj = JumboInline.default;\n+            nfp = null;\n+            fp = new Point(0, 0);\n+            fj = new JumboInline(0, 0);\n@@ -91,1 +162,1 @@\n-        Value v = Value.default;\n+        Value v = new Value();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/QuickeningTest.java","additions":81,"deletions":10,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n@@ -30,2 +34,2 @@\n- * @compile -XDenablePrimitiveClasses Test8186715.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.Test8186715\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Test8186715.java\n+ * @run main\/othervm -XX:+EnableValhalla --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.Test8186715\n@@ -45,1 +49,3 @@\n-primitive final class MyValueType {\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValueType {\n@@ -55,1 +61,2 @@\n-        return MyValueType.default;\n+        MyValueType[] array = (MyValueType[])VM.newNullRestrictedArray(MyValueType.class, 1);\n+        return array[0];\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Test8186715.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestBytecodeLib.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile -XDenablePrimitiveClasses TestFieldNullability.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xmx128m -XX:InlineFieldMaxFlatSize=32\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED  TestFieldNullability.java\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED -XX:+EnableValhalla  -Xmx128m -XX:InlineFieldMaxFlatSize=32\n@@ -36,0 +36,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -38,0 +41,1 @@\n+\n@@ -39,1 +43,3 @@\n-    static primitive class MyValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue {\n@@ -47,1 +53,3 @@\n-    static primitive class MyBigValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyBigValue {\n@@ -58,1 +66,2 @@\n-        MyValue.ref nullableField;\n+        MyValue nullableField;\n+        @NullRestricted\n@@ -60,1 +69,2 @@\n-        MyValue.ref nullField;\n+        MyValue nullField;\n+        @NullRestricted\n@@ -62,1 +72,6 @@\n-        MyBigValue.ref nullBigField;\n+        MyBigValue nullBigField;\n+    }\n+\n+    static class Wrapper {\n+        @NullRestricted\n+        TestPrimitiveClass c;\n@@ -66,1 +81,1 @@\n-        TestPrimitiveClass that = TestPrimitiveClass.default;\n+        TestPrimitiveClass that = new Wrapper().c;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullability.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n-public final primitive value class runtime\/valhalla\/inlinetypes\/TestPrimitiveClass\n+@+\"jdk\/internal\/vm\/annotation\/ImplicitlyConstructible\" { }\n+@+\"jdk\/internal\/vm\/annotation\/LooselyConsistentValue\" { }\n+public final value class runtime\/valhalla\/inlinetypes\/TestPrimitiveClass\n@@ -29,1 +31,2 @@\n-    final Field nullfreeField:   \"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ flattened\n+    @+\"jdk\/internal\/vm\/annotation\/NullRestricted\" { }\n+    final Field nullfreeField:   \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ flattened\n@@ -31,1 +34,2 @@\n-    final Field nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ not flattened\n+    @+\"jdk\/internal\/vm\/annotation\/NullRestricted\" { }\n+    final Field nullfreeBigField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ not flattened\n@@ -43,1 +47,1 @@\n-    public Method withNullfreeField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+    public Method withNullfreeField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n@@ -48,1 +52,1 @@\n-        withfield nullfreeField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n+        withfield nullfreeField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n@@ -52,1 +56,1 @@\n-    public Method withNullfreeBigField:\"(Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n+    public Method withNullfreeBigField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n@@ -57,1 +61,1 @@\n-        withfield nullfreeBigField:\"Qruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\";\n+        withfield nullfreeBigField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\";\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullabilityClasses.jasm","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -32,2 +33,2 @@\n- * @compile -XDallowFlattenabilityModifiers -XDenablePrimitiveClasses Point.java TestInheritedInlineTypeFields.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.TestInheritedInlineTypeFields\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED Point.java TestInheritedInlineTypeFields.java\n+ * @run main\/othervm -XX:+EnableValhalla --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.TestInheritedInlineTypeFields\n@@ -37,0 +38,1 @@\n+    @NullRestricted\n@@ -53,0 +55,1 @@\n+    @NullRestricted\n@@ -61,0 +64,1 @@\n+    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestInheritedInlineTypeFields.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -34,2 +36,2 @@\n- * @compile -XDenablePrimitiveClasses TestJNIIsSameObject.java\n- * @run main\/othervm\/native -XX:+EnableValhalla -XX:+EnablePrimitiveClasses TestJNIIsSameObject\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED TestJNIIsSameObject.java\n+ * @run main\/othervm\/native -XX:+EnableValhalla --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED TestJNIIsSameObject\n@@ -38,1 +40,0 @@\n-\/** test was failing before adding the -XDenablePrimitiveClasses option, but the option should stay as it declares a primitive class  *\/\n@@ -40,1 +41,3 @@\n-  static primitive class Value {\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestJNIIsSameObject.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package runtime.valhalla.inlinetypes;\n-\n-final class ContainerValue1 {\n-    static TestValue1.ref staticInlineField;\n-    TestValue1 nonStaticInlineField;\n-    TestValue1[] inlineArray;\n-}\n-\n-public primitive class TestValue1 {\n-\n-    static TestValue1.ref staticValue = getInstance();\n-\n-    final int i;\n-    final String name;\n-\n-    public TestValue1() {\n-        i = (int)System.nanoTime();\n-        name = Integer.valueOf(i).toString();\n-    }\n-\n-    public TestValue1(int i) {\n-        this.i = i;\n-        name = Integer.valueOf(i).toString();\n-    }\n-\n-    public static TestValue1 getInstance() {\n-        return new TestValue1();\n-    }\n-\n-    public static TestValue1 getNonBufferedInstance() {\n-        return (TestValue1) staticValue;\n-    }\n-\n-    public boolean verify() {\n-        if (name == null) return i == 0;\n-        return Integer.valueOf(i).toString().compareTo(name) == 0;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestValue1.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package runtime.valhalla.inlinetypes;\n-\n-final class ContainerValue2 {\n-    static TestValue2.ref staticInlineField;\n-    TestValue2 nonStaticInlineField;\n-    TestValue2[] valueArray;\n-}\n-\n-public primitive class TestValue2 {\n-    static TestValue2.ref staticValue = getInstance();\n-\n-    final long l;\n-    final double d;\n-    final String s;\n-\n-    public TestValue2() {\n-        l = System.nanoTime();\n-        s = Long.valueOf(l).toString();\n-        d = Double.parseDouble(s);\n-    }\n-\n-    public TestValue2(long l) {\n-        this.l = l;\n-        s = Long.valueOf(l).toString();\n-        d = Double.parseDouble(s);\n-    }\n-\n-    public static TestValue2 getInstance() {\n-        return new TestValue2();\n-    }\n-\n-    public static TestValue2 getNonBufferedInstance() {\n-        return (TestValue2) staticValue;\n-    }\n-\n-    public boolean verify() {\n-        if (s == null) {\n-            return d == 0 && l == 0;\n-        }\n-        return Long.valueOf(l).toString().compareTo(s) == 0\n-                && Double.parseDouble(s) == d;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestValue2.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package runtime.valhalla.inlinetypes;\n-\n-final class ContainerValue3 {\n-    static TestValue3.ref staticInlineField;\n-    TestValue3 nonStaticInlineField;\n-    TestValue3[] valueArray;\n-}\n-\n-public primitive class TestValue3 {\n-\n-    static TestValue3.ref staticValue = getInstance();\n-\n-    final byte b;\n-\n-    public TestValue3() {\n-        b = 123;\n-    }\n-\n-    public TestValue3(byte b) {\n-        this.b = b;\n-    }\n-\n-    public static TestValue3 getInstance() {\n-        return new TestValue3();\n-    }\n-\n-    public static TestValue3 getNonBufferedInstance() {\n-        return (TestValue3) staticValue;\n-    }\n-\n-    public boolean verify() {\n-        return b == 0 || b == 123;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestValue3.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package runtime.valhalla.inlinetypes;\n-\n-import java.nio.ByteBuffer;\n-\n-final class ContainerValue4 {\n-    static TestValue4.ref staticInlineField;\n-    TestValue4 nonStaticInlineField;\n-    TestValue4[] valueArray;\n-}\n-\n-public primitive class TestValue4 {\n-\n-    static TestValue4.ref staticValue = getInstance();\n-\n-    final byte b1;\n-    final byte b2;\n-    final byte b3;\n-    final byte b4;\n-    final short s1;\n-    final short s2;\n-    final int i;\n-    final long l;\n-    final String val;\n-\n-    public TestValue4() {\n-        this((int) System.nanoTime());\n-    }\n-\n-    public TestValue4(int i) {\n-        this.i = i;\n-        val = Integer.valueOf(i).toString();\n-        ByteBuffer bf = ByteBuffer.allocate(8);\n-        bf.putInt(0, i);\n-        bf.putInt(4, i);\n-        l = bf.getLong(0);\n-        s1 = bf.getShort(2);\n-        s2 = bf.getShort(0);\n-        b1 = bf.get(3);\n-        b2 = bf.get(2);\n-        b3 = bf.get(1);\n-        b4 = bf.get(0);\n-    }\n-\n-    public static TestValue4 getInstance() {\n-        return new TestValue4();\n-    }\n-\n-    public static TestValue4 getNonBufferedInstance() {\n-        return (TestValue4) staticValue;\n-    }\n-\n-    public boolean verify() {\n-        if (val == null) {\n-            return i == 0 && l == 0 && b1 == 0 && b2 == 0 && b3 == 0 && b4 == 0\n-                    && s1 == 0 && s2 == 0;\n-        }\n-        ByteBuffer bf = ByteBuffer.allocate(8);\n-        bf.putInt(0, i);\n-        bf.putInt(4, i);\n-        long nl =  bf.getLong(0);\n-        bf.clear();\n-        bf.putShort(0, s2);\n-        bf.putShort(2, s1);\n-        int from_s = bf.getInt(0);\n-        bf.clear();\n-        bf.put(0, b4);\n-        bf.put(1, b3);\n-        bf.put(2, b2);\n-        bf.put(3, b1);\n-        int from_b = bf.getInt(0);\n-        return l == nl && Integer.valueOf(i).toString().compareTo(val) == 0\n-                && from_s == i && from_b == i;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestValue4.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -31,2 +32,2 @@\n- * @compile -XDallowFlattenabilityModifiers -XDenablePrimitiveClasses Point.java JumboInline.java UninitializedInlineFieldsTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.inlinetypes.UninitializedInlineFieldsTest\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED Point.java JumboInline.java UninitializedInlineFieldsTest.java\n+ * @run main\/othervm -XX:+EnableValhalla --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.inlinetypes.UninitializedInlineFieldsTest\n@@ -35,1 +36,2 @@\n-    static Point.ref nonFlattenableStaticPoint;\n+    static Point nonFlattenableStaticPoint;\n+    @NullRestricted\n@@ -38,0 +40,1 @@\n+    @NullRestricted\n@@ -40,1 +43,2 @@\n-    static JumboInline.ref sj1;\n+    static JumboInline sj1;\n+    @NullRestricted\n@@ -43,1 +47,2 @@\n-    JumboInline.ref j1;\n+    JumboInline j1;\n+    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UninitializedInlineFieldsTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+\n+\n@@ -31,2 +33,2 @@\n- * @compile -XDenablePrimitiveClasses Point.java UnsafeTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 runtime.valhalla.inlinetypes.UnsafeTest\n+ * @compile  --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED Point.java UnsafeTest.java\n+ * @run main\/othervm -XX:+EnableValhalla  -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.UnsafeTest\n@@ -36,0 +38,4 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -44,1 +50,4 @@\n-    static primitive class Value1 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Value1 {\n+        @NullRestricted\n@@ -53,1 +62,3 @@\n-    static primitive class Value2 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Value2 {\n@@ -55,0 +66,1 @@\n+        @NullRestricted\n@@ -63,1 +75,3 @@\n-    static primitive class Value3 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Value3 {\n@@ -65,0 +79,1 @@\n+        @NullRestricted\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/VDefaultTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,5 @@\n-import jdk.internal.value.PrimitiveClass;\n+\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -36,2 +40,2 @@\n- * @compile -XDenablePrimitiveClasses VarArgsArray.java NewInstanceFromConstructor.java IntValue.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.VarArgsArray\n+ * @compile --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED VarArgsArray.java\n+ * @run main\/othervm -XX:+EnableValhalla  --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.VarArgsArray\n@@ -39,0 +43,45 @@\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class IntValue {\n+    int val;\n+    public IntValue()       { this(0); }\n+    public IntValue(int v)  { val = v; }\n+    public int getInt()     { return val; }\n+}\n+\n+\n+class NewInstanceFromConstructor {\n+\n+    int value;\n+    static int consCalls = 0;\n+\n+    public NewInstanceFromConstructor() {\n+        this(0);\n+    }\n+\n+    public NewInstanceFromConstructor(int v) {\n+        value = v;\n+        consCalls++;\n+    }\n+\n+    public NewInstanceFromConstructor(IntValue v) {\n+        this(v.getInt());\n+    }\n+\n+    public NewInstanceFromConstructor(IntValue v1,\n+                                      IntValue v2) {\n+        this(v1.getInt() + v2.getInt());\n+    }\n+\n+    public NewInstanceFromConstructor(IntValue v1,\n+                                      String s) {\n+        this(v1);\n+        throw new RuntimeException(s);\n+    }\n+\n+    public int getValue() { return value; }\n+\n+    public static int getConsCalls() { return consCalls; }\n+}\n+\n@@ -61,3 +110,3 @@\n-        Method methodARef = getClass().getDeclaredMethod(\"methodA\", PrimitiveClass.asValueType(MyInt.class));\n-        Method methodBRef = getClass().getDeclaredMethod(\"methodB\", PrimitiveClass.asValueType(MyInt.class), PrimitiveClass.asValueType(MyInt.class));\n-        Method methodCRef = getClass().getDeclaredMethod(\"methodC\", PrimitiveClass.asValueType(MyInt.class), String.class);\n+        Method methodARef = getClass().getDeclaredMethod(\"methodA\", MyInt.class);\n+        Method methodBRef = getClass().getDeclaredMethod(\"methodB\", MyInt.class, MyInt.class);\n+        Method methodCRef = getClass().getDeclaredMethod(\"methodC\", MyInt.class, String.class);\n@@ -101,1 +150,1 @@\n-        Class pt = PrimitiveClass.asValueType(IntValue.class);\n+        Class pt = IntValue.class;\n@@ -161,1 +210,3 @@\n-    primitive class MyInt {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    value class MyInt {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/VarArgsArray.java","additions":59,"deletions":8,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}