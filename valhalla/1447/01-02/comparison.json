{"files":[{"patch":"@@ -2854,4 +2854,0 @@\n-    igvn.optimize();\n-    if (failing()) {\n-      return;\n-    }\n@@ -2879,4 +2875,0 @@\n-      igvn.optimize();\n-      if (failing()) {\n-        return;\n-      }\n@@ -2907,1 +2899,0 @@\n-\n@@ -2909,4 +2900,0 @@\n-        igvn.optimize();\n-        if (failing()) {\n-          return;\n-        }\n@@ -3019,3 +3006,0 @@\n-    igvn.set_delay_transform(false);\n-    igvn.optimize();\n-    igvn.set_delay_transform(true);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -896,8 +896,1 @@\n-\n-      \/\/ Replace the larval object with the non-larval one in all call frames. This avoids the oop\n-      \/\/ alive until the outermost constructor exits.\n-      JVMState* current = map()->jvms();\n-      while (current != nullptr) {\n-        current->map()->replace_edge(receiver, non_larval);\n-        current = current->caller();\n-      }\n+      map()->replace_edge(receiver, non_larval);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2899,1 +2899,1 @@\n-  if (C->macro_count() == 0)\n+  if (C->macro_count() == 0) {\n@@ -2901,0 +2901,1 @@\n+  }\n@@ -2903,7 +2904,5 @@\n-  \/\/ Before elimination may re-mark (change to Nested or NonEscObj)\n-  \/\/ all associated (same box and obj) lock and unlock nodes.\n-  int cnt = C->macro_count();\n-  for (int i=0; i < cnt; i++) {\n-    Node *n = C->macro_node(i);\n-    if (n->is_AbstractLock()) { \/\/ Lock and Unlock nodes\n-      mark_eliminated_locking_nodes(n->as_AbstractLock());\n+  int iteration = 0;\n+  while (C->macro_count() > 0) {\n+    if (iteration++ > 100) {\n+      assert(false, \"Too slow convergence of macro elimination\");\n+      break;\n@@ -2911,10 +2910,0 @@\n-  }\n-  \/\/ Re-marking may break consistency of Coarsened locks.\n-  if (!C->coarsened_locks_consistent()) {\n-    return; \/\/ recompile without Coarsened locks if broken\n-  } else {\n-    \/\/ After coarsened locks are eliminated locking regions\n-    \/\/ become unbalanced. We should not execute any more\n-    \/\/ locks elimination optimizations on them.\n-    C->mark_unbalanced_boxes();\n-  }\n@@ -2922,15 +2911,7 @@\n-  \/\/ First, attempt to eliminate locks\n-  bool progress = true;\n-  while (progress) {\n-    progress = false;\n-    for (int i = C->macro_count(); i > 0; i = MIN2(i - 1, C->macro_count())) { \/\/ more than 1 element can be eliminated at once\n-      Node* n = C->macro_node(i - 1);\n-      bool success = false;\n-      DEBUG_ONLY(int old_macro_count = C->macro_count();)\n-      if (n->is_AbstractLock()) {\n-        success = eliminate_locking_node(n->as_AbstractLock());\n-#ifndef PRODUCT\n-        if (success && PrintOptoStatistics) {\n-          Atomic::inc(&PhaseMacroExpand::_monitor_objects_removed_counter);\n-        }\n-#endif\n+    \/\/ Before elimination may re-mark (change to Nested or NonEscObj)\n+    \/\/ all associated (same box and obj) lock and unlock nodes.\n+    int cnt = C->macro_count();\n+    for (int i=0; i < cnt; i++) {\n+      Node *n = C->macro_node(i);\n+      if (n->is_AbstractLock()) { \/\/ Lock and Unlock nodes\n+        mark_eliminated_locking_nodes(n->as_AbstractLock());\n@@ -2938,2 +2919,0 @@\n-      assert(success == (C->macro_count() < old_macro_count), \"elimination reduces macro count\");\n-      progress = progress || success;\n@@ -2941,6 +2920,11 @@\n-  }\n-  \/\/ Next, attempt to eliminate allocations\n-  _has_locks = false;\n-  progress = true;\n-  while (progress) {\n-    progress = false;\n+    \/\/ Re-marking may break consistency of Coarsened locks.\n+    if (!C->coarsened_locks_consistent()) {\n+      return; \/\/ recompile without Coarsened locks if broken\n+    } else {\n+      \/\/ After coarsened locks are eliminated locking regions\n+      \/\/ become unbalanced. We should not execute any more\n+      \/\/ locks elimination optimizations on them.\n+      C->mark_unbalanced_boxes();\n+    }\n+\n+    bool progress = false;\n@@ -2970,2 +2954,6 @@\n-        assert(!n->as_AbstractLock()->is_eliminated(), \"sanity\");\n-        _has_locks = true;\n+        success = eliminate_locking_node(n->as_AbstractLock());\n+#ifndef PRODUCT\n+        if (success && PrintOptoStatistics) {\n+          Atomic::inc(&PhaseMacroExpand::_monitor_objects_removed_counter);\n+        }\n+#endif\n@@ -2998,0 +2986,4 @@\n+    if (!progress) {\n+      break;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":35,"deletions":43,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,3 +86,0 @@\n-  \/\/ Additional data collected during macro expansion\n-  bool _has_locks;\n-\n@@ -217,1 +214,1 @@\n-  PhaseMacroExpand(PhaseIterGVN &igvn) : Phase(Macro_Expand), _igvn(igvn), _has_locks(false) {\n+  PhaseMacroExpand(PhaseIterGVN &igvn) : Phase(Macro_Expand), _igvn(igvn) {\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -146,26 +146,0 @@\n-\/\/ If call is a constructor call on receiver, returns the class which declares the target method,\n-\/\/ else returns nullptr. This information can then be used to deduce if call modifies a field of\n-\/\/ receiver. Specifically, if the field is declared in a class that is a subclass of the one\n-\/\/ declaring the constructor, then the field is set inside the constructor, else the field must be\n-\/\/ set before the constructor invocation. E.g. A field Super.x will be set during the execution of\n-\/\/ Sub::<init>, while a field Sub.y must be set before Super::<init> is invoked.\n-static ciInstanceKlass* find_constructor_call_method_holder(Node* call, Node* receiver) {\n-  if (!call->is_CallJava()) {\n-    return nullptr;\n-  }\n-\n-  ciMethod* target = call->as_CallJava()->method();\n-  if (target == nullptr || !target->is_object_constructor()) {\n-    return nullptr;\n-  }\n-\n-  assert(call->req() > TypeFunc::Parms, \"constructor must have at least 1 argument\");\n-  Node* parm = call->in(TypeFunc::Parms)->uncast();\n-  receiver = receiver->uncast();\n-  if (parm == receiver || (parm->is_InlineType() && parm->as_InlineType()->get_oop()->uncast() == receiver)) {\n-    return target->holder();\n-  }\n-\n-  return nullptr;\n-}\n-\n@@ -181,36 +155,0 @@\n-\/\/ Try to find a better memory input for a load from a strict final field of an object that is\n-\/\/ allocated in the current compilation unit, or is the first parameter when we are in a\n-\/\/ constructor\n-static Node* optimize_strict_final_load_memory_from_local_object(ciField* field, ProjNode* base_uncasted) {\n-  if (!EnableValhalla) {\n-    \/\/ In this method we depends on the fact that strict fields are set before the invocation of\n-    \/\/ super(), I'm not sure if this is true without Valhalla\n-    return nullptr;\n-  }\n-\n-  \/\/ The node that can be passed into a constructor\n-  Node* base = base_uncasted;\n-  if (!base_uncasted->is_Parm()) {\n-    assert(base_uncasted->_con == AllocateNode::RawAddress && base_uncasted->in(0)->is_Allocate(), \"must be the RawAddress of an AllocateNode\");\n-    base = base_uncasted->in(0)->as_Allocate()->result_cast();\n-    assert(base != nullptr && base->in(1) == base_uncasted, \"must find a valid base\");\n-  }\n-\n-  \/\/ Try to see if there is a constructor call on the base\n-  for (DUIterator_Fast imax, i = base->fast_outs(imax); i < imax; i++) {\n-    Node* out = base->fast_out(i);\n-    ciInstanceKlass* target_holder = find_constructor_call_method_holder(out, base);\n-    if (target_holder == nullptr) {\n-      continue;\n-    } else if (target_holder->is_subclass_of(field->holder())) {\n-      return find_call_fallthrough_mem_output(out->as_CallJava());\n-    } else {\n-      Node* res = out->in(TypeFunc::Memory);\n-      assert(res != nullptr, \"should have a memory input\");\n-      return res;\n-    }\n-  }\n-\n-  return nullptr;\n-}\n-\n@@ -229,1 +167,0 @@\n-      \/\/ The result of an AllocateNode, try to find the constructor call\n@@ -231,1 +168,1 @@\n-      return optimize_strict_final_load_memory_from_local_object(field, base_uncasted->as_Proj());\n+      return nullptr;\n@@ -240,1 +177,1 @@\n-        return optimize_strict_final_load_memory_from_local_object(field, base_uncasted->as_Proj());\n+        return nullptr;\n@@ -251,8 +188,24 @@\n-\/\/ Whether a call can modify a strict final field of base_local, given that base_local is allocated\n-\/\/ inside the current compilation unit, or is the first parameter when the compilation root is a\n-\/\/ constructor. This is equivalent to asking whether base_local is the receiver of the constructor\n-\/\/ invocation call and the class declaring the target method is a subclass of the class declaring\n-\/\/ field.\n-static bool call_can_modify_local_object(ciField* field, CallNode* call, Node* base_local) {\n-  ciInstanceKlass* target_holder = find_constructor_call_method_holder(call, base_local);\n-  return target_holder != nullptr && target_holder->is_subclass_of(field->holder());\n+\/\/ Whether a call can modify a strict final field, given that the object is allocated inside the\n+\/\/ current compilation unit, or is the first parameter when the compilation root is a constructor.\n+\/\/ This is equivalent to asking whether 'call' is a constructor invocation and the class declaring\n+\/\/ the target method is a subclass of the class declaring 'field'.\n+static bool call_can_modify_local_object(ciField* field, CallNode* call) {\n+  if (!call->is_CallJava()) {\n+    return false;\n+  }\n+\n+  ciMethod* target = call->as_CallJava()->method();\n+  if (target == nullptr || !target->is_object_constructor()) {\n+    return false;\n+  }\n+\n+  \/\/ If 'field' is declared in a class that is a subclass of the one declaring the constructor,\n+  \/\/ then the field is set inside the constructor, else the field must be set before the\n+  \/\/ constructor invocation. E.g. A field Super.x will be set during the execution of Sub::<init>,\n+  \/\/ while a field Sub.y must be set before Super::<init> is invoked.\n+  \/\/ We can try to be more heroic and decide if the receiver of the constructor invocation is the\n+  \/\/ object from which we are loading from. This, however, may be problematic as deciding if 2\n+  \/\/ nodes are definitely different may not be trivial, especially if the graph is not canonical.\n+  \/\/ As a result, it is made more conservative for now.\n+  assert(call->req() > TypeFunc::Parms, \"constructor must have at least 1 argument\");\n+  return target->holder()->is_subclass_of(field->holder());\n@@ -323,1 +276,1 @@\n-        } else if (is_strict_final_load && base_local != nullptr && !call_can_modify_local_object(field, call, base_local)) {\n+        } else if (is_strict_final_load && base_local != nullptr && !call_can_modify_local_object(field, call)) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":27,"deletions":74,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1660,1 +1660,1 @@\n-    private static final MethodHandle MULTIPLE_OCCURRENCES_IN_JVMS_RETURN_STACK = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+    private static final MethodHandle MULTIPLE_OCCURRENCES_IN_JVMS = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n@@ -1663,28 +1663,0 @@\n-            CODE -> {\n-                Label loopHead = CODE.newLabel();\n-                Label loopExit = CODE.newLabel();\n-                CODE.\n-                        new_(MyValue1.class.describeConstable().get()).\n-                        dup().\n-                        iconst_0().\n-                        labelBinding(loopHead).\n-                        dup().\n-                        ldc(100).\n-                        if_icmpge(loopExit).\n-                        iconst_1().\n-                        iadd().\n-                        goto_(loopHead).\n-                        labelBinding(loopExit).\n-                        pop().\n-                        iload(0).\n-                        invokespecial(MyValue1.class.describeConstable().get(), \"<init>\", MethodType.methodType(void.class, int.class).describeConstable().get()).\n-                        areturn();\n-            });\n-\n-    public static MyValue1 testMultipleOccurrencesInJVMSReturnStack(int x) throws Throwable {\n-        return (MyValue1) MULTIPLE_OCCURRENCES_IN_JVMS_RETURN_STACK.invokeExact(x);\n-    }\n-\n-    private static final MethodHandle MULTIPLE_OCCURRENCES_IN_JVMS_RETURN_LOCAL = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n-            \"multipleOccurrencesInJVMSReturnLocal\",\n-            MethodType.methodType(MyValue1.class, int.class),\n@@ -1698,0 +1670,1 @@\n+                        astore(2).\n@@ -1699,0 +1672,1 @@\n+                        istore(3).\n@@ -1700,1 +1674,1 @@\n-                        dup().\n+                        iload(3).\n@@ -1703,2 +1677,1 @@\n-                        iconst_1().\n-                        iadd().\n+                        iinc(3, 1).\n@@ -1707,1 +1680,1 @@\n-                        pop().\n+                        aload(2).\n@@ -1710,1 +1683,1 @@\n-                        aload(1).\n+                        aload(2).\n@@ -1714,2 +1687,2 @@\n-    public static MyValue1 testMultipleOccurrencesInJVMSReturnLocal(int x) throws Throwable {\n-        return (MyValue1) MULTIPLE_OCCURRENCES_IN_JVMS_RETURN_LOCAL.invokeExact(x);\n+    public static MyValue1 testMultipleOccurrencesInJVMS(int x) throws Throwable {\n+        return (MyValue1) MULTIPLE_OCCURRENCES_IN_JVMS.invokeExact(x);\n@@ -1845,2 +1818,1 @@\n-        check(testMultipleOccurrencesInJVMSReturnStack(x), new MyValue1(x), doCheck);\n-        check(testMultipleOccurrencesInJVMSReturnLocal(x), new MyValue1(x), doCheck);\n+        check(testMultipleOccurrencesInJVMS(x), new MyValue1(x), doCheck);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":10,"deletions":38,"binary":false,"changes":48,"status":"modified"}]}