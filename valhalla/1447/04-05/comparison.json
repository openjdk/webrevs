{"files":[{"patch":"@@ -707,1 +707,1 @@\n-  \/\/ Scalarize value objects passed into this invocation because we know that they are not larval\n+  \/\/ Scalarize value objects passed into this invocation if we know that they are not larval\n@@ -713,1 +713,1 @@\n-    cast_non_larval(peek(nargs - 1 - arg_idx));\n+    cast_to_non_larval(peek(nargs - 1 - arg_idx));\n@@ -891,1 +891,2 @@\n-      \/\/ Relinquish the oop input, we will delay the allocation to the point it is needed\n+      \/\/ Relinquish the oop input, we will delay the allocation to the point it is needed, see the\n+      \/\/ comments in InlineTypeNode::Ideal for more details\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1504,5 +1504,1 @@\n-Node* GraphKit::cast_non_larval(Node* obj) {\n-  if (obj->is_InlineType()) {\n-    return obj;\n-  }\n-\n+Node* GraphKit::cast_to_non_larval(Node* obj) {\n@@ -1510,1 +1506,1 @@\n-  if (!obj_type->is_inlinetypeptr()) {\n+  if (obj->is_InlineType() || !obj_type->is_inlinetypeptr()) {\n@@ -3444,1 +3440,1 @@\n-  obj = cast_non_larval(obj);\n+  obj = cast_to_non_larval(obj);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-  Node* cast_non_larval(Node* obj);\n+  Node* cast_to_non_larval(Node* obj);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1097,1 +1097,9 @@\n-  \/\/ constructor of an inline type and we want to relinquish the larval oop there\n+  \/\/ constructor of an inline type and we want to relinquish the larval oop there. This has a\n+  \/\/ couple of benefits:\n+  \/\/ - The allocation is likely to be elided earlier if it is not an input of an InlineTypeNode.\n+  \/\/ - The InlineTypeNode without an allocation input is more likely to be GVN-ed. This may emerge\n+  \/\/   when we try to clone a value object.\n+  \/\/ - The buffering, if needed, is delayed until it is required. This new allocation, since it is\n+  \/\/   created from an InlineTypeNode, is recognized as not having a unique identity and in the\n+  \/\/   future, we can move them around more freely such as hoisting out of loops. This is not true\n+  \/\/   for the old allocation since larval value objects do have unique identities.\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2986,3 +2986,5 @@\n-    \/\/ If an allocation is used only in safepoints, elimination of another macro nodes can remove\n-    \/\/ all these safepoints, allowing the allocation to be removed. Hence we do igvn to remove\n-    \/\/ all the excessive uses.\n+    \/\/ Ensure the graph after PhaseMacroExpand::eliminate_macro_nodes is canonical (no igvn\n+    \/\/ transformation is pending). If an allocation is used only in safepoints, elimination of\n+    \/\/ other macro nodes can remove all these safepoints, allowing the allocation to be removed.\n+    \/\/ Hence after igvn we retry removing macro nodes if some progress that has been made in this\n+    \/\/ iteration.\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -186,0 +186,4 @@\n+\n+    \/\/ In an OSR compilation, we cannot know if a value object in the incoming state is larval or\n+    \/\/ not. As a result, we must pass maybe_larval == true to not eagerly scalarize the result if\n+    \/\/ the target type is a value class.\n@@ -625,0 +629,6 @@\n+      \/\/ If the parameter is a value object, try to scalarize it if we know that it is not larval.\n+      \/\/ There are 2 cases when a parameter may be larval:\n+      \/\/ - In an OSR compilation, we do not know if a value object in the incoming state is larval\n+      \/\/   or not. We must be conservative and not eagerly scalarize them.\n+      \/\/ - In a normal compilation, all parameters are non-larval except the receiver of a\n+      \/\/   constructor, which must be a larval object.\n@@ -1782,0 +1792,4 @@\n+        \/\/ An object can appear in the JVMS as either an oop or an InlineTypeNode. If the merge is\n+        \/\/ an InlineTypeNode, we need all the merge inputs to be InlineTypeNodes. Else, if the\n+        \/\/ merge is an oop, each merge input needs to be either an oop or an buffered\n+        \/\/ InlineTypeNode.\n@@ -1783,0 +1797,2 @@\n+          \/\/ The merge cannot be an InlineTypeNode, ensure the input is buffered if it is an\n+          \/\/ InlineTypeNode\n@@ -1784,1 +1800,0 @@\n-            \/\/ The merge is an oop phi, we need to buffer the inline type\n@@ -1788,8 +1803,9 @@\n-          Node* phi = nullptr;\n-          if (target->is_merged()) {\n-            phi = target->start_map()->in(j);\n-          }\n-          if (phi != nullptr && !phi->is_InlineType()) {\n-            if (n->is_InlineType()) {\n-              \/\/ The merge is an oop phi, we need to buffer the inline type\n-              map()->set_req(j, n->as_InlineType()->buffer(this));\n+          \/\/ Since the merge is a value object, it can either be an oop or an InlineTypeNode\n+          if (!target->is_merged()) {\n+            \/\/ This is the first processed input of the merge. If it is an InlineTypeNode, the\n+            \/\/ merge will be an InlineTypeNode. Else, try to scalarize so the merge can be\n+            \/\/ scalarized as well. However, we cannot blindly scalarize an inline type oop here\n+            \/\/ since it may be larval\n+            if (!n->is_InlineType() && gvn().type(n)->is_zero_type()) {\n+              \/\/ Null constant implies that this is not a larval object\n+              map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n@@ -1798,7 +1814,6 @@\n-            if (!n->is_InlineType()) {\n-              \/\/ We cannot blindly expand an inline type here since it may be larval\n-              if (gvn().type(n)->is_zero_type()) {\n-                \/\/ Null constant implies that this is not a larval objects\n-                map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n-              } else if (phi != nullptr && phi->is_InlineType()) {\n-                \/\/ Larval oops cannot be merged with non-larval ones\n+            Node* phi = target->start_map()->in(j);\n+            if (phi->is_InlineType()) {\n+              \/\/ Larval oops cannot be merged with non-larval ones, and since the merge point is\n+              \/\/ non-larval, n must be non-larval as well. As a result, we can scalarize n to merge\n+              \/\/ into phi\n+              if (!n->is_InlineType()) {\n@@ -1807,0 +1822,5 @@\n+            } else {\n+              \/\/ The merge is an oop phi, ensure the input is buffered if it is an InlineTypeNode\n+              if (n->is_InlineType()) {\n+                map()->set_req(j, n->as_InlineType()->buffer(this));\n+              }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":36,"deletions":16,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3409,1 +3409,1 @@\n-    return_current(cast_non_larval(pop()));\n+    return_current(cast_to_non_larval(pop()));\n@@ -3464,1 +3464,1 @@\n-    b = cast_non_larval(pop());\n+    b = cast_to_non_larval(pop());\n@@ -3493,2 +3493,2 @@\n-    a = cast_non_larval(pop());\n-    b = cast_non_larval(pop());\n+    a = cast_to_non_larval(pop());\n+    b = cast_to_non_larval(pop());\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  obj = cast_non_larval(obj);\n+  obj = cast_to_non_larval(obj);\n@@ -258,1 +258,1 @@\n-  val = cast_non_larval(val);\n+  val = cast_to_non_larval(val);\n@@ -260,0 +260,1 @@\n+  \/\/ We cannot store into a non-larval object, so obj must not be an InlineTypeNode\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -652,3 +652,1 @@\n-    \/\/ TODO 8332886 Remove the AlwaysIncrementalInline=false condition\n-    @IR(applyIf = {\"AlwaysIncrementalInline\", \"false\"},\n-        counts = {ALLOC, \"= 1\"})\n+    @IR(counts = {ALLOC, \"= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}