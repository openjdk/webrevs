{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -35,2 +36,2 @@\n-JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src) {\n-  \/\/ move object into WeakHandle when copying into the table\n+JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src) : _h() {\n+  \/\/ move object into Handle when copying into the table\n@@ -38,0 +39,1 @@\n+    _is_weak = !src._obj->klass()->is_inline_klass();\n@@ -43,1 +45,5 @@\n-    _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n+    if (_is_weak) {\n+      _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n+    } else {\n+      _h = OopHandle(JvmtiExport::jvmti_oop_storage(), src._obj);\n+    }\n@@ -46,1 +52,5 @@\n-    _wh = src._wh;\n+    if (_is_weak) {\n+      _wh = src._wh;\n+    } else {\n+      _h = src._h;\n+    }\n@@ -52,2 +62,6 @@\n-void JvmtiTagMapKey::release_weak_handle() {\n-  _wh.release(JvmtiExport::weak_tag_storage());\n+void JvmtiTagMapKey::release_handle() {\n+  if (_is_weak) {\n+    _wh.release(JvmtiExport::weak_tag_storage());\n+  } else {\n+    _h.release(JvmtiExport::jvmti_oop_storage());\n+  }\n@@ -58,1 +72,1 @@\n-  return _wh.resolve();\n+  return _is_weak ? _wh.resolve() : _h.resolve();\n@@ -63,1 +77,1 @@\n-  return _wh.peek();\n+  return _is_weak ? _wh.peek() : _h.peek();\n@@ -78,0 +92,71 @@\n+static bool equal_oops(oop obj1, oop obj2); \/\/ forward declaration\n+\n+static bool equal_fields(char type, oop obj1, oop obj2, int offset) {\n+  switch (type) {\n+  case JVM_SIGNATURE_BOOLEAN:\n+    return obj1->bool_field(offset) == obj2->bool_field(offset);\n+  case JVM_SIGNATURE_CHAR:\n+    return obj1->char_field(offset) == obj2->char_field(offset);\n+  case JVM_SIGNATURE_FLOAT:\n+    return obj1->float_field(offset) == obj2->float_field(offset);\n+  case JVM_SIGNATURE_DOUBLE:\n+    return obj1->double_field(offset) == obj2->double_field(offset);\n+  case JVM_SIGNATURE_BYTE:\n+    return obj1->byte_field(offset) == obj2->byte_field(offset);\n+  case JVM_SIGNATURE_SHORT:\n+    return obj1->short_field(offset) == obj2->short_field(offset);\n+  case JVM_SIGNATURE_INT:\n+    return obj1->int_field(offset) == obj2->int_field(offset);\n+  case JVM_SIGNATURE_LONG:\n+    return obj1->long_field(offset) == obj2->long_field(offset);\n+  case JVM_SIGNATURE_CLASS:\n+  case JVM_SIGNATURE_ARRAY:\n+    return equal_oops(obj1->obj_field(offset), obj2->obj_field(offset));\n+  }\n+  ShouldNotReachHere();\n+}\n+\n+\/\/ For heap-allocated objects offset is 0 and 'klass' is obj1->klass() (== obj2->klass()).\n+\/\/ For flattened objects offset is the offset in the holder object, 'klass' is inlined object class.\n+static bool equal_value_objects(oop obj1, oop obj2, InlineKlass* klass, int offset) {\n+  for (JavaFieldStream fld(klass); !fld.done(); fld.next()) {\n+    \/\/ ignore static fields\n+    if (fld.access_flags().is_static()) {\n+      continue;\n+    }\n+    int field_offset = offset + fld.offset() - (offset > 0 ? klass->payload_offset() : 0);\n+    if (fld.is_flat()) { \/\/ flat value field\n+      InstanceKlass* holder_klass = fld.field_holder();\n+      InlineKlass* field_klass = holder_klass->get_inline_type_field_klass(fld.index());\n+      if (!equal_value_objects(obj1, obj2, field_klass, field_offset)) {\n+        return false;\n+      }\n+    } else {\n+      if (!equal_fields(fld.signature()->char_at(0), obj1, obj2, field_offset)) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+static bool equal_oops(oop obj1, oop obj2) {\n+  if (obj1 == obj2) {\n+    return true;\n+  }\n+\n+  if (EnableValhalla) {\n+    if (obj1 != nullptr && obj2 != nullptr && obj1->klass() == obj2->klass() && obj1->is_inline_type()) {\n+      InlineKlass* vk = InlineKlass::cast(obj1->klass());\n+      return equal_value_objects(obj1, obj2, vk, 0);\n+    }\n+  }\n+  return false;\n+}\n+\n+bool JvmtiTagMapKey::equals(const JvmtiTagMapKey& lhs, const JvmtiTagMapKey& rhs) {\n+  oop lhs_obj = lhs._obj != nullptr ? lhs._obj : lhs.object_no_keepalive();\n+  oop rhs_obj = rhs._obj != nullptr ? rhs._obj : rhs.object_no_keepalive();\n+  return equal_oops(lhs_obj, rhs_obj);\n+}\n+\n@@ -91,1 +176,1 @@\n-      entry.release_weak_handle();\n+      entry.release_handle();\n@@ -145,1 +230,1 @@\n-    entry.release_weak_handle();\n+    entry.release_handle();\n@@ -163,1 +248,1 @@\n-        entry.release_weak_handle();\n+        entry.release_handle();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":96,"deletions":11,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+\/\/\n+\/\/ Valhalla: Keep just one tag for all equal value objects including heap allocated value objects.\n+\/\/ We have to keep a strong reference to each unique value object with a non-zero tag.\n@@ -44,1 +47,7 @@\n-  WeakHandle _wh;\n+  \/\/ All equal value objects should have the same tag.\n+  \/\/ Keep value objects alive (1 copy for each \"value\") until their tags are removed.\n+  union {\n+    WeakHandle _wh;\n+    OopHandle _h; \/\/ for value objects (_is_weak == false)\n+  };\n+  bool _is_weak;\n@@ -53,1 +62,1 @@\n-  void release_weak_handle();\n+  void release_handle();\n@@ -56,5 +65,1 @@\n-  static bool equals(const JvmtiTagMapKey& lhs, const JvmtiTagMapKey& rhs) {\n-    oop lhs_obj = lhs._obj != nullptr ? lhs._obj : lhs.object_no_keepalive();\n-    oop rhs_obj = rhs._obj != nullptr ? rhs._obj : rhs.object_no_keepalive();\n-    return lhs_obj == rhs_obj;\n-  }\n+  static bool equals(const JvmtiTagMapKey& lhs, const JvmtiTagMapKey& rhs);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests SetTag\/GetTag functionality for value objects.\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @run main\/othervm\/native -agentlib:ValueTagMapTest\n+ *                          -XX:+PrintInlineLayout\n+ *                          -XX:+PrintFlatArrayLayout\n+ *                          -Xlog:jvmti+table\n+ *                          ValueTagMapTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+public class ValueTagMapTest {\n+\n+    private static value class ValueClass {\n+        public int f;\n+        public ValueClass(int v) { f = v + 1; }\n+        public String toString() {\n+            return String.valueOf(f);\n+        }\n+    }\n+\n+    private static value class ValueHolder {\n+        @Strict\n+        @NullRestricted\n+        public ValueClass f0;\n+\n+        public ValueHolder(int v) {\n+            f0 = new ValueClass(v);\n+        }\n+        public String toString() {\n+            return \"holder{\" + f0 + \"}\";\n+        }\n+    }\n+\n+    private static value class ValueHolder2 {\n+        public ValueHolder f1;\n+        @Strict\n+        @NullRestricted\n+        public ValueHolder f2;\n+\n+        public ValueHolder2(int v, int v2) {\n+            f1 = new ValueHolder(v);\n+            f2 = new ValueHolder(v2);\n+        }\n+        public ValueHolder2(ValueHolder h1, int v2) {\n+            f1 = h1;\n+            f2 = new ValueHolder(v2);\n+        }\n+        public String toString() {\n+            return \"holder2{\" + f1 + \", \" + f2 + \"}\";\n+        }\n+    }\n+\n+\n+    private static native void setTag0(Object object, long tag);\n+    private static void setTag(Object object, long tag) {\n+        setTag0(object, tag);\n+    }\n+    private static native long getTag0(Object object);\n+    private static long getTag(Object object) {\n+        long tag = getTag0(object);\n+        if (tag == 0) {\n+            throw new RuntimeException(\"Zero tag for object \" + object);\n+        }\n+        return tag;\n+    }\n+\n+    private static void testGetTag(Object o1, Object o2) {\n+        long tag1 = getTag(o1);\n+        long tag2 = getTag(o2);\n+        if (o1 == o2) {\n+            if (tag1 != tag2) {\n+                throw new RuntimeException(\"different tags for equal objects: \"\n+                                           + o1 + \" (tag \" + tag1 + \"), \"\n+                                           + o2 + \" (tag \" + tag2 + \")\");\n+            }\n+        } else {\n+            if (tag1 == tag2) {\n+                throw new RuntimeException(\"equal tags for different objects: \"\n+                                           + o1 + \" (tag \" + tag1 + \"), \"\n+                                           + o2 + \" (tag \" + tag2 + \")\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.loadLibrary(\"ValueTagMapTest\");\n+        List<ValueHolder2> items = new ArrayList<>();\n+\n+        for (int i = 0; i < 20; i++) {\n+            items.add(new ValueHolder2(i % 4, i % 8));\n+        }\n+\n+        long startTime = System.nanoTime();\n+        long tag = 1;\n+        for (ValueHolder2 item : items) {\n+            setTag(item, tag++);\n+            setTag(item.f1, tag++);\n+            setTag(item.f2, tag++);\n+        }\n+\n+        for (ValueHolder2 item: items) {\n+            long tag0 = getTag(item);\n+            long tag1 = getTag(item.f1);\n+            long tag2 = getTag(item.f2);\n+            System.out.println(\"getTag (\" + item + \"): \" + tag0 + \", f1: \" + tag1 + \", f2:\" + tag2);\n+        }\n+\n+        startTime = System.nanoTime();\n+        for (ValueHolder2 item1: items) {\n+            for (ValueHolder2 item2 : items) {\n+                testGetTag(item1, item2);\n+                testGetTag(item1.f1, item2.f1);\n+                testGetTag(item1.f2, item2.f2);\n+                testGetTag(item1.f1, item2.f2);\n+                testGetTag(item1.f2, item2.f1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/SetTag\/ValueTagMapTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+#include \"jvmti_common.hpp\"\n+\n+namespace {\n+\n+jvmtiEnv *jvmti = nullptr;\n+\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL Java_ValueTagMapTest_setTag0(JNIEnv* jni_env, jclass clazz, jobject object, jlong tag) {\n+  jvmtiError err = jvmti->SetTag(object, tag);\n+  check_jvmti_error(err, \"could not set tag\");\n+}\n+\n+extern \"C\" JNIEXPORT jlong JNICALL Java_ValueTagMapTest_getTag0(JNIEnv* jni_env, jclass clazz, jobject object) {\n+  jlong tag;\n+  check_jvmti_error(jvmti->GetTag(object, &tag), \"could not get tag\");\n+  return tag;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  if (vm->GetEnv(reinterpret_cast<void **>(&jvmti), JVMTI_VERSION) != JNI_OK || !jvmti) {\n+    LOG(\"Could not initialize JVMTI\\n\");\n+    abort();\n+  }\n+  jvmtiCapabilities capabilities;\n+  memset(&capabilities, 0, sizeof(capabilities));\n+  capabilities.can_tag_objects = 1;\n+  check_jvmti_error(jvmti->AddCapabilities(&capabilities), \"adding capabilities\");\n+  return JVMTI_ERROR_NONE;\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/SetTag\/libValueTagMapTest.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}