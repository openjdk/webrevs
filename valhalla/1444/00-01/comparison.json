{"files":[{"patch":"@@ -34,1 +34,1 @@\n-JvmtiTagMapKey::JvmtiTagMapKey(oop obj) : _obj(obj), _is_weak(obj->klass()->is_inline_klass()) {}\n+JvmtiTagMapKey::JvmtiTagMapKey(oop obj) : _obj(obj) {}\n@@ -36,1 +36,1 @@\n-JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src) {\n+JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src) : _h() {\n@@ -39,0 +39,1 @@\n+    _is_weak = !src._obj->klass()->is_inline_klass();\n@@ -91,1 +92,1 @@\n-static bool equals_oops(oop obj1, oop obj2); \/\/ forward declaration\n+static bool equal_oops(oop obj1, oop obj2); \/\/ forward declaration\n@@ -93,1 +94,1 @@\n-static bool equals_fields(char type, oop obj1, oop obj2, int offset) {\n+static bool equal_fields(char type, oop obj1, oop obj2, int offset) {\n@@ -113,1 +114,1 @@\n-    return equals_oops(obj1->obj_field(offset), obj2->obj_field(offset));\n+    return equal_oops(obj1->obj_field(offset), obj2->obj_field(offset));\n@@ -120,1 +121,1 @@\n-static bool equals_value_objects(oop obj1, oop obj2, InlineKlass* klass, int offset) {\n+static bool equal_value_objects(oop obj1, oop obj2, InlineKlass* klass, int offset) {\n@@ -130,1 +131,1 @@\n-      if (!equals_value_objects(obj1, obj2, field_klass, field_offset)) {\n+      if (!equal_value_objects(obj1, obj2, field_klass, field_offset)) {\n@@ -134,1 +135,1 @@\n-      if (!equals_fields(fld.signature()->char_at(0), obj1, obj2, field_offset)) {\n+      if (!equal_fields(fld.signature()->char_at(0), obj1, obj2, field_offset)) {\n@@ -142,1 +143,1 @@\n-static bool equals_oops(oop obj1, oop obj2) {\n+static bool equal_oops(oop obj1, oop obj2) {\n@@ -148,1 +149,1 @@\n-    if (obj1 != nullptr && obj2 != nullptr && obj1->klass() == obj2->klass() && obj1->klass()->is_inline_klass()) {\n+    if (obj1 != nullptr && obj2 != nullptr && obj1->klass() == obj2->klass() && obj1->is_inline_type()) {\n@@ -150,1 +151,1 @@\n-      return equals_value_objects(obj1, obj2, vk, 0);\n+      return equal_value_objects(obj1, obj2, vk, 0);\n@@ -153,1 +154,1 @@\n-  return true;\n+  return false;\n@@ -159,5 +160,1 @@\n-  if (lhs_obj != nullptr && lhs_obj->is_inline_type() && rhs_obj != nullptr && rhs_obj->is_inline_type()) {\n-    return equals_oops(lhs_obj, rhs_obj);\n-  }\n-\n-  return lhs_obj == rhs_obj;\n+  return equal_oops(lhs_obj, rhs_obj);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-\/\/ Valhalla: tags for equal (\"the same\") value object are the same.\n-\/\/ We have to keep strong reference to each unique value object with non-0 tag.\n+\/\/ Valhalla: Keep just one tag for all equal value objects including heap allocated value objects.\n+\/\/ We have to keep a strong reference to each unique value object with a non-zero tag.\n@@ -48,1 +48,1 @@\n-  \/\/ So have to keep alive value objects (1 copy for each \"value\") until their tags are removed.\n+  \/\/ Keep value objects alive (1 copy for each \"value\") until their tags are removed.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-        public int f1;\n-        public ValueClass(int v1) { f1 = v1 + 1; }\n+        public int f;\n+        public ValueClass(int v) { f = v + 1; }\n@@ -49,1 +49,1 @@\n-            return String.valueOf(f1);\n+            return String.valueOf(f);\n@@ -56,1 +56,1 @@\n-        public ValueClass f1;\n+        public ValueClass f0;\n@@ -59,1 +59,1 @@\n-            f1 = new ValueClass(v);\n+            f0 = new ValueClass(v);\n@@ -62,1 +62,1 @@\n-            return \"holder{\" + f1 + \"}\";\n+            return \"holder{\" + f0 + \"}\";\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/SetTag\/ValueTagMapTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n-#include <cstdlib>\n-#include <cstring>\n+#include \"jvmti_common.hpp\"\n@@ -32,8 +31,0 @@\n-void checkJvmti(int code, const char* message) {\n-  if (code != JVMTI_ERROR_NONE) {\n-    printf(\"Error %s: %d\\n\", message, code);\n-    fflush(nullptr);\n-    abort();\n-  }\n-}\n-\n@@ -44,1 +35,1 @@\n-  checkJvmti(err, \"could not set tag\");\n+  check_jvmti_error(err, \"could not set tag\");\n@@ -49,1 +40,1 @@\n-  checkJvmti(jvmti->GetTag(object, &tag), \"could not get tag\");\n+  check_jvmti_error(jvmti->GetTag(object, &tag), \"could not get tag\");\n@@ -55,2 +46,1 @@\n-    printf(\"Could not initialize JVMTI\\n\");\n-    fflush(nullptr);\n+    LOG(\"Could not initialize JVMTI\\n\");\n@@ -62,1 +52,1 @@\n-  checkJvmti(jvmti->AddCapabilities(&capabilities), \"adding capabilities\");\n+  check_jvmti_error(jvmti->AddCapabilities(&capabilities), \"adding capabilities\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/SetTag\/libValueTagMapTest.cpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"}]}