{"files":[{"patch":"@@ -782,4 +782,4 @@\n-$(eval $(call SetupTarget, build-microbenchmark, \\\n-    MAKEFILE := test\/BuildMicrobenchmark, \\\n-    DEPS := interim-langtools exploded-image, \\\n-))\n+# $(eval $(call SetupTarget, build-microbenchmark, \\\n+#     MAKEFILE := test\/BuildMicrobenchmark, \\\n+#     DEPS := interim-langtools exploded-image, \\\n+# ))\n@@ -1283,3 +1283,3 @@\n-ifneq ($(JMH_CORE_JAR), )\n-  test-image: build-microbenchmark\n-endif\n+# ifneq ($(JMH_CORE_JAR), )\n+#   test-image: build-microbenchmark\n+# endif\n","filename":"make\/Main.gmk","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3756,1 +3756,2 @@\n-      if (!_method->signature()->returns_null_free_inline_type()) {\n+      \/\/ if (!_method->signature()->returns_null_free_inline_type()) {\n+      if (!false) {  \/\/ JDK-8325660: code to be revisited after removal of Q-descriptors\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-    case T_PRIMITIVE_OBJECT : i = 10; break;\n","filename":"src\/hotspot\/cpu\/aarch64\/abstractInterpreter_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -575,1 +575,0 @@\n-    case T_PRIMITIVE_OBJECT :\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1814,2 +1814,2 @@\n-  andr(temp_reg, temp_reg, JVM_ACC_VALUE);\n-  cbnz(temp_reg, is_inline_type);\n+  andr(temp_reg, temp_reg, JVM_ACC_IDENTITY);\n+  cbz(temp_reg, is_inline_type);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -341,1 +341,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -421,1 +420,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -545,1 +543,0 @@\n-  assert(bt != T_PRIMITIVE_OBJECT || !InlineTypePassFieldsAsArgs, \"no inline type here\");\n@@ -1132,1 +1129,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -1957,1 +1953,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -2146,1 +2141,0 @@\n-  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-    \/\/ T_OBJECT, T_PRIMITIVE_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n+    \/\/ T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n@@ -341,2 +341,0 @@\n-    __ cmp(Rresult_type, (u1)T_PRIMITIVE_OBJECT);\n-    __ br(Assembler::EQ, check_prim);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -596,1 +596,0 @@\n-  case T_PRIMITIVE_OBJECT: \/\/ fall through (value types are handled with oops)\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -342,1 +342,0 @@\n-  __ andr(r3, r3, ~JVM_CONSTANT_QDescBit);\n@@ -3925,24 +3924,0 @@\n-void TemplateTable::aconst_init() {\n-  transition(vtos, atos);\n-  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n-  __ get_constant_pool(c_rarg1);\n-  call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n-          c_rarg1, c_rarg2);\n-  __ verify_oop(r0);\n-  \/\/ Must prevent reordering of stores for object initialization with stores that publish the new object.\n-  __ membar(Assembler::StoreStore);\n-}\n-\n-void TemplateTable::withfield() {\n-  transition(vtos, atos);\n-\n-  resolve_cache_and_index_for_field(f2_byte, c_rarg1 \/*cache*\/, c_rarg2 \/*index*\/);\n-  __ lea(c_rarg2, at_tos());\n-  call_VM(r1, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), c_rarg1, c_rarg2);\n-  \/\/ new value type is returned in r1\n-  \/\/ stack adjustment is returned in r0\n-  __ verify_oop(r1);\n-  __ add(esp, esp, r0);\n-  __ mov(r0, r1);\n-}\n-\n@@ -3988,1 +3963,0 @@\n-  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n@@ -4028,15 +4002,0 @@\n-  if (EnablePrimitiveClasses) {\n-    \/\/ Get cpool & tags index\n-    __ get_cpool_and_tags(r2, r3); \/\/ r2=cpool, r3=tags array\n-    __ get_unsigned_2_byte_index_at_bcp(r19, 1); \/\/ r19=index\n-     \/\/ See if bytecode has already been quicked\n-    __ add(rscratch1, r3, Array<u1>::base_offset_in_bytes());\n-    __ lea(r1, Address(rscratch1, r19));\n-    __ ldarb(r1, r1);\n-    \/\/ See if CP entry is a Q-descriptor\n-    __ andr (r1, r1, JVM_CONSTANT_QDescBit);\n-    __ cmp(r1, (u1) JVM_CONSTANT_QDescBit);\n-    __ br(Assembler::NE, done);\n-    __ b(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n-  }\n-\n@@ -4058,1 +4017,0 @@\n-  __ andr(r1, r1, ~JVM_CONSTANT_QDescBit);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -136,1 +136,0 @@\n-    case T_PRIMITIVE_OBJECT : i = 8; break;\n@@ -157,1 +156,0 @@\n-    case T_PRIMITIVE_OBJECT : i = 10; break;\n","filename":"src\/hotspot\/cpu\/x86\/abstractInterpreter_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -565,1 +565,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2975,2 +2975,2 @@\n-  testl(temp_reg, JVM_ACC_VALUE);\n-  jcc(Assembler::notZero, is_inline_type);\n+  testl(temp_reg, JVM_ACC_IDENTITY);\n+  jcc(Assembler::zero, is_inline_type);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -485,1 +485,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -1014,1 +1013,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -1598,1 +1596,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -1778,1 +1775,0 @@\n-  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,1 +529,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -608,1 +607,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -739,1 +737,0 @@\n-  assert(bt != T_PRIMITIVE_OBJECT || !InlineTypePassFieldsAsArgs, \"no inline type here\");\n@@ -1385,1 +1382,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -2312,1 +2308,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -2507,1 +2502,0 @@\n-  case T_PRIMITIVE_OBJECT:           \/\/ Really a handle\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-  \/\/ T_OBJECT, T_PRIMITIVE_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n+  \/\/ T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)\n@@ -316,2 +316,0 @@\n-  __ cmpl(rbx, T_PRIMITIVE_OBJECT);\n-  __ jcc(Assembler::equal, check_prim);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -369,1 +369,0 @@\n-  case T_PRIMITIVE_OBJECT: \/\/ fall through (inline types are handled with oops)\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -386,1 +386,0 @@\n-  __ andl(rdx, ~JVM_CONSTANT_QDescBit);\n@@ -3341,17 +3340,0 @@\n-void TemplateTable::withfield() {\n-  transition(vtos, atos);\n-\n-  Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n-  Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n-\n-  resolve_cache_and_index_for_field(f2_byte, cache, index);\n-\n-  __ lea(rax, at_tos());\n-  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cache, rax);\n-  \/\/ new value type is returned in rbx\n-  \/\/ stack adjustment is returned in rax\n-  __ verify_oop(rbx);\n-  __ addptr(rsp, rax);\n-  __ movptr(rax, rbx);\n-}\n-\n@@ -4347,1 +4329,0 @@\n-  Label is_not_value;\n@@ -4361,7 +4342,0 @@\n-  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), Klass::InlineKlassKind);\n-  __ jcc(Assembler::notEqual, is_not_value);\n-\n-  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));\n-\n-  __ bind(is_not_value);\n-\n@@ -4390,51 +4364,0 @@\n-void TemplateTable::aconst_init() {\n-  transition(vtos, atos);\n-\n-  Label slow_case;\n-  Label done;\n-  Label is_value;\n-\n-  __ get_unsigned_2_byte_index_at_bcp(rdx, 1);\n-  __ get_cpool_and_tags(rcx, rax);\n-\n-  \/\/ Make sure the class we're about to instantiate has been resolved.\n-  \/\/ This is done before loading InstanceKlass to be consistent with the order\n-  \/\/ how Constant Pool is updated (see ConstantPool::klass_at_put)\n-  const int tags_offset = Array<u1>::base_offset_in_bytes();\n-  __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);\n-  __ jcc(Assembler::notEqual, slow_case);\n-\n-  \/\/ get InstanceKlass\n-  __ load_resolved_klass_at_index(rcx, rcx, rdx);\n-\n-  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), Klass::InlineKlassKind);\n-  __ jcc(Assembler::equal, is_value);\n-\n-  \/\/ in the future, aconst_init will just return null instead of throwing an exception\n-  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));\n-\n-  __ bind(is_value);\n-\n-  \/\/ make sure klass is fully initialized\n-  __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n-  __ jcc(Assembler::notEqual, slow_case);\n-\n-  \/\/ have a resolved InlineKlass in rcx, return the default value oop from it\n-  __ get_default_value_oop(rcx, rdx, rax);\n-  __ jmp(done);\n-\n-  __ bind(slow_case);\n-\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n-  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n-\n-  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n-  __ get_constant_pool(rarg1);\n-\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::aconst_init),\n-      rarg1, rarg2);\n-\n-  __ bind(done);\n-  __ verify_oop(rax);\n-}\n-\n@@ -4479,1 +4402,0 @@\n-  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n@@ -4527,14 +4449,0 @@\n-  if (EnablePrimitiveClasses) {\n-    \/\/ Get cpool & tags index\n-    __ get_cpool_and_tags(rcx, rdx); \/\/ rcx=cpool, rdx=tags array\n-    __ get_unsigned_2_byte_index_at_bcp(rbx, 1); \/\/ rbx=index\n-    \/\/ See if CP entry is a Q-descriptor\n-    __ movzbl(rcx, Address(rdx, rbx,\n-        Address::times_1,\n-        Array<u1>::base_offset_in_bytes()));\n-    __ andl (rcx, JVM_CONSTANT_QDescBit);\n-    __ cmpl(rcx, JVM_CONSTANT_QDescBit);\n-    __ jcc(Assembler::notEqual, done);\n-    __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));\n-  }\n-\n@@ -4557,1 +4465,0 @@\n-  __ andl (rdx, ~JVM_CONSTANT_QDescBit);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":0,"deletions":93,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2796,1 +2796,2 @@\n-      if (!_method->signature()->returns_null_free_inline_type()) {\n+        \/\/ if (!_method->signature()->returns_null_free_inline_type()) {\n+        if (!false) {  \/\/ JDK-8325660: code to be revisited after removal of Q-descriptors\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1040,7 +1040,0 @@\n-  if (x->as_NewInlineTypeInstance() != nullptr && x->as_NewInlineTypeInstance()->in_larval_state()) {\n-    if (x->as_NewInlineTypeInstance()->on_stack_count() == 1) {\n-      x->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-    } else {\n-      x->as_NewInlineTypeInstance()->increment_on_stack_count();\n-    }\n-  }\n@@ -1053,3 +1046,0 @@\n-  if (x->as_NewInlineTypeInstance() != nullptr) {\n-    x->as_NewInlineTypeInstance()->set_local_index(index);\n-  }\n@@ -1084,3 +1074,0 @@\n-  if (x->as_NewInlineTypeInstance() != nullptr) {\n-    x->as_NewInlineTypeInstance()->set_local_index(index);\n-  }\n@@ -1228,1 +1215,0 @@\n-        update_larva_stack_count(w);\n@@ -1234,2 +1220,0 @@\n-        update_larva_stack_count(w1);\n-        update_larva_stack_count(w2);\n@@ -1240,1 +1224,0 @@\n-        update_larval_state(w);\n@@ -1248,1 +1231,0 @@\n-        update_larval_state(w1);\n@@ -1263,5 +1245,0 @@\n-          if (s.cur_bc() != Bytecodes::_pop) {\n-            w1->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-          } else {\n-            w1->as_NewInlineTypeInstance()->increment_on_stack_count();\n-          }\n@@ -1278,2 +1255,0 @@\n-        update_larval_state(w1);\n-        update_larval_state(w2);\n@@ -1290,2 +1265,0 @@\n-        update_larval_state(w1);\n-        update_larval_state(w2);\n@@ -1304,2 +1277,0 @@\n-        update_larval_state(w1);\n-        update_larval_state(w2);\n@@ -1713,1 +1684,1 @@\n-  if ((method()->is_object_constructor() || method()->is_static_vnew_factory()) &&\n+  if (method()->is_object_constructor() &&\n@@ -2156,78 +2127,0 @@\n-\/\/ Baseline version of withfield, allocate every time\n-void GraphBuilder::withfield(int field_index) {\n-  \/\/ Save the entire state and re-execute on deopt\n-  ValueStack* state_before = copy_state_before();\n-  state_before->set_should_reexecute(true);\n-\n-  bool will_link;\n-  ciField* field_modify = stream()->get_field(will_link);\n-  ciInstanceKlass* holder = field_modify->holder();\n-  BasicType field_type = field_modify->type()->basic_type();\n-  ValueType* type = as_ValueType(field_type);\n-  Value val = pop(type);\n-  Value obj = apop();\n-  null_check(obj);\n-\n-  if (!holder->is_loaded() || !holder->is_inlinetype() || !will_link) {\n-    apush(append_split(new Deoptimize(holder, state_before)));\n-    return;\n-  }\n-\n-  \/\/ call will_link again to determine if the field is valid.\n-  const bool needs_patching = !field_modify->will_link(method(), Bytecodes::_withfield) ||\n-                              (!field_modify->is_flat() && PatchALot);\n-  const int offset_modify = !needs_patching ? field_modify->offset_in_bytes() : -1;\n-\n-  scope()->set_wrote_final();\n-  scope()->set_wrote_fields();\n-\n-  NewInlineTypeInstance* new_instance;\n-  if (obj->as_NewInlineTypeInstance() != nullptr && obj->as_NewInlineTypeInstance()->in_larval_state()) {\n-    new_instance = obj->as_NewInlineTypeInstance();\n-    apush(append_split(new_instance));\n-  } else {\n-    new_instance = new NewInlineTypeInstance(holder->as_inline_klass(), state_before);\n-    _memory->new_instance(new_instance);\n-    apush(append_split(new_instance));\n-\n-    \/\/ Initialize fields which are not modified\n-    for (int i = 0; i < holder->nof_nonstatic_fields(); i++) {\n-      ciField* field = holder->nonstatic_field_at(i);\n-      int offset = field->offset_in_bytes();\n-      \/\/ Don't use offset_modify here, it might be set to -1 if needs_patching\n-      if (offset != field_modify->offset_in_bytes()) {\n-        if (field->is_flat()) {\n-          ciInlineKlass* vk = field->type()->as_inline_klass();\n-          if (!vk->is_empty()) {\n-            copy_inline_content(vk, obj, offset, new_instance, vk->first_field_offset(), state_before, field);\n-          }\n-        } else {\n-          LoadField* load = new LoadField(obj, offset, field, false, state_before, false);\n-          Value replacement = append(load);\n-          StoreField* store = new StoreField(new_instance, offset, field, replacement, false, state_before, false);\n-          append(store);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Field to modify\n-  if (field_type == T_BOOLEAN) {\n-    Value mask = append(new Constant(new IntConstant(1)));\n-    val = append(new LogicOp(Bytecodes::_iand, val, mask));\n-  }\n-  if (field_modify->is_null_free()) {\n-    null_check(val);\n-  }\n-  if (field_modify->is_flat()) {\n-    assert(!needs_patching, \"Can't patch flat inline type field access\");\n-    ciInlineKlass* vk = field_modify->type()->as_inline_klass();\n-    if (!vk->is_empty()) {\n-      copy_inline_content(vk, val, vk->first_field_offset(), new_instance, offset_modify, state_before, field_modify);\n-    }\n-  } else {\n-    StoreField* store = new StoreField(new_instance, offset_modify, field_modify, val, false, state_before, needs_patching);\n-    append(store);\n-  }\n-}\n-\n@@ -2587,1 +2480,2 @@\n-                              declared_signature->returns_null_free_inline_type());\n+                              \/\/ declared_signature->returns_null_free_inline_type());\n+                              false);  \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -2609,12 +2503,0 @@\n-void GraphBuilder::default_value(int klass_index) {\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n-  if (!stream()->is_unresolved_klass() && klass->is_inlinetype() &&\n-      klass->as_inline_klass()->is_initialized()) {\n-    ciInlineKlass* vk = klass->as_inline_klass();\n-    apush(append(new Constant(new InstanceConstant(vk->default_instance()))));\n-  } else {\n-    apush(append_split(new Deoptimize(klass, copy_state_before())));\n-  }\n-}\n-\n@@ -2629,1 +2511,2 @@\n-  bool null_free = stream()->has_Q_signature();\n+  \/\/ bool null_free = stream()->has_Q_signature();\n+  bool null_free = false; \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -2655,1 +2538,2 @@\n-  bool null_free = stream()->has_Q_signature();\n+  \/\/ bool null_free = stream()->has_Q_signature();\n+  bool null_free = false; \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -3381,2 +3265,0 @@\n-      case Bytecodes::_aconst_init   : default_value(s.get_index_u2()); break;\n-      case Bytecodes::_withfield      : withfield(s.get_index_u2()); break;\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":7,"deletions":125,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -297,2 +297,0 @@\n-  void default_value(int klass_index);\n-  void withfield(int field_index);\n@@ -394,13 +392,0 @@\n-  \/\/ Inline type support\n-  void update_larval_state(Value v) {\n-    if (v != nullptr && v->as_NewInlineTypeInstance() != nullptr) {\n-      v->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-    }\n-  }\n-  void update_larva_stack_count(Value v) {\n-    if (v != nullptr && v->as_NewInlineTypeInstance() != nullptr &&\n-        v->as_NewInlineTypeInstance()->in_larval_state()) {\n-      v->as_NewInlineTypeInstance()->decrement_on_stack_count();\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -424,3 +424,0 @@\n-  if (value->as_NewInlineTypeInstance() != nullptr) {\n-    value->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-  }\n@@ -441,3 +438,0 @@\n-  if (value->as_NewInlineTypeInstance() != nullptr) {\n-    value->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-  }\n@@ -472,3 +466,0 @@\n-    if (receiver()->as_NewInlineTypeInstance() != nullptr) {\n-      receiver()->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-    }\n@@ -481,3 +472,0 @@\n-    if (v->as_NewInlineTypeInstance() != nullptr) {\n-      v->as_NewInlineTypeInstance()->set_not_larva_anymore();\n-    }\n@@ -965,2 +953,0 @@\n-          if (new_value->as_NewInlineTypeInstance() != nullptr) {new_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n-          if (existing_value->as_NewInlineTypeInstance() != nullptr) {existing_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n@@ -981,2 +967,0 @@\n-          if (new_value->as_NewInlineTypeInstance() != nullptr) {new_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n-          if (existing_value->as_NewInlineTypeInstance() != nullptr) {existing_value->as_NewInlineTypeInstance()->set_not_larva_anymore(); }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1367,3 +1367,1 @@\n-  bool _in_larval_state;\n-  int _first_local_index;\n-  int _on_stack_count;\n+\n@@ -1376,3 +1374,0 @@\n-   , _in_larval_state(true)\n-   , _first_local_index(-1)\n-   , _on_stack_count(1)\n@@ -1394,18 +1389,0 @@\n-\n-  void set_local_index(int index) {\n-    decrement_on_stack_count();\n-    if (_first_local_index != index) {\n-      if (_first_local_index == -1) {\n-        _first_local_index = index;\n-      } else {\n-        set_not_larva_anymore();\n-      }\n-    }\n-  }\n-\n-  bool in_larval_state() const { return _in_larval_state; }\n-  void set_not_larva_anymore() { _in_larval_state = false; }\n-\n-  int on_stack_count() const { return _on_stack_count; }\n-  void increment_on_stack_count() { _on_stack_count++; }\n-  void decrement_on_stack_count() { _on_stack_count--; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-      case Bytecodes::_withfield:\n@@ -68,1 +67,0 @@\n-      case Bytecodes::_aconst_init:\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1163,5 +1163,0 @@\n-      case Bytecodes::_aconst_init:\n-        { Bytecode_aconst_init baconst_init(caller_method(), caller_method->bcp_from(bci));\n-          k = caller_method->constants()->klass_at(baconst_init.index(), CHECK);\n-        }\n-        break;\n@@ -1171,4 +1166,0 @@\n-          if (k->name()->is_Q_array_signature()) {\n-            \/\/ Logically creates elements, ensure klass init\n-            k->initialize(CHECK);\n-          }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -945,1 +945,0 @@\n-      case Bytecodes::_aconst_init:\n@@ -948,15 +947,0 @@\n-      case Bytecodes::_withfield: {\n-        bool will_link;\n-        ciField* field = s.get_field(will_link);\n-        BasicType field_type = field->type()->basic_type();\n-        if (field_type == T_OBJECT || field_type == T_ARRAY) {\n-          set_global_escape(state.apop());\n-        } else if (type2size[field_type] == 1) {\n-          state.spop();\n-        } else {\n-          state.lpop();\n-        }\n-        set_method_escape(state.apop());\n-        state.apush(allocated_obj);\n-        break;\n-      }\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -532,2 +532,1 @@\n-       sym->char_at(1) == JVM_SIGNATURE_CLASS ||\n-       sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT )) {\n+       sym->char_at(1) == JVM_SIGNATURE_CLASS )) {\n@@ -546,1 +545,4 @@\n-      bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+      \/\/ JEP 401 doesn't provide static information about null-freeness,\n+      \/\/ This code should be revisited or removed: JDK-8325660\n+      bool null_free_array = false;\n+      \/\/ bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n@@ -577,11 +579,0 @@\n-  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n-    \/\/ An unloaded array class of inline types is an ObjArrayKlass, an\n-    \/\/ unloaded inline type class is an InstanceKlass. For consistency,\n-    \/\/ make the signature of the unloaded array of inline type use L\n-    \/\/ rather than Q.\n-    char* new_name = name_buffer(sym->utf8_length()+1);\n-    strncpy(new_name, (char*)sym->base(), sym->utf8_length());\n-    new_name[i] = JVM_SIGNATURE_CLASS;\n-    new_name[sym->utf8_length()] = '\\0';\n-    return get_unloaded_klass(accessing_klass, ciSymbol::make(new_name));\n-  }\n@@ -674,8 +665,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciEnv::is_inline_klass\n-\/\/\n-\/\/ Check if the klass is an inline klass.\n-bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n-  GUARDED_VM_ENTRY(return cpool->klass_name_at(index)->is_Q_signature();)\n-}\n-\n@@ -778,5 +761,1 @@\n-    if (klass->is_loaded() && tag.is_Qdescriptor_klass()) {\n-      return ciConstant(T_OBJECT, klass->as_inline_klass()->val_mirror());\n-    } else {\n-      return ciConstant(T_OBJECT, mirror);\n-    }\n+    return ciConstant(T_OBJECT, mirror);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-  bool       has_Q_signature(const constantPoolHandle& cpool,\n-                             int klass_index);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-  _is_null_free = _signature->is_Q_signature();\n+  \/\/ _is_null_free = _signature->is_Q_signature();\n+  _is_null_free = false; \/\/ JDK-8325660: null free-ness should be checked in FieldFlags instead of signature\n@@ -410,2 +411,2 @@\n-         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield  ||\n-         bc == Bytecodes::_withfield, \"unexpected bytecode\");\n+         bc == Bytecodes::_getfield  || bc == Bytecodes::_putfield,\n+         \"unexpected bytecode\");\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,14 +118,0 @@\n-ciInstance* ciInlineKlass::ref_instance() const {\n-  GUARDED_VM_ENTRY(\n-    oop ref_mirror = to_InlineKlass()->ref_mirror();\n-    return CURRENT_ENV->get_instance(ref_mirror);\n-  )\n-}\n-\n-ciInstance* ciInlineKlass::val_instance() const {\n-  GUARDED_VM_ENTRY(\n-    oop val_mirror = to_InlineKlass()->val_mirror();\n-    return CURRENT_ENV->get_instance(val_mirror);\n-  )\n-}\n-\n@@ -152,7 +138,0 @@\n-ciInstance* ciInlineKlass::ref_mirror() {\n-  GUARDED_VM_ENTRY(return CURRENT_ENV->get_instance(to_InlineKlass()->ref_mirror());)\n-}\n-\n-ciInstance* ciInlineKlass::val_mirror() {\n-  GUARDED_VM_ENTRY(return CURRENT_ENV->get_instance(to_InlineKlass()->val_mirror());)\n-}\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -87,2 +87,0 @@\n-  ciInstance* ref_instance() const;\n-  ciInstance* val_instance() const;\n@@ -94,2 +92,0 @@\n-  ciInstance* ref_mirror();\n-  ciInstance* val_mirror();\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-ciType* ciInstance::java_mirror_type(bool* is_val_mirror) {\n+ciType* ciInstance::java_mirror_type() {\n@@ -56,3 +56,0 @@\n-    if (is_val_mirror != nullptr) {\n-      *is_val_mirror = java_lang_Class::is_secondary_mirror(m);\n-    }\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  ciType* java_mirror_type(bool* is_val_mirror = nullptr);\n+  ciType* java_mirror_type();\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -697,1 +697,1 @@\n-    return !get_instanceKlass()->carries_identity_modifier();\n+    return !get_instanceKlass()->access_flags().is_identity_class();\n@@ -773,1 +773,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall-through\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1025,10 +1025,0 @@\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::is_static_vnew_factory\n-\/\/\n-bool ciMethod::is_static_vnew_factory() const {\n-   return (name() == ciSymbols::inline_factory_name()\n-           && !signature()->return_type()->is_void());\n-   \/\/ Note:  We can't test is_static, because that would\n-   \/\/ require the method to be loaded.  Sometimes it isn't.\n-}\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -365,1 +365,0 @@\n-  bool is_static_vnew_factory() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,4 @@\n-  _null_free = k->name()->is_Q_array_signature() && k->name()->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+  \/\/ JEP 401 doesn't provide static information about null-freeness,\n+  \/\/ This code should be revisited or removed: JDK-8325660\n+  \/\/ _null_free = k->name()->is_Q_array_signature() && k->name()->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+  _null_free = false;\n@@ -78,1 +81,4 @@\n-  _null_free = array_name->is_Q_array_signature() && array_name->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+  \/\/ JEP 401 doesn't provide static information about null-freeness,\n+  \/\/ This code should be revisited or removed: JDK-8325660\n+  \/\/ _null_free = array_name->is_Q_array_signature() && array_name->char_at(1) == JVM_SIGNATURE_PRIMITIVE_OBJECT;\n+  _null_free = false;\n@@ -123,1 +129,0 @@\n-  assert(base_name_sym->char_at(0) != JVM_SIGNATURE_PRIMITIVE_OBJECT, \"unloaded array klass element should not have Q-type\");\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1085,1 +1085,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -1152,2 +1151,1 @@\n-        } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &&\n-                   field_signature[1] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+        } else if (field_signature[0] == JVM_SIGNATURE_ARRAY) {\n@@ -1242,1 +1240,1 @@\n-    } else if (field_signature[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+    } else if (fd.is_null_free_inline_type()) {\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,3 +64,0 @@\n-      if (type->is_inlinetype() && ss.has_Q_descriptor()) {\n-        type = env->make_null_free_wrapper(type);\n-      }\n@@ -75,6 +72,0 @@\n-\/\/ ciSignature::returns_null_free_inline_type\n-bool ciSignature::returns_null_free_inline_type() const {\n-  GUARDED_VM_ENTRY(return get_symbol()->is_Q_method_signature();)\n-}\n-\n-\/\/ ------------------------------------------------------------------\n","filename":"src\/hotspot\/share\/ci\/ciSignature.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  bool      returns_null_free_inline_type() const;\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -176,1 +176,0 @@\n-  case Bytecodes::_aconst_init:\n@@ -211,10 +210,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciBytecodeStream::is_inline_klass\n-\/\/\n-\/\/ Check if the klass is an inline klass.\n-bool ciBytecodeStream::has_Q_signature() const {\n-  VM_ENTRY_MARK;\n-  constantPoolHandle cpool(THREAD, _method->get_Method()->constants());\n-  return CURRENT_ENV->has_Q_signature(cpool, get_klass_index());\n-}\n-\n@@ -311,2 +300,1 @@\n-         cur_bc() == Bytecodes::_putstatic ||\n-         cur_bc() == Bytecodes::_withfield, \"wrong bc\");\n+         cur_bc() == Bytecodes::_putstatic, \"wrong bc\");\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -220,1 +220,0 @@\n-  bool has_Q_signature() const;\n@@ -329,1 +328,2 @@\n-      return _sig->returns_null_free_inline_type();\n+      \/\/ return _sig->returns_null_free_inline_type();\n+      return false; \/\/ JDK-8325660: code to be revisited after removal of Q-descriptors\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,12 +116,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciSymbol::is_Q_signature\n-bool ciSymbol::is_Q_signature() const {\n-  GUARDED_VM_ENTRY(return get_symbol()->is_Q_signature();)\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciSymbol::is_Q_array_signature\n-bool ciSymbol::is_Q_array_signature() const {\n-  GUARDED_VM_ENTRY(return get_symbol()->is_Q_array_signature();)\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,3 +89,0 @@\n-  bool is_Q_signature() const;\n-  bool is_Q_array_signature() const;\n-\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -623,1 +623,2 @@\n-  bool null_free = str->has_Q_signature();\n+  \/\/ bool null_free = str->has_Q_signature();\n+  bool null_free = false; \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -1027,1 +1028,2 @@\n-        bool null_free = str->has_Q_signature();\n+        \/\/bool null_free = str->has_Q_signature();\n+        bool null_free = false; \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -1560,3 +1562,0 @@\n-  case Bytecodes::_aconst_init: do_aconst_init(str);              break;\n-  case Bytecodes::_withfield: do_withfield(str);                    break;\n-\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -520,5 +520,1 @@\n-        if (name->is_Q_signature()) {\n-          cp->unresolved_qdescriptor_at_put(index, class_index, num_klasses++);\n-        } else {\n-          cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n-        }\n+        cp->unresolved_klass_at_put(index, class_index, num_klasses++);\n@@ -724,2 +720,1 @@\n-          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature,\n-          \/\/ or if it is an inline type, <vnew> with return.\n+          \/\/ If a class method name begins with '<', it must be \"<init>\" and have void signature.\n@@ -729,2 +724,1 @@\n-            if (name != vmSymbols::object_initializer_name() &&\n-                name != vmSymbols::inline_factory_name()) {\n+            if (name != vmSymbols::object_initializer_name()) {\n@@ -735,7 +729,2 @@\n-            } else if (!Signature::is_void_method(signature)) {\n-              \/\/ if return type is non-void then it must be an inline type\n-              if (name == vmSymbols::object_initializer_name() ||\n-                  !EnableValhalla || !supports_inline_types() ||\n-                  !signature->ends_with(JVM_SIGNATURE_ENDCLASS)) {\n-                throwIllegalSignature(\"Method\", name, signature, CHECK);\n-              }\n+            } else if (!Signature::is_void_method(signature)) {  \/\/ must have void signature.\n+              throwIllegalSignature(\"Method\", name, signature, CHECK);\n@@ -761,11 +750,1 @@\n-            if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) { \/\/ <vnew>\n-              \/\/ <vnew> factory methods must be non-void return and invokeStatic.\n-              const int signature_ref_index =\n-                cp->signature_ref_index_at(name_and_type_ref_index);\n-              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n-              if (signature->is_void_method_signature() || ref_kind != JVM_REF_invokeStatic) {\n-                classfile_parse_error(\n-                  \"Bad factory method name at constant pool index %u in class file %s\",\n-                  name_ref_index, CHECK);\n-              }\n-            } else if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n+            if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n@@ -841,23 +820,5 @@\n-  if (super_type->carries_identity_modifier()) {\n-    if (current->carries_value_modifier()) {\n-        ResourceMark rm(THREAD);\n-        Exceptions::fthrow(\n-          THREAD_AND_LOCATION,\n-          vmSymbols::java_lang_IncompatibleClassChangeError(),\n-          \"Value type %s has an identity type as supertype\",\n-          current->class_name()->as_klass_external_name());\n-        return;\n-      }\n-    current->set_carries_identity_modifier();\n-  }\n-  if (super_type->carries_value_modifier()) {\n-    if (current->carries_identity_modifier()) {\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_IncompatibleClassChangeError(),\n-        \"Identity type %s has a value type as supertype\",\n-        current->class_name()->as_klass_external_name());\n-      return;\n-    }\n-    current->set_carries_value_modifier();\n+  if (super_type->access_flags().is_identity_class() && !current->access_flags().is_identity_class()\n+      && super_type->super() != nullptr \/* Super is not j.l.Object *\/) {\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Value type %s has an identity type as supertype\",\n+                current->class_name()->as_klass_external_name()));\n@@ -1496,1 +1457,1 @@\n-  bool is_inline_type = class_access_flags.is_value_class() && !class_access_flags.is_abstract();\n+  bool is_inline_type = !class_access_flags.is_identity_class() && !class_access_flags.is_abstract();\n@@ -1605,0 +1566,1 @@\n+    \/\/ This use of T_PRIMITIVE_OBJECT is not valid anymore => FIXME (relate to cleanup (removal?) of FiedAllocationCount\n@@ -1607,5 +1569,1 @@\n-    \/\/ Here, we still detect that the field's type is an inline type by checking if it has\n-    \/\/ a Q-descriptor. This test will be replaced later by something not relying on Q-desriptors.\n-    \/\/ From this point forward, checking if a field's type is an inline type should be performed\n-    \/\/ using the inline_type flag of FieldFlags, and not by looking for a Q-descriptor in its signature\n-    if (type == T_PRIMITIVE_OBJECT || is_null_restricted) fieldFlags.update_null_free_inline_type(true);\n+    if (is_null_restricted) fieldFlags.update_null_free_inline_type(true);\n@@ -2358,48 +2316,3 @@\n-  if (EnableValhalla && supports_inline_types() && name == vmSymbols::inline_factory_name()) {\n-    if (is_interface) {\n-      classfile_parse_error(\"Interface cannot have a method named <vnew>, class file %s\", CHECK_NULL);\n-    } else if (!is_value_class) {\n-       classfile_parse_error(\"Identity class cannot have a method <vnew>, class file %s\", CHECK_NULL);\n-    } else if (signature->is_void_method_signature()) {\n-       classfile_parse_error(\"Factory method <vnew> must have a non-void return type, class file %s\", CHECK_NULL);\n-    } else { \/\/ also OK, a static factory, as long as the return value is good\n-      bool ok = false;\n-      SignatureStream ss((Symbol*) signature, true);\n-      while (!ss.at_return_type())  ss.next();\n-      if (ss.is_reference()) {\n-        Symbol* ret = ss.as_symbol();\n-        const Symbol* required = class_name();\n-        if (is_hidden()) {\n-          \/\/ The original class name for hidden classes changed.\n-          \/\/\/ So using the original name in the return type is no longer valid.\n-          required = vmSymbols::java_lang_Object();\n-        }\n-        ok = (ret == required);\n-      }\n-      if (!ok) {\n-        throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-      }\n-      \/\/ factory method, with a non-void return.  No other\n-      \/\/ definition of <vnew> is possible.\n-      \/\/\n-      \/\/ The verifier (in verify_invoke_instructions) will inspect the\n-      \/\/ signature of any attempt to invoke <vnew>, and ensure that it\n-      \/\/ returns non-void.\n-    }\n-  }\n-\n-  if (name == vmSymbols::object_initializer_name()) {\n-    if (is_interface) {\n-      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", CHECK_NULL);\n-    } else if ((!is_value_class || is_abstract_class) && signature->is_void_method_signature()) {\n-      \/\/ OK, a constructor\n-    } else {\n-      \/\/ not OK, so throw the same error as in verify_legal_method_signature.\n-      throwIllegalSignature(\"Method\", name, signature, CHECK_0);\n-    }\n-    \/\/ A declared <init> method must always be a non-static\n-    \/\/ object constructor, with a void return.\n-    \/\/\n-    \/\/ The verifier (in verify_invoke_instructions) will inspect the\n-    \/\/ signature of any attempt to invoke <init>, and ensure that it\n-    \/\/ returns void.\n+  if (name == vmSymbols::object_initializer_name() && is_interface) {\n+    classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n+    return nullptr;\n@@ -2411,1 +2324,1 @@\n-        && !carries_identity_modifier()) {\n+        && !_access_flags.is_identity_class()) {\n@@ -3280,3 +3193,0 @@\n-    if (supports_inline_types()) {\n-      recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY;\n-    }\n@@ -4544,1 +4454,1 @@\n-    if (this_klass->access_flags().is_value_class() &&\n+    if (!this_klass->access_flags().is_identity_class() &&\n@@ -4738,2 +4648,0 @@\n-  const bool is_value_class = (flags & JVM_ACC_VALUE) != 0;\n-  const bool is_primitive_class = (flags & JVM_ACC_PRIMITIVE) != 0;\n@@ -4753,22 +4661,0 @@\n-  if (is_value_class && !EnableValhalla) {\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_ClassFormatError(),\n-        \"Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla\",\n-        _class_name->as_C_string()\n-      );\n-    return;\n-  }\n-\n-  if (is_primitive_class && !EnablePrimitiveClasses) {\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_ClassFormatError(),\n-        \"Class modifier ACC_PRIMITIVE in class %s requires option -XX:+EnablePrimitiveClasses\",\n-        _class_name->as_C_string()\n-      );\n-    return;\n-  }\n-\n@@ -4780,1 +4666,1 @@\n-  const bool is_super      = (flags & JVM_ACC_SUPER)      != 0;\n+  const bool is_identity   = (flags & JVM_ACC_IDENTITY)   != 0;\n@@ -4787,1 +4673,1 @@\n-      (is_interface && major_gte_1_5 && ((is_super && (!EnableValhalla || !supports_inline_types())) || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (is_interface && major_gte_1_5 && (is_identity || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n@@ -4789,4 +4675,1 @@\n-      (is_value_class && is_enum) ||\n-      (is_identity_class && is_value_class) ||\n-      (EnableValhalla && supports_inline_types() && !is_module && !is_abstract && !is_Object && !(is_identity_class || is_value_class) && !is_inner_class) ||\n-      (EnablePrimitiveClasses && supports_inline_types() && is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n+      (!is_identity_class && is_enum)) {\n@@ -4795,3 +4678,1 @@\n-    if (is_value_class)  class_note = \" (a value class)\";\n-    if (is_primitive_class)  class_note = \" (a primitive class)\";\n-    if (is_value_class && is_identity_class) class_note = \" (a value and identity class)\";\n+    if (!is_identity_class)  class_note = \" (a value class)\";\n@@ -4897,1 +4778,0 @@\n-  const bool is_value_class = class_access_flags.is_value_class();\n@@ -4912,1 +4792,1 @@\n-      if (is_value_class && !is_abstract && !is_static && !is_final) {\n+      if (!is_identity_class && !is_abstract && !is_static && !is_final) {\n@@ -4951,1 +4831,1 @@\n-  const bool is_factory      = (name == vmSymbols::inline_factory_name() && supports_inline_types());\n+  \/\/ LW401 CR required: removal of value factories support\n@@ -4953,1 +4833,1 @@\n-  const bool is_value_class  = class_access_flags.is_value_class();\n+  const bool is_value_class  = !class_access_flags.is_identity_class();\n@@ -4993,7 +4873,1 @@\n-      if (is_factory) { \/\/ <vnew> factory method\n-        if (is_final || is_synchronized || is_native || !is_static ||\n-            is_abstract || is_bridge) {\n-          is_illegal = true;\n-          class_note = (is_value_class ? \" (a value class)\" : \" (not a value class)\");\n-        }\n-      } else if (is_initializer) {\n+      if (is_initializer) {\n@@ -5203,10 +5077,0 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n-      \/\/ Can't enable this check fully until JDK upgrades the bytecode generators (TODO: JDK-8270852).\n-      \/\/ For now, compare to class file version 51 so old verifier doesn't see Q signatures.\n-      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses)) {\n-        classfile_parse_error(\"Class name contains illegal Q-signature \"\n-                              \"in descriptor in class file %s, requires option -XX:+EnablePrimitiveClasses\",\n-                              CHECK_0);\n-        return nullptr;\n-      }\n-      \/\/ fall through\n@@ -5351,3 +5215,1 @@\n-          name == vmSymbols::class_initializer_name()  ||\n-          (EnableValhalla && supports_inline_types() &&\n-          name == vmSymbols::inline_factory_name())) {\n+          name == vmSymbols::class_initializer_name()) {\n@@ -5385,3 +5247,0 @@\n-  if ((!supports_inline_types() || !EnablePrimitiveClasses) && (signature->is_Q_signature() || signature->is_Q_array_signature())) {\n-    throwIllegalSignature(\"Field\", name, signature, CHECK);\n-  }\n@@ -5415,8 +5274,6 @@\n-  if (!is_value_class()) {\n-    int sig_length = signature->utf8_length();\n-    if (name->utf8_length() > 0 &&\n-      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-      sig_length > 0 &&\n-      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n-      throwIllegalSignature(\"Method\", name, signature, THREAD);\n-    }\n+  int sig_length = signature->utf8_length();\n+  if (name->utf8_length() > 0 &&\n+    name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+    sig_length > 0 &&\n+    signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    throwIllegalSignature(\"Method\", name, signature, THREAD);\n@@ -5637,6 +5494,0 @@\n-  if (carries_identity_modifier()) {\n-    ik->set_carries_identity_modifier();\n-  } else if (carries_value_modifier()) {\n-    ik->set_carries_value_modifier();\n-  }\n-\n@@ -5984,2 +5835,0 @@\n-  _carries_value_modifier(false),\n-  _carries_identity_modifier(false),\n@@ -6180,4 +6029,0 @@\n-  \/\/ JVM_ACC_VALUE and JVM_ACC_PRIMITIVE supported version\n-  if (supports_inline_types()) {\n-    recognized_modifiers |= JVM_ACC_PRIMITIVE | JVM_ACC_VALUE;\n-  }\n@@ -6220,8 +6065,0 @@\n-  if (EnableValhalla) {\n-    if (_access_flags.is_identity_class()) set_carries_identity_modifier();\n-    if (_access_flags.is_value_class()) set_carries_value_modifier();\n-    if (carries_identity_modifier() && carries_value_modifier()) {\n-      classfile_parse_error(\"Class %s has both ACC_IDENTITY and ACC_VALUE modifiers\", THREAD);\n-    }\n-  }\n-\n@@ -6330,1 +6167,1 @@\n-                is_value_class(),\n+                !is_identity_class(),\n@@ -6452,1 +6289,1 @@\n-    if (EnableValhalla && _access_flags.is_value_class()) {\n+    if (EnableValhalla && !_access_flags.is_identity_class()) {\n@@ -6467,1 +6304,1 @@\n-  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && !_access_flags.is_value_class()) {\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && _access_flags.is_identity_class()) {\n@@ -6472,1 +6309,1 @@\n-  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_ImplicitlyConstructible) && !_access_flags.is_value_class()) {\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_ImplicitlyConstructible) && _access_flags.is_identity_class()) {\n@@ -6480,13 +6317,8 @@\n-  if (EnableValhalla && _access_flags.is_value_class()) {\n-    if (_access_flags.is_primitive_class()) {\n-      _must_be_atomic = false;             \/\/ old semantic, primitive classes are always non-atomic\n-      _is_implicitly_constructible = true; \/\/ old semantic, primitive classes are always implicitly constructible\n-    } else {\n-      if (_super_klass != nullptr  \/\/ not j.l.Object\n-               && _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n-               && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n-        _must_be_atomic = false;\n-      }\n-      if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)) {\n-        _is_implicitly_constructible = true;\n-      }\n+  if (EnableValhalla && !_access_flags.is_identity_class()) {\n+    if (_super_klass != nullptr  \/\/ not j.l.Object\n+              && _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+              && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+      _must_be_atomic = false;\n+    }\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)) {\n+      _is_implicitly_constructible = true;\n@@ -6598,1 +6430,1 @@\n-        if (!klass->access_flags().is_value_class()) {\n+        if (klass->access_flags().is_identity_class()) {\n@@ -6602,1 +6434,17 @@\n-                    err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                    err_msg(\"Class %s expects class %s to be concrete value type, but it is an identity class\",\n+                    _class_name->as_C_string(),\n+                    InstanceKlass::cast(klass)->external_name()));\n+        }\n+        if (klass->is_abstract()) {\n+          assert(klass->is_instance_klass(), \"Sanity check\");\n+          ResourceMark rm(THREAD);\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Class %s expects class %s to be concrete value type, but it is an abstract class\",\n+                    _class_name->as_C_string(),\n+                    InstanceKlass::cast(klass)->external_name()));\n+        }\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        if (!vk->is_implicitly_constructible()) {\n+          ResourceMark rm(THREAD);\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Class %s expects class %s to be implicitly constructible, but it is not\",\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":64,"deletions":216,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -212,2 +212,0 @@\n-  bool _carries_value_modifier;      \/\/ Has ACC_VALUE mddifier or one of its super types has\n-  bool _carries_identity_modifier;   \/\/ Has ACC_IDENTITY modifier or one of its super types has\n@@ -599,2 +597,1 @@\n-  bool is_inline_type() const { return _access_flags.is_value_class() && !_access_flags.is_interface() && !_access_flags.is_abstract(); }\n-  bool is_value_class() const { return _access_flags.is_value_class(); }\n+  bool is_inline_type() const { return !_access_flags.is_identity_class() && !_access_flags.is_interface() && !_access_flags.is_abstract(); }\n@@ -603,1 +600,0 @@\n-  bool is_value_capable_class() const;\n@@ -605,4 +601,0 @@\n-  bool carries_identity_modifier() const { return _carries_identity_modifier; }\n-  void set_carries_identity_modifier() { _carries_identity_modifier = true; }\n-  bool carries_value_modifier() const { return _carries_value_modifier; }\n-  void set_carries_value_modifier() { _carries_value_modifier = true; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    if (*start == JVM_SIGNATURE_CLASS || *start == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+    if (*start == JVM_SIGNATURE_CLASS) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -636,1 +636,0 @@\n-    case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n@@ -641,0 +640,1 @@\n+        assert(type != T_ARRAY, \"null free ptr to array not supported\");\n@@ -652,3 +652,1 @@\n-          if (!vk->is_implicitly_constructible()) {\n-            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n-          }\n+          assert(vk->is_implicitly_constructible(), \"must be, should have been checked in post_process_parsed_stream()\");\n@@ -739,1 +737,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n@@ -747,0 +744,1 @@\n+        assert(type != T_ARRAY, \"null free ptr to array not supported\");\n@@ -758,3 +756,1 @@\n-          if (!vk->is_implicitly_constructible()) {\n-            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n-          }\n+          assert(vk->is_implicitly_constructible(), \"must be, should have been checked in post_process_parsed_stream()\");\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -793,2 +793,1 @@\n-int java_lang_Class::_primary_mirror_offset;\n-int java_lang_Class::_secondary_mirror_offset;\n+\n@@ -1000,2 +999,1 @@\n-        InlineKlass* vk = InlineKlass::cast(element_klass);\n-        comp_mirror = Handle(THREAD, vk->val_mirror());\n+        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n@@ -1017,1 +1015,1 @@\n-        comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+        comp_oop = ik->java_mirror();\n@@ -1085,5 +1083,0 @@\n-    if (k->is_inline_klass()) {\n-      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n-      set_primary_mirror(mirror(), mirror());\n-      set_secondary_mirror(mirror(), secondary_mirror);\n-    }\n@@ -1098,19 +1091,0 @@\n-\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n-\/\/ instance with the same value as the primary mirror\n-oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n-  assert(k->is_inline_klass(), \"primitive class\");\n-  \/\/ Allocate mirror (java.lang.Class instance)\n-  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n-  Handle secondary_mirror(THREAD, mirror_oop);\n-\n-  java_lang_Class::set_klass(secondary_mirror(), k);\n-  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n-\n-  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n-  set_class_loader(secondary_mirror(), class_loader(mirror()));\n-  \/\/ ## handle if java.base is not yet defined\n-  set_module(secondary_mirror(), module(mirror()));\n-  set_primary_mirror(secondary_mirror(), mirror());\n-  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n-  return secondary_mirror();\n-}\n@@ -1247,20 +1221,0 @@\n-oop java_lang_Class::primary_mirror(oop java_class) {\n-  assert(_primary_mirror_offset != 0, \"must be set\");\n-  return java_class->obj_field(_primary_mirror_offset);\n-}\n-\n-void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n-  assert(_primary_mirror_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_primary_mirror_offset, mirror);\n-}\n-\n-oop java_lang_Class::secondary_mirror(oop java_class) {\n-  assert(_secondary_mirror_offset != 0, \"must be set\");\n-  return java_class->obj_field(_secondary_mirror_offset);\n-}\n-\n-void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n-  assert(_secondary_mirror_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n-}\n-\n@@ -1351,1 +1305,0 @@\n-  bool is_Q_descriptor = false;\n@@ -1357,1 +1310,0 @@\n-    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1365,1 +1317,1 @@\n-    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n+    st->print(\"L\");\n@@ -1387,7 +1339,2 @@\n-      const char* sigstr;\n-      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n-        sigstr = InlineKlass::cast(k)->val_signature_name();\n-      } else {\n-        sigstr = k->signature_name();\n-      }\n-      int siglen = (int) strlen(sigstr);\n+      const char* sigstr = k->signature_name();\n+      int         siglen = (int) strlen(sigstr);\n@@ -1481,2 +1428,0 @@\n-  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n-  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":61,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -233,2 +233,0 @@\n-  static int _primary_mirror_offset;\n-  static int _secondary_mirror_offset;\n@@ -249,2 +247,0 @@\n-  static void set_primary_mirror(oop java_class, oop comp_mirror);\n-  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n@@ -266,1 +262,0 @@\n-  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -297,2 +292,1 @@\n-  static int primary_mirror_offset()       { CHECK_INIT(_primary_mirror_offset); }\n-  static int secondary_mirror_offset()     { CHECK_INIT(_secondary_mirror_offset); }\n+\n@@ -306,4 +300,0 @@\n-  static oop  primary_mirror(oop java_class);\n-  static oop  secondary_mirror(oop java_class);\n-  static bool is_primary_mirror(oop java_class);\n-  static bool is_secondary_mirror(oop java_class);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -306,18 +306,0 @@\n-inline bool java_lang_Class::is_primary_mirror(oop java_class) {\n-  Klass* k = as_Klass(java_class);\n-  if (k->is_inline_klass()) {\n-    return java_class == primary_mirror(java_class);\n-  } else {\n-    return true;\n-  }\n-}\n-\n-inline bool java_lang_Class::is_secondary_mirror(oop java_class) {\n-  Klass* k = as_Klass(java_class);\n-  if (k->is_inline_klass()) {\n-    return java_class == secondary_mirror(java_class);\n-  } else {\n-    return false;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -115,3 +114,0 @@\n-      if (ss.type() == T_PRIMITIVE_OBJECT) {\n-        return VerificationType::inline_type(sig);\n-      }\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -193,10 +193,1 @@\n-    if (klass_name->is_Q_signature()) {\n-      Symbol* fund_name = klass_name->fundamental_name(THREAD);\n-      if (fund_name == nullptr) {\n-        _stream->stackmap_format_error(\"TBD something bad happened\", THREAD);\n-        return VerificationType::bogus_type();\n-      }\n-      return VerificationType::inline_type(fund_name);\n-    } else {\n-      return VerificationType::reference_type(klass_name);\n-    }\n+    return VerificationType::reference_type(klass_name);\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -370,8 +370,1 @@\n-      if (class_name->is_Q_array_signature()) {\n-        if (!k->is_inline_klass()) {\n-          THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n-        }\n-        k = InlineKlass::cast(k)->value_array_klass(ndims, CHECK_NULL);\n-      } else {\n-        k = k->array_klass(ndims, CHECK_NULL);\n-      }\n+      k = k->array_klass(ndims, CHECK_NULL);\n@@ -837,1 +830,1 @@\n-    if (t != T_OBJECT && t != T_PRIMITIVE_OBJECT) {\n+    if (t != T_OBJECT) {\n@@ -843,5 +836,1 @@\n-      if (class_name->is_Q_array_signature()) {\n-        k = InlineKlass::cast(k)->value_array_klass_or_null(ndims);\n-      } else {\n-        k = k->array_klass_or_null(ndims);\n-      }\n+      k = k->array_klass_or_null(ndims);\n@@ -1807,1 +1796,1 @@\n-    if (t != T_OBJECT && t != T_PRIMITIVE_OBJECT) {\n+    if (t != T_OBJECT) {\n@@ -1815,5 +1804,1 @@\n-      if (class_name->is_Q_array_signature()) {\n-        klass = InlineKlass::cast(klass)->value_array_klass_or_null(ndims);\n-      } else {\n-        klass = klass->array_klass_or_null(ndims);\n-      }\n+      klass = klass->array_klass_or_null(ndims);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -68,6 +68,6 @@\n-  if (this_class->access_flags().is_primitive_class()) {\n-    Klass* from_class = SystemDictionary::resolve_or_fail(\n-      from_name, Handle(THREAD, klass->class_loader()),\n-      Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n-    return from_class == this_class;\n-  }\n+  \/\/ if (this_class->access_flags().is_primitive_class()) {\n+  \/\/   Klass* from_class = SystemDictionary::resolve_or_fail(\n+  \/\/     from_name, Handle(THREAD, klass->class_loader()),\n+  \/\/     Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n+  \/\/   return from_class == this_class;\n+  \/\/ }\n@@ -224,2 +224,1 @@\n-    case T_OBJECT:\n-    case T_PRIMITIVE_OBJECT: {\n+    case T_OBJECT: {\n@@ -231,3 +230,1 @@\n-      return (ss.type() == T_PRIMITIVE_OBJECT) ?\n-        VerificationType::inline_type(component_copy) :\n-        VerificationType::reference_type(component_copy);\n+      return VerificationType::reference_type(component_copy);\n@@ -269,2 +266,0 @@\n-      } else if (is_inline_type()) {\n-        name()->print_Qvalue_on(st);\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -244,1 +244,0 @@\n-  bool is_inline_type_array() const { return is_x_array(JVM_SIGNATURE_PRIMITIVE_OBJECT); }\n@@ -248,1 +247,1 @@\n-    { return is_object_array() || is_array_array() || is_inline_type_array(); }\n+    { return is_object_array() || is_array_array(); }\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -602,5 +602,6 @@\n-  if (klass->is_inline_klass()) {\n-    return VerificationType::inline_type(klass->name());\n-  } else {\n-    return VerificationType::reference_type(klass->name());\n-  }\n+  \/\/ if (klass->is_inline_klass()) {\n+  \/\/   return VerificationType::inline_type(klass->name());\n+  \/\/ } else {\n+  \/\/   return VerificationType::reference_type(klass->name());\n+  \/\/ }  \/\/ LW401 CR required: verifier update\/cleanup\n+  return VerificationType::reference_type(klass->name());\n@@ -1722,11 +1723,0 @@\n-        case Bytecodes::_withfield :\n-          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n-            class_format_error(\n-              \"withfield not supported by this class file version (%d.%d), class %s\",\n-              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n-            return;\n-          }\n-          \/\/ pass FALSE, operand can't be an array type for withfield.\n-          verify_field_instructions(\n-            &bcs, &current_frame, cp, false, CHECK_VERIFY(this));\n-          no_control_flow = false; break;\n@@ -1758,22 +1748,0 @@\n-        case Bytecodes::_aconst_init :\n-        {\n-          if (_klass->major_version() < INLINE_TYPE_MAJOR_VERSION) {\n-            class_format_error(\n-              \"aconst_init not supported by this class file version (%d.%d), class %s\",\n-              _klass->major_version(), _klass->minor_version(), _klass->external_name());\n-            return;\n-          }\n-          u2 index = bcs.get_index_u2();\n-          verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));\n-          VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));\n-          if (!ref_type.is_object()) {\n-            verify_error(ErrorContext::bad_type(bci,\n-                TypeOrigin::cp(index, ref_type)),\n-                \"Illegal aconst_init instruction\");\n-            return;\n-          }\n-          VerificationType inline_type =\n-            VerificationType::change_ref_to_inline_type(ref_type);\n-          current_frame.push_stack(inline_type, CHECK_VERIFY(this));\n-          no_control_flow = false; break;\n-        }\n@@ -2416,11 +2384,0 @@\n-    case Bytecodes::_withfield: {\n-      for (int i = n - 1; i >= 0; i--) {\n-        current_frame->pop_stack(field_type[i], CHECK_VERIFY(this));\n-      }\n-      \/\/ Check that the receiver is a subtype of the referenced class.\n-      current_frame->pop_stack(target_class_type, CHECK_VERIFY(this));\n-      VerificationType target_inline_type =\n-        VerificationType::change_ref_to_inline_type(target_class_type);\n-      current_frame->push_stack(target_inline_type, CHECK_VERIFY(this));\n-      break;\n-    }\n@@ -2950,5 +2907,2 @@\n-    \/\/   <vnew> can only be invoked by invokestatic.\n-    if (!((opcode == Bytecodes::_invokestatic &&\n-           method_name == vmSymbols::inline_factory_name()) ||\n-         (opcode == Bytecodes::_invokespecial &&\n-          method_name == vmSymbols::object_initializer_name()))) {\n+    if (opcode != Bytecodes::_invokespecial ||\n+          method_name != vmSymbols::object_initializer_name()) {\n@@ -3060,7 +3014,0 @@\n-  } else { \/\/ no return type\n-    \/\/ <vnew> method may not have a void return type\n-    if (method_name == vmSymbols::inline_factory_name()) {\n-      verify_error(ErrorContext::bad_code(bci),\n-          \"Return type must be non-void in <vnew> static factory method\");\n-      return;\n-    }\n@@ -3114,2 +3061,1 @@\n-    char Q_or_L = component_type.is_inline_type() ? JVM_SIGNATURE_PRIMITIVE_OBJECT : JVM_SIGNATURE_CLASS;\n-    \/\/ add one dimension to component with 'L' or 'Q' prepended and ';' appended.\n+    \/\/ add one dimension to component with 'L' prepended and ';' postpended.\n@@ -3119,1 +3065,1 @@\n-                         JVM_SIGNATURE_ARRAY, Q_or_L, component_name);\n+                         JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":10,"deletions":64,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -453,6 +453,0 @@\n-    if (name->is_Q_signature()) {\n-      \/\/ Remove the Q and ;\n-      \/\/ TBD need error msg if fundamental_name() returns nullptr?\n-      Symbol* fund_name = name->fundamental_name(CHECK_(VerificationType::bogus_type()));\n-      return VerificationType::inline_type(fund_name);\n-    }\n@@ -500,9 +494,0 @@\n-    case T_PRIMITIVE_OBJECT:\n-      {\n-        Symbol* vname = sig_type->as_symbol();\n-        \/\/ Create another symbol to save as signature stream unreferences this symbol.\n-        Symbol* vname_copy = create_temporary_symbol(vname);\n-        assert(vname_copy == vname, \"symbols don't match\");\n-        *inference_type = VerificationType::inline_type(vname_copy);\n-        return 1;\n-      }\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -398,1 +398,0 @@\n-  template(inline_factory_name,                       \"<vnew>\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -475,2 +475,0 @@\n-    case Bytecodes::_aconst_init:\n-    case Bytecodes::_withfield:\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,3 +306,2 @@\n-          !vmSymbols::class_initializer_name()->equals(method_name) &&\n-          !vmSymbols::inline_factory_name()->equals(method_name)) {\n-        error_msg = \"Chars '<' and '>' only allowed in <init>, <clinit> and <vnew>\";\n+          !vmSymbols::class_initializer_name()->equals(method_name)) {\n+        error_msg = \"Chars '<' and '>' only allowed in <init>, <clinit>\";\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-                                        JVM_ACC_SUPER | \\\n+                                        JVM_ACC_IDENTITY | \\\n","filename":"src\/hotspot\/share\/include\/jvm_constants.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    number_of_result_handlers = 11                              \/\/ number of result handlers for native calls\n+    number_of_result_handlers = 10                              \/\/ number of result handlers for native calls\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -251,1 +251,0 @@\n-  bool is_withfield() const                      { return java_code() == Bytecodes::_withfield; }\n@@ -259,2 +258,1 @@\n-                                                          is_putstatic()  ||\n-                                                          is_withfield(); }\n+                                                          is_putstatic(); }\n@@ -293,9 +291,0 @@\n-class Bytecode_aconst_init: public Bytecode {\n- public:\n-  Bytecode_aconst_init(Method* method, address bcp): Bytecode(method, bcp) { verify(); }\n-  void verify() const { assert(java_code() == Bytecodes::_aconst_init, \"check aconst_init\"); }\n-\n-  \/\/ Returns index\n-  long index() const   { return get_index_u2(Bytecodes::_aconst_init); };\n-};\n-\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -496,1 +496,0 @@\n-    case Bytecodes::_withfield:\n@@ -572,1 +571,0 @@\n-    case Bytecodes::_aconst_init:\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,1 +983,0 @@\n-    case Bytecodes::_withfield:\n@@ -1136,1 +1135,0 @@\n-    case Bytecodes::_withfield:\n@@ -1433,1 +1431,0 @@\n-    case Bytecodes::_withfield:\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -285,2 +285,0 @@\n-  def(_aconst_init     , \"aconst_init\"     , \"bkk\"  , nullptr    , T_OBJECT ,  1, true , _aconst_init    ) \\\n-  def(_withfield       , \"withfield\"       , \"bJJ\"  , nullptr    , T_OBJECT , -1, true , _withfield      ) \\\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,4 +248,0 @@\n-    \/\/ value-type bytecodes\n-    _aconst_init          = 203, \/\/ 0xcb\n-    _withfield            = 204, \/\/ 0xcc\n-\n@@ -430,1 +426,1 @@\n-    return (_getstatic <= java_code(code) && java_code(code) <= _putfield) || (EnableValhalla && java_code(code) == _withfield);\n+    return (_getstatic <= java_code(code) && java_code(code) <= _putfield);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,3 +161,1 @@\n-  oop java_class = tag.is_Qdescriptor_klass()\n-                      ? InlineKlass::cast(klass)->val_mirror()\n-                      : klass->java_mirror();\n+  oop java_class = klass->java_mirror();\n@@ -227,4 +225,0 @@\n-  if (klass->is_inline_klass()) {\n-    THROW(vmSymbols::java_lang_InstantiationError());\n-  }\n-\n@@ -255,130 +249,0 @@\n-JRT_ENTRY(void, InterpreterRuntime::aconst_init(JavaThread* current, ConstantPool* pool, int index))\n-  \/\/ Getting the InlineKlass\n-  Klass* k = pool->klass_at(index, CHECK);\n-  if (!k->is_inline_klass()) {\n-    \/\/ inconsistency with 'new' which throws an InstantiationError\n-    \/\/ in the future, aconst_init will just return null instead of throwing an exception\n-    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n-  }\n-  assert(k->is_inline_klass(), \"aconst_init argument must be the inline type class\");\n-  InlineKlass* vklass = InlineKlass::cast(k);\n-\n-  vklass->initialize(CHECK);\n-  oop res = vklass->default_value();\n-  current->set_vm_result(res);\n-JRT_END\n-\n-JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ResolvedFieldEntry* entry, uintptr_t ptr))\n-  assert(entry->is_valid(), \"Invalid ResolvedFieldEntry\");\n-  oop obj = nullptr;\n-  int recv_offset = type2size[as_BasicType((TosState)entry->tos_state())];\n-  assert(frame::interpreter_frame_expression_stack_direction() == -1, \"currently is -1 on all platforms\");\n-  int ret_adj = (recv_offset + type2size[T_OBJECT] )* AbstractInterpreter::stackElementSize;\n-  int offset = entry->field_offset();\n-  obj = (oopDesc*)(((uintptr_t*)ptr)[recv_offset * Interpreter::stackElementWords]);\n-  if (obj == nullptr) {\n-    THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n-  }\n-  assert(oopDesc::is_oop(obj), \"Verifying receiver\");\n-  assert(obj->klass()->is_inline_klass(), \"Must have been checked during resolution\");\n-  instanceHandle old_value_h(THREAD, (instanceOop)obj);\n-  oop ref = nullptr;\n-  if (entry->tos_state() == atos) {\n-    ref = *(oopDesc**)ptr;\n-  }\n-  Handle ref_h(THREAD, ref);\n-  InlineKlass* ik = InlineKlass::cast(old_value_h()->klass());\n-  \/\/ Ensure that the class is initialized or being initialized\n-  \/\/ If the class is in error state, the creation of a new value should not be allowed\n-  ik->initialize(CHECK_(ret_adj));\n-\n-  bool can_skip = false;\n-  switch(entry->tos_state()) {\n-    case ztos:\n-      if (old_value_h()->bool_field(offset) == (jboolean)(*(jint*)ptr)) can_skip = true;\n-      break;\n-    case btos:\n-      if (old_value_h()->byte_field(offset) == (jbyte)(*(jint*)ptr)) can_skip = true;\n-      break;\n-    case ctos:\n-      if (old_value_h()->char_field(offset) == (jchar)(*(jint*)ptr)) can_skip = true;\n-      break;\n-    case stos:\n-      if (old_value_h()->short_field(offset) == (jshort)(*(jint*)ptr)) can_skip = true;\n-      break;\n-    case itos:\n-      if (old_value_h()->int_field(offset) == *(jint*)ptr) can_skip = true;\n-      break;\n-    case ltos:\n-      if (old_value_h()->long_field(offset) == *(jlong*)ptr) can_skip = true;\n-      break;\n-    case ftos:\n-      if (memcmp(old_value_h()->field_addr<jfloat>(offset), (jfloat*)ptr, sizeof(jfloat)) == 0) can_skip = true;\n-      break;\n-    case dtos:\n-      if (memcmp(old_value_h()->field_addr<jdouble>(offset), (jdouble*)ptr, sizeof(jdouble)) == 0) can_skip = true;\n-      break;\n-    case atos:\n-      if (!entry->is_null_free_inline_type() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n-      break;\n-    default:\n-      break;\n-  }\n-  if (can_skip) {\n-    current->set_vm_result(old_value_h());\n-    return ret_adj;\n-  }\n-\n-  instanceOop new_value = ik->allocate_instance_buffer(CHECK_(ret_adj));\n-  Handle new_value_h = Handle(THREAD, new_value);\n-  ik->inline_copy_oop_to_new_oop(old_value_h(), new_value_h());\n-  switch(entry->tos_state()) {\n-    case ztos:\n-      new_value_h()->bool_field_put(offset, (jboolean)(*(jint*)ptr));\n-      break;\n-    case btos:\n-      new_value_h()->byte_field_put(offset, (jbyte)(*(jint*)ptr));\n-      break;\n-    case ctos:\n-      new_value_h()->char_field_put(offset, (jchar)(*(jint*)ptr));\n-      break;\n-    case stos:\n-      new_value_h()->short_field_put(offset, (jshort)(*(jint*)ptr));\n-      break;\n-    case itos:\n-      new_value_h()->int_field_put(offset, (*(jint*)ptr));\n-      break;\n-    case ltos:\n-      new_value_h()->long_field_put(offset, *(jlong*)ptr);\n-      break;\n-    case ftos:\n-      new_value_h()->float_field_put(offset, *(jfloat*)ptr);\n-      break;\n-    case dtos:\n-      new_value_h()->double_field_put(offset, *(jdouble*)ptr);\n-      break;\n-    case atos:\n-      {\n-        if (entry->is_null_free_inline_type())  {\n-          if (ref_h() == nullptr) {\n-            THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n-          }\n-          if (!entry->is_flat()) {\n-            new_value_h()->obj_field_put(offset, ref_h());\n-          } else {\n-            int field_index = entry->field_index();\n-            InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(field_index));\n-            field_ik->write_flat_field(new_value_h(), offset, ref_h(), CHECK_(ret_adj));\n-          }\n-        } else {\n-          new_value_h()->obj_field_put(offset, ref_h());\n-        }\n-      }\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-  current->set_vm_result(new_value_h());\n-  return ret_adj;\n-JRT_END\n-\n@@ -462,8 +326,1 @@\n-  bool      is_qtype_desc = pool->tag_at(index).is_Qdescriptor_klass();\n-  arrayOop obj;\n-  if ((!klass->is_array_klass()) && is_qtype_desc) { \/\/ Logically creates elements, ensure klass init\n-    klass->initialize(CHECK);\n-    obj = oopFactory::new_valueArray(klass, size, CHECK);\n-  } else {\n-    obj = oopFactory::new_objArray(klass, size, CHECK);\n-  }\n+  arrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n@@ -490,1 +347,0 @@\n-  bool is_qtype = klass->name()->is_Q_array_signature();\n@@ -495,4 +351,0 @@\n-  if (is_qtype) { \/\/ Logically creates elements, ensure klass init\n-    klass->initialize(CHECK);\n-  }\n-\n@@ -919,1 +771,1 @@\n-                    bytecode == Bytecodes::_putstatic || bytecode == Bytecodes::_withfield);\n+                    bytecode == Bytecodes::_putstatic);\n@@ -921,1 +773,0 @@\n-  bool is_inline_type  = bytecode == Bytecodes::_withfield;\n@@ -972,3 +823,1 @@\n-    if (is_put && is_inline_type) {\n-        put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);\n-    } else if ((is_put && !has_initialized_final_update) || !info.access_flags().is_final()) {\n+    if ((is_put && !has_initialized_final_update) || !info.access_flags().is_final()) {\n@@ -1234,1 +1083,0 @@\n-  case Bytecodes::_withfield:\n@@ -1474,6 +1322,0 @@\n-  \/\/ Both Q-signatures and L-signatures are mapped to atos\n-  ik->field_is_null_free_inline_type(index);\n-  if (entry->tos_state() == atos && ik->field_is_null_free_inline_type(index)) {\n-    sig_type = JVM_SIGNATURE_PRIMITIVE_OBJECT;\n-  }\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":162,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -64,2 +64,0 @@\n-  static void    aconst_init  (JavaThread* current, ConstantPool* pool, int index);\n-  static int     withfield     (JavaThread* current, ResolvedFieldEntry* entry, uintptr_t ptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -964,1 +964,0 @@\n-         byte == Bytecodes::_withfield ||\n@@ -970,1 +969,1 @@\n-                    byte == Bytecodes::_nofast_putfield || byte == Bytecodes::_withfield);\n+                    byte == Bytecodes::_nofast_putfield);\n@@ -976,15 +975,0 @@\n-\n-  if (byte == Bytecodes::_withfield && !resolved_klass->is_inline_klass()) {\n-    ResourceMark rm(THREAD);\n-    char msg[200];\n-    jio_snprintf(msg, sizeof(msg), \"Bytecode withfield cannot be used on identity class %s\", resolved_klass->external_name());\n-    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n-  }\n-\n-  if (is_put && !is_static && byte != Bytecodes::_withfield && resolved_klass->is_inline_klass()) {\n-    ResourceMark rm(THREAD);\n-    char msg[200];\n-    jio_snprintf(msg, sizeof(msg), \"Bytecode putfield cannot be used on primitive class %s\", resolved_klass->external_name());\n-    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n-  }\n-\n@@ -1022,2 +1006,0 @@\n-    \/\/ (3) by withfield when field is in a value type and the\n-    \/\/     selected class and current class are nest mates.\n@@ -1027,15 +1009,6 @@\n-        \/\/ If byte code is a withfield check if they are nestmates.\n-        bool are_nestmates = false;\n-        if (sel_klass->is_instance_klass() &&\n-            InstanceKlass::cast(sel_klass)->is_inline_klass() &&\n-            current_klass->is_instance_klass()) {\n-          are_nestmates = InstanceKlass::cast(current_klass)->has_nestmate_access_to(InstanceKlass::cast(sel_klass), THREAD);\n-        }\n-        if (!are_nestmates) {\n-          ResourceMark rm(THREAD);\n-          stringStream ss;\n-          ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n-                   is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n-                    current_klass->external_name());\n-          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n-        }\n+        ResourceMark rm(THREAD);\n+        stringStream ss;\n+        ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n+                  is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n+                  current_klass->external_name());\n+        THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -475,1 +475,0 @@\n-      case Bytecodes::_withfield      : \/\/ fall through but may require more checks for correctness\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-  T_OBJECT ,\n-  T_PRIMITIVE_OBJECT\n+  T_OBJECT\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -440,2 +440,0 @@\n-  def(Bytecodes::_aconst_init         , ubcp|____|clvm|____, vtos, atos, aconst_init        , _            );\n-  def(Bytecodes::_withfield           , ubcp|____|clvm|____, vtos, atos, withfield           , _            );\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -324,1 +324,0 @@\n-  static void withfield();\n@@ -327,1 +326,0 @@\n-  static void aconst_init();\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-      (type == T_PRIMITIVE_OBJECT) ? _jca->push_oop(next_arg(T_PRIMITIVE_OBJECT)) : _jca->push_oop(next_arg(T_OBJECT));\n+      _jca->push_oop(next_arg(T_OBJECT));\n@@ -2874,1 +2874,1 @@\n-  else if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n+  else if (m->is_object_constructor()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS) {\n+Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {\n@@ -119,5 +119,1 @@\n-    if (qdesc) {\n-      new_str[idx++] = JVM_SIGNATURE_PRIMITIVE_OBJECT;\n-    } else {\n-      new_str[idx++] = JVM_SIGNATURE_CLASS;\n-    }\n+    new_str[idx++] = JVM_SIGNATURE_CLASS;\n@@ -169,1 +165,1 @@\n-                                                 false, name()->is_Q_array_signature(), CHECK_NULL);\n+                                                 false, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  static Symbol* create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS);\n+  static Symbol* create_element_klass_array_name(Klass* element_klass, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,0 @@\n-  assert(!k->name()->is_Q_signature(), \"Q-type without JVM_CONSTANT_QDescBit\");\n@@ -405,4 +404,1 @@\n-      {\n-        jbyte qdesc_bit = tag_at(cp_index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n-        tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n-      }\n+      tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n@@ -464,2 +460,1 @@\n-  jbyte qdesc_bit = tag_at(cp_index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n-  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n+  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n@@ -556,4 +551,0 @@\n-  if (name->is_Q_signature()) {\n-    name = name->fundamental_name(THREAD);\n-    inline_type_signature = true;\n-  }\n@@ -599,5 +590,1 @@\n-    jbyte tag = JVM_CONSTANT_UnresolvedClass;\n-    if (this_cp->tag_at(cp_index).is_Qdescriptor_klass()) {\n-      tag |= JVM_CONSTANT_QDescBit;\n-    }\n-    save_and_throw_exception(this_cp, cp_index, constantTag(tag), CHECK_NULL);\n+    save_and_throw_exception(this_cp, cp_index, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);\n@@ -622,4 +609,0 @@\n-  jbyte tag = JVM_CONSTANT_Class;\n-  if (this_cp->tag_at(cp_index).is_Qdescriptor_klass()) {\n-    tag |= JVM_CONSTANT_QDescBit;\n-  }\n@@ -630,1 +613,1 @@\n-                                  tag);\n+                                  (jbyte)JVM_CONSTANT_Class);\n@@ -740,1 +723,0 @@\n-    case Bytecodes::_withfield:\n@@ -1060,3 +1042,1 @@\n-      result_oop = tag.is_Qdescriptor_klass()\n-                      ? InlineKlass::cast(resolved)->val_mirror()\n-                      : resolved->java_mirror();\n+      result_oop = resolved->java_mirror();\n@@ -1982,6 +1962,0 @@\n-      case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {\n-        idx1 = Bytes::get_Java_u2(bytes);\n-        printf(\"qclass        #%03d\", idx1);\n-        ent_size = 2;\n-        break;\n-      }\n@@ -2030,4 +2004,0 @@\n-      case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {\n-        printf(\"UnresolvedQClass: %s\", WARN_MSG);\n-        break;\n-      }\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -281,9 +281,0 @@\n-  void unresolved_qdescriptor_at_put(int cp_index, int name_index, int resolved_klass_index) {\n-      release_tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);\n-\n-      assert((name_index & 0xffff0000) == 0, \"must be\");\n-      assert((resolved_klass_index & 0xffff0000) == 0, \"must be\");\n-      *int_at_addr(cp_index) =\n-        build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);\n-    }\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, true, CHECK_NULL);\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n@@ -362,1 +362,1 @@\n-        ObjArrayKlass* ak = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, true, CHECK_NULL);\n+        ObjArrayKlass* ak = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -847,1 +847,1 @@\n-  assert(cts.is_reference() || cts.is_inline_type() || cts.is_address(),\n+  assert(cts.is_reference() || cts.is_value() || cts.is_address(),\n@@ -1388,3 +1388,0 @@\n-    case Bytecodes::_aconst_init:      ppush1(CellTypeState::make_line_ref(itr->bci())); break;\n-    case Bytecodes::_withfield:        do_withfield(itr->get_index_u2(), itr->bci(), itr->code()); break;\n-\n@@ -1740,1 +1737,1 @@\n-  assert(in.is_reference() || in.is_inline_type(), \"sanity check\");\n+  assert(in.is_reference() || in.is_value(), \"sanity check\");\n@@ -2004,27 +2001,0 @@\n-void GenerateOopMap::do_withfield(int idx, int bci, Bytecodes::Code bc) {\n-  \/\/ Dig up signature for field in constant pool\n-  ConstantPool* cp = method()->constants();\n-  int nameAndTypeIdx = cp->name_and_type_ref_index_at(idx, bc);\n-  int signatureIdx = cp->signature_ref_index_at(nameAndTypeIdx);\n-  Symbol* signature = cp->symbol_at(signatureIdx);\n-\n-  \/\/ Parse signature (especially simple for fields)\n-  assert(signature->utf8_length() > 0,\n-      \"field signatures cannot have zero length\");\n-  \/\/ The signature is UFT8 encoded, but the first char is always ASCII for signatures.\n-  CellTypeState temp[4];\n-  CellTypeState *eff = signature_to_effect(signature, bci, temp);\n-\n-  CellTypeState in[4];\n-  int i = copy_cts(in, eff);\n-  in[i++] = CellTypeState::ref;\n-  in[i] = CellTypeState::bottom;\n-  assert(i <= 3, \"sanity check\");\n-\n-  CellTypeState out[2];\n-  out[0] = CellTypeState::ref;\n-  out[1] = CellTypeState::bottom;\n-\n-  pp(in, out);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":2,"deletions":32,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  bool is_inline_type() const           { return ((_state & bits_mask) == val_bit); }\n+  bool is_value() const                 { return ((_state & bits_mask) == val_bit); }\n@@ -406,1 +406,0 @@\n-  void  do_withfield                        (int idx, int bci, Bytecodes::Code bc);\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, true, CHECK_NULL);\n+          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, CHECK_NULL);\n@@ -252,3 +252,0 @@\n-      if (bt == T_PRIMITIVE_OBJECT) {\n-        bt = T_OBJECT;\n-      }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -150,13 +150,0 @@\n-  bool is_null_free() const { return access_flags().is_primitive_class(); }\n-\n-  \/\/ ref and val mirror\n-  oop ref_mirror() const { return java_mirror(); }\n-  oop val_mirror() const { return java_lang_Class::secondary_mirror(java_mirror()); }\n-\n-  \/\/ naming\n-  const char* ref_signature_name() const {\n-    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n-  }\n-  const char* val_signature_name() const {\n-    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_PRIMITIVE_OBJECT);\n-  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -960,31 +960,0 @@\n-    if (EnablePrimitiveClasses) {\n-      for (int i = 0; i < methods()->length(); i++) {\n-        Method* m = methods()->at(i);\n-        for (SignatureStream ss(m->signature()); !ss.is_done(); ss.next()) {\n-          if (ss.is_reference()) {\n-            if (ss.is_array()) {\n-              continue;\n-            }\n-            if (ss.type() == T_PRIMITIVE_OBJECT) {\n-              Symbol* symb = ss.as_symbol();\n-              if (symb == name()) continue;\n-              oop loader = class_loader();\n-              oop protection_domain = this->protection_domain();\n-              Klass* klass = SystemDictionary::resolve_or_fail(symb,\n-                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n-                                                              CHECK_false);\n-              if (klass == nullptr) {\n-                THROW_(vmSymbols::java_lang_LinkageError(), false);\n-              }\n-              if (!klass->is_inline_klass()) {\n-                Exceptions::fthrow(\n-                  THREAD_AND_LOCATION,\n-                  vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  \"class %s is not an inline type\",\n-                  klass->external_name());\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n@@ -1778,1 +1747,1 @@\n-                                                                  false, false, CHECK_NULL);\n+                                                                  false, CHECK_NULL);\n@@ -2356,3 +2325,2 @@\n-    if (name == vmSymbols::object_initializer_name() ||\n-        name == vmSymbols::inline_factory_name()) {\n-      break;  \/\/ <init> and <vnew> is never inherited\n+    if (name == vmSymbols::object_initializer_name()) {\n+      break;  \/\/ <init> is never inherited\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":35,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -380,6 +380,0 @@\n-  bool carries_value_modifier() const { return _misc_flags.carries_value_modifier(); }\n-  void set_carries_value_modifier()   { _misc_flags.set_carries_value_modifier(true); }\n-\n-  bool carries_identity_modifier() const  { return _misc_flags.carries_identity_modifier(); }\n-  void set_carries_identity_modifier()    { _misc_flags.set_carries_identity_modifier(true); }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,4 +62,2 @@\n-    flag(carries_value_modifier             , 1 << 19) \/* the class or one of its super types has the ACC_VALUE modifier *\/ \\\n-    flag(carries_identity_modifier          , 1 << 20) \/* the class or one of its super types has the ACC_IDENTITY modifier *\/ \\\n-    flag(has_loosely_consistent_annotation  , 1 << 21) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n-    flag(is_implicitly_constructible        , 1 << 22) \/* the class has the ImplicitlyConstrutible annotation *\/\n+    flag(has_loosely_consistent_annotation  , 1 << 19) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n+    flag(is_implicitly_constructible        , 1 << 20) \/* the class has the ImplicitlyConstrutible annotation *\/\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -693,1 +693,0 @@\n-  bool is_value_class() const           { return _access_flags.is_value_class(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -934,5 +934,0 @@\n-\/\/ A method named <vnew> is a factory for an inline class.\n-bool Method::is_static_vnew_factory() const {\n-  return name() == vmSymbols::inline_factory_name();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -589,1 +589,1 @@\n-  \/\/ returns true if the method name is <init> and the method is not a static factory\n+  \/\/ returns true if the method name is <init>\n@@ -593,5 +593,2 @@\n-  \/\/ (non-static <init> or <clinit>), but false for factories (static <vnew>).\n-  bool is_object_constructor_or_class_initializer() const;\n-\n-  \/\/ returns true if the method name is <vnew> and the method is static\n-  bool is_static_vnew_factory() const;\n+  \/\/ (non-static <init> or <clinit>).\n+  bool is_object_constructor_or_class_initializer() const; \/\/ JDK-8325660: revisit this method because it didn't exist before Valhalla and seems to be related to value factories (<vnew) that are now gone\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-                                                      bool null_free, bool qdesc, TRAPS) {\n-  assert(!null_free || (n == 1 && element_klass->is_inline_klass() && qdesc), \"null-free unsupported\");\n+                                                      bool null_free, TRAPS) {\n+  assert(!null_free || (n == 1 && element_klass->is_inline_klass()), \"null-free unsupported\");\n@@ -122,1 +122,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, qdesc, CHECK_NULL);\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n@@ -147,2 +147,0 @@\n-  assert(!null_free || name->is_Q_array_signature(), \"sanity check\");\n-\n@@ -206,10 +204,0 @@\n-  if (rank == 1) { \/\/ last dim may be flatArray, check if we have any special storage requirements\n-    if (name()->char_at(1) != JVM_SIGNATURE_ARRAY &&  name()->is_Q_array_signature()) {\n-      return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);\n-    } else {\n-      return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);\n-    }\n-  }\n-  guarantee(rank > 1, \"Rank below 1\");\n-  \/\/ Call to lower_dimension uses this pointer, so most be called before a\n-  \/\/ possible GC\n@@ -220,13 +208,15 @@\n-  if (length != 0) {\n-    for (int index = 0; index < length; index++) {\n-      oop sub_array = ld_klass->multi_allocate(rank-1, &sizes[1], CHECK_NULL);\n-      h_array->obj_at_put(index, sub_array);\n-    }\n-  } else {\n-    \/\/ Since this array dimension has zero length, nothing will be\n-    \/\/ allocated, however the lower dimension values must be checked\n-    \/\/ for illegal values.\n-    for (int i = 0; i < rank - 1; ++i) {\n-      sizes += 1;\n-      if (*sizes < 0) {\n-        THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(\"%d\", *sizes));\n+  if (rank > 1) {\n+    if (length != 0) {\n+      for (int index = 0; index < length; index++) {\n+        oop sub_array = ld_klass->multi_allocate(rank-1, &sizes[1], CHECK_NULL);\n+        h_array->obj_at_put(index, sub_array);\n+      }\n+    } else {\n+      \/\/ Since this array dimension has zero length, nothing will be\n+      \/\/ allocated, however the lower dimension values must be checked\n+      \/\/ for illegal values.\n+      for (int i = 0; i < rank - 1; ++i) {\n+        sizes += 1;\n+        if (*sizes < 0) {\n+          THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(\"%d\", *sizes));\n+        }\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":18,"deletions":28,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                                                bool null_free, bool qdesc, TRAPS);\n+                                                bool null_free, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    (put_code() == 0 || put_code() == Bytecodes::_putstatic || put_code() == Bytecodes::_putfield || put_code() == Bytecodes::_withfield);\n+    (put_code() == 0 || put_code() == Bytecodes::_putstatic || put_code() == Bytecodes::_putfield);\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-    case Bytecodes::_withfield:\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,35 +90,0 @@\n-bool Symbol::is_Q_signature() const {\n-  int len = utf8_length();\n-  return len > 2 && char_at(0) == JVM_SIGNATURE_PRIMITIVE_OBJECT && char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;\n-}\n-\n-bool Symbol::is_Q_array_signature() const {\n-  int l = utf8_length();\n-  if (l < 2 || char_at(0) != JVM_SIGNATURE_ARRAY || char_at(l - 1) != JVM_SIGNATURE_ENDCLASS) {\n-    return false;\n-  }\n-  for (int i = 1; i < (l - 2); i++) {\n-    char c = char_at(i);\n-    if (c == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n-      return true;\n-    }\n-    if (c != JVM_SIGNATURE_ARRAY) {\n-      return false;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool Symbol::is_Q_method_signature() const {\n-  assert(SignatureVerifier::is_valid_method_signature(this), \"must be\");\n-  int len = utf8_length();\n-  if (len > 4 && char_at(0) == JVM_SIGNATURE_FUNC) {\n-    for (int i=1; i<len-3; i++) { \/\/ Must end with \")Qx;\", where x is at least one character or more.\n-      if (char_at(i) == JVM_SIGNATURE_ENDFUNC && char_at(i+1) == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -126,1 +91,1 @@\n-  if ((char_at(0) == JVM_SIGNATURE_PRIMITIVE_OBJECT || char_at(0) == JVM_SIGNATURE_CLASS) && ends_with(JVM_SIGNATURE_ENDCLASS)) {\n+  if (char_at(0) == JVM_SIGNATURE_CLASS && ends_with(JVM_SIGNATURE_ENDCLASS)) {\n@@ -141,1 +106,1 @@\n-    if (char_at(0) != JVM_SIGNATURE_PRIMITIVE_OBJECT && char_at(0) != JVM_SIGNATURE_CLASS) return false;\n+    if (char_at(0) != JVM_SIGNATURE_CLASS) return false;\n@@ -149,1 +114,1 @@\n-    if (s->char_at(0) != JVM_SIGNATURE_PRIMITIVE_OBJECT && s->char_at(0) != JVM_SIGNATURE_CLASS) return false;\n+    if (s->char_at(0) != JVM_SIGNATURE_CLASS) return false;\n@@ -490,8 +455,0 @@\n-void Symbol::print_Qvalue_on(outputStream* st) const {\n-  st->print(\"'Q\");\n-  for (int i = 0; i < utf8_length(); i++) {\n-    st->print(\"%c\", char_at(i));\n-  }\n-  st->print(\";'\");\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":3,"deletions":46,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -250,3 +250,0 @@\n-  bool is_Q_signature() const;\n-  bool is_Q_array_signature() const;\n-  bool is_Q_method_signature() const;\n@@ -300,1 +297,0 @@\n-  void print_Qvalue_on(outputStream* st) const;  \/\/ Second level print for Q-types.\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -801,1 +801,2 @@\n-        vt->replace_call_results(&kit, call, C, inline_method->signature()->returns_null_free_inline_type());\n+        \/\/ vt->replace_call_results(&kit, call, C, inline_method->signature()->returns_null_free_inline_type());\n+        vt->replace_call_results(&kit, call, C, false); \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -810,1 +811,2 @@\n-          if (!inline_method->signature()->returns_null_free_inline_type()) {\n+          \/\/ if (!inline_method->signature()->returns_null_free_inline_type()) {\n+          if (!false) { \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -743,1 +743,2 @@\n-            if (declared_signature->returns_null_free_inline_type()) {\n+            \/\/ if (declared_signature->returns_null_free_inline_type()) {\n+            if (false) { \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1132,9 +1132,0 @@\n-  case Bytecodes::_withfield: {\n-    bool ignored_will_link;\n-    ciField* field = method()->get_field_at_bci(bci(), ignored_will_link);\n-    int      size  = field->type()->size();\n-    inputs = size+1;\n-    depth = rsize() - inputs;\n-    break;\n-  }\n-\n@@ -1948,1 +1939,2 @@\n-    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, call->method()->signature()->returns_null_free_inline_type());\n+    \/\/ ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, call->method()->signature()->returns_null_free_inline_type());\n+    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, false); \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -3671,1 +3663,2 @@\n-  Node* p = basic_plus_adr(mirror, java_lang_Class::secondary_mirror_offset());\n+  \/\/ JDK-8325660: notion of secondary mirror \/ val_mirror is gone one JEP 401\n+  Node* p = basic_plus_adr(mirror, (int)0 \/* java_lang_Class::secondary_mirror_offset() *\/);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4118,2 +4118,2 @@\n-  bool is_val_mirror = true;\n-  ciType* tm = mirror_con->java_mirror_type(&is_val_mirror);\n+  \/\/ \/\/ JDK-8325660: Code has been modified because secondary mirror are gone in JEP 401\n+  ciType* tm = mirror_con->java_mirror_type();\n@@ -4122,3 +4122,1 @@\n-    if ((id == vmIntrinsics::_asPrimaryType || id == vmIntrinsics::_asPrimaryTypeArg) && is_val_mirror) {\n-      result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->ref_mirror()));\n-    } else if (id == vmIntrinsics::_asValueType || id == vmIntrinsics::_asValueTypeArg) {\n+    if (id == vmIntrinsics::_asValueType || id == vmIntrinsics::_asValueTypeArg) {\n@@ -4127,2 +4125,2 @@\n-      } else if (!is_val_mirror) {\n-        result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->val_mirror()));\n+      } else {\n+        result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->java_mirror()));\n@@ -4152,2 +4150,1 @@\n-  bool requires_null_check = false;\n-  ciType* tm = mirror_con->java_mirror_type(&requires_null_check);\n+  ciType* tm = mirror_con->java_mirror_type();\n@@ -4163,3 +4160,0 @@\n-        if (requires_null_check) {\n-          obj = null_check(obj);\n-        }\n@@ -4186,3 +4180,0 @@\n-  if (requires_null_check) {\n-    obj = null_check(obj);\n-  }\n@@ -4209,20 +4200,21 @@\n-    if (EnableValhalla && !requires_null_check) {\n-      \/\/ Check if we are casting to QMyValue\n-      Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), nullptr);\n-      if (ctrl_val_mirror != nullptr) {\n-        RegionNode* r = new RegionNode(3);\n-        record_for_igvn(r);\n-        r->init_req(1, control());\n-\n-        \/\/ Casting to QMyValue, check for null\n-        set_control(ctrl_val_mirror);\n-        { \/\/ PreserveJVMState because null check replaces obj in map\n-          PreserveJVMState pjvms(this);\n-          Node* null_ctr = top();\n-          null_check_oop(obj, &null_ctr);\n-          region->init_req(_npe_path, null_ctr);\n-          r->init_req(2, control());\n-        }\n-        set_control(_gvn.transform(r));\n-      }\n-    }\n+    \/\/ JDK-8325660: JEP 401 removed notions of Q-descriptors and secondary mirrors\n+    \/\/ if (EnableValhalla && !requires_null_check) {\n+    \/\/   \/\/ Check if we are casting to QMyValue\n+    \/\/   Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), nullptr);\n+    \/\/   if (ctrl_val_mirror != nullptr) {\n+    \/\/     RegionNode* r = new RegionNode(3);\n+    \/\/     record_for_igvn(r);\n+    \/\/     r->init_req(1, control());\n+\n+    \/\/     \/\/ Casting to QMyValue, check for null\n+    \/\/     set_control(ctrl_val_mirror);\n+    \/\/     { \/\/ PreserveJVMState because null check replaces obj in map\n+    \/\/       PreserveJVMState pjvms(this);\n+    \/\/       Node* null_ctr = top();\n+    \/\/       null_check_oop(obj, &null_ctr);\n+    \/\/       region->init_req(_npe_path, null_ctr);\n+    \/\/       r->init_req(2, control());\n+    \/\/     }\n+    \/\/     set_control(_gvn.transform(r));\n+    \/\/   }\n+    \/\/ }\n@@ -4434,2 +4426,1 @@\n-      bool null_free;\n-      ciType* t = tp->java_mirror_type(&null_free);\n+      ciType* t = tp->java_mirror_type();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":28,"deletions":37,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2077,5 +2077,6 @@\n-        if (off == java_lang_Class::primary_mirror_offset()) {\n-          const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->ref_instance());\n-        } else if (off == java_lang_Class::secondary_mirror_offset()) {\n-          const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->val_instance());\n-        }\n+        \/\/ JDK-8325660: notion of secondary mirror is gone in JEP 401\n+        \/\/ if (off == java_lang_Class::primary_mirror_offset()) {\n+        \/\/   const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->java_mirror());\n+        \/\/ } else if (off == java_lang_Class::secondary_mirror_offset()) {\n+        \/\/   const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->java_mirror());\n+        \/\/ }\n@@ -2448,1 +2449,1 @@\n-      ciType* t = tinst->java_mirror_type(&null_free);\n+      ciType* t = tinst->java_mirror_type();\n@@ -2458,0 +2459,1 @@\n+          \/\/ JDK-8325660: after removal of secondary mirror and Q-types, null_free is now always false => cleanup?\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -936,1 +936,2 @@\n-        if (!method()->signature()->returns_null_free_inline_type()) {\n+        \/\/ if (!method()->signature()->returns_null_free_inline_type()) {\n+        if (!false) { \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -946,1 +947,2 @@\n-      vt->pass_fields(&kit, ret, idx, false, method()->signature()->returns_null_free_inline_type());\n+      \/\/ vt->pass_fields(&kit, ret, idx, false, method()->signature()->returns_null_free_inline_type());\n+      vt->pass_fields(&kit, ret, idx, false, false); \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n@@ -2374,1 +2376,2 @@\n-        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), method()->signature()->returns_null_free_inline_type());\n+        \/\/ value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), method()->signature()->returns_null_free_inline_type());\n+        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), false); \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3506,6 +3506,0 @@\n-  case Bytecodes::_aconst_init:\n-    do_aconst_init();\n-    break;\n-  case Bytecodes::_withfield:\n-    do_withfield();\n-    break;\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -307,1 +307,2 @@\n-  bool null_free = iter().has_Q_signature();\n+  \/\/ bool null_free = iter().has_Q_signature();\n+  bool null_free = false; \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,1 +72,2 @@\n-  bool null_free = iter().has_Q_signature();\n+  \/\/ bool null_free = iter().has_Q_signature();\n+  bool null_free = false; \/\/ JDK-8325660: revisit this code after removal of Q-descriptors\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-  TypeAryPtr::_array_body_type[T_PRIMITIVE_OBJECT] = TypeAryPtr::OOPS;\n+  TypeAryPtr::_array_body_type[T_PRIMITIVE_OBJECT] = TypeAryPtr::OOPS;  \/\/ JDK-8325660: verify this usage of T_PRIMITIVE_OBJECT\n@@ -2201,4 +2201,2 @@\n-    if (!sig->returns_null_free_inline_type()) {\n-      \/\/ InlineTypeNode::IsInit field used for null checking\n-      arg_cnt++;\n-    }\n+    \/\/ InlineTypeNode::IsInit field used for null checking\n+    arg_cnt++;\n@@ -2221,4 +2219,2 @@\n-      if (!sig->returns_null_free_inline_type()) {\n-        \/\/ InlineTypeNode::IsInit field used for null checking\n-        field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n-      }\n+      \/\/ InlineTypeNode::IsInit field used for null checking\n+      field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n@@ -2227,1 +2223,1 @@\n-      field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling)->join_speculative(sig->returns_null_free_inline_type() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n+      field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling)->join_speculative(TypePtr::BOTTOM);\n@@ -4653,1 +4649,1 @@\n-ciType* TypeInstPtr::java_mirror_type(bool* is_val_mirror) const {\n+ciType* TypeInstPtr::java_mirror_type() const {\n@@ -4659,1 +4655,1 @@\n-  return const_oop()->as_instance()->java_mirror_type(is_val_mirror);\n+  return const_oop()->as_instance()->java_mirror_type();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1397,1 +1397,1 @@\n-  ciType* java_mirror_type(bool* is_val_mirror = nullptr) const;\n+  ciType* java_mirror_type() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n+  if (m->is_object_constructor()) {\n@@ -506,12 +506,3 @@\n-  jboolean ret;\n-  if (sub_klass == super_klass && sub_klass->is_inline_klass()) {\n-    \/\/ val type is a subtype of ref type\n-    InlineKlass* ik = InlineKlass::cast(sub_klass);\n-    if (sub_mirror == super_mirror || (ik->val_mirror() == sub_mirror && ik->ref_mirror() == super_mirror)) {\n-      ret = JNI_TRUE;\n-    } else {\n-      ret = JNI_FALSE;\n-    }\n-  } else {\n-    ret = sub_klass->is_subtype_of(super_klass) ? JNI_TRUE : JNI_FALSE;\n-  }\n+  jboolean ret = sub_klass->is_subtype_of(super_klass) ?\n+                   JNI_TRUE : JNI_FALSE;\n+\n@@ -817,2 +808,1 @@\n-    case T_OBJECT:\n-    case T_PRIMITIVE_OBJECT: push_object(va_arg(_ap, jobject)); break;\n+    case T_OBJECT: push_object(va_arg(_ap, jobject)); break;\n@@ -981,1 +971,7 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == nullptr || k->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n+  }\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n@@ -1002,12 +998,6 @@\n-  if (!k->is_inline_klass()) {\n-    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n-    obj = JNIHandles::make_local(THREAD, i);\n-    JavaValue jvalue(T_VOID);\n-    JNI_ArgumentPusherArray ap(methodID, args);\n-    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n-  } else {\n-    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n-    JNI_ArgumentPusherArray ap(methodID, args);\n-    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_NULL);\n-    obj = jvalue.get_jobject();\n-  }\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+  obj = JNIHandles::make_local(THREAD, i);\n+  JavaValue jvalue(T_VOID);\n+  JNI_ArgumentPusherArray ap(methodID, args);\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+\n@@ -1034,12 +1024,6 @@\n-  if (!k->is_inline_klass()) {\n-    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n-    obj = JNIHandles::make_local(THREAD, i);\n-    JavaValue jvalue(T_VOID);\n-    JNI_ArgumentPusherVaArg ap(methodID, args);\n-    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n-  } else {\n-    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n-    JNI_ArgumentPusherVaArg ap(methodID, args);\n-    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_NULL);\n-    obj = jvalue.get_jobject();\n-  }\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+  obj = JNIHandles::make_local(THREAD, i);\n+  JavaValue jvalue(T_VOID);\n+  JNI_ArgumentPusherVaArg ap(methodID, args);\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+\n@@ -1066,18 +1050,9 @@\n-  if (!k->is_inline_klass()) {\n-    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n-    obj = JNIHandles::make_local(THREAD, i);\n-    va_list args;\n-    va_start(args, methodID);\n-    JavaValue jvalue(T_VOID);\n-    JNI_ArgumentPusherVaArg ap(methodID, args);\n-    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n-    va_end(args);\n-  } else {\n-    va_list args;\n-    va_start(args, methodID);\n-    JavaValue jvalue(T_PRIMITIVE_OBJECT);\n-    JNI_ArgumentPusherVaArg ap(methodID, args);\n-    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_NULL);\n-    va_end(args);\n-    obj = jvalue.get_jobject();\n-  }\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n+  obj = JNIHandles::make_local(THREAD, i);\n+  va_list args;\n+  va_start(args, methodID);\n+  JavaValue jvalue(T_VOID);\n+  JNI_ArgumentPusherVaArg ap(methodID, args);\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);\n+  va_end(args);\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":33,"deletions":58,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -259,2 +259,1 @@\n-      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT) &&\n-      !(fd.field_type() == T_PRIMITIVE_OBJECT && ftype == T_OBJECT)) {\n+      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT))  {\n@@ -297,2 +296,1 @@\n-      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT) &&\n-      !(fd.field_type() == T_PRIMITIVE_OBJECT && ftype == T_OBJECT)) {\n+      !(fd.field_type() == T_ARRAY && ftype == T_OBJECT)) {\n@@ -471,1 +469,1 @@\n-      (name[0] == JVM_SIGNATURE_CLASS || name[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) && \/\/ 'L' or 'Q'\n+      name[0] == JVM_SIGNATURE_CLASS &&            \/\/ 'L'\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-  if (!klass->is_value_class()) {\n+  if (klass->is_identity_class()) {\n@@ -1917,2 +1917,1 @@\n-  bool is_ctor = (method->is_object_constructor() ||\n-                  method->is_static_vnew_factory());\n+  bool is_ctor = (method->is_object_constructor());\n@@ -1987,2 +1986,1 @@\n-        assert(method->is_object_constructor() ||\n-               method->is_static_vnew_factory(), \"must be\");\n+        assert(method->is_object_constructor(), \"must be\");\n@@ -2271,1 +2269,1 @@\n-  if (m->is_object_constructor() || m->is_static_vnew_factory()) {\n+  if (m->is_object_constructor()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -920,1 +920,1 @@\n-  write_u2(ik()->access_flags().get_flags() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_PRIMITIVE | JVM_ACC_VALUE | JVM_ACC_IDENTITY));\n+  write_u2(ik()->access_flags().get_flags() & (JVM_RECOGNIZED_CLASS_MODIFIERS));\n@@ -1030,2 +1030,1 @@\n-      case Bytecodes::_putfield        :  \/\/ fall through\n-      case Bytecodes::_withfield       : {\/\/ fall through\n+      case Bytecodes::_putfield        : {\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2350,1 +2350,1 @@\n-  if (sig_type == JVM_SIGNATURE_CLASS || sig_type == JVM_SIGNATURE_PRIMITIVE_OBJECT) {\n+  if (sig_type == JVM_SIGNATURE_CLASS) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -459,2 +459,1 @@\n-  if ((ty_sign[0] == JVM_SIGNATURE_CLASS ||\n-       ty_sign[0] == JVM_SIGNATURE_PRIMITIVE_OBJECT) &&\n+  if (ty_sign[0] == JVM_SIGNATURE_CLASS &&\n@@ -538,1 +537,0 @@\n-  case T_PRIMITIVE_OBJECT:\n@@ -686,1 +684,1 @@\n-      if (_type == T_OBJECT || _type == T_PRIMITIVE_OBJECT) {\n+      if (_type == T_OBJECT) {\n@@ -704,2 +702,1 @@\n-      case T_OBJECT:\n-      case T_PRIMITIVE_OBJECT: {\n+      case T_OBJECT: {\n@@ -726,2 +723,1 @@\n-        case T_OBJECT:\n-        case T_PRIMITIVE_OBJECT: {\n+        case T_OBJECT: {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2248,2 +2248,0 @@\n-      case Bytecodes::_aconst_init   : \/\/ fall through\n-      case Bytecodes::_withfield      : \/\/ fall through\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -823,2 +823,0 @@\n-        } else if (name == vmSymbols::inline_factory_name()) {\n-          LinkResolver::resolve_static_call(result, link_info, false, THREAD);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2963,6 +2963,0 @@\n-  if (!EnableValhalla && EnablePrimitiveClasses) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"Cannot specify -XX:+EnablePrimitiveClasses without -XX:+EnableValhalla\");\n-    return JNI_EINVAL;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-    case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1984,3 +1984,0 @@\n-  product(bool, EnablePrimitiveClasses, false,                              \\\n-          \"Enable experimental Valhalla primitive classes\")                 \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-    case T_PRIMITIVE_OBJECT: return T_PRIMITIVE_OBJECT;\n@@ -295,13 +294,0 @@\n-\n-  \/\/ Special case for factory methods\n-  if (EnableValhalla && !constructor_signature->is_void_method_signature()) {\n-    guarantee(klass->is_inline_klass(), \"inline classes must use factory methods\");\n-    JavaValue factory_result(T_OBJECT);\n-    JavaCalls::call_static(&factory_result, klass,\n-                           vmSymbols::inline_factory_name(),\n-                           constructor_signature, args, CHECK_NH);\n-    return Handle(THREAD, factory_result.get_oop());\n-  }\n-\n-  \/\/ main branch of code creates a non-inline object:\n-  assert(!klass->is_inline_klass(), \"classic constructors are only for non-inline classes\");\n@@ -410,1 +396,1 @@\n-  if (InlineTypeReturnedAsFields && (result->get_type() == T_PRIMITIVE_OBJECT || result->get_type() == T_OBJECT)) {\n+  if (InlineTypeReturnedAsFields && (result->get_type() == T_OBJECT)) {\n@@ -608,1 +594,0 @@\n-    case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -358,5 +358,1 @@\n-    if (k->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n-      return oopFactory::new_valueArray(k, length, THREAD);\n-    } else {\n-      return oopFactory::new_objArray(k, length, THREAD);\n-    }\n+    return oopFactory::new_objArray(k, length, THREAD);\n@@ -403,5 +399,1 @@\n-  if (klass->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n-    klass = InlineKlass::cast(klass)->value_array_klass(dim, CHECK_NULL);\n-  } else {\n-    klass = klass->array_klass(dim, CHECK_NULL);\n-  }\n+  klass = klass->array_klass(dim, CHECK_NULL);\n@@ -838,2 +830,1 @@\n-  assert(method()->is_object_constructor() ||\n-         method()->is_static_vnew_factory(),\n+  assert(method()->is_object_constructor(),\n@@ -1016,1 +1007,1 @@\n-    \/\/ no need to resolve if method is private, <init> or <vnew>\n+    \/\/ no need to resolve if method is private or <init>\n@@ -1018,2 +1009,1 @@\n-        reflected_method->name() == vmSymbols::object_initializer_name() ||\n-        reflected_method->name() == vmSymbols::inline_factory_name()) {\n+        reflected_method->name() == vmSymbols::object_initializer_name()) {\n@@ -1174,2 +1164,0 @@\n-  } else if (java_lang_Class::as_Klass(return_type_mirror)->is_inline_klass()) {\n-    rtype = java_lang_Class::is_primary_mirror(return_type_mirror) ? T_OBJECT : T_PRIMITIVE_OBJECT;\n@@ -1209,18 +1197,0 @@\n-\n-  \/\/ Special case for factory methods\n-  if (!method->signature()->is_void_method_signature()) {\n-    assert(klass->is_inline_klass(), \"inline classes must use factory methods\");\n-    assert(method->name() == vmSymbols::inline_factory_name(), \"wrong factory method name\");\n-    Handle no_receiver; \/\/ null instead of receiver\n-    BasicType rtype;\n-    if (klass->is_hidden()) {\n-      rtype = T_OBJECT;\n-    } else {\n-      rtype = T_PRIMITIVE_OBJECT;\n-    }\n-    return invoke(klass, method, no_receiver, override, ptypes, rtype, args, false, CHECK_NULL);\n-  }\n-\n-  \/\/ main branch of code creates a non-inline object:\n-  assert(!klass->is_inline_klass(), \"classic constructors are only for non-inline classes\");\n-  assert(method->name() == vmSymbols::object_initializer_name(), \"wrong constructor name\");\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -951,1 +951,1 @@\n-        (method->result_type() == T_PRIMITIVE_OBJECT || method->result_type() == T_OBJECT)) {\n+        (method->result_type() == T_OBJECT)) {\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3047,1 +3047,1 @@\n-      if (bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) {\n+      if (bt == T_OBJECT) {\n@@ -3820,1 +3820,1 @@\n-    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+    if (bt == T_OBJECT && callee->is_scalarized_arg(arg_num)) {\n@@ -3838,1 +3838,1 @@\n-    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n+    if (bt == T_OBJECT && callee->is_scalarized_arg(arg_num)) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  case T_PRIMITIVE_OBJECT:\n@@ -339,1 +338,0 @@\n-  case T_PRIMITIVE_OBJECT:\n@@ -424,1 +422,0 @@\n-  case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n@@ -560,2 +557,1 @@\n-  return has_Q_descriptor() ? InlineKlass::cast(klass)->val_mirror()\n-                            : klass->java_mirror();\n+  return klass->java_mirror();\n@@ -671,1 +667,0 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT: \/\/ fall through\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-    return (signature_char == JVM_SIGNATURE_CLASS) || (signature_char == JVM_SIGNATURE_PRIMITIVE_OBJECT);\n+    return (signature_char == JVM_SIGNATURE_CLASS);\n@@ -261,2 +261,1 @@\n-    case T_OBJECT:\n-    case T_PRIMITIVE_OBJECT:  type_name(\"jobject\" ); break;\n+    case T_OBJECT:  type_name(\"jobject\" ); break;\n@@ -411,1 +410,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -524,4 +522,0 @@\n-  bool has_Q_descriptor() const {\n-    return has_envelope() && (_signature->char_at(_begin) == JVM_SIGNATURE_PRIMITIVE_OBJECT);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -432,1 +432,0 @@\n-  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -476,1 +476,0 @@\n-    case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1033,1 +1033,0 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT: return HPROF_NORMAL_OBJECT; \/\/ not inlined Q-object, i.e. identity object.\n@@ -1064,1 +1063,0 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT:\n@@ -1108,1 +1106,0 @@\n-    case JVM_SIGNATURE_PRIMITIVE_OBJECT: \/\/ not inlined Q-object, i.e. identity object.\n@@ -1484,1 +1481,1 @@\n-  if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {  \/\/ TODO: FIXME\n+  if (type == T_OBJECT) {\n@@ -1486,0 +1483,3 @@\n+  } else if (type == T_PRIMITIVE_OBJECT) {\n+      \/\/ TODO: FIXME\n+      fatal(\"Not supported yet\"); \/\/ FIXME: JDK-8325678\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-  if (is_value_class()) st->print(\"value \"        );\n-  if (is_primitive_class()) st->print(\"primitive \");\n+  if (!is_identity_class()) st->print(\"value \"    );\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-  bool is_value_class () const         { return (_flags & JVM_ACC_VALUE       ) != 0; }\n-  bool is_primitive_class () const     { return (_flags & JVM_ACC_PRIMITIVE   ) != 0; }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,2 +109,0 @@\n-    case (JVM_CONSTANT_Class | (jbyte)JVM_CONSTANT_QDescBit):\n-      return \"Q-Descriptor\";\n","filename":"src\/hotspot\/share\/utilities\/constantTag.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-  \/\/ internal constant tag flags\n-  JVM_CONSTANT_QDescBit                 = (1 << 7) \/\/ Separate bit, encode Q type descriptors\n@@ -79,4 +77,0 @@\n-  bool is_Qdescriptor_klass() const {\n-    return (_tag & JVM_CONSTANT_QDescBit) != 0;\n-  }\n-\n@@ -130,8 +124,3 @@\n-    jbyte entry_tag = tag & ~JVM_CONSTANT_QDescBit;\n-    assert((((tag & JVM_CONSTANT_QDescBit) == 0) && (entry_tag >= 0 && entry_tag <= JVM_CONSTANT_NameAndType) ||\n-           (entry_tag >= JVM_CONSTANT_MethodHandle && entry_tag <= JVM_CONSTANT_InvokeDynamic) ||\n-           (entry_tag >= JVM_CONSTANT_InternalMin && entry_tag <= JVM_CONSTANT_InternalMax))\n-           || (((tag & JVM_CONSTANT_QDescBit) != 0) && (entry_tag == JVM_CONSTANT_Class ||\n-               entry_tag == JVM_CONSTANT_UnresolvedClass || entry_tag == JVM_CONSTANT_UnresolvedClassInError\n-               || entry_tag == JVM_CONSTANT_ClassIndex))\n-               , \"Invalid constant tag\");\n+    assert((tag >= 0 && tag <= JVM_CONSTANT_NameAndType) ||\n+           (tag >= JVM_CONSTANT_MethodHandle && tag <= JVM_CONSTANT_InvokeDynamic) ||\n+           (tag >= JVM_CONSTANT_InternalMin && tag <= JVM_CONSTANT_InternalMax), \"Invalid constant tag\");\n@@ -161,1 +150,1 @@\n-  jbyte value() const                { return _tag & ~JVM_CONSTANT_QDescBit; }\n+  jbyte value() const                { return _tag; }\n","filename":"src\/hotspot\/share\/utilities\/constantTag.hpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-  T_PRIMITIVE_OBJECT = 14,\n+  T_PRIMITIVE_OBJECT = 14, \/\/ Not a true BasicType, only use in headers of flat arrays\n@@ -966,1 +966,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1340,1 +1339,1 @@\n-\/\/ It's an alias to (EnablePrimitiveClasses && (FlatArrayElementMaxSize != 0)),\n+\/\/ It's an alias to (EnableValhalla && (FlatArrayElementMaxSize != 0)),\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    JVM_ACC_VALUE         = 0x0040,\n","filename":"src\/java.base\/share\/native\/include\/classfile_constants.h.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -197,2 +197,1 @@\n-            case JVM_SIGNATURE_CLASS:\n-            case JVM_SIGNATURE_PRIMITIVE_OBJECT: {\n+            case JVM_SIGNATURE_CLASS: {\n","filename":"src\/java.base\/share\/native\/libjava\/check_classname.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CheckcastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package runtime.valhalla.inlinetypes;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.lang.invoke.*;\n-import java.lang.ref.*;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.*;\n-\n-import static jdk.test.lib.Asserts.*;\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n-\n-import jdk.experimental.bytecode.MacroCodeBuilder;\n-import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;\n-import jdk.experimental.bytecode.TypeTag;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.Utils;\n-\n-import javax.tools.*;\n-\n-\/**\n- * @test CreationErrorTest\n- * @summary Test data movement with inline types\n- * @modules java.base\/jdk.internal.value\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n- * @compile -XDenablePrimitiveClasses CreationErrorTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xmx128m\n- *                   runtime.valhalla.inlinetypes.CreationErrorTest\n- *\/\n-\n-public class CreationErrorTest {\n-\n-    static value class InlineClass {\n-        int i = 0;\n-    }\n-\n-    static class IdentityClass {\n-        long l = 0L;\n-    }\n-\n-    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n-\n-    public static void main(String[] args) {\n-        testErroneousObjectCreation();\n-        testErroneousValueCreation();\n-    }\n-\n-    static void testErroneousObjectCreation() {\n-        MethodHandle testNewOnInlineClass = OldInstructionHelper.loadCode(\n-                LOOKUP,\n-                \"testNewOnInlineClass\",\n-                MethodType.methodType(boolean.class),\n-                CODE -> {\n-                    CODE.new_(InlineClass.class)\n-                        .iconst_1()\n-                        .return_(TypeTag.Z);\n-                });\n-        Throwable error = null;\n-        try {\n-            boolean result = (boolean) testNewOnInlineClass.invokeExact();\n-        } catch (Throwable t) {\n-            error = t;\n-        }\n-        System.out.println(\"error=\"+error);\n-        assertTrue(error != null && error instanceof InstantiationError, \"Invariant\");\n-\n-    }\n-\n-    \/\/ Note: this test might become obsolete if aconst_init is extended to accept identity classes\n-    static void testErroneousValueCreation() {\n-        MethodHandle testAconstInitOnIdentityClass = OldInstructionHelper.loadCode(\n-                LOOKUP,\n-                \"testAconstInitOnIdentityClass\",\n-                MethodType.methodType(boolean.class),\n-                CODE -> {\n-                    CODE.aconst_init(IdentityClass.class)\n-                        .iconst_1()\n-                        .return_(TypeTag.Z);\n-                });\n-        Throwable error = null;\n-        try {\n-            boolean result = (boolean) testAconstInitOnIdentityClass.invokeExact();\n-        } catch (Throwable t) {\n-            error = t;\n-        }\n-        System.out.println(\"error=\"+error);\n-        assertTrue(error != null && error instanceof IncompatibleClassChangeError, \"Invariant\");\n-\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CreationErrorTest.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-EnablePrimitiveClasses HiddenInlineClassTest\n+ * @run main\/othervm -XX:+EnableValhalla HiddenInlineClassTest\n@@ -36,1 +36,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenInlineClassTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -593,0 +593,8 @@\n+        public FooValue() {\n+            id = 0;\n+            name = null;\n+            description = null;\n+            timestamp = 0L;\n+            notes = null;\n+        }\n+\n@@ -613,1 +621,3 @@\n-                            .aconst_init(FooValue.class)\n+                            .new_(FooValue.class)\n+                            .dup()\n+                            .invokespecial(FooValue.class, \"<init>\", \"()V\", false)\n@@ -623,1 +633,3 @@\n-                            .aconst_init(FooValue.class)\n+                            .new_(FooValue.class)\n+                            .dup()\n+                            .invokespecial(FooValue.class, \"<init>\", \"()V\", false)\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -90,2 +90,3 @@\n-        i = (int)System.nanoTime();\n-        name = Integer.valueOf(i).toString();\n+        int now =  (int)System.nanoTime();\n+        i = now;\n+        name = Integer.valueOf(now).toString();\n@@ -130,3 +131,5 @@\n-        l = System.nanoTime();\n-        s = Long.valueOf(l).toString();\n-        d = Double.parseDouble(s);\n+        long now = System.nanoTime();\n+        l = now;\n+        String stringNow = Long.valueOf(now).toString();\n+        s = stringNow;\n+        d = Double.parseDouble(stringNow);\n@@ -137,2 +140,3 @@\n-        s = Long.valueOf(l).toString();\n-        d = Double.parseDouble(s);\n+        String txt = Long.valueOf(l).toString();\n+        s = txt;\n+        d = Double.parseDouble(txt);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/native -XX:+EnableValhalla -XX:-EnablePrimitiveClasses runtime.valhalla.inlinetypes.InlineWithJni\n+ * @run main\/othervm\/native -XX:+EnableValhalla runtime.valhalla.inlinetypes.InlineWithJni\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineWithJni.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,18 +55,18 @@\n-        l2 = l0+l1;\n-        l3 = l1+l2;\n-        l4 = l2+l3;\n-        l5 = l3+l4;\n-        l6 = l4+l5;\n-        l7 = l5+l6;\n-        l8 = l6+l7;\n-        l9 = l7+l8;\n-        l10 = l8+l9;\n-        l11 = l9+l10;\n-        l12 = l10+l11;\n-        l13 = l11+l12;\n-        l14 = l12+l13;\n-        l15 = l13+l14;\n-        l16 = l14+l15;\n-        l17 = l15+l16;\n-        l18 = l16+l17;\n-        l19 = l17+l18;\n+        l2 = l0Val+1;\n+        l3 = l1Val+2;\n+        l4 = l0Val+3;\n+        l5 = l1Val+4;\n+        l6 = l0Val+5;\n+        l7 = l1Val+6;\n+        l8 = l0Val+7;\n+        l9 = l1Val+8;\n+        l10 = l0Val+9;\n+        l11 = l1Val+10;\n+        l12 = l0Val+11;\n+        l13 = l1Val+12;\n+        l14 = l0Val+13;\n+        l15 = l1Val+14;\n+        l16 = l0Val+15;\n+        l17 = l1Val+16;\n+        l18 = l0Val+17;\n+        l19 = l1Val+18;\n@@ -76,6 +76,6 @@\n-        return (l2 == (l0 + l1)  &&  l3 == (l1 + l2) && l5 == (l3 + l4)\n-            && l6 == (l4 + l5) && l7 == (l5 + l6) && l8 == (l6 + l7)\n-            && l9 == (l7 + l8) && l10 == (l8 + l9) && l11 == (l9 + l10)\n-            && l12 == (l10 + l11) && l13 == (l11 + l12) && l14 == (l12 + l13)\n-            && l15 == (l13 + l14) && l16 == (l14 + l15) && l17 == (l15 + l16)\n-            && l18 == (l16 + l17) && l19 == (l17 + l18));\n+        return (l2 == (l0 + 1)  &&  l3 == (l1 + 2) && l4 == (l0 + 3)\n+            && l5 == (l1 + 4) && l6 == (l0 + 5) && l7 == (l1 + 6) && l8 == (l0 + 7)\n+            && l9 == (l1 + 8) && l10 == (l0 + 9) && l11 == (l1 + 10)\n+            && l12 == (l0 + 11) && l13 == (l1 + 12) && l14 == (l1 + 13)\n+            && l15 == (l1 + 14) && l16 == (l0 + l15) && l17 == (l1 + 16)\n+            && l18 == (l0 + 17) && l19 == (l1 + 18));\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/JumboInline.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/MultiANewArrayTest\/MultiANewArrayTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:-EnablePrimitiveClasses -XX:+UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods\n- * @run main\/othervm -XX:+EnableValhalla -XX:-EnablePrimitiveClasses -XX:-UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods\n- * @run main\/othervm -XX:+EnableValhalla -XX:-EnablePrimitiveClasses -noverify runtime.valhalla.inlinetypes.ObjectMethods noverify\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods\n+ * @run main\/othervm -XX:+EnableValhalla -XX:-UseCompressedClassPointers runtime.valhalla.inlinetypes.ObjectMethods\n+ * @run main\/othervm -XX:+EnableValhalla -noverify runtime.valhalla.inlinetypes.ObjectMethods noverify\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ObjectMethods.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,18 +81,18 @@\n-            l2 = l0+l1;\n-            l3 = l1+l2;\n-            l4 = l2+l3;\n-            l5 = l3+l4;\n-            l6 = l4+l5;\n-            l7 = l5+l6;\n-            l8 = l6+l7;\n-            l9 = l7+l8;\n-            l10 = l8+l9;\n-            l11 = l9+l10;\n-            l12 = l10+l11;\n-            l13 = l11+l12;\n-            l14 = l12+l13;\n-            l15 = l13+l14;\n-            l16 = l14+l15;\n-            l17 = l15+l16;\n-            l18 = l16+l17;\n-            l19 = l17+l18;\n+            l2 = l0Val+1;\n+            l3 = l1Val+2;\n+            l4 = l0Val+3;\n+            l5 = l1Val+4;\n+            l6 = l0Val+5;\n+            l7 = l1Val+6;\n+            l8 = l0Val+7;\n+            l9 = l1Val+8;\n+            l10 = l0Val+9;\n+            l11 = l1Val+10;\n+            l12 = l0Val+11;\n+            l13 = l1Val+12;\n+            l14 = l0Val+13;\n+            l15 = l1Val+14;\n+            l16 = l0Val+15;\n+            l17 = l1Val+16;\n+            l18 = l0Val+17;\n+            l19 = l1Val+18;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/QuickeningTest.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @build org.openjdk.asmtools.* org.openjdk.asmtools.jasm.*\n- * @run driver org.openjdk.asmtools.JtregDriver jasm -strict TestFieldNullabilityClasses.jasm\n@@ -76,31 +74,1 @@\n-    static class Wrapper {\n-        @NullRestricted\n-        TestPrimitiveClass c;\n-    }\n-\n-    static void testPrimitiveClass() {\n-        TestPrimitiveClass that = new Wrapper().c;\n-        Asserts.assertNull(that.nullField, \"Invalid non null value for uninitialized non flattenable field\");\n-        Asserts.assertNull(that.nullBigField, \"Invalid non null value for uninitialized non flattenable field\");\n-        boolean NPE = false;\n-        try {\n-            TestPrimitiveClass tv = that.withNullableField(that.nullField);\n-        } catch(NullPointerException e) {\n-            NPE = true;\n-        }\n-        Asserts.assertFalse(NPE, \"Invalid NPE when assigning null to a non flattenable field\");\n-        try {\n-            TestPrimitiveClass tv = that.withNullfreeField((MyValue) that.nullField);\n-        } catch(NullPointerException e) {\n-            NPE = true;\n-        }\n-        Asserts.assertTrue(NPE, \"Missing NPE when assigning null to a flattened field\");\n-        try {\n-            TestPrimitiveClass tv = that.withNullfreeBigField((MyBigValue) that.nullBigField);\n-        } catch(NullPointerException e) {\n-            NPE = true;\n-        }\n-        Asserts.assertTrue(NPE, \"Missing NPE when assigning null to a flattenable field\");\n-    }\n-\n-    static void testIdentityClass() {\n+    public static void main(String[] args) {\n@@ -131,5 +99,0 @@\n-    public static void main(String[] args) {\n-        testIdentityClass();\n-        testPrimitiveClass();\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullability.java","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-@+\"jdk\/internal\/vm\/annotation\/ImplicitlyConstructible\" { }\n-@+\"jdk\/internal\/vm\/annotation\/LooselyConsistentValue\" { }\n-public final value class runtime\/valhalla\/inlinetypes\/TestPrimitiveClass\n-    version 66:0\n-{\n-    final Field nullableField:   \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n-    @+\"jdk\/internal\/vm\/annotation\/NullRestricted\" { }\n-    final Field nullfreeField:   \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ flattened\n-    final Field nullField:       \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\"; \/\/ src of null\n-    @+\"jdk\/internal\/vm\/annotation\/NullRestricted\" { }\n-    final Field nullfreeBigField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ not flattened\n-    final Field nullBigField:    \"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\"; \/\/ src of null\n-\n-    public Method withNullableField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n-        stack 2\n-    {\n-        aload_0;\n-        aload_1;\n-        withfield nullableField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n-        areturn;\n-    }\n-\n-    public Method withNullfreeField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n-        stack 2\n-    {\n-        aload_0;\n-        aload_1;\n-        withfield nullfreeField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyValue;\";\n-        areturn;\n-    }\n-\n-    public Method withNullfreeBigField:\"(Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;)Lruntime\/valhalla\/inlinetypes\/TestPrimitiveClass;\"\n-        stack 2\n-    {\n-        aload_0;\n-        aload_1;\n-        withfield nullfreeBigField:\"Lruntime\/valhalla\/inlinetypes\/TestFieldNullability$MyBigValue;\";\n-        areturn;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullabilityClasses.jasm","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatch.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n@@ -37,0 +35,3 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -41,1 +42,1 @@\n-        Collections.addAll(argsList, \"-XX:+EnableValhalla\", \"-XX:-EnablePrimitiveClasses\");\n+        Collections.addAll(argsList, \"-XX:+EnableValhalla\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldAccessorTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACC_CFETest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACC_ICCETest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/BadACCValue.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/BadInlineTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/PrimitiveUsers.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testClassModifiers\/TestClassModifiers.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testSupers\/TestSuperClasses.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/VTAssignability.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile -XDenablePrimitiveClasses VTMonitor.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xverify:remote VTMonitor\n+ * @compile  VTMonitor.java\n+ * @run main\/othervm -XX:+EnableValhalla -Xverify:remote VTMonitor\n@@ -32,1 +32,1 @@\n-public primitive final class VTMonitor {\n+public value final class VTMonitor {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/VTMonitor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/VerifierInlineTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @ignore\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/withfieldTests\/RunWithfieldTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}