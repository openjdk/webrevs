{"files":[{"patch":"@@ -862,33 +862,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciTypeFlow::StateVector::do_aconst_init\n-void ciTypeFlow::StateVector::do_aconst_init(ciBytecodeStream* str) {\n-  bool will_link;\n-  ciKlass* klass = str->get_klass(will_link);\n-  if (!will_link || str->is_unresolved_klass() || !klass->is_inlinetype()) {\n-    trap(str, klass, str->get_klass_index());\n-  } else {\n-    push(outer()->mark_as_null_free(klass));\n-  }\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciTypeFlow::StateVector::do_withfield\n-void ciTypeFlow::StateVector::do_withfield(ciBytecodeStream* str) {\n-  bool will_link;\n-  ciField* field = str->get_field(will_link);\n-  ciKlass* klass = field->holder();\n-  if (!will_link) {\n-    trap(str, klass, str->get_field_holder_index());\n-  } else {\n-    ciType* type = pop_value();\n-    ciType* field_type = field->type();\n-    if (field_type->is_two_word()) {\n-      ciType* type2 = pop_value();\n-      assert(type2->is_two_word(), \"must be 2nd half\");\n-      assert(type == half_type(type2), \"must be 2nd half\");\n-    }\n-    pop_object();\n-    push(outer()->mark_as_null_free(klass));\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -365,2 +365,0 @@\n-    void do_aconst_init(ciBytecodeStream* str);\n-    void do_withfield(ciBytecodeStream* str);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4118,1 +4118,1 @@\n-  \/\/ \/\/ JDK-8325660: Code has been modified because secondary mirror are gone in JEP 401\n+  \/\/ JDK-8325660: Code has been modified because secondary mirror are gone in JEP 401\n@@ -4313,1 +4313,2 @@\n-    generate_fair_guard(is_val_mirror(args[0]), prim_region);\n+    \/\/ TODO JDK-8325660\n+    \/\/ generate_fair_guard(is_val_mirror(args[0]), prim_region);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -552,2 +552,0 @@\n-  void do_aconst_init();\n-  void do_withfield();\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -324,65 +324,0 @@\n-\/\/------------------------------do_aconst_init---------------------------------\n-void Parse::do_aconst_init() {\n-  bool will_link;\n-  ciInlineKlass* vk = iter().get_klass(will_link)->as_inline_klass();\n-  assert(will_link && !iter().is_unresolved_klass(), \"aconst_init: typeflow responsibility\");\n-\n-  if (C->needs_clinit_barrier(vk, method())) {\n-    clinit_barrier(vk, method());\n-    if (stopped())  return;\n-  }\n-\n-  push(InlineTypeNode::make_default(_gvn, vk));\n-}\n-\n-\/\/------------------------------do_withfield------------------------------------\n-void Parse::do_withfield() {\n-  bool will_link;\n-  ciField* field = iter().get_field(will_link);\n-  assert(will_link, \"withfield: typeflow responsibility\");\n-  int holder_depth = field->type()->size();\n-  null_check(peek(holder_depth));\n-  if (stopped()) {\n-    return;\n-  }\n-  Node* val = pop_node(field->layout_type());\n-  Node* holder = pop();\n-\n-  if (field->is_null_free()) {\n-    PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n-    int nargs = 1 + field->type()->size();\n-    inc_sp(nargs);\n-    val = null_check(val);\n-    if (stopped()) {\n-      return;\n-    }\n-  }\n-  if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n-    \/\/ Scalarize inline type field value\n-    val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n-  } else if (val->is_InlineType() && !field->is_flat()) {\n-    \/\/ Field value needs to be allocated because it can be merged with an oop.\n-    \/\/ Re-execute withfield if buffering triggers deoptimization.\n-    PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n-    int nargs = 1 + field->type()->size();\n-    inc_sp(nargs);\n-    val = val->as_InlineType()->buffer(this);\n-  }\n-\n-  \/\/ Clone the inline type node and set the new field value\n-  InlineTypeNode* new_vt = holder->clone()->as_InlineType();\n-  new_vt->set_oop(gvn().zerocon(T_OBJECT));\n-  new_vt->set_is_buffered(gvn(), false);\n-  new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n-  {\n-    PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n-    int nargs = 1 + field->type()->size();\n-    inc_sp(nargs);\n-    new_vt = new_vt->adjust_scalarization_depth(this);\n-  }\n-  push(_gvn.transform(new_vt));\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"}]}