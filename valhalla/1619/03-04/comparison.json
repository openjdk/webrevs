{"files":[{"patch":"@@ -65,1 +65,1 @@\n-    public static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n@@ -72,1 +72,1 @@\n-    public static final int FLAGS_IS_PREVIEW_VERSION = 0x2;\n+    private static final int FLAGS_IS_PREVIEW_VERSION = 0x2;\n@@ -87,1 +87,1 @@\n-    public static final int FLAGS_IS_PREVIEW_ONLY = 0x4;\n+    private static final int FLAGS_IS_PREVIEW_ONLY = 0x4;\n@@ -95,1 +95,1 @@\n-    public static final int FLAGS_IS_PACKAGE_ROOT = 0x8;\n+    private static final int FLAGS_IS_PACKAGE_ROOT = 0x8;\n@@ -109,0 +109,14 @@\n+     * <p>Based on the entry name, the flags are:\n+     * <ul>\n+     *     <li>{@code \"[\/modules]\/<module>\/<path>\"} normal resource or directory:<br>\n+     *     Zero, or {@code FLAGS_HAS_PREVIEW_VERSION} if a preview entry exists.\n+     *     <li>{@code \"[\/modules]\/<module>\/META-INF\/preview\/<path>\"} preview\n+     *     resource or directory:<br>\n+     *     {@code FLAGS_IS_PREVIEW_VERSION}, and additionally {@code\n+     *     FLAGS_IS_PREVIEW_ONLY} if no normal version of the resource exists.\n+     *     <li>{@code \"\/packages\"} (special case): {@code FLAGS_IS_PACKAGE_ROOT}.\n+     *     <li>{@code \"\/packages\/xxx\"} (special case): Calculated elsewhere based\n+     *     on module entries.\n+     *     <li>In all other cases, flags are zero.\n+     * <\/ul>\n+     *\n@@ -141,0 +155,15 @@\n+    \/**\n+     * Tests a non-preview image location's flags to see if it has preview\n+     * content associated with it.\n+     *\/\n+    public static boolean hasPreviewVersion(int flags) {\n+        return (flags & FLAGS_HAS_PREVIEW_VERSION) != 0;\n+    }\n+\n+    \/**\n+     * Tests an image location's flags to see if it only exists in preview mode.\n+     *\/\n+    public static boolean isPreviewOnly(int flags) {\n+        return (flags & FLAGS_IS_PREVIEW_ONLY) != 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageLocation.java","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-import static jdk.internal.jimage.ImageLocation.FLAGS_HAS_PREVIEW_VERSION;\n-import static jdk.internal.jimage.ImageLocation.FLAGS_IS_PREVIEW_ONLY;\n@@ -119,1 +117,2 @@\n-    public static ImageReader open(Path imagePath, ByteOrder byteOrder, PreviewMode mode) throws IOException {\n+    public static ImageReader open(Path imagePath, ByteOrder byteOrder, PreviewMode mode)\n+            throws IOException {\n@@ -122,1 +121,1 @@\n-        return SharedImageReader.open(imagePath, byteOrder, mode.resolve());\n+        return SharedImageReader.open(imagePath, byteOrder, mode.isPreviewModeEnabled());\n@@ -333,1 +332,1 @@\n-                if (previewMode || (flags & FLAGS_IS_PREVIEW_ONLY) == 0) {\n+                if (previewMode || !ImageLocation.isPreviewOnly(flags)) {\n@@ -336,2 +335,7 @@\n-                if (!previewMode || (flags & FLAGS_HAS_PREVIEW_VERSION) == 0) {\n-                    continue;\n+                if (previewMode && ImageLocation.hasPreviewVersion(flags)) {\n+                    \/\/ Only do this in preview mode for the small set of packages with\n+                    \/\/ preview versions (the number of preview entries should be small).\n+                    List<String> moduleNames = new ArrayList<>();\n+                    ModuleReference.readNameOffsets(getOffsetBuffer(pkgDir), \/*normal*\/ false, \/*preview*\/ true)\n+                            .forEachRemaining(n -> moduleNames.add(getString(n)));\n+                    previewPackagesToModules.put(pkgDir.getBase().replace('.', '\/'), moduleNames);\n@@ -339,6 +343,0 @@\n-                \/\/ Only do this in preview mode for the small set of packages with\n-                \/\/ preview versions (the number of preview entries should be small).\n-                List<String> moduleNames = new ArrayList<>();\n-                ModuleReference.readNameOffsets(getOffsetBuffer(pkgDir), \/*normal*\/ false, \/*preview*\/ true)\n-                        .forEachRemaining(n -> moduleNames.add(getString(n)));\n-                previewPackagesToModules.put(pkgDir.getBase().replace('.', '\/'), moduleNames);\n@@ -362,1 +360,1 @@\n-                boolean isPreviewOnly = (childLoc.getFlags() & FLAGS_IS_PREVIEW_ONLY) != 0;\n+                boolean isPreviewOnly = ImageLocation.isPreviewOnly(childLoc.getFlags());\n@@ -380,1 +378,1 @@\n-            if ((previewLoc.getFlags() & FLAGS_IS_PREVIEW_ONLY) != 0) {\n+            if (ImageLocation.isPreviewOnly(previewLoc.getFlags())) {\n@@ -399,5 +397,0 @@\n-        \/\/ As above but ignores null.\n-        private <T extends Node> T ensureCachedIfNonNull(T node) {\n-            return node != null ? ensureCached(node) : null;\n-        }\n-\n@@ -558,2 +551,3 @@\n-            return ensureCachedIfNonNull(\n-                    loc != null && loc.getType() == RESOURCE ? newResource(name, loc) : null);\n+            return loc != null && loc.getType() == RESOURCE\n+                    ? ensureCached(newResource(name, loc))\n+                    : null;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.ArrayList;\n@@ -36,5 +35,0 @@\n-import java.util.function.IntFunction;\n-import java.util.function.IntPredicate;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import java.util.stream.Stream;\n@@ -55,5 +49,1 @@\n-    \/\/ The following flags are designed to be additive (hence \"has-resources\"\n-    \/\/ rather than \"is-empty\", even though \"isEmpty()\" is whats in the API).\n-    \/\/ API methods like \"isEmpty()\" and \"hasPreviewVersion()\" are designed to\n-    \/\/ match the semantics of ImageLocation flags to avoid having business\n-    \/\/ logic need to reason about two different flag regimes.\n+    \/\/ These flags are additive (hence \"has-content\" rather than \"is-empty\").\n@@ -61,2 +51,2 @@\n-    \/** If set, the associated module has resources (in normal or preview mode). *\/\n-    private static final int FLAGS_HAS_CONTENT = 0x1;\n+    \/** If set, this package exists in preview mode. *\/\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n@@ -65,2 +55,2 @@\n-    \/** If set, this package exists in preview mode. *\/\n-    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x4;\n+    \/** If set, the associated module has resources (in normal or preview mode). *\/\n+    private static final int FLAGS_HAS_CONTENT = 0x4;\n@@ -77,3 +67,8 @@\n-    \/** Creates a reference for an empty package (one without content in). *\/\n-    public static ModuleReference forEmptyPackage(String moduleName, boolean isPreview) {\n-        return new ModuleReference(moduleName, previewFlag(isPreview));\n+    \/**\n+     * Returns a reference for non-empty packages (those with resources) in a\n+     * given module.\n+     *\n+     * <p>The same reference can be used for multiple packages in the same module.\n+     *\/\n+    public static ModuleReference forPackage(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, FLAGS_HAS_CONTENT | previewFlag(isPreview));\n@@ -82,3 +77,7 @@\n-    \/** Creates a reference for a preview only module. *\/\n-    public static ModuleReference forResource(String moduleName, boolean isPreview) {\n-        return new ModuleReference(moduleName, FLAGS_HAS_CONTENT | previewFlag(isPreview));\n+    \/**\n+     * Returns a reference for empty packages in a given module.\n+     *\n+     * <p>The same reference can be used for multiple packages in the same module.\n+     *\/\n+    public static ModuleReference forEmptyPackage(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, previewFlag(isPreview));\n@@ -118,1 +117,1 @@\n-     * under many modules, it is only non-empty in one.\n+     * under many modules, it only has content in one.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ModuleReference.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -43,6 +43,1 @@\n-    DISABLED() {\n-        @Override\n-        boolean resolve() {\n-            return false;\n-        }\n-    },\n+    DISABLED,\n@@ -53,6 +48,1 @@\n-    ENABLED() {\n-        @Override\n-        boolean resolve() {\n-            return true;\n-        }\n-    },\n+    ENABLED,\n@@ -63,20 +53,1 @@\n-    FOR_RUNTIME() {\n-        @Override\n-        boolean resolve() {\n-            \/\/ We want to call jdk.internal.misc.PreviewFeatures.isEnabled(), but\n-            \/\/ is not available in older JREs, so we must look to it reflectively.\n-            Class<?> clazz;\n-            try {\n-                clazz = Class.forName(\"jdk.internal.misc.PreviewFeatures\");\n-            } catch (ClassNotFoundException e) {\n-                \/\/ It is valid and expected that the class might not exist (JDK-8).\n-                return false;\n-            }\n-            try {\n-                return (Boolean) clazz.getDeclaredMethod(\"isEnabled\").invoke(null);\n-            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n-                \/\/ But if the class exists, the method must exist and be callable.\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n-    };\n+    FOR_RUNTIME;\n@@ -87,1 +58,28 @@\n-    abstract boolean resolve();\n+    public boolean isPreviewModeEnabled() {\n+        \/\/ A switch, instead of an abstract method, saves 3 subclasses.\n+        switch (this) {\n+            case DISABLED:\n+                return false;\n+            case ENABLED:\n+                return true;\n+            case FOR_RUNTIME:\n+                \/\/ We want to call jdk.internal.misc.PreviewFeatures.isEnabled(), but\n+                \/\/ is not available in older JREs, so we must look to it reflectively.\n+                Class<?> clazz;\n+                try {\n+                    clazz = Class.forName(\"jdk.internal.misc.PreviewFeatures\");\n+                } catch (ClassNotFoundException e) {\n+                    \/\/ It is valid and expected that the class might not exist (JDK-8).\n+                    return false;\n+                }\n+                try {\n+                    return (Boolean) clazz.getDeclaredMethod(\"isEnabled\").invoke(null);\n+                } catch (NoSuchMethodException | IllegalAccessException |\n+                         InvocationTargetException e) {\n+                    \/\/ But if the class exists, the method must exist and be callable.\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            default:\n+                throw new IllegalStateException(\"Invalid mode: \" + this);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/PreviewMode.java","additions":31,"deletions":33,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -121,3 +121,1 @@\n-        if (envValue instanceof Boolean && (Boolean) envValue) {\n-            return PreviewMode.ENABLED;\n-        } else if (envValue instanceof String && Boolean.parseBoolean((String) envValue)) {\n+        if (envValue instanceof String && Boolean.parseBoolean((String) envValue)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystemProvider.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,2 +78,0 @@\n-        \/\/ TODO: Maybe throw if enablePreview attempted for exploded image?\n-\n@@ -82,0 +80,4 @@\n+        \/\/ TODO: Support preview mode in ExplodedImage and remove this check.\n+        if (mode.isPreviewModeEnabled())\n+            throw new UnsupportedOperationException(\n+                    \"Preview mode not yet supported for exploded images\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import static jdk.internal.jimage.ModuleReference.forResource;\n+import static jdk.internal.jimage.ModuleReference.forPackage;\n@@ -53,1 +53,1 @@\n-    private static final int FLAGS_HAS_CONTENT = 0x1;\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n@@ -55,1 +55,1 @@\n-    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x4;\n+    private static final int FLAGS_HAS_CONTENT = 0x4;\n@@ -71,1 +71,1 @@\n-        ModuleReference ref = forResource(\"module\", isPreview);\n+        ModuleReference ref = forPackage(\"module\", isPreview);\n@@ -83,1 +83,1 @@\n-        ModuleReference resourceRef = forResource(\"module\", isPreview);\n+        ModuleReference resourceRef = forPackage(\"module\", isPreview);\n@@ -97,1 +97,1 @@\n-                forResource(\"gamma\", false),\n+                forPackage(\"gamma\", false),\n@@ -122,1 +122,1 @@\n-                forResource(\"first\", false),\n+                forPackage(\"first\", false),\n@@ -135,2 +135,2 @@\n-                forResource(\"alpha\", false),\n-                forResource(\"beta\", false));\n+                forPackage(\"alpha\", false),\n+                forPackage(\"beta\", false));\n@@ -209,1 +209,1 @@\n-                forResource(\"preview.beta\", true),\n+                forPackage(\"preview.beta\", true),\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ModuleReferenceTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}