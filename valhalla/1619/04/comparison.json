{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,17 @@\n+ * Defines the header and version information for jimage files.\n+ *\n+ * <p>Version number changes must be synced in a single change across all code\n+ * which reads\/writes jimage files, and code which tries to open a jimage file\n+ * with an unexpected version should fail.\n+ *\n+ * <p>Known jimage file code which needs updating on version change:\n+ * <ul>\n+ *     <li>src\/java.base\/share\/native\/libjimage\/imageFile.hpp\n+ * <\/ul>\n+ *\n+ * <p>Version history:\n+ * <ul>\n+ *     <li>{@code 1.0}: Original version.\n+ *     <li>{@code 1.1}: Support preview mode with new flags.\n+ * <\/ul>\n+ *\n@@ -42,1 +59,1 @@\n-    public static final int MINOR_VERSION = 0;\n+    public static final int MINOR_VERSION = 1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageHeader.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.function.Predicate;\n@@ -47,1 +48,125 @@\n-    public static final int ATTRIBUTE_COUNT = 8;\n+    public static final int ATTRIBUTE_PREVIEW_FLAGS = 8;\n+    public static final int ATTRIBUTE_COUNT = 9;\n+\n+    \/\/ Flag masks for the ATTRIBUTE_PREVIEW_FLAGS attribute. Defined so\n+    \/\/ that zero is the overwhelmingly common case for normal resources.\n+\n+    \/**\n+     * Indicates that a non-preview location is associated with preview\n+     * resources.\n+     *\n+     * <p>This can apply to both resources and directories in the\n+     * {@code \/modules\/xxx\/...} namespace, as well as {@code \/packages\/xxx}\n+     * directories.\n+     *\n+     * <p>For {@code \/packages\/xxx} directories, it indicates that the package\n+     * has preview resources in one of the modules in which it exists.\n+     *\/\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n+    \/**\n+     * Set on all locations in the {@code \/modules\/xxx\/META-INF\/preview\/...}\n+     * namespace.\n+     *\n+     * <p>This flag is mutually exclusive with {@link #FLAGS_HAS_PREVIEW_VERSION}.\n+     *\/\n+    private static final int FLAGS_IS_PREVIEW_VERSION = 0x2;\n+    \/**\n+     * Indicates that a location only exists due to preview resources.\n+     *\n+     * <p>This can apply to both resources and directories in the\n+     * {@code \/modules\/xxx\/...} namespace, as well as {@code \/packages\/xxx}\n+     * directories.\n+     *\n+     * <p>For {@code \/packages\/xxx} directories it indicates that, for every\n+     * module in which the package exists, it is preview only.\n+     *\n+     * <p>This flag is mutually exclusive with {@link #FLAGS_HAS_PREVIEW_VERSION}\n+     * and need not imply that {@link #FLAGS_IS_PREVIEW_VERSION} is set (i.e.\n+     * for {@code \/packages\/xxx} directories).\n+     *\/\n+    private static final int FLAGS_IS_PREVIEW_ONLY = 0x4;\n+    \/**\n+     * This flag identifies the unique {@code \"\/packages\"} location, and\n+     * is used to determine the {@link LocationType} without additional\n+     * string comparison.\n+     *\n+     * <p>This flag is mutually exclusive with all other flags.\n+     *\/\n+    private static final int FLAGS_IS_PACKAGE_ROOT = 0x8;\n+\n+    \/\/ Also used in ImageReader.\n+    static final String MODULES_PREFIX = \"\/modules\";\n+    static final String PACKAGES_PREFIX = \"\/packages\";\n+    static final String PREVIEW_INFIX = \"\/META-INF\/preview\";\n+\n+    \/**\n+     * Helper function to calculate preview flags (ATTRIBUTE_PREVIEW_FLAGS).\n+     *\n+     * <p>Since preview flags are calculated separately for resource nodes and\n+     * directory nodes (in two quite different places) it's useful to have a\n+     * common helper.\n+     *\n+     * <p>Based on the entry name, the flags are:\n+     * <ul>\n+     *     <li>{@code \"[\/modules]\/<module>\/<path>\"} normal resource or directory:<br>\n+     *     Zero, or {@code FLAGS_HAS_PREVIEW_VERSION} if a preview entry exists.\n+     *     <li>{@code \"[\/modules]\/<module>\/META-INF\/preview\/<path>\"} preview\n+     *     resource or directory:<br>\n+     *     {@code FLAGS_IS_PREVIEW_VERSION}, and additionally {@code\n+     *     FLAGS_IS_PREVIEW_ONLY} if no normal version of the resource exists.\n+     *     <li>{@code \"\/packages\"} (special case): {@code FLAGS_IS_PACKAGE_ROOT}.\n+     *     <li>{@code \"\/packages\/xxx\"} (special case): Calculated elsewhere based\n+     *     on module entries.\n+     *     <li>In all other cases, flags are zero.\n+     * <\/ul>\n+     *\n+     * @param name the jimage name of the resource or directory.\n+     * @param hasEntry a predicate for jimage names returning whether an entry\n+     *     is present.\n+     * @return flags for the ATTRIBUTE_PREVIEW_FLAGS attribute.\n+     *\/\n+    public static int getFlags(String name, Predicate<String> hasEntry) {\n+        if (name.startsWith(PACKAGES_PREFIX + \"\/\")) {\n+            throw new IllegalArgumentException(\"Package sub-directory flags handled separately: \" + name);\n+        }\n+        String start = name.startsWith(MODULES_PREFIX + \"\/\") ? MODULES_PREFIX + \"\/\" : \"\/\";\n+        int idx = name.indexOf('\/', start.length());\n+        if (idx == -1) {\n+            \/\/ Special case for \"\/packages\" root, but otherwise, no flags.\n+            return name.equals(PACKAGES_PREFIX) ? FLAGS_IS_PACKAGE_ROOT : 0;\n+        }\n+        String prefix = name.substring(0, idx);\n+        String suffix = name.substring(idx);\n+        if (suffix.startsWith(PREVIEW_INFIX + \"\/\")) {\n+            \/\/ Preview resources\/directories.\n+            String nonPreviewName = prefix + suffix.substring(PREVIEW_INFIX.length());\n+            return FLAGS_IS_PREVIEW_VERSION\n+                    | (hasEntry.test(nonPreviewName) ? 0 : FLAGS_IS_PREVIEW_ONLY);\n+        } else if (!suffix.startsWith(\"\/META-INF\/\")) {\n+            \/\/ Non-preview resources\/directories.\n+            String previewName = prefix + PREVIEW_INFIX + suffix;\n+            return hasEntry.test(previewName) ? FLAGS_HAS_PREVIEW_VERSION : 0;\n+        } else {\n+            \/\/ Edge case for things META-INF\/module-info.class etc.\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * Tests a non-preview image location's flags to see if it has preview\n+     * content associated with it.\n+     *\/\n+    public static boolean hasPreviewVersion(int flags) {\n+        return (flags & FLAGS_HAS_PREVIEW_VERSION) != 0;\n+    }\n+\n+    \/**\n+     * Tests an image location's flags to see if it only exists in preview mode.\n+     *\/\n+    public static boolean isPreviewOnly(int flags) {\n+        return (flags & FLAGS_IS_PREVIEW_ONLY) != 0;\n+    }\n+\n+    public enum LocationType {\n+        RESOURCE, MODULES_ROOT, MODULES_DIR, PACKAGES_ROOT, PACKAGES_DIR;\n+    }\n@@ -288,0 +413,4 @@\n+    public int getFlags() {\n+        return (int) getAttribute(ATTRIBUTE_PREVIEW_FLAGS);\n+    }\n+\n@@ -297,1 +426,1 @@\n-                builder.append(\"\/modules\");\n+                builder.append(MODULES_PREFIX);\n@@ -320,30 +449,0 @@\n-    String buildName(boolean includeModule, boolean includeParent,\n-            boolean includeName) {\n-        StringBuilder builder = new StringBuilder();\n-\n-        if (includeModule && getModuleOffset() != 0) {\n-            builder.append(\"\/modules\/\");\n-            builder.append(getModule());\n-         }\n-\n-        if (includeParent && getParentOffset() != 0) {\n-            builder.append('\/');\n-            builder.append(getParent());\n-        }\n-\n-        if (includeName) {\n-            if (includeModule || includeParent) {\n-                builder.append('\/');\n-            }\n-\n-            builder.append(getBase());\n-\n-            if (getExtensionOffset() != 0) {\n-                builder.append('.');\n-                builder.append(getExtension());\n-            }\n-        }\n-\n-        return builder.toString();\n-   }\n-\n@@ -362,0 +461,42 @@\n+    \/\/ Fast (zero allocation) type determination for locations.\n+    public LocationType getType() {\n+        switch (getModuleOffset()) {\n+            case ImageStrings.MODULES_STRING_OFFSET:\n+                \/\/ Locations in \/modules\/... namespace are directory entries.\n+                return LocationType.MODULES_DIR;\n+            case ImageStrings.PACKAGES_STRING_OFFSET:\n+                \/\/ Locations in \/packages\/... namespace are always 2-level\n+                \/\/ \"\/packages\/xxx\" directories.\n+                return LocationType.PACKAGES_DIR;\n+            case ImageStrings.EMPTY_STRING_OFFSET:\n+                \/\/ Only 2 choices, either the \"\/modules\" or \"\/packages\" root.\n+                assert isRootDir() : \"Invalid root directory: \" + getFullName();\n+\n+                \/\/ Temporary logic to handle package root classification until new\n+                \/\/ image reader code is committed which sets FLAGS_IS_PACKAGE_ROOT.\n+                \/\/ Base name is \"\/packages\" or \"\/modules\" (NOT \"packages\" and \"modules\").\n+                \/\/ TODO: Uncomment the FLAGS_IS_PACKAGE_ROOT test below.\n+                \/\/ return (getFlags() & FLAGS_IS_PACKAGE_ROOT) != 0\n+                return getBase().charAt(1) == 'p'\n+                        ? LocationType.PACKAGES_ROOT\n+                        : LocationType.MODULES_ROOT;\n+            default:\n+                \/\/ Anything else is \/<module>\/<path> and references a resource.\n+                return LocationType.RESOURCE;\n+        }\n+    }\n+\n+    private boolean isRootDir() {\n+        if (getModuleOffset() == 0 && getParentOffset() == 0) {\n+            String name = getFullName();\n+            return name.equals(MODULES_PREFIX) || name.equals(PACKAGES_PREFIX);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Cannot use String.format() (too early in startup for locale code).\n+        return \"ImageLocation[name='\" + getFullName() + \"', type=\" + getType() + \", flags=\" + getFlags() + \"]\";\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageLocation.java","additions":174,"deletions":33,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.ImageLocation.LocationType;\n+\n@@ -37,0 +39,1 @@\n+import java.util.Comparator;\n@@ -43,0 +46,1 @@\n+import java.util.TreeMap;\n@@ -47,0 +51,8 @@\n+import static jdk.internal.jimage.ImageLocation.LocationType.MODULES_DIR;\n+import static jdk.internal.jimage.ImageLocation.LocationType.MODULES_ROOT;\n+import static jdk.internal.jimage.ImageLocation.LocationType.PACKAGES_DIR;\n+import static jdk.internal.jimage.ImageLocation.LocationType.RESOURCE;\n+import static jdk.internal.jimage.ImageLocation.MODULES_PREFIX;\n+import static jdk.internal.jimage.ImageLocation.PACKAGES_PREFIX;\n+import static jdk.internal.jimage.ImageLocation.PREVIEW_INFIX;\n+\n@@ -89,2 +101,4 @@\n-     * Opens an image reader for a jimage file at the specified path, using the\n-     * given byte order.\n+     * Opens an image reader for a jimage file at the specified path.\n+     *\n+     * @param imagePath file system path of the jimage file.\n+     * @param mode whether to return preview resources.\n@@ -92,5 +106,2 @@\n-    public static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n-        Objects.requireNonNull(imagePath);\n-        Objects.requireNonNull(byteOrder);\n-\n-        return SharedImageReader.open(imagePath, byteOrder);\n+    public static ImageReader open(Path imagePath, PreviewMode mode) throws IOException {\n+        return open(imagePath, ByteOrder.nativeOrder(), mode);\n@@ -100,2 +111,5 @@\n-     * Opens an image reader for a jimage file at the specified path, using the\n-     * platform native byte order.\n+     * Opens an image reader for a jimage file at the specified path.\n+     *\n+     * @param imagePath file system path of the jimage file.\n+     * @param byteOrder the byte-order to be used when reading the jimage file.\n+     * @param mode controls whether preview resources are visible.\n@@ -103,2 +117,5 @@\n-    public static ImageReader open(Path imagePath) throws IOException {\n-        return open(imagePath, ByteOrder.nativeOrder());\n+    public static ImageReader open(Path imagePath, ByteOrder byteOrder, PreviewMode mode)\n+            throws IOException {\n+        Objects.requireNonNull(imagePath);\n+        Objects.requireNonNull(byteOrder);\n+        return SharedImageReader.open(imagePath, byteOrder, mode.isPreviewModeEnabled());\n@@ -217,3 +234,0 @@\n-        private static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n-        private static final String MODULES_ROOT = \"\/modules\";\n-        private static final String PACKAGES_ROOT = \"\/packages\";\n@@ -225,0 +239,27 @@\n+        static final class ReaderKey {\n+            private final Path imagePath;\n+            private final boolean previewMode;\n+\n+            public ReaderKey(Path imagePath, boolean previewMode) {\n+                this.imagePath = imagePath;\n+                this.previewMode = previewMode;\n+            }\n+\n+            @Override\n+            public boolean equals(Object obj) {\n+                \/\/ No pattern variables here (Java 8 compatible source).\n+                if (obj instanceof ReaderKey) {\n+                    ReaderKey other = (ReaderKey) obj;\n+                    return this.imagePath.equals(other.imagePath) && this.previewMode == other.previewMode;\n+                }\n+                return false;\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return imagePath.hashCode() ^ Boolean.hashCode(previewMode);\n+            }\n+        }\n+\n+        private static final Map<ReaderKey, SharedImageReader> OPEN_FILES = new HashMap<>();\n+\n@@ -235,3 +276,0 @@\n-        \/\/ Used to classify ImageLocation instances without string comparison.\n-        private final int modulesStringOffset;\n-        private final int packagesStringOffset;\n@@ -239,1 +277,8 @@\n-        private SharedImageReader(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        \/\/ Preview mode support.\n+        private final boolean previewMode;\n+        \/\/ A relativized mapping from non-preview name to directories containing\n+        \/\/ preview-only nodes. This is used to add preview-only content to\n+        \/\/ directories as they are completed.\n+        private final HashMap<String, Directory> previewDirectoriesToMerge;\n+\n+        private SharedImageReader(Path imagePath, ByteOrder byteOrder, boolean previewMode) throws IOException {\n@@ -243,4 +288,1 @@\n-            \/\/ Pick stable jimage names from which to extract string offsets (we cannot\n-            \/\/ use \"\/modules\" or \"\/packages\", since those have a module offset of zero).\n-            this.modulesStringOffset = getModuleOffset(\"\/modules\/java.base\");\n-            this.packagesStringOffset = getModuleOffset(\"\/packages\/java.lang\");\n+            this.previewMode = previewMode;\n@@ -250,4 +292,2 @@\n-            Directory packages = newDirectory(PACKAGES_ROOT);\n-            nodes.put(packages.getName(), packages);\n-            Directory modules = newDirectory(MODULES_ROOT);\n-            nodes.put(modules.getName(), modules);\n+            Directory packages = ensureCached(newDirectory(PACKAGES_PREFIX));\n+            Directory modules = ensureCached(newDirectory(MODULES_PREFIX));\n@@ -257,1 +297,8 @@\n-            nodes.put(root.getName(), root);\n+            ensureCached(root);\n+\n+            \/\/ By scanning the \/packages directory information early we can determine\n+            \/\/ which module\/package pairs have preview resources, and build the (small)\n+            \/\/ set of preview nodes early. This also ensures that preview-only entries\n+            \/\/ in the \/packages directory are not present in non-preview mode.\n+            this.previewDirectoriesToMerge = previewMode ? new HashMap<>() : null;\n+            packages.setChildren(processPackagesDirectory(previewMode));\n@@ -261,3 +308,8 @@\n-         * Returns the offset of the string denoting the leading \"module\" segment in\n-         * the given path (e.g. {@code <module>\/<path>}). We can't just pass in the\n-         * {@code \/<module>} string here because that has a module offset of zero.\n+         * Process {@code \"\/packages\/xxx\"} entries to build the child nodes for the\n+         * root {@code \"\/packages\"} node. Preview-only entries will be skipped if\n+         * {@code previewMode == false}.\n+         *\n+         * <p>If {@code previewMode == true}, this method also populates the {@link\n+         * #previewDirectoriesToMerge} map with any preview-only nodes, to be merged\n+         * into directories as they are completed. It also caches preview resources\n+         * and preview-only directories for direct lookup.\n@@ -265,6 +317,71 @@\n-        private int getModuleOffset(String path) {\n-            ImageLocation location = findLocation(path);\n-            assert location != null : \"Cannot find expected jimage location: \" + path;\n-            int offset = location.getModuleOffset();\n-            assert offset != 0 : \"Invalid module offset for jimage location: \" + path;\n-            return offset;\n+        private ArrayList<Node> processPackagesDirectory(boolean previewMode) {\n+            ImageLocation pkgRoot = findLocation(PACKAGES_PREFIX);\n+            assert pkgRoot != null : \"Invalid jimage file\";\n+            IntBuffer offsets = getOffsetBuffer(pkgRoot);\n+            ArrayList<Node> pkgDirs = new ArrayList<>(offsets.capacity());\n+            \/\/ Package path to module map, sorted in reverse order so that\n+            \/\/ longer child paths get processed first.\n+            Map<String, List<String>> previewPackagesToModules =\n+                    new TreeMap<>(Comparator.reverseOrder());\n+            for (int i = 0; i < offsets.capacity(); i++) {\n+                ImageLocation pkgDir = getLocation(offsets.get(i));\n+                int flags = pkgDir.getFlags();\n+                \/\/ A package subdirectory is \"preview only\" if all the modules\n+                \/\/ it references have that package marked as preview only.\n+                \/\/ Skipping these entries avoids empty package subdirectories.\n+                if (previewMode || !ImageLocation.isPreviewOnly(flags)) {\n+                    pkgDirs.add(ensureCached(newDirectory(pkgDir.getFullName())));\n+                }\n+                if (previewMode && ImageLocation.hasPreviewVersion(flags)) {\n+                    \/\/ Only do this in preview mode for the small set of packages with\n+                    \/\/ preview versions (the number of preview entries should be small).\n+                    List<String> moduleNames = new ArrayList<>();\n+                    ModuleReference.readNameOffsets(getOffsetBuffer(pkgDir), \/*normal*\/ false, \/*preview*\/ true)\n+                            .forEachRemaining(n -> moduleNames.add(getString(n)));\n+                    previewPackagesToModules.put(pkgDir.getBase().replace('.', '\/'), moduleNames);\n+                }\n+            }\n+            \/\/ Reverse sorted map means child directories are processed first.\n+            previewPackagesToModules.forEach((pkgPath, modules) ->\n+                    modules.forEach(modName -> processPreviewDir(MODULES_PREFIX + \"\/\" + modName, pkgPath)));\n+            \/\/ We might have skipped some preview-only package entries.\n+            pkgDirs.trimToSize();\n+            return pkgDirs;\n+        }\n+\n+        void processPreviewDir(String namePrefix, String pkgPath) {\n+            String previewDirName = namePrefix + PREVIEW_INFIX + \"\/\" + pkgPath;\n+            ImageLocation previewLoc = findLocation(previewDirName);\n+            assert previewLoc != null : \"Missing preview directory location: \" + previewDirName;\n+            String nonPreviewDirName = namePrefix + \"\/\" + pkgPath;\n+            List<Node> previewOnlyChildren = createChildNodes(previewLoc, 0, childLoc -> {\n+                String baseName = getBaseName(childLoc);\n+                String nonPreviewChildName = nonPreviewDirName + \"\/\" + baseName;\n+                boolean isPreviewOnly = ImageLocation.isPreviewOnly(childLoc.getFlags());\n+                LocationType type = childLoc.getType();\n+                if (type == RESOURCE) {\n+                    \/\/ Preview resources are cached to override non-preview versions.\n+                    Node childNode = ensureCached(newResource(nonPreviewChildName, childLoc));\n+                    return isPreviewOnly ? childNode : null;\n+                } else {\n+                    \/\/ Child directories are not cached here (they are either cached\n+                    \/\/ already or have been added to previewDirectoriesToMerge).\n+                    assert type == MODULES_DIR : \"Invalid location type: \" + childLoc;\n+                    Node childNode = nodes.get(nonPreviewChildName);\n+                    assert isPreviewOnly == (childNode != null) :\n+                            \"Inconsistent child node: \" + nonPreviewChildName;\n+                    return childNode;\n+                }\n+            });\n+            Directory previewDir = newDirectory(nonPreviewDirName);\n+            previewDir.setChildren(previewOnlyChildren);\n+            if (ImageLocation.isPreviewOnly(previewLoc.getFlags())) {\n+                \/\/ If we are preview-only, our children are also preview-only, so\n+                \/\/ this directory is a complete hierarchy and should be cached.\n+                assert !previewOnlyChildren.isEmpty() : \"Invalid empty preview-only directory: \" + nonPreviewDirName;\n+                ensureCached(previewDir);\n+            } else if (!previewOnlyChildren.isEmpty()) {\n+                \/\/ A partial directory containing extra preview-only nodes\n+                \/\/ to be merged when the non-preview directory is completed.\n+                previewDirectoriesToMerge.put(nonPreviewDirName, previewDir);\n+            }\n@@ -273,1 +390,8 @@\n-        private static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        \/\/ Adds a node to the cache, ensuring that no matching entry already existed.\n+        private <T extends Node> T ensureCached(T node) {\n+            Node existingNode = nodes.put(node.getName(), node);\n+            assert existingNode == null : \"Unexpected node already cached for: \" + node;\n+            return node;\n+        }\n+\n+        private static ImageReader open(Path imagePath, ByteOrder byteOrder, boolean previewMode) throws IOException {\n@@ -278,1 +402,2 @@\n-                SharedImageReader reader = OPEN_FILES.get(imagePath);\n+                ReaderKey key = new ReaderKey(imagePath, previewMode);\n+                SharedImageReader reader = OPEN_FILES.get(key);\n@@ -282,2 +407,2 @@\n-                    reader =  new SharedImageReader(imagePath, byteOrder);\n-                    OPEN_FILES.put(imagePath, reader);\n+                    reader = new SharedImageReader(imagePath, byteOrder, previewMode);\n+                    OPEN_FILES.put(key, reader);\n@@ -307,1 +432,1 @@\n-                    if (!OPEN_FILES.remove(this.getImagePath(), this)) {\n+                    if (!OPEN_FILES.remove(new ReaderKey(getImagePath(), previewMode), this)) {\n@@ -325,0 +450,2 @@\n+            \/\/ Root directories \"\/\", \"\/modules\" and \"\/packages\", as well\n+            \/\/ as all \"\/packages\/xxx\" subdirectories are already cached.\n@@ -327,12 +454,4 @@\n-                \/\/ We cannot get the root paths (\"\/modules\" or \"\/packages\") here\n-                \/\/ because those nodes are already in the nodes cache.\n-                if (name.startsWith(MODULES_ROOT + \"\/\")) {\n-                    \/\/ This may perform two lookups, one for a directory (in\n-                    \/\/ \"\/modules\/...\") and one for a non-prefixed resource\n-                    \/\/ (with \"\/modules\" removed).\n-                    node = buildModulesNode(name);\n-                } else if (name.startsWith(PACKAGES_ROOT + \"\/\")) {\n-                    node = buildPackagesNode(name);\n-                }\n-                if (node != null) {\n-                    nodes.put(node.getName(), node);\n+                if (name.startsWith(MODULES_PREFIX + \"\/\")) {\n+                    node = buildAndCacheModulesNode(name);\n+                } else if (name.startsWith(PACKAGES_PREFIX + \"\/\")) {\n+                    node = buildAndCacheLinkNode(name);\n@@ -362,1 +481,1 @@\n-            String nodeName = MODULES_ROOT + \"\/\" + moduleName + \"\/\" + resourcePath;\n+            String nodeName = MODULES_PREFIX + \"\/\" + moduleName + \"\/\" + resourcePath;\n@@ -368,1 +487,1 @@\n-                    if (loc != null && isResource(loc)) {\n+                    if (loc != null && loc.getType() == RESOURCE) {\n@@ -384,3 +503,4 @@\n-         * search). As such, it skips checking the nodes cache and only checks\n-         * for an entry in the jimage file, as this is faster if the resource\n-         * is not present. This also means it doesn't need synchronization.\n+         * search). As such, it skips checking the nodes cache if possible, and\n+         * only checks for an entry in the jimage file, as this is faster if the\n+         * resource is not present. This also means it doesn't need\n+         * synchronization most of the time.\n@@ -392,2 +512,12 @@\n-            \/\/ If the given module name is 'modules', then 'isResource()'\n-            \/\/ returns false to prevent false positives.\n+            \/\/ In preview mode, preview-only resources are eagerly added to the\n+            \/\/ cache, so we must check that first.\n+            if (previewMode) {\n+                String nodeName = MODULES_PREFIX + \"\/\" + moduleName + \"\/\" + resourcePath;\n+                \/\/ Synchronize as tightly as possible to reduce locking contention.\n+                synchronized (this) {\n+                    Node node = nodes.get(nodeName);\n+                    if (node != null) {\n+                        return node.isResource();\n+                    }\n+                }\n+            }\n@@ -395,1 +525,1 @@\n-            return loc != null && isResource(loc);\n+            return loc != null && loc.getType() == RESOURCE;\n@@ -404,2 +534,5 @@\n-        private Node buildModulesNode(String name) {\n-            assert name.startsWith(MODULES_ROOT + \"\/\") : \"Invalid module node name: \" + name;\n+        private Node buildAndCacheModulesNode(String name) {\n+            assert name.startsWith(MODULES_PREFIX + \"\/\") : \"Invalid module node name: \" + name;\n+            if (isPreviewName(name)) {\n+                return null;\n+            }\n@@ -411,2 +544,2 @@\n-                assert isModulesSubdirectory(loc) : \"Invalid modules directory: \" + name;\n-                return completeModuleDirectory(newDirectory(name), loc);\n+                assert loc.getType() == MODULES_DIR : \"Invalid modules directory: \" + name;\n+                return ensureCached(completeModuleDirectory(newDirectory(name), loc));\n@@ -417,2 +550,34 @@\n-            loc = findLocation(name.substring(MODULES_ROOT.length()));\n-            return loc != null && isResource(loc) ? newResource(name, loc) : null;\n+            loc = findLocation(name.substring(MODULES_PREFIX.length()));\n+            return loc != null && loc.getType() == RESOURCE\n+                    ? ensureCached(newResource(name, loc))\n+                    : null;\n+        }\n+\n+        \/**\n+         * Returns whether a directory name in the \"\/modules\/\" directory could be referencing\n+         * the \"META-INF\" directory\".\n+         *\/\n+        private boolean isMetaInf(Directory dir) {\n+            String name = dir.getName();\n+            int pathStart = name.indexOf('\/', MODULES_PREFIX.length() + 1);\n+            return name.length() == pathStart + \"\/META-INF\".length()\n+                    && name.endsWith(\"\/META-INF\");\n+        }\n+\n+        \/**\n+         * Returns whether a node name in the \"\/modules\/\" directory could be referencing\n+         * a preview resource or directory under \"META-INF\/preview\".\n+         *\/\n+        private boolean isPreviewName(String name) {\n+            int pathStart = name.indexOf('\/', MODULES_PREFIX.length() + 1);\n+            int previewEnd = pathStart + PREVIEW_INFIX.length();\n+            return pathStart > 0\n+                    && name.regionMatches(pathStart, PREVIEW_INFIX, 0, PREVIEW_INFIX.length())\n+                    && (name.length() == previewEnd || name.charAt(previewEnd) == '\/');\n+        }\n+\n+        private String getBaseName(ImageLocation loc) {\n+            \/\/ Matches logic in ImageLocation#getFullName() regarding extensions.\n+            String trailingParts = loc.getBase()\n+                    + ((loc.getExtensionOffset() != 0) ? \".\" + loc.getExtension() : \"\");\n+            return trailingParts.substring(trailingParts.lastIndexOf('\/') + 1);\n@@ -422,1 +587,1 @@\n-         * Builds a node in the \"\/packages\/...\" namespace.\n+         * Builds a link node of the form \"\/packages\/xxx\/yyy\".\n@@ -424,2 +589,2 @@\n-         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...} node\n-         * is not present in the cache.\n+         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...}\n+         * node is not present in the cache (the name is not trusted).\n@@ -427,7 +592,5 @@\n-        private Node buildPackagesNode(String name) {\n-            \/\/ There are only locations for the root \"\/packages\" or \"\/packages\/xxx\"\n-            \/\/ directories, but not the symbolic links below them (the links can be\n-            \/\/ entirely derived from the name information in the parent directory).\n-            \/\/ However, unlike resources this means that we do not have a constant\n-            \/\/ time lookup for link nodes when creating them.\n-            int packageStart = PACKAGES_ROOT.length() + 1;\n+        private Node buildAndCacheLinkNode(String name) {\n+            \/\/ There are only locations for \"\/packages\" or \"\/packages\/xxx\"\n+            \/\/ directories, but not the symbolic links below them (links are\n+            \/\/ derived from the name information in the parent directory).\n+            int packageStart = PACKAGES_PREFIX.length() + 1;\n@@ -435,8 +598,3 @@\n-            if (packageEnd == -1) {\n-                ImageLocation loc = findLocation(name);\n-                return loc != null ? completePackageDirectory(newDirectory(name), loc) : null;\n-            } else {\n-                \/\/ We cannot assume that the parent directory exists for a link node, since\n-                \/\/ the given name is untrusted and could reference a non-existent link.\n-                \/\/ However, if the parent directory is present, we can conclude that the\n-                \/\/ given name was not a valid link (or else it would already be cached).\n+            \/\/ We already built the 2-level \"\/packages\/xxx\" directories,\n+            \/\/ so if this is a 2-level name, it cannot reference a node.\n+            if (packageEnd >= 0) {\n@@ -444,8 +602,6 @@\n-                if (!nodes.containsKey(dirName)) {\n-                    ImageLocation loc = findLocation(dirName);\n-                    \/\/ If the parent location doesn't exist, the link node cannot exist.\n-                    if (loc != null) {\n-                        nodes.put(dirName, completePackageDirectory(newDirectory(dirName), loc));\n-                        \/\/ When the parent is created its child nodes are created and cached,\n-                        \/\/ but this can still return null if given name wasn't a valid link.\n-                        return nodes.get(name);\n+                \/\/ If no parent exists here, the name cannot be valid.\n+                Directory parent = (Directory) nodes.get(dirName);\n+                if (parent != null) {\n+                    if (!parent.isCompleted()) {\n+                        \/\/ This caches all child links of the parent directory.\n+                        completePackageSubdirectory(parent, findLocation(dirName));\n@@ -453,0 +609,1 @@\n+                    return nodes.get(name);\n@@ -464,1 +621,1 @@\n-            assert name.startsWith(MODULES_ROOT) || name.startsWith(PACKAGES_ROOT);\n+            assert name.startsWith(MODULES_PREFIX) || name.startsWith(PACKAGES_PREFIX);\n@@ -467,4 +624,2 @@\n-            \/\/ We cannot use 'isXxxSubdirectory()' methods here since we could\n-            \/\/ be given a top-level directory (for which that test doesn't work).\n-            \/\/ The string MUST start \"\/modules\" or \"\/packages\" here.\n-            if (name.charAt(1) == 'm') {\n+            LocationType type = loc.getType();\n+            if (type == MODULES_DIR || type == MODULES_ROOT) {\n@@ -473,1 +628,2 @@\n-                completePackageDirectory(dir, loc);\n+                assert type == PACKAGES_DIR : \"Invalid location type: \" + loc;\n+                completePackageSubdirectory(dir, loc);\n@@ -478,6 +634,1 @@\n-        \/**\n-         * Completes a modules directory by setting the list of child nodes.\n-         *\n-         * <p>The given directory can be the top level {@code \/modules} directory,\n-         * so it is NOT safe to use {@code isModulesSubdirectory(loc)} here.\n-         *\/\n+        \/** Completes a modules directory by setting the list of child nodes. *\/\n@@ -486,3 +637,11 @@\n-            List<Node> children = createChildNodes(loc, childLoc -> {\n-                if (isModulesSubdirectory(childLoc)) {\n-                    return nodes.computeIfAbsent(childLoc.getFullName(), this::newDirectory);\n+            List<Node> previewOnlyNodes = getPreviewNodesToMerge(dir);\n+            \/\/ We hide preview names from direct lookup, but must also prevent\n+            \/\/ the preview directory from appearing in any META-INF directories.\n+            boolean parentIsMetaInfDir = isMetaInf(dir);\n+            List<Node> children = createChildNodes(loc, previewOnlyNodes.size(), childLoc -> {\n+                LocationType type = childLoc.getType();\n+                if (type == MODULES_DIR) {\n+                    String name = childLoc.getFullName();\n+                    return parentIsMetaInfDir && name.endsWith(\"\/preview\")\n+                            ? null\n+                            : nodes.computeIfAbsent(name, this::newDirectory);\n@@ -490,0 +649,1 @@\n+                    assert type == RESOURCE : \"Invalid location type: \" + loc;\n@@ -495,0 +655,1 @@\n+            children.addAll(previewOnlyNodes);\n@@ -499,7 +660,2 @@\n-        \/**\n-         * Completes a package directory by setting the list of child nodes.\n-         *\n-         * <p>The given directory can be the top level {@code \/packages} directory,\n-         * so it is NOT safe to use {@code isPackagesSubdirectory(loc)} here.\n-         *\/\n-        private Directory completePackageDirectory(Directory dir, ImageLocation loc) {\n+        \/** Completes a package directory by setting the list of child nodes. *\/\n+        private void completePackageSubdirectory(Directory dir, ImageLocation loc) {\n@@ -507,20 +663,24 @@\n-            \/\/ The only directories in the \"\/packages\" namespace are \"\/packages\" or\n-            \/\/ \"\/packages\/<package>\". However, unlike \"\/modules\" directories, the\n-            \/\/ location offsets mean different things.\n-            List<Node> children;\n-            if (dir.getName().equals(PACKAGES_ROOT)) {\n-                \/\/ Top-level directory just contains a list of subdirectories.\n-                children = createChildNodes(loc, c -> nodes.computeIfAbsent(c.getFullName(), this::newDirectory));\n-            } else {\n-                \/\/ A package directory's content is array of offset PAIRS in the\n-                \/\/ Strings table, but we only need the 2nd value of each pair.\n-                IntBuffer intBuffer = getOffsetBuffer(loc);\n-                int offsetCount = intBuffer.capacity();\n-                assert (offsetCount & 0x1) == 0 : \"Offset count must be even: \" + offsetCount;\n-                children = new ArrayList<>(offsetCount \/ 2);\n-                \/\/ Iterate the 2nd offset in each pair (odd indices).\n-                for (int i = 1; i < offsetCount; i += 2) {\n-                    String moduleName = getString(intBuffer.get(i));\n-                    children.add(nodes.computeIfAbsent(\n-                            dir.getName() + \"\/\" + moduleName,\n-                            n -> newLinkNode(n, MODULES_ROOT + \"\/\" + moduleName)));\n+            assert !dir.isCompleted() : \"Directory already completed: \" + dir;\n+            assert loc.getType() == PACKAGES_DIR : \"Invalid location type: \" + loc.getType();\n+\n+            \/\/ In non-preview mode we might skip a very small number of preview-only\n+            \/\/ entries, but it's not worth \"right-sizing\" the array for that.\n+            IntBuffer offsets = getOffsetBuffer(loc);\n+            List<Node> children = new ArrayList<>(offsets.capacity() \/ 2);\n+            ModuleReference.readNameOffsets(offsets, \/*normal*\/ true, previewMode)\n+                    .forEachRemaining(n -> {\n+                        String modName = getString(n);\n+                        Node link = newLinkNode(dir.getName() + \"\/\" + modName, MODULES_PREFIX + \"\/\" + modName);\n+                        children.add(ensureCached(link));\n+                    });\n+            \/\/ If the parent directory exists, there must be at least one child node.\n+            assert !children.isEmpty() : \"Invalid empty package directory: \" + dir;\n+            dir.setChildren(children);\n+        }\n+\n+        \/** Returns the list of child preview nodes to be merged into the given directory. *\/\n+        List<Node> getPreviewNodesToMerge(Directory dir) {\n+            if (previewDirectoriesToMerge != null) {\n+                Directory mergeDir = previewDirectoriesToMerge.get(dir.getName());\n+                if (mergeDir != null) {\n+                    return mergeDir.children;\n@@ -529,3 +689,1 @@\n-            \/\/ This only happens once and \"completes\" the directory.\n-            dir.setChildren(children);\n-            return dir;\n+            return Collections.emptyList();\n@@ -535,1 +693,7 @@\n-         * Creates the list of child nodes for a {@code Directory} based on a given\n+         * Creates the list of child nodes for a modules {@code Directory} from\n+         * its parent location.\n+         *\n+         * <p>The {@code getChildFn} may return existing cached nodes rather\n+         * than creating them, and if newly created nodes are to be cached,\n+         * it is the job of {@code getChildFn}, or the caller of this method,\n+         * to do that.\n@@ -537,2 +701,7 @@\n-         * <p>Note: This cannot be used for package subdirectories as they have\n-         * child offsets stored differently to other directories.\n+         * @param loc a location relating to a \"\/modules\" directory.\n+         * @param extraNodesCount a known number of preview-only child nodes\n+         *     which will be merged onto the end of the returned list later.\n+         * @param getChildFn a function to return a node for each child location\n+         *     (or null to skip putting anything in the list).\n+         * @return the list of the non-null child nodes, returned by\n+         *     {@code getChildFn}, in the order of the locations entries.\n@@ -540,1 +709,3 @@\n-        private List<Node> createChildNodes(ImageLocation loc, Function<ImageLocation, Node> newChildFn) {\n+        private List<Node> createChildNodes(ImageLocation loc, int extraNodesCount, Function<ImageLocation, Node> getChildFn) {\n+            LocationType type = loc.getType();\n+            assert type == MODULES_DIR || type == MODULES_ROOT : \"Invalid location type: \" + loc;\n@@ -543,1 +714,1 @@\n-            List<Node> children = new ArrayList<>(childCount);\n+            List<Node> children = new ArrayList<>(childCount + extraNodesCount);\n@@ -545,1 +716,4 @@\n-                children.add(newChildFn.apply(getLocation(offsets.get(i))));\n+                Node childNode = getChildFn.apply(getLocation(offsets.get(i)));\n+                if (childNode != null) {\n+                    children.add(childNode);\n+                }\n@@ -552,1 +726,1 @@\n-            assert !isResource(dir) : \"Not a directory: \" + dir.getFullName();\n+            assert dir.getType() != RESOURCE : \"Not a directory: \" + dir.getFullName();\n@@ -559,26 +733,0 @@\n-        \/**\n-         * Efficiently determines if an image location is a resource.\n-         *\n-         * <p>A resource must have a valid module associated with it, so its\n-         * module offset must be non-zero, and not equal to the offsets for\n-         * \"\/modules\/...\" or \"\/packages\/...\" entries.\n-         *\/\n-        private boolean isResource(ImageLocation loc) {\n-            int moduleOffset = loc.getModuleOffset();\n-            return moduleOffset != 0\n-                    && moduleOffset != modulesStringOffset\n-                    && moduleOffset != packagesStringOffset;\n-        }\n-\n-        \/**\n-         * Determines if an image location is a directory in the {@code \/modules}\n-         * namespace (if so, the location name is the node name).\n-         *\n-         * <p>In jimage, every {@code ImageLocation} under {@code \/modules\/} is a\n-         * directory and has the same value for {@code getModule()}, and {@code\n-         * getModuleOffset()}.\n-         *\/\n-        private boolean isModulesSubdirectory(ImageLocation loc) {\n-            return loc.getModuleOffset() == modulesStringOffset;\n-        }\n-\n@@ -600,1 +748,0 @@\n-            assert name.equals(loc.getFullName(true)) : \"Mismatched location for resource: \" + name;\n@@ -832,1 +979,1 @@\n-        private void setChildren(List<Node> children) {\n+        private void setChildren(List<? extends Node> children) {\n@@ -837,0 +984,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":321,"deletions":173,"binary":false,"changes":494,"status":"modified"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jimage;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Function;\n-\n-\/**\n- * Factory to get ImageReader\n- *\n- * @implNote This class needs to maintain JDK 8 source compatibility.\n- *\n- * It is used internally in the JDK to implement jimage\/jrtfs access,\n- * but also compiled and delivered as part of the jrtfs.jar to support access\n- * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n- *\/\n-public class ImageReaderFactory {\n-    private ImageReaderFactory() {}\n-\n-    private static final String JAVA_HOME = System.getProperty(\"java.home\");\n-    private static final Path BOOT_MODULES_JIMAGE;\n-\n-    static {\n-        FileSystem fs;\n-        if (ImageReaderFactory.class.getClassLoader() == null) {\n-            try {\n-                fs = (FileSystem) Class.forName(\"sun.nio.fs.DefaultFileSystemProvider\")\n-                        .getMethod(\"theFileSystem\")\n-                        .invoke(null);\n-            } catch (Exception e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        } else {\n-            fs = FileSystems.getDefault();\n-        }\n-        BOOT_MODULES_JIMAGE = fs.getPath(JAVA_HOME, \"lib\", \"modules\");\n-    }\n-\n-    private static final Map<Path, ImageReader> readers = new ConcurrentHashMap<>();\n-\n-    \/**\n-     * Returns an {@code ImageReader} to read from the given image file\n-     *\/\n-    public static ImageReader get(Path jimage) throws IOException {\n-        Objects.requireNonNull(jimage);\n-        try {\n-            return readers.computeIfAbsent(jimage, OPENER);\n-        } catch (UncheckedIOException io) {\n-            throw io.getCause();\n-        }\n-    }\n-\n-    private static Function<Path, ImageReader> OPENER = new Function<Path, ImageReader>() {\n-        public ImageReader apply(Path path) {\n-            try {\n-                return ImageReader.open(path);\n-            } catch (IOException io) {\n-                throw new UncheckedIOException(io);\n-            }\n-        }\n-    };\n-\n-    \/**\n-     * Returns the {@code ImageReader} to read the image file in this\n-     * run-time image.\n-     *\n-     * @throws UncheckedIOException if an I\/O error occurs\n-     *\/\n-    public static ImageReader getImageReader() {\n-        try {\n-            return get(BOOT_MODULES_JIMAGE);\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(ioe);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReaderFactory.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,13 @@\n+    \/\/ String offset constants are useful for efficient classification\n+    \/\/ of location entries without string comparison. These may change\n+    \/\/ between jimage versions (they are checked during initialization).\n+\n+    \/** Fixed offset for the empty string in the strings table. *\/\n+    int EMPTY_STRING_OFFSET = 0;\n+    \/** Fixed offset for the string \"class\" in the strings table. *\/\n+    int CLASS_STRING_OFFSET = 1;\n+    \/** Fixed offset for the string \"modules\" in the strings table. *\/\n+    int MODULES_STRING_OFFSET = 7;\n+    \/** Fixed offset for the string \"packages\" in the strings table. *\/\n+    int PACKAGES_STRING_OFFSET = 15;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageStrings.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jimage;\n+\n+import java.nio.IntBuffer;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the module entries stored in the buffer of {@code \"\/packages\/xxx\"}\n+ * image locations (package subdirectories). These entries use flags which are\n+ * similar to, but distinct from, the {@link ImageLocation} flags, so\n+ * encapsulating them here helps avoid confusion.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ *\/\n+public final class ModuleReference implements Comparable<ModuleReference> {\n+    \/\/ These flags are additive (hence \"has-content\" rather than \"is-empty\").\n+\n+    \/** If set, this package exists in preview mode. *\/\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n+    \/** If set, this package exists in non-preview mode. *\/\n+    private static final int FLAGS_HAS_NORMAL_VERSION = 0x2;\n+    \/** If set, the associated module has resources (in normal or preview mode). *\/\n+    private static final int FLAGS_HAS_CONTENT = 0x4;\n+\n+    \/**\n+     * References are ordered with preview versions first which permits early\n+     * exit when processing preview entries (it's reversed because the default\n+     * order for a boolean is {@code false < true}).\n+     *\/\n+    private static final Comparator<ModuleReference> PREVIEW_FIRST =\n+            Comparator.comparing(ModuleReference::hasPreviewVersion).reversed()\n+                    .thenComparing(ModuleReference::name);\n+\n+    \/**\n+     * Returns a reference for non-empty packages (those with resources) in a\n+     * given module.\n+     *\n+     * <p>The same reference can be used for multiple packages in the same module.\n+     *\/\n+    public static ModuleReference forPackage(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, FLAGS_HAS_CONTENT | previewFlag(isPreview));\n+    }\n+\n+    \/**\n+     * Returns a reference for empty packages in a given module.\n+     *\n+     * <p>The same reference can be used for multiple packages in the same module.\n+     *\/\n+    public static ModuleReference forEmptyPackage(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, previewFlag(isPreview));\n+    }\n+\n+    private static int previewFlag(boolean isPreview) {\n+        return isPreview ? FLAGS_HAS_PREVIEW_VERSION : FLAGS_HAS_NORMAL_VERSION;\n+    }\n+\n+    \/** Merges two references for the same module (combining their flags). *\/\n+    public ModuleReference merge(ModuleReference other) {\n+        if (!name.equals(other.name)) {\n+            throw new IllegalArgumentException(\"Cannot merge \" + other + \" with \" + this);\n+        }\n+        \/\/ Because flags are additive, we can just OR them here.\n+        return new ModuleReference(name, flags | other.flags);\n+    }\n+\n+    private final String name;\n+    private final int flags;\n+\n+    private ModuleReference(String moduleName, int flags) {\n+        this.name = Objects.requireNonNull(moduleName);\n+        this.flags = flags;\n+    }\n+\n+    \/** Returns the module name of this reference. *\/\n+    public String name() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns whether the package associated with this reference contains\n+     * resources in this reference's module.\n+     *\n+     * <p>An invariant of the module system is that while a package may exist\n+     * under many modules, it only has content in one.\n+     *\/\n+    public boolean hasContent() {\n+        return ((flags & FLAGS_HAS_CONTENT) != 0);\n+    }\n+\n+    \/**\n+     * Returns whether the package associated with this reference has a preview\n+     * version (empty or otherwise) in this reference's module.\n+     *\/\n+    public boolean hasPreviewVersion() {\n+        return (flags & FLAGS_HAS_PREVIEW_VERSION) != 0;\n+    }\n+\n+    \/** Returns whether this reference exists only in preview mode. *\/\n+    public boolean isPreviewOnly() {\n+        return !hasNormalVersion(flags);\n+    }\n+\n+    private static boolean hasNormalVersion(int flags) {\n+        return (flags & FLAGS_HAS_NORMAL_VERSION) != 0;\n+    }\n+\n+    @Override\n+    public int compareTo(ModuleReference rhs) {\n+        return PREVIEW_FIRST.compare(this, rhs);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ModuleReference{ module=\" + name + \", flags=\" + flags + \" }\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof ModuleReference)) {\n+            return false;\n+        }\n+        ModuleReference other = (ModuleReference) obj;\n+        return name.equals(other.name) && flags == other.flags;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, flags);\n+    }\n+\n+    \/**\n+     * Reads the content buffer of a package subdirectory to return a sequence\n+     * of module name offsets in the jimage.\n+     *\n+     * @param buffer the content buffer of an {@link ImageLocation} with type\n+     *     {@link ImageLocation.LocationType#PACKAGES_DIR PACKAGES_DIR}.\n+     * @param includeNormal whether to include name offsets for modules present\n+     *     in normal (non-preview) mode.\n+     * @param includePreview whether to include name offsets for modules present\n+     *     in preview mode.\n+     * @return an iterator of module name offsets.\n+     *\/\n+    public static Iterator<Integer> readNameOffsets(\n+            IntBuffer buffer, boolean includeNormal, boolean includePreview) {\n+        int bufferSize = buffer.capacity();\n+        if (bufferSize == 0 || (bufferSize & 0x1) != 0) {\n+            throw new IllegalArgumentException(\"Invalid buffer size\");\n+        }\n+        int testFlags = (includeNormal ? FLAGS_HAS_NORMAL_VERSION : 0)\n+                + (includePreview ? FLAGS_HAS_PREVIEW_VERSION : 0);\n+        if (testFlags == 0) {\n+            throw new IllegalArgumentException(\"Invalid flags\");\n+        }\n+\n+        return new Iterator<Integer>() {\n+            private int idx = nextIdx(0);\n+\n+            int nextIdx(int idx) {\n+                for (; idx < bufferSize; idx += 2) {\n+                    \/\/ If any of the test flags are set, include this entry.\n+\n+                    \/\/ Temporarily allow for *neither* flag to be set. This is what would\n+                    \/\/ be written by a 1.0 version of the jimage flag, and indicates a\n+                    \/\/ normal resource without a preview version.\n+                    \/\/ TODO: Remove the zero-check below once image writer code is updated.\n+                    int previewFlags =\n+                            buffer.get(idx) & (FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION);\n+                    if (previewFlags == 0 || (previewFlags & testFlags) != 0) {\n+                        return idx;\n+                    } else if (!includeNormal) {\n+                        \/\/ Preview entries are first in the offset buffer, so we\n+                        \/\/ can exit early (by returning the end index) if we are\n+                        \/\/ only iterating preview entries, and have run out.\n+                        break;\n+                    }\n+                }\n+                return bufferSize;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return idx < bufferSize;\n+            }\n+\n+            @Override\n+            public Integer next() {\n+                if (idx < bufferSize) {\n+                    int nameOffset = buffer.get(idx + 1);\n+                    idx = nextIdx(idx + 2);\n+                    return nameOffset;\n+                }\n+                throw new NoSuchElementException();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Writes a list of module references to a given buffer. The given references\n+     * list is checked carefully to ensure the written buffer will be valid.\n+     *\n+     * <p>Entries are written in order, taking two integer slots per entry as\n+     * {@code [<flags>, <encoded-name>]}.\n+     *\n+     * @param refs the references to write, correctly ordered.\n+     * @param buffer destination buffer.\n+     * @param nameEncoder encoder for module names.\n+     * @throws IllegalArgumentException in the references are invalid in any way.\n+     *\/\n+    public static void write(\n+            List<ModuleReference> refs, IntBuffer buffer, Function<String, Integer> nameEncoder) {\n+        if (refs.isEmpty()) {\n+            throw new IllegalArgumentException(\"References list must be non-empty\");\n+        }\n+        int expectedCapacity = 2 * refs.size();\n+        if (buffer.capacity() != expectedCapacity) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid buffer capacity: expected \" + expectedCapacity + \", got \" + buffer.capacity());\n+        }\n+        \/\/ This catches exact duplicates in the list.\n+        refs.stream().reduce((lhs, rhs) -> {\n+            if (lhs.compareTo(rhs) >= 0) {\n+                throw new IllegalArgumentException(\"References must be strictly ordered: \" + refs);\n+            }\n+            return rhs;\n+        });\n+        \/\/ Distinct references can have the same name (but we don't allow this).\n+        if (refs.stream().map(ModuleReference::name).distinct().count() != refs.size()) {\n+            throw new IllegalArgumentException(\"Reference names must be unique: \" + refs);\n+        }\n+        if (refs.stream().filter(ModuleReference::hasContent).count() > 1) {\n+            throw new IllegalArgumentException(\"At most one reference can have content: \" + refs);\n+        }\n+        for (ModuleReference modRef : refs) {\n+            buffer.put(modRef.flags);\n+            buffer.put(nameEncoder.apply(modRef.name));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ModuleReference.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jimage;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+\/**\n+ * Specifies the preview mode used to open a jimage file via {@link ImageReader}.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ * *\/\n+public enum PreviewMode {\n+    \/**\n+     * Preview mode is disabled. No preview classes or resources will be available\n+     * in this mode.\n+     *\/\n+    DISABLED,\n+    \/**\n+     * Preview mode is enabled. If preview classes or resources exist in the jimage file,\n+     * they will be made available.\n+     *\/\n+    ENABLED,\n+    \/**\n+     * The preview mode of the current run-time, typically determined by the\n+     * {@code --enable-preview} flag.\n+     *\/\n+    FOR_RUNTIME;\n+\n+    \/**\n+     * Resolves whether preview mode should be enabled for an {@link ImageReader}.\n+     *\/\n+    public boolean isPreviewModeEnabled() {\n+        \/\/ A switch, instead of an abstract method, saves 3 subclasses.\n+        switch (this) {\n+            case DISABLED:\n+                return false;\n+            case ENABLED:\n+                return true;\n+            case FOR_RUNTIME:\n+                \/\/ We want to call jdk.internal.misc.PreviewFeatures.isEnabled(), but\n+                \/\/ is not available in older JREs, so we must look to it reflectively.\n+                Class<?> clazz;\n+                try {\n+                    clazz = Class.forName(\"jdk.internal.misc.PreviewFeatures\");\n+                } catch (ClassNotFoundException e) {\n+                    \/\/ It is valid and expected that the class might not exist (JDK-8).\n+                    return false;\n+                }\n+                try {\n+                    return (Boolean) clazz.getDeclaredMethod(\"isEnabled\").invoke(null);\n+                } catch (NoSuchMethodException | IllegalAccessException |\n+                         InvocationTargetException e) {\n+                    \/\/ But if the class exists, the method must exist and be callable.\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            default:\n+                throw new IllegalStateException(\"Invalid mode: \" + this);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/PreviewMode.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jimage;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+\n+\/**\n+ * Static holder class for singleton {@link ImageReader} instance.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ *\/\n+public class SystemImageReader {\n+    private static final ImageReader SYSTEM_IMAGE_READER;\n+\n+    static {\n+        String javaHome = System.getProperty(\"java.home\");\n+        FileSystem fs;\n+        if (SystemImageReader.class.getClassLoader() == null) {\n+            try {\n+                fs = (FileSystem) Class.forName(\"sun.nio.fs.DefaultFileSystemProvider\")\n+                        .getMethod(\"theFileSystem\")\n+                        .invoke(null);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        } else {\n+            fs = FileSystems.getDefault();\n+        }\n+        try {\n+            SYSTEM_IMAGE_READER = ImageReader.open(fs.getPath(javaHome, \"lib\", \"modules\"), PreviewMode.FOR_RUNTIME);\n+        } catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the singleton {@code ImageReader} to read the image file in this\n+     * run-time image. The returned instance must not be closed.\n+     *\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public static ImageReader get() {\n+        return SYSTEM_IMAGE_READER;\n+    }\n+\n+    private SystemImageReader() {}\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/SystemImageReader.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -61,1 +61,0 @@\n-import java.util.Map;\n@@ -66,0 +65,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -84,3 +84,9 @@\n-    JrtFileSystem(JrtFileSystemProvider provider, Map<String, ?> env)\n-            throws IOException\n-    {\n+    \/**\n+     * Special constructor for the singleton system jrt file system. This creates\n+     * a non-closable instance, and should only be called once by {@link\n+     * JrtFileSystemProvider}.\n+     *\n+     * @param provider the provider opening the file system.\n+     *\/\n+    JrtFileSystem(JrtFileSystemProvider provider)\n+            throws IOException {\n@@ -88,1 +94,1 @@\n-        this.image = SystemImage.open();  \/\/ open image file\n+        this.image = SystemImage.open(PreviewMode.FOR_RUNTIME);  \/\/ open image file\n@@ -90,1 +96,16 @@\n-        this.isClosable = env != null;\n+        \/\/ Only the system singleton jrt file system is \"unclosable\".\n+        this.isClosable = false;\n+    }\n+\n+    \/**\n+     * Creates a new, non-system, instance of the jrt file system.\n+     *\n+     * @param provider the provider opening the file system.\n+     * @param mode controls whether preview resources are visible.\n+     *\/\n+    JrtFileSystem(JrtFileSystemProvider provider, PreviewMode mode)\n+            throws IOException {\n+        this.provider = provider;\n+        this.image = SystemImage.open(mode);  \/\/ open image file\n+        this.isOpen = true;\n+        this.isClosable = true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.PreviewMode;\n+\n@@ -47,1 +49,1 @@\n- * .jimage file or exploded modules directory of underlying JDK.\n+ * a jimage file, or exploded modules directory of underlying JDK.\n@@ -110,1 +112,11 @@\n-            return new JrtFileSystem(this, env);\n+            return new JrtFileSystem(this, parsePreviewMode(env.get(\"previewMode\")));\n+        }\n+    }\n+\n+    \/\/ Currently this does not support specifying \"for runtime\", because it is\n+    \/\/ expected that callers creating non-standard image readers will not be\n+    \/\/ using them to read resources for the current runtime (they would just\n+    \/\/ use \"jrt:\" URLs if they were doing that).\n+    private static PreviewMode parsePreviewMode(Object envValue) {\n+        if (envValue instanceof String && Boolean.parseBoolean((String) envValue)) {\n+            return PreviewMode.ENABLED;\n@@ -112,0 +124,2 @@\n+        \/\/ Default (unspecified\/null or bad parameter) is to not use preview mode.\n+        return PreviewMode.DISABLED;\n@@ -211,1 +225,2 @@\n-                        this.theFileSystem = fs = new JrtFileSystem(this, null);\n+                        \/\/ Special constructor call for singleton instance.\n+                        this.theFileSystem = fs = new JrtFileSystem(this);\n@@ -229,1 +244,1 @@\n-    static final JrtPath toJrtPath(Path path) {\n+    static JrtPath toJrtPath(Path path) {\n@@ -260,1 +275,1 @@\n-    public final void delete(Path path) throws IOException {\n+    public void delete(Path path) throws IOException {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystemProvider.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -57,1 +58,1 @@\n-    static SystemImage open() throws IOException {\n+    static SystemImage open(PreviewMode mode) throws IOException {\n@@ -60,1 +61,1 @@\n-            final ImageReader image = ImageReader.open(moduleImageFile);\n+            final ImageReader image = ImageReader.open(moduleImageFile, mode);\n@@ -76,0 +77,1 @@\n+\n@@ -78,0 +80,4 @@\n+        \/\/ TODO: Support preview mode in ExplodedImage and remove this check.\n+        if (mode.isPreviewModeEnabled())\n+            throw new UnsupportedOperationException(\n+                    \"Preview mode not yet supported for exploded images\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-import jdk.internal.jimage.ImageReaderFactory;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -395,1 +395,1 @@\n-        static final ImageReader READER = ImageReaderFactory.getImageReader();\n+        static final ImageReader READER = SystemImageReader.get();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.internal.jimage.ImageReaderFactory;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -51,1 +51,1 @@\n-    private static final ImageReader READER = ImageReaderFactory.getImageReader();\n+    private static final ImageReader READER = SystemImageReader.get();\n@@ -112,0 +112,2 @@\n+        \/\/ Note: UncheckedIOException is thrown by the Node subclass in\n+        \/\/ ExplodedImage (this not obvious, so worth calling out).\n@@ -114,1 +116,1 @@\n-        } catch (IOException ioe) {\n+        } catch (IOException | UncheckedIOException ioe) {\n@@ -127,0 +129,4 @@\n+        if (path.indexOf('%') == -1) {\n+            \/\/ Nothing to decode (overwhelmingly common case).\n+            return path;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jrt\/JavaRuntimeURLConnection.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    static final int EMPTY_OFFSET = 0;\n@@ -45,5 +44,6 @@\n-        \/\/ Reserve 0 offset for empty string.\n-        int offset = addString(\"\");\n-        if (offset != 0) {\n-            throw new InternalError(\"Empty string not offset zero\");\n-        }\n+        \/\/ Frequently used\/special strings for which the offset is useful.\n+        reserveString(\"\", ImageStrings.EMPTY_STRING_OFFSET);\n+        reserveString(\"class\", ImageStrings.CLASS_STRING_OFFSET);\n+        reserveString(\"modules\", ImageStrings.MODULES_STRING_OFFSET);\n+        reserveString(\"packages\", ImageStrings.PACKAGES_STRING_OFFSET);\n+    }\n@@ -51,4 +51,4 @@\n-        \/\/ Reserve 1 offset for frequently used \".class\".\n-        offset = addString(\"class\");\n-        if (offset != 1) {\n-            throw new InternalError(\"'class' string not offset one\");\n+    private void reserveString(String value, int expectedOffset) {\n+        int offset = addString(value);\n+        if (offset != expectedOffset) {\n+            throw new InternalError(\"Reserved string \\\"\" + value + \"\\\" not at expected offset \" + expectedOffset + \"[was \" + offset + \"]\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageStringsWriter.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -94,1 +95,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -109,1 +110,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -116,1 +117,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -134,1 +135,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -161,1 +162,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -181,1 +182,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -189,1 +190,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -206,1 +207,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -340,1 +341,1 @@\n-        try (ImageReader nativeReader = ImageReader.open(imageFile)) {\n+        try (ImageReader nativeReader = ImageReader.open(imageFile, PreviewMode.DISABLED)) {\n@@ -343,1 +344,1 @@\n-        } catch (IOException expected) {\n+        } catch (IOException unexpected) {\n@@ -349,1 +350,1 @@\n-        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder));\n+        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder, PreviewMode.DISABLED));\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ModuleReference;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.nio.IntBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static jdk.internal.jimage.ModuleReference.forEmptyPackage;\n+import static jdk.internal.jimage.ModuleReference.forPackage;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ModuleReference.\n+ * @modules java.base\/jdk.internal.jimage\n+ * @run junit\/othervm -esa ModuleReferenceTest\n+ *\/\n+public final class ModuleReferenceTest {\n+    \/\/ Copied (not referenced) for testing.\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n+    private static final int FLAGS_HAS_NORMAL_VERSION = 0x2;\n+    private static final int FLAGS_HAS_CONTENT = 0x4;\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void emptyRefs(boolean isPreview) {\n+        ModuleReference ref = forEmptyPackage(\"module\", isPreview);\n+\n+        assertEquals(\"module\", ref.name());\n+        assertFalse(ref.hasContent());\n+        assertEquals(isPreview, ref.hasPreviewVersion());\n+        assertEquals(isPreview, ref.isPreviewOnly());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void resourceRefs(boolean isPreview) {\n+        ModuleReference ref = forPackage(\"module\", isPreview);\n+\n+        assertEquals(\"module\", ref.name());\n+        assertTrue(ref.hasContent());\n+        assertEquals(isPreview, ref.hasPreviewVersion());\n+        assertEquals(isPreview, ref.isPreviewOnly());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void mergedRefs(boolean isPreview) {\n+        ModuleReference emptyRef = forEmptyPackage(\"module\", true);\n+        ModuleReference resourceRef = forPackage(\"module\", isPreview);\n+        ModuleReference merged = emptyRef.merge(resourceRef);\n+\n+        \/\/ Merging preserves whether there's content.\n+        assertTrue(merged.hasContent());\n+        \/\/ And clears the preview-only status unless it was set in both.\n+        assertEquals(isPreview, merged.isPreviewOnly());\n+    }\n+\n+    @Test\n+    public void writeBuffer() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"alpha\", true),\n+                forEmptyPackage(\"beta\", false).merge(forEmptyPackage(\"beta\", true)),\n+                forPackage(\"gamma\", false),\n+                forEmptyPackage(\"zeta\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        ModuleReference.write(refs, buffer, fakeEncoder());\n+        assertArrayEquals(\n+                new int[]{\n+                        FLAGS_HAS_PREVIEW_VERSION, 100,\n+                        FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION, 101,\n+                        FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_CONTENT, 102,\n+                        FLAGS_HAS_NORMAL_VERSION, 103},\n+                buffer.array());\n+    }\n+\n+    @Test\n+    public void writeBuffer_emptyList() {\n+        IntBuffer buffer = IntBuffer.allocate(0);\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(List.of(), buffer, null));\n+        assertTrue(err.getMessage().contains(\"non-empty\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_badCapacity() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forPackage(\"first\", false),\n+                forEmptyPackage(\"alpha\", false));\n+        IntBuffer buffer = IntBuffer.allocate(10);\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"buffer capacity\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_multipleContent() {\n+        \/\/ Only one module reference (at most) can have resources.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forPackage(\"alpha\", false),\n+                forPackage(\"beta\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"content\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_badOrdering() {\n+        \/\/ Badly ordered because preview references should come first.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"alpha\", false),\n+                forEmptyPackage(\"beta\", true));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"strictly ordered\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_duplicateRef() {\n+        \/\/ Technically distinct, and correctly sorted, but with duplicate names.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"duplicate\", true),\n+                forEmptyPackage(\"duplicate\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"unique\"));\n+    }\n+\n+    @Test\n+    public void readNameOffsets() {\n+        \/\/ Preview versions must be first (important for early exit).\n+        IntBuffer buffer = IntBuffer.wrap(new int[]{\n+                FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION, 100,\n+                FLAGS_HAS_PREVIEW_VERSION, 101,\n+                FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_CONTENT, 102,\n+                FLAGS_HAS_NORMAL_VERSION, 103});\n+\n+        List<Integer> normalOffsets = asList(ModuleReference.readNameOffsets(buffer, true, false));\n+        List<Integer> previewOffsets = asList(ModuleReference.readNameOffsets(buffer, false, true));\n+        List<Integer> allOffsets = asList(ModuleReference.readNameOffsets(buffer, true, true));\n+\n+        assertEquals(List.of(100, 102, 103), normalOffsets);\n+        assertEquals(List.of(100, 101), previewOffsets);\n+        assertEquals(List.of(100, 101, 102, 103), allOffsets);\n+    }\n+\n+    @Test\n+    public void readNameOffsets_badBufferSize() {\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.readNameOffsets(IntBuffer.allocate(3), true, false));\n+        assertTrue(err.getMessage().contains(\"buffer size\"));\n+    }\n+\n+    @Test\n+    public void readNameOffsets_badFlags() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[]{FLAGS_HAS_CONTENT, 100});\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.readNameOffsets(buffer, false, false));\n+        assertTrue(err.getMessage().contains(\"flags\"));\n+    }\n+\n+    @Test\n+    public void sortOrder_previewFirst() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackage(\"normal.beta\", false),\n+                forPackage(\"preview.beta\", true),\n+                forEmptyPackage(\"preview.alpha\", true),\n+                forEmptyPackage(\"normal.alpha\", false));\n+        refs.sort(Comparator.naturalOrder());\n+        \/\/ Non-empty first with remaining sorted by name.\n+        assertEquals(\n+                List.of(\"preview.alpha\", \"preview.beta\", \"normal.alpha\", \"normal.beta\"),\n+                refs.stream().map(ModuleReference::name).toList());\n+    }\n+\n+    private static <T> List<T> asList(Iterator<T> src) {\n+        List<T> list = new ArrayList<>();\n+        src.forEachRemaining(list::add);\n+        return list;\n+    }\n+\n+    \/\/ Encodes strings sequentially starting from index 100.\n+    private static Function<String, Integer> fakeEncoder() {\n+        List<String> cache = new ArrayList<>();\n+        return s -> {\n+            int i = cache.indexOf(s);\n+            if (i == -1) {\n+                cache.add(s);\n+                return 100 + (cache.size() - 1);\n+            } else {\n+                return 100 + i;\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ModuleReferenceTest.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -57,1 +58,1 @@\n-        try (final ImageReader reader = ImageReader.open(imagePath)) {\n+        try (final ImageReader reader = ImageReader.open(imagePath, PreviewMode.DISABLED)) {\n","filename":"test\/jdk\/tools\/jimage\/ImageReaderDuplicateChildNodesTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -42,1 +43,0 @@\n-import java.nio.ByteOrder;\n@@ -74,1 +74,0 @@\n-        protected ByteOrder byteOrder;\n@@ -79,1 +78,0 @@\n-            byteOrder = ByteOrder.nativeOrder();\n@@ -96,1 +94,1 @@\n-            reader = ImageReader.open(copiedImageFile, byteOrder);\n+            reader = ImageReader.open(copiedImageFile, PreviewMode.DISABLED);\n@@ -125,1 +123,1 @@\n-            reader = ImageReader.open(copiedImageFile, byteOrder);\n+            reader = ImageReader.open(copiedImageFile, PreviewMode.DISABLED);\n@@ -152,1 +150,1 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, PreviewMode.DISABLED)) {\n@@ -176,1 +174,1 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, PreviewMode.DISABLED)) {\n@@ -213,1 +211,1 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, PreviewMode.DISABLED)) {\n@@ -510,1 +508,1 @@\n-            \"\/modules\/java.base\/java\/nio\/ByteOrder.class\",\n+            \"\/modules\/java.base\/java\/nio\/PreviewMode.DISABLED.class\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}