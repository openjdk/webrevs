{"files":[{"patch":"@@ -210,1 +210,2 @@\n-        \"{,**\/}.git\"\n+        \"{,**\/}.git\",\n+        \"{,**\/}core.[0-9]*\"\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-      genCollectedHeap.cpp \\\n@@ -230,1 +229,0 @@\n-      hashtable.cpp \\\n@@ -248,1 +246,0 @@\n-      markSweep.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -187,0 +187,12 @@\n+  ifeq ($$($1_Type), Boolean)\n+    $1_type := boolean\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -Kbyte\n+    $1_ARGS += -KShorterThanInt\n+  endif\n+\n@@ -196,0 +208,1 @@\n+    $1_ARGS += -KShorterThanInt\n@@ -205,0 +218,2 @@\n+\n+    $1_ARGS += -KShorterThanInt\n@@ -214,0 +229,2 @@\n+\n+    $1_ARGS += -KShorterThanInt\n@@ -290,1 +307,1 @@\n-VARHANDLES_MEMORY_SEGMENT_TYPES := Byte Short Char Int Long Float Double\n+VARHANDLES_MEMORY_SEGMENT_TYPES := Boolean Byte Short Char Int Long Float Double\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -886,1 +886,0 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n@@ -1527,1 +1526,0 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4088,0 +4088,89 @@\n+  \/\/ Execute one round of keccak of two computations in parallel.\n+  \/\/ One of the states should be loaded into the lower halves of\n+  \/\/ the vector registers v0-v24, the other should be loaded into\n+  \/\/ the upper halves of those registers. The ld1r instruction loads\n+  \/\/ the round constant into both halves of register v31.\n+  \/\/ Intermediate results c0...c5 and d0...d5 are computed\n+  \/\/ in registers v25...v30.\n+  \/\/ All vector instructions that are used operate on both register\n+  \/\/ halves in parallel.\n+  \/\/ If only a single computation is needed, one can only load the lower halves.\n+  void keccak_round(Register rscratch1) {\n+  __ eor3(v29, __ T16B, v4, v9, v14);       \/\/ c4 = a4 ^ a9 ^ a14\n+  __ eor3(v26, __ T16B, v1, v6, v11);       \/\/ c1 = a1 ^ a16 ^ a11\n+  __ eor3(v28, __ T16B, v3, v8, v13);       \/\/ c3 = a3 ^ a8 ^a13\n+  __ eor3(v25, __ T16B, v0, v5, v10);       \/\/ c0 = a0 ^ a5 ^ a10\n+  __ eor3(v27, __ T16B, v2, v7, v12);       \/\/ c2 = a2 ^ a7 ^ a12\n+  __ eor3(v29, __ T16B, v29, v19, v24);     \/\/ c4 ^= a19 ^ a24\n+  __ eor3(v26, __ T16B, v26, v16, v21);     \/\/ c1 ^= a16 ^ a21\n+  __ eor3(v28, __ T16B, v28, v18, v23);     \/\/ c3 ^= a18 ^ a23\n+  __ eor3(v25, __ T16B, v25, v15, v20);     \/\/ c0 ^= a15 ^ a20\n+  __ eor3(v27, __ T16B, v27, v17, v22);     \/\/ c2 ^= a17 ^ a22\n+\n+  __ rax1(v30, __ T2D, v29, v26);           \/\/ d0 = c4 ^ rol(c1, 1)\n+  __ rax1(v26, __ T2D, v26, v28);           \/\/ d2 = c1 ^ rol(c3, 1)\n+  __ rax1(v28, __ T2D, v28, v25);           \/\/ d4 = c3 ^ rol(c0, 1)\n+  __ rax1(v25, __ T2D, v25, v27);           \/\/ d1 = c0 ^ rol(c2, 1)\n+  __ rax1(v27, __ T2D, v27, v29);           \/\/ d3 = c2 ^ rol(c4, 1)\n+\n+  __ eor(v0, __ T16B, v0, v30);             \/\/ a0 = a0 ^ d0\n+  __ xar(v29, __ T2D, v1,  v25, (64 - 1));  \/\/ a10' = rol((a1^d1), 1)\n+  __ xar(v1,  __ T2D, v6,  v25, (64 - 44)); \/\/ a1 = rol(a6^d1), 44)\n+  __ xar(v6,  __ T2D, v9,  v28, (64 - 20)); \/\/ a6 = rol((a9^d4), 20)\n+  __ xar(v9,  __ T2D, v22, v26, (64 - 61)); \/\/ a9 = rol((a22^d2), 61)\n+  __ xar(v22, __ T2D, v14, v28, (64 - 39)); \/\/ a22 = rol((a14^d4), 39)\n+  __ xar(v14, __ T2D, v20, v30, (64 - 18)); \/\/ a14 = rol((a20^d0), 18)\n+  __ xar(v31, __ T2D, v2,  v26, (64 - 62)); \/\/ a20' = rol((a2^d2), 62)\n+  __ xar(v2,  __ T2D, v12, v26, (64 - 43)); \/\/ a2 = rol((a12^d2), 43)\n+  __ xar(v12, __ T2D, v13, v27, (64 - 25)); \/\/ a12 = rol((a13^d3), 25)\n+  __ xar(v13, __ T2D, v19, v28, (64 - 8));  \/\/ a13 = rol((a19^d4), 8)\n+  __ xar(v19, __ T2D, v23, v27, (64 - 56)); \/\/ a19 = rol((a23^d3), 56)\n+  __ xar(v23, __ T2D, v15, v30, (64 - 41)); \/\/ a23 = rol((a15^d0), 41)\n+  __ xar(v15, __ T2D, v4,  v28, (64 - 27)); \/\/ a15 = rol((a4^d4), 27)\n+  __ xar(v28, __ T2D, v24, v28, (64 - 14)); \/\/ a4' = rol((a24^d4), 14)\n+  __ xar(v24, __ T2D, v21, v25, (64 - 2));  \/\/ a24 = rol((a21^d1), 2)\n+  __ xar(v8,  __ T2D, v8,  v27, (64 - 55)); \/\/ a21' = rol((a8^d3), 55)\n+  __ xar(v4,  __ T2D, v16, v25, (64 - 45)); \/\/ a8' = rol((a16^d1), 45)\n+  __ xar(v16, __ T2D, v5,  v30, (64 - 36)); \/\/ a16 = rol((a5^d0), 36)\n+  __ xar(v5,  __ T2D, v3,  v27, (64 - 28)); \/\/ a5 = rol((a3^d3), 28)\n+  __ xar(v27, __ T2D, v18, v27, (64 - 21)); \/\/ a3' = rol((a18^d3), 21)\n+  __ xar(v3,  __ T2D, v17, v26, (64 - 15)); \/\/ a18' = rol((a17^d2), 15)\n+  __ xar(v25, __ T2D, v11, v25, (64 - 10)); \/\/ a17' = rol((a11^d1), 10)\n+  __ xar(v26, __ T2D, v7,  v26, (64 - 6));  \/\/ a11' = rol((a7^d2), 6)\n+  __ xar(v30, __ T2D, v10, v30, (64 - 3));  \/\/ a7' = rol((a10^d0), 3)\n+\n+  __ bcax(v20, __ T16B, v31, v22, v8);      \/\/ a20 = a20' ^ (~a21 & a22')\n+  __ bcax(v21, __ T16B, v8,  v23, v22);     \/\/ a21 = a21' ^ (~a22 & a23)\n+  __ bcax(v22, __ T16B, v22, v24, v23);     \/\/ a22 = a22 ^ (~a23 & a24)\n+  __ bcax(v23, __ T16B, v23, v31, v24);     \/\/ a23 = a23 ^ (~a24 & a20')\n+  __ bcax(v24, __ T16B, v24, v8,  v31);     \/\/ a24 = a24 ^ (~a20' & a21')\n+\n+  __ ld1r(v31, __ T2D, __ post(rscratch1, 8)); \/\/ rc = round_constants[i]\n+\n+  __ bcax(v17, __ T16B, v25, v19, v3);      \/\/ a17 = a17' ^ (~a18' & a19)\n+  __ bcax(v18, __ T16B, v3,  v15, v19);     \/\/ a18 = a18' ^ (~a19 & a15')\n+  __ bcax(v19, __ T16B, v19, v16, v15);     \/\/ a19 = a19 ^ (~a15 & a16)\n+  __ bcax(v15, __ T16B, v15, v25, v16);     \/\/ a15 = a15 ^ (~a16 & a17')\n+  __ bcax(v16, __ T16B, v16, v3,  v25);     \/\/ a16 = a16 ^ (~a17' & a18')\n+\n+  __ bcax(v10, __ T16B, v29, v12, v26);     \/\/ a10 = a10' ^ (~a11' & a12)\n+  __ bcax(v11, __ T16B, v26, v13, v12);     \/\/ a11 = a11' ^ (~a12 & a13)\n+  __ bcax(v12, __ T16B, v12, v14, v13);     \/\/ a12 = a12 ^ (~a13 & a14)\n+  __ bcax(v13, __ T16B, v13, v29, v14);     \/\/ a13 = a13 ^ (~a14 & a10')\n+  __ bcax(v14, __ T16B, v14, v26, v29);     \/\/ a14 = a14 ^ (~a10' & a11')\n+\n+  __ bcax(v7, __ T16B, v30, v9,  v4);       \/\/ a7 = a7' ^ (~a8' & a9)\n+  __ bcax(v8, __ T16B, v4,  v5,  v9);       \/\/ a8 = a8' ^ (~a9 & a5)\n+  __ bcax(v9, __ T16B, v9,  v6,  v5);       \/\/ a9 = a9 ^ (~a5 & a6)\n+  __ bcax(v5, __ T16B, v5,  v30, v6);       \/\/ a5 = a5 ^ (~a6 & a7)\n+  __ bcax(v6, __ T16B, v6,  v4,  v30);      \/\/ a6 = a6 ^ (~a7 & a8')\n+\n+  __ bcax(v3, __ T16B, v27, v0,  v28);      \/\/ a3 = a3' ^ (~a4' & a0)\n+  __ bcax(v4, __ T16B, v28, v1,  v0);       \/\/ a4 = a4' ^ (~a0 & a1)\n+  __ bcax(v0, __ T16B, v0,  v2,  v1);       \/\/ a0 = a0 ^ (~a1 & a2)\n+  __ bcax(v1, __ T16B, v1,  v27, v2);       \/\/ a1 = a1 ^ (~a2 & a3)\n+  __ bcax(v2, __ T16B, v2,  v28, v27);      \/\/ a2 = a2 ^ (~a3 & a4')\n+\n+  __ eor(v0, __ T16B, v0, v31);             \/\/ a0 = a0 ^ rc\n+  }\n+\n@@ -4192,1 +4281,1 @@\n-    \/\/ block_size == 144, bit5 == 0, SHA3-244\n+    \/\/ block_size == 144, bit5 == 0, SHA3-224\n@@ -4221,76 +4310,1 @@\n-    __ eor3(v29, __ T16B, v4, v9, v14);\n-    __ eor3(v26, __ T16B, v1, v6, v11);\n-    __ eor3(v28, __ T16B, v3, v8, v13);\n-    __ eor3(v25, __ T16B, v0, v5, v10);\n-    __ eor3(v27, __ T16B, v2, v7, v12);\n-    __ eor3(v29, __ T16B, v29, v19, v24);\n-    __ eor3(v26, __ T16B, v26, v16, v21);\n-    __ eor3(v28, __ T16B, v28, v18, v23);\n-    __ eor3(v25, __ T16B, v25, v15, v20);\n-    __ eor3(v27, __ T16B, v27, v17, v22);\n-\n-    __ rax1(v30, __ T2D, v29, v26);\n-    __ rax1(v26, __ T2D, v26, v28);\n-    __ rax1(v28, __ T2D, v28, v25);\n-    __ rax1(v25, __ T2D, v25, v27);\n-    __ rax1(v27, __ T2D, v27, v29);\n-\n-    __ eor(v0, __ T16B, v0, v30);\n-    __ xar(v29, __ T2D, v1,  v25, (64 - 1));\n-    __ xar(v1,  __ T2D, v6,  v25, (64 - 44));\n-    __ xar(v6,  __ T2D, v9,  v28, (64 - 20));\n-    __ xar(v9,  __ T2D, v22, v26, (64 - 61));\n-    __ xar(v22, __ T2D, v14, v28, (64 - 39));\n-    __ xar(v14, __ T2D, v20, v30, (64 - 18));\n-    __ xar(v31, __ T2D, v2,  v26, (64 - 62));\n-    __ xar(v2,  __ T2D, v12, v26, (64 - 43));\n-    __ xar(v12, __ T2D, v13, v27, (64 - 25));\n-    __ xar(v13, __ T2D, v19, v28, (64 - 8));\n-    __ xar(v19, __ T2D, v23, v27, (64 - 56));\n-    __ xar(v23, __ T2D, v15, v30, (64 - 41));\n-    __ xar(v15, __ T2D, v4,  v28, (64 - 27));\n-    __ xar(v28, __ T2D, v24, v28, (64 - 14));\n-    __ xar(v24, __ T2D, v21, v25, (64 - 2));\n-    __ xar(v8,  __ T2D, v8,  v27, (64 - 55));\n-    __ xar(v4,  __ T2D, v16, v25, (64 - 45));\n-    __ xar(v16, __ T2D, v5,  v30, (64 - 36));\n-    __ xar(v5,  __ T2D, v3,  v27, (64 - 28));\n-    __ xar(v27, __ T2D, v18, v27, (64 - 21));\n-    __ xar(v3,  __ T2D, v17, v26, (64 - 15));\n-    __ xar(v25, __ T2D, v11, v25, (64 - 10));\n-    __ xar(v26, __ T2D, v7,  v26, (64 - 6));\n-    __ xar(v30, __ T2D, v10, v30, (64 - 3));\n-\n-    __ bcax(v20, __ T16B, v31, v22, v8);\n-    __ bcax(v21, __ T16B, v8,  v23, v22);\n-    __ bcax(v22, __ T16B, v22, v24, v23);\n-    __ bcax(v23, __ T16B, v23, v31, v24);\n-    __ bcax(v24, __ T16B, v24, v8,  v31);\n-\n-    __ ld1r(v31, __ T2D, __ post(rscratch1, 8));\n-\n-    __ bcax(v17, __ T16B, v25, v19, v3);\n-    __ bcax(v18, __ T16B, v3,  v15, v19);\n-    __ bcax(v19, __ T16B, v19, v16, v15);\n-    __ bcax(v15, __ T16B, v15, v25, v16);\n-    __ bcax(v16, __ T16B, v16, v3,  v25);\n-\n-    __ bcax(v10, __ T16B, v29, v12, v26);\n-    __ bcax(v11, __ T16B, v26, v13, v12);\n-    __ bcax(v12, __ T16B, v12, v14, v13);\n-    __ bcax(v13, __ T16B, v13, v29, v14);\n-    __ bcax(v14, __ T16B, v14, v26, v29);\n-\n-    __ bcax(v7, __ T16B, v30, v9,  v4);\n-    __ bcax(v8, __ T16B, v4,  v5,  v9);\n-    __ bcax(v9, __ T16B, v9,  v6,  v5);\n-    __ bcax(v5, __ T16B, v5,  v30, v6);\n-    __ bcax(v6, __ T16B, v6,  v4,  v30);\n-\n-    __ bcax(v3, __ T16B, v27, v0,  v28);\n-    __ bcax(v4, __ T16B, v28, v1,  v0);\n-    __ bcax(v0, __ T16B, v0,  v2,  v1);\n-    __ bcax(v1, __ T16B, v1,  v27, v2);\n-    __ bcax(v2, __ T16B, v2,  v28, v27);\n-\n-    __ eor(v0, __ T16B, v0, v31);\n+    keccak_round(rscratch1);\n@@ -4315,0 +4329,89 @@\n+    \/\/ restore callee-saved registers\n+    __ ldpd(v14, v15, Address(sp, 48));\n+    __ ldpd(v12, v13, Address(sp, 32));\n+    __ ldpd(v10, v11, Address(sp, 16));\n+    __ ldpd(v8, v9, __ post(sp, 64));\n+\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - long[]  state0\n+  \/\/   c_rarg1   - long[]  state1\n+  address generate_double_keccak() {\n+    static const uint64_t round_consts[24] = {\n+      0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n+      0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n+      0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n+      0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n+      0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n+      0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n+      0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n+      0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n+    };\n+\n+    \/\/ Implements the double_keccak() method of the\n+    \/\/ sun.secyrity.provider.SHA3Parallel class\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"double_keccak\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register state0        = c_rarg0;\n+    Register state1        = c_rarg1;\n+\n+    Label rounds24_loop;\n+\n+    \/\/ save callee-saved registers\n+    __ stpd(v8, v9, __ pre(sp, -64));\n+    __ stpd(v10, v11, Address(sp, 16));\n+    __ stpd(v12, v13, Address(sp, 32));\n+    __ stpd(v14, v15, Address(sp, 48));\n+\n+    \/\/ load states\n+    __ add(rscratch1, state0, 32);\n+    __ ld4(v0, v1, v2,  v3, __ D, 0,  state0);\n+    __ ld4(v4, v5, v6,  v7, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v8, v9, v10, v11, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v12, v13, v14, v15, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v16, v17, v18, v19, __ D, 0, __ post(rscratch1, 32));\n+    __ ld4(v20, v21, v22, v23, __ D, 0, __ post(rscratch1, 32));\n+    __ ld1(v24, __ D, 0, rscratch1);\n+    __ add(rscratch1, state1, 32);\n+    __ ld4(v0, v1, v2,  v3,  __ D, 1, state1);\n+    __ ld4(v4, v5, v6,  v7, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v8, v9, v10, v11, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v12, v13, v14, v15, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v16, v17, v18, v19, __ D, 1, __ post(rscratch1, 32));\n+    __ ld4(v20, v21, v22, v23, __ D, 1, __ post(rscratch1, 32));\n+    __ ld1(v24, __ D, 1, rscratch1);\n+\n+    \/\/ 24 keccak rounds\n+    __ movw(rscratch2, 24);\n+\n+    \/\/ load round_constants base\n+    __ lea(rscratch1, ExternalAddress((address) round_consts));\n+\n+    __ BIND(rounds24_loop);\n+    __ subw(rscratch2, rscratch2, 1);\n+    keccak_round(rscratch1);\n+    __ cbnzw(rscratch2, rounds24_loop);\n+\n+    __ st4(v0, v1, v2,  v3,  __ D, 0, __ post(state0, 32));\n+    __ st4(v4, v5, v6,  v7,  __ D, 0, __ post(state0, 32));\n+    __ st4(v8, v9, v10, v11, __ D, 0, __ post(state0, 32));\n+    __ st4(v12, v13, v14, v15, __ D, 0, __ post(state0, 32));\n+    __ st4(v16, v17, v18, v19, __ D, 0, __ post(state0, 32));\n+    __ st4(v20, v21, v22, v23, __ D, 0, __ post(state0, 32));\n+    __ st1(v24, __ D, 0, state0);\n+    __ st4(v0, v1, v2,  v3,  __ D, 1, __ post(state1, 32));\n+    __ st4(v4, v5, v6,  v7, __ D, 1, __ post(state1, 32));\n+    __ st4(v8, v9, v10, v11, __ D, 1, __ post(state1, 32));\n+    __ st4(v12, v13, v14, v15, __ D, 1, __ post(state1, 32));\n+    __ st4(v16, v17, v18, v19, __ D, 1, __ post(state1, 32));\n+    __ st4(v20, v21, v22, v23, __ D, 1, __ post(state1, 32));\n+    __ st1(v24, __ D, 1, state1);\n+\n+    \/\/ restore callee-saved vector registers\n@@ -4320,0 +4423,2 @@\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n@@ -4563,0 +4668,955 @@\n+  void dilithium_load16zetas(int o0, Register zetas) {\n+    __ ldpq(as_FloatRegister(o0), as_FloatRegister(o0 + 1), __ post (zetas, 32));\n+    __ ldpq(as_FloatRegister(o0 + 2), as_FloatRegister(o0 + 3), __ post (zetas, 32));\n+\n+  }\n+\n+  void dilithium_load32zetas(Register zetas) {\n+    dilithium_load16zetas(16, zetas);\n+    dilithium_load16zetas(20, zetas);\n+  }\n+\n+  \/\/ 2x16 32-bit Montgomery multiplications in parallel\n+  \/\/ See the montMul() method of the sun.security.provider.ML_DSA class.\n+  \/\/ Here MONT_R_BITS is 32, so the right shift by it is implicit.\n+  \/\/ The constants qInv = MONT_Q_INV_MOD_R and q = MONT_Q are loaded in\n+  \/\/ (all 32-bit chunks of) vector registers v30 and v31, resp.\n+  \/\/ The inputs are b[i]s in v0-v7 and c[i]s v16-v23 and\n+  \/\/ the results are a[i]s in v16-v23, four 32-bit values in each register\n+  \/\/ and we do a_i = b_i * c_i * 2^-32 mod MONT_Q for all\n+  void dilithium_montmul32(bool by_constant) {\n+    FloatRegister vr0 = by_constant ? v29 : v0;\n+    FloatRegister vr1 = by_constant ? v29 : v1;\n+    FloatRegister vr2 = by_constant ? v29 : v2;\n+    FloatRegister vr3 = by_constant ? v29 : v3;\n+    FloatRegister vr4 = by_constant ? v29 : v4;\n+    FloatRegister vr5 = by_constant ? v29 : v5;\n+    FloatRegister vr6 = by_constant ? v29 : v6;\n+    FloatRegister vr7 = by_constant ? v29 : v7;\n+\n+    __ sqdmulh(v24, __ T4S, vr0, v16); \/\/ aHigh = hi32(2 * b * c)\n+    __ mulv(v16, __ T4S, vr0, v16);    \/\/ aLow = lo32(b * c)\n+    __ sqdmulh(v25, __ T4S, vr1, v17);\n+    __ mulv(v17, __ T4S, vr1, v17);\n+    __ sqdmulh(v26, __ T4S, vr2, v18);\n+    __ mulv(v18, __ T4S, vr2, v18);\n+    __ sqdmulh(v27, __ T4S, vr3, v19);\n+    __ mulv(v19, __ T4S, vr3, v19);\n+\n+    __ mulv(v16, __ T4S, v16, v30);     \/\/ m = aLow * qinv\n+    __ mulv(v17, __ T4S, v17, v30);\n+    __ mulv(v18, __ T4S, v18, v30);\n+    __ mulv(v19, __ T4S, v19, v30);\n+\n+    __ sqdmulh(v16, __ T4S, v16, v31);  \/\/ n = hi32(2 * m * q)\n+    __ sqdmulh(v17, __ T4S, v17, v31);\n+    __ sqdmulh(v18, __ T4S, v18, v31);\n+    __ sqdmulh(v19, __ T4S, v19, v31);\n+\n+    __ shsubv(v16, __ T4S, v24, v16);   \/\/ a = (aHigh - n) \/ 2\n+    __ shsubv(v17, __ T4S, v25, v17);\n+    __ shsubv(v18, __ T4S, v26, v18);\n+    __ shsubv(v19, __ T4S, v27, v19);\n+\n+    __ sqdmulh(v24, __ T4S, vr4, v20);\n+    __ mulv(v20, __ T4S, vr4, v20);\n+    __ sqdmulh(v25, __ T4S, vr5, v21);\n+    __ mulv(v21, __ T4S, vr5, v21);\n+    __ sqdmulh(v26, __ T4S, vr6, v22);\n+    __ mulv(v22, __ T4S, vr6, v22);\n+    __ sqdmulh(v27, __ T4S, vr7, v23);\n+    __ mulv(v23, __ T4S, vr7, v23);\n+\n+    __ mulv(v20, __ T4S, v20, v30);\n+    __ mulv(v21, __ T4S, v21, v30);\n+    __ mulv(v22, __ T4S, v22, v30);\n+    __ mulv(v23, __ T4S, v23, v30);\n+\n+    __ sqdmulh(v20, __ T4S, v20, v31);\n+    __ sqdmulh(v21, __ T4S, v21, v31);\n+    __ sqdmulh(v22, __ T4S, v22, v31);\n+    __ sqdmulh(v23, __ T4S, v23, v31);\n+\n+    __ shsubv(v20, __ T4S, v24, v20);\n+    __ shsubv(v21, __ T4S, v25, v21);\n+    __ shsubv(v22, __ T4S, v26, v22);\n+    __ shsubv(v23, __ T4S, v27, v23);\n+  }\n+\n+ \/\/ Do the addition and subtraction done in the ntt algorithm.\n+ \/\/ See sun.security.provider.ML_DSA.implDilithiumAlmostNttJava()\n+  void dilithium_add_sub32() {\n+    __ addv(v24, __ T4S, v0, v16); \/\/ coeffs[j] = coeffs[j] + tmp;\n+    __ addv(v25, __ T4S, v1, v17);\n+    __ addv(v26, __ T4S, v2, v18);\n+    __ addv(v27, __ T4S, v3, v19);\n+    __ addv(v28, __ T4S, v4, v20);\n+    __ addv(v29, __ T4S, v5, v21);\n+    __ addv(v30, __ T4S, v6, v22);\n+    __ addv(v31, __ T4S, v7, v23);\n+\n+    __ subv(v0, __ T4S, v0, v16);  \/\/ coeffs[j + l] = coeffs[j] - tmp;\n+    __ subv(v1, __ T4S, v1, v17);\n+    __ subv(v2, __ T4S, v2, v18);\n+    __ subv(v3, __ T4S, v3, v19);\n+    __ subv(v4, __ T4S, v4, v20);\n+    __ subv(v5, __ T4S, v5, v21);\n+    __ subv(v6, __ T4S, v6, v22);\n+    __ subv(v7, __ T4S, v7, v23);\n+  }\n+\n+  \/\/ Do the same computation that\n+  \/\/ dilithium_montmul32() and dilithium_add_sub32() does,\n+  \/\/ except for only 4x4 32-bit vector elements and with\n+  \/\/ different register usage.\n+  void dilithium_montmul_sub_add16() {\n+    __ sqdmulh(v24, __ T4S, v1, v16);\n+    __ mulv(v16, __ T4S, v1, v16);\n+    __ sqdmulh(v25, __ T4S, v3, v17);\n+    __ mulv(v17, __ T4S, v3, v17);\n+    __ sqdmulh(v26, __ T4S, v5, v18);\n+    __ mulv(v18, __ T4S, v5, v18);\n+    __ sqdmulh(v27, __ T4S, v7, v19);\n+    __ mulv(v19, __ T4S, v7, v19);\n+\n+    __ mulv(v16, __ T4S, v16, v30);\n+    __ mulv(v17, __ T4S, v17, v30);\n+    __ mulv(v18, __ T4S, v18, v30);\n+    __ mulv(v19, __ T4S, v19, v30);\n+\n+    __ sqdmulh(v16, __ T4S, v16, v31);\n+    __ sqdmulh(v17, __ T4S, v17, v31);\n+    __ sqdmulh(v18, __ T4S, v18, v31);\n+    __ sqdmulh(v19, __ T4S, v19, v31);\n+\n+    __ shsubv(v16, __ T4S, v24, v16);\n+    __ shsubv(v17, __ T4S, v25, v17);\n+    __ shsubv(v18, __ T4S, v26, v18);\n+    __ shsubv(v19, __ T4S, v27, v19);\n+\n+    __ subv(v1, __ T4S, v0, v16);\n+    __ subv(v3, __ T4S, v2, v17);\n+    __ subv(v5, __ T4S, v4, v18);\n+    __ subv(v7, __ T4S, v6, v19);\n+\n+    __ addv(v0, __ T4S, v0, v16);\n+    __ addv(v2, __ T4S, v2, v17);\n+    __ addv(v4, __ T4S, v4, v18);\n+    __ addv(v6, __ T4S, v6, v19);\n+  }\n+\n+  \/\/ At these levels, the indices that correspond to the 'j's (and 'j+l's)\n+  \/\/ in the Java implementation come in sequences of at least 8, so we\n+  \/\/ can use ldpq to collect the corresponding data into pairs of vector\n+  \/\/ registers.\n+  \/\/ We collect the coefficients corresponding to the 'j+l' indexes into\n+  \/\/ the vector registers v0-v7, the zetas into the vector registers v16-v23\n+  \/\/ then we do the (Montgomery) multiplications by the zetas in parallel\n+  \/\/ into v16-v23, load the coeffs corresponding to the 'j' indexes into\n+  \/\/ v0-v7, then do the additions into v24-v31 and the subtractions into\n+  \/\/ v0-v7 and finally save the results back to the coeffs array.\n+  void dilithiumNttLevel0_4(const Register dilithiumConsts,\n+    const Register coeffs, const Register zetas) {\n+    int c1 = 0;\n+    int c2 = 512;\n+    int startIncr;\n+    int incr1 = 32;\n+    int incr2 = 64;\n+    int incr3 = 96;\n+\n+    for (int level = 0; level < 5; level++) {\n+      int c1Start = c1;\n+      int c2Start = c2;\n+      if (level == 3) {\n+        incr1 = 32;\n+        incr2 = 128;\n+        incr3 = 160;\n+      } else if (level == 4) {\n+        incr1 = 64;\n+        incr2 = 128;\n+        incr3 = 192;\n+      }\n+\n+      for (int i = 0; i < 4; i++) {\n+        __ ldpq(v30, v31, Address(dilithiumConsts, 0)); \/\/ qInv, q\n+        __ ldpq(v0, v1, Address(coeffs, c2Start));\n+        __ ldpq(v2, v3, Address(coeffs, c2Start + incr1));\n+        __ ldpq(v4, v5, Address(coeffs, c2Start + incr2));\n+        __ ldpq(v6, v7, Address(coeffs, c2Start + incr3));\n+        dilithium_load32zetas(zetas);\n+        dilithium_montmul32(false);\n+        __ ldpq(v0, v1, Address(coeffs, c1Start));\n+        __ ldpq(v2, v3, Address(coeffs, c1Start + incr1));\n+        __ ldpq(v4, v5, Address(coeffs, c1Start + incr2));\n+        __ ldpq(v6, v7, Address(coeffs, c1Start + incr3));\n+        dilithium_add_sub32();\n+        __ stpq(v24, v25, Address(coeffs, c1Start));\n+        __ stpq(v26, v27, Address(coeffs, c1Start + incr1));\n+        __ stpq(v28, v29, Address(coeffs, c1Start + incr2));\n+        __ stpq(v30, v31, Address(coeffs, c1Start + incr3));\n+        __ stpq(v0, v1, Address(coeffs, c2Start));\n+        __ stpq(v2, v3, Address(coeffs, c2Start + incr1));\n+        __ stpq(v4, v5, Address(coeffs, c2Start + incr2));\n+        __ stpq(v6, v7, Address(coeffs, c2Start + incr3));\n+\n+        int k = 4 * level + i;\n+\n+        if (k > 7) {\n+          startIncr = 256;\n+        } else if (k == 5) {\n+          startIncr = 384;\n+        } else {\n+          startIncr = 128;\n+        }\n+\n+        c1Start += startIncr;\n+        c2Start += startIncr;\n+      }\n+\n+      c2 \/= 2;\n+    }\n+  }\n+\n+  \/\/ Dilithium NTT function except for the final \"normalization\" to |coeff| < Q.\n+  \/\/ Implements the method\n+  \/\/ static int implDilithiumAlmostNtt(int[] coeffs, int zetas[]) {}\n+  \/\/ of the Java class sun.security.provider\n+  \/\/\n+  \/\/ coeffs (int[256]) = c_rarg0\n+  \/\/ zetas (int[256]) = c_rarg1\n+  address generate_dilithiumAlmostNtt() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostNtt_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    const Register coeffs = c_rarg0;\n+    const Register zetas = c_rarg1;\n+\n+    const Register tmpAddr = r9;\n+    const Register dilithiumConsts = r10;\n+    const Register result = r11;\n+\n+    __ add(result, coeffs, 0);\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    \/\/ Each level represents one iteration of the outer for loop of the Java version\n+\n+    \/\/ level 0-4\n+    dilithiumNttLevel0_4(dilithiumConsts, coeffs, zetas);\n+\n+    \/\/ level 5\n+    for (int i = 0; i < 1024; i += 256) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));  \/\/ qInv, q\n+      __ ldr(v0, __ Q, Address(coeffs, i + 16));\n+      __ ldr(v1, __ Q, Address(coeffs, i + 48));\n+      __ ldr(v2, __ Q, Address(coeffs, i + 80));\n+      __ ldr(v3, __ Q, Address(coeffs, i + 112));\n+      __ ldr(v4, __ Q, Address(coeffs, i + 144));\n+      __ ldr(v5, __ Q, Address(coeffs, i + 176));\n+      __ ldr(v6, __ Q, Address(coeffs, i + 208));\n+      __ ldr(v7, __ Q, Address(coeffs, i + 240));\n+      dilithium_load32zetas(zetas);\n+      dilithium_montmul32(false);\n+      __ ldr(v0, __ Q, Address(coeffs, i));\n+      __ ldr(v1, __ Q, Address(coeffs, i + 32));\n+      __ ldr(v2, __ Q, Address(coeffs, i + 64));\n+      __ ldr(v3, __ Q, Address(coeffs, i + 96));\n+      __ ldr(v4, __ Q, Address(coeffs, i + 128));\n+      __ ldr(v5, __ Q, Address(coeffs, i + 160));\n+      __ ldr(v6, __ Q, Address(coeffs, i + 192));\n+      __ ldr(v7, __ Q, Address(coeffs, i + 224));\n+      dilithium_add_sub32();\n+      __ str(v24, __ Q, Address(coeffs, i));\n+      __ str(v25, __ Q, Address(coeffs, i + 32));\n+      __ str(v26, __ Q, Address(coeffs, i + 64));\n+      __ str(v27, __ Q, Address(coeffs, i + 96));\n+      __ str(v28, __ Q, Address(coeffs, i + 128));\n+      __ str(v29, __ Q, Address(coeffs, i + 160));\n+      __ str(v30, __ Q, Address(coeffs, i + 192));\n+      __ str(v31, __ Q, Address(coeffs, i + 224));\n+      __ str(v0, __ Q, Address(coeffs, i + 16));\n+      __ str(v1, __ Q, Address(coeffs, i + 48));\n+      __ str(v2, __ Q, Address(coeffs, i + 80));\n+      __ str(v3, __ Q, Address(coeffs, i + 112));\n+      __ str(v4, __ Q, Address(coeffs, i + 144));\n+      __ str(v5, __ Q, Address(coeffs, i + 176));\n+      __ str(v6, __ Q, Address(coeffs, i + 208));\n+      __ str(v7, __ Q, Address(coeffs, i + 240));\n+    }\n+\n+    \/\/ level 6\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));  \/\/ qInv, q\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T2D, tmpAddr);\n+      dilithium_load16zetas(16, zetas);\n+      dilithium_montmul_sub_add16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T2D, tmpAddr);\n+    }\n+\n+    \/\/ level 7\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));  \/\/ qInv, q\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T4S, tmpAddr);\n+      dilithium_load16zetas(16, zetas);\n+      dilithium_montmul_sub_add16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T4S, tmpAddr);\n+    }\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+\n+  }\n+\n+  \/\/ Do the computations that can be found in the body of the loop in\n+  \/\/ sun.security.provider.ML_DSA.implDilithiumAlmostInverseNttJava()\n+  \/\/ for 16 coefficients in parallel:\n+  \/\/ tmp = coeffs[j];\n+  \/\/ coeffs[j] = (tmp + coeffs[j + l]);\n+  \/\/ coeffs[j + l] = montMul(tmp - coeffs[j + l], -MONT_ZETAS_FOR_NTT[m]);\n+  \/\/ coefss[j]s are loaded in v0, v2, v4 and v6,\n+  \/\/ coeffs[j + l]s in v1, v3, v5 and v7,\n+  \/\/ the corresponding zetas in v16, v17, v18 and v19.\n+  void dilithium_sub_add_montmul16() {\n+    __ subv(v20, __ T4S, v0, v1);\n+    __ subv(v21, __ T4S, v2, v3);\n+    __ subv(v22, __ T4S, v4, v5);\n+    __ subv(v23, __ T4S, v6, v7);\n+\n+    __ addv(v0, __ T4S, v0, v1);\n+    __ addv(v2, __ T4S, v2, v3);\n+    __ addv(v4, __ T4S, v4, v5);\n+    __ addv(v6, __ T4S, v6, v7);\n+\n+    __ sqdmulh(v24, __ T4S, v20, v16); \/\/ aHigh = hi32(2 * b * c)\n+    __ mulv(v1, __ T4S, v20, v16);     \/\/ aLow = lo32(b * c)\n+    __ sqdmulh(v25, __ T4S, v21, v17);\n+    __ mulv(v3, __ T4S, v21, v17);\n+    __ sqdmulh(v26, __ T4S, v22, v18);\n+    __ mulv(v5, __ T4S, v22, v18);\n+    __ sqdmulh(v27, __ T4S, v23, v19);\n+    __ mulv(v7, __ T4S, v23, v19);\n+\n+    __ mulv(v1, __ T4S, v1, v30);      \/\/ m = (aLow * q)\n+    __ mulv(v3, __ T4S, v3, v30);\n+    __ mulv(v5, __ T4S, v5, v30);\n+    __ mulv(v7, __ T4S, v7, v30);\n+\n+    __ sqdmulh(v1, __ T4S, v1, v31);  \/\/ n = hi32(2 * m * q)\n+    __ sqdmulh(v3, __ T4S, v3, v31);\n+    __ sqdmulh(v5, __ T4S, v5, v31);\n+    __ sqdmulh(v7, __ T4S, v7, v31);\n+\n+    __ shsubv(v1, __ T4S, v24, v1);  \/\/ a = (aHigh  - n) \/ 2\n+    __ shsubv(v3, __ T4S, v25, v3);\n+    __ shsubv(v5, __ T4S, v26, v5);\n+    __ shsubv(v7, __ T4S, v27, v7);\n+  }\n+\n+  \/\/ At these levels, the indices that correspond to the 'j's (and 'j+l's)\n+  \/\/ in the Java implementation come in sequences of at least 8, so we\n+  \/\/ can use ldpq to collect the corresponding data into pairs of vector\n+  \/\/ registers\n+  \/\/ We collect the coefficients that correspond to the 'j's into v0-v7\n+  \/\/ the coefficiets that correspond to the 'j+l's into v16-v23 then\n+  \/\/ do the additions into v24-v31 and the subtractions into v0-v7 then\n+  \/\/ save the result of the additions, load the zetas into v16-v23\n+  \/\/ do the (Montgomery) multiplications by zeta in parallel into v16-v23\n+  \/\/ finally save the results back to the coeffs array\n+  void dilithiumInverseNttLevel3_7(const Register dilithiumConsts,\n+    const Register coeffs, const Register zetas) {\n+    int c1 = 0;\n+    int c2 = 32;\n+    int startIncr;\n+    int incr1;\n+    int incr2;\n+    int incr3;\n+\n+    for (int level = 3; level < 8; level++) {\n+      int c1Start = c1;\n+      int c2Start = c2;\n+      if (level == 3) {\n+        incr1 = 64;\n+        incr2 = 128;\n+        incr3 = 192;\n+      } else if (level == 4) {\n+        incr1 = 32;\n+        incr2 = 128;\n+        incr3 = 160;\n+      } else {\n+        incr1 = 32;\n+        incr2 = 64;\n+        incr3 = 96;\n+      }\n+\n+      for (int i = 0; i < 4; i++) {\n+        __ ldpq(v0, v1, Address(coeffs, c1Start));\n+        __ ldpq(v2, v3, Address(coeffs, c1Start + incr1));\n+        __ ldpq(v4, v5, Address(coeffs, c1Start + incr2));\n+        __ ldpq(v6, v7, Address(coeffs, c1Start + incr3));\n+        __ ldpq(v16, v17, Address(coeffs, c2Start));\n+        __ ldpq(v18, v19, Address(coeffs, c2Start + incr1));\n+        __ ldpq(v20, v21, Address(coeffs, c2Start + incr2));\n+        __ ldpq(v22, v23, Address(coeffs, c2Start + incr3));\n+        dilithium_add_sub32();\n+        __ stpq(v24, v25, Address(coeffs, c1Start));\n+        __ stpq(v26, v27, Address(coeffs, c1Start + incr1));\n+        __ stpq(v28, v29, Address(coeffs, c1Start + incr2));\n+        __ stpq(v30, v31, Address(coeffs, c1Start + incr3));\n+        __ ldpq(v30, v31, Address(dilithiumConsts, 0));   \/\/ qInv, q\n+        dilithium_load32zetas(zetas);\n+        dilithium_montmul32(false);\n+        __ stpq(v16, v17, Address(coeffs, c2Start));\n+        __ stpq(v18, v19, Address(coeffs, c2Start + incr1));\n+        __ stpq(v20, v21, Address(coeffs, c2Start + incr2));\n+        __ stpq(v22, v23, Address(coeffs, c2Start + incr3));\n+\n+        int k = 4 * level + i;\n+\n+        if (k < 24) {\n+          startIncr = 256;\n+        } else if (k == 25) {\n+          startIncr = 384;\n+        } else {\n+          startIncr = 128;\n+        }\n+\n+        c1Start += startIncr;\n+        c2Start += startIncr;\n+      }\n+\n+      c2 *= 2;\n+    }\n+  }\n+\n+  \/\/ Dilithium Inverse NTT function except the final mod Q division by 2^256.\n+  \/\/ Implements the method\n+  \/\/ static int implDilithiumAlmostInverseNtt(int[] coeffs, int[] zetas) {} of\n+  \/\/ the sun.security.provider.ML_DSA class.\n+  \/\/\n+  \/\/ coeffs (int[256]) = c_rarg0\n+  \/\/ zetas (int[256]) = c_rarg1\n+  address generate_dilithiumAlmostInverseNtt() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumAlmostInverseNtt_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    const Register coeffs = c_rarg0;\n+    const Register zetas = c_rarg1;\n+\n+    const Register tmpAddr = r9;\n+    const Register dilithiumConsts = r10;\n+    const Register result = r11;\n+\n+    __ add(result, coeffs, 0);\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    \/\/ Each level represents one iteration of the outer for loop of the Java version\n+    \/\/ level0\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));  \/\/ qInv, q\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T4S, tmpAddr);\n+      dilithium_load16zetas(16, zetas);\n+      dilithium_sub_add_montmul16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T4S, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T4S, tmpAddr);\n+    }\n+\n+    \/\/ level 1\n+    for (int i = 0; i < 1024; i += 128) {\n+      __ add(tmpAddr, coeffs, i);\n+      __ ld2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ ld2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ ld2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ ld2(v6, v7, __ T2D, tmpAddr);\n+      dilithium_load16zetas(16, zetas);\n+      dilithium_sub_add_montmul16();\n+      __ add(tmpAddr, coeffs, i);\n+      __ st2(v0, v1, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 32);\n+      __ st2(v2, v3, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 64);\n+      __ st2(v4, v5, __ T2D, tmpAddr);\n+      __ add(tmpAddr, coeffs, i + 96);\n+      __ st2(v6, v7, __ T2D, tmpAddr);\n+    }\n+\n+    \/\/level 2\n+    for (int i = 0; i < 1024; i += 256) {\n+      __ ldr(v0, __ Q, Address(coeffs, i));\n+      __ ldr(v1, __ Q, Address(coeffs, i + 32));\n+      __ ldr(v2, __ Q, Address(coeffs, i + 64));\n+      __ ldr(v3, __ Q, Address(coeffs, i + 96));\n+      __ ldr(v4, __ Q, Address(coeffs, i + 128));\n+      __ ldr(v5, __ Q, Address(coeffs, i + 160));\n+      __ ldr(v6, __ Q, Address(coeffs, i + 192));\n+      __ ldr(v7, __ Q, Address(coeffs, i + 224));\n+      __ ldr(v16, __ Q, Address(coeffs, i + 16));\n+      __ ldr(v17, __ Q, Address(coeffs, i + 48));\n+      __ ldr(v18, __ Q, Address(coeffs, i + 80));\n+      __ ldr(v19, __ Q, Address(coeffs, i + 112));\n+      __ ldr(v20, __ Q, Address(coeffs, i + 144));\n+      __ ldr(v21, __ Q, Address(coeffs, i + 176));\n+      __ ldr(v22, __ Q, Address(coeffs, i + 208));\n+      __ ldr(v23, __ Q, Address(coeffs, i + 240));\n+      dilithium_add_sub32();\n+      __ str(v24, __ Q, Address(coeffs, i));\n+      __ str(v25, __ Q, Address(coeffs, i + 32));\n+      __ str(v26, __ Q, Address(coeffs, i + 64));\n+      __ str(v27, __ Q, Address(coeffs, i + 96));\n+      __ str(v28, __ Q, Address(coeffs, i + 128));\n+      __ str(v29, __ Q, Address(coeffs, i + 160));\n+      __ str(v30, __ Q, Address(coeffs, i + 192));\n+      __ str(v31, __ Q, Address(coeffs, i + 224));\n+      dilithium_load32zetas(zetas);\n+      __ ldpq(v30, v31, Address(dilithiumConsts, 0));  \/\/ qInv, q\n+      dilithium_montmul32(false);\n+      __ str(v16, __ Q, Address(coeffs, i + 16));\n+      __ str(v17, __ Q, Address(coeffs, i + 48));\n+      __ str(v18, __ Q, Address(coeffs, i + 80));\n+      __ str(v19, __ Q, Address(coeffs, i + 112));\n+      __ str(v20, __ Q, Address(coeffs, i + 144));\n+      __ str(v21, __ Q, Address(coeffs, i + 176));\n+      __ str(v22, __ Q, Address(coeffs, i + 208));\n+      __ str(v23, __ Q, Address(coeffs, i + 240));\n+    }\n+\n+    \/\/ level 3-7\n+    dilithiumInverseNttLevel3_7(dilithiumConsts, coeffs, zetas);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+\n+  }\n+\n+  \/\/ Dilithium multiply polynomials in the NTT domain.\n+  \/\/ Straightforward implementation of the method\n+  \/\/ static int implDilithiumNttMult(\n+  \/\/              int[] result, int[] ntta, int[] nttb {} of\n+  \/\/ the sun.security.provider.ML_DSA class.\n+  \/\/\n+  \/\/ result (int[256]) = c_rarg0\n+  \/\/ poly1 (int[256]) = c_rarg1\n+  \/\/ poly2 (int[256]) = c_rarg2\n+  address generate_dilithiumNttMult() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumNttMult_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_loop;\n+\n+    const Register result = c_rarg0;\n+    const Register poly1 = c_rarg1;\n+    const Register poly2 = c_rarg2;\n+\n+    const Register dilithiumConsts = r10;\n+    const Register len = r11;\n+\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    __ ldpq(v30, v31, Address(dilithiumConsts, 0));   \/\/ qInv, q\n+    __ ldr(v29, __ Q, Address(dilithiumConsts, 48));  \/\/ rSquare\n+\n+    __ mov(len, zr);\n+    __ add(len, len, 1024);\n+\n+    __ BIND(L_loop);\n+\n+    __ ldpq(v0, v1, __ post(poly1, 32));\n+    __ ldpq(v2, v3, __ post(poly1, 32));\n+    __ ldpq(v4, v5, __ post(poly1, 32));\n+    __ ldpq(v6, v7, __ post(poly1, 32));\n+    __ ldpq(v16, v17, __ post(poly2, 32));\n+    __ ldpq(v18, v19, __ post(poly2, 32));\n+    __ ldpq(v20, v21, __ post(poly2, 32));\n+    __ ldpq(v22, v23, __ post(poly2, 32));\n+    dilithium_montmul32(false);\n+    dilithium_montmul32(true);\n+    __ stpq(v16, v17, __ post(result, 32));\n+    __ stpq(v18, v19, __ post(result, 32));\n+    __ stpq(v20, v21, __ post(result, 32));\n+    __ stpq(v22, v23, __ post(result, 32));\n+\n+    __ sub(len, len, 128);\n+    __ cmp(len, (u1)128);\n+    __ br(Assembler::GE, L_loop);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+\n+  }\n+\n+  \/\/ Dilithium Motgomery multiply an array by a constant.\n+  \/\/ A straightforward implementation of the method\n+  \/\/ static int implDilithiumMontMulByConstant(int[] coeffs, int constant) {}\n+  \/\/ of the sun.security.provider.MLDSA class\n+  \/\/\n+  \/\/ coeffs (int[256]) = c_rarg0\n+  \/\/ constant (int) = c_rarg1\n+  address generate_dilithiumMontMulByConstant() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumMontMulByConstant_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_loop;\n+\n+    const Register coeffs = c_rarg0;\n+    const Register constant = c_rarg1;\n+\n+    const Register dilithiumConsts = r10;\n+    const Register result = r11;\n+    const Register len = r12;\n+\n+    __ add(result, coeffs, 0);\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    __ ldpq(v30, v31, Address(dilithiumConsts, 0));   \/\/ qInv, q\n+    __ dup(v29, __ T4S, constant);\n+    __ mov(len, zr);\n+    __ add(len, len, 1024);\n+\n+    __ BIND(L_loop);\n+\n+    __ ldpq(v16, v17, __ post(coeffs, 32));\n+    __ ldpq(v18, v19, __ post(coeffs, 32));\n+    __ ldpq(v20, v21, __ post(coeffs, 32));\n+    __ ldpq(v22, v23, __ post(coeffs, 32));\n+    dilithium_montmul32(true);\n+    __ stpq(v16, v17, __ post(result, 32));\n+    __ stpq(v18, v19, __ post(result, 32));\n+    __ stpq(v20, v21, __ post(result, 32));\n+    __ stpq(v22, v23, __ post(result, 32));\n+\n+    __ sub(len, len, 128);\n+    __ cmp(len, (u1)128);\n+    __ br(Assembler::GE, L_loop);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Dilithium decompose poly.\n+  \/\/ Implements the method\n+  \/\/ static int implDilithiumDecomposePoly(int[] coeffs, int constant) {}\n+  \/\/ of the sun.security.provider.ML_DSA class\n+  \/\/\n+  \/\/ input (int[256]) = c_rarg0\n+  \/\/ lowPart (int[256]) = c_rarg1\n+  \/\/ highPart (int[256]) = c_rarg2\n+  \/\/ twoGamma2  (int) = c_rarg3\n+  \/\/ multiplier (int) = c_rarg4\n+  address generate_dilithiumDecomposePoly() {\n+\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::dilithiumDecomposePoly_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+    __ enter();\n+\n+    Label L_loop;\n+\n+    const Register input = c_rarg0;\n+    const Register lowPart = c_rarg1;\n+    const Register highPart = c_rarg2;\n+    const Register twoGamma2 = c_rarg3;\n+    const Register multiplier = c_rarg4;\n+\n+    const Register len = r9;\n+    const Register dilithiumConsts = r10;\n+    const Register tmp = r11;\n+\n+    __ lea(dilithiumConsts, ExternalAddress((address) StubRoutines::aarch64::_dilithiumConsts));\n+\n+    \/\/ save callee-saved registers\n+    __ stpd(v8, v9, __ pre(sp, -64));\n+    __ stpd(v10, v11, Address(sp, 16));\n+    __ stpd(v12, v13, Address(sp, 32));\n+    __ stpd(v14, v15, Address(sp, 48));\n+\n+\n+    __ mov(tmp, zr);\n+    __ add(tmp, tmp, 1);\n+    __ dup(v25, __ T4S, tmp); \/\/ 1\n+    __ ldr(v30, __ Q, Address(dilithiumConsts, 16)); \/\/ q\n+    __ ldr(v31, __ Q, Address(dilithiumConsts, 64)); \/\/ addend for mod q reduce\n+    __ dup(v28, __ T4S, twoGamma2); \/\/ 2 * gamma2\n+    __ dup(v29, __ T4S, multiplier); \/\/ multiplier for mod 2 * gamma reduce\n+    __ subv(v26, __ T4S, v30, v25); \/\/ q - 1\n+    __ sshr(v27, __ T4S, v28, 1); \/\/ gamma2\n+\n+    __ mov(len, zr);\n+    __ add(len, len, 1024);\n+\n+    __ BIND(L_loop);\n+\n+    __ ld4(v0, v1, v2, v3, __ T4S, __ post(input, 64));\n+\n+    \/\/ rplus in v0\n+    \/\/  rplus = rplus - ((rplus + 5373807) >> 23) * dilithium_q;\n+    __ addv(v4, __ T4S, v0, v31);\n+    __ addv(v5, __ T4S, v1, v31);\n+    __ addv(v6, __ T4S, v2, v31);\n+    __ addv(v7, __ T4S, v3, v31);\n+\n+    __ sshr(v4, __ T4S, v4, 23);\n+    __ sshr(v5, __ T4S, v5, 23);\n+    __ sshr(v6, __ T4S, v6, 23);\n+    __ sshr(v7, __ T4S, v7, 23);\n+\n+    __ mulv(v4, __ T4S, v4, v30);\n+    __ mulv(v5, __ T4S, v5, v30);\n+    __ mulv(v6, __ T4S, v6, v30);\n+    __ mulv(v7, __ T4S, v7, v30);\n+\n+    __ subv(v0, __ T4S, v0, v4);\n+    __ subv(v1, __ T4S, v1, v5);\n+    __ subv(v2, __ T4S, v2, v6);\n+    __ subv(v3, __ T4S, v3, v7);\n+\n+    \/\/ rplus in v0\n+    \/\/ rplus = rplus + ((rplus >> 31) & dilithium_q);\n+    __ sshr(v4, __ T4S, v0, 31);\n+    __ sshr(v5, __ T4S, v1, 31);\n+    __ sshr(v6, __ T4S, v2, 31);\n+    __ sshr(v7, __ T4S, v3, 31);\n+\n+    __ andr(v4, __ T16B, v4, v30);\n+    __ andr(v5, __ T16B, v5, v30);\n+    __ andr(v6, __ T16B, v6, v30);\n+    __ andr(v7, __ T16B, v7, v30);\n+\n+    __ addv(v0, __ T4S, v0, v4);\n+    __ addv(v1, __ T4S, v1, v5);\n+    __ addv(v2, __ T4S, v2, v6);\n+    __ addv(v3, __ T4S, v3, v7);\n+\n+    \/\/ rplus in v0\n+    \/\/ int quotient = (rplus * multiplier) >> 22;\n+    __ mulv(v4, __ T4S, v0, v29);\n+    __ mulv(v5, __ T4S, v1, v29);\n+    __ mulv(v6, __ T4S, v2, v29);\n+    __ mulv(v7, __ T4S, v3, v29);\n+\n+    __ sshr(v4, __ T4S, v4, 22);\n+    __ sshr(v5, __ T4S, v5, 22);\n+    __ sshr(v6, __ T4S, v6, 22);\n+    __ sshr(v7, __ T4S, v7, 22);\n+\n+    \/\/ quotient in v4\n+    \/\/ int r0 = rplus - quotient * twoGamma2;\n+    __ mulv(v8, __ T4S, v4, v28);\n+    __ mulv(v9, __ T4S, v5, v28);\n+    __ mulv(v10, __ T4S, v6, v28);\n+    __ mulv(v11, __ T4S, v7, v28);\n+\n+    __ subv(v8, __ T4S, v0, v8);\n+    __ subv(v9, __ T4S, v1, v9);\n+    __ subv(v10, __ T4S, v2, v10);\n+    __ subv(v11, __ T4S, v3, v11);\n+\n+    \/\/ r0 in v8\n+    \/\/ int mask = (twoGamma2 - r0) >> 22;\n+    __ subv(v12, __ T4S, v28, v8);\n+    __ subv(v13, __ T4S, v28, v9);\n+    __ subv(v14, __ T4S, v28, v10);\n+    __ subv(v15, __ T4S, v28, v11);\n+\n+    __ sshr(v12, __ T4S, v12, 22);\n+    __ sshr(v13, __ T4S, v13, 22);\n+    __ sshr(v14, __ T4S, v14, 22);\n+    __ sshr(v15, __ T4S, v15, 22);\n+\n+    \/\/ mask in v12\n+    \/\/ r0 -= (mask & twoGamma2);\n+    __ andr(v16, __ T16B, v12, v28);\n+    __ andr(v17, __ T16B, v13, v28);\n+    __ andr(v18, __ T16B, v14, v28);\n+    __ andr(v19, __ T16B, v15, v28);\n+\n+    __ subv(v8, __ T4S, v8, v16);\n+    __ subv(v9, __ T4S, v9, v17);\n+    __ subv(v10, __ T4S, v10, v18);\n+    __ subv(v11, __ T4S, v11, v19);\n+\n+    \/\/ r0 in v8\n+    \/\/  quotient += (mask & 1);\n+    __ andr(v16, __ T16B, v12, v25);\n+    __ andr(v17, __ T16B, v13, v25);\n+    __ andr(v18, __ T16B, v14, v25);\n+    __ andr(v19, __ T16B, v15, v25);\n+\n+    __ addv(v4, __ T4S, v4, v16);\n+    __ addv(v5, __ T4S, v5, v17);\n+    __ addv(v6, __ T4S, v6, v18);\n+    __ addv(v7, __ T4S, v7, v19);\n+\n+    \/\/ mask = (twoGamma2 \/ 2 - r0) >> 31;\n+    __ subv(v12, __ T4S, v27, v8);\n+    __ subv(v13, __ T4S, v27, v9);\n+    __ subv(v14, __ T4S, v27, v10);\n+    __ subv(v15, __ T4S, v27, v11);\n+\n+    __ sshr(v12, __ T4S, v12, 31);\n+    __ sshr(v13, __ T4S, v13, 31);\n+    __ sshr(v14, __ T4S, v14, 31);\n+    __ sshr(v15, __ T4S, v15, 31);\n+\n+    \/\/ r0 -= (mask & twoGamma2);\n+    __ andr(v16, __ T16B, v12, v28);\n+    __ andr(v17, __ T16B, v13, v28);\n+    __ andr(v18, __ T16B, v14, v28);\n+    __ andr(v19, __ T16B, v15, v28);\n+\n+    __ subv(v8, __ T4S, v8, v16);\n+    __ subv(v9, __ T4S, v9, v17);\n+    __ subv(v10, __ T4S, v10, v18);\n+    __ subv(v11, __ T4S, v11, v19);\n+\n+    \/\/ quotient += (mask & 1);\n+    __ andr(v16, __ T16B, v12, v25);\n+    __ andr(v17, __ T16B, v13, v25);\n+    __ andr(v18, __ T16B, v14, v25);\n+    __ andr(v19, __ T16B, v15, v25);\n+\n+    __ addv(v4, __ T4S, v4, v16);\n+    __ addv(v5, __ T4S, v5, v17);\n+    __ addv(v6, __ T4S, v6, v18);\n+    __ addv(v7, __ T4S, v7, v19);\n+\n+    \/\/ int r1 = rplus - r0 - (dilithium_q - 1);\n+    __ subv(v16, __ T4S, v0, v8);\n+    __ subv(v17, __ T4S, v1, v9);\n+    __ subv(v18, __ T4S, v2, v10);\n+    __ subv(v19, __ T4S, v3, v11);\n+\n+    __ subv(v16, __ T4S, v16, v26);\n+    __ subv(v17, __ T4S, v17, v26);\n+    __ subv(v18, __ T4S, v18, v26);\n+    __ subv(v19, __ T4S, v19, v26);\n+\n+    \/\/ r1 in v16\n+    \/\/ r1 = (r1 | (-r1)) >> 31; \/\/ 0 if rplus - r0 == (dilithium_q - 1), -1 otherwise\n+    __ negr(v20, __ T4S, v16);\n+    __ negr(v21, __ T4S, v17);\n+    __ negr(v22, __ T4S, v18);\n+    __ negr(v23, __ T4S, v19);\n+\n+    __ orr(v16, __ T16B, v16, v20);\n+    __ orr(v17, __ T16B, v17, v21);\n+    __ orr(v18, __ T16B, v18, v22);\n+    __ orr(v19, __ T16B, v19, v23);\n+\n+    __ sshr(v0, __ T4S, v16, 31);\n+    __ sshr(v1, __ T4S, v17, 31);\n+    __ sshr(v2, __ T4S, v18, 31);\n+    __ sshr(v3, __ T4S, v19, 31);\n+\n+    \/\/ r1 in v0\n+    \/\/ r0 += ~r1;\n+    __ notr(v20, __ T16B, v0);\n+    __ notr(v21, __ T16B, v1);\n+    __ notr(v22, __ T16B, v2);\n+    __ notr(v23, __ T16B, v3);\n+\n+    __ addv(v8, __ T4S, v8, v20);\n+    __ addv(v9, __ T4S, v9, v21);\n+    __ addv(v10, __ T4S, v10, v22);\n+    __ addv(v11, __ T4S, v11, v23);\n+\n+    \/\/ r0 in v8\n+    \/\/ r1 = r1 & quotient;\n+    __ andr(v0, __ T16B, v4, v0);\n+    __ andr(v1, __ T16B, v5, v1);\n+    __ andr(v2, __ T16B, v6, v2);\n+    __ andr(v3, __ T16B, v7, v3);\n+\n+    \/\/ r1 in v0\n+    \/\/ lowPart[m] = r0;\n+    \/\/ highPart[m] = r1;\n+    __ st4(v8, v9, v10, v11, __ T4S, __ post(lowPart, 64));\n+    __ st4(v0, v1, v2, v3, __ T4S, __ post(highPart, 64));\n+\n+\n+    __ sub(len, len, 64);\n+    __ cmp(len, (u1)64);\n+    __ br(Assembler::GE, L_loop);\n+\n+    \/\/ restore callee-saved vector registers\n+    __ ldpd(v14, v15, Address(sp, 48));\n+    __ ldpd(v12, v13, Address(sp, 32));\n+    __ ldpd(v10, v11, Address(sp, 16));\n+    __ ldpd(v8, v9, __ post(sp, 64));\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ mov(r0, zr); \/\/ return 0\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -9100,0 +10160,8 @@\n+    if (UseDilithiumIntrinsics) {\n+      StubRoutines::_dilithiumAlmostNtt = generate_dilithiumAlmostNtt();\n+      StubRoutines::_dilithiumAlmostInverseNtt = generate_dilithiumAlmostInverseNtt();\n+      StubRoutines::_dilithiumNttMult = generate_dilithiumNttMult();\n+      StubRoutines::_dilithiumMontMulByConstant = generate_dilithiumMontMulByConstant();\n+      StubRoutines::_dilithiumDecomposePoly = generate_dilithiumDecomposePoly();\n+    }\n+\n@@ -9142,0 +10210,1 @@\n+      StubRoutines::_double_keccak         = generate_double_keccak();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1146,"deletions":77,"binary":false,"changes":1223,"status":"modified"},{"patch":"@@ -6259,1 +6259,1 @@\n-  \/\/ LZCNT = 32 - (biased_exp - 127)\n+  \/\/ LZCNT = 31 - (biased_exp - 127)\n@@ -6266,0 +6266,6 @@\n+  \/\/ Remove the bit to the right of the highest set bit ensuring that the conversion to float cannot round up to a higher\n+  \/\/ power of 2, which has a higher exponent than the input. This transformation is valid as only the highest set bit\n+  \/\/ contributes to the leading number of zeros.\n+  vpsrld(xtmp2, src, 1, vec_enc);\n+  vpandn(xtmp3, xtmp2, src, vec_enc);\n+\n@@ -6267,1 +6273,1 @@\n-  vcvtdq2ps(dst, src, vec_enc);\n+  vcvtdq2ps(dst, xtmp3, vec_enc);\n@@ -6276,1 +6282,1 @@\n-  \/\/ Exponent = Exponent  + 1\n+  \/\/ Exponent_plus_one = Exponent + 1\n@@ -6289,1 +6295,1 @@\n-  \/\/ LZCNT = 32 - exponent\n+  \/\/ LZCNT = 32 - exponent_plus_one\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -105,16 +105,2 @@\n-    \/\/ 2..15 are implied in range usage\n-    r31_off = xmm_off + (XSAVE_AREA_EGPRS - XSAVE_AREA_BEGIN)\/BytesPerInt,\n-    r31H_off,\n-    r30_off, r30H_off,\n-    r29_off, r29H_off,\n-    r28_off, r28H_off,\n-    r27_off, r27H_off,\n-    r26_off, r26H_off,\n-    r25_off, r25H_off,\n-    r24_off, r24H_off,\n-    r23_off, r23H_off,\n-    r22_off, r22H_off,\n-    r21_off, r21H_off,\n-    r20_off, r20H_off,\n-    r19_off, r19H_off,\n-    r18_off, r18H_off,\n+    r16_off = xmm_off + (XSAVE_AREA_EGPRS - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    r16H_off,\n@@ -122,1 +108,14 @@\n-    r16_off, r16H_off,\n+    r18_off, r18H_off,\n+    r19_off, r19H_off,\n+    r20_off, r20H_off,\n+    r21_off, r21H_off,\n+    r22_off, r22H_off,\n+    r23_off, r23H_off,\n+    r24_off, r24H_off,\n+    r25_off, r25H_off,\n+    r26_off, r26H_off,\n+    r27_off, r27H_off,\n+    r28_off, r28H_off,\n+    r29_off, r29H_off,\n+    r30_off, r30H_off,\n+    r31_off, r31H_off,\n@@ -269,1 +268,1 @@\n-      for(int n = 16; n < Register::number_of_registers; n++) {\n+      for (int n = 16; n < Register::number_of_registers; n++) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1859,1 +1859,1 @@\n-  while ( (encoding = (NameAndList*)_encoding.iter()) != 0 ) {\n+  while ( (encoding = (NameAndList*)_encoding.iter()) != nullptr ) {\n@@ -1866,1 +1866,1 @@\n-    while (  (parameter = encoding->iter()) != 0 ) {\n+    while (  (parameter = encoding->iter()) != nullptr ) {\n@@ -3310,1 +3310,1 @@\n-    _lChild(lChild), _rChild(rChild), _internalop(0), _numleaves(0),\n+    _lChild(lChild), _rChild(rChild), _internalop(nullptr), _numleaves(0),\n@@ -3319,1 +3319,1 @@\n-    _internalop(0), _numleaves(mnode._numleaves),\n+    _internalop(nullptr), _numleaves(mnode._numleaves),\n@@ -3326,1 +3326,1 @@\n-    _internalop(0), _numleaves(mnode._numleaves),\n+    _internalop(nullptr), _numleaves(mnode._numleaves),\n@@ -3629,1 +3629,1 @@\n-  if (_lChild==0 && _rChild==0) {\n+  if (_lChild==nullptr && _rChild==nullptr) {\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -413,0 +413,2 @@\n+  DEBUG_ONLY(CompilationMemoryStatistic::do_test_allocations();)\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-bool CDSConfig::_has_archived_invokedynamic = false;\n@@ -80,3 +79,10 @@\n-    if (RequireSharedSpaces) {\n-      warning(\"Cannot dump shared archive while using shared archive\");\n-    }\n+    \/\/ Note: -Xshare and -XX:AOTMode flags are mutually exclusive.\n+    \/\/ - Classic workflow: -Xshare:on and -Xshare:dump cannot take effect at the same time.\n+    \/\/ - JEP 483 workflow: -XX:AOTMode:record and -XX:AOTMode=on cannot take effect at the same time.\n+    \/\/ So we can never come to here with RequireSharedSpaces==true.\n+    assert(!RequireSharedSpaces, \"sanity\");\n+\n+    \/\/ If dumping the classic archive, or making an AOT training run (dumping a preimage archive),\n+    \/\/ for sanity, parse all classes from classfiles.\n+    \/\/ TODO: in the future, if we want to support re-training on top of an existing AOT cache, this\n+    \/\/ needs to be changed.\n@@ -101,5 +107,3 @@\n-    char jvm_path[JVM_MAXPATHLEN];\n-    os::jvm_path(jvm_path, sizeof(jvm_path));\n-    char *end = strrchr(jvm_path, *os::file_separator());\n-    if (end != nullptr) *end = '\\0';\n-    tmp.print(\"%s%sclasses\", jvm_path, os::file_separator());\n+    const char* subdir = WINDOWS_ONLY(\"bin\") NOT_WINDOWS(\"lib\");\n+    tmp.print(\"%s%s%s%s%s%sclasses\", Arguments::get_java_home(), os::file_separator(), subdir,\n+              os::file_separator(), Abstract_VM_Version::vm_variant(), os::file_separator());\n@@ -766,2 +770,7 @@\n-bool CDSConfig::is_loading_invokedynamic() {\n-  return UseSharedSpaces && is_using_full_module_graph() && _has_archived_invokedynamic;\n+\/\/ When we are dumping aot-linked classes and we are able to write archived heap objects, we automatically\n+\/\/ enable the archiving of MethodHandles. This will in turn enable the archiving of MethodTypes and hidden\n+\/\/ classes that are used in the implementation of MethodHandles.\n+\/\/ Archived MethodHandles are required for higher-level optimizations such as AOT resolution of invokedynamic\n+\/\/ and dynamic proxies.\n+bool CDSConfig::is_dumping_method_handles() {\n+  return is_initing_classes_at_dump_time();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  static bool _has_archived_invokedynamic;\n@@ -171,2 +170,1 @@\n-  static bool is_loading_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  static void set_has_archived_invokedynamic()               { CDS_JAVA_HEAP_ONLY(_has_archived_invokedynamic = true); }\n+  static bool is_dumping_method_handles()                    NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-  if (CDSConfig::is_dumping_invokedynamic()) {\n+  if (CDSConfig::is_dumping_method_handles()) {\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,1 +303,0 @@\n-  _has_archived_invokedynamic = CDSConfig::is_dumping_invokedynamic();\n@@ -381,1 +380,0 @@\n-  st->print_cr(\"- has_archived_invokedynamic      %d\", _has_archived_invokedynamic);\n@@ -2044,4 +2042,0 @@\n-\n-    if (_has_archived_invokedynamic) {\n-      CDSConfig::set_has_archived_invokedynamic();\n-    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,1 +175,0 @@\n-  bool   _has_archived_invokedynamic;   \/\/ Does the archive have aot-linked invokedynamic CP entries?\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -144,2 +144,1 @@\n-MetaspaceObjToOopHandleTable* HeapShared::_scratch_java_mirror_table = nullptr;\n-MetaspaceObjToOopHandleTable* HeapShared::_scratch_references_table = nullptr;\n+MetaspaceObjToOopHandleTable* HeapShared::_scratch_objects_table = nullptr;\n@@ -396,1 +395,1 @@\n-    _scratch_references_table->set_oop(src, dest);\n+    _scratch_objects_table->set_oop(src, dest);\n@@ -401,1 +400,1 @@\n-  return (objArrayOop)_scratch_references_table->get_oop(src);\n+  return (objArrayOop)_scratch_objects_table->get_oop(src);\n@@ -405,2 +404,1 @@\n-  _scratch_java_mirror_table = new (mtClass)MetaspaceObjToOopHandleTable();\n-  _scratch_references_table = new (mtClass)MetaspaceObjToOopHandleTable();\n+  _scratch_objects_table = new (mtClass)MetaspaceObjToOopHandleTable();\n@@ -409,1 +407,1 @@\n-void HeapShared::init_scratch_objects(TRAPS) {\n+void HeapShared::init_scratch_objects_for_basic_type_mirrors(TRAPS) {\n@@ -451,1 +449,1 @@\n-  return _scratch_java_mirror_table->get_oop(k);\n+  return _scratch_objects_table->get_oop(k);\n@@ -455,1 +453,1 @@\n-  _scratch_java_mirror_table->set_oop(k, mirror);\n+  _scratch_objects_table->set_oop(k, mirror);\n@@ -462,1 +460,1 @@\n-  oop mirror = _scratch_java_mirror_table->get_oop(k);\n+  oop mirror = _scratch_objects_table->get_oop(k);\n@@ -466,1 +464,1 @@\n-  _scratch_java_mirror_table->remove_oop(k);\n+  _scratch_objects_table->remove_oop(k);\n@@ -468,1 +466,1 @@\n-    _scratch_references_table->remove(InstanceKlass::cast(k)->constants());\n+    _scratch_objects_table->remove(InstanceKlass::cast(k)->constants());\n@@ -495,1 +493,1 @@\n-  return CDSConfig::is_dumping_invokedynamic() &&\n+  return CDSConfig::is_dumping_method_handles() &&\n@@ -785,1 +783,1 @@\n-    if (CDSConfig::is_dumping_invokedynamic()) {\n+    if (CDSConfig::is_dumping_method_handles()) {\n@@ -838,1 +836,1 @@\n-  if (CDSConfig::is_dumping_invokedynamic()) {\n+  if (CDSConfig::is_dumping_method_handles()) {\n@@ -1111,1 +1109,1 @@\n-  if (CDSConfig::is_loading_invokedynamic() || CDSConfig::is_dumping_invokedynamic()) {\n+  if (CDSConfig::is_using_aot_linked_classes() || CDSConfig::is_dumping_method_handles()) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-  \/\/ be the encoding base, since the the headers of archived base objects (and with Lilliput,\n+  \/\/ be the encoding base, since the headers of archived base objects (and with Lilliput,\n@@ -641,1 +641,1 @@\n-  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+  if (CDSConfig::is_dumping_method_handles()) {\n@@ -990,1 +990,1 @@\n-    if (CDSConfig::is_dumping_invokedynamic()) {\n+    if (CDSConfig::is_dumping_method_handles()) {\n@@ -1000,0 +1000,1 @@\n+    }\n@@ -1001,0 +1002,1 @@\n+    if (CDSConfig::is_initing_classes_at_dump_time()) {\n@@ -1006,0 +1008,1 @@\n+      JavaValue result(T_VOID);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,0 @@\n-friend class VMStructs;\n@@ -87,1 +86,0 @@\n-friend class VMStructs;                \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  : _ciEnv_arena(mtCompiler) {\n+  : _ciEnv_arena(mtCompiler, Arena::Tag::tag_cienv) {\n@@ -242,1 +242,1 @@\n-ciEnv::ciEnv(Arena* arena) : _ciEnv_arena(mtCompiler) {\n+ciEnv::ciEnv(Arena* arena) : _ciEnv_arena(mtCompiler, Arena::Tag::tag_cienv) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  Arena* arena = new (mtCompiler) Arena(mtCompiler);\n+  Arena* arena = new (mtCompiler) Arena(mtCompiler, Arena::Tag::tag_cienv);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -526,2 +526,2 @@\n-  Cell limit = local(_outer->max_locals()-1);\n-  for (Cell c = start_cell(); c <= limit; c = next_cell(c)) {\n+  Cell limit = local_limit_cell();\n+  for (Cell c = start_cell(); c < limit; c = next_cell(c)) {\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,0 +216,2 @@\n+    Cell local_limit_cell() const { return (Cell) outer()->max_locals(); }\n+\n@@ -219,0 +221,1 @@\n+      assert(Cell_0 <= lnum && lnum <= Cell_max, \"out of Cell's range\");\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5472,1 +5472,1 @@\n-  if (!CDSConfig::is_dumping_invokedynamic()) {\n+  if (!CDSConfig::is_dumping_method_handles()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,0 +483,1 @@\n+  case vmIntrinsics::_double_keccak:\n@@ -495,0 +496,7 @@\n+  case vmIntrinsics::_dilithiumAlmostNtt:\n+  case vmIntrinsics::_dilithiumAlmostInverseNtt:\n+  case vmIntrinsics::_dilithiumNttMult:\n+  case vmIntrinsics::_dilithiumMontMulByConstant:\n+  case vmIntrinsics::_dilithiumDecomposePoly:\n+    if (!UseDilithiumIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -522,0 +522,6 @@\n+  \/* support for sun.security.provider.SHAKE128Parallel *\/                                                              \\\n+  do_class(sun_security_provider_sha3_parallel,                \"sun\/security\/provider\/SHA3Parallel\")                    \\\n+   do_intrinsic(_double_keccak, sun_security_provider_sha3_parallel, double_keccak_name, double_keccak_signature, F_S)   \\\n+   do_name(     double_keccak_name,                                 \"doubleKeccak\")                                     \\\n+   do_signature(double_keccak_signature,                            \"([J[J)I\")                                          \\\n+                                                                                                                        \\\n@@ -567,0 +573,20 @@\n+  \/* support for sun.security.provider.ML_DSA *\/                                                                        \\\n+ do_class(sun_security_provider_ML_DSA,      \"sun\/security\/provider\/ML_DSA\")                                            \\\n+   do_signature(IaII_signature, \"([II)I\")                                                                               \\\n+   do_signature(IaIaI_signature, \"([I[I)I\")                                                                             \\\n+   do_signature(IaIaIaI_signature, \"([I[I[I)I\")                                                                         \\\n+   do_signature(IaIaIaIII_signature, \"([I[I[III)I\")                                                                     \\\n+  do_intrinsic(_dilithiumAlmostNtt, sun_security_provider_ML_DSA, dilithiumAlmostNtt_name, IaIaI_signature, F_S)        \\\n+   do_name(dilithiumAlmostNtt_name,                            \"implDilithiumAlmostNtt\")                                \\\n+  do_intrinsic(_dilithiumAlmostInverseNtt, sun_security_provider_ML_DSA,                                                \\\n+                dilithiumAlmostInverseNtt_name, IaIaI_signature, F_S)                                                   \\\n+   do_name(dilithiumAlmostInverseNtt_name,                     \"implDilithiumAlmostInverseNtt\")                         \\\n+  do_intrinsic(_dilithiumNttMult, sun_security_provider_ML_DSA, dilithiumNttMult_name, IaIaIaI_signature, F_S)          \\\n+   do_name(dilithiumNttMult_name,                              \"implDilithiumNttMult\")                                  \\\n+  do_intrinsic(_dilithiumMontMulByConstant, sun_security_provider_ML_DSA,                                               \\\n+                dilithiumMontMulByConstant_name, IaII_signature, F_S)                                                   \\\n+   do_name(dilithiumMontMulByConstant_name,                    \"implDilithiumMontMulByConstant\")                        \\\n+  do_intrinsic(_dilithiumDecomposePoly, sun_security_provider_ML_DSA,                                                   \\\n+                dilithiumDecomposePoly_name, IaIaIaIII_signature, F_S)                                                  \\\n+   do_name(dilithiumDecomposePoly_name,                    \"implDilithiumDecomposePoly\")                                \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -391,0 +391,1 @@\n+  bool stack_slot_is_s2 = true;\n@@ -439,0 +440,6 @@\n+    case STACK_SLOT4_PRIMITIVE:\n+    case STACK_SLOT4_NARROW_OOP:\n+    case STACK_SLOT4_OOP:\n+    case STACK_SLOT4_VECTOR:\n+      stack_slot_is_s2 = false;\n+      \/\/ fall through\n@@ -443,1 +450,1 @@\n-      jint offset = (jshort) stream->read_s2(\"offset\");\n+      jint offset = stack_slot_is_s2 ? (jshort) stream->read_s2(\"offset\") : stream->read_s4(\"offset4\");\n@@ -857,1 +864,1 @@\n-    _orig_pc_offset = stream->read_s2(\"offset\");\n+    _orig_pc_offset = stream->read_s4(\"offset\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -397,0 +397,1 @@\n+  static_field(StubRoutines,                _double_keccak,                                   address)                               \\\n@@ -398,0 +399,5 @@\n+  static_field(StubRoutines,                _dilithiumAlmostNtt,                              address)                               \\\n+  static_field(StubRoutines,                _dilithiumAlmostInverseNtt,                       address)                               \\\n+  static_field(StubRoutines,                _dilithiumNttMult,                                address)                               \\\n+  static_field(StubRoutines,                _dilithiumMontMulByConstant,                      address)                               \\\n+  static_field(StubRoutines,                _dilithiumDecomposePoly,                          address)                               \\\n@@ -582,0 +588,4 @@\n+  declare_constant(CodeInstaller::STACK_SLOT4_PRIMITIVE)                  \\\n+  declare_constant(CodeInstaller::STACK_SLOT4_OOP)                        \\\n+  declare_constant(CodeInstaller::STACK_SLOT4_NARROW_OOP)                 \\\n+  declare_constant(CodeInstaller::STACK_SLOT4_VECTOR)                     \\\n@@ -714,0 +724,1 @@\n+  declare_constant(Deoptimization::Reason_auto_vectorization_check)       \\\n@@ -948,1 +959,1 @@\n-#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \\\n+#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field) \\\n@@ -962,1 +973,1 @@\n-#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \\\n+#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field) \\\n@@ -966,1 +977,1 @@\n-#define VM_INT_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \\\n+#define VM_INT_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant) \\\n@@ -980,1 +991,1 @@\n-#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field)\n+#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field)\n@@ -984,1 +995,1 @@\n-#define VM_INT_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+#define VM_INT_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant)\n@@ -988,1 +999,1 @@\n-#define VM_LONG_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+#define VM_LONG_CONSTANTS_CPU(declare_constant, declare_preprocessor_constant)\n@@ -1015,4 +1026,1 @@\n-                 GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n+                 GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -1043,4 +1051,1 @@\n-                       GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+                       GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -1069,4 +1074,1 @@\n-                        GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n+                        GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -1128,4 +1130,1 @@\n-                 CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                 CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                 CHECK_NO_OP,\n-                 CHECK_NO_OP);\n+                 CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-      HeapShared::init_scratch_objects(CHECK);\n+      HeapShared::init_scratch_objects_for_basic_type_mirrors(CHECK);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-  if (rr != nullptr && cache() != nullptr && CDSConfig::is_dumping_invokedynamic()) {\n+  if (rr != nullptr && cache() != nullptr && CDSConfig::is_dumping_method_handles()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -576,1 +576,1 @@\n-    if (CDSConfig::is_dumping_invokedynamic()) {\n+    if (CDSConfig::is_dumping_method_handles()) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -349,0 +349,6 @@\n+  product(bool, LoopMultiversioning, true, DIAGNOSTIC,                      \\\n+          \"Enable loop multiversioning (for speculative compilation)\")      \\\n+                                                                            \\\n+  develop(bool, TraceLoopMultiversioning, false,                            \\\n+          \"Trace loop multiversioning\")                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -790,0 +790,1 @@\n+  case vmIntrinsics::_double_keccak:\n@@ -799,0 +800,5 @@\n+  case vmIntrinsics::_dilithiumAlmostNtt:\n+  case vmIntrinsics::_dilithiumAlmostInverseNtt:\n+  case vmIntrinsics::_dilithiumNttMult:\n+  case vmIntrinsics::_dilithiumMontMulByConstant:\n+  case vmIntrinsics::_dilithiumDecomposePoly:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -200,1 +200,0 @@\n-  friend class VMStructs;\n@@ -333,1 +332,0 @@\n-  friend class VMStructs;\n@@ -692,1 +690,0 @@\n-  friend class VMStructs;\n@@ -782,1 +779,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-  static IfNode* make_with_same_profile(IfNode* if_node_profile, Node* ctrl, BoolNode* bol);\n+  static IfNode* make_with_same_profile(IfNode* if_node_profile, Node* ctrl, Node* bol);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,2 +369,2 @@\n-  ResourceArea split_arena(mtCompiler);     \/\/ Arena for Split local resources\n-  ResourceArea live_arena(mtCompiler);      \/\/ Arena for liveness & IFG info\n+  ResourceArea split_arena(mtCompiler, Arena::Tag::tag_regsplit);     \/\/ Arena for Split local resources\n+  ResourceArea live_arena(mtCompiler, Arena::Tag::tag_reglive);     \/\/ Arena for liveness & IFG info\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -282,0 +282,1 @@\n+macro(OpaqueMultiversioning)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -444,0 +445,3 @@\n+        if (child->is_data_proj_of_pure_function(n)) {\n+          worklist.push(n);\n+        }\n@@ -653,1 +657,1 @@\n-      _comp_arena(mtCompiler),\n+      _comp_arena(mtCompiler, Arena::Tag::tag_comp),\n@@ -677,1 +681,1 @@\n-      _Compile_types(mtCompiler),\n+      _Compile_types(mtCompiler, Arena::Tag::tag_type),\n@@ -940,1 +944,1 @@\n-      _comp_arena(mtCompiler),\n+      _comp_arena(mtCompiler, Arena::Tag::tag_comp),\n@@ -952,2 +956,2 @@\n-      _node_arena_one(mtCompiler),\n-      _node_arena_two(mtCompiler),\n+      _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -956,1 +960,1 @@\n-      _Compile_types(mtCompiler),\n+      _Compile_types(mtCompiler, Arena::Tag::tag_type),\n@@ -3495,0 +3499,7 @@\n+#ifdef ASSERT\n+  {\n+    CompilationMemoryStatistic::do_test_allocations();\n+    if (failing()) return;\n+  }\n+#endif\n+\n@@ -4802,0 +4813,1 @@\n+  assert(id != PhaseTraceId::_t_none, \"Don't use none\");\n@@ -4810,0 +4822,5 @@\n+\n+  \/\/ Inform memory statistic, if enabled\n+  if (CompilationMemoryStatistic::enabled()) {\n+    CompilationMemoryStatistic::on_phase_start((int)id, name);\n+  }\n@@ -4816,0 +4833,6 @@\n+\n+  \/\/ Inform memory statistic, if enabled\n+  if (CompilationMemoryStatistic::enabled()) {\n+    CompilationMemoryStatistic::on_phase_end();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,0 @@\n-  friend class VMStructs;\n@@ -227,1 +226,0 @@\n-  friend class VMStructs;\n@@ -243,1 +241,1 @@\n-    Compile*    _compile;\n+    Compile* const _compile;\n@@ -245,1 +243,1 @@\n-    bool _dolog;\n+    const bool _dolog;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1518,0 +1518,6 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n+  if (result_is_unused) {\n+    return replace_with_con(igvn, TypeF::make(0.));\n+  }\n@@ -1538,1 +1544,1 @@\n-    return replace_with_con(phase, t1);\n+    return replace_with_con(igvn, t1);\n@@ -1541,1 +1547,1 @@\n-    return replace_with_con(phase, t2);\n+    return replace_with_con(igvn, t2);\n@@ -1556,1 +1562,1 @@\n-  return replace_with_con(phase, TypeF::make(jfloat_cast(xr)));\n+  return replace_with_con(igvn, TypeF::make(jfloat_cast(xr)));\n@@ -1563,0 +1569,6 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+  bool result_is_unused = proj_out_or_null(TypeFunc::Parms) == nullptr;\n+  if (result_is_unused) {\n+    return replace_with_con(igvn, TypeD::make(0.));\n+  }\n@@ -1583,1 +1595,1 @@\n-    return replace_with_con(phase, t1);\n+    return replace_with_con(igvn, t1);\n@@ -1586,1 +1598,1 @@\n-    return replace_with_con(phase, t2);\n+    return replace_with_con(igvn, t2);\n@@ -1601,1 +1613,1 @@\n-  return replace_with_con(phase, TypeD::make(jdouble_cast(xr)));\n+  return replace_with_con(igvn, TypeD::make(jdouble_cast(xr)));\n@@ -1604,1 +1616,1 @@\n-Node* ModFloatingNode::replace_with_con(PhaseGVN* phase, const Type* con) {\n+Node* ModFloatingNode::replace_with_con(PhaseIterGVN* phase, const Type* con) {\n@@ -1608,1 +1620,1 @@\n-  C->gvn_replace_by(projs->fallthrough_proj, in(TypeFunc::Control));\n+  phase->replace_node(projs->fallthrough_proj, in(TypeFunc::Control));\n@@ -1610,1 +1622,1 @@\n-    C->gvn_replace_by(projs->fallthrough_catchproj, in(TypeFunc::Control));\n+    phase->replace_node(projs->fallthrough_catchproj, in(TypeFunc::Control));\n@@ -1613,1 +1625,1 @@\n-    C->gvn_replace_by(projs->fallthrough_memproj, in(TypeFunc::Memory));\n+    phase->replace_node(projs->fallthrough_memproj, in(TypeFunc::Memory));\n@@ -1616,1 +1628,1 @@\n-    C->gvn_replace_by(projs->catchall_memproj, C->top());\n+    phase->replace_node(projs->catchall_memproj, C->top());\n@@ -1619,1 +1631,1 @@\n-    C->gvn_replace_by(projs->fallthrough_ioproj, in(TypeFunc::I_O));\n+    phase->replace_node(projs->fallthrough_ioproj, in(TypeFunc::I_O));\n@@ -1624,1 +1636,1 @@\n-    C->gvn_replace_by(projs->resproj[0], con_node);\n+    phase->replace_node(projs->resproj[0], con_node);\n@@ -1626,1 +1638,1 @@\n-  C->gvn_replace_by(this, C->top());\n+  phase->replace_node(this, C->top());\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  Node* replace_with_con(PhaseGVN* phase, const Type* con);\n+  Node* replace_with_con(PhaseIterGVN* phase, const Type* con);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2245,0 +2245,5 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumAlmostNtt\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumAlmostInverseNtt\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumNttMult\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumMontMulByConstant\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"dilithiumDecomposePoly\") == 0 ||\n@@ -2256,0 +2261,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"double_keccak\") == 0 ||\n@@ -4567,1 +4573,1 @@\n-        \/\/ This AddP will go away when we reduce the the Phi\n+        \/\/ This AddP will go away when we reduce the Phi\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1701,1 +1701,1 @@\n-  ResourceArea live_arena(mtCompiler);      \/\/ Arena for liveness\n+  ResourceArea live_arena(mtCompiler, Arena::Tag::tag_reglive);      \/\/ Arena for liveness\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4574,0 +4574,1 @@\n+  add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-IfNode* IfNode::make_with_same_profile(IfNode* if_node_profile, Node* ctrl, BoolNode* bol) {\n+IfNode* IfNode::make_with_same_profile(IfNode* if_node_profile, Node* ctrl, Node* bol) {\n@@ -2197,0 +2197,1 @@\n+    case Deoptimization::Reason_auto_vectorization_check:\n@@ -2234,0 +2235,3 @@\n+    case Deoptimization::DeoptReason::Reason_auto_vectorization_check:\n+      st->print(\"Auto_Vectorization_Check \");\n+      break;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -604,0 +604,2 @@\n+  case vmIntrinsics::_double_keccak:\n+    return inline_double_keccak();\n@@ -634,0 +636,10 @@\n+  case vmIntrinsics::_dilithiumAlmostNtt:\n+    return inline_dilithiumAlmostNtt();\n+  case vmIntrinsics::_dilithiumAlmostInverseNtt:\n+    return inline_dilithiumAlmostInverseNtt();\n+  case vmIntrinsics::_dilithiumNttMult:\n+    return inline_dilithiumNttMult();\n+  case vmIntrinsics::_dilithiumMontMulByConstant:\n+    return inline_dilithiumMontMulByConstant();\n+  case vmIntrinsics::_dilithiumDecomposePoly:\n+    return inline_dilithiumDecomposePoly();\n@@ -7979,0 +7991,170 @@\n+\/\/------------------------------inline_dilithiumAlmostNtt\n+bool LibraryCallKit::inline_dilithiumAlmostNtt() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumAlmostNtt has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumAlmostNtt();\n+  stubName = \"dilithiumAlmostNtt\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* ntt_zetas        = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+  ntt_zetas = must_be_not_null(ntt_zetas, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* ntt_zetas_start  = array_element_address(ntt_zetas, intcon(0), T_INT);\n+  assert(ntt_zetas_start, \"ntt_zetas is null\");\n+  Node* dilithiumAlmostNtt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumAlmostNtt_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, ntt_zetas_start);\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumAlmostNtt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumAlmostInverseNtt\n+bool LibraryCallKit::inline_dilithiumAlmostInverseNtt() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumAlmostInverseNtt has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumAlmostInverseNtt();\n+  stubName = \"dilithiumAlmostInverseNtt\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* zetas           = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+  zetas = must_be_not_null(zetas, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* zetas_start  = array_element_address(zetas, intcon(0), T_INT);\n+  assert(zetas_start, \"inverseNtt_zetas is null\");\n+  Node* dilithiumAlmostInverseNtt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumAlmostInverseNtt_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, zetas_start);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumAlmostInverseNtt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumNttMult\n+bool LibraryCallKit::inline_dilithiumNttMult() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"dilithiumNttMult has 3 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumNttMult();\n+  stubName = \"dilithiumNttMult\";\n+  if (!stubAddr) return false;\n+\n+  Node* result          = argument(0);\n+  Node* ntta            = argument(1);\n+  Node* nttb            = argument(2);\n+\n+  result = must_be_not_null(result, true);\n+  ntta = must_be_not_null(ntta, true);\n+  nttb = must_be_not_null(nttb, true);\n+\n+  Node* result_start  = array_element_address(result, intcon(0), T_INT);\n+  assert(result_start, \"result is null\");\n+  Node* ntta_start  = array_element_address(ntta, intcon(0), T_INT);\n+  assert(ntta_start, \"ntta is null\");\n+  Node* nttb_start  = array_element_address(nttb, intcon(0), T_INT);\n+  assert(nttb_start, \"nttb is null\");\n+  Node* dilithiumNttMult = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumNttMult_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  result_start, ntta_start, nttb_start);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumNttMult, TypeFunc::Parms));\n+  set_result(retvalue);\n+\n+  return true;\n+}\n+\n+\/\/------------------------------inline_dilithiumMontMulByConstant\n+bool LibraryCallKit::inline_dilithiumMontMulByConstant() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"dilithiumMontMulByConstant has 2 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumMontMulByConstant();\n+  stubName = \"dilithiumMontMulByConstant\";\n+  if (!stubAddr) return false;\n+\n+  Node* coeffs          = argument(0);\n+  Node* constant        = argument(1);\n+\n+  coeffs = must_be_not_null(coeffs, true);\n+\n+  Node* coeffs_start  = array_element_address(coeffs, intcon(0), T_INT);\n+  assert(coeffs_start, \"coeffs is null\");\n+  Node* dilithiumMontMulByConstant = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumMontMulByConstant_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  coeffs_start, constant);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumMontMulByConstant, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_dilithiumDecomposePoly\n+bool LibraryCallKit::inline_dilithiumDecomposePoly() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseDilithiumIntrinsics, \"need Dilithium intrinsics support\");\n+  assert(callee()->signature()->size() == 5, \"dilithiumDecomposePoly has 5 parameters\");\n+\n+  stubAddr = StubRoutines::dilithiumDecomposePoly();\n+  stubName = \"dilithiumDecomposePoly\";\n+  if (!stubAddr) return false;\n+\n+  Node* input          = argument(0);\n+  Node* lowPart        = argument(1);\n+  Node* highPart       = argument(2);\n+  Node* twoGamma2      = argument(3);\n+  Node* multiplier     = argument(4);\n+\n+  input = must_be_not_null(input, true);\n+  lowPart = must_be_not_null(lowPart, true);\n+  highPart = must_be_not_null(highPart, true);\n+\n+  Node* input_start  = array_element_address(input, intcon(0), T_INT);\n+  assert(input_start, \"input is null\");\n+  Node* lowPart_start  = array_element_address(lowPart, intcon(0), T_INT);\n+  assert(lowPart_start, \"lowPart is null\");\n+  Node* highPart_start  = array_element_address(highPart, intcon(0), T_INT);\n+  assert(highPart_start, \"highPart is null\");\n+\n+  Node* dilithiumDecomposePoly = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::dilithiumDecomposePoly_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  input_start, lowPart_start, highPart_start,\n+                                  twoGamma2, multiplier);\n+\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(dilithiumDecomposePoly, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n@@ -8242,0 +8424,32 @@\n+\/\/------------------------------inline_double_keccak\n+bool LibraryCallKit::inline_double_keccak() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseSHA3Intrinsics, \"need SHA3 intrinsics support\");\n+  assert(callee()->signature()->size() == 2, \"double_keccak has 2 parameters\");\n+\n+  stubAddr = StubRoutines::double_keccak();\n+  stubName = \"double_keccak\";\n+  if (!stubAddr) return false;\n+\n+  Node* status0        = argument(0);\n+  Node* status1        = argument(1);\n+\n+  status0 = must_be_not_null(status0, true);\n+  status1 = must_be_not_null(status1, true);\n+\n+  Node* status0_start  = array_element_address(status0, intcon(0), T_LONG);\n+  assert(status0_start, \"status0 is null\");\n+  Node* status1_start  = array_element_address(status1, intcon(0), T_LONG);\n+  assert(status1_start, \"status1 is null\");\n+  Node* double_keccak = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::double_keccak_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  status0_start, status1_start);\n+  \/\/ return an int\n+  Node* retvalue = _gvn.transform(new ProjNode(double_keccak, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":214,"deletions":0,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -344,0 +344,5 @@\n+  bool inline_dilithiumAlmostNtt();\n+  bool inline_dilithiumAlmostInverseNtt();\n+  bool inline_dilithiumNttMult();\n+  bool inline_dilithiumMontMulByConstant();\n+  bool inline_dilithiumDecomposePoly();\n@@ -350,0 +355,1 @@\n+  bool inline_double_keccak();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,17 @@\n+\/\/ Multiversioning:\n+\/\/ A loop is cloned, and a selector If decides which loop is taken at run-time: the true-path-loop (original) or the\n+\/\/ false-path-loop (cloned).\n+\/\/\n+\/\/ Use-cases:\n+\/\/ - Speculative compilation:\n+\/\/   The selector If checks some assumptions which allow stronger optimization in the true-path-loop. If the assumptions\n+\/\/   do not hold, we can still execute in the false-path-loop, although with fewer optimizations.\n+\/\/   See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n+\/\/        PhaseIdealLoop::create_new_if_for_multiversion\n+\/\/\n+\/\/ - Unswitching:\n+\/\/   The selector If has the same (loop invariant) condition as some unswitching candidate If inside the loop. This\n+\/\/   allows us to constant-fold the unswitching candidate If to true in the true-path-loop and to false in the\n+\/\/   false-path-loop, thus eliminating the unswitching candidate If from the loop.\n+\/\/\n+\/\/\n@@ -341,4 +358,4 @@\n-\/\/ This class creates an If node (i.e. loop selector) that selects if the true-path-loop or the false-path-loop should be\n-\/\/ executed at runtime. This is done by finding an invariant and non-loop-exiting unswitch candidate If node (guaranteed\n-\/\/ to exist at this point) to perform Loop Unswitching on.\n-class UnswitchedLoopSelector : public StackObj {\n+\/\/ LoopSelector is used for loop multiversioning and unswitching. This class creates an If node (i.e. loop selector)\n+\/\/ that selects if the true-path-loop or the false-path-loop should be executed at runtime.\n+class LoopSelector : public StackObj {\n+  \/\/ Cached fields for construction.\n@@ -348,1 +365,3 @@\n-  const UnswitchCandidate& _unswitch_candidate;\n+  const uint _dom_depth; \/\/ of original_loop_entry\n+\n+  \/\/ Constructed selector if with its projections.\n@@ -358,1 +377,2 @@\n-  UnswitchedLoopSelector(IdealLoopTree* loop, const UnswitchCandidate& unswitch_candidate)\n+  \/\/ For multiversioning: create a new selector (multiversion_if) from a bol condition.\n+  LoopSelector(IdealLoopTree* loop, Node* bol, float prob, float fcnt)\n@@ -362,2 +382,2 @@\n-        _unswitch_candidate(unswitch_candidate),\n-        _selector(create_selector_if()),\n+        _dom_depth(_phase->dom_depth(_original_loop_entry)),\n+        _selector(create_multiversioning_if(bol, prob, fcnt)), \/\/ multiversioning\n@@ -367,1 +387,13 @@\n-  NONCOPYABLE(UnswitchedLoopSelector);\n+\n+  \/\/ For unswitching: create an unswitching if before the loop, from a pre-existing\n+  \/\/                  unswitching_candidate inside the loop.\n+  LoopSelector(IdealLoopTree* loop, const UnswitchCandidate& unswitch_candidate)\n+      : _phase(loop->_phase),\n+        _outer_loop(loop->skip_strip_mined()->_parent),\n+        _original_loop_entry(loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl)),\n+        _dom_depth(_phase->dom_depth(_original_loop_entry)),\n+        _selector(create_unswitching_if(unswitch_candidate)), \/\/ unswitching\n+        _true_path_loop_proj(create_proj_to_loop(TRUE_PATH)->as_IfTrue()),\n+        _false_path_loop_proj(create_proj_to_loop(FALSE_PATH)->as_IfFalse()) {\n+  }\n+  NONCOPYABLE(LoopSelector);\n@@ -370,1 +402,8 @@\n-  IfNode* create_selector_if() const {\n+  IfNode* create_multiversioning_if(Node* bol, float prob, float fcnt) {\n+    _phase->igvn().rehash_node_delayed(_original_loop_entry);\n+    IfNode* selector_if = new IfNode(_original_loop_entry, bol, prob, fcnt);\n+    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, _dom_depth);\n+    return selector_if;\n+  }\n+\n+  IfNode* create_unswitching_if(const UnswitchCandidate& unswitch_candidate) {\n@@ -373,1 +412,1 @@\n-    IfNode* unswitch_candidate_if = _unswitch_candidate.candidate();\n+    IfNode* unswitch_candidate_if = unswitch_candidate.candidate();\n@@ -375,2 +414,2 @@\n-    if (_unswitch_candidate.has_multiple_flat_array_check_candidates()) {\n-      selector_bool = _unswitch_candidate.merge_flat_array_checks();\n+    if (unswitch_candidate.has_multiple_flat_array_check_candidates()) {\n+      selector_bool = unswitch_candidate.merge_flat_array_checks();\n@@ -385,1 +424,0 @@\n-    const uint dom_depth = _phase->dom_depth(_original_loop_entry);\n@@ -393,1 +431,1 @@\n-    _phase->register_node(proj_to_loop, _outer_loop, _selector, dom_depth);\n+    _phase->register_node(proj_to_loop, _outer_loop, _selector, _dom_depth);\n@@ -411,0 +449,22 @@\n+\/\/ This class creates an If node (i.e. loop selector) that selects if the true-path-loop or the false-path-loop should be\n+\/\/ executed at runtime. This is done by finding an invariant and non-loop-exiting unswitch candidate If node (guaranteed\n+\/\/ to exist at this point) to perform Loop Unswitching on.\n+class UnswitchedLoopSelector : public StackObj {\n+  const UnswitchCandidate& _unswitch_candidate;\n+  const LoopSelector _loop_selector;\n+\n+ public:\n+  UnswitchedLoopSelector(IdealLoopTree* loop, const UnswitchCandidate& unswitch_candidate)\n+      : _unswitch_candidate(unswitch_candidate),\n+        _loop_selector(loop, _unswitch_candidate) {}\n+  NONCOPYABLE(UnswitchedLoopSelector);\n+\n+  IfNode* selector_if() const {\n+    return _loop_selector.selector();\n+  }\n+\n+  const LoopSelector& loop_selector() const {\n+    return _loop_selector;\n+  }\n+};\n+\n@@ -430,0 +490,6 @@\n+    multiversion(unswitched_loop_selector.loop_selector());\n+  }\n+\n+  \/\/ Multiversion the original loop. The loop selector if selects between the original loop (true-path-loop), and\n+  \/\/ a copy of it (false-path-loop).\n+  void multiversion(const LoopSelector& loop_selector) {\n@@ -431,1 +497,1 @@\n-    clone_loop(unswitched_loop_selector);\n+    clone_loop(loop_selector);\n@@ -433,1 +499,1 @@\n-    move_parse_and_template_assertion_predicates_to_unswitched_loops(unswitched_loop_selector,\n+    move_parse_and_template_assertion_predicates_to_unswitched_loops(loop_selector,\n@@ -435,1 +501,1 @@\n-    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n+    DEBUG_ONLY(verify_loop_versions(_loop->_head->as_Loop(), loop_selector);)\n@@ -441,1 +507,1 @@\n-  void clone_loop(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+  void clone_loop(const LoopSelector& loop_selector) {\n@@ -443,2 +509,2 @@\n-                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n-    fix_loop_entries(unswitched_loop_selector);\n+                       PhaseIdealLoop::CloneIncludesStripMined, loop_selector.selector());\n+    fix_loop_entries(loop_selector);\n@@ -447,2 +513,2 @@\n-  void fix_loop_entries(const UnswitchedLoopSelector& unswitched_loop_selector) {\n-    _phase->replace_loop_entry(_loop_head, unswitched_loop_selector.true_path_loop_proj());\n+  void fix_loop_entries(const LoopSelector& loop_selector) {\n+    _phase->replace_loop_entry(_loop_head, loop_selector.true_path_loop_proj());\n@@ -451,1 +517,1 @@\n-                               unswitched_loop_selector.false_path_loop_proj());\n+                               loop_selector.false_path_loop_proj());\n@@ -458,1 +524,1 @@\n-    const UnswitchedLoopSelector& unswitched_loop_selector, const uint first_false_path_loop_node_index) const {\n+    const LoopSelector& loop_selector, const uint first_false_path_loop_node_index) const {\n@@ -464,1 +530,1 @@\n-    Node* source_loop_entry = unswitched_loop_selector.selector()->in(0);\n+    Node* source_loop_entry = loop_selector.selector()->in(0);\n@@ -470,5 +536,6 @@\n-  void verify_unswitched_loop_versions(LoopNode* true_path_loop_head,\n-                                       const UnswitchedLoopSelector& unswitched_loop_selector) const {\n-    verify_unswitched_loop_version(true_path_loop_head, unswitched_loop_selector.true_path_loop_proj());\n-    verify_unswitched_loop_version(old_to_new(true_path_loop_head)->as_Loop(),\n-                                   unswitched_loop_selector.false_path_loop_proj());\n+  void verify_loop_versions(LoopNode* true_path_loop_head,\n+                            const LoopSelector& loop_selector) const {\n+    verify_loop_version(true_path_loop_head,\n+                        loop_selector.true_path_loop_proj());\n+    verify_loop_version(old_to_new(true_path_loop_head)->as_Loop(),\n+                        loop_selector.false_path_loop_proj());\n@@ -477,1 +544,1 @@\n-  static void verify_unswitched_loop_version(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n+  static void verify_loop_version(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n@@ -488,1 +555,0 @@\n-\n@@ -511,2 +577,2 @@\n-  unswitch_candidate.update_in_true_path_loop(unswitched_loop_selector.true_path_loop_proj());\n-  unswitch_candidate.update_in_false_path_loop(unswitched_loop_selector.false_path_loop_proj(),\n+  unswitch_candidate.update_in_true_path_loop(unswitched_loop_selector.loop_selector().true_path_loop_proj());\n+  unswitch_candidate.update_in_false_path_loop(unswitched_loop_selector.loop_selector().false_path_loop_proj(),\n@@ -514,1 +580,1 @@\n-  hoist_invariant_check_casts(loop, old_new, unswitch_candidate, unswitched_loop_selector.selector());\n+  hoist_invariant_check_casts(loop, old_new, unswitch_candidate, unswitched_loop_selector.selector_if());\n@@ -525,0 +591,166 @@\n+void PhaseIdealLoop::do_multiversioning(IdealLoopTree* lpt, Node_List& old_new) {\n+#ifndef PRODUCT\n+  if (TraceLoopOpts || TraceLoopMultiversioning) {\n+    tty->print(\"Multiversion \");\n+    lpt->dump_head();\n+  }\n+#endif\n+  assert(LoopMultiversioning, \"LoopMultiversioning must be enabled\");\n+\n+  CountedLoopNode* original_head = lpt->_head->as_CountedLoop();\n+  C->print_method(PHASE_BEFORE_LOOP_MULTIVERSIONING, 4, original_head);\n+\n+  Node* one = _igvn.intcon(1);\n+  set_ctrl(one, C->root());\n+  Node* opaque = new OpaqueMultiversioningNode(C, one);\n+  set_ctrl(opaque, C->root());\n+  _igvn.register_new_node_with_optimizer(opaque);\n+  _igvn.set_type(opaque, TypeInt::BOOL);\n+\n+  const LoopSelector loop_selector(lpt, opaque, PROB_LIKELY_MAG(3), COUNT_UNKNOWN);\n+  OriginalLoop original_loop(lpt, old_new);\n+  original_loop.multiversion(loop_selector);\n+\n+  add_unswitched_loop_version_bodies_to_igvn(lpt, old_new);\n+\n+  CountedLoopNode* new_head = old_new[original_head->_idx]->as_CountedLoop();\n+  original_head->set_multiversion_fast_loop();\n+  new_head->set_multiversion_delayed_slow_loop();\n+\n+  NOT_PRODUCT(trace_loop_multiversioning_result(loop_selector, original_head, new_head);)\n+  C->print_method(PHASE_AFTER_LOOP_MULTIVERSIONING, 4, new_head);\n+  C->set_major_progress();\n+}\n+\n+\/\/ Create a new if in the multiversioning pattern, adding an additional condition for the\n+\/\/ multiversioning fast-loop.\n+\/\/\n+\/\/ Before:\n+\/\/                       entry  opaque\n+\/\/                         |      |\n+\/\/                      multiversion_if\n+\/\/                         |      |\n+\/\/        +----------------+      +---------------+\n+\/\/        |                                       |\n+\/\/   multiversion_fast_proj          multiversion_slow_proj\n+\/\/                                                |\n+\/\/                                                +--------+\n+\/\/                                                         |\n+\/\/                                                      slow_path\n+\/\/\n+\/\/\n+\/\/ After:\n+\/\/                     entry  opaque <-- to be replaced by caller\n+\/\/                         |  |\n+\/\/                        new_if\n+\/\/                         |  |\n+\/\/                         |  +-----------------------------+\n+\/\/                         |                                |\n+\/\/                 new_if_true  opaque                new_if_false\n+\/\/                         |      |                         |\n+\/\/                      multiversion_if                     |\n+\/\/                         |      |                         |\n+\/\/        +----------------+      +---------------+         |\n+\/\/        |                                       |         |\n+\/\/   multiversion_fast_proj      new_multiversion_slow_proj |\n+\/\/                                                |         |\n+\/\/                                                +------+  |\n+\/\/                                                       |  |\n+\/\/                                                      region\n+\/\/                                                         |\n+\/\/                                                      slow_path\n+\/\/\n+IfTrueNode* PhaseIdealLoop::create_new_if_for_multiversion(IfTrueNode* multiversioning_fast_proj) {\n+  \/\/ Give all nodes in the old sub-graph a name.\n+  IfNode* multiversion_if = multiversioning_fast_proj->in(0)->as_If();\n+  Node* entry = multiversion_if->in(0);\n+  OpaqueMultiversioningNode* opaque = multiversion_if->in(1)->as_OpaqueMultiversioning();\n+  IfFalseNode* multiversion_slow_proj = multiversion_if->proj_out(0)->as_IfFalse();\n+  Node* slow_path = multiversion_slow_proj->unique_ctrl_out();\n+\n+  \/\/ The slow_loop may still be delayed, and waiting for runtime-checks to be added to the\n+  \/\/ multiversion_if. Now that we have at least one condition for the multiversioning,\n+  \/\/ we should resume optimizations for the slow loop.\n+  opaque->notify_slow_loop_that_it_can_resume_optimizations();\n+\n+  \/\/ Create new_if with its projections.\n+  IfNode* new_if = IfNode::make_with_same_profile(multiversion_if, entry, opaque);\n+  IdealLoopTree* lp = get_loop(entry);\n+  register_control(new_if, lp, entry);\n+\n+  IfTrueNode*  new_if_true  = new IfTrueNode(new_if);\n+  IfFalseNode* new_if_false = new IfFalseNode(new_if);\n+  register_control(new_if_true,  lp, new_if);\n+  register_control(new_if_false, lp, new_if);\n+\n+  \/\/ Hook new_if_true into multiversion_if.\n+  _igvn.replace_input_of(multiversion_if, 0, new_if_true);\n+\n+  \/\/ Clone multiversion_slow_path - this allows us to easily carry the dependencies to\n+  \/\/ the new region below.\n+  IfFalseNode* new_multiversion_slow_proj = multiversion_slow_proj->clone()->as_IfFalse();\n+  register_control(new_multiversion_slow_proj, lp, multiversion_if);\n+\n+  \/\/ Create new Region.\n+  RegionNode* region = new RegionNode(1);\n+  region->add_req(new_multiversion_slow_proj);\n+  region->add_req(new_if_false);\n+  register_control(region, lp, new_multiversion_slow_proj);\n+\n+  \/\/ Hook region into slow_path, in stead of the multiversion_slow_proj.\n+  \/\/ This also moves all other dependencies of the multiversion_slow_proj to the region.\n+  _igvn.replace_node(multiversion_slow_proj, region);\n+\n+  return new_if_true;\n+}\n+\n+OpaqueMultiversioningNode* find_multiversion_opaque_from_multiversion_if_false(Node* maybe_multiversion_if_false) {\n+  IfFalseNode* multiversion_if_false = maybe_multiversion_if_false->isa_IfFalse();\n+  if (multiversion_if_false == nullptr) { return nullptr; }\n+  IfNode* multiversion_if = multiversion_if_false->in(0)->isa_If();\n+  if (multiversion_if == nullptr) { return nullptr; }\n+  return multiversion_if->in(1)->isa_OpaqueMultiversioning();\n+}\n+\n+bool PhaseIdealLoop::try_resume_optimizations_for_delayed_slow_loop(IdealLoopTree* lpt) {\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+  assert(cl->is_multiversion_delayed_slow_loop(), \"must currently be delayed\");\n+\n+  \/\/ Find multiversion_if.\n+  Node* entry = cl->skip_strip_mined()->in(LoopNode::EntryControl);\n+  const Predicates predicates(entry);\n+\n+  Node* slow_path = predicates.entry();\n+\n+  \/\/ Find opaque.\n+  OpaqueMultiversioningNode* opaque = nullptr;\n+  if (slow_path->is_Region()) {\n+    for (uint i = 1; i < slow_path->req(); i++) {\n+      Node* n = slow_path->in(i);\n+      opaque = find_multiversion_opaque_from_multiversion_if_false(n);\n+      if (opaque != nullptr) { break; }\n+    }\n+  } else {\n+    opaque = find_multiversion_opaque_from_multiversion_if_false(slow_path);\n+  }\n+  assert(opaque != nullptr, \"must have found multiversion opaque node\");\n+  if (opaque == nullptr) { return false; }\n+\n+  \/\/ We may still be delayed, if there were not yet any runtime-checks added\n+  \/\/ for the multiversioning. We may never add any, and then this loop would\n+  \/\/ fold away. So we wait until some runtime-checks are added, then we know\n+  \/\/ that this loop will be reachable and it is worth optimizing further.\n+  if (opaque->is_delayed_slow_loop()) { return false; }\n+\n+  \/\/ Clear away the \"delayed\" status, i.e. resume optimizations.\n+  cl->set_no_multiversion();\n+  cl->set_multiversion_slow_loop();\n+#ifndef PRODUCT\n+  if (TraceLoopOpts) {\n+    tty->print(\"Resume Optimizations \");\n+    lpt->dump_head();\n+  }\n+#endif\n+  return true;\n+}\n+\n@@ -560,1 +792,1 @@\n-    IfNode* loop_selector = unswitched_loop_selector.selector();\n+    IfNode* loop_selector = unswitched_loop_selector.selector_if();\n@@ -569,0 +801,11 @@\n+\n+void PhaseIdealLoop::trace_loop_multiversioning_result(const LoopSelector& loop_selector,\n+                                                       const LoopNode* original_head, const LoopNode* new_head) {\n+  if (TraceLoopMultiversioning) {\n+    IfNode* selector_if = loop_selector.selector();\n+    tty->print_cr(\"Loop Multiversioning:\");\n+    tty->print_cr(\"- Loop-Selector-If: %d %s\", selector_if->_idx, selector_if->Name());\n+    tty->print_cr(\"- True-Path-Loop (=Orig \/ Fast): %d %s\", original_head->_idx, original_head->Name());\n+    tty->print_cr(\"- False-Path-Loop (=Clone \/ Slow): %d %s\", new_head->_idx, new_head->Name());\n+  }\n+}\n@@ -572,1 +815,1 @@\n-\/\/ post loop anymore after loop unswitching.\n+\/\/ post loop anymore after loop unswitching. We also lose the multiversion structure, with access to the multiversion_if.\n@@ -575,3 +818,3 @@\n-  if (cl != nullptr && !cl->is_normal_loop()) {\n-    cl->set_normal_loop();\n-  }\n+  if (cl == nullptr) { return; }\n+  if (!cl->is_normal_loop()) { cl->set_normal_loop(); }\n+  if (cl->is_multiversion()) { cl->set_no_multiversion(); }\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":284,"deletions":41,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class LoopSelector;\n@@ -84,1 +85,5 @@\n-         FlatArrays            = 1<<17};\n+         MultiversionFastLoop         = 1<<17,\n+         MultiversionSlowLoop         = 2<<17,\n+         MultiversionDelayedSlowLoop  = 3<<17,\n+         MultiversionFlagsMask        = 3<<17,\n+         FlatArrays            = 1<<18};\n@@ -322,0 +327,26 @@\n+  \/\/ Multiversioning allows us to duplicate a CountedLoop, and have two versions, and the multiversion_if\n+  \/\/ decides which one is taken:\n+  \/\/ (1) fast_loop: We enter this loop by default, by default the multiversion_if has its condition set to\n+  \/\/                \"true\", guarded by a OpaqueMultiversioning. If we want to make a speculative assumption\n+  \/\/                for an optimization, we can add the runtime-check to the multiversion_if, and if the\n+  \/\/                assumption fails we take the slow_loop instead, where we do not make the same speculative\n+  \/\/                assumption.\n+  \/\/                We call it the \"fast_loop\" because it has more optimizations, enabled by the speculative\n+  \/\/                runtime-checks at the multiversion_if, and we expect the fast_loop to execute faster.\n+  \/\/ (2) slow_loop: By default, it is not taken, until a runtime-check is added to the multiversion_if while\n+  \/\/                optimizing the fast_looop. If such a runtime-check is never added, then after loop-opts\n+  \/\/                the multiversion_if constant folds to true, and the slow_loop is folded away. To save\n+  \/\/                compile time, we delay the optimization of the slow_loop until a runtime-check is added\n+  \/\/                to the multiversion_if, at which point we resume optimizations for the slow_loop.\n+  \/\/                We call it the \"slow_loop\" because it has fewer optimizations, since this is the fall-back\n+  \/\/                loop where we do not make any of the speculative assumptions we make for the fast_loop.\n+  \/\/                Hence, we expect the slow_loop to execute slower.\n+  bool is_multiversion()                   const { return (_loop_flags & MultiversionFlagsMask) != Normal; }\n+  bool is_multiversion_fast_loop()         const { return (_loop_flags & MultiversionFlagsMask) == MultiversionFastLoop; }\n+  bool is_multiversion_slow_loop()         const { return (_loop_flags & MultiversionFlagsMask) == MultiversionSlowLoop; }\n+  bool is_multiversion_delayed_slow_loop() const { return (_loop_flags & MultiversionFlagsMask) == MultiversionDelayedSlowLoop; }\n+  void set_multiversion_fast_loop()         { assert(!is_multiversion(), \"\"); _loop_flags |= MultiversionFastLoop; }\n+  void set_multiversion_slow_loop()         { assert(!is_multiversion(), \"\"); _loop_flags |= MultiversionSlowLoop; }\n+  void set_multiversion_delayed_slow_loop() { assert(!is_multiversion(), \"\"); _loop_flags |= MultiversionDelayedSlowLoop; }\n+  void set_no_multiversion()                { assert( is_multiversion(), \"\"); _loop_flags &= ~MultiversionFlagsMask; }\n+\n@@ -1467,0 +1498,2 @@\n+  static void trace_loop_multiversioning_result(const LoopSelector& loop_selector,\n+                                                const LoopNode* original_head, const LoopNode* new_head);\n@@ -1493,0 +1526,5 @@\n+  void maybe_multiversion_for_auto_vectorization_runtime_checks(IdealLoopTree* lpt, Node_List& old_new);\n+  void do_multiversioning(IdealLoopTree* lpt, Node_List& old_new);\n+  IfTrueNode* create_new_if_for_multiversion(IfTrueNode* multiversioning_fast_proj);\n+  bool try_resume_optimizations_for_delayed_slow_loop(IdealLoopTree* lpt);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -4665,0 +4665,60 @@\n+\/\/ Just before insert_pre_post_loops, we can multi-version the loop:\n+\/\/\n+\/\/              multiversion_if\n+\/\/               |       |\n+\/\/         fast_loop   slow_loop\n+\/\/\n+\/\/ In the fast_loop we can make speculative assumptions, and put the\n+\/\/ conditions into the multiversion_if. If the conditions hold at runtime,\n+\/\/ we enter the fast_loop, if the conditions fail, we take the slow_loop\n+\/\/ instead which does not make any of the speculative assumptions.\n+\/\/\n+\/\/ Note: we only multiversion the loop if the loop does not have any\n+\/\/       auto vectorization check Predicate. If we have that predicate,\n+\/\/       then we can simply add the speculative assumption checks to\n+\/\/       that Predicate. This means we do not need to duplicate the\n+\/\/       loop - we have a smaller graph and save compile time. Should\n+\/\/       the conditions ever fail, then we deopt \/ trap at the Predicate\n+\/\/       and recompile without that Predicate. At that point we will\n+\/\/       multiversion the loop, so that we can still have speculative\n+\/\/       runtime checks.\n+\/\/\n+\/\/ We perform the multiversioning when the loop is still in its single\n+\/\/ iteration form, even before we insert pre and post loops. This makes\n+\/\/ the cloning much simpler. However, this means that both the fast\n+\/\/ and the slow loop have to be optimized independently (adding pre\n+\/\/ and post loops, unrolling the main loop, auto-vectorize etc.). And\n+\/\/ we may end up not needing any speculative assumptions in the fast_loop\n+\/\/ and then rejecting the slow_loop by constant folding the multiversion_if.\n+\/\/\n+\/\/ Therefore, we \"delay\" the optimization of the slow_loop until we add\n+\/\/ at least one speculative assumption for the fast_loop. If we never\n+\/\/ add such a speculative runtime check, the OpaqueMultiversioningNode\n+\/\/ of the multiversion_if constant folds to true after loop opts, and the\n+\/\/ multiversion_if folds away the \"delayed\" slow_loop. If we add any\n+\/\/ speculative assumption, then we notify the OpaqueMultiversioningNode\n+\/\/ with \"notify_slow_loop_that_it_can_resume_optimizations\".\n+\/\/\n+\/\/ Note: new runtime checks can be added to the multiversion_if with\n+\/\/       PhaseIdealLoop::create_new_if_for_multiversion\n+void PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks(IdealLoopTree* lpt, Node_List& old_new) {\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+  LoopNode* outer_loop = cl->skip_strip_mined();\n+  Node* entry = outer_loop->in(LoopNode::EntryControl);\n+\n+  \/\/ Check we have multiversioning enabled, and are not already multiversioned.\n+  if (!LoopMultiversioning || cl->is_multiversion()) { return; }\n+\n+  \/\/ Check that we do not have a parse-predicate where we can add the runtime checks\n+  \/\/ during auto-vectorization.\n+  const Predicates predicates(entry);\n+  const PredicateBlock* predicate_block = predicates.auto_vectorization_check_block();\n+  if (predicate_block->has_parse_predicate()) { return; }\n+\n+  \/\/ Check node budget.\n+  uint estimate = lpt->est_loop_clone_sz(2);\n+  if (!may_require_nodes(estimate)) { return; }\n+\n+  do_multiversioning(lpt, old_new);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  _states_arena(Chunk::medium_size, mtCompiler),\n+  _states_arena(Chunk::medium_size, mtCompiler, Arena::Tag::tag_states),\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1462,0 +1462,2 @@\n+          } else if (dead->is_data_proj_of_pure_function(n)) {\n+            igvn->_worklist.push(n);\n@@ -2941,0 +2943,19 @@\n+bool Node::is_pure_function() const {\n+  switch (Opcode()) {\n+  case Op_ModD:\n+  case Op_ModF:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n+\/\/ `maybe_pure_function` is assumed to be the input of `this`. This is a bit redundant,\n+\/\/ but we already have and need maybe_pure_function in all the call sites, so\n+\/\/ it makes it obvious that the `maybe_pure_function` is the same node as in the caller,\n+\/\/ while it takes more thinking to realize that a locally computed in(0) must be equal to\n+\/\/ the local in the caller.\n+bool Node::is_data_proj_of_pure_function(const Node* maybe_pure_function) const {\n+  return Opcode() == Op_Proj && as_Proj()->_con == TypeFunc::Parms && maybe_pure_function->is_pure_function();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+class OpaqueMultiversioningNode;\n@@ -247,1 +248,0 @@\n-  friend class VMStructs;\n@@ -812,0 +812,1 @@\n+      DEFINE_CLASS_ID(OpaqueMultiversioning, Opaque1, 2)\n@@ -998,0 +999,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueMultiversioning)\n@@ -1298,0 +1300,4 @@\n+  bool is_pure_function() const;\n+\n+  bool is_data_proj_of_pure_function(const Node* maybe_pure_function) const;\n+\n@@ -1629,1 +1635,0 @@\n-  friend class VMStructs;\n@@ -1674,1 +1679,0 @@\n-  friend class VMStructs;\n@@ -1741,1 +1745,0 @@\n-  friend class VMStructs;\n@@ -1881,1 +1884,0 @@\n-  friend class VMStructs;\n@@ -1957,1 +1959,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1345,0 +1345,2 @@\n+            } else if (dead->is_data_proj_of_pure_function(in)) {\n+              _worklist.push(in);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  flags(BEFORE_LOOP_MULTIVERSIONING,    \"Before Loop Multiversioning\") \\\n+  flags(AFTER_LOOP_MULTIVERSIONING,     \"After Loop Multiversioning\") \\\n@@ -71,4 +73,5 @@\n-  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,       \"AutoVectorization 1, Before Apply\") \\\n-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,      \"AutoVectorization 2, After Apply Memop Reordering\") \\\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, \"AutoVectorization 3, After Adjusting Pre-Loop Limit\") \\\n-  flags(AUTO_VECTORIZATION4_AFTER_APPLY,        \"AutoVectorization 4, After Apply\") \\\n+  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,                     \"AutoVectorization 1, Before Apply\") \\\n+  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, After Apply Memop Reordering\") \\\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, After Adjusting Pre-Loop Limit\") \\\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, After Adding Speculative Runtime Checks\") \\\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, After Apply\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -234,0 +235,1 @@\n+const TypeFunc* OptoRuntime::_double_keccak_Type                  = nullptr;\n@@ -243,0 +245,7 @@\n+\n+const TypeFunc* OptoRuntime::_dilithiumAlmostNtt_Type             = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumAlmostInverseNtt_Type      = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumNttMult_Type               = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumMontMulByConstant_Type     = nullptr;\n+const TypeFunc* OptoRuntime::_dilithiumDecomposePoly_Type         = nullptr;\n+\n@@ -272,0 +281,1 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n@@ -1180,0 +1190,3 @@\n+\/*\n+ * int implCompressMultiBlock(byte[] b, int ofs, int limit)\n+ *\/\n@@ -1201,0 +1214,19 @@\n+\/\/ SHAKE128Parallel doubleKeccak function\n+static const TypeFunc* make_double_keccak_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ status0\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ status1\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1386,0 +1418,99 @@\n+\/\/ Dilithium NTT function except for the final \"normalization\" to |coeff| < Q\n+static const TypeFunc* make_dilithiumAlmostNtt_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ NTT zetas\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium inverse NTT function except the final mod Q division by 2^256\n+static const TypeFunc* make_dilithiumAlmostInverseNtt_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ inverse NTT zetas\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium NTT multiply function\n+static const TypeFunc* make_dilithiumNttMult_Type() {\n+    int argcnt = 3;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ ntta\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ nttb\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium Montgomery multiply a polynome coefficient array by a constant\n+static const TypeFunc* make_dilithiumMontMulByConstant_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ coeffs\n+    fields[argp++] = TypeInt::INT;          \/\/ constant multiplier\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ Dilithium decompose polynomial\n+static const TypeFunc* make_dilithiumDecomposePoly_Type() {\n+    int argcnt = 5;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ input\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ lowPart\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ highPart\n+    fields[argp++] = TypeInt::INT;          \/\/ 2 * gamma2\n+    fields[argp++] = TypeInt::INT;          \/\/ multiplier\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1989,0 +2120,1 @@\n+  _double_keccak_Type                 = make_double_keccak_Type();\n@@ -1998,0 +2130,7 @@\n+\n+  _dilithiumAlmostNtt_Type            = make_dilithiumAlmostNtt_Type();\n+  _dilithiumAlmostInverseNtt_Type     = make_dilithiumAlmostInverseNtt_Type();\n+  _dilithiumNttMult_Type              = make_dilithiumNttMult_Type();\n+  _dilithiumMontMulByConstant_Type    = make_dilithiumMontMulByConstant_Type();\n+  _dilithiumDecomposePoly_Type        = make_dilithiumDecomposePoly_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":139,"deletions":0,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+  static const TypeFunc* _double_keccak_Type;\n@@ -182,0 +183,5 @@\n+  static const TypeFunc* _dilithiumAlmostNtt_Type;\n+  static const TypeFunc* _dilithiumAlmostInverseNtt_Type;\n+  static const TypeFunc* _dilithiumNttMult_Type;\n+  static const TypeFunc* _dilithiumMontMulByConstant_Type;\n+  static const TypeFunc* _dilithiumDecomposePoly_Type;\n@@ -532,0 +538,5 @@\n+  static inline const TypeFunc* double_keccak_Type() {\n+    assert(_double_keccak_Type != nullptr, \"should be initialized\");\n+    return _double_keccak_Type;\n+  }\n+\n@@ -580,0 +591,25 @@\n+  static inline const TypeFunc* dilithiumAlmostNtt_Type() {\n+    assert(_dilithiumAlmostNtt_Type != nullptr, \"should be initialized\");\n+    return _dilithiumAlmostNtt_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumAlmostInverseNtt_Type() {\n+    assert(_dilithiumAlmostInverseNtt_Type != nullptr, \"should be initialized\");\n+    return _dilithiumAlmostInverseNtt_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumNttMult_Type() {\n+    assert(_dilithiumNttMult_Type != nullptr, \"should be initialized\");\n+    return _dilithiumNttMult_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumMontMulByConstant_Type() {\n+    assert(_dilithiumMontMulByConstant_Type != nullptr, \"should be initialized\");\n+    return _dilithiumMontMulByConstant_Type;\n+  }\n+\n+  static inline const TypeFunc* dilithiumDecomposePoly_Type() {\n+    assert(_dilithiumDecomposePoly_Type != nullptr, \"should be initialized\");\n+    return _dilithiumDecomposePoly_Type;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-  Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);\n+  Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler, Arena::Tag::tag_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"interpreter\/bytecode.inline.hpp\"\n@@ -671,5 +672,6 @@\n-    Bytecode_invoke cur = Bytecode_invoke_check(method, deopt_sender.interpreter_frame_bci());\n-    if (cur.is_invokedynamic() || cur.is_invokehandle()) {\n-      \/\/ Method handle invokes may involve fairly arbitrary chains of\n-      \/\/ calls so it's impossible to know how much actual space the\n-      \/\/ caller has for locals.\n+    Bytecode_invoke cur(method, deopt_sender.interpreter_frame_bci());\n+    if (cur.has_member_arg()) {\n+      \/\/ This should cover all real-world cases.  One exception is a pathological chain of\n+      \/\/ MH.linkToXXX() linker calls, which only trusted code could do anyway.  To handle that case, we\n+      \/\/ would need to get the size from the resolved method entry.  Another exception would\n+      \/\/ be an invokedynamic with an adapter that is really a MethodHandle linker.\n@@ -778,0 +780,5 @@\n+  int caller_actual_parameters = -1; \/\/ value not used except for interpreted frames, see below\n+  if (deopt_sender.is_interpreted_frame()) {\n+    caller_actual_parameters = callee_parameters + (caller_was_method_handle ? 1 : 0);\n+  }\n+\n@@ -780,1 +787,1 @@\n-                                      caller_was_method_handle ? 0 : callee_parameters,\n+                                      caller_actual_parameters,\n@@ -969,1 +976,1 @@\n-        if (i != 0 && !invoke.is_invokedynamic() && MethodHandles::has_member_arg(invoke.klass(), invoke.name())) {\n+        if (i != 0 && invoke.has_member_arg()) {\n@@ -2826,0 +2833,1 @@\n+  \"auto_vectorization_check\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    Reason_auto_vectorization_check, \/\/ compiler generated (speculative) auto vectorization checks failed\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -328,0 +328,3 @@\n+  product(bool, UseDilithiumIntrinsics, false, DIAGNOSTIC,                  \\\n+          \"Use intrinsics for the vectorized version of Dilithium\")         \\\n+                                                                            \\\n@@ -1430,0 +1433,3 @@\n+  product(bool, PrintCompilerMemoryStatisticsAtExit, false, DIAGNOSTIC,     \\\n+          \"Print compiler memory statistics upon VM exit.\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1013,1 +1013,2 @@\n-     \"Total: \" JLONG_FORMAT \" ns\",\n+     \"Total: \" JLONG_FORMAT \" ns, \"\n+     \"Threads: %d runnable, %d total\",\n@@ -1019,1 +1020,3 @@\n-      _last_safepoint_end_time_ns   - _last_safepoint_begin_time_ns\n+      _last_safepoint_end_time_ns   - _last_safepoint_begin_time_ns,\n+      _nof_running,\n+      _nof_threads\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,0 @@\n-  friend class VMStructs;\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-\/\/ relevant template macros ahve been defined\n+\/\/ relevant template macros have been defined\n@@ -691,0 +691,15 @@\n+  do_stub(compiler, dilithiumAlmostNtt)                                 \\\n+  do_entry(compiler, dilithiumAlmostNtt,                                \\\n+           dilithiumAlmostNtt, dilithiumAlmostNtt)                      \\\n+  do_stub(compiler, dilithiumAlmostInverseNtt)                          \\\n+  do_entry(compiler, dilithiumAlmostInverseNtt,                         \\\n+           dilithiumAlmostInverseNtt, dilithiumAlmostInverseNtt)        \\\n+  do_stub(compiler, dilithiumNttMult)                                   \\\n+  do_entry(compiler, dilithiumNttMult,                                  \\\n+           dilithiumNttMult, dilithiumNttMult)                          \\\n+  do_stub(compiler, dilithiumMontMulByConstant)                         \\\n+  do_entry(compiler, dilithiumMontMulByConstant,                        \\\n+           dilithiumMontMulByConstant, dilithiumMontMulByConstant)      \\\n+  do_stub(compiler, dilithiumDecomposePoly)                             \\\n+  do_entry(compiler, dilithiumDecomposePoly,                            \\\n+           dilithiumDecomposePoly, dilithiumDecomposePoly)              \\\n@@ -741,0 +756,2 @@\n+  do_stub(compiler, double_keccak)                                      \\\n+  do_entry(compiler, double_keccak, double_keccak, double_keccak)       \\\n@@ -1056,1 +1073,0 @@\n-\n@@ -1078,1 +1094,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,6 +26,0 @@\n-#include \"ci\/ciField.hpp\"\n-#include \"ci\/ciInstance.hpp\"\n-#include \"ci\/ciMethodData.hpp\"\n-#include \"ci\/ciObjArrayKlass.hpp\"\n-#include \"ci\/ciSymbol.hpp\"\n-#include \"classfile\/dictionary.hpp\"\n@@ -35,3 +29,0 @@\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -108,1 +99,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -111,1 +101,0 @@\n-#include \"runtime\/threadSMR.hpp\"\n@@ -120,24 +109,0 @@\n-#include \"opto\/addnode.hpp\"\n-#include \"opto\/block.hpp\"\n-#include \"opto\/callnode.hpp\"\n-#include \"opto\/castnode.hpp\"\n-#include \"opto\/cfgnode.hpp\"\n-#include \"opto\/chaitin.hpp\"\n-#include \"opto\/convertnode.hpp\"\n-#include \"opto\/divnode.hpp\"\n-#include \"opto\/intrinsicnode.hpp\"\n-#include \"opto\/locknode.hpp\"\n-#include \"opto\/loopnode.hpp\"\n-#include \"opto\/machnode.hpp\"\n-#include \"opto\/matcher.hpp\"\n-#include \"opto\/mathexactnode.hpp\"\n-#include \"opto\/movenode.hpp\"\n-#include \"opto\/mulnode.hpp\"\n-#include \"opto\/narrowptrnode.hpp\"\n-#include \"opto\/opaquenode.hpp\"\n-#include \"opto\/parse.hpp\"\n-#include \"opto\/phaseX.hpp\"\n-#include \"opto\/regalloc.hpp\"\n-#include \"opto\/rootnode.hpp\"\n-#include \"opto\/subnode.hpp\"\n-#include \"opto\/vectornode.hpp\"\n@@ -149,1 +114,0 @@\n-#include OS_CPU_HEADER(vmStructs)\n@@ -188,5 +152,1 @@\n-                   nonproduct_nonstatic_field,                                                                                       \\\n-                   c1_nonstatic_field,                                                                                               \\\n-                   c2_nonstatic_field,                                                                                               \\\n-                   unchecked_c1_static_field,                                                                                        \\\n-                   unchecked_c2_static_field)                                                                                        \\\n+                   nonproduct_nonstatic_field)                                                                                       \\\n@@ -445,1 +405,1 @@\n-  \/* SystemDictionary *\/                                                                                                             \\\n+  \/* VM Classes       *\/                                                                                                             \\\n@@ -600,2 +560,0 @@\n-  unchecked_c2_static_field(Deoptimization,    _trap_reason_name,                             void*)                                 \\\n-                                                                                                                                     \\\n@@ -671,2 +629,0 @@\n-  nonstatic_field(Thread,                      _resource_area,                                ResourceArea*)                         \\\n-  nonstatic_field(CompilerThread,              _env,                                          ciEnv*)                                \\\n@@ -715,69 +671,0 @@\n-  \/*******************************\/                                                                                                  \\\n-  \/* Runtime1 (NOTE: incomplete) *\/                                                                                                  \\\n-  \/*******************************\/                                                                                                  \\\n-                                                                                                                                     \\\n-  unchecked_c1_static_field(Runtime1,          _blobs,                                 sizeof(Runtime1::_blobs)) \/* NOTE: no type *\/ \\\n-                                                                                                                                     \\\n-  \/**************\/                                                                                                                   \\\n-  \/* CI *\/                                                                                                                           \\\n-  \/************\/                                                                                                                     \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciEnv,                       _compiler_data,                                void*)                                 \\\n-  nonstatic_field(ciEnv,                       _factory,                                      ciObjectFactory*)                      \\\n-  nonstatic_field(ciEnv,                       _dependencies,                                 Dependencies*)                         \\\n-  nonstatic_field(ciEnv,                       _task,                                         CompileTask*)                          \\\n-  nonstatic_field(ciEnv,                       _arena,                                        Arena*)                                \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciBaseObject,                _ident,                                        uint)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObject,                    _handle,                                       jobject)                               \\\n-  nonstatic_field(ciObject,                    _klass,                                        ciKlass*)                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMetadata,                  _metadata,                                     Metadata*)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciSymbol,                    _symbol,                                       Symbol*)                               \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciType,                      _basic_type,                                   BasicType)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciKlass,                     _name,                                         ciSymbol*)                             \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciArrayKlass,                _dimension,                                    jint)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObjArrayKlass,             _element_klass,                                ciKlass*)                              \\\n-  nonstatic_field(ciObjArrayKlass,             _base_element_klass,                           ciKlass*)                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciInstanceKlass,             _init_state,                                   InstanceKlass::ClassState)             \\\n-  nonstatic_field(ciInstanceKlass,             _is_shared,                                    bool)                                  \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMethod,                    _interpreter_invocation_count,                 int)                                   \\\n-  nonstatic_field(ciMethod,                    _interpreter_throwout_count,                   int)                                   \\\n-  nonstatic_field(ciMethod,                    _inline_instructions_size,                     int)                                   \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciMethodData,                _data_size,                                    int)                                   \\\n-  nonstatic_field(ciMethodData,                _state,                                        u_char)                                \\\n-  nonstatic_field(ciMethodData,                _extra_data_size,                              int)                                   \\\n-  nonstatic_field(ciMethodData,                _data,                                         intptr_t*)                             \\\n-  nonstatic_field(ciMethodData,                _hint_di,                                      int)                                   \\\n-  nonstatic_field(ciMethodData,                _eflags,                                       intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_local,                                    intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_stack,                                    intx)                                  \\\n-  nonstatic_field(ciMethodData,                _arg_returned,                                 intx)                                  \\\n-  nonstatic_field(ciMethodData,                _orig,                                         MethodData::CompilerCounters)          \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciField,                     _holder,                                       ciInstanceKlass*)                      \\\n-  nonstatic_field(ciField,                     _name,                                         ciSymbol*)                             \\\n-  nonstatic_field(ciField,                     _signature,                                    ciSymbol*)                             \\\n-  nonstatic_field(ciField,                     _offset,                                       int)                                   \\\n-  nonstatic_field(ciField,                     _is_constant,                                  bool)                                  \\\n-  nonstatic_field(ciField,                     _constant_value,                               ciConstant)                            \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciObjectFactory,             _ci_metadata,                                  GrowableArray<ciMetadata*>)            \\\n-  nonstatic_field(ciObjectFactory,             _symbols,                                      GrowableArray<ciSymbol*>)              \\\n-                                                                                                                                     \\\n-  nonstatic_field(ciConstant,                  _type,                                         BasicType)                             \\\n-  nonstatic_field(ciConstant,                  _value._int,                                   jint)                                  \\\n-  nonstatic_field(ciConstant,                  _value._long,                                  jlong)                                 \\\n-  nonstatic_field(ciConstant,                  _value._float,                                 jfloat)                                \\\n-  nonstatic_field(ciConstant,                  _value._double,                                jdouble)                               \\\n-  nonstatic_field(ciConstant,                  _value._object,                                ciObject*)                             \\\n-                                                                                                                                     \\\n@@ -803,117 +690,0 @@\n-  \/* Matcher (C2 only) *\/                                                                                                            \\\n-  \/*********************\/                                                                                                            \\\n-                                                                                                                                     \\\n-  unchecked_c2_static_field(Matcher,           _regEncode,                          sizeof(Matcher::_regEncode)) \/* NOTE: no type *\/ \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node,                     _in,                                           Node**)                                \\\n-  c2_nonstatic_field(Node,                     _out,                                          Node**)                                \\\n-  c2_nonstatic_field(Node,                     _cnt,                                          node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _max,                                          node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _outcnt,                                       node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _outmax,                                       node_idx_t)                            \\\n-  c2_nonstatic_field(Node,                     _idx,                                          const node_idx_t)                      \\\n-  c2_nonstatic_field(Node,                     _class_id,                                     juint)                                 \\\n-  c2_nonstatic_field(Node,                     _flags,                                        juint)                                 \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Compile,                  _root,                                         RootNode*)                             \\\n-  c2_nonstatic_field(Compile,                  _unique,                                       uint)                                  \\\n-  c2_nonstatic_field(Compile,                  _entry_bci,                                    int)                                   \\\n-  c2_nonstatic_field(Compile,                  _top,                                          Node*)                                 \\\n-  c2_nonstatic_field(Compile,                  _cfg,                                          PhaseCFG*)                             \\\n-  c2_nonstatic_field(Compile,                  _regalloc,                                     PhaseRegAlloc*)                        \\\n-  c2_nonstatic_field(Compile,                  _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(Compile,                  _compile_id,                                   const int)                             \\\n-  c2_nonstatic_field(Compile,                  _options,                                      const Options)                         \\\n-  c2_nonstatic_field(Compile,                  _ilt,                                          InlineTree*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Options,                  _subsume_loads,                                const bool)                            \\\n-  c2_nonstatic_field(Options,                  _do_escape_analysis,                           const bool)                            \\\n-  c2_nonstatic_field(Options,                  _eliminate_boxing,                             const bool)                            \\\n-  c2_nonstatic_field(Options,                  _do_locks_coarsening,                          const bool)                            \\\n-  c2_nonstatic_field(Options,                  _install_code,                                 const bool)                            \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(InlineTree,               _caller_jvms,                                  JVMState*)                             \\\n-  c2_nonstatic_field(InlineTree,               _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(InlineTree,               _caller_tree,                                  InlineTree*)                           \\\n-  c2_nonstatic_field(InlineTree,               _subtrees,                                     GrowableArray<InlineTree*>)            \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(OptoRegPair,              _first,                                        short)                                 \\\n-  c2_nonstatic_field(OptoRegPair,              _second,                                       short)                                 \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(JVMState,                 _caller,                                       JVMState*)                             \\\n-  c2_nonstatic_field(JVMState,                 _depth,                                        uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _locoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _stkoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _monoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _scloff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _endoff,                                       uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _sp,                                           uint)                                  \\\n-  c2_nonstatic_field(JVMState,                 _bci,                                          int)                                   \\\n-  c2_nonstatic_field(JVMState,                 _method,                                       ciMethod*)                             \\\n-  c2_nonstatic_field(JVMState,                 _map,                                          SafePointNode*)                        \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(SafePointNode,            _jvms,                                         JVMState* const)                       \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachSafePointNode,        _jvms,                                         JVMState*)                             \\\n-  c2_nonstatic_field(MachSafePointNode,        _jvmadj,                                       uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachIfNode,               _prob,                                         jfloat)                                \\\n-  c2_nonstatic_field(MachIfNode,               _fcnt,                                         jfloat)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachJumpNode,             _probs,                                        jfloat*)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallNode,                 _entry_point,                                  address)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallJavaNode,             _method,                                       ciMethod*)                             \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallRuntimeNode,          _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CallStaticJavaNode,       _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallJavaNode,         _method,                                       ciMethod*)                             \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallStaticJavaNode,   _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(MachCallRuntimeNode,      _name,                                         const char*)                           \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseCFG,                 _number_of_blocks,                             uint)                                  \\\n-  c2_nonstatic_field(PhaseCFG,                 _blocks,                                       Block_List)                            \\\n-  c2_nonstatic_field(PhaseCFG,                 _node_to_block_mapping,                        Block_Array)                           \\\n-  c2_nonstatic_field(PhaseCFG,                 _root_block,                                   Block*)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _node_regs,                                    OptoRegPair*)                          \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _node_regs_max_index,                          uint)                                  \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _framesize,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseRegAlloc,            _max_reg,                                      OptoReg::Name)                         \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(PhaseChaitin,             _trip_cnt,                                     int)                                   \\\n-  c2_nonstatic_field(PhaseChaitin,             _alternate,                                    int)                                   \\\n-  c2_nonstatic_field(PhaseChaitin,             _lo_degree,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _lo_stk_degree,                                uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _hi_degree,                                    uint)                                  \\\n-  c2_nonstatic_field(PhaseChaitin,             _simplified,                                   uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block,                    _nodes,                                        Node_List)                             \\\n-  c2_nonstatic_field(Block,                    _succs,                                        Block_Array)                           \\\n-  c2_nonstatic_field(Block,                    _num_succs,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _pre_order,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _dom_depth,                                    uint)                                  \\\n-  c2_nonstatic_field(Block,                    _idom,                                         Block*)                                \\\n-  c2_nonstatic_field(Block,                    _freq,                                         jdouble)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(CFGElement,               _freq,                                         jdouble)                               \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block_List,               _cnt,                                          uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Block_Array,              _size,                                         uint)                                  \\\n-  c2_nonstatic_field(Block_Array,              _blocks,                                       Block**)                               \\\n-  c2_nonstatic_field(Block_Array,              _arena,                                        Arena*)                                \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node_List,                _cnt,                                          uint)                                  \\\n-                                                                                                                                     \\\n-  c2_nonstatic_field(Node_Array,               _max,                                          uint)                                  \\\n-  c2_nonstatic_field(Node_Array,               _nodes,                                        Node**)                                \\\n-  c2_nonstatic_field(Node_Array,               _a,                                            Arena*)                                \\\n-                                                                                                                                     \\\n-                                                                                                                                     \\\n-  \/*********************\/                                                                                                            \\\n@@ -1068,4 +838,1 @@\n-                 declare_unsigned_integer_type,                           \\\n-                 declare_c1_toplevel_type,                                \\\n-                 declare_c2_type,                                         \\\n-                 declare_c2_toplevel_type)                                \\\n+                 declare_unsigned_integer_type)                           \\\n@@ -1237,1 +1004,1 @@\n-  \/* SystemDictionary *\/                                                  \\\n+  \/* VM Classes       *\/                                                  \\\n@@ -1240,1 +1007,0 @@\n-  declare_toplevel_type(SystemDictionary)                                 \\\n@@ -1246,2 +1012,0 @@\n-  declare_toplevel_type(Arena)                                            \\\n-    declare_type(ResourceArea, Arena)                                     \\\n@@ -1318,2 +1082,0 @@\n-  declare_toplevel_type(SharedRuntime)                                    \\\n-                                                                          \\\n@@ -1332,2 +1094,2 @@\n-  declare_c2_type(ExceptionBlob,         SingletonBlob)                   \\\n-  declare_c2_type(UncommonTrapBlob,      RuntimeBlob)                     \\\n+  COMPILER2_PRESENT(declare_type(ExceptionBlob,    SingletonBlob))        \\\n+  COMPILER2_PRESENT(declare_type(UncommonTrapBlob, RuntimeBlob))          \\\n@@ -1381,6 +1143,0 @@\n-  \/**********************\/                                                \\\n-  \/* Runtime1 (C1 only) *\/                                                \\\n-  \/**********************\/                                                \\\n-                                                                          \\\n-  declare_c1_toplevel_type(Runtime1)                                      \\\n-                                                                          \\\n@@ -1397,461 +1153,0 @@\n-  \/*********************\/                                                 \\\n-  \/* Matcher (C2 only) *\/                                                 \\\n-  \/*********************\/                                                 \\\n-                                                                          \\\n-  declare_c2_toplevel_type(Matcher)                                       \\\n-  declare_c2_toplevel_type(Compile)                                       \\\n-  declare_c2_toplevel_type(Options)                                       \\\n-  declare_c2_toplevel_type(InlineTree)                                    \\\n-  declare_c2_toplevel_type(OptoRegPair)                                   \\\n-  declare_c2_toplevel_type(JVMState)                                      \\\n-  declare_c2_toplevel_type(Phase)                                         \\\n-    declare_c2_type(PhaseCFG, Phase)                                      \\\n-    declare_c2_type(PhaseRegAlloc, Phase)                                 \\\n-    declare_c2_type(PhaseChaitin, PhaseRegAlloc)                          \\\n-  declare_c2_toplevel_type(CFGElement)                                    \\\n-    declare_c2_type(Block, CFGElement)                                    \\\n-  declare_c2_toplevel_type(Block_Array)                                   \\\n-    declare_c2_type(Block_List, Block_Array)                              \\\n-  declare_c2_toplevel_type(Node_Array)                                    \\\n-  declare_c2_type(Node_List, Node_Array)                                  \\\n-  declare_c2_type(Unique_Node_List, Node_List)                            \\\n-  declare_c2_toplevel_type(Node)                                          \\\n-  declare_c2_type(AddNode, Node)                                          \\\n-  declare_c2_type(AddINode, AddNode)                                      \\\n-  declare_c2_type(AddLNode, AddNode)                                      \\\n-  declare_c2_type(AddFNode, AddNode)                                      \\\n-  declare_c2_type(AddDNode, AddNode)                                      \\\n-  declare_c2_type(AddPNode, Node)                                         \\\n-  declare_c2_type(OrINode, AddNode)                                       \\\n-  declare_c2_type(OrLNode, AddNode)                                       \\\n-  declare_c2_type(XorINode, AddNode)                                      \\\n-  declare_c2_type(XorLNode, AddNode)                                      \\\n-  declare_c2_type(MaxNode, AddNode)                                       \\\n-  declare_c2_type(MaxINode, MaxNode)                                      \\\n-  declare_c2_type(MinINode, MaxNode)                                      \\\n-  declare_c2_type(MaxLNode, MaxNode)                                      \\\n-  declare_c2_type(MinLNode, MaxNode)                                      \\\n-  declare_c2_type(MaxFNode, MaxNode)                                      \\\n-  declare_c2_type(MinFNode, MaxNode)                                      \\\n-  declare_c2_type(MaxDNode, MaxNode)                                      \\\n-  declare_c2_type(MinDNode, MaxNode)                                      \\\n-  declare_c2_type(StartNode, MultiNode)                                   \\\n-  declare_c2_type(StartOSRNode, StartNode)                                \\\n-  declare_c2_type(ParmNode, ProjNode)                                     \\\n-  declare_c2_type(ReturnNode, Node)                                       \\\n-  declare_c2_type(RethrowNode, Node)                                      \\\n-  declare_c2_type(TailCallNode, ReturnNode)                               \\\n-  declare_c2_type(TailJumpNode, ReturnNode)                               \\\n-  declare_c2_type(ForwardExceptionNode, ReturnNode)                       \\\n-  declare_c2_type(SafePointNode, MultiNode)                               \\\n-  declare_c2_type(CallNode, SafePointNode)                                \\\n-  declare_c2_type(CallJavaNode, CallNode)                                 \\\n-  declare_c2_type(CallStaticJavaNode, CallJavaNode)                       \\\n-  declare_c2_type(CallDynamicJavaNode, CallJavaNode)                      \\\n-  declare_c2_type(CallRuntimeNode, CallNode)                              \\\n-  declare_c2_type(CallLeafNode, CallRuntimeNode)                          \\\n-  declare_c2_type(CallLeafNoFPNode, CallLeafNode)                         \\\n-  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n-  declare_c2_type(AllocateNode, CallNode)                                 \\\n-  declare_c2_type(AllocateArrayNode, AllocateNode)                        \\\n-  declare_c2_type(LockNode, AbstractLockNode)                             \\\n-  declare_c2_type(UnlockNode, AbstractLockNode)                           \\\n-  declare_c2_type(FastLockNode, CmpNode)                                  \\\n-  declare_c2_type(FastUnlockNode, CmpNode)                                \\\n-  declare_c2_type(RegionNode, Node)                                       \\\n-  declare_c2_type(JProjNode, ProjNode)                                    \\\n-  declare_c2_type(PhiNode, TypeNode)                                      \\\n-  declare_c2_type(GotoNode, Node)                                         \\\n-  declare_c2_type(CProjNode, ProjNode)                                    \\\n-  declare_c2_type(MultiBranchNode, MultiNode)                             \\\n-  declare_c2_type(IfNode, MultiBranchNode)                                \\\n-  declare_c2_type(IfTrueNode, CProjNode)                                  \\\n-  declare_c2_type(IfFalseNode, CProjNode)                                 \\\n-  declare_c2_type(PCTableNode, MultiBranchNode)                           \\\n-  declare_c2_type(JumpNode, PCTableNode)                                  \\\n-  declare_c2_type(JumpProjNode, JProjNode)                                \\\n-  declare_c2_type(CatchNode, PCTableNode)                                 \\\n-  declare_c2_type(CatchProjNode, CProjNode)                               \\\n-  declare_c2_type(CreateExNode, TypeNode)                                 \\\n-  declare_c2_type(ClearArrayNode, Node)                                   \\\n-  declare_c2_type(NeverBranchNode, MultiBranchNode)                       \\\n-  declare_c2_type(ConNode, TypeNode)                                      \\\n-  declare_c2_type(ConINode, ConNode)                                      \\\n-  declare_c2_type(ConPNode, ConNode)                                      \\\n-  declare_c2_type(ConNNode, ConNode)                                      \\\n-  declare_c2_type(ConLNode, ConNode)                                      \\\n-  declare_c2_type(ConFNode, ConNode)                                      \\\n-  declare_c2_type(ConDNode, ConNode)                                      \\\n-  declare_c2_type(BinaryNode, Node)                                       \\\n-  declare_c2_type(CMoveNode, TypeNode)                                    \\\n-  declare_c2_type(CMoveDNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveFNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveINode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveLNode, CMoveNode)                                  \\\n-  declare_c2_type(CMovePNode, CMoveNode)                                  \\\n-  declare_c2_type(CMoveNNode, CMoveNode)                                  \\\n-  declare_c2_type(EncodePNode, TypeNode)                                  \\\n-  declare_c2_type(DecodeNNode, TypeNode)                                  \\\n-  declare_c2_type(EncodePKlassNode, TypeNode)                             \\\n-  declare_c2_type(DecodeNKlassNode, TypeNode)                             \\\n-  declare_c2_type(ConstraintCastNode, TypeNode)                           \\\n-  declare_c2_type(CastIINode, ConstraintCastNode)                         \\\n-  declare_c2_type(CastPPNode, ConstraintCastNode)                         \\\n-  declare_c2_type(CheckCastPPNode, TypeNode)                              \\\n-  declare_c2_type(Conv2BNode, Node)                                       \\\n-  declare_c2_type(ConvertNode, TypeNode)                                  \\\n-  declare_c2_type(ConvD2FNode, Node)                                      \\\n-  declare_c2_type(ConvD2INode, Node)                                      \\\n-  declare_c2_type(ConvD2LNode, Node)                                      \\\n-  declare_c2_type(ConvF2DNode, Node)                                      \\\n-  declare_c2_type(ConvF2INode, Node)                                      \\\n-  declare_c2_type(ConvF2LNode, Node)                                      \\\n-  declare_c2_type(ConvI2DNode, Node)                                      \\\n-  declare_c2_type(ConvI2FNode, Node)                                      \\\n-  declare_c2_type(ConvI2LNode, TypeNode)                                  \\\n-  declare_c2_type(ConvL2DNode, Node)                                      \\\n-  declare_c2_type(ConvL2FNode, Node)                                      \\\n-  declare_c2_type(ConvL2INode, Node)                                      \\\n-  declare_c2_type(CastX2PNode, Node)                                      \\\n-  declare_c2_type(CastP2XNode, Node)                                      \\\n-  declare_c2_type(MemBarNode, MultiNode)                                  \\\n-  declare_c2_type(MemBarAcquireNode, MemBarNode)                          \\\n-  declare_c2_type(MemBarReleaseNode, MemBarNode)                          \\\n-  declare_c2_type(LoadFenceNode, MemBarNode)                              \\\n-  declare_c2_type(StoreFenceNode, MemBarNode)                             \\\n-  declare_c2_type(MemBarVolatileNode, MemBarNode)                         \\\n-  declare_c2_type(MemBarCPUOrderNode, MemBarNode)                         \\\n-  declare_c2_type(OnSpinWaitNode, MemBarNode)                             \\\n-  declare_c2_type(BlackholeNode, MultiNode)                               \\\n-  declare_c2_type(InitializeNode, MemBarNode)                             \\\n-  declare_c2_type(ThreadLocalNode, Node)                                  \\\n-  declare_c2_type(Opaque1Node, Node)                                      \\\n-  declare_c2_type(PartialSubtypeCheckNode, Node)                          \\\n-  declare_c2_type(MoveI2FNode, Node)                                      \\\n-  declare_c2_type(MoveL2DNode, Node)                                      \\\n-  declare_c2_type(MoveF2INode, Node)                                      \\\n-  declare_c2_type(MoveD2LNode, Node)                                      \\\n-  declare_c2_type(DivINode, Node)                                         \\\n-  declare_c2_type(DivLNode, Node)                                         \\\n-  declare_c2_type(DivFNode, Node)                                         \\\n-  declare_c2_type(DivDNode, Node)                                         \\\n-  declare_c2_type(UDivINode, Node)                                        \\\n-  declare_c2_type(UDivLNode, Node)                                        \\\n-  declare_c2_type(ModINode, Node)                                         \\\n-  declare_c2_type(ModLNode, Node)                                         \\\n-  declare_c2_type(ModFNode, Node)                                         \\\n-  declare_c2_type(ModDNode, Node)                                         \\\n-  declare_c2_type(UModINode, Node)                                        \\\n-  declare_c2_type(UModLNode, Node)                                        \\\n-  declare_c2_type(DivModNode, MultiNode)                                  \\\n-  declare_c2_type(DivModINode, DivModNode)                                \\\n-  declare_c2_type(DivModLNode, DivModNode)                                \\\n-  declare_c2_type(UDivModINode, DivModNode)                               \\\n-  declare_c2_type(UDivModLNode, DivModNode)                               \\\n-  declare_c2_type(BoxLockNode, Node)                                      \\\n-  declare_c2_type(LoopNode, RegionNode)                                   \\\n-  declare_c2_type(CountedLoopNode, LoopNode)                              \\\n-  declare_c2_type(CountedLoopEndNode, IfNode)                             \\\n-  declare_c2_type(MachNode, Node)                                         \\\n-  declare_c2_type(MachIdealNode, MachNode)                                \\\n-  declare_c2_type(MachTypeNode, MachNode)                                 \\\n-  declare_c2_type(MachBreakpointNode, MachIdealNode)                      \\\n-  declare_c2_type(MachUEPNode, MachIdealNode)                             \\\n-  declare_c2_type(MachVEPNode, MachIdealNode)                             \\\n-  declare_c2_type(MachPrologNode, MachIdealNode)                          \\\n-  declare_c2_type(MachEpilogNode, MachIdealNode)                          \\\n-  declare_c2_type(MachNopNode, MachIdealNode)                             \\\n-  declare_c2_type(MachSpillCopyNode, MachIdealNode)                       \\\n-  declare_c2_type(MachNullCheckNode, MachIdealNode)                       \\\n-  declare_c2_type(MachProjNode, ProjNode)                                 \\\n-  declare_c2_type(MachIfNode, MachNode)                                   \\\n-  declare_c2_type(MachJumpNode, MachNode)                                 \\\n-  declare_c2_type(MachFastLockNode, MachNode)                             \\\n-  declare_c2_type(MachReturnNode, MachNode)                               \\\n-  declare_c2_type(MachSafePointNode, MachReturnNode)                      \\\n-  declare_c2_type(MachCallNode, MachSafePointNode)                        \\\n-  declare_c2_type(MachCallJavaNode, MachCallNode)                         \\\n-  declare_c2_type(MachCallStaticJavaNode, MachCallJavaNode)               \\\n-  declare_c2_type(MachCallDynamicJavaNode, MachCallJavaNode)              \\\n-  declare_c2_type(MachCallRuntimeNode, MachCallNode)                      \\\n-  declare_c2_type(MachHaltNode, MachReturnNode)                           \\\n-  declare_c2_type(MachTempNode, MachNode)                                 \\\n-  declare_c2_type(MemNode, Node)                                          \\\n-  declare_c2_type(MergeMemNode, Node)                                     \\\n-  declare_c2_type(LoadNode, MemNode)                                      \\\n-  declare_c2_type(LoadBNode, LoadNode)                                    \\\n-  declare_c2_type(LoadUSNode, LoadNode)                                   \\\n-  declare_c2_type(LoadINode, LoadNode)                                    \\\n-  declare_c2_type(LoadRangeNode, LoadINode)                               \\\n-  declare_c2_type(LoadLNode, LoadNode)                                    \\\n-  declare_c2_type(LoadL_unalignedNode, LoadLNode)                         \\\n-  declare_c2_type(LoadFNode, LoadNode)                                    \\\n-  declare_c2_type(LoadDNode, LoadNode)                                    \\\n-  declare_c2_type(LoadD_unalignedNode, LoadDNode)                         \\\n-  declare_c2_type(LoadPNode, LoadNode)                                    \\\n-  declare_c2_type(LoadNNode, LoadNode)                                    \\\n-  declare_c2_type(LoadKlassNode, LoadPNode)                               \\\n-  declare_c2_type(LoadNKlassNode, LoadNNode)                              \\\n-  declare_c2_type(LoadSNode, LoadNode)                                    \\\n-  declare_c2_type(StoreNode, MemNode)                                     \\\n-  declare_c2_type(StoreBNode, StoreNode)                                  \\\n-  declare_c2_type(StoreCNode, StoreNode)                                  \\\n-  declare_c2_type(StoreINode, StoreNode)                                  \\\n-  declare_c2_type(StoreLNode, StoreNode)                                  \\\n-  declare_c2_type(StoreFNode, StoreNode)                                  \\\n-  declare_c2_type(StoreDNode, StoreNode)                                  \\\n-  declare_c2_type(StorePNode, StoreNode)                                  \\\n-  declare_c2_type(StoreNNode, StoreNode)                                  \\\n-  declare_c2_type(StoreNKlassNode, StoreNode)                             \\\n-  declare_c2_type(SCMemProjNode, ProjNode)                                \\\n-  declare_c2_type(LoadStoreNode, Node)                                    \\\n-  declare_c2_type(CompareAndSwapNode, LoadStoreConditionalNode)           \\\n-  declare_c2_type(CompareAndSwapBNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapSNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapLNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapINode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapPNode, CompareAndSwapNode)                \\\n-  declare_c2_type(CompareAndSwapNNode, CompareAndSwapNode)                \\\n-  declare_c2_type(WeakCompareAndSwapBNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapSNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapLNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapINode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapPNode, CompareAndSwapNode)            \\\n-  declare_c2_type(WeakCompareAndSwapNNode, CompareAndSwapNode)            \\\n-  declare_c2_type(CompareAndExchangeNode, LoadStoreNode)                  \\\n-  declare_c2_type(CompareAndExchangeBNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeSNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeLNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeINode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangePNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(CompareAndExchangeNNode, CompareAndExchangeNode)        \\\n-  declare_c2_type(MulNode, Node)                                          \\\n-  declare_c2_type(MulINode, MulNode)                                      \\\n-  declare_c2_type(MulLNode, MulNode)                                      \\\n-  declare_c2_type(MulFNode, MulNode)                                      \\\n-  declare_c2_type(MulDNode, MulNode)                                      \\\n-  declare_c2_type(MulHiLNode, Node)                                       \\\n-  declare_c2_type(UMulHiLNode, Node)                                      \\\n-  declare_c2_type(AndINode, MulINode)                                     \\\n-  declare_c2_type(AndLNode, MulLNode)                                     \\\n-  declare_c2_type(LShiftINode, Node)                                      \\\n-  declare_c2_type(LShiftLNode, Node)                                      \\\n-  declare_c2_type(RShiftINode, Node)                                      \\\n-  declare_c2_type(RShiftLNode, Node)                                      \\\n-  declare_c2_type(URShiftINode, Node)                                     \\\n-  declare_c2_type(URShiftLNode, Node)                                     \\\n-  declare_c2_type(MultiNode, Node)                                        \\\n-  declare_c2_type(ProjNode, Node)                                         \\\n-  declare_c2_type(TypeNode, Node)                                         \\\n-  declare_c2_type(RootNode, LoopNode)                                     \\\n-  declare_c2_type(HaltNode, Node)                                         \\\n-  declare_c2_type(SubNode, Node)                                          \\\n-  declare_c2_type(SubINode, SubNode)                                      \\\n-  declare_c2_type(SubLNode, SubNode)                                      \\\n-  declare_c2_type(SubFPNode, SubNode)                                     \\\n-  declare_c2_type(SubFNode, SubFPNode)                                    \\\n-  declare_c2_type(SubDNode, SubFPNode)                                    \\\n-  declare_c2_type(CmpNode, SubNode)                                       \\\n-  declare_c2_type(CmpINode, CmpNode)                                      \\\n-  declare_c2_type(CmpUNode, CmpNode)                                      \\\n-  declare_c2_type(CmpU3Node, CmpUNode)                                    \\\n-  declare_c2_type(CmpPNode, CmpNode)                                      \\\n-  declare_c2_type(CmpNNode, CmpNode)                                      \\\n-  declare_c2_type(CmpLNode, CmpNode)                                      \\\n-  declare_c2_type(CmpULNode, CmpNode)                                     \\\n-  declare_c2_type(CmpL3Node, CmpLNode)                                    \\\n-  declare_c2_type(CmpUL3Node, CmpULNode)                                  \\\n-  declare_c2_type(CmpFNode, CmpNode)                                      \\\n-  declare_c2_type(CmpF3Node, CmpFNode)                                    \\\n-  declare_c2_type(CmpDNode, CmpNode)                                      \\\n-  declare_c2_type(CmpD3Node, CmpDNode)                                    \\\n-  declare_c2_type(BoolNode, Node)                                         \\\n-  declare_c2_type(AbsNode, Node)                                          \\\n-  declare_c2_type(AbsINode, AbsNode)                                      \\\n-  declare_c2_type(AbsFNode, AbsNode)                                      \\\n-  declare_c2_type(AbsDNode, AbsNode)                                      \\\n-  declare_c2_type(CmpLTMaskNode, Node)                                    \\\n-  declare_c2_type(NegNode, Node)                                          \\\n-  declare_c2_type(NegINode, NegNode)                                      \\\n-  declare_c2_type(NegLNode, NegNode)                                      \\\n-  declare_c2_type(NegFNode, NegNode)                                      \\\n-  declare_c2_type(NegDNode, NegNode)                                      \\\n-  declare_c2_type(AtanDNode, Node)                                        \\\n-  declare_c2_type(SqrtFNode, Node)                                        \\\n-  declare_c2_type(SqrtDNode, Node)                                        \\\n-  declare_c2_type(ReverseBytesINode, Node)                                \\\n-  declare_c2_type(ReverseBytesLNode, Node)                                \\\n-  declare_c2_type(ReductionNode, Node)                                    \\\n-  declare_c2_type(VectorNode, Node)                                       \\\n-  declare_c2_type(AbsVFNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVDNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVBNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVSNode, VectorNode)                                  \\\n-  declare_c2_type(AbsVINode, VectorNode)                                  \\\n-  declare_c2_type(AbsVLNode, VectorNode)                                  \\\n-  declare_c2_type(AddVBNode, VectorNode)                                  \\\n-  declare_c2_type(AddVSNode, VectorNode)                                  \\\n-  declare_c2_type(AddVINode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVINode, ReductionNode)                      \\\n-  declare_c2_type(AddVLNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVLNode, ReductionNode)                      \\\n-  declare_c2_type(AddVFNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVFNode, ReductionNode)                      \\\n-  declare_c2_type(AddVDNode, VectorNode)                                  \\\n-  declare_c2_type(AddReductionVDNode, ReductionNode)                      \\\n-  declare_c2_type(SubVBNode, VectorNode)                                  \\\n-  declare_c2_type(SubVSNode, VectorNode)                                  \\\n-  declare_c2_type(SubVINode, VectorNode)                                  \\\n-  declare_c2_type(SubVLNode, VectorNode)                                  \\\n-  declare_c2_type(SubVFNode, VectorNode)                                  \\\n-  declare_c2_type(SubVDNode, VectorNode)                                  \\\n-  declare_c2_type(MulVBNode, VectorNode)                                  \\\n-  declare_c2_type(MulVSNode, VectorNode)                                  \\\n-  declare_c2_type(MulVLNode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVLNode, ReductionNode)                      \\\n-  declare_c2_type(MulVINode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVINode, ReductionNode)                      \\\n-  declare_c2_type(MulVFNode, VectorNode)                                  \\\n-  declare_c2_type(MulReductionVFNode, ReductionNode)                      \\\n-  declare_c2_type(MulVDNode, VectorNode)                                  \\\n-  declare_c2_type(NegVNode, VectorNode)                                   \\\n-  declare_c2_type(NegVINode, NegVNode)                                    \\\n-  declare_c2_type(NegVLNode, NegVNode)                                    \\\n-  declare_c2_type(NegVFNode, NegVNode)                                    \\\n-  declare_c2_type(NegVDNode, NegVNode)                                    \\\n-  declare_c2_type(FmaVDNode, VectorNode)                                  \\\n-  declare_c2_type(FmaVFNode, VectorNode)                                  \\\n-  declare_c2_type(CompressVNode, VectorNode)                              \\\n-  declare_c2_type(CompressMNode, VectorNode)                              \\\n-  declare_c2_type(ExpandVNode, VectorNode)                                \\\n-  declare_c2_type(CompressBitsVNode, VectorNode)                          \\\n-  declare_c2_type(ExpandBitsVNode, VectorNode)                            \\\n-  declare_c2_type(MulReductionVDNode, ReductionNode)                      \\\n-  declare_c2_type(DivVFNode, VectorNode)                                  \\\n-  declare_c2_type(DivVDNode, VectorNode)                                  \\\n-  declare_c2_type(PopCountVINode, VectorNode)                             \\\n-  declare_c2_type(PopCountVLNode, VectorNode)                             \\\n-  declare_c2_type(LShiftVBNode, VectorNode)                               \\\n-  declare_c2_type(LShiftVSNode, VectorNode)                               \\\n-  declare_c2_type(LShiftVINode, VectorNode)                               \\\n-  declare_c2_type(LShiftVLNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVBNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVSNode, VectorNode)                               \\\n-  declare_c2_type(RShiftVINode, VectorNode)                               \\\n-  declare_c2_type(RShiftVLNode, VectorNode)                               \\\n-  declare_c2_type(URShiftVBNode, VectorNode)                              \\\n-  declare_c2_type(URShiftVSNode, VectorNode)                              \\\n-  declare_c2_type(URShiftVINode, VectorNode)                              \\\n-  declare_c2_type(URShiftVLNode, VectorNode)                              \\\n-  declare_c2_type(MinReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(MaxReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(AndVNode, VectorNode)                                   \\\n-  declare_c2_type(AndReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(OrVNode, VectorNode)                                    \\\n-  declare_c2_type(OrReductionVNode, ReductionNode)                        \\\n-  declare_c2_type(XorVNode, VectorNode)                                   \\\n-  declare_c2_type(XorReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(MaxVNode, VectorNode)                                   \\\n-  declare_c2_type(MinVNode, VectorNode)                                   \\\n-  declare_c2_type(LoadVectorNode, LoadNode)                               \\\n-  declare_c2_type(StoreVectorNode, StoreNode)                             \\\n-  declare_c2_type(ReplicateNode, VectorNode)                              \\\n-  declare_c2_type(PopulateIndexNode, VectorNode)                          \\\n-  declare_c2_type(PackNode, VectorNode)                                   \\\n-  declare_c2_type(PackBNode, PackNode)                                    \\\n-  declare_c2_type(PackSNode, PackNode)                                    \\\n-  declare_c2_type(PackINode, PackNode)                                    \\\n-  declare_c2_type(PackLNode, PackNode)                                    \\\n-  declare_c2_type(PackFNode, PackNode)                                    \\\n-  declare_c2_type(PackDNode, PackNode)                                    \\\n-  declare_c2_type(Pack2LNode, PackNode)                                   \\\n-  declare_c2_type(Pack2DNode, PackNode)                                   \\\n-  declare_c2_type(ExtractNode, Node)                                      \\\n-  declare_c2_type(ExtractBNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractUBNode, ExtractNode)                             \\\n-  declare_c2_type(ExtractCNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractSNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractINode, ExtractNode)                              \\\n-  declare_c2_type(ExtractLNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractFNode, ExtractNode)                              \\\n-  declare_c2_type(ExtractDNode, ExtractNode)                              \\\n-  declare_c2_type(OverflowNode, CmpNode)                                  \\\n-  declare_c2_type(OverflowINode, OverflowNode)                            \\\n-  declare_c2_type(OverflowAddINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowSubINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowMulINode, OverflowINode)                        \\\n-  declare_c2_type(OverflowLNode, OverflowNode)                            \\\n-  declare_c2_type(OverflowAddLNode, OverflowLNode)                        \\\n-  declare_c2_type(OverflowSubLNode, OverflowLNode)                        \\\n-  declare_c2_type(OverflowMulLNode, OverflowLNode)                        \\\n-  declare_c2_type(FmaDNode, Node)                                         \\\n-  declare_c2_type(FmaFNode, Node)                                         \\\n-  declare_c2_type(CopySignDNode, Node)                                    \\\n-  declare_c2_type(CopySignFNode, Node)                                    \\\n-  declare_c2_type(SignumDNode, Node)                                      \\\n-  declare_c2_type(SignumFNode, Node)                                      \\\n-  declare_c2_type(IsInfiniteFNode, Node)                                  \\\n-  declare_c2_type(IsInfiniteDNode, Node)                                  \\\n-  declare_c2_type(IsFiniteFNode, Node)                                    \\\n-  declare_c2_type(IsFiniteDNode, Node)                                    \\\n-  declare_c2_type(LoadVectorGatherNode, LoadVectorNode)                   \\\n-  declare_c2_type(StoreVectorScatterNode, StoreVectorNode)                \\\n-  declare_c2_type(VectorLoadMaskNode, VectorNode)                         \\\n-  declare_c2_type(VectorLoadShuffleNode, VectorNode)                      \\\n-  declare_c2_type(VectorStoreMaskNode, VectorNode)                        \\\n-  declare_c2_type(VectorBlendNode, VectorNode)                            \\\n-  declare_c2_type(VectorRearrangeNode, VectorNode)                        \\\n-  declare_c2_type(VectorMaskWrapperNode, VectorNode)                      \\\n-  declare_c2_type(VectorMaskCmpNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastB2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastS2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastI2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastL2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastF2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorCastD2XNode, VectorNode)                          \\\n-  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n-  declare_c2_type(VectorInsertNode, VectorNode)                           \\\n-  declare_c2_type(VectorUnboxNode, VectorNode)                            \\\n-  declare_c2_type(VectorReinterpretNode, VectorNode)                      \\\n-  declare_c2_type(VectorMaskCastNode, VectorNode)                         \\\n-  declare_c2_type(CountLeadingZerosVNode, VectorNode)                     \\\n-  declare_c2_type(CountTrailingZerosVNode, VectorNode)                    \\\n-  declare_c2_type(ReverseBytesVNode, VectorNode)                          \\\n-  declare_c2_type(ReverseVNode, VectorNode)                               \\\n-  declare_c2_type(MaskAllNode, VectorNode)                                \\\n-  declare_c2_type(AndVMaskNode, VectorNode)                               \\\n-  declare_c2_type(OrVMaskNode, VectorNode)                                \\\n-  declare_c2_type(XorVMaskNode, VectorNode)                               \\\n-  declare_c2_type(VectorBoxNode, Node)                                    \\\n-  declare_c2_type(VectorBoxAllocateNode, CallStaticJavaNode)              \\\n-  declare_c2_type(VectorTestNode, CmpNode)                                \\\n-                                                                          \\\n-  \/*********************\/                                                 \\\n-  \/* Adapter Blob Entries *\/                                              \\\n-  \/*********************\/                                                 \\\n-  declare_toplevel_type(AdapterHandlerEntry)                              \\\n-  declare_toplevel_type(AdapterHandlerEntry*)                             \\\n-                                                                          \\\n-  \/*********************\/                                                 \\\n-  \/* CI *\/                                                                \\\n-  \/*********************\/                                                 \\\n-  declare_toplevel_type(ciEnv)                                            \\\n-  declare_toplevel_type(ciObjectFactory)                                  \\\n-  declare_toplevel_type(ciConstant)                                       \\\n-  declare_toplevel_type(ciField)                                          \\\n-  declare_toplevel_type(ciSymbol)                                         \\\n-  declare_toplevel_type(ciBaseObject)                                     \\\n-  declare_type(ciObject, ciBaseObject)                                    \\\n-  declare_type(ciInstance, ciObject)                                      \\\n-  declare_type(ciMetadata, ciBaseObject)                                  \\\n-  declare_type(ciMethod, ciMetadata)                                      \\\n-  declare_type(ciMethodData, ciMetadata)                                  \\\n-  declare_type(ciType, ciMetadata)                                        \\\n-  declare_type(ciKlass, ciType)                                           \\\n-  declare_type(ciInstanceKlass, ciKlass)                                  \\\n-  declare_type(ciArrayKlass, ciKlass)                                     \\\n-  declare_type(ciTypeArrayKlass, ciArrayKlass)                            \\\n-  declare_type(ciObjArrayKlass, ciArrayKlass)                             \\\n-                                                                          \\\n@@ -1902,1 +1197,0 @@\n-   COMPILER2_PRESENT(declare_integer_type(OptoReg::Name))                 \\\n@@ -1954,1 +1248,0 @@\n-  COMPILER2_PRESENT(declare_unsigned_integer_type(node_idx_t))            \\\n@@ -1994,4 +1287,1 @@\n-                         declare_preprocessor_constant,                   \\\n-                         declare_c1_constant,                             \\\n-                         declare_c2_constant,                             \\\n-                         declare_c2_preprocessor_constant)                \\\n+                         declare_preprocessor_constant)                   \\\n@@ -2011,0 +1301,1 @@\n+  declare_preprocessor_constant(\"COMPILER2\", COMPILER2_PRESENT(1) NOT_COMPILER2(0)) \\\n@@ -2277,0 +1568,1 @@\n+  declare_constant(Deoptimization::Reason_auto_vectorization_check)       \\\n@@ -2359,6 +1651,0 @@\n-  \/*********************\/                                                 \\\n-  \/* Matcher (C2 only) *\/                                                 \\\n-  \/*********************\/                                                 \\\n-                                                                          \\\n-  declare_c2_preprocessor_constant(\"Matcher::interpreter_frame_pointer_reg\", Matcher::interpreter_frame_pointer_reg()) \\\n-                                                                          \\\n@@ -2464,2 +1750,2 @@\n-  declare_c2_preprocessor_constant(\"SAVED_ON_ENTRY_REG_COUNT\", SAVED_ON_ENTRY_REG_COUNT) \\\n-  declare_c2_preprocessor_constant(\"C_SAVED_ON_ENTRY_REG_COUNT\", C_SAVED_ON_ENTRY_REG_COUNT) \\\n+  COMPILER2_PRESENT(declare_preprocessor_constant(\"SAVED_ON_ENTRY_REG_COUNT\", SAVED_ON_ENTRY_REG_COUNT)) \\\n+  COMPILER2_PRESENT(declare_preprocessor_constant(\"C_SAVED_ON_ENTRY_REG_COUNT\", C_SAVED_ON_ENTRY_REG_COUNT)) \\\n@@ -2516,1 +1802,1 @@\n-#define VM_LONG_CONSTANTS(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant) \\\n+#define VM_LONG_CONSTANTS(declare_constant, declare_preprocessor_constant) \\\n@@ -2582,102 +1868,0 @@\n-\/\/ Generate and check a nonstatic field in C1 builds\n-#ifdef COMPILER1\n-# define GENERATE_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)    CHECK_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C1_FIELD_TYPE_PRESENT(a, b, c)          ENSURE_FIELD_TYPE_PRESENT(a, b, c)\n-#else\n-# define GENERATE_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C1_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C1_FIELD_TYPE_PRESENT(a, b, c)\n-#endif \/* COMPILER1 *\/\n-\/\/ Generate and check a nonstatic field in C2 builds\n-#ifdef COMPILER2\n-# define GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)    CHECK_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C2_FIELD_TYPE_PRESENT(a, b, c)          ENSURE_FIELD_TYPE_PRESENT(a, b, c)\n-#else\n-# define GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY(a, b, c)\n-# define ENSURE_C2_FIELD_TYPE_PRESENT(a, b, c)\n-#endif \/* COMPILER2 *\/\n-\n-\/\/ Generate but do not check a static field in C1 builds\n-#ifdef COMPILER1\n-# define GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#else\n-# define GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#endif \/* COMPILER1 *\/\n-\n-\/\/ Generate but do not check a static field in C2 builds\n-#ifdef COMPILER2\n-# define GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c) GENERATE_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#else\n-# define GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY(a, b, c)\n-#endif \/* COMPILER2 *\/\n-\n-\/\/--------------------------------------------------------------------------------\n-\/\/ VMTypeEntry build-specific macros\n-\/\/\n-\n-#ifdef COMPILER1\n-# define GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY(a)               GENERATE_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#else\n-# define GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#endif \/* COMPILER1 *\/\n-\n-#ifdef COMPILER2\n-# define GENERATE_C2_VM_TYPE_ENTRY(a, b)                     GENERATE_VM_TYPE_ENTRY(a, b)\n-# define CHECK_C2_VM_TYPE_ENTRY(a, b)                        CHECK_VM_TYPE_ENTRY(a, b)\n-# define GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY(a)               GENERATE_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#else\n-# define GENERATE_C2_VM_TYPE_ENTRY(a, b)\n-# define CHECK_C2_VM_TYPE_ENTRY(a, b)\n-# define GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY(a)\n-# define CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY(a)\n-#endif \/* COMPILER2 *\/\n-\n-\n-\/\/--------------------------------------------------------------------------------\n-\/\/ VMIntConstantEntry build-specific macros\n-\/\/\n-\n-\/\/ Generate an int constant for a C1 build\n-#ifdef COMPILER1\n-# define GENERATE_C1_VM_INT_CONSTANT_ENTRY(name)  GENERATE_VM_INT_CONSTANT_ENTRY(name)\n-#else\n-# define GENERATE_C1_VM_INT_CONSTANT_ENTRY(name)\n-#endif \/* COMPILER1 *\/\n-\n-\/\/ Generate an int constant for a C2 build\n-#ifdef COMPILER2\n-# define GENERATE_C2_VM_INT_CONSTANT_ENTRY(name)                      GENERATE_VM_INT_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY(name, value)  GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY(name, value)\n-#else\n-# define GENERATE_C2_VM_INT_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY(name, value)\n-#endif \/* COMPILER1 *\/\n-\n-\n-\/\/--------------------------------------------------------------------------------\n-\/\/ VMLongConstantEntry build-specific macros\n-\/\/\n-\n-\/\/ Generate a long constant for a C1 build\n-#ifdef COMPILER1\n-# define GENERATE_C1_VM_LONG_CONSTANT_ENTRY(name)  GENERATE_VM_LONG_CONSTANT_ENTRY(name)\n-#else\n-# define GENERATE_C1_VM_LONG_CONSTANT_ENTRY(name)\n-#endif \/* COMPILER1 *\/\n-\n-\/\/ Generate a long constant for a C2 build\n-#ifdef COMPILER2\n-# define GENERATE_C2_VM_LONG_CONSTANT_ENTRY(name)                     GENERATE_VM_LONG_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY(name, value) GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY(name, value)\n-#else\n-# define GENERATE_C2_VM_LONG_CONSTANT_ENTRY(name)\n-# define GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY(name, value)\n-#endif \/* COMPILER1 *\/\n-\n-\n@@ -2697,5 +1881,1 @@\n-             GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C1_NONSTATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-             GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n+             GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2708,4 +1888,1 @@\n-                GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-                GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n+                GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2717,13 +1894,1 @@\n-                 GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-                 GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n-\n-  VM_STRUCTS_OS_CPU(GENERATE_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_STATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_UNCHECKED_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_C1_UNCHECKED_STATIC_VM_STRUCT_ENTRY,\n-                    GENERATE_C2_UNCHECKED_STATIC_VM_STRUCT_ENTRY)\n+                 GENERATE_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2744,5 +1909,1 @@\n-           GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-           GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-           GENERATE_C2_VM_TYPE_ENTRY,\n-           GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n-\n+           GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY)\n@@ -2754,4 +1915,1 @@\n-              GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-              GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-              GENERATE_C2_VM_TYPE_ENTRY,\n-              GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n+              GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY)\n@@ -2763,13 +1921,1 @@\n-               GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-               GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-               GENERATE_C2_VM_TYPE_ENTRY,\n-               GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n-\n-  VM_TYPES_OS_CPU(GENERATE_VM_TYPE_ENTRY,\n-                  GENERATE_TOPLEVEL_VM_TYPE_ENTRY,\n-                  GENERATE_OOP_VM_TYPE_ENTRY,\n-                  GENERATE_INTEGER_VM_TYPE_ENTRY,\n-                  GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY,\n-                  GENERATE_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-                  GENERATE_C2_VM_TYPE_ENTRY,\n-                  GENERATE_C2_TOPLEVEL_VM_TYPE_ENTRY)\n+               GENERATE_UNSIGNED_INTEGER_VM_TYPE_ENTRY)\n@@ -2788,4 +1934,1 @@\n-                   GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                   GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                   GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                   GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+                   GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2794,4 +1937,1 @@\n-                      GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                      GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                      GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                      GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+                      GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2800,4 +1940,1 @@\n-                       GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                       GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+                       GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2805,5 +1942,0 @@\n-  VM_INT_CONSTANTS_OS_CPU(GENERATE_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_C1_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_C2_VM_INT_CONSTANT_ENTRY,\n-                          GENERATE_C2_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n@@ -2824,4 +1956,1 @@\n-                    GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                    GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                    GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                    GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n+                    GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2830,4 +1959,1 @@\n-                       GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                       GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                       GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                       GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n+                       GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2836,4 +1962,1 @@\n-                        GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                        GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n+                        GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2841,5 +1964,0 @@\n-  VM_LONG_CONSTANTS_OS_CPU(GENERATE_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_C1_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_C2_VM_LONG_CONSTANT_ENTRY,\n-                           GENERATE_C2_PREPROCESSOR_VM_LONG_CONSTANT_ENTRY)\n@@ -2899,6 +2017,1 @@\n-             CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-             CHECK_C1_NONSTATIC_VM_STRUCT_ENTRY,\n-             CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP);\n-\n+             CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2910,13 +2023,1 @@\n-                 CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                 CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                 CHECK_NO_OP,\n-                 CHECK_NO_OP);\n-\n-  VM_STRUCTS_OS_CPU(CHECK_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_STATIC_VM_STRUCT_ENTRY,\n-                    CHECK_NO_OP,\n-                    CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_C2_NONSTATIC_VM_STRUCT_ENTRY,\n-                    CHECK_NO_OP,\n-                    CHECK_NO_OP);\n+                 CHECK_NONPRODUCT_NONSTATIC_VM_STRUCT_ENTRY)\n@@ -2928,4 +2029,1 @@\n-           CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-           CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-           CHECK_C2_VM_TYPE_ENTRY,\n-           CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY);\n+           CHECK_SINGLE_ARG_VM_TYPE_NO_OP)\n@@ -2938,13 +2036,1 @@\n-               CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-               CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-               CHECK_C2_VM_TYPE_ENTRY,\n-               CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY);\n-\n-  VM_TYPES_OS_CPU(CHECK_VM_TYPE_ENTRY,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_SINGLE_ARG_VM_TYPE_NO_OP,\n-                  CHECK_C1_TOPLEVEL_VM_TYPE_ENTRY,\n-                  CHECK_C2_VM_TYPE_ENTRY,\n-                  CHECK_C2_TOPLEVEL_VM_TYPE_ENTRY);\n+               CHECK_SINGLE_ARG_VM_TYPE_NO_OP)\n@@ -2974,5 +2060,1 @@\n-             CHECK_NO_OP,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP);\n+             CHECK_NO_OP)\n@@ -2985,5 +2067,1 @@\n-             ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT,\n-             ENSURE_C1_FIELD_TYPE_PRESENT,\n-             ENSURE_C2_FIELD_TYPE_PRESENT,\n-             CHECK_NO_OP,\n-             CHECK_NO_OP);\n+             ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT)\n@@ -2995,12 +2073,1 @@\n-                 ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT,\n-                 ENSURE_C2_FIELD_TYPE_PRESENT,\n-                 CHECK_NO_OP,\n-                 CHECK_NO_OP);\n-  VM_STRUCTS_OS_CPU(ENSURE_FIELD_TYPE_PRESENT,\n-                    ENSURE_FIELD_TYPE_PRESENT,\n-                    CHECK_NO_OP,\n-                    ENSURE_FIELD_TYPE_PRESENT,\n-                    ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT,\n-                    ENSURE_C2_FIELD_TYPE_PRESENT,\n-                    CHECK_NO_OP,\n-                    CHECK_NO_OP);\n+                 ENSURE_NONPRODUCT_FIELD_TYPE_PRESENT)\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":31,"deletions":964,"binary":false,"changes":995,"status":"modified"},{"patch":"@@ -1173,3 +1173,4 @@\n-  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n-  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n-  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _verbose(\"verbose\", \"Print detailed information\", \"BOOLEAN\", false, \"false\"),\n+  _legend(\"legend\", \"Table mode: print legend\", \"BOOLEAN\", false, \"false\"),\n+  _minsize(\"minsize\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n+  _dcmdparser.add_dcmd_option(&_verbose);\n@@ -1177,0 +1178,1 @@\n+  _dcmdparser.add_dcmd_option(&_legend);\n@@ -1180,2 +1182,1 @@\n-  const bool human_readable = _human_readable.value();\n-  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n+  CompilationMemoryStatistic::print_jcmd_report(output(), _verbose.value(), _legend.value(), minsize);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -828,1 +828,2 @@\n-  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<bool> _verbose;\n+  DCmdArgument<bool> _legend;\n@@ -831,1 +832,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 3; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -737,1 +737,1 @@\n-    @SuppressWarnings({\"deprecation\", \"removal\"})\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -1561,2 +1562,2 @@\n-            public VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask, ByteOrder order) {\n-                return VarHandles.memorySegmentViewHandle(carrier, alignmentMask, order);\n+            public VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean constantOffset, long offset) {\n+                return VarHandles.memorySegmentViewHandle(carrier, enclosing, alignmentMask, constantOffset, offset, order);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -475,2 +475,1 @@\n-     permits IndirectVarHandle, LazyInitializingVarHandle,\n-             VarHandleSegmentViewBase,\n+     permits IndirectVarHandle, LazyInitializingVarHandle, SegmentVarHandle,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -316,2 +317,3 @@\n-     * Creates a memory segment view var handle.\n-     *\n+     * Creates a memory segment view var handle accessing a {@code carrier} element. It has access coordinates\n+     * {@code (MS, long)} if {@code constantOffset}, {@code (MS, long, (validated) long)} otherwise.\n+     * <p>\n@@ -319,4 +321,5 @@\n-     * and a {@code long} as second argument (the offset into the segment).\n-     *\n-     * Note: the returned var handle does not perform any size or alignment check. It is up to clients\n-     * to adapt the returned var handle and insert the appropriate checks.\n+     * and a {@code long} as second argument (the offset into the segment). Both arguments are checked.\n+     * <p>\n+     * If {@code constantOffset == false}, the resulting var handle will take a third pre-validated additional\n+     * offset instead of the given fixed {@code offset}, and caller must ensure that passed additional offset,\n+     * either to the handle (such as computing through method handles) or as fixed {@code offset} here, is valid.\n@@ -324,4 +327,7 @@\n-     * @param carrier the Java carrier type.\n-     * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.\n-     * @param byteOrder the byte order.\n-     * @return the created VarHandle.\n+     * @param carrier the Java carrier type of the element\n+     * @param enclosing the enclosing layout to perform bound and alignment checks against\n+     * @param alignmentMask alignment of this accessed element in the enclosing layout\n+     * @param constantOffset if access path has a constant offset value, i.e. it has no strides\n+     * @param offset the offset value, if the offset is constant\n+     * @param byteOrder the byte order\n+     * @return the created var handle\n@@ -329,3 +335,3 @@\n-    static VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask,\n-                                             ByteOrder byteOrder) {\n-        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {\n+    static VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask,\n+                                             boolean constantOffset, long offset, ByteOrder byteOrder) {\n+        if (!carrier.isPrimitive() || carrier == void.class) {\n@@ -337,0 +343,2 @@\n+        \/\/ All carrier types must persist across MethodType erasure\n+        VarForm form;\n@@ -338,1 +346,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsBytes.selectForm(alignmentMask, constantOffset);\n@@ -340,1 +348,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsChars(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsChars.selectForm(alignmentMask, constantOffset);\n@@ -342,1 +350,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsShorts(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsShorts.selectForm(alignmentMask, constantOffset);\n@@ -344,1 +352,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsInts(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsInts.selectForm(alignmentMask, constantOffset);\n@@ -346,1 +354,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsFloats(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsFloats.selectForm(alignmentMask, constantOffset);\n@@ -348,1 +356,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsLongs(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsLongs.selectForm(alignmentMask, constantOffset);\n@@ -350,1 +358,3 @@\n-            return maybeAdapt(new VarHandleSegmentAsDoubles(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsDoubles.selectForm(alignmentMask, constantOffset);\n+        } else if (carrier == boolean.class) {\n+            form = VarHandleSegmentAsBooleans.selectForm(alignmentMask, constantOffset);\n@@ -354,0 +364,2 @@\n+\n+        return maybeAdapt(new SegmentVarHandle(form, be, enclosing, offset, exact));\n@@ -749,1 +761,1 @@\n-\/\/        record HandleType(Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n+\/\/        record HandleType(Class<?> receiver, Class<?>... intermediates) {\n@@ -769,11 +781,6 @@\n-\/\/            Stream<HandleType> hts = Stream.of(\n-\/\/                    \/\/ Object->Object\n-\/\/                    new HandleType(Object.class, Object.class),\n-\/\/                    \/\/ Object->int\n-\/\/                    new HandleType(Object.class, int.class),\n-\/\/                    \/\/ Object->long\n-\/\/                    new HandleType(Object.class, long.class),\n-\/\/                    \/\/ Object->float\n-\/\/                    new HandleType(Object.class, float.class),\n-\/\/                    \/\/ Object->double\n-\/\/                    new HandleType(Object.class, double.class),\n+\/\/            List<HandleType> hts = List.of(\n+\/\/                    \/\/ Object->T\n+\/\/                    new HandleType(Object.class),\n+\/\/\n+\/\/                    \/\/ <static>->T\n+\/\/                    new HandleType(null),\n@@ -781,10 +788,2 @@\n-\/\/                    \/\/ <static>->Object\n-\/\/                    new HandleType(null, Object.class),\n-\/\/                    \/\/ <static>->int\n-\/\/                    new HandleType(null, int.class),\n-\/\/                    \/\/ <static>->long\n-\/\/                    new HandleType(null, long.class),\n-\/\/                    \/\/ <static>->float\n-\/\/                    new HandleType(null, float.class),\n-\/\/                    \/\/ <static>->double\n-\/\/                    new HandleType(null, double.class),\n+\/\/                    \/\/ Array[index]->T\n+\/\/                    new HandleType(Object.class, int.class),\n@@ -792,10 +791,2 @@\n-\/\/                    \/\/ Array[int]->Object\n-\/\/                    new HandleType(Object.class, Object.class, int.class),\n-\/\/                    \/\/ Array[int]->int\n-\/\/                    new HandleType(Object.class, int.class, int.class),\n-\/\/                    \/\/ Array[int]->long\n-\/\/                    new HandleType(Object.class, long.class, int.class),\n-\/\/                    \/\/ Array[int]->float\n-\/\/                    new HandleType(Object.class, float.class, int.class),\n-\/\/                    \/\/ Array[int]->double\n-\/\/                    new HandleType(Object.class, double.class, int.class),\n+\/\/                    \/\/ MS[base]->T\n+\/\/                    new HandleType(Object.class, long.class),\n@@ -803,3 +794,1 @@\n-\/\/                    \/\/ Array[long]->int\n-\/\/                    new HandleType(Object.class, int.class, long.class),\n-\/\/                    \/\/ Array[long]->long\n+\/\/                    \/\/ MS[base][offset]->T\n@@ -809,2 +798,8 @@\n-\/\/            hts.flatMap(ht -> Stream.of(VarHandleTemplate.class.getMethods()).\n-\/\/                    map(m -> generateMethodType(m, ht.receiver, ht.value, ht.intermediates))).\n+\/\/            Stream.of(VarHandleTemplate.class.getMethods()).<MethodType>\n+\/\/                    mapMulti((m, sink) -> {\n+\/\/                        for (var ht : hts) {\n+\/\/                            for (var bt : LambdaForm.BasicType.ARG_TYPES) {\n+\/\/                                sink.accept(generateMethodType(m, ht.receiver, bt.btClass, ht.intermediates));\n+\/\/                            }\n+\/\/                        }\n+\/\/                    }).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":52,"deletions":57,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,1 +205,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1130,1 +1130,1 @@\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    @SuppressWarnings(\"unchecked\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -31,1 +32,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n@@ -84,1 +84,1 @@\n-    VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask, ByteOrder order);\n+    VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean constantOffset, long offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -275,1 +275,0 @@\n-        @SuppressWarnings(\"unchecked\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,3 +94,0 @@\n-  public void dumpReplayData(PrintStream out) {\n-      out.println(\"# Unknown Metadata\");\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Metadata.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,16 +359,0 @@\n-  public void dumpReplayData(PrintStream out) {\n-      NMethod nm = getNativeMethod();\n-      int code_size = 0;\n-      if (nm != null) {\n-        code_size = (int)nm.codeEnd().minus(nm.getVerifiedEntryPoint());\n-      }\n-      Klass holder = getMethodHolder();\n-      out.println(\"ciMethod \" +\n-                  nameAsAscii() + \" \" +\n-                  getInvocationCount() + \" \" +\n-                  getBackedgeCount() + \" \" +\n-                  interpreterInvocationCount() + \" \" +\n-                  interpreterThrowoutCount() + \" \" +\n-                  code_size);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-compiler\/ciReplay\/TestSAServer.java 8029528 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2546,0 +2546,10 @@\n+    public static final String MOD_F = PREFIX + \"MOD_F\" + POSTFIX;\n+    static {\n+        macroNodes(MOD_F, \"ModF\");\n+    }\n+\n+    public static final String MOD_D = PREFIX + \"MOD_D\" + POSTFIX;\n+    static {\n+        macroNodes(MOD_D, \"ModD\");\n+    }\n+\n@@ -2591,0 +2601,10 @@\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases up to and including {@link CompilePhase#BEFORE_MACRO_EXPANSION}.\n+     *\/\n+    private static void macroNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.BEFORE_MACRO_EXPANSION, regex,\n+                                                                          CompilePhase.BEFORE_STRINGOPTS,\n+                                                                          CompilePhase.BEFORE_MACRO_EXPANSION));\n+    }\n+\n@@ -2651,13 +2671,0 @@\n-    \/**\n-     * Apply a regex that matches a macro node IR node name {@code macroNodeName} exactly on all machine independent\n-     * ideal graph phases up to and including {@link CompilePhase#BEFORE_MACRO_EXPANSION}. By default, we match on\n-     * {@link CompilePhase#BEFORE_MACRO_EXPANSION} when no {@link CompilePhase} is chosen.\n-     *\/\n-    private static void macroNodes(String irNodePlaceholder, String macroNodeName) {\n-        String macroNodeRegex = START + macroNodeName + \"\\\\b\" + MID + END;\n-        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.BEFORE_MACRO_EXPANSION,\n-                                                                          macroNodeRegex,\n-                                                                          CompilePhase.BEFORE_STRINGOPTS,\n-                                                                          CompilePhase.BEFORE_MACRO_EXPANSION));\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -502,1 +502,0 @@\n-java\/awt\/FullScreen\/FullscreenWindowProps\/FullscreenWindowProps.java 8280991 linux-x64\n@@ -549,0 +548,3 @@\n+com\/sun\/management\/OperatingSystemMXBean\/GetProcessCpuLoad.java 8351002 windows-all\n+com\/sun\/management\/OperatingSystemMXBean\/GetSystemCpuLoad.java  8351002 windows-all\n+\n@@ -761,0 +763,1 @@\n+jdk\/incubator\/vector\/Long256VectorTests.java                    8350840 generic-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}