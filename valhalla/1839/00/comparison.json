{"files":[{"patch":"@@ -5958,1 +5958,7 @@\n-    \/\/ Remove the extension of the caller's frame used for inline type unpacking\n+    \/\/ The method has a scalarized entry point (where fields of value object arguments\n+    \/\/ are passed through registers and stack), and a non-scalarized entry point (where\n+    \/\/ value object arguments are given as oops). The non-scalarized entry point will\n+    \/\/ first load each field of value object arguments and store them in registers and on\n+    \/\/ the stack in a way compatible with the scalarized entry point. To do so, some extra\n+    \/\/ stack space might be reserved (if argument registers are not enough). On leaving the\n+    \/\/ method, this space must be freed.\n@@ -5960,1 +5966,1 @@\n-    \/\/ Right now the stack looks like this:\n+    \/\/ In case we used the non-scalarized entry point the stack looks like this:\n@@ -5986,1 +5992,1 @@\n-    \/\/ do unpacking.\n+    \/\/ do unpacking (from the scalarized entry point).\n@@ -5990,1 +5996,11 @@\n-    \/\/ only one copy of each.\n+    \/\/ only one copy of each. Indeed, in the case we used the scalarized calling\n+    \/\/ convention, the stack looks like this:\n+    \/\/\n+    \/\/ | Arguments from caller     |\n+    \/\/ |---------------------------|  <-- caller's SP \/ start of this method's frame\n+    \/\/ | Saved LR                  |\n+    \/\/ | Saved FP                  |\n+    \/\/ |---------------------------|  <-- FP\n+    \/\/ | sp_inc                    |\n+    \/\/ | method locals             |\n+    \/\/ |---------------------------|  <-- SP\n@@ -5997,1 +6013,1 @@\n-    \/\/ TODO 8371993 store fake values instead of LR\/FP#2\n+    \/\/ One can find sp_inc since the start the method's frame is SP + initial_framesize.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+\/\/ Beware! This sp_inc is NOT the same as the one mentioned in MacroAssembler::remove_frame but only the size\n+\/\/ of the extension space + the additional copy of the return address. That means, it doesn't contain the\n+\/\/ frame size (where the local and sp_inc are) and the saved RBP.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -659,0 +659,25 @@\n+\n+\/\/ See comment in MacroAssembler::remove_frame\n+frame::CompiledFramePointers frame::compiled_frame_details() const {\n+  \/\/ frame owned by optimizing compiler\n+  assert(_cb->frame_size() > 0, \"must have non-zero frame size\");\n+  intptr_t* sender_sp = unextended_sp() + _cb->frame_size();\n+  assert(sender_sp == real_fp(), \"\");\n+\n+  \/\/ This is the saved value of EBP which may or may not really be an FP.\n+  \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n+  \/\/ saved_fp_addr should be correct even for a bottom thawed frame (with a return barrier)\n+  intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);\n+\n+  \/\/ Repair the sender sp if the frame has been extended\n+  sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);\n+\n+  CompiledFramePointers cfp;\n+  cfp.sender_sp = sender_sp;\n+  cfp.saved_fp_addr = saved_fp_addr;\n+  \/\/ On Intel the return_address is always the word on the stack\n+  cfp.sender_pc_addr = (address*)(sender_sp - frame::return_addr_offset);\n+\n+  return cfp;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -144,0 +144,6 @@\n+  struct CompiledFramePointers {\n+    intptr_t* sender_sp;       \/\/ The top of the stack of the sender\n+    intptr_t** saved_fp_addr;  \/\/ Where RBP is saved on the stack\n+    address* sender_pc_addr;   \/\/ Where return address (copy #1 in remove_frame's comment) is saved on the stack\n+  };\n+  CompiledFramePointers compiled_frame_details() const;\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -429,30 +429,1 @@\n-\n-  \/\/ frame owned by optimizing compiler\n-  assert(_cb->frame_size() > 0, \"must have non-zero frame size\");\n-  intptr_t* sender_sp = unextended_sp() + _cb->frame_size();\n-  assert(sender_sp == real_fp(), \"\");\n-\n-#ifdef ASSERT\n-  address sender_pc_copy = (address) *(sender_sp-1);\n-#endif\n-\n-  \/\/ This is the saved value of EBP which may or may not really be an FP.\n-  \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n-  \/\/ saved_fp_addr should be correct even for a bottom thawed frame (with a return barrier)\n-  intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);\n-\n-  \/\/ Repair the sender sp if the frame has been extended\n-  sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);\n-\n-  \/\/ On Intel the return_address is always the word on the stack\n-  address sender_pc = (address) *(sender_sp-1);\n-\n-#ifdef ASSERT\n-  if (sender_pc != sender_pc_copy) {\n-    \/\/ When extending the stack in the callee method entry to make room for unpacking of value\n-    \/\/ type args, we keep a copy of the sender pc at the expected location in the callee frame.\n-    \/\/ If the sender pc is patched due to deoptimization, the copy is not consistent anymore.\n-    nmethod* nm = CodeCache::find_blob(sender_pc)->as_nmethod();\n-    assert(sender_pc == nm->deopt_handler_entry(), \"unexpected sender pc\");\n-  }\n-#endif\n+  CompiledFramePointers cfp = compiled_frame_details();\n@@ -497,1 +468,1 @@\n-    update_map_with_saved_link(map, saved_fp_addr);\n+    update_map_with_saved_link(map, cfp.saved_fp_addr);\n@@ -500,1 +471,1 @@\n-  assert(sender_sp != sp(), \"must have changed\");\n+  assert(cfp.sender_sp != sp(), \"must have changed\");\n@@ -502,1 +473,1 @@\n-  if (Continuation::is_return_barrier_entry(sender_pc)) {\n+  if (Continuation::is_return_barrier_entry(*cfp.sender_pc_addr)) {\n@@ -506,1 +477,1 @@\n-      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, cfp.sender_sp);\n@@ -510,2 +481,2 @@\n-  intptr_t* unextended_sp = sender_sp;\n-  return frame(sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  intptr_t* unextended_sp = cfp.sender_sp;\n+  return frame(cfp.sender_sp, unextended_sp, *cfp.saved_fp_addr, *cfp.sender_pc_addr);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":7,"deletions":36,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -6068,1 +6068,5 @@\n-\/\/ args and adjust the stack pointer\n+\/\/ args and adjust the stack pointer.\n+\/\/\n+\/\/ This extra stack space take into account the copy #2 of the return address,\n+\/\/ but NOT the saved RBP or the normal size of the frame (see MacroAssembler::remove_frame\n+\/\/ for notations).\n@@ -6079,0 +6083,5 @@\n+#ifdef ASSERT\n+  movl(Address(rsp, -VMRegImpl::stack_slot_size), badRegWordVal);\n+  movl(Address(rsp, -2 * VMRegImpl::stack_slot_size), badRegWordVal);\n+  subptr(rsp, 2 * VMRegImpl::stack_slot_size);\n+#else\n@@ -6080,0 +6089,1 @@\n+#endif\n@@ -6314,1 +6324,54 @@\n-    \/\/ TODO 8284443 Add a comment drawing the frame like in Aarch64's version of MacroAssembler::remove_frame\n+    \/\/ The method has a scalarized entry point (where fields of value object arguments\n+    \/\/ are passed through registers and stack), and a non-scalarized entry point (where\n+    \/\/ value object arguments are given as oops). The non-scalarized entry point will\n+    \/\/ first load each field of value object arguments and store them in registers and on\n+    \/\/ the stack in a way compatible with the scalarized entry point. To do so, some extra\n+    \/\/ stack space might be reserved (if argument registers are not enough). On leaving the\n+    \/\/ method, this space must be freed.\n+    \/\/\n+    \/\/ In case we used the non-scalarized entry point the stack looks like this:\n+    \/\/\n+    \/\/ | Arguments from caller     |\n+    \/\/ |---------------------------|  <-- caller's SP\n+    \/\/ | Return address #1         |\n+    \/\/ |---------------------------|\n+    \/\/ | Extension space for       |\n+    \/\/ |   inline arg (un)packing  |\n+    \/\/ |---------------------------|\n+    \/\/ | Return address #2         |\n+    \/\/ | Saved RBP                 |\n+    \/\/ |---------------------------|  <-- start of this method's frame\n+    \/\/ | sp_inc                    |\n+    \/\/ | method locals             |\n+    \/\/ |---------------------------|  <-- SP\n+    \/\/\n+    \/\/ There is two copies of the return address on the stack. They will be identical at\n+    \/\/ first, but that can change.\n+    \/\/ If the caller has been deoptimized, the copy #1 will be patched to point at the\n+    \/\/ deopt blob, and the copy #2 will still point into the old method. In short\n+    \/\/ the copy #2 is not reliable and should not be used. It is mostly needed to\n+    \/\/ add space between the extension space and the locals, as there would be between\n+    \/\/ the real arguments and the locals if we don't need to do unpacking (from the\n+    \/\/ scalarized entry point).\n+    \/\/\n+    \/\/ When leaving, one must use the copy #1 of the return address, while keeping in mind\n+    \/\/ that from the scalarized entry point, there will be only one copy. Indeed, in the\n+    \/\/ case we used the scalarized calling convention, the stack looks like this:\n+    \/\/\n+    \/\/ | Arguments from caller     |\n+    \/\/ |---------------------------|  <-- caller's SP\n+    \/\/ | Return address            |\n+    \/\/ | Saved RBP                 |\n+    \/\/ |---------------------------|  <-- start of this method's frame\n+    \/\/ | sp_inc                    |\n+    \/\/ | method locals             |\n+    \/\/ |---------------------------|  <-- SP\n+    \/\/\n+    \/\/ The sp_inc stack slot holds the total size of the frame, including the extension\n+    \/\/ space the possible copy #2 of the return address and the saved RBP (but never the\n+    \/\/ copy #1 of the return address). That is how to find the copy #1 of the return address.\n+    \/\/ This size is expressed in bytes. Be careful when using it from C++ in pointer arithmetic;\n+    \/\/ you might need to divide it by wordSize.\n+    \/\/\n+    \/\/ One can find sp_inc since the start the method's frame is SP + initial_framesize.\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":65,"deletions":2,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -843,2 +843,2 @@\n-jdk\/internal\/vm\/Continuation\/Fuzz.java#default 8370177 generic-aarch64\n-jdk\/internal\/vm\/Continuation\/Fuzz.java#preserve-fp 8370177 generic-aarch64\n+jdk\/internal\/vm\/Continuation\/Fuzz.java#default 8370177 generic-aarch64,generic-x64\n+jdk\/internal\/vm\/Continuation\/Fuzz.java#preserve-fp 8370177 generic-aarch64,generic-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}