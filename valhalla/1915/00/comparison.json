{"files":[{"patch":"@@ -0,0 +1,498 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * Unsigned 32-bit two's complement integers.\n+ *\n+ * @see Integer\n+ *\/\n+@jdk.internal.ValueBased\n+public final class \/*value record*\/ UnsignedInt  {\n+    \/\/ In the future, expect to add \"implements Integral<UnsignedInt>\"\n+    \/\/ (or similar).\n+    \/\/ Currently *not* extending java.lang.Number, and, for now, *not*\n+    \/\/ implementing Serializable. Might implement Comparable<UnsignedInt>.\n+\n+    \/**\n+     * The bits of the unsigned value.\n+     *\/\n+    private int value;\n+\n+    \/**\n+     * Constructs a new unsigned int.\n+     *\/\n+    private UnsignedInt(int value) {\n+        this.value = value;\n+    }\n+\n+    \/**\n+     * {@return an unsigned integer with the bits of the argument}\n+     *\n+     * @param x the argument\n+     *\/\n+    public static UnsignedInt valueOf(int x) {\n+        return new UnsignedInt(x);\n+    }\n+\n+    \/**\n+     * {@return an unsigned integer with the bits of the argument if\n+     * the argument is zero or positive}\n+     *\n+     * @param x the argument\n+     * @throws ArithmeticException if the argument as an {@code int} is negative\n+     *\/\n+    public static UnsignedInt valueOfExact(int x) {\n+        if (x < 0) {\n+            throw new ArithmeticException(\"Attempt to convert negative value to unsigned\");\n+        }\n+        return new UnsignedInt(x);\n+    }\n+\n+    \/**\n+     * {@return the result of parsing the string as an unsigned\n+     * integer} Base 10 is used as the implicit radix.\n+     *\n+     * @implSpec\n+     * The same grammar of strings is recognized by this method as by\n+     * {@link Integer#parseUnsignedInt(String)}.\n+     *\n+     * @param s the argument\n+     * @throws    NumberFormatException  if the string does not contain a\n+     *            parsable unsigned integer.\n+     * @see Integer#parseUnsignedInt(String)\n+     *\/\n+    public static UnsignedInt valueOf(String s) throws NumberFormatException {\n+        return new UnsignedInt(Integer.parseUnsignedInt(s));\n+    }\n+\n+    \/**\n+     * {@return the result of parsing the string as an unsigned\n+     * integer in the specified radix}\n+     *\n+     * @implSpec\n+     * The same grammar of strings is recognized by this method as by\n+     * {@link Integer#parseUnsignedInt(String, int)}.\n+     *\n+     * @param      s   the string to be parsed.\n+     * @param      radix the radix to be used in interpreting {@code s}\n+     * @throws    NumberFormatException if the {@code String}\n+     *            does not contain a parsable unsigned integer.\n+     * @see Integer#parseUnsignedInt(String, int)\n+     *\/\n+    public static UnsignedInt valueOf(String s, int radix) throws NumberFormatException {\n+        return new UnsignedInt(Integer.parseUnsignedInt(s, radix));\n+    }\n+\n+    \/**\n+     * {@return a string representing the unsigned value}\n+     *\/\n+    @Override\n+    public String toString() {\n+        return toString(this);\n+    }\n+\n+    \/**\n+     * {@return a string representing the unsigned argument}\n+     *\n+     * @implSpec\n+     * The method behaves as if the argument were passed to {@link\n+     * Integer#toUnsignedString(int)}.\n+     *\n+     * @param x the unsigned integer to be represented\n+     * @see Integer#toUnsignedString(int)\n+     *\/\n+    public static String toString(UnsignedInt x) {\n+        return Integer.toUnsignedString(x.value);\n+    }\n+\n+    \/**\n+     * {@return a string representing the unsigned argument in the\n+     * specified radix}\n+     *\n+     * @implSpec\n+     * The method behaves as if the arguments were passed to {@link\n+     * Integer#toUnsignedString(int, int)}.\n+     *\n+     * @param x the unsigned integer to be represented\n+     * @param radix the radix to use in the string representation\n+     * @see Integer#toUnsignedString(int, int)\n+     *\/\n+    public static String toString(UnsignedInt x, int radix) {\n+        return Integer.toUnsignedString(x.value, radix);\n+    }\n+\n+    \/**\n+     * {@return the bits of this unsigned integer as an {@code int}}\n+     *\/\n+    public int intValue() {\n+        return this.value;\n+    }\n+\n+    \/**\n+     * {@return the value of this unsigned integer as a {@code long}}\n+     *\n+     * @see Integer#toUnsignedLong(int)\n+     *\/\n+    public long longValue() {\n+        return Integer.toUnsignedLong(this.value);\n+    }\n+\n+    \/\/ Arithmetic operators\n+\n+    \/**\n+     * Addition operation, binary \"{@code +}\".\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\/\n+    public static UnsignedInt add(UnsignedInt addend, UnsignedInt augend) {\n+        \/\/ signed and unsigned addition is the same for 2's complement\n+        return valueOf(addend.value + augend.value);\n+    }\n+\n+    \/**\n+     * Subtraction operation, binary \"{@code -}\".\n+     *\n+     * @param minuend the first operand\n+     * @param subtrahend the second operand\n+     * @return the difference of the operands\n+     *\/\n+    public static UnsignedInt subtract(UnsignedInt minuend, UnsignedInt subtrahend) {\n+        \/\/ signed and unsigned subtraction is the same for 2's complement\n+        return valueOf(minuend.value - subtrahend.value);\n+    }\n+\n+    \/**\n+     * Multiplication operation, \"{@code *}\".\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\/\n+    public static UnsignedInt multiply(UnsignedInt multiplier,\n+                                       UnsignedInt multiplicand) {\n+        \/\/ signed and unsigned multiply is the same for 2's complement\n+        return valueOf(multiplier.value * multiplicand.value);\n+    }\n+\n+    \/**\n+     * Division operation, \"{@code \/}\".\n+     *\n+     * @param dividend the value to be divided\n+     * @param divisor the value being divided by\n+     * @return the unsigned quotient of the first argument divided by\n+     * the second argument\n+     * @throws ArithmeticException if the divisor is zero\n+     * @see Integer#divideUnsigned(int, int)\n+     *\/\n+    public static UnsignedInt divide(UnsignedInt dividend,\n+                                     UnsignedInt divisor) {\n+        return valueOf(Integer.divideUnsigned(dividend.value, divisor.value));\n+    }\n+\n+    \/**\n+     * Remainder operation, \"{@code %}\".\n+     *\n+     * @param dividend the value to be divided to compute the remainder\n+     * @param divisor the value being divided by\n+     * @return the unsigned remainder of the first argument divided by\n+     * the second argument\n+     * @throws ArithmeticException if the divisor is zero\n+     * @see Integer#remainderUnsigned(int, int)\n+     *\/\n+    public static UnsignedInt remainder(UnsignedInt dividend,\n+                                        UnsignedInt divisor) {\n+        return valueOf((Integer.remainderUnsigned(dividend.value, divisor.value)));\n+    }\n+\n+    \/\/ TODO: API decision, is this method needed?\n+\n+    \/**\n+     * Unary plus operation, \"{@code +}\".\n+     *\n+     * @param operand the operand\n+     * @return unary plus of the operand\n+     *\/\n+    public static UnsignedInt plus(UnsignedInt operand) {\n+        return operand;\n+    }\n+\n+    \/\/ TODO: API discussion, is this method needed?\n+    \/\/\n+    \/\/ If there is a single interface defining the operations over\n+    \/\/ integral types, negation should be defined over unsigned\n+    \/\/ values. If there are separate interfaces for signed and\n+    \/\/ unsigned integral types, the negate method can be elided on\n+    \/\/ unsigned types.\n+\n+    \/**\n+     * Negation operation, unary \"{@code -}\".\n+     * Unconditionally throws {@code UnsupportedOperationException}.\n+     *\n+     * @param operand the operand\n+     * @return the negation of the operand\n+     * @throws UnsupportedOperationException for all inputs\n+     *\/\n+    public static UnsignedInt negate(UnsignedInt operand) {\n+        \/\/ What does negating an unsigned int do in C?\n+        \/\/ From the draft C standard 6.5.3:\n+        \/\/\n+        \/\/ \"The result of the unary - operator is the negative of its\n+        \/\/ (promoted) operand. The integer promotions are performed on\n+        \/\/ the operand, and the result has the promoted type.\"\n+\n+        \/\/ Could special case 0?\n+        throw new UnsupportedOperationException(\"Cannot negate unsigned value\");\n+    }\n+\n+    \/**\n+     * Compares two unsigned int values numerically.\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     * @return the value {@code 0} if {@code x == y};\n+     *         a value less than {@code 0} if {@code x < y}; and\n+     *         a value greater than {@code 0} if {@code x > y}\n+     * @see Integer#compareUnsigned(int, int)\n+     *\/\n+    public static int compare(UnsignedInt x, UnsignedInt y) {\n+        return Integer.compareUnsigned(x.value, y.value);\n+    }\n+\n+\/\/     \/**\n+\/\/      * {@return lorem ipsum}\n+\/\/      *\n+\/\/      * @param y the argument to compare to\n+\/\/      * @see Integer#compareUnsigned(int, int)\n+\/\/      *\/\n+\/\/     @Override\n+\/\/     public int compareTo(UnsignedInt y) {\n+\/\/         return compare(this, y);\n+\/\/     }\n+\n+    \/\/ TODO: replace ordered comparison implementations with better code\n+    \/\/ from \"Hackers Delight\" or similar.\n+\n+    \/\/ Integral-specific operations\n+    \/\/ and, or, xor, complement, leftShift, rightShift, rightShift unsigned...\n+\n+    \/\/ OrderedComparison\n+    \/\/ min, max, lessThan, lessThanEqual, greaterThan, greaterThanEqual,\n+\n+    \/\/ Ordered comparison operators\n+\n+    \/**\n+     * {@return {@code true} if the first argument is less than the\n+     * second argument and {@code false} otherwise}\n+     *\n+     * The method corresponds to the less than operator, \"{@code <}\".\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static boolean lessThan(UnsignedInt x, UnsignedInt y) {\n+        return compare(x, y) < 0;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the first argument is less than or\n+     * equal to the second argument and {@code false} otherwise}\n+     *\n+     * The method corresponds to the less than or equal to operator,\n+     * \"{@code <=}\".\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static boolean lessThanEqual(UnsignedInt x, UnsignedInt y) {\n+        return compare(x, y) <= 0;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the first argument is greater than the\n+     * second argument and {@code false} otherwise}\n+     *\n+     * The method corresponds to the less than operator, \"{@code >}\".\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static boolean greaterThan(UnsignedInt x, UnsignedInt y) {\n+        return compare(x, y) > 0;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the first argument is greater than or\n+     * equal to the second argument and {@code false} otherwise}\n+     *\n+     * The method corresponds to the greater than or equal to operator,\n+     * \"{@code >=}\".\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static boolean greaterThanEqual(UnsignedInt x, UnsignedInt y) {\n+        return compare(x, y) >= 0;\n+    }\n+\n+    \/**\n+     * {@return the smaller of the two arguments}.  If the arguments\n+     * have the same value, the result is that same value.\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static UnsignedInt min(UnsignedInt x, UnsignedInt y) {\n+        return (compare(x, y) <= 0) ? x : y;\n+    }\n+\n+    \/**\n+     * {@return the larger of the two arguments}.  If the arguments\n+     * have the same value, the result is that same value.\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static UnsignedInt max(UnsignedInt x, UnsignedInt y) {\n+        return (compare(x, y) >= 0) ? x : y;\n+    }\n+\n+    \/\/ Bit-wise operators\n+\n+    \/**\n+     * {@return the bit-wise AND of the arguments}\n+     *\n+     * The method corresponds to the AND operator, \"{@code &}\".\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static UnsignedInt and(UnsignedInt x, UnsignedInt y) {\n+        return valueOf(x.value & y.value);\n+    }\n+\n+    \/**\n+     * {@return the bit-wise OR of the arguments}\n+     *\n+     * The method corresponds to the OR operator, \"{@code |}\".\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static UnsignedInt or(UnsignedInt x, UnsignedInt y) {\n+        return valueOf(x.value | y.value);\n+    }\n+\n+    \/**\n+     * {@return the bit-wise XOR of the arguments}\n+     *\n+     * The method corresponds to the XOR operator, \"{@code ^}\".\n+     *\n+     * @param x the first argument\n+     * @param y the second argument\n+     *\/\n+    public static UnsignedInt xor(UnsignedInt x, UnsignedInt y) {\n+        return valueOf(x.value ^ y.value);\n+    }\n+\n+    \/**\n+     * {@return the bit-wise complement of the argument}\n+     *\n+     * The method corresponds to the complement operator, \"{@code ~}\".\n+     *\n+     * @param x the argument\n+     *\/\n+    public static UnsignedInt complement(UnsignedInt x) {\n+        return valueOf(~x.value);\n+    }\n+\n+    \/\/ Shift Operators\n+\n+    \/\/ Per the JLS, the shiftDistance is AND-ed with a 5 or 6 bit mask\n+    \/\/ (for int and long value being shifted, respectively) so the\n+    \/\/ distance always non-negative.\n+\n+    \/**\n+     * {@return the first operand left shifted by the distance\n+     * indicated by the second operand, operator \"{@code <<\"}}\n+     *\n+     * Only the value of the five low-order bits of the shift distance\n+     * argument are taken into account in determining the shift\n+     * distance.\n+     *\n+     * The method corresponds to the shift left operator, \"{@code <<}\".\n+     *\n+     * @param x the value to be shifted\n+     * @param shiftDistance number of bits to shift\n+     * @jls 15.19 Shift Operators\n+     *\/\n+    public static UnsignedInt shiftLeft(UnsignedInt x, int shiftDistance) {\n+        return valueOf(x.value << shiftDistance);\n+    }\n+\n+    \/**\n+     * {@return the first operand right shifted by the distance\n+     * indicated by the second operand}\n+     *\n+     * This method corresponds to the shift right operator, \"{@code >>}\".\n+     *\n+     * Note: since this the is unsigned, semantically a (signed) right\n+     * shift is equivalent to an <em>unsigned<\/em> right shift.\n+     *\n+     * <p>Only the value of the five low-order bits of the shift distance\n+     * argument are taken into account in determining the shift\n+     * distance.\n+     *\n+     * @param x the value to be shifted\n+     * @param shiftDistance number of bits to shift\n+     * @jls 15.19 Shift Operators\n+     *\/\n+    public static UnsignedInt shiftRight(UnsignedInt x, int shiftDistance) {\n+        \/\/ Shifts of an unsigned value are always unsigned; use >>> *not* >>.\n+        return valueOf(x.value >>> shiftDistance);\n+    }\n+\n+    \/**\n+     * {@return the first operand right shifted (unsigned) by the distance\n+     * indicated by the second operand}\n+     *\n+     * This method corresponds to the shift right unsigned operator, \"{@code >>>}\".\n+     *\n+     * <p>Only the value of the five low-order bits of the shift distance\n+     * argument are taken into account in determining the shift\n+     * distance.\n+     *\n+     * @param x the value to be shifted\n+     * @param shiftDistance  number of bits to shift\n+     * @jls 15.19 Shift Operators\n+     *\/\n+    public static UnsignedInt shiftRightUnsigned(UnsignedInt x, int shiftDistance) {\n+        \/\/ Shifts of an unsigned value are always unsigned; use >>> *not* >>.\n+        return valueOf(x.value >>> shiftDistance);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/UnsignedInt.java","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"}]}