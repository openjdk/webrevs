{"files":[{"patch":"@@ -768,2 +768,1 @@\n-        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n-        return nm != null && nm.nullMarker() == NullMarker.NULLABLE;\n+        return getNullMarker() == NullMarker.NULLABLE;\n@@ -773,2 +772,1 @@\n-        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n-        return nm != null && nm.nullMarker() == NullMarker.NOT_NULL;\n+        return getNullMarker() == NullMarker.NOT_NULL;\n@@ -778,2 +776,1 @@\n-        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n-        return nm != null && nm.nullMarker() == NullMarker.PARAMETRIC;\n+        return getNullMarker() == NullMarker.PARAMETRIC;\n@@ -783,1 +780,7 @@\n-        return getMetadata(TypeMetadata.NullMarker.class) == null;\n+        return getNullMarker() == NullMarker.UNSPECIFIED;\n+    }\n+\n+    public NullMarker getNullMarker() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null ?\n+                nm.nullMarker() : NullMarker.UNSPECIFIED;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-            } else if (isSubtype(t, s, capture)) {\n+            } else if (isSubtype(t, s, capture, warn)) {\n@@ -1089,0 +1089,8 @@\n+    public boolean isSubtype(Type t, Type s, boolean capture, Warner warner) {\n+        try {\n+            pushWarner(warner);\n+            return isSubtype(t, s, capture);\n+        } finally {\n+            popWarner();\n+        }\n+    }\n@@ -1091,2 +1099,2 @@\n-            if (allowNullRestrictedTypes) {\n-                new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+            if (allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                warnStack.head.warn(LintCategory.NULL);\n@@ -1120,2 +1128,2 @@\n-        private IsSubtype isSubtype = new IsSubtype();\n-        class IsSubtype extends TypeRelation {\n+        private TypeRelation isSubtype = new TypeRelation()\n+        {\n@@ -1213,2 +1221,2 @@\n-                if (result && allowNullRestrictedTypes) {\n-                    new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n@@ -1257,47 +1265,1 @@\n-        }\n-\n-        public class NullabilityComparator extends TypeRelation {\n-            BiFunction<Type, Type, Boolean> differentNullability;\n-\n-            NullabilityComparator(BiFunction<Type, Type, Boolean> differentNullability) {\n-                this.differentNullability = differentNullability;\n-            }\n-\n-            @Override\n-            public Boolean visitType(Type t, Type s) {\n-                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n-                if (differentNullability.apply(t, s)) {\n-                    warner.warn(LintCategory.NULL);\n-                    return true;\n-                } else {\n-                    return false;\n-                }\n-            }\n-\n-            @Override\n-            public Boolean visitClassType(ClassType t, Type s) {\n-                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n-                if (differentNullability.apply(t, s)) {\n-                    warner.warn(LintCategory.NULL);\n-                    return true;\n-                } else {\n-                    return s != null && (!s.isParameterized() || compareTypeArgsRecursive(t, s))\n-                            && visit(t.getEnclosingType(), s.getEnclosingType());\n-                }\n-            }\n-            \/\/ where\n-            boolean compareTypeArgsRecursive(Type t, Type s) {\n-                return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n-            }\n-\n-            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n-                while (ts.nonEmpty() && ss.nonEmpty()) {\n-                    if (visit(ts.head, ss.head)) {\n-                        return true;\n-                    }\n-                    ts = ts.tail;\n-                    ss = ss.tail;\n-                }\n-                return false;\n-            }\n-        }\n+        };\n@@ -1493,2 +1455,2 @@\n-                if (equal && allowNullRestrictedTypes) {\n-                    new NullabilityComparator((t1, t2) -> !hasSameNullability(t1, t2)).visit(s, t);\n+                if (equal && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n@@ -5432,8 +5394,2 @@\n-        if (s == null) {\n-            return t.isNullUnspecified();\n-        }\n-        if (t.isNullUnspecified()) {\n-            return s.isNullUnspecified();\n-        }\n-        if (t.isNonNullable()) {\n-            return s.isNonNullable();\n+        if (s == null || t == null || t.isNullUnspecified() || s.isNullUnspecified()) {\n+            return true;\n@@ -5441,1 +5397,1 @@\n-        throw new AssertionError(\"shouldn't get here\");\n+        return t.getNullMarker() == s.getNullMarker();\n@@ -5445,1 +5401,1 @@\n-     * Does t has narrower nullability than s?\n+     * Does t have narrower nullability than s?\n@@ -5448,2 +5404,2 @@\n-        if (t.isNonNullable()) {\n-            return s != null && !s.isNonNullable();\n+        if (s == null || t == null || t.isNullUnspecified() || s.isNullUnspecified()) {\n+            return false;\n@@ -5451,1 +5407,1 @@\n-        return false;\n+        return t.getNullMarker().ordinal() < s.getNullMarker().ordinal();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":25,"deletions":69,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1370,7 +1370,8 @@\n-                if ((result.isNonNullable() || elemOrType.isNonNullable()) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor())) {\n-                    log.error(tree.pos(),\n-                            types.elemtype(result) == null?\n-                                    Errors.TypeCantBeNullRestricted(result) :\n-                                    Errors.TypeCantBeNullRestricted2(result)\n-                    );\n-                }\n+\/\/                @@@ Maybe guard with flag?\n+\/\/                if ((result.isNonNullable() || elemOrType.isNonNullable()) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor())) {\n+\/\/                    log.error(tree.pos(),\n+\/\/                            types.elemtype(result) == null?\n+\/\/                                    Errors.TypeCantBeNullRestricted(result) :\n+\/\/                                    Errors.TypeCantBeNullRestricted2(result)\n+\/\/                    );\n+\/\/                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-        this.allowNullRestrictedTypes = (!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n-                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n+        this.allowNullRestrictedTypes = true; \/*(!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);*\/\n@@ -712,4 +712,0 @@\n-        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n-            setNullMarker(t);\n-            nextToken();\n-        }\n@@ -1190,1 +1186,1 @@\n-                    if (allowNullRestrictedTypes && token.kind == QUES && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                    if (allowNullRestrictedTypes && token.kind == QUES) {\n@@ -1381,1 +1377,0 @@\n-        boolean emotionalMarkersOK = false;\n@@ -1524,1 +1519,0 @@\n-                    emotionalMarkersOK = true;\n@@ -1679,10 +1673,0 @@\n-            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (token.kind == QUES || token.kind == BANG || (token.kind == STAR))) {\n-                if (peekToken(LBRACKET) || peekToken(LT) || emotionalMarkersOK) {\n-                    selectTypeMode();\n-                    setNullMarker(t);\n-                    nextToken();\n-                } else {\n-                    \/\/ not a type\n-                    break;\n-                }\n-            }\n@@ -2180,1 +2164,1 @@\n-    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG || (t == QUES && !isMode(NOQUES)) || t == STAR;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -239,0 +239,2 @@\n+compiler.err.type.cant.be.null.restricted\n+compiler.err.type.cant.be.null.restricted.2\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.type.cant.be.null.restricted\n-\/\/ key: compiler.err.type.cant.be.null.restricted.2\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n-\n-public class CantBeNonNullableType {\n-    String! s;\n-    String[]! sa;\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantBeNonNullableType.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @compile NullabilityParsingTest.java\n+ * @compile NullabilityParsingBangTest.java\n@@ -34,1 +34,0 @@\n-import java.util.*;\n@@ -36,1 +35,1 @@\n-class NullabilityParsingTest {\n+class NullabilityParsingBangTest {\n@@ -81,1 +80,1 @@\n-\/*        switch (o) {\n+        switch (o) {\n@@ -85,1 +84,1 @@\n-        }*\/\n+        }\n@@ -158,1 +157,1 @@\n-\/*\n+\n@@ -162,1 +161,1 @@\n-*\/\n+\n@@ -179,1 +178,1 @@\n-\/*        switch (o) {\n+        switch (o) {\n@@ -182,1 +181,1 @@\n-        }*\/\n+        }\n@@ -186,1 +185,1 @@\n-\/*        switch (o) {\n+        switch (o) {\n@@ -189,1 +188,1 @@\n-        }*\/\n+        }\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingBangTest.java","additions":11,"deletions":12,"binary":false,"changes":23,"previous_filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary Smoke test for parsing of bang types\n+ * @compile -XDenableNullRestrictedTypes NullabilityParsingQuesTest.java\n+ *\/\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+class NullabilityParsingQuesTest {\n+    static value class Point { public implicit Point(); }\n+    static value class Shape { public implicit Shape(); }\n+    \/\/ fields\n+    Point? o2;\n+\n+    \/\/ method parameters\n+    void m2(Point? o) { }\n+\n+    \/\/ method returns\n+    Point? m2() { return new Point(); }\n+\n+    \/\/ locals\n+    void testLocals() {\n+        Point? o2;\n+    }\n+\n+    \/\/ generics - field\n+    Consumer<Point?> co2;\n+\n+    \/\/ generics - method param\n+    void m4(Consumer<Point?> co) { }\n+\n+    \/\/ generics - method return\n+    Consumer<Point?> m4() { return null; }\n+\n+    \/\/ generics - local\n+    void testGenericLocals() {\n+        Consumer<Point?> co2;\n+    }\n+\n+    \/\/ lambdas\n+    void testLambdas() {\n+        Consumer<Point?> co2 = (Point? co) -> {};\n+    }\n+\n+    void testGenericLambdas() {\n+        Consumer<Consumer<Point?>> co2 = (Consumer<Point?> co) -> {};\n+        Consumer<Function<Point?, Point?>> co3 = (Function<Point?, Point?> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Point?>>>> co6 = (Consumer<Consumer<Consumer<Point?>>> co) -> {};\n+    }\n+\n+    \/\/ type test patterns\n+\n+    void testTypeTestPatterns(Object o) {\n+        switch (o) {\n+            case Point? i -> throw new AssertionError();\n+            case Shape? s -> throw new AssertionError();\n+            default -> throw new AssertionError();\n+        }\n+    }\n+\n+    sealed interface I<X> {}\n+    final class A implements I<Point> { }\n+\n+    void genericTypeTestPatterns(A o) {\n+        switch (o) {\n+            case I<Point?> i -> { }\n+        }\n+    }\n+\n+    sealed interface I2<X> {}\n+    final class A2 implements I2<I<Point>> { }\n+\n+    void genericTypeTestPatterns(A2 o) {\n+        switch (o) {\n+            case I2<I<Point?>> i -> { }\n+        }\n+    }\n+\n+    sealed interface I3<X> {}\n+    final class A3 implements I3<I2<I<Point>>> { }\n+\n+    void genericTypeTestPatterns(A3 o) {\n+        switch (o) {\n+            case I3<I2<I<Point?>>> i -> { }\n+        }\n+    }\n+\n+    \/\/ record patterns\n+\n+    record R(A a) { }\n+\n+    void genericRecordPatterns(R o) {\n+        switch (o) {\n+            case R?(I<Point?> i) -> { }\n+        }\n+    }\n+\n+    record R2(A2 a2) { }\n+\n+    void genericRecordPatterns(R2 o) {\n+        switch (o) {\n+            case R2?(I2<I<Point?>> i) -> { }\n+        }\n+    }\n+\n+    record R3(A3 a3) { }\n+\n+    void genericRecordPatterns(R3 o) {\n+        switch (o) {\n+            case R3?(I3<I2<I<Point?>>> i) -> { }\n+        }\n+    }\n+\n+    \/\/ instanceof\/cast\n+\n+    void testInstanceOf(Object o) {\n+        boolean r2 = o instanceof Point?;\n+    }\n+\n+    void testInstanceRecord(R r) {\n+        boolean r2 = r instanceof R(I<Point?> i);\n+    }\n+\n+    void testCast(Object o) {\n+        Point? s2 = (Point?)o;\n+    }\n+\n+    void testGenericCast(A a) {\n+        I<Point?> i2 = (I<Point?>)a;\n+    }\n+\n+    void testGenericCast2(A a) {\n+        I<Point?> i2 = (I<Point?>)a;\n+    }\n+\n+    \/\/ arrays\n+\n+    Point?[]?[]?[]? oarr;\n+    Function<Point?[]?[]?, Function<Point?[]?[]?, Point?[]?[]?>>[][] garr;\n+\n+    void mBad1(Object o) {\n+        Point s1 = o instanceof Point ? (Point)o : null;\n+        Point s2 = o instanceof Point? ? (Point)o : null;\n+    }\n+\n+    void mBad2(Object o) {\n+        Point s1 = o instanceof Point ? null : null;\n+        Point s2 = o instanceof Point? ? null : null;\n+    }\n+\n+    void testPatternRule(Object o) {\n+        switch (o) {\n+            case Point? s -> { }\n+                default -> { }\n+        }\n+    }\n+\n+    void testPatternCol(Object o) {\n+        switch (o) {\n+            case Point? s: { }\n+            default: { }\n+        }\n+    }\n+\n+    void testInstanceOfAndInfix1(Object a, boolean b) {\n+        boolean x2 = a instanceof Point? && b;\n+    }\n+\n+    void testInstanceOfAndInfix2(Object a, boolean b) {\n+        boolean x2 = a instanceof Point? s && b;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingQuesTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"}]}