{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -686,2 +686,2 @@\n-     * {@return {@code true} if this {@code Class} object represents an identity\n-     * class or interface; otherwise {@code false}}\n+     * {@return {@code true} if this {@code Class} object represents an identity class;\n+     * otherwise {@code false}}\n@@ -689,3 +689,2 @@\n-     * If this {@code Class} object represents an array type, then this method\n-     * returns {@code true}.\n-     * If this {@code Class} object represents a primitive type, or {@code void},\n+     * If this {@code Class} object represents an array type then this method returns {@code true}.\n+     * If this {@code Class} object represents an interface, a primitive type, or {@code void}\n@@ -694,0 +693,1 @@\n+     * @see AccessFlag#IDENTITY\n@@ -700,2 +700,3 @@\n-     * {@return {@code true} if this {@code Class} object represents a value\n-     * class; otherwise {@code false}}\n+     * {@return {@code true} if this {@code Class} object represents a value class;\n+     * otherwise {@code false}}\n+     * All classes that are not {@linkplain #isIdentity identity classes} are value classes.\n@@ -703,2 +704,3 @@\n-     * If this {@code Class} object represents an array type, an interface,\n-     * a primitive type, or {@code void}, then this method returns {@code false}.\n+     * If this {@code Class} object represents an array type then this method returns {@code false}.\n+     * If this {@code Class} object represents an interface, a primitive type, or {@code void},\n+     * then this method returns {@code true}.\n@@ -706,0 +708,1 @@\n+     * @see AccessFlag#IDENTITY\n@@ -710,6 +713,1 @@\n-        if (!PreviewFeatures.isEnabled()) {\n-            return false;\n-        }\n-         if (isPrimitive() || isArray() || isInterface())\n-             return false;\n-        return ((getModifiers() & Modifier.IDENTITY) == 0);\n+        return PreviewFeatures.isEnabled() ? !isIdentity() : false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -599,1 +599,1 @@\n-            return cls.isValue() && cls.accessFlags().contains(AccessFlag.FINAL);\n+            return cls.isValue() && cls.accessFlags().contains(AccessFlag.FINAL) && !cls.isPrimitive();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,4 +38,2 @@\n- * reference-equality for {@linkplain Class#isIdentity() identity objects} and\n- * substutitability for {@linkplain Class#isValue value objects}\n- * in place of object-equality when comparing keys (and\n- * values).  In other words, in an {@code IdentityHashMap}, two keys\n+ * `==` in place of object-equality when comparing keys (and values).\n+ * In other words, in an {@code IdentityHashMap}, two keys\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -183,2 +182,2 @@\n-    * {@return {@code true} if the specified object reference is an identity object,\n-    * otherwise {@code false}}\n+    * {@return {@code true} if the object is a non-null reference\n+    * to an {@linkplain Class#isIdentity() identity object}, otherwise {@code false}}\n@@ -186,2 +185,10 @@\n-    * @param obj an object\n-    * @throws NullPointerException if {@code obj} is {@code null}\n+    * @apiNote\n+    * If the parameter is {@code null}, there is no object\n+    * and hence no class to check for identity; the return is {@code false}.\n+    * To test for a {@linkplain Class#isValue() value object} use:\n+    * {@snippet type=\"java\" :\n+    *     if (obj != null && !Objects.hasIdentity(obj)) {\n+    *         \/\/ obj is a non-null value object\n+    *     }\n+    * }\n+    * @param obj an object or {@code null}\n@@ -193,3 +200,14 @@\n-        requireNonNull(obj);\n-        return obj.getClass().isIdentity() ||  \/\/ Before Valhalla all classes are identity classes\n-                obj.getClass() == Object.class;\n+        return (obj == null) ? false : obj.getClass().isIdentity();\n+    }\n+\n+   \/**\n+    * {@return {@code true} if the object is a non-null reference\n+    * to an {@linkplain Class#isValue() value object}, otherwise {@code false}}\n+    *\n+    * @param obj an object or {@code null}\n+    * @since Valhalla\n+    *\/\n+   @PreviewFeature(feature = PreviewFeature.Feature.VALUE_OBJECTS)\n+\/\/    @IntrinsicCandidate\n+    public static boolean isValueObject(Object obj) {\n+        return (obj == null) ? false : obj.getClass().isValue();\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.Reference;\n@@ -34,1 +33,0 @@\n-import java.util.function.Function;\n@@ -130,1 +128,1 @@\n- *          Keys that are {@linkplain Class#isValue() value objects} do not have identity\n+ *          Objects that are {@linkplain Class#isValue() value objects} do not have identity\n@@ -309,0 +307,2 @@\n+     * The key may be a value object, but it will never be equal to the referent\n+     * so does not need a separate Objects.hasIdentity check.\n@@ -311,3 +311,0 @@\n-        \/\/ only identity objects can be compared to a reference\n-        if (!Objects.hasIdentity(key))\n-            return false;\n@@ -480,1 +477,1 @@\n-     * @throws IdentityException if the {@code key} is a value object\n+     * @throws IdentityException if {@code key} is a value object\n@@ -484,1 +481,1 @@\n-        Objects.hasIdentity(k);\n+        Objects.requireIdentity(k);\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-                                        \"public abstract interface java.util.Map<K,V>\"),\n+                                        \"public abstract value interface java.util.Map<K,V>\"),\n@@ -144,1 +144,1 @@\n-@ExpectedGenericString(\"abstract interface AnInterface\")\n+@ExpectedGenericString(\"abstract value interface AnInterface\")\n@@ -147,1 +147,1 @@\n-@ExpectedGenericString(\"abstract interface LocalMap<K,V>\")\n+@ExpectedGenericString(\"abstract value interface LocalMap<K,V>\")\n@@ -205,1 +205,1 @@\n-@ExpectedGenericString(\"abstract sealed interface SealedRootIntf\")\n+@ExpectedGenericString(\"abstract sealed value interface SealedRootIntf\")\n@@ -244,1 +244,1 @@\n-    @ExpectedGenericString(\"public abstract static sealed interface SealedRootIntf$IntfA\")\n+    @ExpectedGenericString(\"public abstract static sealed value interface SealedRootIntf$IntfA\")\n@@ -250,1 +250,1 @@\n-    @ExpectedGenericString(\"public abstract static non-sealed interface SealedRootIntf$IntfB\")\n+    @ExpectedGenericString(\"public abstract static non-sealed value interface SealedRootIntf$IntfB\")\n","filename":"test\/jdk\/java\/lang\/Class\/GenericStringTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -54,1 +55,0 @@\n-\n@@ -56,0 +56,1 @@\n+\n@@ -73,0 +74,12 @@\n+\n+    \/**\n+     * Check that queries with a value object return false or null.\n+     *\/\n+    @Test\n+    void checkValueObjectGet() {\n+        WeakHashMap<Object, Object> whm = new WeakHashMap<>();\n+        Object key = \"X\";\n+        Object v = new Foo(1);\n+        assertEquals(whm.get(v), null, \"Get of value object should return null\");\n+        assertEquals(whm.containsKey(v), false, \"containsKey should return false\");\n+    }\n","filename":"test\/jdk\/java\/util\/WeakHashMapValues.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Optional;\n@@ -34,0 +35,1 @@\n+import java.util.function.Function;\n@@ -35,0 +37,2 @@\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n@@ -115,0 +119,1 @@\n+    \/\/ Instances to test, classes of each instance are tested too\n@@ -116,0 +121,1 @@\n+        Function<String, String> lambda1 = (a) -> \"xyz\";\n@@ -117,1 +123,2 @@\n-                Arguments.of(new Object(), true, false),\n+                Arguments.of(lambda1, true, false),         \/\/ a lambda (Identity for now)\n+                Arguments.of(new Object(), true, false),    \/\/ java.lang.Object\n@@ -119,2 +126,0 @@\n-                Arguments.of(String.class, true, false),\n-                Arguments.of(Object.class, true, false),\n@@ -131,0 +136,19 @@\n+    \/\/ Classes to test\n+    static Stream<Arguments> classesData() {\n+        return Stream.of(\n+                Arguments.of(int.class, false, true),       \/\/ Fabricated primitive classes\n+                Arguments.of(long.class, false, true),\n+                Arguments.of(short.class, false, true),\n+                Arguments.of(byte.class, false, true),\n+                Arguments.of(float.class, false, true),\n+                Arguments.of(double.class, false, true),\n+                Arguments.of(char.class, false, true),\n+                Arguments.of(void.class, false, true),\n+                Arguments.of(String.class, true, false),\n+                Arguments.of(Object.class, true, false),\n+                Arguments.of(Function.class, false, true),  \/\/ Interface\n+                Arguments.of(Optional.class, false, true),  \/\/ Concrete value classes...\n+                Arguments.of(Character.class, false, true)\n+        );\n+    }\n+\n@@ -135,0 +159,1 @@\n+        assertEquals(identityClass, Objects.hasIdentity(obj), \"Objects.hasIdentity(\" + obj + \")\");\n@@ -136,5 +161,3 @@\n-        if (clazz == Object.class) {\n-            assertTrue(Objects.hasIdentity(obj), \"Objects.hasIdentity()\");\n-        } else {\n-            assertEquals(identityClass, Objects.hasIdentity(obj), \"Objects.hasIdentity()\");\n-        }\n+        \/\/ Run tests on the class\n+        classTests(clazz, identityClass, valueClass);\n+    }\n@@ -142,1 +165,4 @@\n-        assertEquals(identityClass, clazz.isIdentity(), \"Class.isIdentity()\");\n+    @ParameterizedTest\n+    @MethodSource(\"classesData\")\n+    public void classTests(Class<?> clazz, boolean identityClass, boolean valueClass) {\n+        assertEquals(identityClass, clazz.isIdentity(), \"Class.isIdentity(): \" + clazz);\n@@ -144,1 +170,9 @@\n-        assertEquals(valueClass, clazz.isValue(), \"Class.isValue()\");\n+        assertEquals(valueClass, clazz.isValue(), \"Class.isValue(): \" + clazz);\n+\n+        assertEquals(clazz.accessFlags().contains(AccessFlag.IDENTITY),\n+                identityClass, \"AccessFlag.IDENTITY: \" + clazz);\n+\n+        int modifiers = clazz.getModifiers();\n+        assertEquals(clazz.isIdentity(), (modifiers & Modifier.IDENTITY) != 0, \"Class.getModifiers() & IDENTITY != 0\");\n+        assertEquals(clazz.isValue(), (modifiers & Modifier.IDENTITY) == 0, \"Class.getModifiers() & IDENTITY == 0\");\n+    }\n@@ -146,6 +180,4 @@\n-        \/\/ JDK-8294866: Not yet implemented checks of AccessFlags for the array class\n-\/\/        assertEquals(clazz.accessFlags().contains(AccessFlag.IDENTITY),\n-\/\/                identityClass, \"AccessFlag.IDENTITY\");\n-\/\/\n-\/\/        assertEquals(clazz.accessFlags().contains(AccessFlag.VALUE),\n-\/\/                valueClass, \"AccessFlag.VALUE\");\n+    @Test\n+    public void identityTestNull() {\n+        assertFalse(Objects.hasIdentity(null), \"Objects.hasIdentity(null)\");\n+        assertFalse(Objects.isValueObject(null), \"Objects.isValueObject(null)\");\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":49,"deletions":17,"binary":false,"changes":66,"status":"modified"}]}