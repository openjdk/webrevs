{"files":[{"patch":"@@ -108,0 +108,1 @@\n+  f(UseNonAtomicValueFlattening) \\\n@@ -111,0 +112,1 @@\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+  if (field_info.access_flags().is_volatile()) {\n+    \/\/ volatile is used as a keyword to prevent flattening\n+    return LayoutKind::REFERENCE;\n+  }\n+\n@@ -62,1 +67,1 @@\n-    if (vk->must_be_atomic() || field_info.access_flags().is_volatile() || AlwaysAtomicAccesses) {\n+    if (vk->must_be_atomic() || AlwaysAtomicAccesses) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1112,0 +1112,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsAtomicArray(JNIEnv *env, jobject obj);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -491,0 +491,17 @@\n+JVM_ENTRY(jboolean, JVM_IsAtomicArray(JNIEnv *env, jobject obj))\n+  \/\/ There are multiple cases where an array can\/must support atomic access:\n+  \/\/   - the array is a reference array\n+  \/\/   - the array uses an atomic flat layout: NULLABLE_ATOMIC_FLAT or ATOMIC_FLAT\n+  \/\/   - the array is flat and its component type is naturally atomic\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  if (oop->is_objArray()) return true;\n+  if (oop->is_flatArray()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(oop->klass());\n+    if (fak->layout_kind() == LayoutKind::ATOMIC_FLAT || fak->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n+      return true;\n+    }\n+    if (fak->element_klass()->is_naturally_atomic()) return true;\n+  }\n+  return false;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -136,0 +136,5 @@\n+\n+    \/**\n+     * {@return true if the given array uses a layout designed for atomic accesses }\n+     *\/\n+    public static native boolean isAtomicArray(Object array);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_value_ValueClass_isAtomicArray(JNIEnv *env, jclass cls, jobject obj)\n+{\n+    return JVM_IsAtomicArray(env, obj);\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/native\/libjava\/ValueClass.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ValueClass APIs to get array properties\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.value\n+ * @enablePreview\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening\n+ *           -XX:+UseNonAtomicValueFlattening -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ *           ArrayQueryTest\n+ *\/\n+\n+\n+ import jdk.internal.value.ValueClass;\n+ import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+ import jdk.internal.vm.annotation.LooselyConsistentValue;\n+ import jdk.test.lib.Asserts;\n+\n+\n+ public class ArrayQueryTest {\n+\n+    @ImplicitlyConstructible\n+    static value class SmallValue {\n+        short i = 0;\n+        short j = 0;\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class WeakValue {\n+        short i = 0;\n+        short j = 0;\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class NaturallyAtomic {\n+        int i = 0;\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class BigValue {\n+        long l0 = 0L;\n+        long l1 = 0L;\n+        long l2 = 0L;\n+    }\n+\n+    public static void main(String[] args) {\n+        SmallValue[] array0 = new SmallValue[10];\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray((array0)));\n+        Asserts.assertFalse(ValueClass.isFlatArray(array0));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(array0));\n+\n+        Object[] array1 = ValueClass.newNullRestrictedAtomicArray(SmallValue.class, 10);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array1)));\n+        Asserts.assertTrue(ValueClass.isFlatArray(array1));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(array1));\n+\n+        Object[] array2 = ValueClass.newNullableAtomicArray(SmallValue.class, 10);\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray((array2)));\n+        Asserts.assertTrue(ValueClass.isFlatArray(array2));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(array2));\n+\n+        Object[] array3 = ValueClass.newNullRestrictedArray(WeakValue.class, 10);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array3)));\n+        Asserts.assertTrue(ValueClass.isFlatArray(array3));\n+        Asserts.assertFalse(ValueClass.isAtomicArray(array3));\n+\n+        Object[] array4 = ValueClass.newNullRestrictedAtomicArray(WeakValue.class, 10);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array4)));\n+        Asserts.assertTrue(ValueClass.isFlatArray(array4));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(array4));\n+\n+        Object[] array5 = ValueClass.newNullRestrictedAtomicArray(NaturallyAtomic.class, 10);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array5)));\n+        Asserts.assertTrue(ValueClass.isFlatArray(array5));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(array5));\n+\n+        Object[] array6 = ValueClass.newNullRestrictedArray(BigValue.class, 10);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array6)));\n+        Asserts.assertTrue(ValueClass.isFlatArray(array6));\n+        Asserts.assertFalse(ValueClass.isAtomicArray(array6));\n+\n+        Object[] array7 = ValueClass.newNullRestrictedAtomicArray(BigValue.class, 10);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray((array7)));\n+        Asserts.assertFalse(ValueClass.isFlatArray(array7));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(array7));\n+\n+        Object[] array8 = ValueClass.newNullableAtomicArray(BigValue.class, 10);\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray((array8)));\n+        Asserts.assertFalse(ValueClass.isFlatArray(array8));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(array8));\n+    }\n+\n+ }\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ArrayQueryTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -167,5 +167,2 @@\n-        if (useAtomicFlat) {\n-            Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.ATOMIC_FLAT, f0.layoutKind());\n-        } else {\n-            Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f0.layoutKind());\n-        }\n+        \/\/ volatile fields are never flattened\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f0.layoutKind());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/TestLayoutFlags.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}