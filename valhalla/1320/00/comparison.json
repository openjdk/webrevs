{"files":[{"patch":"@@ -500,11 +500,0 @@\n-    \/**\n-     * Return the size of the object in the heap.\n-     *\n-     * @param o an object\n-     * @return the objects's size\n-     * @since Valhalla\n-     *\/\n-    public static long getObjectSize(Object o) {\n-        return Unsafe.getUnsafe().getObjectSize(o);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import sun.security.action.GetPropertyAction;\n-\n-import java.lang.ref.SoftReference;\n@@ -42,2 +39,1 @@\n- * its key is no longer in ordinary use.\n- * More precisely, for keys that are identity objects, the presence of a\n+ * its key is no longer in ordinary use.  More precisely, the presence of a\n@@ -46,3 +42,0 @@\n- * For keys that are {@linkplain Class#isValue() value objects}, the retention of the\n- * key and value depends on the {@link ValuePolicy} for the {@code WeakHashMap} and\n- * the garbage collection handling of objects that are linked by {@link SoftReference}.\n@@ -53,16 +46,0 @@\n- * <p>\n- * Keys that are {@linkplain Class#isValue() value objects} do not have identity and cannot be\n- * the referent in any {@link java.lang.ref.Reference} including {@link WeakReference}.\n- * The retention of entries with keys that are value objects is selected\n- * using {@link ValuePolicy} when the {@code WeakHashMap} is created.\n- * The default {@code ValuePolicy} is {@link ValuePolicy#defaultValuePolicy()}.\n- * The retention modes implemented by {@link #put(Object, Object) WeakHashMap.put(k,v)} are:\n- * <UL>\n- *     <LI> {@linkplain ValuePolicy#STRONG SOFT} - entries have a lifetime similar to\n- *          referents of {@link SoftReference},\n- *     <LI> {@linkplain ValuePolicy#STRONG STRONG} - entries are retained until removed,\n- *     <LI> {@linkplain ValuePolicy#STRONG DISCARD} - entries are discarded and not put in the map,\n- *     <LI> {@linkplain ValuePolicy#STRONG THROW} - entries are not inserted and\n- *          {@link #put(Object, Object) put(k,v)} throws {@link IdentityException}\n- * <\/UL>\n- *\n@@ -79,2 +56,1 @@\n- * <p> <i>Update needed for Value Objects:\n- * <br>This class is intended primarily for use with key objects whose\n+ * <p> This class is intended primarily for use with key objects whose\n@@ -89,1 +65,1 @@\n- * keys have been discarded may prove to be confusing.<\/i>\n+ * keys have been discarded may prove to be confusing.\n@@ -216,3 +192,0 @@\n-    \/\/ Current policy with regard to keys that are Value classes.\n-    private final ValuePolicy valuePolicy;\n-\n@@ -227,2 +200,0 @@\n-     * The {@code WeakHashMap} is created using the {@linkplain ValuePolicy#defaultValuePolicy()\n-     * default policy for value objects}.\n@@ -240,16 +211,0 @@\n-        this(initialCapacity, loadFactor, ValuePolicy.DEFAULT_VALUE_POLICY);\n-    }\n-\n-    \/**\n-     * Constructs a new, empty {@code WeakHashMap} with the given initial\n-     * capacity, the given load factor, and value policy.\n-     *\n-     * @param  initialCapacity The initial capacity of the {@code WeakHashMap}\n-     * @param  loadFactor      The load factor of the {@code WeakHashMap}\n-     * @param  valuePolicy     The {@link ValuePolicy} for keys that are value objects\n-     * @throws IllegalArgumentException if the initial capacity is negative,\n-     *         or if the load factor is nonpositive.\n-     * @throws NullPointerException if {@code valuePolicy} is null\n-     * @since Valhalla\n-     *\/\n-    public WeakHashMap(int initialCapacity, float loadFactor, ValuePolicy valuePolicy) {\n@@ -265,1 +220,0 @@\n-        this.valuePolicy = Objects.requireNonNull(valuePolicy, \"valuePolicy\");\n@@ -275,2 +229,0 @@\n-     * The {@code WeakHashMap} is created using the {@linkplain ValuePolicy#defaultValuePolicy()\n-     * default policy for value objects}.\n@@ -292,2 +244,0 @@\n-     * The {@code WeakHashMap} is created using the {@linkplain ValuePolicy#defaultValuePolicy()\n-     * default policy for value objects}.\n@@ -299,13 +249,0 @@\n-    \/**\n-     * Constructs a new, empty {@code WeakHashMap} with the {@link ValuePolicy},\n-     * the default initial capacity (16) and load factor (0.75).\n-     *\n-     * @param  valuePolicy     The {@link ValuePolicy} for keys that are value objects; non-null\n-     * @throws NullPointerException if {@code valuePolicy} is null\n-     *\n-     * @since Valhalla\n-     *\/\n-    public WeakHashMap(ValuePolicy valuePolicy) {\n-        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, valuePolicy);\n-    }\n-\n@@ -317,2 +254,0 @@\n-     * The {@code WeakHashMap} is created using the {@linkplain ValuePolicy#defaultValuePolicy()\n-     * default policy for value objects}.\n@@ -332,9 +267,0 @@\n-    \/**\n-     * {@return the {@link ValuePolicy} for this WeakHashMap.}\n-     *\n-     * @since Valhalla\n-     *\/\n-    public ValuePolicy valuePolicy() {\n-        return valuePolicy;\n-    }\n-\n@@ -369,2 +295,1 @@\n-        \/\/ only identity objects can be compared to a reference\n-        if (Objects.hasIdentity(key) && e.refersTo(key)) return true;\n+        if (e.refersTo(key)) return true;\n@@ -534,2 +459,0 @@\n-     * @throws IdentityException if {@code key} is a value object\n-     *         and the {@link #valuePolicy() valuePolicy} is {@link ValuePolicy#THROW}.\n@@ -539,5 +462,0 @@\n-        final boolean hasIdentity = Objects.hasIdentity(k);\n-        if (!hasIdentity && valuePolicy == ValuePolicy.DISCARD) {\n-            \/\/ put of a value object key with value policy DISCARD is more like remove(key)\n-            return remove(key);\n-        }\n@@ -557,3 +475,0 @@\n-        Entry<K,V> e = tab[i];\n-        e = hasIdentity ? new Entry<>(k, value, queue, h, e) : newValueEntry(k, value, queue, h, e);\n-\n@@ -561,1 +476,2 @@\n-        tab[i] = e;\n+        Entry<K,V> e = tab[i];\n+        tab[i] = new Entry<>(k, value, queue, h, e);\n@@ -567,29 +483,0 @@\n-    \/**\n-     * Return a new entry for keys that are value objects.\n-     * The {@link ValuePolicy} for this WeakHashMap determines what entry is returned.\n-     * <ul>\n-     *     <li> THROW - Throws an IdentityException<\/li>\n-     *     <li> STRONG - a StrongEntry <\/li>\n-     *     <li> SOFT - a SoftEntry<\/li>\n-     *     <li> DISCARD - null<\/li>\n-     * <\/ul>\n-     *\n-     * @param key key with which the specified value is to be associated; non-null\n-     * @param value value to be associated with the specified key\n-     * @param queue queue\n-     * @param hash hash\n-     * @param next next\n-     * @return a new entry or null to discard\n-     * @throws IdentityException if the valuePolicy is {@link ValuePolicy#THROW}\n-     *\/\n-    private Entry<K, V> newValueEntry(Object key, V value,\n-                                      ReferenceQueue<Object> queue,\n-                                      int hash, Entry<K,V> next) {\n-        return switch (valuePolicy) {\n-            case THROW -> throw new IdentityException(key.getClass());\n-            case STRONG -> StrongEntry.newStrongEntry(key, value, queue, hash,  next);\n-            case SOFT ->  SoftEntry.newSoftEntry(key, value, queue, hash,  next);\n-            case DISCARD -> null;\n-        };\n-    }\n-\n@@ -664,2 +551,0 @@\n-     * @throws  IdentityException if any of the {@code keys} is a value object\n-     *         and the {@link #valuePolicy() valuePolicy} is {@link ValuePolicy#THROW}.\n@@ -696,18 +581,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     * @param key {@inheritDoc}\n-     * @param value {@inheritDoc}\n-     * @return {@inheritDoc}\n-     *\n-     * @throws  IdentityException if {@code key} is a value object\n-     *         and the {@link #valuePolicy() valuePolicy} is {@link ValuePolicy#THROW}.\n-     *\/\n-    public V putIfAbsent(K key, V value) {\n-        V v = get(key);\n-        if (v == null) {\n-            v = put(key, value);\n-        }\n-\n-        return v;\n-    }\n-\n@@ -903,90 +770,0 @@\n-    \/**\n-     * A SoftEntry is used for value class keys in which the entries are retained\n-     * until there is some memory pressure.  An anchor object is used as the referent\n-     * of a SoftReference and also as the referent of the WeakReference.\n-     * After the SoftReference is cleared, due to GC pressure, the WeakReference is cleared too.\n-     *\n-     * @param <K> key\n-     * @param <V> value\n-     *\/\n-    private static class SoftEntry<K, V> extends Entry<K, V> {\n-        final Object realKey;\n-        \/\/ SoftReference to the anchor to keep it alive until GC clears the SoftReference\n-        private final SoftReference<Object> softAnchor;\n-\n-        static <K, V> SoftEntry<K, V> newSoftEntry(Object key, V value,\n-                                      ReferenceQueue<Object> queue,\n-                                      int hash, Entry<K, V> next) {\n-            \/\/ Select a new anchor object; the entry will be retained until the anchor is collected\n-            Object anchor = new Object();\n-            return new SoftEntry<>(anchor, key, value, queue, hash, next);\n-        }\n-\n-        private SoftEntry(Object anchor, Object key, V value,\n-                    ReferenceQueue<Object> queue,\n-                    int hash, Entry<K,V> next) {\n-            super(anchor, value, queue, hash, next);\n-            this.realKey = key;\n-            this.softAnchor = new SoftReference<>(anchor);\n-        }\n-\n-        \/**\n-         * The real key is not the referent.\n-         * {{@inheritDoc}}\n-         *\/\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public K get() {\n-            return (K) realKey;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public K getKey() {\n-            return (K) realKey;\n-        }\n-    }\n-\n-    \/**\n-     * A StrongEntry is used for value class keys in which the entries are retained\n-     * until removed.  A singleton instance is used as the referent of the WeakReference.\n-     * Since the anchor is never reclaimed, the Entry is retained forever.\n-     *\n-     * @param <K> key\n-     * @param <V> value\n-     *\/\n-    private static class StrongEntry<K, V> extends Entry<K, V> {\n-        final Object realKey;\n-\n-        \/\/ A permanent strong reference to an Object\n-        private static final Object STRONG_ANCHOR = new Object();\n-\n-        static <K, V> StrongEntry<K, V> newStrongEntry(Object key, V value,\n-                                      ReferenceQueue<Object> queue,\n-                                      int hash, Entry<K, V> next) {\n-            return new StrongEntry<>(STRONG_ANCHOR, key, value, queue, hash, next);\n-        }\n-\n-        private StrongEntry(Object anchor, Object key, V value,\n-                    ReferenceQueue<Object> queue,\n-                    int hash, Entry<K,V> next) {\n-            super(anchor, value, queue, hash, next);\n-            this.realKey = key;\n-        }\n-\n-        \/**\n-         * The real key is not the referent.\n-         * {{@inheritDoc}}\n-         *\/\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public K get() {\n-            return (K) realKey;\n-        }\n-\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public K getKey() {\n-            return (K) realKey;\n-        }\n-    }\n-\n@@ -1590,67 +1367,0 @@\n-    \/**\n-     * Enum for the ValuePolicy; when putting a key and value into a WeakHashMap\n-     * determines how keys that are value objects are retained (or not).\n-     * The default {@code ValuePolicy} is {@link ValuePolicy#SOFT}.\n-     * @since Valhalla\n-     *\/\n-    public enum ValuePolicy {\n-        \/**\n-         * If the key is a value object, retain the key and value until removed or\n-         * there is memory pressure that causes soft references to be cleared.\n-         *\/\n-        SOFT,\n-        \/**\n-         * If the key is a value object, retain the key and value until removed.\n-         *\/\n-        STRONG,\n-        \/**\n-         * If the key is a value object, discard the key and value immediately;\n-         * such keys and values are not retained.\n-         *\/\n-        DISCARD,\n-        \/**\n-         * If the key is a value object, throw {@link IdentityException};\n-         * such keys and values are not retained.\n-         *\/\n-        THROW;\n-\n-        \/**\n-         * {@return the default ValuePolicy}\n-         *\n-         * The default {@code ValuePolicy} is {@link ValuePolicy#SOFT} unless overridden by\n-         * the system property {@systemProperty java.util.WeakHashMap.valueKeyRetention}.\n-         * If the property is set to the name of a {@code ValuePolicy} enum,\n-         * the default {@code ValuePolicy} is set using {@link ValuePolicy#valueOf(String)}.\n-         * If the property value is absent or not valid, the policy is set to {@link ValuePolicy#SOFT}.\n-         *\/\n-        public static ValuePolicy defaultValuePolicy() {\n-            return DEFAULT_VALUE_POLICY;\n-        }\n-\n-        \/\/ System property name for the default ValuePolicy\n-        private static final String WEAK_HASH_MAP_VALUE_KEY_RETENTION =\n-                \"java.util.WeakHashMap.valueKeyRetention\";\n-\n-        \/\/ Default WeakHashMap ValuePolicy for keys that are value objects\n-        private static final ValuePolicy DEFAULT_VALUE_POLICY = initDefaultValuePolicy();\n-\n-        \/**\n-         * {@return the default policy for retention of keys that are value classes}\n-         * If the system property \"java.util.WeakHashMap.valueKeyRetention\"\n-         * is the name of a {@link ValuePolicy} enum return it,\n-         * otherwise return {@link ValuePolicy#THROW}.\n-         *\/\n-        private static ValuePolicy initDefaultValuePolicy() {\n-            try {\n-                String p = GetPropertyAction\n-                        .privilegedGetProperty(WEAK_HASH_MAP_VALUE_KEY_RETENTION);\n-                if (p != null) {\n-                    return ValuePolicy.valueOf(p);\n-                }\n-            } catch (IllegalArgumentException ex) {\n-            }\n-\n-            return THROW;  \/\/ hardcoded default if property not set\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":6,"deletions":296,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-        new WeakHashMap<>(16, 0.75f, WeakHashMap.ValuePolicy.SOFT),\n-        new WeakHashMap<>(16, 0.75f, WeakHashMap.ValuePolicy.STRONG),\n","filename":"test\/jdk\/java\/util\/Map\/EntryHashCode.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm WeakValuePolicyTest\n- * @summary Test WeakHashMap.ValuePolicy modes\n- *\/\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.Assert;\n-import static org.testng.Assert.*;\n-\n-import java.util.ArrayList;\n-import java.util.Objects;\n-import java.util.WeakHashMap;\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-\n-@Test\n-public class WeakValuePolicyTest {\n-\n-    record KeyValue(Object key, String value){};\n-\n-    @DataProvider(name=\"Keys\")\n-    KeyValue[] keys() {\n-        return new KeyValue[] {\n-                new KeyValue(new IntValue(1), \"IntValue(1)\"),\n-                new KeyValue(new StringValue(\"xyz\"), \"StringValue(\\\"xyz\\\")\"),\n-                new KeyValue(Integer.valueOf(2), \"Integer.valueOf(2)\"),\n-        };\n-    }\n-\n-    @DataProvider(name=\"WeakHashMaps\")\n-    Object[][] weakValuePolicy() {\n-        return new Object[][] {\n-                {new WeakHashMap<Object, String>(0, 0.75f, WeakHashMap.ValuePolicy.SOFT)},\n-                {new WeakHashMap<Object, String>(0, 0.75f, WeakHashMap.ValuePolicy.STRONG)},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"WeakHashMaps\")\n-    public void putValueSoftStrong(WeakHashMap map) {\n-        WeakHashMap.ValuePolicy policy = map.valuePolicy();\n-        for (KeyValue kv : keys()) {\n-            System.out.println(\"k: \" + kv.key);\n-            Assert.assertFalse(map.containsKey(kv.key), \"map.contains on empty map: \" + kv.key);\n-            Assert.assertNull(map.get(kv.key), \"map.get on empty map: \" + kv.key);\n-            var prev = map.put(kv.key, kv.value);\n-            Assert.assertNull(prev, \"map.put on empty map did not return null: \" + kv.key);\n-            Assert.assertEquals(map.get(kv.key), kv.value, \"map.get after put: \" + kv.key);\n-\n-            forceGC();\n-\n-            if (kv.key.getClass().isValue() &&\n-                    policy.equals(WeakHashMap.ValuePolicy.SOFT)) {\n-                Assert.assertFalse(map.containsKey(kv.key), \"map.containsKey after GC: \" + kv.key);\n-                String value = (String)map.get(kv.key);\n-                Assert.assertNull(value, \"map.get after GC should return null: \" + kv.key);\n-            } else {\n-                prev = map.remove(kv.key);\n-                Assert.assertEquals(prev, kv.value, \"map.remove: \" + kv.key);\n-                Assert.assertNull(map.get(kv.key), \"map.get after remove: \" + kv.key);\n-            }\n-            Assert.assertTrue(map.isEmpty(), \"m.isEmpty()\");\n-        }\n-    }\n-\n-    @Test\n-    public void putValueDiscard() {\n-        final WeakHashMap<Object, String> map = new WeakHashMap<>(0, 0.75f, WeakHashMap.ValuePolicy.DISCARD);\n-        final IntValue intValue = new IntValue(1);\n-        String old = map.put(intValue, \"IntValue(1)\");\n-        Assert.assertNull(old, \"old\");\n-        old = map.get(intValue);\n-        Assert.assertNull(old, \"get after put of discarded value\");\n-    }\n-\n-    @Test\n-    public void putValueThrows() {\n-        final WeakHashMap<Object, String> map = new WeakHashMap<>(0, 0.75f, WeakHashMap.ValuePolicy.THROW);\n-        Assert.assertThrows(IdentityException.class, () -> map.put(new IntValue(1), \"IntValue(1)\"));\n-    }\n-\n-    private void forceGC()  {\n-        Object marker = new Object();\n-        ReferenceQueue<Object> queue = new ReferenceQueue<>();\n-        SoftReference expected = new SoftReference(marker, queue);\n-        marker = null;\n-        Reference<?> actual = waitForReference(queue);\n-        assertEquals(actual, expected, \"Unexpected Reference queued\");\n-    }\n-\n-    \/**\n-     * Wait for any Reference to be enqueued to a ReferenceQueue.\n-     * The garbage collector is invoked to find unreferenced objects.\n-     *\n-     * @param queue a ReferenceQueue\n-     * @return true if the reference was enqueued, false if not enqueued within\n-     *\/\n-    private static Reference<?> waitForReference(ReferenceQueue<Object> queue) {\n-        Objects.requireNonNull(queue, \"queue should not be null\");\n-        ArrayList<Object> chunks = new ArrayList<>(10000);\n-        try {\n-            for (int i = 0; i < 10_000; i++) {\n-                chunks.add(new byte[100_000]);\n-            }\n-        } catch (OutOfMemoryError oome) {\n-\n-        } finally {\n-            chunks = null;\n-        }\n-        for (int retries = 100; retries > 0; retries--) {\n-            try {\n-                var r = queue.remove(10L);\n-                if (r != null) {\n-                    return r;\n-                }\n-            } catch (InterruptedException ie) {\n-                \/\/ ignore, the loop will try again\n-            }\n-        }\n-        return null;\n-    }\n-\n-    static value class IntValue {\n-        int value;\n-\n-        IntValue(int value) {\n-            this.value = value;\n-        }\n-\n-        @java.lang.Override\n-        public java.lang.String toString() {\n-            return \"IntValue{\" + \"value=\" + value + '}';\n-        }\n-    }\n-\n-    static value class StringValue {\n-        String value;\n-\n-        StringValue(String value) {\n-            this.value = value;\n-        }\n-\n-        @java.lang.Override\n-        public java.lang.String toString() {\n-            return \"StringValue{\" + \"value='\" + value + '\\'' + '}';\n-        }\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/WeakValuePolicyTest.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"}]}