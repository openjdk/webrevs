{"files":[{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * This annotation is used to mark type class witnesses in the classfile.\n+ *\/\n+@Target(ElementType.FIELD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Witness { }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Witness.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import jdk.internal.reflect.TypeContext;\n+import sun.reflect.generics.factory.CoreReflectionFactory;\n+import sun.reflect.generics.parser.SignatureParser;\n+import sun.reflect.generics.scope.Scope;\n+import sun.reflect.generics.tree.TypeSignature;\n+import sun.reflect.generics.visitor.Reifier;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This class defines helper method to perform dynamic witness lookups.\n+ *\/\n+public class WitnessSupport {\n+\n+    \/\/ just the one\n+    private WitnessSupport() {\n+\n+    }\n+\n+    \/**\n+     * {@return a witness object with the provided lookup type}\n+     * @param lookup lookup\n+     * @param witnessLookupType the witness lookup type\n+     *\/\n+    public static Object lookupWitness(MethodHandles.Lookup lookup, Type witnessLookupType) {\n+        if (!(witnessLookupType instanceof ParameterizedType)) {\n+               throw new IllegalArgumentException(\"Witness is not a generic type: \" + witnessLookupType.getTypeName());\n+        }\n+        return lookupWitness(lookup, witnessLookupType, Set.of());\n+    }\n+\n+    \/**\n+     * {@return a reflective type modelling the provided signature string}\n+     * @param lookup lookup\n+     * @param signatureString the signature string\n+     *\/\n+    public static Type type(MethodHandles.Lookup lookup, String signatureString) {\n+        class Holder {\n+            private static final Scope DUMMY_SCOPE = _ -> { throw new UnsupportedOperationException(\"DUMMY SCOPE!\"); };\n+        }\n+        SignatureParser parser = SignatureParser.make();\n+        TypeSignature signature = parser.parseTypeSig(signatureString);\n+        CoreReflectionFactory coreReflectionFactory = CoreReflectionFactory.make(lookup.lookupClass(), Holder.DUMMY_SCOPE);\n+        Reifier reifier = Reifier.make(coreReflectionFactory);\n+        signature.accept(reifier);\n+        return reifier.getResult();\n+    }\n+\n+    static Object lookupWitness(MethodHandles.Lookup lookup, Type witnessLookupType, Set<TypeVariable<?>> allowedTvars) {\n+        WitnessGraph witnessGraph = new WitnessGraph(witnessLookupType, allowedTvars);\n+        List<Candidate> candidates = List.of();\n+        for (Class<?> definingClass : witnessGraph.nodes()) {\n+            try {\n+                candidates = findWitnesses(witnessGraph, lookup, candidates, definingClass, witnessLookupType);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+        if (candidates.size() == 1) {\n+            try {\n+                Candidate candidate = candidates.get(0);\n+                return candidate.handle().invoke();\n+            } catch (Throwable ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        } else if (candidates.size() > 1) {\n+            throw new IllegalArgumentException(\"Ambiguous witnesses for type: \" + witnessLookupType.getTypeName());\n+        } else {\n+            \/\/ no canidates\n+            throw new IllegalArgumentException(\"Witness not found for type: \" + witnessLookupType.getTypeName());\n+        }\n+    }\n+\n+    \/*\n+     * 1. find a graph of all generic types (edge is added between A and B if A<B>)\n+     * 2. for all the nodes in the graph, run the witness lookup\n+     * 3. if two results are found, say in A and B, and A dominates B in the graph, then prefer A.\n+     * 4. otherwise, ambiguous`\n+     *\n+     * Note: this is a port of the compiler code in Resolve::findWitness\n+     *\/\n+\n+    static class WitnessGraph {\n+\n+        private final Map<Class<?>, List<Class<?>>> deps = new LinkedHashMap<>();\n+\n+        WitnessGraph(Type target, Set<TypeVariable<?>> allowedTvars) {\n+            new Builder(allowedTvars).buildGraph(0, target);\n+        }\n+\n+        void addNode(Class<?> node, Stack<Class<?>> dominated) {\n+            deps.computeIfAbsent(node, _ -> new ArrayList<>());\n+            for (Class<?> d : dominated) {\n+                deps.compute(d, (_, targets) -> {\n+                    targets.add(node);\n+                    return targets;\n+                });\n+            }\n+        }\n+\n+        boolean isDominatedBy(Class<?> dominated, Class<?> dominating) {\n+            return deps.get(dominated).contains(dominating) &&\n+                    !deps.get(dominating).contains(dominated);\n+        }\n+\n+        boolean isDominatedBy(Class<?> dominated, List<Class<?>> dominating) {\n+            return isDominatedBy(List.of(dominated), dominating);\n+        }\n+\n+        boolean isDominatedBy(List<Class<?>> dominated, Class<?> dominating) {\n+            return isDominatedBy(dominated, List.of(dominating));\n+        }\n+\n+        boolean isDominatedBy(List<Class<?>> dominated, List<Class<?>> dominating) {\n+            for (Class<?> s : dominated) {\n+                for (Class<?> t : dominating) {\n+                    if (!isDominatedBy(s, t)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+\n+        Collection<Class<?>> nodes() {\n+            return deps.keySet();\n+        }\n+\n+        class Builder {\n+\n+            final Set<TypeVariable<?>> allowedTvars;\n+            final Stack<Class<?>> stack = new Stack<>();\n+\n+            Builder(Set<TypeVariable<?>> allowedTvars) {\n+                this.allowedTvars = allowedTvars;\n+            }\n+\n+            void buildGraph(int level, Type target) {\n+                switch (target) {\n+                    case Class<?> clazz when clazz.isArray() -> buildGraph(level, clazz.getComponentType());\n+                    case Class<?> clazz -> addNode(clazz, stack);\n+                    case WildcardType wt -> {\n+                        if (level == 1) {\n+                            throw new IllegalArgumentException(\"Unsupported toplevel wildcard type in witness: \" + target);\n+                        }\n+                        if (wt.getLowerBounds().length > 0) {\n+                            buildGraph(level, wt.getLowerBounds());\n+                        } else {\n+                            buildGraph(level, wt.getUpperBounds());\n+                        }\n+                    }\n+                    case TypeVariable<?> tv -> {\n+                        if (!allowedTvars.contains(tv)) {\n+                            throw new IllegalArgumentException(\"Unsupported type variables in witness: \" + target);\n+                        }\n+                    }\n+                    case GenericArrayType at -> buildGraph(level, at.getGenericComponentType());\n+                    case ParameterizedType pt -> {\n+                        Class<?> base = (Class<?>) pt.getRawType();\n+                        addNode(base, stack);\n+                        try {\n+                            stack.push((Class<?>) pt.getRawType());\n+                            buildGraph(level + 1, pt.getActualTypeArguments());\n+                        } finally {\n+                            stack.pop();\n+                        }\n+                    }\n+                    default -> {\n+                        \/\/ do nothing\n+                    }\n+                }\n+            }\n+\n+            void buildGraph(int level, Type[] target) {\n+                Stream.of(target).forEach(t -> buildGraph(level, t));\n+            }\n+        }\n+    }\n+\n+    private static List<Candidate> findWitnesses(WitnessGraph witnessGraph, MethodHandles.Lookup lookup, List<Candidate> candidates, Class<?> current, Type target) throws ReflectiveOperationException {\n+        for (Field field : current.getDeclaredFields()) {\n+            if (field.isAnnotationPresent(Witness.class)) {\n+                TypeContext tc = new TypeContext();\n+                if (tc.isSameType(field.getGenericType(), target)) {\n+                    if (!tc.checkBounds()) {\n+                        continue;\n+                    }\n+                    candidates = merge(witnessGraph, new Candidate(field, lookup.unreflectGetter(field)), candidates);\n+                }\n+            }\n+        }\n+        outer: for (Method method : current.getDeclaredMethods()) {\n+            if (method.isAnnotationPresent(Witness.class)) {\n+                TypeContext tc = new TypeContext();\n+                if (tc.isSameType(method.getGenericReturnType(), target)) {\n+                    if (!tc.checkBounds()) {\n+                        continue;\n+                    }\n+                    MethodHandle handle = lookup.unreflect(method);\n+                    for (Type p : method.getGenericParameterTypes()) {\n+                        Object o = lookupWitness(lookup, tc.subst(p),\n+                                Stream.of(method.getTypeParameters())\n+                                        .collect(Collectors.toSet()));\n+                        if (o == null) continue outer; \/\/ fail\n+                        handle = handle.bindTo(o);\n+                    }\n+                    candidates = merge(witnessGraph, new Candidate(method, handle), candidates);\n+                }\n+            }\n+        }\n+        return candidates;\n+    }\n+\n+    record Candidate(Member member, MethodHandle handle) { }\n+\n+    static List<Candidate> merge(WitnessGraph graph, Candidate result, List<Candidate> candidates) {\n+        if (candidates.isEmpty()) {\n+            return List.of(result);\n+        }\n+        Class<?> resultClass = result.member.getDeclaringClass();\n+        List<Class<?>> candidateClasses = candidates.stream().map(c -> c.member.getDeclaringClass())\n+                .collect(Collectors.toList());\n+        if (graph.isDominatedBy(resultClass, candidateClasses)) {\n+            return candidates;\n+        } else if (graph.isDominatedBy(candidateClasses, resultClass)) {\n+            return List.of(result);\n+        } else {\n+            List<Candidate> merged = new ArrayList<>(candidates);\n+            merged.add(result);\n+            return merged;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/WitnessSupport.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl;\n+import sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl;\n+import sun.reflect.generics.reflectiveObjects.WildcardTypeImpl;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public class TypeContext {\n+    private final Map<TypeVariable<?>, Type> inferredVars = new HashMap<>();\n+\n+    public boolean checkBounds() {\n+        for (Map.Entry<TypeVariable<?>, Type> inferredTypes : inferredVars.entrySet()) {\n+            for (Type bound : upper(inferredTypes.getKey())) {\n+                if (!isSubType(inferredTypes.getValue(), subst(bound))) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean isSameType(Type t1, Type t2) {\n+        if (isTypeVar(t1) || isTypeVar(t2)) {\n+            \/\/ inference!\n+            TypeVariable<?> tv = isTypeVar(t1) ?\n+                    (TypeVariable<?>)t1 : (TypeVariable<?>)t2;\n+            Type inferred = isTypeVar(t1) ? t2 : t1;\n+            Type prevInferred = inferredVars.get(tv);\n+            if (prevInferred != null && !isSameType(inferred, prevInferred)) {\n+                \/\/ incompatible constraints\n+                return false;\n+            }\n+            inferredVars.put(tv, inferred);\n+            return true;\n+        }\n+        if (isArray(t1) && isArray(t2)) {\n+            return isSameType(arrayComponent(t1), arrayComponent(t2));\n+        } else if (isClass(t1) && isClass(t2)) {\n+            return toClass(t1).equals(toClass(t2)) &&\n+                    isSameTypes(typeArguments(t1), typeArguments(t2));\n+        } else if (isWildcard(t1) && isWildcard(t2)) {\n+            return isSameTypes(upper(t1), upper(t2)) &&\n+                    isSameTypes(lower(t2), lower(t2));\n+        } else {\n+            return t1.equals(t2);\n+        }\n+    }\n+\n+    public boolean isSameTypes(Type[] ts1, Type[] ts2) {\n+        if (ts1.length != ts2.length) return false;\n+        for (int i = 0 ; i < ts1.length ; i++) {\n+            if (!isSameType(ts1[i], ts2[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean isSubType(Type s, Type t) {\n+        if (isPrimitive(s) && isPrimitive(t)) {\n+            return ((Class<?>)t).isAssignableFrom(((Class<?>)s));\n+        } else if (isArray(s)) {\n+            if (isArray(t)) {\n+                Type cs = arrayComponent(s);\n+                Type ct = arrayComponent(t);\n+                return isSubType(cs, ct);\n+            } else {\n+                return isSameType(t, Object.class) ||\n+                        isSameType(t, Serializable.class) ||\n+                        isSameType(t, Cloneable.class);\n+            }\n+        } else if (isClass(s) && isClass(t)) {\n+            \/\/ Lift subtype to supertype\n+            Type sup = lift(s, toClass(t));\n+            return sup != null &&\n+                    (typeArguments(t).length == 0 ||\n+                    isSameTypes(typeArguments(sup), typeArguments(t)));\n+        }\n+        return false;\n+    }\n+\n+    public Type subst(Type t) {\n+        if (inferredVars.isEmpty()) return t; \/\/ fast-path\n+        return switch (t) {\n+            case TypeVariable<?> tv -> inferredVars.get(tv);\n+            case WildcardType wt -> WildcardTypeImpl.make(subst(wt.getUpperBounds()), subst(wt.getLowerBounds()));\n+            case GenericArrayType at -> GenericArrayTypeImpl.make(subst(at.getGenericComponentType()));\n+            case ParameterizedType pt -> ParameterizedTypeImpl.make((Class<?>)pt.getRawType(), subst(pt.getActualTypeArguments()), pt.getOwnerType());\n+            default -> t;\n+        };\n+    }\n+\n+    public Type[] subst(Type[] ts) {\n+        return Stream.of(ts).map(this::subst).toArray(Type[]::new);\n+    }\n+\n+    Type lift(Type type, Class<?> target) {\n+        Class<?> baseType = type instanceof ParameterizedType pt ?\n+                (Class<?>)pt.getRawType() : (Class<?>)type;\n+        if (baseType.equals(target)) {\n+            return type;\n+        } else if (target.equals(Object.class)) {\n+            return Object.class;\n+        }\n+        TypeContext tc = new TypeContext();\n+        if (type instanceof ParameterizedType pt) {\n+            ParameterizedType formal = ParameterizedTypeImpl.make(baseType, baseType.getTypeParameters(), pt.getOwnerType());\n+            tc.isSameType(pt, formal); \/\/ generate substitutions\n+        }\n+        if (!tc.checkBounds()) {\n+            return null;\n+        }\n+        if (baseType.getGenericSuperclass() != null) {\n+            Type res = lift(tc.subst(baseType.getGenericSuperclass()), target);\n+            if (res != null) {\n+                return res;\n+            }\n+        }\n+        for (Type intf : baseType.getGenericInterfaces()) {\n+            Type res = lift(tc.subst(intf), target);\n+            if (res != null) {\n+                return res;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static Type[] typeArguments(Type t) {\n+        return switch (t) {\n+            case ParameterizedType pt -> pt.getActualTypeArguments();\n+            case Class<?> _ -> new Type[0];\n+            default -> throw unsupported(t);\n+        };\n+    }\n+\n+    static Class<?> toClass(Type t) {\n+        return switch (t) {\n+            case ParameterizedType pt -> (Class<?>)pt.getRawType();\n+            case Class<?> c -> c;\n+            default -> throw unsupported(t);\n+        };\n+    }\n+\n+    static boolean isPrimitive(Type t) {\n+        return t instanceof Class<?> c && c.isPrimitive();\n+    }\n+\n+    static boolean isClass(Type t) {\n+        return switch (t) {\n+            case Class<?> c -> !c.isPrimitive() && !c.isArray();\n+            case ParameterizedType _ -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isArray(Type t) {\n+        return switch (t) {\n+            case Class<?> c -> c.isArray();\n+            case GenericArrayType _ -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static boolean isTypeVar(Type t) {\n+        return t instanceof TypeVariable<?>;\n+    }\n+\n+    static boolean isWildcard(Type t) {\n+        return t instanceof WildcardType;\n+    }\n+\n+    static Type[] upper(Type t) {\n+        if (isWildcard(t)) {\n+            return ((WildcardType)t).getUpperBounds();\n+        } else if (isTypeVar(t)) {\n+            return ((TypeVariable<?>)t).getBounds();\n+        } else {\n+            throw unsupported(t);\n+        }\n+    }\n+\n+    static Type[] lower(Type t) {\n+        if (isWildcard(t)) {\n+            return ((WildcardType) t).getLowerBounds();\n+        } else {\n+            throw unsupported(t);\n+        }\n+    }\n+\n+    static Type arrayComponent(Type t) {\n+        return switch (t) {\n+            case GenericArrayType gat -> gat.getGenericComponentType();\n+            case Class<?> c when c.isArray() -> c.componentType();\n+            default -> throw unsupported(t);\n+        };\n+    }\n+\n+    static UnsupportedOperationException unsupported(Type t) {\n+        return new UnsupportedOperationException(t.getTypeName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/TypeContext.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,2 @@\n-    private WildcardTypeImpl(FieldTypeSignature[] ubs,\n-                             FieldTypeSignature[] lbs,\n+    private WildcardTypeImpl(Object[] ubs,\n+                             Object[] lbs,\n@@ -80,0 +80,11 @@\n+    \/**\n+     * Eager factory method.\n+     * @param ubs - an array of types representing the upper bounds\n+     * @param lbs - an array of types representing the lower bounds\n+     * @return a wild card type with the requested bounds\n+     *\/\n+    public static WildcardTypeImpl make(Type[] ubs,\n+                                        Type[] lbs) {\n+        return new WildcardTypeImpl(ubs, lbs, null);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/WildcardTypeImpl.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,0 +354,6 @@\n+    \/**\n+     * Flag that indicates that a var symbol represent a type class witness.\n+     *\/\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long WITNESS = 1L<<47;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,2 @@\n-        ABSENT_TYP(Category.RESOLUTION_TARGET, KindName.CLASS);        \/\/ not overloaded   non-target\n+        ABSENT_TYP(Category.RESOLUTION_TARGET, KindName.CLASS),        \/\/ not overloaded   non-target\n+        ABSENT_WITNESS(Category.RESOLUTION_TARGET);                    \/\/ not overloaded   non-target\n@@ -233,0 +234,1 @@\n+        WITNESS(\"kindname.witness\"),\n@@ -301,1 +303,7 @@\n-            return ((sym.flags_field & RECORD) != 0) ? KindName.RECORD_COMPONENT : KindName.VAR;\n+            if ((sym.flags_field & RECORD) != 0) {\n+                return KindName.RECORD_COMPONENT;\n+            } else if ((sym.flags_field & WITNESS) != 0) {\n+                return KindName.WITNESS;\n+            } else {\n+                return KindName.VAR;\n+            }\n@@ -307,1 +315,5 @@\n-            return KindName.METHOD;\n+            if ((sym.flags_field & WITNESS) != 0) {\n+                return KindName.WITNESS;\n+            } else {\n+                return KindName.METHOD;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Kinds.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2531,0 +2531,9 @@\n+    public static class WitnessSymbol extends VarSymbol {\n+        public List<WitnessSymbol> params;\n+\n+        public WitnessSymbol(long flags, Name name, Type type, Symbol owner, List<WitnessSymbol> params) {\n+            super(flags, name, type, owner);\n+            this.params = params;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,0 +255,3 @@\n+    \/\/ For type classes\n+    public final Type witnessType;\n+\n@@ -662,0 +665,4 @@\n+        \/\/ For type classes\n+        witnessType = enterClass(\"java.lang.runtime.Witness\");\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,1 +431,1 @@\n-     * Computes the set of captured variables mentioned in a given type. See {@link CaptureScanner}.\n+     * Computes the set of captured variables mentioned in a given type. See {@link TypeVarScanner}.\n@@ -439,4 +439,3 @@\n-        CaptureScanner cs = new CaptureScanner();\n-        Set<Type> captures = new HashSet<>();\n-        cs.visit(t, captures);\n-        return List.from(captures);\n+        return typeVars(t).stream()\n+                .filter(tv -> tv instanceof CapturedType || (tv.tsym.flags() & Flags.SYNTHETIC) != 0)\n+                .collect(List.collector());\n@@ -446,1 +445,4 @@\n-     * This visitor scans a type recursively looking for occurrences of captured type variables.\n+     * Computes the set of type variables mentioned in a given type. See {@link TypeVarScanner}.\n+     *\n+     * @param t the type where occurrences of captured variables have to be found\n+     * @return the set of type variables found in t\n@@ -448,1 +450,11 @@\n-    class CaptureScanner extends SimpleVisitor<Void, Set<Type>> {\n+    public List<Type> typeVars(Type t) {\n+        TypeVarScanner cs = new TypeVarScanner();\n+        Set<Type> typeVars = new HashSet<>();\n+        cs.visit(t, typeVars);\n+        return List.from(typeVars);\n+    }\n+\n+    \/**\n+     * This visitor scans a type recursively looking for occurrences of type variables.\n+     *\/\n+    class TypeVarScanner extends SimpleVisitor<Void, Set<Type>> {\n@@ -478,1 +490,1 @@\n-            if ((t.tsym.flags() & Flags.SYNTHETIC) != 0 && seen.add(t)) {\n+            if (seen.add(t)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1231,0 +1231,4 @@\n+                if ((m.flags() & WITNESS) != 0) {\n+                    chk.checkWitnessDeclaration(tree, m.enclClass().type, m, m.type.getTypeArguments());\n+                }\n+\n@@ -1712,0 +1716,3 @@\n+            if ((v.flags() & WITNESS) != 0) {\n+                chk.checkWitnessDeclaration(tree, v.enclClass().type, v, List.nil());\n+            }\n@@ -4779,1 +4786,1 @@\n-                tree.name == names._class)\n+                tree.name == names._class || tree.name == names.witness)\n@@ -4937,0 +4944,8 @@\n+                } else if (name == names.witness) {\n+                    if (!chk.checkWitnessLookup(pos, site)) {\n+                        return syms.errSymbol;\n+                    }\n+                    \/\/ In this case, we have already made sure in\n+                    \/\/ visitSelect that qualifier expression is a type.\n+                    Symbol sym = rs.findWitness(env, site);\n+                    return rs.accessBase(sym, pos, location, site, name, true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.comp.Infer.InferenceException;\n@@ -1190,0 +1191,3 @@\n+            if ((flags & WITNESS) != 0) {\n+                implicit |= STATIC | FINAL;\n+            }\n@@ -1222,0 +1226,4 @@\n+            if ((flags & WITNESS) != 0) {\n+                implicit |= STATIC;\n+                mask = AccessFlags | STATIC;\n+            }\n@@ -2984,0 +2992,111 @@\n+    boolean checkWitnessLookup(DiagnosticPosition pos, Type lookupType) {\n+        Fragment fragment = checkWitnessTypeInternal(null, lookupType, List.nil());\n+        if (fragment != null) {\n+            log.error(pos, Errors.BadWitnessLookupType(lookupType, fragment));\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void checkWitnessDeclaration(DiagnosticPosition pos, Type site, Symbol witness, List<Type> allowedTypeVars) {\n+        Type witnessType = witnessType(witness);\n+        Fragment fragment = checkWitnessTypeInternal(site, witnessType, allowedTypeVars);\n+        if (fragment != null) {\n+            log.error(pos, Errors.BadWitnessDecl(witnessType, fragment));\n+            witness.flags_field |= CLASH;\n+            return;\n+        } else if (protection(witness.flags()) > protection(site.tsym.flags())) {\n+            Fragment cause = (site.tsym.flags() & AccessFlags) == 0 ?\n+                        Fragments.WitnessInaccessible(\"package\") :\n+                        Fragments.WitnessInaccessible(asFlagSet(site.tsym.flags() & AccessFlags));\n+            log.error(pos, Errors.BadWitnessDecl(witnessType, cause));\n+            witness.flags_field |= CLASH;\n+            return;\n+        }\n+\n+        Predicate<Symbol> witnessFilter = witnessFilter(witness);\n+        for (Symbol other : witness.enclClass().members().getSymbols(witnessFilter)) {\n+            List<Type> allAllowedTypeVars = other.type.hasTag(FORALL) ?\n+                    allowedTypeVars.prependList(other.type.getTypeArguments()) :\n+                    allowedTypeVars;\n+            Type otherType = witnessType(other);\n+            if (isSameTypeWitness(otherType, witnessType, allAllowedTypeVars)) {\n+                \/\/ dominated\n+                log.error(pos, Errors.WitnessClash(witness, other, Fragments.WitnessClashSameType(witnessType)));\n+                witness.flags_field |= CLASH;\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ The two routines below are similar to equality and subtype checks, except they take free type-variables into account\n+    \/\/ e.g. Foo<X> is a subtype of Bar<Integer> (for X = Integer, and Foo <: Bar). These checks ensure that a single\n+    \/\/ class declaration can provide at most one witness for each lookup type.\n+\n+    private boolean isSameTypeWitness(Type t1, Type t2, List<Type> typevars) {\n+        InferenceContext context = new InferenceContext(infer, typevars);\n+        boolean res = types.isSameType(context.asUndetVar(t1), context.asUndetVar(t2));\n+        try {\n+            context.solve(types.noWarnings);\n+        } catch (InferenceException ex) {\n+            res = false;\n+        }\n+        return res;\n+    }\n+\n+    private boolean isSubtypeWitness(Type t1, Type t2, List<Type> typevars) {\n+        InferenceContext context = new InferenceContext(infer, typevars);\n+        boolean res = types.isSubtype(context.asUndetVar(t1), context.asUndetVar(t2));\n+        try {\n+            context.solve(types.noWarnings);\n+        } catch (InferenceException ex) {\n+            res = false;\n+        }\n+        return res;\n+    }\n+\n+    private Predicate<Symbol> witnessFilter(Symbol witness) {\n+        return s ->\n+                s != witness &&\n+                (s.flags() & WITNESS) != 0 &&\n+                (s.flags() & CLASH) == 0;\n+    }\n+\n+\n+    private Type witnessType(Symbol witness) {\n+        return witness.kind == MTH ?\n+                witness.type.getReturnType() :\n+                witness.type;\n+    }\n+\n+    private boolean isValidWitnessType(Type site, Type witnessType, List<Type> allowedTypeVars) {\n+        return checkWitnessTypeInternal(site, witnessType, allowedTypeVars) == null;\n+    }\n+\n+    private Fragment checkWitnessTypeInternal(Type site, Type witnessType, List<Type> allowedTypeVars) {\n+        if (!witnessType.isErroneous()) {\n+            JCDiagnostic.Fragment cause = null;\n+            if (!types.typeVars(witnessType).diff(allowedTypeVars).isEmpty()) {\n+                return Fragments.TypeVarInWitness;\n+            } else if (!types.isSameType(witnessType, types.capture(witnessType))) {\n+                \/\/ @@@: top-level wildcards unsupported\n+                return Fragments.UnsupportedWildcards;\n+            } else if (!witnessType.isInterface() || witnessType.getTypeArguments().isEmpty()) {\n+                return Fragments.WitnessMustBeGenericInterface;\n+            } else if (site != null && !containsReferenceTo(witnessType, site)) {\n+                return Fragments.WitnessMustReferToSite(site);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean containsReferenceTo(Type witnessType, Type site) {\n+        return switch (witnessType.getTag()) {\n+            case CLASS -> witnessType.tsym == site.tsym ||\n+                    witnessType.getTypeArguments().stream().anyMatch(a -> containsReferenceTo(a, site)); \/\/ @@@: inner classes\n+            case WILDCARD -> containsReferenceTo(((WildcardType)witnessType).type, site);\n+            case ARRAY -> containsReferenceTo(types.elemtypeOrType(witnessType), site);\n+            default -> false; \/\/ note: type variables are never deemed a \"provable\" reference to a type\n+        };\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":120,"deletions":1,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -785,0 +785,22 @@\n+\n+    \/*\n+     * Instantiate a witness method type using target type constraint.\n+     *\/\n+    public Type instantiateWitnessMethod(ForAll witnessMethodType, Type target) {\n+        InferenceContext context = new InferenceContext(this, witnessMethodType.tvars);\n+        Type freeRet = context.asUndetVar(witnessMethodType.getReturnType());\n+        if (!types.isSubtype(freeRet, target)) {\n+            return Type.noType;\n+        }\n+        \/\/ propagate\n+        doIncorporation(context, types.noWarnings);\n+        \/\/ make sure each under variable has some equality bound\n+        for (Type v : context.undetVars()) {\n+            if (v instanceof UndetVar uv && uv.getBounds(InferenceBound.EQ).isEmpty()) {\n+                return null;\n+            }\n+        }\n+        \/\/ ok, let's infer using only eq bounds\n+        context.solveBasic(context.inferenceVars(), EnumSet.of(InferenceStep.EQ));\n+        return context.asInstType(witnessMethodType.qtype);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.code.Attribute.Compound;\n@@ -1892,1 +1893,25 @@\n-\/* ************************************************************************\n+    \/** The tree simulating a T.witness expression.\n+     *  @param witness      The witness symbol.\n+     *\/\n+    private DynamicVarSymbol witnessOf(WitnessSymbol witness) {\n+        MethodSymbol msym = rs.resolveInternalMethod(null, attrEnv, syms.constantBootstrapsType, names.invoke,\n+                List.of(syms.methodHandleLookupType, syms.stringType, syms.classType, syms.methodHandleType, types.makeArrayType(syms.objectType)), List.nil());\n+\n+        ListBuffer<LoadableConstant> staticArgs = new ListBuffer<>();\n+\n+        LoadableConstant witnessHandle = switch (witness.baseSymbol()) {\n+            case VarSymbol v -> v.asMethodHandle(true);\n+            case MethodSymbol m -> m.asHandle();\n+            default -> throw Assert.error(\"Cannot get here\");\n+        };\n+        staticArgs.add(witnessHandle);\n+\n+        for (WitnessSymbol param : witness.params) {\n+            staticArgs.add(witnessOf(param));\n+        }\n+\n+        return new DynamicVarSymbol(names.witness, currentClass, msym.asHandle(), witness.type,\n+                staticArgs.toArray(LoadableConstant[]::new));\n+    }\n+\n+\/* *************************************************************************\n@@ -2763,0 +2788,3 @@\n+            if ((tree.sym.flags() & WITNESS) != 0) {\n+                tree.sym.appendAttributes(List.of(new Compound(syms.witnessType, List.nil())));\n+            }\n@@ -3759,0 +3787,3 @@\n+            if ((tree.sym.flags() & WITNESS) != 0) {\n+                tree.sym.appendAttributes(List.of(new Compound(syms.witnessType, List.nil())));\n+            }\n@@ -4312,0 +4343,3 @@\n+        } else if (tree.name == names.witness) {\n+            VarSymbol witnessAccess = witnessOf((WitnessSymbol)tree.sym);\n+            result = make.Ident(witnessAccess);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+import java.util.HashMap;\n@@ -70,0 +71,1 @@\n+import java.util.stream.Collectors;\n@@ -74,0 +76,1 @@\n+import javax.lang.model.type.TypeVisitor;\n@@ -2351,0 +2354,177 @@\n+    \/*\n+     * 1. find a graph of all generic types (edge is added between A and B if A<B>)\n+     * 2. for all the nodes in the graph, run the witness lookup\n+     * 3. if two results are found, say in A and B, and A dominates B in the graph, then prefer A.\n+     * 4. otherwise, ambiguous`\n+     *\/\n+\n+    static class WitnessGraph {\n+\n+        private final Map<Symbol, List<Symbol>> deps = new LinkedHashMap<>();\n+\n+        WitnessGraph(Type witnessType) {\n+            witnessType.accept(BUILDER, this);\n+        }\n+\n+        void addNode(Symbol node, List<Symbol> dominated) {\n+            deps.putIfAbsent(node, List.nil());\n+            for (Symbol d : dominated) {\n+                deps.compute(d, (_, targets) -> targets.prepend(node));\n+            }\n+        }\n+\n+        boolean isDominatedBy(Symbol dominated, Symbol dominating) {\n+            return deps.get(dominated).contains(dominating) &&\n+                    !deps.get(dominating).contains(dominated);\n+        }\n+\n+        boolean isDominatedBy(Symbol dominated, List<Symbol> dominating) {\n+            return isDominatedBy(List.of(dominated), dominating);\n+        }\n+\n+        boolean isDominatedBy(List<Symbol> dominated, Symbol dominating) {\n+            return isDominatedBy(dominated, List.of(dominating));\n+        }\n+\n+        boolean isDominatedBy(List<Symbol> dominated, List<Symbol> dominating) {\n+            for (Symbol s : dominated) {\n+                for (Symbol t : dominating) {\n+                    if (!isDominatedBy(s, t)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+\n+        Collection<Symbol> nodes() {\n+            return deps.keySet();\n+        }\n+\n+        static final Type.Visitor<Void, WitnessGraph> BUILDER = new Types.SimpleVisitor<>() {\n+\n+            List<Symbol> stack = List.nil();\n+\n+            @Override\n+            public Void visitType(Type t, WitnessGraph witnessGraph) {\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitClassType(ClassType t, WitnessGraph witnessGraph) {\n+                \/\/ @@@: inner classes\n+                witnessGraph.addNode(t.tsym, stack);\n+                try {\n+                    stack = stack.prepend(t.tsym);\n+                    for (Type arg : t.getTypeArguments()) {\n+                        visit(arg, witnessGraph);\n+                    }\n+                    return null;\n+                } finally {\n+                    stack = stack.tail;\n+                }\n+            }\n+\n+            @Override\n+            public Void visitArrayType(ArrayType t, WitnessGraph witnessGraph) {\n+                return visit(t.elemtype, witnessGraph);\n+            }\n+\n+            @Override\n+            public Void visitWildcardType(WildcardType t, WitnessGraph witnessGraph) {\n+                return visit(t.type, witnessGraph);\n+            }\n+        };\n+\n+    }\n+\n+    Symbol findWitness(Env<AttrContext> env, Type target) {\n+        WitnessGraph witnessGraph = new WitnessGraph(target);\n+        Symbol bestSoFar = new WitnessNotFoundError(target);\n+        for (Symbol ts : witnessGraph.nodes()) {\n+            bestSoFar = selectBestWitness(\n+                    bestSoFar,\n+                    lookupWitness(env, ts.type, target),\n+                    witnessGraph);\n+        }\n+        return bestSoFar;\n+    }\n+\n+    \/\/ Assumption: each class can have at most one matching witness\n+    private Symbol lookupWitness(Env<AttrContext> env, Type site, Type target) {\n+        for (Symbol witness : site.tsym.members().getSymbols(s -> (s.flags() & WITNESS) != 0 && !s.type.isErroneous())) {\n+            if (witness.kind == VAR && types.isSameType(witness.type, target)) {\n+                return witnessResult(env, site, witness, target, List.nil());\n+            } else if (witness.kind == MTH) {\n+                Type witnessType = witness.type;\n+                if (witnessType.hasTag(FORALL)) {\n+                    try {\n+                        \/\/ first, infer a concrete method type using the target\n+                        witnessType = infer.instantiateWitnessMethod((ForAll) witnessType, target);\n+                    } catch (Infer.InferenceException ex) {\n+                        continue;\n+                    }\n+                }\n+                ListBuffer<WitnessSymbol> params = new ListBuffer<>();\n+                \/\/ check if the witness method return is the same as the target type\n+                if (witnessType.hasTag(METHOD) &&\n+                        types.isSameType(witnessType.getReturnType(), target)) {\n+                    boolean mismatch = false;\n+                    for (Type p : witnessType.getParameterTypes()) {\n+                        Symbol witnessParam = findWitness(env, p);\n+                        if (witnessParam.exists()) {\n+                            params.add((WitnessSymbol)witnessParam);\n+                        } else {\n+                            mismatch = true;\n+                            break;\n+                        }\n+                    }\n+                    \/\/ make it look like a variable access\n+                    if (!mismatch) {\n+                        return witnessResult(env, site, witness, target, params.toList());\n+                    }\n+                }\n+            }\n+        }\n+        return new WitnessNotFoundError(target);\n+    }\n+\n+    private Symbol witnessResult(Env<AttrContext> env, Type site, Symbol witness, Type target, List<WitnessSymbol> params) {\n+        Symbol result = new WitnessSymbol(witness.flags(), witness.name, target, witness.owner, params) {\n+            @Override\n+            public Symbol baseSymbol() {\n+                return witness;\n+            }\n+        };\n+        if (!isAccessible(env, site, witness)) {\n+            Assert.error(\"Unexpected inaccessible witness: \" + witness);\n+        }\n+        return result;\n+    }\n+\n+    private Symbol selectBestWitness(Symbol bestSoFar, Symbol witness, WitnessGraph witnessGraph) {\n+        if (witness.exists() && bestSoFar.exists()) {\n+            List<Symbol> currentOwners = (bestSoFar.kind == AMBIGUOUS) ?\n+                    ambiguousWitnessOwners(bestSoFar) :\n+                    List.of(bestSoFar.owner);\n+            if (witnessGraph.isDominatedBy(currentOwners, witness.owner)) {\n+                return witness;\n+            } else if (witnessGraph.isDominatedBy(witness.owner, currentOwners)) {\n+                return bestSoFar;\n+            } else {\n+                \/\/ no domination, ambiguity\n+                return new AmbiguityError(bestSoFar, witness);\n+            }\n+        } else if (witness.exists()) {\n+            return witness;\n+        } else {\n+            return bestSoFar;\n+        }\n+    }\n+\n+    List<Symbol> ambiguousWitnessOwners(Symbol ambiguousSym) {\n+        Set<Symbol> owners = ((AmbiguityError)ambiguousSym).ambiguousSyms.stream()\n+                .map(s -> s.owner).collect(Collectors.toSet());\n+        return List.from(owners);\n+    }\n+\n@@ -4187,0 +4367,14 @@\n+    class WitnessNotFoundError extends ResolveError {\n+        final Type type;\n+\n+        WitnessNotFoundError(Type type) {\n+            super(Kind.ABSENT_WITNESS, \"witness not found\");\n+            this.type = type;\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {\n+            return diags.create(dkind, log.currentSource(), pos, \"cant.resolve.witness\", type);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":195,"deletions":1,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,1 +319,1 @@\n-        if ((sym.flags_field & (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))\n+        if ((sym.flags_field & (SYNTHETIC|BRIDGE|WITNESS)) != SYNTHETIC || sym.name.startsWith(names.lambda))\n@@ -1566,0 +1566,4 @@\n+            } else if (proxy.type.tsym.flatName() == syms.witnessType.tsym.flatName()) {\n+                \/\/ @@@: replace with proper attribute\n+                Assert.check((sym.kind == VAR || sym.kind == MTH) && sym.owner.kind == TYP);\n+                sym.flags_field |= WITNESS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1702,2 +1702,5 @@\n-                        if (!isMode(TYPE) && isParameterizedTypePrefix()) {\n-                            \/\/this is either an unbound method reference whose qualifier\n+                        TypeExprQualifier typeExprQualifier = classifyTypeExprQualifier();\n+                        if (typeExprQualifier == TypeExprQualifier.UNBOUNDED_MEMBER_REF ||\n+                                (typeExprQualifier == TypeExprQualifier.TYPE_OR_UNBOUNDED_MEMBER_REF && !isMode(TYPE)) ||\n+                                typeExprQualifier == TypeExprQualifier.WITNESS_LOOKUP) {\n+                            \/\/this is an unbound method reference whose qualifier\n@@ -1717,0 +1720,6 @@\n+                                if (token.kind == IDENTIFIER && token.name() == names.witness) {\n+                                    \/\/ witness selector!\n+                                    t = toP(F.at(token.pos).Select(t, ident()));\n+                                    selectExprMode();\n+                                    return term3Rest(t, typeArgs);\n+                                }\n@@ -1942,0 +1951,8 @@\n+    enum TypeExprQualifier {\n+        UNBOUNDED_MEMBER_REF,\n+        WITNESS_LOOKUP,\n+        TYPE_OR_UNBOUNDED_MEMBER_REF,\n+        EXPRESSION,\n+        NONE\n+    }\n+\n@@ -1944,1 +1961,1 @@\n-     * method reference or a binary expression. To disambiguate, look for a\n+     * method reference, a witness lookup, or a binary expression. To disambiguate, look for a\n@@ -1948,1 +1965,1 @@\n-    boolean isParameterizedTypePrefix() {\n+    TypeExprQualifier classifyTypeExprQualifier() {\n@@ -1966,1 +1983,1 @@\n-                                return false;\n+                                return TypeExprQualifier.NONE;\n@@ -1989,4 +2006,12 @@\n-                        return\n-                            nextKind == TokenKind.DOT ||\n-                            nextKind == TokenKind.LBRACKET ||\n-                            nextKind == TokenKind.COLCOL;\n+                        if (nextKind == TokenKind.DOT) {\n+                            Token afterDot = S.token(pos + 2);\n+                            return (afterDot.kind == IDENTIFIER && afterDot.name() == names.witness) ?\n+                                    TypeExprQualifier.WITNESS_LOOKUP :\n+                                    TypeExprQualifier.TYPE_OR_UNBOUNDED_MEMBER_REF;\n+                        } else if (nextKind == TokenKind.LBRACKET) {\n+                            return TypeExprQualifier.TYPE_OR_UNBOUNDED_MEMBER_REF;\n+                        } else if (nextKind == TokenKind.COLCOL) {\n+                            return TypeExprQualifier.UNBOUNDED_MEMBER_REF;\n+                        } else {\n+                            return TypeExprQualifier.EXPRESSION;\n+                        }\n@@ -1996,1 +2021,1 @@\n-                    return false;\n+                    return TypeExprQualifier.EXPRESSION;\n@@ -3659,0 +3684,4 @@\n+                if (token.name() == names.witness) {\n+                    flag = Flags.WITNESS;\n+                    break;\n+                }\n@@ -3684,0 +3713,7 @@\n+        if ((flags & Flags.WITNESS) != 0) {\n+            \/\/ a witness symbol is implicitly static\n+            \/\/ we need to set static here, otherwise codegen will misbehave\n+            \/\/ as that looks at the AST modifiers, not at the symbol flags (!!)\n+            flags |= Flags.STATIC;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":47,"deletions":11,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -3127,0 +3127,41 @@\n+# 0: type\n+compiler.err.cant.resolve.witness=\\\n+    cannot find witness\\n\\\n+    type: {0}\n+\n+# 0: type, 1: message segment\n+compiler.err.bad.witness.decl=\\\n+    invalid type {0} in witness declaration\\n\\\n+    ({1})\n+\n+compiler.misc.unsupported.wildcards=\\\n+    Top-level wildcards not supported in witness declaration\n+\n+compiler.misc.type.var.in.witness=\\\n+    Type-variables not supported in witness lookup\n+\n+compiler.misc.witness.must.be.generic.interface=\\\n+    Witness type must be a generic interface\n+\n+# 0: set of flag or string\n+compiler.misc.witness.inaccessible=\\\n+    Witness declaration has weaker access privileges; expected {0}\n+\n+# 0: type\n+compiler.misc.witness.must.refer.to.site=\\\n+    Witness type must refer to enclosing type {0}\n+\n+# 0: type, 1: message segment\n+compiler.err.bad.witness.lookup.type=\\\n+    Bad witness lookup type {0}\\n\\\n+    ({1})\n+\n+# 0: symbol, 1: symbol, 2: message segment\n+compiler.err.witness.clash=\\\n+    Witness {0} clashes with {1}\\n\\\n+    ({2})\n+\n+# 0: type\n+compiler.misc.witness.clash.same.type=\\\n+    Witnesses have the same type {0}\n+\n@@ -3169,0 +3210,3 @@\n+compiler.misc.kindname.witness=\\\n+    witness\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,0 +240,3 @@\n+    \/\/ type classes\n+    public final Name witness;\n+\n@@ -431,0 +434,3 @@\n+\n+        \/\/ type classes\n+        witness = fromString(\"__witness\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -227,0 +227,13 @@\n+\n+# type classes (experimental)\n+compiler.err.cant.resolve.witness\n+compiler.misc.kindname.witness\n+compiler.err.bad.witness.decl\n+compiler.err.bad.witness.lookup.type\n+compiler.misc.unsupported.wildcards\n+compiler.misc.witness.must.refer.to.site\n+compiler.misc.witness.must.be.generic.interface\n+compiler.misc.type.var.in.witness\n+compiler.err.witness.clash\n+compiler.misc.witness.clash.same.type\n+compiler.misc.witness.inaccessible\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary negative tests for bad provides declarations\n+ * @compile\/fail\/ref=BadWitnessDecls.out -XDrawDiagnostics BadWitnessDecls.java\n+ *\/\n+\n+import java.util.List;\n+\n+public class BadWitnessDecls {\n+    interface Foo<X> {\n+        __witness List<String> W1 = List.of(); \/\/ ok, but no reference to Foo\n+        __witness Foo<? extends String> W2 = new Foo<String>() { }; \/\/ error, wildcards\n+    }\n+\n+    static class Bar<X> {\n+        __witness Bar<String> W3 = new Bar<String>() { }; \/\/ error, not an interface\n+    }\n+\n+    interface Barf {\n+        __witness Barf W4 = new Barf() { }; \/\/ error, not generic\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/BadWitnessDecls.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+BadWitnessDecls.java:11:32: compiler.err.bad.witness.decl: java.util.List<java.lang.String>, (compiler.misc.witness.must.refer.to.site: BadWitnessDecls.Foo<X>)\n+BadWitnessDecls.java:12:41: compiler.err.bad.witness.decl: BadWitnessDecls.Foo<? extends java.lang.String>, (compiler.misc.unsupported.wildcards)\n+BadWitnessDecls.java:16:31: compiler.err.bad.witness.decl: BadWitnessDecls.Bar<java.lang.String>, (compiler.misc.witness.must.be.generic.interface)\n+BadWitnessDecls.java:20:24: compiler.err.bad.witness.decl: BadWitnessDecls.Barf, (compiler.misc.witness.must.be.generic.interface)\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/BadWitnessDecls.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.runtime.WitnessSupport;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary negative test for bad dynamic witness lookup\n+ *\/\n+public class BadWitnessDynamicLookup<Z> {\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface Expected {\n+        String value();\n+    }\n+\n+    interface Foo<X> { }\n+\n+    interface Bar { }\n+\n+    @Expected(\"Unsupported toplevel wildcard\")\n+    Foo<? extends Bar> f1 = null; \/\/ error, captured type-variable\n+    @Expected(\"Unsupported type variable\")\n+    Foo<Z> f2 = null; \/\/ error, declared type-variable\n+    @Expected(\"Witness is not a generic type\")\n+    Bar f3 = null; \/\/ error, not generic\n+\n+    public static void main(String[] args) {\n+        for (Field f : BadWitnessDynamicLookup.class.getDeclaredFields()) {\n+            Expected expected = f.getAnnotation(Expected.class);\n+            assertThrows(() -> WitnessSupport.lookupWitness(MethodHandles.lookup(), f.getGenericType()), IllegalArgumentException.class, expected);\n+        }\n+    }\n+\n+    static <T> void assertThrows(Supplier<T> supplier, Class<? extends Throwable> exceptionClass, Expected expected) {\n+        try {\n+            supplier.get();\n+            throw new AssertionError(\"Expected exception not thrown\");\n+        } catch (Throwable ex) {\n+            if (!ex.getClass().equals(exceptionClass)) {\n+                throw new AssertionError(\"Unexpected exception thrown: \" + ex.getClass().getName());\n+            } else if (!ex.getMessage().contains(expected.value())) {\n+                throw new AssertionError(\"Unexpected exception message: \" + ex.getMessage());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/BadWitnessDynamicLookup.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary negative test for bad witness lookup\n+ * @compile\/fail\/ref=BadWitnessLookup.out -XDrawDiagnostics BadWitnessLookup.java\n+ *\/\n+class BadWitnessLookup {\n+    interface Foo<X> { }\n+\n+    static class Bar {\n+        __witness Foo<Bar> FOO_W = new Foo<Bar>() { };\n+    }\n+\n+    static class Baz<X> { }\n+\n+    interface Barf { }\n+\n+    <Z> void test() {\n+        Foo<Bar> fb = Foo<Bar>.__witness; \/\/ ok\n+        Foo<? extends Bar> fwb = Foo<? extends Bar>.__witness; \/\/ error, captured type-variable\n+        Foo<Z> fwb = Foo<Z>.__witness; \/\/ error, declared type-variable\n+        Foo<String> fs = Foo<String>.__witness; \/\/ error, not found\n+        Baz<Bar> bt = Baz<Bar>.__witness; \/\/ error, not an interface\n+        Barf b = Barf.__witness; \/\/ error, not generic\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/BadWitnessLookup.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+BadWitnessLookup.java:19:53: compiler.err.bad.witness.lookup.type: BadWitnessLookup.Foo<compiler.misc.type.captureof: 1, ? extends BadWitnessLookup.Bar>, (compiler.misc.type.var.in.witness)\n+BadWitnessLookup.java:20:16: compiler.err.already.defined: kindname.variable, fwb, kindname.method, <Z>test()\n+BadWitnessLookup.java:20:29: compiler.err.bad.witness.lookup.type: BadWitnessLookup.Foo<Z>, (compiler.misc.type.var.in.witness)\n+BadWitnessLookup.java:21:38: compiler.err.cant.resolve.witness: BadWitnessLookup.Foo<java.lang.String>\n+BadWitnessLookup.java:22:32: compiler.err.bad.witness.lookup.type: BadWitnessLookup.Baz<BadWitnessLookup.Bar>, (compiler.misc.witness.must.be.generic.interface)\n+BadWitnessLookup.java:23:22: compiler.err.bad.witness.lookup.type: BadWitnessLookup.Barf, (compiler.misc.witness.must.be.generic.interface)\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/BadWitnessLookup.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+import java.util.function.Function;\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Test for witness lookup which violates type-variable bounds\n+ * @compile\/fail\/ref=BadWitnessLookupBounds.out -XDrawDiagnostics BadWitnessLookupBounds.java\n+ *\/\n+class BadWitnessLookupBounds {\n+    interface Comparator<X> {\n+        int compare(X a, X b);\n+\n+        __witness <Z extends Comparable<Z>> Comparator<Z> INT() {\n+            return (a, b) -> a.compareTo(b);\n+        }\n+    }\n+\n+    interface Convertible<X, Y> {\n+        Y convertTo(X a);\n+\n+        __witness <Z> Convertible<Z, Z> IDENTITY() {\n+            return a -> a;\n+        }\n+    }\n+\n+    void testComparator() {\n+        var r = Comparator<Runnable>.__witness; \/\/ fail\n+        var s = Comparator<String>.__witness; \/\/ ok\n+        var i = Comparator<Integer>.__witness; \/\/ ok\n+    }\n+\n+    void testConvertible() {\n+        var is = Convertible<Integer, String>.__witness; \/\/ fail\n+        var ss = Convertible<String, String>.__witness; \/\/ ok\n+        var ii = Convertible<Integer, Integer>.__witness; \/\/ ok\n+        var si = Convertible<String, Integer>.__witness; \/\/ fail\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/BadWitnessLookupBounds.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+BadWitnessLookupBounds.java:26:38: compiler.err.cant.resolve.witness: BadWitnessLookupBounds.Comparator<java.lang.Runnable>\n+BadWitnessLookupBounds.java:32:47: compiler.err.cant.resolve.witness: BadWitnessLookupBounds.Convertible<java.lang.Integer,java.lang.String>\n+BadWitnessLookupBounds.java:35:47: compiler.err.cant.resolve.witness: BadWitnessLookupBounds.Convertible<java.lang.String,java.lang.Integer>\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/BadWitnessLookupBounds.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary check that outer classes can't witness inner classes\n+ * @compile\/fail\/ref=InnerClassLookup.out -XDrawDiagnostics InnerClassLookup.java\n+ *\/\n+class InnerClassLookup {\n+    static class Outer {\n+        __witness U<Inner> U = null;\n+\n+        class Inner { }\n+\n+        void test() {\n+            var x = U<Inner>.__witness;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/InnerClassLookup.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+InnerClassLookup.java:8:19: compiler.err.cant.resolve.location: kindname.class, U, , , (compiler.misc.location: kindname.class, InnerClassLookup.Outer, null)\n+InnerClassLookup.java:13:21: compiler.err.cant.resolve.location: kindname.class, U, , , (compiler.misc.location: kindname.class, InnerClassLookup.Outer, null)\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/InnerClassLookup.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for type class generic lifting\n+ *\/\n+\n+public class LiftTest {\n+    interface Monoid<X> {\n+        X zero();\n+        X add(X x1, X x2);\n+    }\n+\n+    record MyInt(int value) {\n+\n+        __witness Monoid<MyInt> MONOID = new Monoid<>() {\n+            public MyInt add(MyInt m1, MyInt m2) {\n+                return new MyInt(m1.value + m2.value);\n+            }\n+            public MyInt zero() {\n+                return new MyInt(0);\n+            }\n+        };\n+    }\n+\n+    record Box<X>(X x) {\n+        __witness <Z> Monoid<Box<Z>> monoid(Monoid<Z> monoidZ) {\n+            return new Monoid<>() {\n+                public Box<Z> zero() {\n+                    return new Box<>(monoidZ.zero());\n+                }\n+                public Box<Z> add(Box<Z> b1, Box<Z> b2) {\n+                    return new Box<>(monoidZ.add(b1.x, b2.x));\n+                }\n+            };\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        testMonoid(Monoid<Box<MyInt>>.__witness); \/\/ implicit\/implicit\n+        testMonoid(Box.monoid(Monoid<MyInt>.__witness)); \/\/ explicit\/implicit\n+        testMonoid(Box.monoid(MyInt.MONOID)); \/\/ explicit\/explicit\n+    }\n+\n+    static void testMonoid(Monoid<Box<MyInt>> mm) {\n+        checkEquals(mm.add(new Box<>(new MyInt(1)), new Box<>(new MyInt(42))), new Box<>(new MyInt(43)));\n+        checkEquals(mm.zero(), new Box<>(new MyInt(0)));\n+    }\n+\n+    static void checkEquals(Object o1, Object o2) {\n+        if (!o1.equals(o2)) throw new AssertionError();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/LiftTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary check that a non-existent type class in a witness lookup doesn't crash javac\n+ * @compile\/fail\/ref=NonExistentTypeClass.out -XDrawDiagnostics NonExistentTypeClass.java\n+ *\/\n+\n+class NonExistentTypeClass {\n+\n+    interface TC_f<X> {\n+        __witness NonExistent<String> NON_EXISTENT_FIELD = null;\n+    }\n+    interface TC_m<X> {\n+        __witness NonExistent<String> NON_EXISTENT_METHOD() {\n+            return null;\n+        }\n+    }\n+\n+    interface TC_gm<X> {\n+        __witness <Z> NonExistent<Z> NON_EXISTENT_GENERIC_METHOD() {\n+            return null;\n+        }\n+    }\n+\n+    void test() {\n+        Object o1 = TC_f<String>.__witness;\n+        Object o2 = TC_m<String>.__witness;\n+        Object o3 = TC_gm<String>.__witness;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/NonExistentTypeClass.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+NonExistentTypeClass.java:10:19: compiler.err.cant.resolve.location: kindname.class, NonExistent, , , (compiler.misc.location: kindname.interface, NonExistentTypeClass.TC_f<X>, null)\n+NonExistentTypeClass.java:13:19: compiler.err.cant.resolve.location: kindname.class, NonExistent, , , (compiler.misc.location: kindname.interface, NonExistentTypeClass.TC_m<X>, null)\n+NonExistentTypeClass.java:19:23: compiler.err.cant.resolve.location: kindname.class, NonExistent, , , (compiler.misc.location: kindname.interface, NonExistentTypeClass.TC_gm<X>, null)\n+NonExistentTypeClass.java:25:34: compiler.err.cant.resolve.witness: NonExistentTypeClass.TC_f<java.lang.String>\n+NonExistentTypeClass.java:26:34: compiler.err.cant.resolve.witness: NonExistentTypeClass.TC_m<java.lang.String>\n+NonExistentTypeClass.java:27:35: compiler.err.cant.resolve.witness: NonExistentTypeClass.TC_gm<java.lang.String>\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/NonExistentTypeClass.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for numeric type class hierarchy\n+ * @run junit\/othervm NumericTypeClassTest\n+ *\/\n+public class NumericTypeClassTest {\n+    interface Eq<X> {\n+        boolean eq(X x1, X x2);\n+\n+        __witness Eq<Integer> INT = (x1, x2) -> x1 == x2;\n+    }\n+\n+    interface Ord<X> extends Eq<X> {\n+        int compare(X x1, X x2);\n+\n+        __witness Ord<Integer> INT = new Ord<>() {\n+            public int compare(Integer x, Integer y) {\n+                return x.compareTo(y);\n+            }\n+            public boolean eq(Integer x, Integer y) {\n+                return Eq<Integer>.__witness.eq(x, y);\n+            }\n+        };\n+    }\n+\n+    interface Num<X> extends Eq<X> {\n+        X plus(X a, X b);\n+        X minus(X a, X b);\n+        X mul(X a, X b);\n+\n+        __witness Num<Integer> INT = new Num<>() {\n+            public Integer mul(Integer x, Integer y) {\n+                return x * y;\n+            }\n+            public Integer plus(Integer x, Integer y) {\n+                return x + y;\n+            }\n+            public Integer minus(Integer x, Integer y) {\n+                return x - y;\n+            }\n+            public boolean eq(Integer x, Integer y) {\n+                return Eq<Integer>.__witness.eq(x, y);\n+            }\n+        };\n+    }\n+\n+    interface Enumeration<X> {\n+        X succ(X x);\n+        X pred(X x);\n+\n+        __witness Enumeration<Integer> INT = new Enumeration<>() {\n+            public Integer succ(Integer x) {\n+                return x + 1;\n+            }\n+            public Integer pred(Integer x) {\n+                return x - 1;\n+            }\n+        };\n+    }\n+\n+    interface Bounded<X> {\n+        X min();\n+        X max();\n+\n+        __witness Bounded<Integer> INT = new Bounded<>() {\n+            public Integer max() {\n+                return Integer.MAX_VALUE;\n+            }\n+            public Integer min() {\n+                return Integer.MIN_VALUE;\n+            }\n+        };\n+    }\n+\n+    interface Integral<X> extends Num<X>, Ord<X>, Enumeration<X> {\n+        X div(X a, X b);\n+\n+        __witness Integral<Integer> INT = new Integral<>() {\n+            public Integer div(Integer x, Integer y) {\n+                return x \/ y;\n+            }\n+            public Integer succ(Integer x) {\n+                return Enumeration<Integer>.__witness.succ(x);\n+            }\n+            public Integer pred(Integer x) {\n+                return Enumeration<Integer>.__witness.pred(x);\n+            }\n+            public Integer mul(Integer x, Integer y) {\n+                return Num<Integer>.__witness.mul(x, y);\n+            }\n+            public Integer plus(Integer x, Integer y) {\n+                return Num<Integer>.__witness.plus(x, y);\n+            }\n+            public Integer minus(Integer x, Integer y) {\n+                return Num<Integer>.__witness.minus(x, y);\n+            }\n+            public boolean eq(Integer x, Integer y) {\n+                return Eq<Integer>.__witness.eq(x, y);\n+            }\n+            public int compare(Integer x, Integer y) {\n+                return Ord<Integer>.__witness.compare(x, y);\n+            }\n+        };\n+    }\n+\n+    @Test\n+    public void testEq() {\n+        testEq(Eq<Integer>.__witness);\n+    }\n+\n+    @Test\n+    public void testOrd() {\n+        testOrd(Ord<Integer>.__witness);\n+        testEq(Ord<Integer>.__witness);\n+    }\n+\n+    @Test\n+    public void testEnum() {\n+        testEnum(Enumeration<Integer>.__witness);\n+    }\n+\n+    @Test\n+    public void testBounded() {\n+        testBounded(Bounded<Integer>.__witness);\n+    }\n+\n+    @Test\n+    public void testNum() {\n+        testNum(Num<Integer>.__witness);\n+        testEq(Num<Integer>.__witness);\n+    }\n+\n+    @Test\n+    public void testIntegral() {\n+        testIntegral(Integral<Integer>.__witness);\n+        testNum(Integral<Integer>.__witness);\n+        testOrd(Integral<Integer>.__witness);\n+        testEnum(Integral<Integer>.__witness);\n+    }\n+\n+    void testEq(Eq<Integer> eq) {\n+        assertFalse(eq.eq(1, 3));\n+        assertTrue(eq.eq(3, 3));\n+    }\n+\n+    void testOrd(Ord<Integer> ord) {\n+        assertTrue(ord.compare(1, 3) < 0);\n+        assertTrue(ord.compare(3, 1) > 0);\n+        assertTrue(ord.compare(3, 3) == 0);\n+    }\n+\n+    void testEnum(Enumeration<Integer> en) {\n+        assertEquals(en.succ(1), 2);\n+        assertEquals(en.pred(2), 1);\n+    }\n+\n+    void testBounded(Bounded<Integer> bounded) {\n+        assertEquals(bounded.max(), Integer.MAX_VALUE);\n+        assertEquals(bounded.min(), Integer.MIN_VALUE);\n+    }\n+\n+    void testNum(Num<Integer> num) {\n+        assertEquals(num.plus(1, 2), 3);\n+        assertEquals(num.minus(3, 2), 1);\n+        assertEquals(num.mul(3, 2), 6);\n+    }\n+\n+    void testIntegral(Integral<Integer> intg) {\n+        assertEquals(intg.div(4, 2), 2);\n+        assertEquals(intg.div(5, 2), 2);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/NumericTypeClassTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for type classes and field witnesses\n+ *\/\n+\n+public class TypeClassesFieldSmokeTest {\n+    interface Monoid<X> {\n+        X add(X x1, X x2);\n+        X zero();\n+    }\n+\n+    record MyInt(int value) {\n+\n+        __witness Monoid<MyInt> MONOID = new Monoid<>() {\n+            public MyInt add(MyInt m1, MyInt m2) {\n+                return new MyInt(m1.value + m2.value);\n+            }\n+            public MyInt zero() {\n+                return new MyInt(0);\n+            }\n+        };\n+    };\n+\n+    public static void main(String[] args) {\n+        testMonoid(Monoid<MyInt>.__witness); \/\/ implicit\n+        testMonoid(MyInt.MONOID); \/\/ explicit\n+    }\n+\n+    static void testMonoid(Monoid<MyInt> mm) {\n+        check(mm.add(new MyInt(1), new MyInt(42)).equals(new MyInt(43)));\n+        check(mm.zero().equals(new MyInt(0)));\n+    }\n+\n+    static void check(boolean cond) {\n+        if (!cond) throw new AssertionError();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/TypeClassesFieldSmokeTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for type classes and generic method witnesses\n+ *\/\n+\n+public class TypeClassesGenericMethodSmokeTest {\n+    interface Convertible<A, B> {\n+        B convertTo(A a);\n+    }\n+\n+    record Box<X>(X x) {\n+        __witness <Z> Convertible<Box<Z>, Z> convBox() {\n+            return box -> box.x();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        testConversion(42, Convertible<Box<Integer>, Integer>.__witness); \/\/ implicit\n+        testConversion(42, Box.convBox()); \/\/ explicit\n+        testConversion(new Box<>(42), Convertible<Box<Box<Integer>>, Box<Integer>>.__witness); \/\/ implicit\n+        testConversion(new Box<>(42), Box.convBox()); \/\/ explicit\n+        testConversion(new Box<>(new Box<>(42)), Convertible<Box<Box<Box<Integer>>>, Box<Box<Integer>>>.__witness); \/\/ implicit\n+        testConversion(new Box<>(new Box<>(42)), Box.convBox()); \/\/ explicit\n+    }\n+\n+    static <Z> void testConversion(Z expected, Convertible<Box<Z>, Z> convertible) {\n+        checkEquals(expected, convertible.convertTo(new Box<>(expected)));\n+    }\n+\n+    static void checkEquals(Object o1, Object o2) {\n+        if (!o1.equals(o2)) throw new AssertionError();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/TypeClassesGenericMethodSmokeTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for type classes and method witnesses\n+ *\/\n+\n+public class TypeClassesMethodSmokeTest {\n+    interface Monoid<X> {\n+        X add(X x1, X x2);\n+        X zero();\n+    }\n+\n+    record MyInt(int value) {\n+\n+        __witness Monoid<MyInt> MONOID() {\n+            return new Monoid<>() {\n+                public MyInt add(MyInt m1, MyInt m2) {\n+                    return new MyInt(m1.value + m2.value);\n+                }\n+                public MyInt zero() {\n+                    return new MyInt(0);\n+                }\n+            };\n+        }\n+    };\n+\n+    public static void main(String[] args) {\n+        testMonoid(Monoid<MyInt>.__witness); \/\/ implicit\n+        testMonoid(MyInt.MONOID()); \/\/ explicit\n+    }\n+\n+    static void testMonoid(Monoid<MyInt> mm) {\n+        check(mm.add(new MyInt(1), new MyInt(42)).equals(new MyInt(43)));\n+        check(mm.zero().equals(new MyInt(0)));\n+    }\n+\n+    static void check(boolean cond) {\n+        if (!cond) throw new AssertionError();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/TypeClassesMethodSmokeTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Smoke test for subtyping checks in witness lookups\n+ * @compile\/fail\/ref=TypeClassesSubTypingTest.out -XDrawDiagnostics TypeClassesSubTypingTest.java\n+ *\/\n+class TypeClassesSubTypingTest {\n+    interface A<X> { }\n+    interface B<X> extends A<X> { }\n+\n+    interface C<W> { A<W> a(); }\n+    interface D<X> extends C<X> { }\n+\n+    static class E {\n+        __witness B<E> BE = new B<>() { };\n+        __witness D<E> DE(A<E> az) {\n+            return new D<>() {\n+                public A<E> a() {\n+                    return az;\n+                }\n+            };\n+        }\n+    }\n+\n+    void test() {\n+        A<E> ae = A<E>.__witness; \/\/ fail, not an exact match\n+        B<E> be = B<E>.__witness; \/\/ ok, exact match\n+        C<E> ce = C<E>.__witness; \/\/ fail, not an exact match\n+        D<E> de = D<E>.__witness; \/\/ fail, exact match, but D<E> depends on A<E> which is not an exact match\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/TypeClassesSubTypingTest.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+TypeClassesSubTypingTest.java:25:24: compiler.err.cant.resolve.witness: TypeClassesSubTypingTest.A<TypeClassesSubTypingTest.E>\n+TypeClassesSubTypingTest.java:27:24: compiler.err.cant.resolve.witness: TypeClassesSubTypingTest.C<TypeClassesSubTypingTest.E>\n+TypeClassesSubTypingTest.java:28:24: compiler.err.cant.resolve.witness: TypeClassesSubTypingTest.D<TypeClassesSubTypingTest.E>\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/TypeClassesSubTypingTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Matrix test for witness accessibility check\n+ * @compile\/fail\/ref=WitnessAccessCheck.out -XDrawDiagnostics WitnessAccessCheck.java\n+ *\/\n+\n+class WitnessAccessCheck {\n+    interface U<X> { }\n+    interface W<X> { }\n+    interface Y<X> { }\n+    interface Z<X> { }\n+\n+    public static class A_pub {\n+        private __witness U<A_pub> U_pri = null; \/\/ error, weaker access\n+        protected __witness W<A_pub> W_pro = null; \/\/ error, weaker access\n+        public __witness Y<A_pub> Y_pub = null; \/\/ ok\n+        __witness Z<A_pub> Z_pkg = null; \/\/ error, weaker access\n+    }\n+\n+    private static class A_priv {\n+        private __witness U<A_priv> U_pri = null; \/\/ ok\n+        protected __witness W<A_priv> W_pro = null; \/\/ ok\n+        public __witness Y<A_priv> Y_pub = null; \/\/ ok\n+        __witness Z<A_priv> Z_pkg = null; \/\/ ok\n+    }\n+\n+    protected static class A_prot {\n+        private __witness U<A_prot> U_pri = null; \/\/ error, weaker access\n+        protected __witness W<A_prot> W_pro = null; \/\/ ok\n+        public __witness Y<A_prot> Y_pub = null; \/\/ ok\n+        __witness Z<A_prot> Z_pkg = null; \/\/ error, weaker access\n+    }\n+\n+    static class A_pkg {\n+        private __witness U<A_pkg> U_pri = null; \/\/ error, weaker access\n+        protected __witness W<A_pkg> W_pro = null; \/\/ ok\n+        public __witness Y<A_pkg> Y_pub = null; \/\/ ok\n+        __witness Z<A_pkg> Z_pkg = null; \/\/ ok\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessAccessCheck.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+WitnessAccessCheck.java:14:36: compiler.err.bad.witness.decl: WitnessAccessCheck.U<WitnessAccessCheck.A_pub>, (compiler.misc.witness.inaccessible: public)\n+WitnessAccessCheck.java:15:38: compiler.err.bad.witness.decl: WitnessAccessCheck.W<WitnessAccessCheck.A_pub>, (compiler.misc.witness.inaccessible: public)\n+WitnessAccessCheck.java:17:28: compiler.err.bad.witness.decl: WitnessAccessCheck.Z<WitnessAccessCheck.A_pub>, (compiler.misc.witness.inaccessible: public)\n+WitnessAccessCheck.java:28:37: compiler.err.bad.witness.decl: WitnessAccessCheck.U<WitnessAccessCheck.A_prot>, (compiler.misc.witness.inaccessible: protected)\n+WitnessAccessCheck.java:31:29: compiler.err.bad.witness.decl: WitnessAccessCheck.Z<WitnessAccessCheck.A_prot>, (compiler.misc.witness.inaccessible: protected)\n+WitnessAccessCheck.java:35:36: compiler.err.bad.witness.decl: WitnessAccessCheck.U<WitnessAccessCheck.A_pkg>, (compiler.misc.witness.inaccessible: package)\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessAccessCheck.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Smoke test for witness declaration clashes\n+ * @compile\/fail\/ref=WitnessClash.out -XDrawDiagnostics WitnessClash.java\n+ *\/\n+class WitnessClash {\n+    interface T<X> { }\n+\n+    interface U<X> extends T<X> { }\n+    interface W<X> extends T<X> { }\n+\n+    interface G<X> extends T<K> { }\n+    interface H<X> extends T<K> { }\n+\n+    static class K { }\n+\n+    \/\/ witness field only\n+    static class A {\n+        __witness T<A> A1 = null; \/\/ clash with A2\n+        __witness T<A> A2 = null; \/\/ clash with A1 (but no duplicate error)\n+    }\n+\n+    \/\/ witness method only\n+    static class B {\n+        __witness T<B> B1() { return null; } \/\/ clash with B2\n+        __witness T<B> B2() { return null; } \/\/ clash with B1 (but no duplicate error)\n+    }\n+\n+    \/\/ witness field and method\n+    static class C {\n+        __witness T<C> C1 = null; \/\/ clash with C2\n+        __witness T<C> C2() { return null; } \/\/ clash with C1 (but no duplicate error)\n+    }\n+\n+    \/\/ generic vs. non-generic clash\n+    static class D<X> {\n+        __witness T<D<Integer>> D1 = null; \/\/ clash with D2 (where Z == Integer)\n+        __witness <Z extends Number> T<D<Z>> D2() { return null; } \/\/ clash by D1 (where Z == Integer, but no duplicate error)\n+        __witness <Z extends StringBuilder> T<D<Z>> D3() { return null; } \/\/ ok\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessClash.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+WitnessClash.java:19:24: compiler.err.witness.clash: A1, A2, (compiler.misc.witness.clash.same.type: WitnessClash.T<WitnessClash.A>)\n+WitnessClash.java:25:24: compiler.err.witness.clash: B1(), B2(), (compiler.misc.witness.clash.same.type: WitnessClash.T<WitnessClash.B>)\n+WitnessClash.java:31:24: compiler.err.witness.clash: C1, C2(), (compiler.misc.witness.clash.same.type: WitnessClash.T<WitnessClash.C>)\n+WitnessClash.java:37:33: compiler.err.witness.clash: D1, <Z>D2(), (compiler.misc.witness.clash.same.type: WitnessClash.T<WitnessClash.D<java.lang.Integer>>)\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessClash.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Check that the witness lookup follows expected order\n+ * @compile\/fail\/ref=WitnessLookupPriorityTest.out -XDrawDiagnostics WitnessLookupPriorityTest.java\n+ *\/\n+public class WitnessLookupPriorityTest {\n+    interface Triple<X, Y, Z> {\n+        String name();\n+    }\n+\n+    class A {\n+        __witness Triple<A, B, C> W1 = () -> \"A\";\n+        __witness Triple<A, C, B> W2 = () -> \"A\";\n+        __witness Triple<B, A, C> W3 = () -> \"A\";\n+        __witness Triple<B, C, A> W4 = () -> \"A\";\n+        __witness Triple<C, A, B> W5 = () -> \"A\";\n+        __witness Triple<C, B, A> W6 = () -> \"A\";\n+    }\n+\n+    class B {\n+        __witness Triple<A, B, C> W1 = () -> \"B\";\n+        __witness Triple<A, C, B> W2 = () -> \"B\";\n+        __witness Triple<B, A, C> W3 = () -> \"B\";\n+        __witness Triple<B, C, A> W4 = () -> \"B\";\n+        __witness Triple<C, A, B> W5 = () -> \"B\";\n+        __witness Triple<C, B, A> W6 = () -> \"B\";\n+    }\n+\n+    class C {\n+        __witness Triple<A, B, C> W1 = () -> \"C\";\n+        __witness Triple<A, C, B> W2 = () -> \"C\";\n+        __witness Triple<B, A, C> W3 = () -> \"C\";\n+        __witness Triple<B, C, A> W4 = () -> \"C\";\n+        __witness Triple<C, A, B> W5 = () -> \"C\";\n+        __witness Triple<C, B, A> W6= () -> \"C\";\n+    }\n+\n+    public static void checkLeftToRight() {\n+        checkEquals(Triple<A, B, C>.__witness.name(), \"A\"); \/\/ ambiguous\n+        checkEquals(Triple<A, C, B>.__witness.name(), \"A\"); \/\/ ambiguous\n+        checkEquals(Triple<B, A, C>.__witness.name(), \"B\"); \/\/ ambiguous\n+        checkEquals(Triple<B, C, A>.__witness.name(), \"B\"); \/\/ ambiguous\n+        checkEquals(Triple<C, A, B>.__witness.name(), \"C\"); \/\/ ambiguous\n+        checkEquals(Triple<C, B, A>.__witness.name(), \"C\"); \/\/ ambiguous\n+    }\n+\n+    interface Mono<X> {\n+        String name();\n+    }\n+\n+    class D<X> {\n+        __witness Mono<D<E<F<String>>>> W1 = () -> \"D\";\n+        __witness Mono<D<F<E<String>>>> W2 = () -> \"D\";\n+        __witness Mono<E<D<F<String>>>> W3 = () -> \"D\";\n+        __witness Mono<E<F<D<String>>>> W4 = () -> \"D\";\n+        __witness Mono<F<D<E<String>>>> W5 = () -> \"D\";\n+        __witness Mono<F<E<D<String>>>> W6 = () -> \"D\";\n+    }\n+\n+    class E<X> {\n+        __witness Mono<D<E<F<String>>>> W1 = () -> \"E\";\n+        __witness Mono<D<F<E<String>>>> W2 = () -> \"E\";\n+        __witness Mono<E<D<F<String>>>> W3 = () -> \"E\";\n+        __witness Mono<E<F<D<String>>>> W4 = () -> \"E\";\n+        __witness Mono<F<D<E<String>>>> W5 = () -> \"E\";\n+        __witness Mono<F<E<D<String>>>> W6 = () -> \"E\";\n+    }\n+\n+    class F<X> {\n+        __witness Mono<D<E<F<String>>>> W1 = () -> \"F\";\n+        __witness Mono<D<F<E<String>>>> W2 = () -> \"F\";\n+        __witness Mono<E<D<F<String>>>> W3 = () -> \"F\";\n+        __witness Mono<E<F<D<String>>>> W4 = () -> \"F\";\n+        __witness Mono<F<D<E<String>>>> W5 = () -> \"F\";\n+        __witness Mono<F<E<D<String>>>> W6 = () -> \"F\";\n+    }\n+\n+    public static void checkInnerToOuter() {\n+        checkEquals(Mono<D<E<F<String>>>>.__witness.name(), \"F\");\n+        checkEquals(Mono<D<F<E<String>>>>.__witness.name(), \"E\");\n+        checkEquals(Mono<E<D<F<String>>>>.__witness.name(), \"F\");\n+        checkEquals(Mono<E<F<D<String>>>>.__witness.name(), \"D\");\n+        checkEquals(Mono<F<D<E<String>>>>.__witness.name(), \"E\");\n+        checkEquals(Mono<F<E<D<String>>>>.__witness.name(), \"D\");\n+    }\n+\n+    public static void main(String[] args) {\n+        checkLeftToRight();\n+        checkInnerToOuter();\n+    }\n+\n+    static void checkEquals(Object found, Object expected) {\n+        if (!found.equals(expected)) throw new AssertionError(String.format(\"Found %s, expected %s\", found, expected));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessLookupPriorityTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+WitnessLookupPriorityTest.java:39:37: compiler.err.ref.ambiguous: W1, kindname.witness, W1, WitnessLookupPriorityTest.A, kindname.witness, W1, WitnessLookupPriorityTest.B\n+WitnessLookupPriorityTest.java:40:37: compiler.err.ref.ambiguous: W2, kindname.witness, W2, WitnessLookupPriorityTest.A, kindname.witness, W2, WitnessLookupPriorityTest.C\n+WitnessLookupPriorityTest.java:41:37: compiler.err.ref.ambiguous: W3, kindname.witness, W3, WitnessLookupPriorityTest.B, kindname.witness, W3, WitnessLookupPriorityTest.A\n+WitnessLookupPriorityTest.java:42:37: compiler.err.ref.ambiguous: W4, kindname.witness, W4, WitnessLookupPriorityTest.B, kindname.witness, W4, WitnessLookupPriorityTest.C\n+WitnessLookupPriorityTest.java:43:37: compiler.err.ref.ambiguous: W5, kindname.witness, W5, WitnessLookupPriorityTest.C, kindname.witness, W5, WitnessLookupPriorityTest.A\n+WitnessLookupPriorityTest.java:44:37: compiler.err.ref.ambiguous: W6, kindname.witness, W6, WitnessLookupPriorityTest.C, kindname.witness, W6, WitnessLookupPriorityTest.B\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessLookupPriorityTest.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for witness declaration clashes\n+ * @compile WitnessNoClash.java\n+ *\/\n+class WitnessNoClash {\n+    interface T<X> { }\n+\n+    interface U<X> extends T<X> { }\n+    interface W<X> extends T<X> { }\n+\n+    static class K { }\n+\n+    \/\/ witness field only\n+    static class A {\n+        __witness U<A> U = null; \/\/ ok, common super with W (T<A>)\n+        __witness W<A> W = null; \/\/ ok, common super with U (T<A>)\n+    }\n+\n+    \/\/ witness method only\n+    static class B {\n+        __witness U<B> U() { return null; } \/\/ ok, common super with W (T<B>)\n+        __witness W<B> W() { return null; } \/\/ ok, common super with U (T<B>)\n+    }\n+\n+    \/\/ witness field and method\n+    static class C {\n+        __witness U<C> U = null; \/\/ ok, common super with W (T<C>)\n+        __witness W<C> W() { return null; } \/\/ ok, common super with U (T<C>)\n+    }\n+\n+    \/\/ generic vs. non-generic common super\n+    static class E<X> {\n+        __witness <Z> U<E<Integer>> E1() { return null; } \/\/ ok, common super with E2 (T<Z>, where Z == Integer)\n+        __witness <Z extends Number> W<E<Z>> E2() { return null; } \/\/ ok, common super with E1 (T<Z>, where Z == Integer)\n+        __witness <Z extends StringBuilder> W<E<Z>> E3() { return null; } \/\/ ok\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessNoClash.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check that redundant modifiers on witness fields\/methods are accepted\n+ * @compile WitnessRedundantModifiers.java\n+ *\/\n+\n+class WitnessRedundantModifiers {\n+    interface One<X> { }\n+    interface Two<X> { }\n+    interface Three<X> { }\n+    static class E {\n+        __witness static final One<E> ONE = null;\n+        __witness static Two<E> TWO = null;\n+        __witness static Three<E> THREE() { return null; }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessRedundantModifiers.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check that the witness lookup supports various types\n+ *\/\n+public class WitnessTypeTraversalTest {\n+    interface Mono<X> {\n+        int id();\n+    }\n+\n+    interface Box<X> { }\n+\n+    interface Provider {\n+        __witness Mono<Provider> W1 = () -> 1;\n+        __witness Mono<Box<Provider>> W2 = () -> 2;\n+        __witness Mono<Box<? extends Provider>> W3 = () -> 3;\n+        __witness Mono<Box<? super Provider>> W4 = () -> 4;\n+        __witness Mono<Box<Provider[]>> W5 = () -> 5;\n+        __witness Mono<Box<? extends Provider[]>> W6 = () -> 6;\n+        __witness Mono<Box<? super Provider[]>> W7 = () -> 7;\n+        __witness Mono<Box<Provider>[]> W8 = () -> 8;\n+        __witness Mono<Box<? extends Provider>[]> W9 = () -> 9;\n+        __witness Mono<Box<? super Provider>[]> W10 = () -> 10;\n+    }\n+\n+    public static void main(String[] args) {\n+        checkId(Mono<Provider>.__witness.id(), 1);\n+        checkId(Mono<Box<Provider>>.__witness.id(), 2);\n+        checkId(Mono<Box<? extends Provider>>.__witness.id(), 3);\n+        checkId(Mono<Box<? super Provider>>.__witness.id(), 4);\n+        checkId(Mono<Box<Provider[]>>.__witness.id(), 5);\n+        checkId(Mono<Box<? extends Provider[]>>.__witness.id(), 6);\n+        checkId(Mono<Box<? super Provider[]>>.__witness.id(), 7);\n+        checkId(Mono<Box<Provider>[]>.__witness.id(), 8);\n+        checkId(Mono<Box<? extends Provider>[]>.__witness.id(), 9);\n+        checkId(Mono<Box<? super Provider>[]>.__witness.id(), 10);\n+    }\n+\n+    static void checkId(int found, int expected) {\n+        if (found != expected) throw new AssertionError(String.format(\"Found %s, expected %s\", found, expected));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/WitnessTypeTraversalTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+            jdk.compiler\/com.sun.tools.javac.main\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.JarTask\n+ * @run junit\/othervm WitnessResolution01\n+ *\/\n+\n+import java.util.Set;\n+import org.junit.jupiter.api.Test;\n+\n+public class WitnessResolution01 extends WitnessResolutionTest {\n+\n+    @Test\n+    public void checkLeftToRight() {\n+        findWitness(\"T<A, B, C>\", Set.of(\"A\", \"B\", \"C\")).ambiguous();\n+        findWitness(\"T<A, B, C>\", Set.of(\"A\", \"B\")).ambiguous();\n+        findWitness(\"T<A, B, C>\", Set.of(\"B\", \"C\")).ambiguous();\n+        findWitness(\"T<A, B, C>\", Set.of(\"A\", \"C\")).ambiguous();\n+        findWitness(\"T<A, B, C>\", Set.of(\"A\")).success(\"A\");\n+        findWitness(\"T<A, B, C>\", Set.of(\"B\")).success(\"B\");\n+        findWitness(\"T<A, B, C>\", Set.of(\"C\")).success(\"C\");\n+        findWitness(\"T<A, B, C>\", Set.of()).notFound();\n+    }\n+\n+    @Test\n+    public void checkInnerToOuter() {\n+        findWitness(\"A<B<C<D<E>>>>\", Set.of(\"A\", \"B\", \"C\", \"D\", \"E\")).success(\"E\");\n+        findWitness(\"A<B<C<D<E>>>>\", Set.of(\"A\", \"B\", \"C\", \"D\")).success(\"D\");\n+        findWitness(\"A<B<C<D<E>>>>\", Set.of(\"A\", \"B\", \"C\")).success(\"C\");\n+        findWitness(\"A<B<C<D<E>>>>\", Set.of(\"A\", \"B\")).success(\"B\");\n+        findWitness(\"A<B<C<D<E>>>>\", Set.of(\"A\")).success(\"A\");\n+        findWitness(\"A<B<C<D<E>>>>\", Set.of()).notFound();\n+    }\n+\n+    @Test\n+    public void checkDominance() {\n+        findWitness(\"T<A<B<C>>,D<E>>\", Set.of(\"C\", \"E\")).ambiguous(); \/\/ no dominance between E and C (unrelated)\n+        findWitness(\"T<A<B>,B<A>>\", Set.of(\"A\", \"B\")).ambiguous(); \/\/ no dominance between A and B (cycle)\n+        findWitness(\"T<A<C>,A<B>,C<B>>\", Set.of(\"A\", \"B\", \"C\")).success(\"B\"); \/\/ B dominates everything\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/resolution\/WitnessResolution01.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,398 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.Task.Expect;\n+import toolbox.Task.TaskError;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+import toolbox.ToolBox.JavaSource;\n+\n+public abstract class WitnessResolutionTest {\n+\n+    final ToolBox tb = new ToolBox();\n+\n+    static final StackWalker STACK_WALKER = StackWalker.getInstance();\n+\n+    private String testCaseId(StackWalker.StackFrame frame) {\n+        return frame.getClassName() + \"_\" + frame.getMethodName() + \"_\" + frame.getLineNumber();\n+    }\n+\n+    public Result findWitness(String witnessString, Set<String> witnessDeclTypes) {\n+        String testCaseId = STACK_WALKER.walk(frames -> testCaseId(frames.skip(1).findFirst().get()));\n+        Result result = Result.dummy();\n+        for (DeclarationKind dkind : DeclarationKind.values()) {\n+            for (LookupMode lmode : LookupMode.values()) {\n+                TestCase testCase = new TestCase(testCaseId, witnessString, witnessDeclTypes, dkind, lmode);\n+                result = Result.combine(result, testCase.result());\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public interface Result {\n+        void success(String string);\n+        void ambiguous();\n+        void notFound();\n+\n+        static Result combine(Result first, Result second) {\n+            return new Result() {\n+                @Override\n+                public void success(String string) {\n+                    first.success(string);\n+                    second.success(string);\n+                }\n+\n+                @Override\n+                public void ambiguous() {\n+                    first.ambiguous();\n+                    second.ambiguous();\n+                }\n+\n+                @Override\n+                public void notFound() {\n+                    first.notFound();\n+                    second.notFound();\n+                }\n+            };\n+        }\n+\n+        static Result dummy() {\n+            return new Result() {\n+                @Override\n+                public void success(String string) { }\n+                @Override\n+                public void ambiguous() { }\n+                @Override\n+                public void notFound() { }\n+            };\n+        }\n+    }\n+\n+    enum LookupMode {\n+        STATIC,\n+        DYNAMIC;\n+    }\n+\n+    enum DeclarationKind {\n+        FIELD,\n+        METHOD;\n+    }\n+\n+    class TestCase {\n+        final TypeNode witnessType;\n+        final Set<String> witnessDecls;\n+        final List<JavaSource> auxClasses = new ArrayList<>();\n+        final JavaSource mainClass;\n+        final Path base;\n+        final LookupMode lmode;\n+        final DeclarationKind dkind;\n+\n+        static class TemplatedTestClass {\n+            final String template;\n+\n+            TemplatedTestClass(String template) {\n+                this.template = template;\n+            }\n+\n+            JavaSource toSource(String... args) {\n+                String source = template;\n+                for (int i = 0; i < args.length; i++) {\n+                    source = source.replaceAll(\"#\\\\{\" + i + \"\\\\}\", args[i]);\n+                }\n+                return new JavaSource(source);\n+            }\n+\n+            static final TemplatedTestClass STATIC_TEST_CLASS = new TemplatedTestClass(\"\"\"\n+                    class TestStaticLookup {\n+                        public static void main(String[] args) {\n+                            System.out.println(#{0}.__witness.m());\n+                        }\n+                    }\n+                    \"\"\");\n+\n+            static final TemplatedTestClass DYNAMIC_TEST_CLASS = new TemplatedTestClass(\"\"\"\n+                    import java.lang.reflect.Type;\n+                    import java.lang.invoke.MethodHandles;\n+                    import java.lang.runtime.WitnessSupport;\n+\n+                    class TestDynamicLookup {\n+                        public static void main(String[] args) throws Throwable {\n+                            Type type = WitnessSupport.type(MethodHandles.lookup(), \"#{1}\");\n+                            #{0} witness = (#{0})WitnessSupport.lookupWitness(MethodHandles.lookup(), type);\n+                            System.out.println(witness.m());\n+                        }\n+                    }\n+                    \"\"\");\n+\n+            static final TemplatedTestClass AUX_TEST_CLASS = new TemplatedTestClass(\"\"\"\n+                    interface #{0}#{1} {\n+                        #{2}\n+                        #{3}\n+                    }\n+                    \"\"\");\n+        }\n+\n+        TestCase(String id, String witnessTypeString, Set<String> witnessDecls, DeclarationKind dkind, LookupMode lmode) {\n+            this.base = Path.of(id);\n+            this.witnessDecls = witnessDecls;\n+            this.lmode = lmode;\n+            this.dkind = dkind;\n+            GenericTypeParser genericTypeParser = new GenericTypeParser(witnessTypeString);\n+            witnessType = genericTypeParser.parseType();\n+            for (Map.Entry<String, List<TypeNode>> typeReferences : genericTypeParser.typeDictionary.entrySet()) {\n+                int nParameters = typeReferences.getValue().stream().mapToInt(tn -> tn.typeArguments.size()).max().getAsInt();\n+                String typeParameters = nParameters == 0 ? \"\" :\n+                        IntStream.range(0, nParameters).mapToObj(i -> \"X_\" + i).collect(Collectors.joining(\", \", \"<\", \">\"));\n+                String className = typeReferences.getKey();\n+                String witnessDecl = \"\";\n+                if (witnessDecls.contains(className)) {\n+                    witnessDecl = dkind == DeclarationKind.METHOD ?\n+                            \"__witness \" + witnessType + \" W_\" + className + \"() { return () -> \\\"\" + className + \"\\\"; }\" :\n+                            \"__witness \" + witnessType + \" W_\" + className + \" = () -> \\\"\" + className + \"\\\";\";\n+                }\n+                String witnessMethod = witnessType.name.equals(className) ?\n+                        \"String m();\" : \"\";\n+                auxClasses.add(TemplatedTestClass.AUX_TEST_CLASS.toSource(className, typeParameters, witnessDecl, witnessMethod));\n+            }\n+            if (lmode == LookupMode.DYNAMIC) {\n+                mainClass = TemplatedTestClass.DYNAMIC_TEST_CLASS.toSource(witnessType.toString(), witnessType.toSignatureString());\n+            } else {\n+                mainClass = TemplatedTestClass.STATIC_TEST_CLASS.toSource(witnessType.toString());\n+            }\n+        }\n+\n+        Result result() {\n+            return new Result() {\n+                public void success(String string) {\n+                    compileSuccess();\n+                    runSuccess(string);\n+                }\n+\n+                public void ambiguous() {\n+                    if (lmode == LookupMode.STATIC) {\n+                        \/\/ static lookup\n+                        compileFail(\"ambiguous\");\n+                    } else {\n+                        \/\/ dynamic lookup\n+                        compileSuccess();\n+                        runFail(\"Ambiguous\");\n+                    }\n+                }\n+\n+                public void notFound() {\n+                    if (lmode == LookupMode.STATIC) {\n+                        \/\/ static lookup\n+                        compileFail(\"cannot find\");\n+                    } else {\n+                        \/\/ dynamic lookup\n+                        compileSuccess();\n+                        runFail(\"not found\");\n+                    }\n+                }\n+            };\n+        }\n+\n+        private void compileSuccess() {\n+            compile(Expect.SUCCESS, null, null);\n+        }\n+\n+        private void compileFail(String message) {\n+            compile(Expect.FAIL, OutputKind.DIRECT, message);\n+        }\n+\n+        private void runSuccess() {\n+            run(Expect.SUCCESS, null, null);\n+        }\n+\n+        private void runSuccess(String out) {\n+            run(Expect.SUCCESS, OutputKind.STDOUT, out);\n+        }\n+\n+        private void runFail(String message) {\n+            run(Expect.FAIL, OutputKind.STDERR, message);\n+        }\n+\n+        private void compile(Expect expect, OutputKind outputKind, String expected) {\n+            try {\n+                Path src = base.resolve(\"src_\" + lmode + \"_\" + dkind);\n+                Path out = base.resolve(\"out_\" + lmode + \"_\" + dkind);\n+                for (JavaSource auxClass : auxClasses) {\n+                    auxClass.write(src);\n+                }\n+                mainClass.write(src);\n+\n+                JavacTask task = new JavacTask(tb)\n+                        .outdir(Files.createDirectories(out))\n+                        .files(tb.findJavaFiles(src));\n+                taskHelper(task, expect, JavacTask::run, outputKind, expected);\n+            } catch (IOException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+\n+        private void run(Expect expect, OutputKind outputKind, String expected) {\n+            String main = mainClass.getName().replace(\".java\", \"\");\n+            JavaTask task = new JavaTask(tb)\n+                    .classpath(base.resolve(\"out_\" + lmode + \"_\" + dkind).toString())\n+                    .className(main);\n+            taskHelper(task, expect, JavaTask::run, outputKind, expected);\n+        }\n+\n+        AssertionError fail(String msg) {\n+            return new AssertionError(msg);\n+        }\n+\n+        private <T extends Task> void taskHelper(T task, Expect expect, BiFunction<T, Expect, Task.Result> runner, OutputKind outputKind, String expected) {\n+            printTask(task, expect, expected);\n+            Task.Result result = null;\n+            try {\n+                result = runner.apply(task, expect);\n+            } catch (TaskError _) {\n+                String badOutcome = expect == Expect.SUCCESS ? \"failed\" : \"succeeded\";\n+                throw fail(\"task \" + badOutcome + \" unexpectedly\");\n+            }\n+            if (expected != null) {\n+                String out = result.getOutput(outputKind);\n+                if (!out.contains(expected)) {\n+                    System.err.println(out);\n+                    throw fail(\"unexpected output\");\n+                }\n+            }\n+        }\n+\n+        void printTask(Task task, Expect expect, String expected) {\n+            System.err.println(task.name() + \" task; witness = \" + witnessType +\n+                    \" ; declarations = \" + witnessDecls + \" ; expected outcome = \" + expect +\n+                    \" ; expected output = \" + expected + \" ; declaration kind = \" + dkind +\n+                    \" ; lookup mode = \" + lmode);\n+        }\n+    }\n+\n+    public record TypeNode(String name, List<TypeNode> typeArguments) {\n+        @Override\n+        public String toString() {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(name);\n+            if (!typeArguments.isEmpty()) {\n+                String typeArgString = typeArguments.stream()\n+                        .map(TypeNode::toString)\n+                        .collect(Collectors.joining(\", \", \"<\", \">\"));\n+                buf.append(typeArgString);\n+            }\n+            return buf.toString();\n+        }\n+\n+        public String toSignatureString() {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(\"L\" + name);\n+            if (!typeArguments.isEmpty()) {\n+                String typeArgString = typeArguments.stream()\n+                        .map(TypeNode::toSignatureString)\n+                        .collect(Collectors.joining(\"\", \"<\", \">\"));\n+                buf.append(typeArgString);\n+            }\n+            buf.append(\";\");\n+            return buf.toString();\n+        }\n+    }\n+\n+    static class GenericTypeParser {\n+        private final Map<String, List<TypeNode>> typeDictionary = new LinkedHashMap<>();\n+        private final String input;\n+        private int pos;\n+\n+        public GenericTypeParser(String input) {\n+            this.input = input.replaceAll(\"\\\\s+\", \"\");\n+            this.pos = 0;\n+        }\n+\n+        public TypeNode parse() {\n+            return parseType();\n+        }\n+\n+        private TypeNode parseType() {\n+            \/\/ Parse class name\n+            String name = parseIdentifier();\n+\n+            \/\/ Parse generic params, if any\n+            List<TypeNode> typeArguments = new ArrayList<>();\n+            if (peek() == '<') {\n+                next(); \/\/ Skip '<'\n+                typeArguments.add(parseType());\n+                while (peek() == ',') {\n+                    next(); \/\/ Skip ','\n+                    typeArguments.add(parseType());\n+                }\n+                expect('>'); \/\/ Expect '>'\n+            }\n+\n+            TypeNode res = new TypeNode(name, typeArguments);\n+            List<TypeNode> types = typeDictionary.computeIfAbsent(name, k -> new ArrayList<>());\n+            types.add(res);\n+            return res;\n+        }\n+\n+        private String parseIdentifier() {\n+            int start = pos;\n+            while (pos < input.length() && Character.isJavaIdentifierPart(input.charAt(pos))) {\n+                pos++;\n+            }\n+            if (start == pos) {\n+                throw new IllegalStateException(\"Expected identifier at position \" + pos);\n+            }\n+            return input.substring(start, pos);\n+        }\n+\n+        private char peek() {\n+            if (pos < input.length())\n+                return input.charAt(pos);\n+            return (char) -1;\n+        }\n+\n+        private void next() {\n+            input.charAt(pos++);\n+        }\n+\n+        private void expect(char c) {\n+            if (peek() != c)\n+                throw new RuntimeException(\"Expected '\" + c + \"' at position \" + pos);\n+            pos++;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/resolution\/WitnessResolutionTest.java","additions":398,"deletions":0,"binary":false,"changes":398,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Type;\n+import java.lang.runtime.WitnessSupport;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @summary Test for witness lookup which violates type-variable bounds\n+ * @run junit\/othervm BadWitnessLookupBoundsRuntime\n+ *\/\n+class BadWitnessLookupBoundsRuntime {\n+    interface Comparator<X> {\n+        int compare(X a, X b);\n+\n+        __witness <Z extends Comparable<Z>> Comparator<Z> INT() {\n+            return (a, b) -> a.compareTo(b);\n+        }\n+    }\n+\n+    interface Convertible<X, Y> {\n+        Y convertTo(X a);\n+\n+        __witness <Z> Convertible<Z, Z> IDENTITY() {\n+            return a -> a;\n+        }\n+    }\n+\n+    @Test\n+    public void testComparator() {\n+        assertThrows(IllegalArgumentException.class, lookup(type(Comparator.class, Runnable.class)));\n+        assertDoesNotThrow(lookup(type(Comparator.class, String.class)));\n+        assertDoesNotThrow(lookup(type(Comparator.class, Integer.class)));\n+    }\n+\n+    @Test\n+    public void testConvertible() {\n+        assertThrows(IllegalArgumentException.class, lookup(type(Convertible.class, Integer.class, String.class)));\n+        assertDoesNotThrow(lookup(type(Convertible.class, String.class, String.class)));\n+        assertDoesNotThrow(lookup(type(Convertible.class, Integer.class, Integer.class)));\n+        assertThrows(IllegalArgumentException.class, lookup(type(Convertible.class, String.class, Integer.class)));\n+    }\n+\n+    Executable lookup(Type type) {\n+        return () -> WitnessSupport.lookupWitness(MethodHandles.lookup(), type);\n+    }\n+\n+    Type type(Class<?> baseType, Class<?>... typeArgs) {\n+        StringBuilder buf = new StringBuilder();\n+        String baseSig = baseType.describeConstable().get().descriptorString();\n+        buf.append(baseSig, 0, baseSig.length() - 1);\n+        if (typeArgs.length > 0) {\n+            buf.append(\"<\");\n+            for (Class<?> targ : typeArgs) {\n+                buf.append(targ.describeConstable().get().descriptorString());\n+            }\n+            buf.append(\">\");\n+        }\n+        buf.append(\";\");\n+        return WitnessSupport.type(MethodHandles.lookup(), buf.toString());\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/runtime\/BadWitnessLookupBoundsRuntime.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.reflect.TypeContext;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.runtime.WitnessSupport;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.reflect\n+ * @summary Smoke test for witness support type operations\n+ * @run junit\/othervm TestTypeOps\n+ *\/\n+\n+public class TestTypeOps {\n+\n+    @ParameterizedTest\n+    @MethodSource(\"primitivePairs\")\n+    public void testSamePrimitive(Class<?> s, Class<?> t) {\n+        if (s.equals(t)) {\n+            assertSameType(s, t);\n+        } else {\n+            assertNotSameType(s, t);\n+        }\n+    }\n+\n+    @Test\n+    public void testSameClass() {\n+        assertSameType(String.class, String.class);\n+        assertNotSameType(Integer.class, String.class);\n+    }\n+\n+    @Test\n+    public void testSameArray() {\n+        assertSameType(arr(String.class), arr(String.class));\n+        assertNotSameType(arr(String.class), arr(Integer.class));\n+        assertNotSameType(String.class, arr(String.class));\n+        assertNotSameType(arr(String.class), String.class);\n+        assertSameType(arr(arr(String.class)), arr(arr(String.class)));\n+        assertNotSameType(arr(arr(String.class)), arr(arr(Integer.class)));\n+        assertNotSameType(arr(String.class), arr(arr(String.class)));\n+        assertNotSameType(arr(arr(String.class)), arr(String.class));\n+    }\n+\n+    @Test\n+    public void testSameGenericSingle() {\n+        assertSameType(pt(List.class, String.class), pt(List.class, String.class));\n+        assertNotSameType(pt(List.class, String.class), pt(List.class, Integer.class));\n+        assertSameType(pt(List.class, arr(String.class)), pt(List.class, arr(String.class)));\n+        assertNotSameType(pt(List.class, arr(String.class)), pt(List.class, arr(Integer.class)));\n+        assertSameType(pt(List.class, pt(List.class, String.class)), pt(List.class, pt(List.class, String.class)));\n+        assertNotSameType(pt(List.class, pt(List.class, String.class)), pt(List.class, pt(List.class, Integer.class)));\n+        assertSameType(pt(List.class, pt(List.class, arr(String.class))), pt(List.class, pt(List.class, arr(String.class))));\n+        assertNotSameType(pt(List.class, pt(List.class, arr(String.class))), pt(List.class, pt(List.class, arr(Integer.class))));\n+        assertSameType(pt(List.class, arr(int.class)), pt(List.class, arr(int.class)));\n+        assertNotSameType(pt(List.class, arr(int.class)), pt(List.class, arr(float.class)));\n+    }\n+\n+    @Test\n+    public void testSameGenericMulti() {\n+        assertSameType(pt(Map.class, String.class, Integer.class), pt(Map.class, String.class, Integer.class));\n+        assertNotSameType(pt(Map.class, String.class, Integer.class), pt(Map.class, Integer.class, String.class));\n+        assertSameType(pt(Map.class, arr(String.class), Integer.class), pt(Map.class, arr(String.class), Integer.class));\n+        assertNotSameType(pt(Map.class, arr(String.class), Integer.class), pt(Map.class, String.class, arr(Integer.class)));\n+        assertSameType(pt(Map.class, pt(List.class, String.class), pt(List.class, Integer.class)), pt(Map.class, pt(List.class, String.class), pt(List.class, Integer.class)));\n+        assertNotSameType(pt(Map.class, pt(List.class, String.class), pt(List.class, Integer.class)), pt(Map.class, pt(List.class, Integer.class), pt(List.class, String.class)));\n+        assertSameType(pt(Map.class, pt(List.class, String.class), pt(List.class, arr(Integer.class))), pt(Map.class, pt(List.class, String.class), pt(List.class, arr(Integer.class))));\n+        assertNotSameType(pt(Map.class, pt(List.class, String.class), pt(List.class, arr(Integer.class))), pt(Map.class, pt(List.class, arr(String.class)), pt(List.class, Integer.class)));\n+        assertSameType(pt(Map.class, arr(int.class), arr(float.class)), pt(Map.class, arr(int.class), arr(float.class)));\n+        assertNotSameType(pt(Map.class, arr(int.class), arr(float.class)), pt(Map.class, arr(float.class), arr(int.class)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"primitivePairs\")\n+    public void testSubPrimitive(Class<?> s, Class<?> t) {\n+        if (t.isAssignableFrom(s)) {\n+            assertSubtype(s, t);\n+        } else {\n+            assertNotSubtype(s, t);\n+        }\n+    }\n+\n+    @Test\n+    public void testSubClass() {\n+        assertSubtype(String.class, Object.class);\n+        assertNotSubtype(Object.class, String.class);\n+        assertSubtype(String.class, Serializable.class);\n+        assertNotSubtype(Serializable.class, String.class);\n+    }\n+\n+    @Test\n+    public void testSubArray() {\n+        for (Class<?> elem : List.of(Number.class, Integer.class)) {\n+            assertSubtype(arr(elem), arr(Number.class));\n+            assertSubtype(arr(elem), arr(Object.class));\n+            assertNotSubtype(arr(elem), arr(String.class));\n+            assertNotSubtype(arr(elem), Number.class);\n+            assertNotSubtype(elem, arr(Number.class));\n+            assertSubtype(arr(arr(elem)), arr(arr(Number.class)));\n+            assertSubtype(arr(arr(elem)), arr(arr(Object.class)));\n+            assertNotSubtype(arr(arr(elem)), arr(arr(String.class)));\n+            assertNotSubtype(arr(arr(elem)), arr(Number.class));\n+            assertNotSubtype(arr(elem), arr(arr(Number.class)));\n+            assertSubtype(arr(elem), Serializable.class);\n+            assertSubtype(arr(elem), Cloneable.class);\n+        }\n+    }\n+\n+    @Test\n+    public void testSubGenericSingle() {\n+        for (Class<?> list : List.of(List.class, ArrayList.class)) {\n+            assertSubtype(pt(list, String.class), pt(List.class, String.class));\n+            assertNotSubtype(pt(list, String.class), pt(List.class, Integer.class));\n+            assertSubtype(pt(list, arr(String.class)), pt(List.class, arr(String.class)));\n+            assertNotSubtype(pt(list, arr(String.class)), pt(List.class, arr(Integer.class)));\n+            assertSubtype(pt(list, pt(List.class, String.class)), pt(List.class, pt(List.class, String.class)));\n+            assertNotSubtype(pt(list, pt(List.class, String.class)), pt(List.class, pt(List.class, Integer.class)));\n+            assertSubtype(pt(list, pt(List.class, arr(String.class))), pt(List.class, pt(List.class, arr(String.class))));\n+            assertNotSubtype(pt(list, pt(List.class, arr(String.class))), pt(List.class, pt(List.class, arr(Integer.class))));\n+            assertSubtype(pt(list, arr(int.class)), pt(List.class, arr(int.class)));\n+            assertNotSubtype(pt(list, arr(int.class)), pt(List.class, arr(float.class)));\n+        }\n+    }\n+\n+    @Test\n+    public void testSubGenericMulti() {\n+        for (Class<?> map : List.of(Map.class, HashMap.class)) {\n+            assertSubtype(pt(map, String.class, Integer.class), pt(Map.class, String.class, Integer.class));\n+            assertNotSubtype(pt(map, String.class, Integer.class), pt(Map.class, Integer.class, String.class));\n+            assertSubtype(pt(map, arr(String.class), Integer.class), pt(Map.class, arr(String.class), Integer.class));\n+            assertNotSubtype(pt(map, arr(String.class), Integer.class), pt(Map.class, String.class, arr(Integer.class)));\n+            assertSubtype(pt(map, pt(List.class, String.class), pt(List.class, Integer.class)), pt(Map.class, pt(List.class, String.class), pt(List.class, Integer.class)));\n+            assertNotSubtype(pt(map, pt(List.class, String.class), pt(List.class, Integer.class)), pt(Map.class, pt(List.class, Integer.class), pt(List.class, String.class)));\n+            assertSubtype(pt(map, pt(List.class, String.class), pt(List.class, arr(Integer.class))), pt(Map.class, pt(List.class, String.class), pt(List.class, arr(Integer.class))));\n+            assertNotSubtype(pt(map, pt(List.class, String.class), pt(List.class, arr(Integer.class))), pt(Map.class, pt(List.class, arr(String.class)), pt(List.class, Integer.class)));\n+            assertSubtype(pt(map, arr(int.class), arr(float.class)), pt(Map.class, arr(int.class), arr(float.class)));\n+            assertNotSubtype(pt(map, arr(int.class), arr(float.class)), pt(Map.class, arr(float.class), arr(int.class)));\n+        }\n+    }\n+\n+    void assertSameType(Type s, Type t) {\n+        System.err.println(format(s, t, \"==\"));\n+        assertTrue(new TypeContext().isSameType(s, t), format(s, t, \"!=\"));\n+    }\n+\n+    void assertNotSameType(Type s, Type t) {\n+        System.err.println(format(s, t, \"!=\"));\n+        assertFalse(new TypeContext().isSameType(s, t), format(s, t, \"==\"));\n+    }\n+\n+    void assertSubtype(Type s, Type t) {\n+        System.err.println(format(s, t, \"<:\"));\n+        assertTrue(new TypeContext().isSubType(s, t), format(s, t, \"<\/:\"));\n+    }\n+\n+    void assertNotSubtype(Type s, Type t) {\n+        System.err.println(format(s, t, \"<\/:\"));\n+        assertFalse(new TypeContext().isSubType(s, t), format(s, t, \"<:\"));\n+    }\n+\n+    Type pt(Class<?> baseType, Type... typeArgs) {\n+        return WitnessSupport.type(MethodHandles.lookup(), classSig(baseType, typeArgs));\n+    }\n+\n+    Type arr(Type elementType) {\n+        return WitnessSupport.type(MethodHandles.lookup(), arraySig(elementType));\n+    }\n+\n+    String format(Type s, Type t, String op) {\n+        return s.getTypeName() + \" \" + op + \" \" + t.getTypeName();\n+    }\n+\n+    String typeSig(Type t) {\n+        if (t instanceof ParameterizedType pt) {\n+            return classSig((Class<?>)pt.getRawType(), pt.getActualTypeArguments());\n+        } else if (t instanceof GenericArrayType gat) {\n+            return arraySig(gat.getGenericComponentType());\n+        } else {\n+            return ((Class<?>)t).describeConstable().get().descriptorString();\n+        }\n+    }\n+\n+    String classSig(Class<?> baseType, Type... typeArgs) {\n+        StringBuilder buf = new StringBuilder();\n+        String baseSig = baseType.describeConstable().get().descriptorString();\n+        buf.append(baseSig, 0, baseSig.length() - 1);\n+        if (typeArgs.length > 0) {\n+            buf.append(\"<\");\n+            Stream.of(typeArgs).map(this::typeSig).forEach(buf::append);\n+            buf.append(\">\");\n+        }\n+        buf.append(\";\");\n+        return buf.toString();\n+    }\n+\n+    String arraySig(Type elementType) {\n+        return \"[\" + typeSig(elementType);\n+    }\n+\n+    private static Stream<Arguments> primitivePairs() {\n+        List<Class<?>> primitives = List.of(boolean.class, char.class, byte.class, short.class,\n+                int.class, float.class, long.class, double.class, void.class);\n+        return primitives.stream()\n+                .flatMap(a -> primitives.stream().flatMap(b -> Stream.of(Arguments.of(a, b))));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/runtime\/TestTypeOps.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.runtime.WitnessSupport;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for subtyping checks in witness lookups\n+ *\/\n+public class TypeClassesSubTypingRuntimeTest {\n+    interface A<X> {\n+        String a();\n+    }\n+    interface B<X> extends A<X> { }\n+\n+    interface C<W> { String a(); }\n+    interface D<X> extends C<X> { }\n+\n+    static class E {\n+        __witness B<E> BE = () -> \"BE\";\n+        __witness D<E> DE(A<E> az) {\n+            return () -> \"DE\";\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (String name : List.of(\"A\", \"B\", \"C\", \"D\")) {\n+            var typeName = String.format(\"LTypeClassesSubTypingRuntimeTest$%s<LTypeClassesSubTypingRuntimeTest$E;>;\", name);\n+            var lookup = MethodHandles.lookup();\n+            var type = WitnessSupport.type(lookup, typeName);\n+            try {\n+                WitnessSupport.lookupWitness(lookup, type);\n+                System.out.println(\"Success: \" + name);\n+                if (!name.equals(\"B\")) {\n+                    throw new AssertionError(\"Expected failure: \" + name);\n+                }\n+            } catch (IllegalArgumentException ex) {\n+                System.out.println(\"Fail: \" + name);\n+                if (name.equals(\"B\")) {\n+                    throw new AssertionError(\"Expected success: \" + name);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/runtime\/TypeClassesSubTypingRuntimeTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary smoke test for separate compilation of type classes\n+ * @compile  pkg1\/Monoid.java\n+ * @compile  pkg1\/MyIntF.java\n+ * @compile  pkg1\/MyIntM.java\n+ * @compile  Separate.java\n+ *\/\n+\n+import pkg1.*;\n+\n+class Separate {\n+    void test() {\n+        Monoid<MyIntF> mm_f = Monoid<MyIntF>.__witness;\n+        Monoid<MyIntM> mm_m = Monoid<MyIntM>.__witness;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/separate\/Separate.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg1;\n+\n+public interface Monoid<X> {\n+    X add(X x1, X x2);\n+    X zero();\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/separate\/pkg1\/Monoid.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg1;\n+\n+public record MyIntF(int value) {\n+\n+    public __witness Monoid<MyIntF> MONOID = new Monoid<>() {\n+        public MyIntF add(MyIntF m1, MyIntF m2) {\n+            return new MyIntF(m1.value + m2.value);\n+        }\n+        public MyIntF zero() {\n+            return new MyIntF(0);\n+        }\n+    };\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/separate\/pkg1\/MyIntF.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg1;\n+\n+public record MyIntM(int value) {\n+\n+    public __witness Monoid<MyIntM> MONOID() {\n+        return new Monoid<>() {\n+            public MyIntM add(MyIntM m1, MyIntM m2) {\n+                return new MyIntM(m1.value + m2.value);\n+            }\n+            public MyIntM zero() {\n+                return new MyIntM(0);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/typeClasses\/separate\/pkg1\/MyIntM.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}