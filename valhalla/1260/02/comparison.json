{"files":[{"patch":"@@ -203,10 +203,125 @@\n-     * argument.\n-     *\n-     * @implSpec\n-     * The current implementation acts as this {@code Float16} were\n-     * {@linkplain #floatValue() converted} to {@code float} and then\n-     * the string for that {@code float} returned. This behavior is\n-     * expected to change to accommodate the precision of {@code\n-     * Float16}.\n-     *\n-     * @param   f16   the {@code Float16} to be converted.\n+     * argument. All characters mentioned below are ASCII characters.\n+     * <ul>\n+     * <li>If the argument is NaN, the result is the string\n+     * \"{@code NaN}\".\n+     * <li>Otherwise, the result is a string that represents the sign and\n+     *     magnitude (absolute value) of the argument. If the sign is\n+     *     negative, the first character of the result is\n+     *     '{@code -}' ({@code '\\u005Cu002D'}); if the sign is\n+     *     positive, no sign character appears in the result. As for\n+     *     the magnitude <i>m<\/i>:\n+     * <ul>\n+     * <li>If <i>m<\/i> is infinity, it is represented by the characters\n+     *     {@code \"Infinity\"}; thus, positive infinity produces\n+     *     the result {@code \"Infinity\"} and negative infinity\n+     *     produces the result {@code \"-Infinity\"}.\n+     * <li>If <i>m<\/i> is zero, it is represented by the characters\n+     *     {@code \"0.0\"}; thus, negative zero produces the result\n+     *     {@code \"-0.0\"} and positive zero produces the result\n+     *     {@code \"0.0\"}.\n+     *\n+     * <li> Otherwise <i>m<\/i> is positive and finite.\n+     * It is converted to a string in two stages:\n+     * <ul>\n+     * <li> <em>Selection of a decimal<\/em>:\n+     * A well-defined decimal <i>d<\/i><sub><i>m<\/i><\/sub>\n+     * is selected to represent <i>m<\/i>.\n+     * This decimal is (almost always) the <em>shortest<\/em> one that\n+     * rounds to <i>m<\/i> according to the round to nearest\n+     * rounding policy of IEEE 754 floating-point arithmetic.\n+     * <li> <em>Formatting as a string<\/em>:\n+     * The decimal <i>d<\/i><sub><i>m<\/i><\/sub> is formatted as a string,\n+     * either in plain or in computerized scientific notation,\n+     * depending on its value.\n+     * <\/ul>\n+     * <\/ul>\n+     * <\/ul>\n+     *\n+     * <p>A <em>decimal<\/em> is a number of the form\n+     * <i>s<\/i>&times;10<sup><i>i<\/i><\/sup>\n+     * for some (unique) integers <i>s<\/i> &gt; 0 and <i>i<\/i> such that\n+     * <i>s<\/i> is not a multiple of 10.\n+     * These integers are the <em>significand<\/em> and\n+     * the <em>exponent<\/em>, respectively, of the decimal.\n+     * The <em>length<\/em> of the decimal is the (unique)\n+     * positive integer <i>n<\/i> meeting\n+     * 10<sup><i>n<\/i>-1<\/sup> &le; <i>s<\/i> &lt; 10<sup><i>n<\/i><\/sup>.\n+     *\n+     * <p>The decimal <i>d<\/i><sub><i>m<\/i><\/sub> for a finite positive <i>m<\/i>\n+     * is defined as follows:\n+     * <ul>\n+     * <li>Let <i>R<\/i> be the set of all decimals that round to <i>m<\/i>\n+     * according to the usual <em>round to nearest<\/em> rounding policy of\n+     * IEEE 754 floating-point arithmetic.\n+     * <li>Let <i>p<\/i> be the minimal length over all decimals in <i>R<\/i>.\n+     * <li>When <i>p<\/i> &ge; 2, let <i>T<\/i> be the set of all decimals\n+     * in <i>R<\/i> with length <i>p<\/i>.\n+     * Otherwise, let <i>T<\/i> be the set of all decimals\n+     * in <i>R<\/i> with length 1 or 2.\n+     * <li>Define <i>d<\/i><sub><i>m<\/i><\/sub> as the decimal in <i>T<\/i>\n+     * that is closest to <i>m<\/i>.\n+     * Or if there are two such decimals in <i>T<\/i>,\n+     * select the one with the even significand.\n+     * <\/ul>\n+     *\n+     * <p>The (uniquely) selected decimal <i>d<\/i><sub><i>m<\/i><\/sub>\n+     * is then formatted.\n+     * Let <i>s<\/i>, <i>i<\/i> and <i>n<\/i> be the significand, exponent and\n+     * length of <i>d<\/i><sub><i>m<\/i><\/sub>, respectively.\n+     * Further, let <i>e<\/i> = <i>n<\/i> + <i>i<\/i> - 1 and let\n+     * <i>s<\/i><sub>1<\/sub>&hellip;<i>s<\/i><sub><i>n<\/i><\/sub>\n+     * be the usual decimal expansion of <i>s<\/i>.\n+     * Note that <i>s<\/i><sub>1<\/sub> &ne; 0\n+     * and <i>s<\/i><sub><i>n<\/i><\/sub> &ne; 0.\n+     * Below, the decimal point {@code '.'} is {@code '\\u005Cu002E'}\n+     * and the exponent indicator {@code 'E'} is {@code '\\u005Cu0045'}.\n+     * <ul>\n+     * <li>Case -3 &le; <i>e<\/i> &lt; 0:\n+     * <i>d<\/i><sub><i>m<\/i><\/sub> is formatted as\n+     * <code>0.0<\/code>&hellip;<code>0<\/code><!--\n+     * --><i>s<\/i><sub>1<\/sub>&hellip;<i>s<\/i><sub><i>n<\/i><\/sub>,\n+     * where there are exactly -(<i>n<\/i> + <i>i<\/i>) zeroes between\n+     * the decimal point and <i>s<\/i><sub>1<\/sub>.\n+     * For example, 123 &times; 10<sup>-4<\/sup> is formatted as\n+     * {@code 0.0123}.\n+     * <li>Case 0 &le; <i>e<\/i> &lt; 7:\n+     * <ul>\n+     * <li>Subcase <i>i<\/i> &ge; 0:\n+     * <i>d<\/i><sub><i>m<\/i><\/sub> is formatted as\n+     * <i>s<\/i><sub>1<\/sub>&hellip;<i>s<\/i><sub><i>n<\/i><\/sub><!--\n+     * --><code>0<\/code>&hellip;<code>0.0<\/code>,\n+     * where there are exactly <i>i<\/i> zeroes\n+     * between <i>s<\/i><sub><i>n<\/i><\/sub> and the decimal point.\n+     * For example, 123 &times; 10<sup>2<\/sup> is formatted as\n+     * {@code 12300.0}.\n+     * <li>Subcase <i>i<\/i> &lt; 0:\n+     * <i>d<\/i><sub><i>m<\/i><\/sub> is formatted as\n+     * <i>s<\/i><sub>1<\/sub>&hellip;<!--\n+     * --><i>s<\/i><sub><i>n<\/i>+<i>i<\/i><\/sub><code>.<\/code><!--\n+     * --><i>s<\/i><sub><i>n<\/i>+<i>i<\/i>+1<\/sub>&hellip;<!--\n+     * --><i>s<\/i><sub><i>n<\/i><\/sub>,\n+     * where there are exactly -<i>i<\/i> digits to the right of\n+     * the decimal point.\n+     * For example, 123 &times; 10<sup>-1<\/sup> is formatted as\n+     * {@code 12.3}.\n+     * <\/ul>\n+     * <li>Case <i>e<\/i> &lt; -3 (case <i>e<\/i> &ge; 7 cannot happen):\n+     * computerized scientific notation is used to format\n+     * <i>d<\/i><sub><i>m<\/i><\/sub>.\n+     * Here <i>e<\/i> is formatted as by {@link Integer#toString(int)}.\n+     * <ul>\n+     * <li>Subcase <i>n<\/i> = 1:\n+     * <i>d<\/i><sub><i>m<\/i><\/sub> is formatted as\n+     * <i>s<\/i><sub>1<\/sub><code>.0E<\/code><i>e<\/i>.\n+     * For example, 1 &times; 10<sup>-5<\/sup> is formatted as\n+     * {@code 1.0E-5}.\n+     * <li>Subcase <i>n<\/i> &gt; 1:\n+     * <i>d<\/i><sub><i>m<\/i><\/sub> is formatted as\n+     * <i>s<\/i><sub>1<\/sub><code>.<\/code><i>s<\/i><sub>2<\/sub><!--\n+     * -->&hellip;<i>s<\/i><sub><i>n<\/i><\/sub><code>E<\/code><i>e<\/i>.\n+     * For example, 123 &times; 10<sup>-7<\/sup> is formatted as\n+     * {@code 1.23E-5}.\n+     * <\/ul>\n+     * <\/ul>\n+     *\n+     * @param   f16   the {@code float} to be converted.\n@@ -214,1 +329,0 @@\n-     * @see java.lang.Float#toString(float)\n@@ -217,2 +331,1 @@\n-        \/\/ FIXME -- update for Float16 precision\n-        return FloatToDecimal.toString(f16.floatValue());\n+        return Float16ToDecimal.toString(f16);\n@@ -503,1 +616,4 @@\n-     * {@return a string representation of this {@code Float16}}\n+     * Returns a string representation of this {@link Float16} object.\n+     * This object\n+     * is converted to a {@code String} exactly as if by the method\n+     * {@link #toString(Float16)}.\n@@ -505,2 +621,2 @@\n-     * @implSpec\n-     * This method returns the result of {@code Float16.toString(this)}.\n+     * @return  a {@code String} representation of this object.\n+     * @see #toString(Float16)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":132,"deletions":16,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -0,0 +1,499 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+import java.io.IOException;\n+\n+import static java.lang.Float16.PRECISION;\n+import static java.lang.Float16.float16ToRawShortBits;\n+import static java.lang.Integer.numberOfLeadingZeros;\n+import static java.lang.Math.multiplyHigh;\n+import static jdk.internal.math.MathUtils.*;\n+\n+\/**\n+ * This class exposes a method to render a {@code Float16} as a string.\n+ *\/\n+public final class Float16ToDecimal {\n+    \/*\n+     * For full details about this code see the following references:\n+     *\n+     * [1] Giulietti, \"The Schubfach way to render doubles\",\n+     *     https:\/\/drive.google.com\/file\/d\/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb\n+     *\n+     * [2] IEEE Computer Society, \"IEEE Standard for Floating-Point Arithmetic\"\n+     *\n+     * [3] Bouvier & Zimmermann, \"Division-Free Binary-to-Decimal Conversion\"\n+     *\n+     * Divisions are avoided altogether for the benefit of those architectures\n+     * that do not provide specific machine instructions or where they are slow.\n+     * This is discussed in section 10 of [1].\n+     *\/\n+\n+    \/* The precision in bits *\/\n+    static final int P = PRECISION;\n+\n+    \/* Exponent width in bits *\/\n+    private static final int W = (Float16.SIZE - 1) - (P - 1);\n+\n+    \/* Minimum value of the exponent: -(2^(W-1)) - P + 3 *\/\n+    static final int Q_MIN = (-1 << (W - 1)) - P + 3;\n+\n+    \/* Maximum value of the exponent: 2^(W-1) - P *\/\n+    static final int Q_MAX = (1 << (W - 1)) - P;\n+\n+    \/* 10^(E_MIN - 1) <= MIN_VALUE < 10^E_MIN *\/\n+    static final int E_MIN = -7;\n+\n+    \/* 10^(E_MAX - 1) <= MAX_VALUE < 10^E_MAX *\/\n+    static final int E_MAX = 5;\n+\n+    \/* Threshold to detect tiny values, as in section 8.2.1 of [1] *\/\n+    static final int C_TINY = 2;\n+\n+    \/* The minimum and maximum k, as in section 8 of [1] *\/\n+    static final int K_MIN = -8;\n+    static final int K_MAX = 1;\n+\n+    \/* H is as in section 8.1 of [1] *\/\n+    static final int H = 5;\n+\n+    \/* Minimum value of the significand of a normal value: 2^(P-1) *\/\n+    private static final int C_MIN = 1 << (P - 1);\n+\n+    \/* Mask to extract the biased exponent *\/\n+    private static final int BQ_MASK = (1 << W) - 1;\n+\n+    \/* Mask to extract the fraction bits *\/\n+    private static final int T_MASK = (1 << (P - 1)) - 1;\n+\n+    \/* Used in rop() *\/\n+    private static final long MASK_32 = (1L << 32) - 1;\n+\n+    \/* Used for left-to-tight digit extraction *\/\n+    private static final int MASK_15 = (1 << 15) - 1;\n+\n+    private static final int NON_SPECIAL    = 0;\n+    private static final int PLUS_ZERO      = 1;\n+    private static final int MINUS_ZERO     = 2;\n+    private static final int PLUS_INF       = 3;\n+    private static final int MINUS_INF      = 4;\n+    private static final int NAN            = 5;\n+\n+    \/*\n+     * Room for the longer of the forms\n+     *     -ddd.dd      H + 2 characters\n+     *     -ddddd.0     H + 3 characters\n+     *     -0.00ddddd   H + 5 characters\n+     *     -d.ddddE-e   H + 5 characters\n+     * where there are H digits d\n+     *\/\n+    public static final int MAX_CHARS = H + 5;\n+\n+    private final byte[] bytes = new byte[MAX_CHARS];\n+\n+    \/* Index into bytes of rightmost valid character *\/\n+    private int index;\n+\n+    private Float16ToDecimal() {\n+    }\n+\n+    \/**\n+     * Returns a string representation of the {@code Float16}\n+     * argument. All characters mentioned below are ASCII characters.\n+     *\n+     * @param   v   the {@code Float16} to be converted.\n+     * @return a string representation of the argument.\n+     * @see Float16#toString(Float16)\n+     *\/\n+    public static String toString(Float16 v) {\n+        return new Float16ToDecimal().toDecimalString(v);\n+    }\n+\n+    \/**\n+     * Appends the rendering of the {@code v} to {@code app}.\n+     *\n+     * <p>The outcome is the same as if {@code v} were first\n+     * {@link #toString(Float16) rendered} and the resulting string were then\n+     * {@link Appendable#append(CharSequence) appended} to {@code app}.\n+     *\n+     * @param v the {@code Float16} whose rendering is appended.\n+     * @param app the {@link Appendable} to append to.\n+     * @throws IOException If an I\/O error occurs\n+     *\/\n+    public static Appendable appendTo(Float16 v, Appendable app)\n+            throws IOException {\n+        return new Float16ToDecimal().appendDecimalTo(v, app);\n+    }\n+\n+    private String toDecimalString(Float16 v) {\n+        return switch (toDecimal(v)) {\n+            case NON_SPECIAL -> charsToString();\n+            case PLUS_ZERO -> \"0.0\";\n+            case MINUS_ZERO -> \"-0.0\";\n+            case PLUS_INF -> \"Infinity\";\n+            case MINUS_INF -> \"-Infinity\";\n+            default -> \"NaN\";\n+        };\n+    }\n+\n+    private Appendable appendDecimalTo(Float16 v, Appendable app)\n+            throws IOException {\n+        switch (toDecimal(v)) {\n+            case NON_SPECIAL:\n+                char[] chars = new char[index + 1];\n+                for (int i = 0; i < chars.length; ++i) {\n+                    chars[i] = (char) bytes[i];\n+                }\n+                if (app instanceof StringBuilder builder) {\n+                    return builder.append(chars);\n+                }\n+                if (app instanceof StringBuffer buffer) {\n+                    return buffer.append(chars);\n+                }\n+                for (char c : chars) {\n+                    app.append(c);\n+                }\n+                return app;\n+            case PLUS_ZERO: return app.append(\"0.0\");\n+            case MINUS_ZERO: return app.append(\"-0.0\");\n+            case PLUS_INF: return app.append(\"Infinity\");\n+            case MINUS_INF: return app.append(\"-Infinity\");\n+            default: return app.append(\"NaN\");\n+        }\n+    }\n+\n+    \/*\n+     * Returns\n+     *     PLUS_ZERO       iff v is 0.0\n+     *     MINUS_ZERO      iff v is -0.0\n+     *     PLUS_INF        iff v is POSITIVE_INFINITY\n+     *     MINUS_INF       iff v is NEGATIVE_INFINITY\n+     *     NAN             iff v is NaN\n+     *\/\n+    private int toDecimal(Float16 v) {\n+        \/*\n+         * For full details see references [2] and [1].\n+         *\n+         * For finite v != 0, determine integers c and q such that\n+         *     |v| = c 2^q    and\n+         *     Q_MIN <= q <= Q_MAX    and\n+         *         either    2^(P-1) <= c < 2^P                 (normal)\n+         *         or        0 < c < 2^(P-1)  and  q = Q_MIN    (subnormal)\n+         *\/\n+        int bits = float16ToRawShortBits(v);\n+        int t = bits & T_MASK;\n+        int bq = (bits >>> P - 1) & BQ_MASK;\n+        if (bq < BQ_MASK) {\n+            index = -1;\n+            if (bits < 0) {\n+                append('-');\n+            }\n+            if (bq != 0) {\n+                \/* normal value. Here mq = -q *\/\n+                int mq = -Q_MIN + 1 - bq;\n+                int c = C_MIN | t;\n+                \/* The fast path discussed in section 8.3 of [1] *\/\n+                if (0 < mq & mq < P) {\n+                    int f = c >> mq;\n+                    if (f << mq == c) {\n+                        return toChars(f, 0);\n+                    }\n+                }\n+                return toDecimal(-mq, c, 0);\n+            }\n+            if (t != 0) {\n+                \/* subnormal value *\/\n+                return t < C_TINY\n+                       ? toDecimal(Q_MIN, 10 * t, -1)\n+                       : toDecimal(Q_MIN, t, 0);\n+            }\n+            return bits == 0 ? PLUS_ZERO : MINUS_ZERO;\n+        }\n+        if (t != 0) {\n+            return NAN;\n+        }\n+        return bits > 0 ? PLUS_INF : MINUS_INF;\n+    }\n+\n+    private int toDecimal(int q, int c, int dk) {\n+        \/*\n+         * The skeleton corresponds to figure 7 of [1].\n+         * The efficient computations are those summarized in figure 9.\n+         * Also check the appendix.\n+         *\n+         * Here's a correspondence between Java names and names in [1],\n+         * expressed as approximate LaTeX source code and informally.\n+         * Other names are identical.\n+         * cb:     \\bar{c}     \"c-bar\"\n+         * cbr:    \\bar{c}_r   \"c-bar-r\"\n+         * cbl:    \\bar{c}_l   \"c-bar-l\"\n+         *\n+         * vb:     \\bar{v}     \"v-bar\"\n+         * vbr:    \\bar{v}_r   \"v-bar-r\"\n+         * vbl:    \\bar{v}_l   \"v-bar-l\"\n+         *\n+         * rop:    r_o'        \"r-o-prime\"\n+         *\/\n+        int out = c & 0x1;\n+        long cb = c << 2;\n+        long cbr = cb + 2;\n+        long cbl;\n+        int k;\n+        \/*\n+         * flog10pow2(e) = floor(log_10(2^e))\n+         * flog10threeQuartersPow2(e) = floor(log_10(3\/4 2^e))\n+         * flog2pow10(e) = floor(log_2(10^e))\n+         *\/\n+        if (c != C_MIN | q == Q_MIN) {\n+            \/* regular spacing *\/\n+            cbl = cb - 2;\n+            k = flog10pow2(q);\n+        } else {\n+            \/* irregular spacing *\/\n+            cbl = cb - 1;\n+            k = flog10threeQuartersPow2(q);\n+        }\n+        int h = q + flog2pow10(-k) + 33;\n+\n+        \/* g is as in the appendix *\/\n+        long g = g1(k) + 1;\n+\n+        int vb = rop(g, cb << h);\n+        int vbl = rop(g, cbl << h);\n+        int vbr = rop(g, cbr << h);\n+\n+        int s = vb >> 2;\n+        if (s >= 100) {\n+            \/*\n+             * For n = 5, m = 1 the discussion in section 10 of [1] shows\n+             *     s' = floor(s \/ 10) = floor(s 52_429 \/ 2^19)\n+             *\n+             * sp10 = 10 s'\n+             * tp10 = 10 t'\n+             * upin    iff    u' = sp10 10^k in Rv\n+             * wpin    iff    w' = tp10 10^k in Rv\n+             * See section 9.3 of [1].\n+             *\/\n+            int sp10 = 10 * (int) (s * 52_429L >>> 19);\n+            int tp10 = sp10 + 10;\n+            boolean upin = vbl + out <= sp10 << 2;\n+            boolean wpin = (tp10 << 2) + out <= vbr;\n+            if (upin != wpin) {\n+                return toChars(upin ? sp10 : tp10, k);\n+            }\n+        }\n+\n+        \/*\n+         * 10 <= s < 100    or    s >= 100  and  u', w' not in Rv\n+         * uin    iff    u = s 10^k in Rv\n+         * win    iff    w = t 10^k in Rv\n+         * See section 9.3 of [1].\n+         *\/\n+        int t = s + 1;\n+        boolean uin = vbl + out <= s << 2;\n+        boolean win = (t << 2) + out <= vbr;\n+        if (uin != win) {\n+            \/* Exactly one of u or w lies in Rv *\/\n+            return toChars(uin ? s : t, k + dk);\n+        }\n+        \/*\n+         * Both u and w lie in Rv: determine the one closest to v.\n+         * See section 9.3 of [1].\n+         *\/\n+        int cmp = vb - (s + t << 1);\n+        return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+    }\n+\n+    \/*\n+     * Computes rop(cp g 2^(-95))\n+     * See appendix and figure 11 of [1].\n+     *\/\n+    private static int rop(long g, long cp) {\n+        long x1 = multiplyHigh(g, cp);\n+        long vbp = x1 >>> 31;\n+        return (int) (vbp | (x1 & MASK_32) + MASK_32 >>> 32);\n+    }\n+\n+    \/*\n+     * Formats the decimal f 10^e.\n+     *\/\n+    private int toChars(int f, int e) {\n+        \/*\n+         * For details not discussed here see section 10 of [1].\n+         *\n+         * Determine len such that\n+         *     10^(len-1) <= f < 10^len\n+         *\/\n+        int len = flog10pow2(Integer.SIZE - numberOfLeadingZeros(f));\n+        if (f >= pow10(len)) {\n+            len += 1;\n+        }\n+\n+        \/*\n+         * Let fp and ep be the original f and e, respectively.\n+         * Transform f and e to ensure\n+         *     10^(H-1) <= f < 10^H\n+         *     fp 10^ep = f 10^(e-H) = 0.f 10^e\n+         *\/\n+        f *= (int)pow10(H - len);\n+        e += len;\n+\n+        \/*\n+         * The toChars?() methods perform left-to-right digits extraction\n+         * using ints, provided that the arguments are limited to 8 digits.\n+         * Therefore, split the H = 9 digits of f into:\n+         *     h = the most significant digit of f\n+         *     l = the last 4, least significant digits of f\n+         *\n+         * For n = 5, m = 4 the discussion in section 10 of [1] shows\n+         *     floor(f \/ 10^4) = floor(107_375L f \/ 2^30)\n+         *\/\n+        int h = (int) (f * 107_375L >>> 30);\n+        int l = f - 10_000 * h;\n+\n+        if (0 < e && e <= 7) {\n+            return toChars1(h, l, e);\n+        }\n+        if (-3 < e && e <= 0) {\n+            return toChars2(h, l, e);\n+        }\n+        return toChars3(h, l, e);\n+    }\n+\n+    private int toChars1(int h, int l, int e) {\n+        \/*\n+         * 0 < e <= 7: plain format without leading zeroes.\n+         * Left-to-right digits extraction:\n+         * algorithm 1 in [3], with b = 10, k = 4, n = 15.\n+         *\/\n+        appendDigit(h);\n+        int y = y(l);\n+        int t;\n+        int i = 1;\n+        for (; i < e; ++i) {\n+            t = 10 * y;\n+            appendDigit(t >>> 15);\n+            y = t & MASK_15;\n+        }\n+        append('.');\n+        for (; i <= 4; ++i) {\n+            t = 10 * y;\n+            appendDigit(t >>> 15);\n+            y = t & MASK_15;\n+        }\n+        \/*\n+         * As H = 5 < 7, where 7 is the threshold for plain format without\n+         * leading zeros, it can happen that the 2nd loop above is not executed.\n+         * The following line ensures the presence of a digit to the right\n+         * of the decimal point.\n+         *\/\n+        appendDigit(0);\n+        removeTrailingZeroes();\n+        return NON_SPECIAL;\n+    }\n+\n+    private int toChars2(int h, int l, int e) {\n+        \/* -3 < e <= 0: plain format with leading zeroes *\/\n+        appendDigit(0);\n+        append('.');\n+        for (; e < 0; ++e) {\n+          appendDigit(0);\n+        }\n+        appendDigit(h);\n+        append4Digits(l);\n+        removeTrailingZeroes();\n+        return NON_SPECIAL;\n+    }\n+\n+    private int toChars3(int h, int l, int e) {\n+        \/* -3 >= e | e > 7: computerized scientific notation *\/\n+        appendDigit(h);\n+        append('.');\n+        append4Digits(l);\n+        removeTrailingZeroes();\n+        exponent(e - 1);\n+        return NON_SPECIAL;\n+    }\n+\n+    private void append4Digits(int m) {\n+        \/*\n+         * Left-to-right digits extraction:\n+         * algorithm 1 in [3], with b = 10, k = 4, n = 15.\n+         *\/\n+        int y = y(m);\n+        for (int i = 0; i < 4; ++i) {\n+            int t = 10 * y;\n+            appendDigit(t >>> 15);\n+            y = t & MASK_15;\n+        }\n+    }\n+\n+    private void removeTrailingZeroes() {\n+        while (bytes[index] == '0') {\n+            --index;\n+        }\n+        \/* ... but do not remove the one directly to the right of '.' *\/\n+        if (bytes[index] == '.') {\n+            ++index;\n+        }\n+    }\n+\n+    private int y(int a) {\n+        \/*\n+         * Algorithm 1 in [3] needs computation of\n+         *     floor((a + 1) 2^n \/ b^k) - 1\n+         * with a < 10^4, b = 10, k = 4, n = 15.\n+         * Noting that\n+         *     (a + 1) 2^n <= 10^4 2^15 < 10^9\n+         * For n = 9, m = 4 the discussion in section 10 of [1] leads to:\n+         *\/\n+        return (int) (((a + 1) << 15) * 1_759_218_605L >>> 44) - 1;\n+    }\n+\n+    private void exponent(int e) {\n+        append('E');\n+        if (e < 0) {\n+            append('-');\n+            e = -e;\n+        }\n+        appendDigit(e);\n+    }\n+\n+    private void append(int c) {\n+        bytes[++index] = (byte) c;\n+    }\n+\n+    private void appendDigit(int d) {\n+        bytes[++index] = (byte) ('0' + d);\n+    }\n+\n+    \/* Using the deprecated constructor enhances performance *\/\n+    @SuppressWarnings(\"deprecation\")\n+    private String charsToString() {\n+        return new String(bytes, 0, 0, index + 1);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/Float16ToDecimal.java","additions":499,"deletions":0,"binary":false,"changes":499,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.math.Float16ToDecimalChecker;\n+\n+\/*\n+ * @test\n+ * @bug 8341245\n+ *\n+ * @modules java.base\/jdk.internal.math\n+ * @library java.base\n+ * @build java.base\/jdk.internal.math.*\n+ * @run main Float16ToDecimalTest\n+ *\/\n+public class Float16ToDecimalTest {\n+\n+    public static void main(String[] args) {\n+        Float16ToDecimalChecker.testAll();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/math\/ToDecimal\/Float16ToDecimalTest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+import java.math.BigDecimal;\n+\n+import static java.lang.Float16.*;\n+import static java.lang.Integer.numberOfTrailingZeros;\n+import static jdk.internal.math.MathUtils.flog10pow2;\n+\n+public class Float16ToDecimalChecker extends ToDecimalChecker {\n+\n+    private static final int P =\n+            numberOfTrailingZeros(float16ToRawShortBits(Float16.valueOf(3))) + 2;\n+    private static final int W = (SIZE - 1) - (P - 1);\n+    private static final int Q_MIN = (-1 << (W - 1)) - P + 3;\n+    private static final int Q_MAX = (1 << (W - 1)) - P;\n+    private static final int C_MAX = (1 << P) - 1;\n+\n+    private static final int H = flog10pow2(P) + 2;\n+\n+    private static final Float16 MIN_VALUE = scalb(Float16.valueOf(1), Q_MIN);\n+    private static final Float16 MAX_VALUE = scalb(Float16.valueOf(C_MAX), Q_MAX);\n+\n+    private static final int E_MIN = e(MIN_VALUE.doubleValue());\n+    private static final int E_MAX = e(MAX_VALUE.doubleValue());\n+\n+    private final Float16 v;\n+\n+    private Float16ToDecimalChecker(Float16 v) {\n+        super(Float16ToDecimal.toString(v));\n+\/\/        super(Float.toString(v));\n+        this.v = v;\n+    }\n+\n+    @Override\n+    int h() {\n+        return H;\n+    }\n+\n+    @Override\n+    int maxStringLength() {\n+        return H + 5;\n+    }\n+\n+    @Override\n+    BigDecimal toBigDecimal() {\n+        return new BigDecimal(v.floatValue());\n+    }\n+\n+    @Override\n+    boolean recovers(BigDecimal bd) {\n+        return bd.float16Value().floatValue() == v.floatValue();\n+    }\n+\n+    @Override\n+    boolean recovers(String s) {\n+        return Float16.valueOf(s).floatValue() == v.floatValue();\n+    }\n+\n+    @Override\n+    String hexString() {\n+        return toHexString(v) + \"F16\";\n+    }\n+\n+    @Override\n+    int minExp() {\n+        return E_MIN;\n+    }\n+\n+    @Override\n+    int maxExp() {\n+        return E_MAX;\n+    }\n+\n+    @Override\n+    boolean isNegativeInfinity() {\n+        return v.floatValue() == Float.NEGATIVE_INFINITY;\n+    }\n+\n+    @Override\n+    boolean isPositiveInfinity() {\n+        return v.floatValue() == Float.POSITIVE_INFINITY;\n+    }\n+\n+    @Override\n+    boolean isMinusZero() {\n+        return float16ToRawShortBits(v) == 0xFFFF_8000;\n+    }\n+\n+    @Override\n+    boolean isPlusZero() {\n+        return float16ToRawShortBits(v) == 0x0000;\n+    }\n+\n+    @Override\n+    boolean isNaN() {\n+        return Float16.isNaN(v);\n+    }\n+\n+    private static void testDec(Float16 v) {\n+        new Float16ToDecimalChecker(v).check();\n+    }\n+\n+    public static void testAll() {\n+        for (int bits = Short.MIN_VALUE; bits <= Short.MAX_VALUE; ++bits) {\n+            testDec(shortBitsToFloat16((short) bits));\n+        }\n+        throwOnErrors(\"Float16ToDecimalChecker\");\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/math\/ToDecimal\/java.base\/jdk\/internal\/math\/Float16ToDecimalChecker.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -157,1 +157,9 @@\n-            if (l > h()) {\n+            \/*\n+             * For float16, strings of the form ddddd.0 are allowed,\n+             * despite the fact l == 6 > h().\n+             * In such cases, f = fz + 1, x = f, l = h() + 1.\n+             *\n+             * Similar cases for float and double are not an issue,\n+             * since l <= h() holds.\n+             *\/\n+            if (!(f - fz == 1 && x == f && l - h() == 1) && l > h()) {\n","filename":"test\/jdk\/jdk\/internal\/math\/ToDecimal\/java.base\/jdk\/internal\/math\/ToDecimalChecker.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}