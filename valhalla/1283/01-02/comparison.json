{"files":[{"patch":"@@ -1898,2 +1898,1 @@\n-\/\/ Returns the BasicType of a given convert node and a type, with special handling to ensure that conversions to\n-\/\/ and from half float will return the SHORT basic type, as that wouldn't be returned typically from TypeInt.\n+\/\/ Returns the BasicType of a given convert node based on its opcode and type\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,0 +128,18 @@\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public static int halfFloat2Int(boolean c, short a, short b) {\n+        return c ? Float16.shortBitsToFloat16(a).intValue() : Float16.shortBitsToFloat16(b).intValue();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public static long halfFloat2Long(boolean c, short a, short b) {\n+        return c ? Float16.shortBitsToFloat16(a).longValue() : Float16.shortBitsToFloat16(b).longValue();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV, \"1\"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static double halfFloat2Double(boolean c, short a, short b) {\n+        return c ? Float16.shortBitsToFloat16(a).doubleValue() : Float16.shortBitsToFloat16(b).doubleValue();\n+    }\n+\n@@ -132,1 +150,3 @@\n-                 \"float2HalfFloat\", \"halfFloat2Float\"})\n+                 \"float2HalfFloat\", \"halfFloat2Float\",\n+                 \"halfFloat2Int\", \"halfFloat2Long\",\n+                 \"halfFloat2Double\"})\n@@ -154,0 +174,3 @@\n+        Asserts.assertEQ(c ? Float16.shortBitsToFloat16(halfFloatA).intValue() : Float16.shortBitsToFloat16(halfFloatB).intValue(), halfFloat2Int(c, halfFloatA, halfFloatB));\n+        Asserts.assertEQ(c ? Float16.shortBitsToFloat16(halfFloatA).longValue() : Float16.shortBitsToFloat16(halfFloatB).longValue(), halfFloat2Long(c, halfFloatA, halfFloatB));\n+        Asserts.assertEQ(c ? Float16.shortBitsToFloat16(halfFloatA).doubleValue() : Float16.shortBitsToFloat16(halfFloatB).doubleValue(), halfFloat2Double(c, halfFloatA, halfFloatB));\n@@ -155,1 +178,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPhiDuplicatedConversion.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+              Float16.MAX_VALUE,           \/\/ FP16 Max value(0x1.ffcp15f)\n+              Float16.MIN_VALUE,           \/\/ FP16 Min value(0x1.0p-24f)\n+              Float16.MIN_NORMAL           \/\/ FP16 Min normal value(0x1.0p-14f)\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}