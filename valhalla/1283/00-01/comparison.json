{"files":[{"patch":"@@ -8576,1 +8576,1 @@\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToInt)) {\n+    if (Matcher::match_rule_supported(Op_ConvHF2I)) {\n@@ -8580,1 +8580,1 @@\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToDouble)) {\n+    if (Matcher::match_rule_supported(Op_ConvHF2D)) {\n@@ -8584,1 +8584,1 @@\n-    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToLong)) {\n+    if (Matcher::match_rule_supported(Op_ConvHF2L)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -223,4 +223,0 @@\n-  \/* Float16 conversion intrinsics *\/                                                                                   \\\n-  do_intrinsic(_float16ToDouble,          java_lang_Float16,      doubleValue_name, void_double_signature,       F_R)   \\\n-  do_intrinsic(_float16ToInt,             java_lang_Float16,      intValue_name,    void_int_signature,          F_R)   \\\n-  do_intrinsic(_float16ToLong,            java_lang_Float16,      longValue_name,   void_long_signature,         F_R)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,9 +638,0 @@\n-  case vmIntrinsics::_float16ToDouble:\n-    if (!Matcher::match_rule_supported(Op_ConvHF2D)) return false;\n-    break;\n-  case vmIntrinsics::_float16ToInt:\n-    if (!Matcher::match_rule_supported(Op_ConvHF2I)) return false;\n-    break;\n-  case vmIntrinsics::_float16ToLong:\n-    if (!Matcher::match_rule_supported(Op_ConvHF2L)) return false;\n-    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -253,0 +253,11 @@\n+\/\/------------------------------Ideal------------------------------------------\n+Node* ConvF2DNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Optimize ConvHF2F->ConvF2D sequence to ConvHF2D\n+  if (in(1)->Opcode() == Op_ConvHF2F &&\n+      Matcher::match_rule_supported(Op_ConvHF2D)) {\n+    Node* inp = in(1)->in(1);\n+    return new ConvHF2DNode(inp);\n+  }\n+  return nullptr;\n+}\n+\n@@ -268,1 +279,1 @@\n-  \/\/ Optimize pattern - ConvHF2F (SqrtF) ConvF2HF ==> ReinterpretS2HF (SqrtHF) ReinterpretHF2S.\n+  \/\/ Optimize pattern - ConvHF2D->SqrtD->ConvD2F->ConvF2HF ==> ReinterpretS2HF (SqrtHF) ReinterpretHF2S.\n@@ -273,3 +284,5 @@\n-  if (in(1)->Opcode() == Op_SqrtF && in(1)->in(1)->Opcode() == Op_ConvHF2F) {\n-    Node* sqrtf = in(1);\n-    Node* convhf2f = sqrtf->in(1);\n+  if (in(1)->Opcode() == Op_ConvD2F && in(1)->in(1)->Opcode() == Op_SqrtD &&\n+      in(1)->in(1)->in(1)->Opcode() == Op_ConvHF2D) {\n+    Node* in1 = in(1);\n+    Node* in2 = in1->in(1);\n+    Node* in3 = in2->in(1);\n@@ -279,2 +292,2 @@\n-      hf2f = phase->transform(new ReinterpretS2HFNode(convhf2f->in(1)));\n-      sqrthf = phase->transform(new SqrtHFNode(phase->C, sqrtf->in(0), hf2f));\n+      hf2f = phase->transform(new ReinterpretS2HFNode(in3->in(1)));\n+      sqrthf = phase->transform(new SqrtHFNode(phase->C, in2->in(0), hf2f));\n@@ -312,0 +325,7 @@\n+\n+  \/\/ Optimize ConvHF2F->ConvF2I sequence to ConvHF2I\n+  if (in(1)->Opcode() == Op_ConvHF2F &&\n+      Matcher::match_rule_supported(Op_ConvHF2I)) {\n+    Node* inp = in(1)->in(1);\n+    return new ConvHF2INode(inp);\n+  }\n@@ -341,0 +361,6 @@\n+  \/\/ Optimize ConvHF2F->ConvF2L sequence to ConvHF2L\n+  if (in(1)->Opcode() == Op_ConvHF2F &&\n+      Matcher::match_rule_supported(Op_ConvHF2L)) {\n+    Node* inp = in(1)->in(1);\n+    return new ConvHF2LNode(inp);\n+  }\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -559,3 +559,0 @@\n-  case vmIntrinsics::_float16ToDouble:\n-  case vmIntrinsics::_float16ToInt:\n-  case vmIntrinsics::_float16ToLong:            return inline_fp16_conversions(intrinsic_id());\n@@ -5144,20 +5141,0 @@\n-bool LibraryCallKit::inline_fp16_conversions(vmIntrinsics::ID id) {\n-  Node* arg = argument(0);\n-  if (!arg->is_InlineType()) {\n-    return false;\n-  }\n-\n-  Node* result = nullptr;\n-\n-  switch (id) {\n-  case vmIntrinsics::_float16ToDouble:  result = _gvn.transform(new ConvHF2DNode(arg->as_InlineType()->field_value(0))); break;\n-  case vmIntrinsics::_float16ToInt:     result = _gvn.transform(new ConvHF2INode(arg->as_InlineType()->field_value(0))); break;\n-  case vmIntrinsics::_float16ToLong:    result = _gvn.transform(new ConvHF2LNode(arg->as_InlineType()->field_value(0))); break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  set_result(_gvn.transform(result));\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -641,1 +641,0 @@\n-    @IntrinsicCandidate\n@@ -653,1 +652,0 @@\n-    @IntrinsicCandidate\n@@ -684,1 +682,0 @@\n-    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package compiler.c2.irTests;\n-\n-import compiler.lib.ir_framework.*;\n-import static java.lang.Float16.*;\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @bug 8338061\n- * @summary Test that Ideal transformations of ConvF2HF are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.irTests.ConvF2HFIdealizationTests\n- *\/\n-public class ConvF2HFIdealizationTests {\n-    private short[] sin;\n-    private short[] sout;\n-    private static final int SIZE = 65504;\n-    public ConvF2HFIdealizationTests() {\n-        sin  = new short[SIZE];\n-        sout = new short[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            sin[i] = Float.floatToFloat16((float)i);\n-        }\n-    }\n-    public static void main(String[] args) {\n-        TestFramework.runWithFlags(\"--enable-preview\", \"-XX:-UseSuperWord\");\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.SQRT_HF, \">=1\", IRNode.REINTERPRET_S2HF, \">=1\", IRNode.REINTERPRET_HF2S, \">=1\"},\n-        failOn = {IRNode.SQRT_F, IRNode.CONV_HF2F, IRNode.CONV_F2HF},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n-    \/\/ Test pattern - ConvHF2F -> ConvF2D -> SqrtD -> ConvD2F -> ConvF2HF is optimized to ReinterpretS2HF -> SqrtHF -> ReinterpretHF2S\n-    public void test1() {\n-        for (int i = 0; i < SIZE; i++) {\n-            sout[i] = Float.floatToFloat16((float)Math.sqrt(Float16.shortBitsToFloat16(sin[i]).floatValue()));\n-        }\n-    }\n-\n-    @Check(test=\"test1\")\n-    public void checkResult() {\n-        for (int i = 0; i < SIZE; i++) {\n-            short expected = Float16.float16ToRawShortBits(Float16.sqrt(Float16.shortBitsToFloat16(sin[i])));\n-            if (expected != sout[i]) {\n-                throw new RuntimeException(\"Invalid result: sout[\" + i + \"] = \" + sout[i] + \" != \" + expected);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConvF2HFIdealizationTests.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import static java.lang.Float16.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8338061\n+ * @summary Test that Ideal transformations of ConvF2HF, ConvF2D, ConvF2I and ConvF2L\n+ * for generating FP16 nodes is performing as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ConvF2XIdealizationTests\n+ *\/\n+public class ConvF2XIdealizationTests {\n+    private short[] sin;\n+    private short[] sout;\n+    private int[] iout;\n+    private long[] lout;\n+    private double[] dout;\n+\n+    private static final int SIZE = 65504;\n+    public ConvF2XIdealizationTests() {\n+        sin  = new short[SIZE];\n+        sout = new short[SIZE];\n+        iout = new int[SIZE];\n+        dout = new double[SIZE];\n+        lout = new long[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            sin[i] = Float.floatToFloat16((float)i);\n+        }\n+    }\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--enable-preview\", \"-XX:-UseSuperWord\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SQRT_HF, \">=1\", IRNode.REINTERPRET_S2HF, \">=1\", IRNode.REINTERPRET_HF2S, \">=1\"},\n+        failOn = {IRNode.SQRT_F, IRNode.CONV_HF2F, IRNode.CONV_F2HF},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    \/\/ Test pattern - ConvHF2F -> ConvF2D -> SqrtD -> ConvD2F -> ConvF2HF is optimized to ReinterpretS2HF -> SqrtHF -> ReinterpretHF2S\n+    public void test1() {\n+        for (int i = 0; i < SIZE; i++) {\n+            sout[i] = Float.floatToFloat16((float)Math.sqrt(shortBitsToFloat16(sin[i]).floatValue()));\n+        }\n+    }\n+\n+    @Check(test=\"test1\")\n+    public void checkTest1() {\n+        for (int i = 0; i < SIZE; i++) {\n+            short expected = float16ToRawShortBits(sqrt(shortBitsToFloat16(sin[i])));\n+            if (expected != sout[i]) {\n+                throw new RuntimeException(\"Invalid result for test1 : sout[\" + i + \"] = \" + sout[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_HF2I, \">=1\"},\n+        failOn = {IRNode.CONV_HF2F, IRNode.CONV_F2I},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    \/\/ Test to verify if ConvHF2F -> ConvF2I is optimized to ConvHF2I\n+    public void test2() {\n+        for (int i = 0; i < SIZE; i++) {\n+            iout[i] = shortBitsToFloat16(sin[i]).intValue();\n+        }\n+    }\n+\n+    @Check(test=\"test2\")\n+    public void checkTest2() {\n+        int expected = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            expected = Float.valueOf(shortBitsToFloat16(sin[i]).floatValue()).intValue();\n+            if (expected != iout[i]) {\n+                throw new RuntimeException(\"Invalid result for test2 : iout[\" + i + \"] = \" + iout[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_HF2L, \">=1\"},\n+        failOn = {IRNode.CONV_HF2F, IRNode.CONV_F2L},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    \/\/ Test to verify if ConvHF2F -> ConvF2L is optimized to ConvHF2L\n+    public void test3() {\n+        for (int i = 0; i < SIZE; i++) {\n+            lout[i] = shortBitsToFloat16(sin[i]).longValue();\n+        }\n+    }\n+\n+    @Check(test=\"test3\")\n+    public void checkTest3() {\n+        long expected = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            expected = Float.valueOf(shortBitsToFloat16(sin[i]).floatValue()).longValue();\n+            if (expected != lout[i]) {\n+                throw new RuntimeException(\"Invalid result for test3 : lout[\" + i + \"] = \" + lout[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_HF2D, \">=1\"},\n+        failOn = {IRNode.CONV_HF2F, IRNode.CONV_F2D},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    \/\/ Test to verify if ConvHF2F -> ConvF2D is optimized to ConvHF2D\n+    public void test4() {\n+        for (int i = 0; i < SIZE; i++) {\n+            dout[i] = shortBitsToFloat16(sin[i]).doubleValue();\n+        }\n+    }\n+\n+    @Check(test=\"test4\")\n+    public void checkTest4() {\n+        double expected = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            expected = Float.valueOf(shortBitsToFloat16(sin[i]).floatValue()).doubleValue();\n+            if (expected != dout[i]) {\n+                throw new RuntimeException(\"Invalid result for test4 : dout[\" + i + \"] = \" + dout[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConvF2XIdealizationTests.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -480,0 +480,15 @@\n+    public static final String CONV_F2I = PREFIX + \"CONV_F2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2I, \"ConvF2I\");\n+    }\n+\n+    public static final String CONV_F2L = PREFIX + \"CONV_F2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2L, \"ConvF2L\");\n+    }\n+\n+    public static final String CONV_F2D = PREFIX + \"CONV_F2D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2D, \"ConvF2D\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}