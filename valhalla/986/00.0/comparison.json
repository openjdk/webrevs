{"files":[{"patch":"@@ -1090,1 +1090,1 @@\n-        windows_x64: \"VS2022-17.1.0+1.1\",\n+        windows_x64: \"VS2022-17.6.5+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -855,0 +855,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libfast-math := -ffast-math\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -400,0 +400,1 @@\n+  CHECK_BAILOUT_(no_frame_size);\n@@ -449,2 +450,0 @@\n-  CompilationMemoryStatisticMark cmsm(env()->task()->directive());\n-\n@@ -456,0 +455,2 @@\n+    CHECK_BAILOUT();\n+\n@@ -609,0 +610,2 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n+\n@@ -614,0 +617,1 @@\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  bool               _oom;\n@@ -208,0 +209,4 @@\n+  \/\/ MemLimit handling\n+  bool oom() const { return _oom; }\n+  void set_oom() { _oom = true; }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-#include \"logging\/logStream.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -55,0 +55,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -66,1 +67,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"cds\/classListWriter.hpp\"\n+#include \"cds\/cds_globals.hpp\"\n@@ -34,0 +34,1 @@\n+#include \"cds\/classListWriter.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"classfile\/modules.hpp\"\n@@ -48,1 +50,1 @@\n-#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n@@ -66,0 +68,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -82,1 +85,1 @@\n-#include \"runtime\/vmThread.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -85,1 +88,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -88,1 +90,1 @@\n-#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -391,0 +393,1 @@\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n@@ -483,0 +486,2 @@\n+  \/\/ Write module name into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n@@ -767,2 +772,0 @@\n-  HeapShared::init_for_dumping(CHECK);\n-\n@@ -782,0 +785,5 @@\n+    if (!HeapShared::is_archived_boot_layer_available(THREAD)) {\n+      log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n+      disable_full_module_graph();\n+    }\n+    HeapShared::init_for_dumping(CHECK);\n@@ -1167,2 +1175,2 @@\n-    log_info(cds)(\"optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-  bool failing() { return _failure_reason != nullptr; }\n+  bool failing() const { return _failure_reason != nullptr; }\n@@ -331,1 +331,1 @@\n-  const char* failure_reason() { return _failure_reason; }\n+  const char* failure_reason() const { return _failure_reason; }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,16 +89,0 @@\n-\/\/ Entry points in zip.dll for loading zip\/jar file entries\n-\n-typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);\n-typedef void     (*ZipClose_t)(jzfile *zip);\n-typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);\n-typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);\n-typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);\n-\n-static ZipOpen_t         ZipOpen            = nullptr;\n-static ZipClose_t        ZipClose           = nullptr;\n-static FindEntry_t       FindEntry          = nullptr;\n-static ReadEntry_t       ReadEntry          = nullptr;\n-static Crc32_t           Crc32              = nullptr;\n-int    ClassLoader::_libzip_loaded          = 0;\n-void*  ClassLoader::_zip_handle             = nullptr;\n-\n@@ -295,1 +279,1 @@\n-  (*ZipClose)(_zip);\n+  ZipLibrary::close(_zip);\n@@ -304,1 +288,1 @@\n-  jzentry* entry = (*FindEntry)(_zip, name, filesize, &name_len);\n+  jzentry* entry = ZipLibrary::find_entry(_zip, name, filesize, &name_len);\n@@ -324,1 +308,3 @@\n-  if (!(*ReadEntry)(_zip, entry, buffer, filename)) return nullptr;\n+  if (!ZipLibrary::read_entry(_zip, entry, buffer, filename)) {\n+    return nullptr;\n+  }\n@@ -727,2 +713,1 @@\n-  load_zip_library_if_needed();\n-  return (*ZipOpen)(canonical_path, error_msg);\n+  return ZipLibrary::open(canonical_path, error_msg);\n@@ -940,26 +925,0 @@\n-void ClassLoader::release_load_zip_library() {\n-  ConditionalMutexLocker locker(Zip_lock, Zip_lock != nullptr, Monitor::_no_safepoint_check_flag);\n-  if (_libzip_loaded == 0) {\n-    load_zip_library();\n-    Atomic::release_store(&_libzip_loaded, 1);\n-  }\n-}\n-\n-void ClassLoader::load_zip_library() {\n-  assert(ZipOpen == nullptr, \"should not load zip library twice\");\n-  char path[JVM_MAXPATHLEN];\n-  char ebuf[1024];\n-  if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), \"zip\")) {\n-    _zip_handle = os::dll_load(path, ebuf, sizeof ebuf);\n-  }\n-  if (_zip_handle == nullptr) {\n-    vm_exit_during_initialization(\"Unable to load zip library\", path);\n-  }\n-\n-  ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(_zip_handle, \"ZIP_Open\", path));\n-  ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(_zip_handle, \"ZIP_Close\", path));\n-  FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(_zip_handle, \"ZIP_FindEntry\", path));\n-  ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(_zip_handle, \"ZIP_ReadEntry\", path));\n-  Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(_zip_handle, \"ZIP_CRC32\", path));\n-}\n-\n@@ -985,2 +944,1 @@\n-  load_zip_library_if_needed();\n-  return (*Crc32)(crc, (const jbyte*)buf, len);\n+  return ZipLibrary::crc32(crc, (const jbyte*)buf, len);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":7,"deletions":49,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2535,1 +2535,1 @@\n-    {\n+    if (THREAD->can_call_java()) {\n@@ -2557,0 +2557,3 @@\n+    } else {\n+      st->print_raw_cr(\"<<cannot call Java to get cause>>\");\n+      return;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-  assert(THREAD->can_call_java(),\n+  guarantee(THREAD->can_call_java(),\n@@ -2140,1 +2140,1 @@\n-  assert(THREAD->can_call_java() ,\"\");\n+  guarantee(THREAD->can_call_java(), \"\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -84,1 +85,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -238,8 +238,3 @@\n-      \/\/ In PSCardTable::scavenge_contents_parallel(), when work is distributed\n-      \/\/ among different workers, an object is never split between multiple workers.\n-      \/\/ Therefore, if a worker gets owned a large objArray, it may accumulate\n-      \/\/ many tasks (corresponding to every element in this array) in its\n-      \/\/ task queue. When there are too many overflow tasks, publishing them\n-      \/\/ (via try_push_to_taskqueue()) can incur noticeable overhead in Young GC\n-      \/\/ pause, so it is better to process them locally until large-objArray-splitting is implemented.\n-      process_popped_location_depth(task);\n+      if (!tq->try_push_to_taskqueue(task)) {\n+        process_popped_location_depth(task);\n+      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  JavaThread* THREAD = thread;                                        \\\n+  JavaThread* THREAD = thread;                                    \\\n@@ -172,4 +172,9 @@\n-#define C2V_BLOCK(result_type, name, signature)      \\\n-  JVMCI_VM_ENTRY_MARK;                               \\\n-  ResourceMark rm;                                   \\\n-  JVMCIENV_FROM_JNI(JVMCI::compilation_tick(thread), env);\n+\/\/ Note: CompilerThreadCanCallJava must precede JVMCIENV_FROM_JNI so that\n+\/\/ the translation of an uncaught exception in the JVMCIEnv does not make\n+\/\/ a Java call when __is_hotspot == false.\n+#define C2V_BLOCK(result_type, name, signature)            \\\n+  JVMCI_VM_ENTRY_MARK;                                     \\\n+  ResourceMark rm;                                         \\\n+  bool __is_hotspot = env == thread->jni_environment();    \\\n+  CompilerThreadCanCallJava ccj(thread, __is_hotspot);     \\\n+  JVMCIENV_FROM_JNI(JVMCI::compilation_tick(thread), env); \\\n@@ -191,1 +196,1 @@\n-  if (thread == nullptr) {                                  \\\n+  if (thread == nullptr) {                               \\\n@@ -202,1 +207,1 @@\n-  if (thread == nullptr) {                                  \\\n+  if (thread == nullptr) {                               \\\n@@ -224,1 +229,1 @@\n-      tty->print_cr(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n+      JVMCI_event_1(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n@@ -232,1 +237,1 @@\n-      tty->print_cr(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n+      JVMCI_event_1(\"Throwing \" #name \" in \" caller \" returned %d\", __throw_res); \\\n@@ -582,0 +587,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, resolve); \/\/ Resolution requires Java calls\n@@ -595,1 +601,1 @@\n-    } else if (strstr(val, str) != nullptr) {\n+    } else if (strstr(str, val) != nullptr) {\n@@ -941,0 +947,11 @@\n+\n+  Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) & 0xFF);\n+  int holder_index = cp->klass_ref_index_at(index, bc);\n+  if (!cp->tag_at(holder_index).is_klass() && !THREAD->can_call_java()) {\n+    \/\/ If the holder is not resolved in the constant pool and the current\n+    \/\/ thread cannot call Java, return null. This avoids a Java call\n+    \/\/ in LinkInfo to load the holder.\n+    Symbol* klass_name = cp->klass_ref_at_noresolve(index, bc);\n+    return nullptr;\n+  }\n+\n@@ -1964,0 +1981,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Linking requires Java calls\n@@ -2729,0 +2747,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, PEER_JVMCIENV->is_hotspot());\n@@ -2782,2 +2801,2 @@\n-        \/\/ Only HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.\n-        if (PEER_JVMCIENV->is_hotspot()) {\n+        \/\/ Only non-default HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.\n+        if (!isDefault && PEER_JVMCIENV->is_hotspot()) {\n@@ -2786,1 +2805,1 @@\n-            JVMCI_THROW_MSG_0(IllegalArgumentException, \"Cannot set HotSpotNmethod mirror for default nmethod\");\n+            JVMCI_THROW_MSG_0(IllegalArgumentException, \"Missing HotSpotNmethod data\");\n@@ -2948,0 +2967,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n@@ -2954,0 +2974,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n@@ -2960,0 +2981,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true); \/\/ Requires Java support\n@@ -3016,0 +3038,1 @@\n+  CompilerThreadCanCallJava canCallJava(thread, true);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2737,1 +2737,3 @@\n-      InstanceKlass* impl = Atomic::load_acquire(adr_implementor());\n+      InstanceKlass* volatile* iklass = adr_implementor();\n+      assert(iklass != nullptr, \"Klass must not be null\");\n+      InstanceKlass* impl = Atomic::load_acquire(iklass);\n@@ -2740,1 +2742,0 @@\n-        InstanceKlass* volatile* iklass = adr_implementor();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"logging\/logTag.hpp\"\n+#include \"logging\/logTag.hpp\"\n@@ -52,0 +52,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -76,1 +77,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -679,0 +680,1 @@\n+                  _oom(false),\n@@ -965,0 +967,1 @@\n+    _oom(false),\n@@ -5812,0 +5815,3 @@\n+void Compile::record_method_not_compilable_oom() {\n+  record_method_not_compilable(CompilationMemoryStatistic::failure_reason_memlimit());\n+}\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -470,0 +470,3 @@\n+  \/\/ \"MemLimit\" directive was specified and the memory limit was hit during compilation\n+  bool                          _oom;\n+\n@@ -513,0 +516,2 @@\n+  void record_method_not_compilable_oom();\n+\n@@ -843,0 +848,4 @@\n+    if (oom()) {\n+      record_method_not_compilable_oom();\n+      return true;\n+    }\n@@ -850,0 +859,2 @@\n+  bool oom() const { return _oom; }\n+  void set_oom()   { _oom = true; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -186,0 +186,21 @@\n+void MachNode::fill_new_machnode(MachNode* node) const {\n+  \/\/ New node must use same node index\n+  node->set_idx(_idx);\n+  \/\/ Copy machine-independent inputs\n+  for (uint j = 0; j < req(); j++) {\n+    node->add_req(in(j));\n+  }\n+  \/\/ Copy my operands, except for cisc position\n+  int nopnds = num_opnds();\n+  assert(node->num_opnds() == (uint)nopnds, \"Must have same number of operands\");\n+  MachOper** to = node->_opnds;\n+  for (int i = 0; i < nopnds; i++) {\n+    if (i != cisc_operand()) {\n+      to[i] = _opnds[i]->clone();\n+    }\n+  }\n+  \/\/ Do not increment node index counter, since node reuses my index\n+  Compile* C = Compile::current();\n+  C->set_unique(C->unique() - 1);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-  \/\/ Copy inputs and operands to new node of instruction.\n+  \/\/ Copy index, inputs, and operands to a new version of the instruction.\n@@ -235,1 +235,0 @@\n-  \/\/ !!!! The method's body is defined in ad_<arch>.cpp file.\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,12 @@\n+      if (subk->is_same_java_type_as(superk) && !sub_t->maybe_null()) {\n+        \/\/ The super_t has no subclasses, and sub_t has the same type and is not null,\n+        \/\/ hence the check should always evaluate to EQ. However, this is an impossible\n+        \/\/ situation since super_t is also abstract, and hence sub_t cannot have the\n+        \/\/ same type and be non-null.\n+        \/\/ Still, if the non-static method of an abstract class without subclasses is\n+        \/\/ force-compiled, the Param0 has the self\/this pointer with NotNull. This\n+        \/\/ method would now never be called, because of the leaf-type dependency. Hence,\n+        \/\/ just for consistency with verification, we return EQ.\n+        return TypeInt::CC_EQ;\n+      }\n+      \/\/ subk is either a supertype of superk, or null. In either case, superk is a subtype.\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -60,1 +61,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -93,1 +94,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+#include \"utilities\/zipLibrary.hpp\"\n@@ -3519,2 +3520,1 @@\n-  ClassLoader::load_zip_library_if_needed();\n-  return ClassLoader::zip_library_handle();\n+  return ZipLibrary::handle();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+#include \"nmt\/mallocSiteTable.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n@@ -94,2 +96,0 @@\n-#include \"services\/mallocSiteTable.hpp\"\n-#include \"services\/memTracker.hpp\"\n@@ -127,2 +127,2 @@\n-#include \"os_linux.hpp\"\n-#include \"osContainer_linux.hpp\"\n+#include \"osContainer_linux.hpp\"\n+#include \"os_linux.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n@@ -62,1 +63,0 @@\n-#include \"services\/nmtCommon.hpp\"\n@@ -1266,2 +1266,1 @@\n-  if (is_internal_module_property(key) ||\n-      strcmp(key, \"jdk.module.main\") == 0) {\n+  if (is_internal_module_property(key)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"nmt\/memTracker.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n@@ -37,2 +39,0 @@\n-#include \"prims\/downcallLinker.hpp\"\n-#include \"runtime\/globals.hpp\"\n@@ -42,0 +42,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  } else {\n+  } else if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n@@ -206,5 +206,1 @@\n-    if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n-      result = JNILocalRefType;\n-    } else {\n-      ShouldNotReachHere();\n-    }\n+    result = JNILocalRefType;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -43,0 +43,1 @@\n+#include \"nmt\/nmtDCmd.hpp\"\n@@ -62,1 +63,0 @@\n-#include \"services\/nmtDCmd.hpp\"\n@@ -70,1 +70,1 @@\n-#include \"trimCHeapDCmd.hpp\"\n+#include \"trimCHeapDCmd.hpp\"\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-class AbstractDumpWriter : public ResourceObj {\n+class AbstractDumpWriter : public CHeapObj<mtInternal> {\n@@ -2449,1 +2449,3 @@\n-    remove(path);\n+    if (remove(path) != 0) {\n+      log_info(heapdump)(\"Removal of segment file (%d) failed (%d)\", i, errno);\n+    }\n@@ -2867,0 +2869,1 @@\n+      delete local_writer;\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -108,2 +108,2 @@\n-  static bool special_exception(JavaThread* thread, const char* file, int line, Handle exception);\n-  static bool special_exception(JavaThread* thread, const char* file, int line, Symbol* name, const char* message);\n+  \/\/ Either `exception` or `symbol` must be non-null but not both.\n+  static bool special_exception(JavaThread* thread, const char* file, int line, Handle exception, Symbol* name = nullptr, const char* message = nullptr);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -417,0 +417,29 @@\n+\n+\/\/ Check for Flush-To-Zero mode\n+\n+\/\/ On some processors faster execution can be achieved by setting a\n+\/\/ mode to return zero for extremely small results, rather than an\n+\/\/ IEEE-754 subnormal number. This mode is not compatible with the\n+\/\/ Java Language Standard.\n+\n+\/\/ We need the addition of _large_subnormal and _small_subnormal to be\n+\/\/ performed at runtime. _small_subnormal is volatile so that\n+\/\/ expressions involving it cannot be evaluated at compile time.\n+static const double large_subnormal_double\n+  = jdouble_cast(0x0030000000000000); \/\/ 0x1.0p-1020;\n+static const volatile double small_subnormal_double\n+  = jdouble_cast(0x0000000000000003); \/\/ 0x0.0000000000003p-1022;\n+\n+\/\/ Quickly test to make sure IEEE-754 subnormal numbers are correctly\n+\/\/ handled.\n+bool IEEE_subnormal_handling_OK() {\n+  \/\/ _small_subnormal is the smallest subnormal number that has two\n+  \/\/ bits set. _large_subnormal is a number such that, when\n+  \/\/ _small_subnormal is added to it, must be rounded according to the\n+  \/\/ mode. These two tests detect the rounding mode in use. If\n+  \/\/ subnormals are turned off (i.e. subnormals-are-zero) flush-to-\n+  \/\/ zero mode is in use.\n+\n+  return (large_subnormal_double + small_subnormal_double > large_subnormal_double\n+          && -large_subnormal_double - small_subnormal_double < -large_subnormal_double);\n+}\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1359,0 +1359,4 @@\n+\/\/ Quickly test to make sure IEEE-754 subnormal numbers are correctly\n+\/\/ handled.\n+bool IEEE_subnormal_handling_OK();\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2693,1 +2693,1 @@\n-                return loader.nameAndId();\n+                return loader != null ? loader.nameAndId() : \"null\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static java.lang.invoke.MethodHandleStatics.VAR_HANDLE_SEGMENT_FORCE_EXACT;\n@@ -335,1 +336,1 @@\n-        boolean exact = false;\n+        boolean exact = VAR_HANDLE_SEGMENT_FORCE_EXACT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-        @JEP(number=443, title=\"Unnamed Patterns and Variables\")\n-        UNNAMED,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-         * @since 21\n+         * @since 22\n@@ -235,1 +235,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-     * @since 21\n+     * @since 22\n@@ -286,1 +286,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -676,1 +676,1 @@\n-     * @since 21\n+     * @since 22\n@@ -679,1 +679,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-        UNNAMED_VARIABLES(JDK21, Fragments.FeatureUnnamedVariables, DiagKind.PLURAL),\n+        UNNAMED_VARIABLES(JDK22, Fragments.FeatureUnnamedVariables, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -40,0 +41,1 @@\n+import java.util.function.Predicate;\n@@ -2312,0 +2314,1 @@\n+                addTypeAnnotationsToSymbol(sym, newList);\n@@ -2318,0 +2321,298 @@\n+    \/**\n+     * Rewrites types in the given symbol to include type annotations.\n+     *\n+     * <p>The list of type annotations includes annotations for all types in the signature of the\n+     * symbol. Associating the annotations with the correct type requires interpreting the JVMS\n+     * 4.7.20-A target_type to locate the correct type to rewrite, and then interpreting the JVMS\n+     * 4.7.20.2 type_path to associate the annotation with the correct contained type.\n+     *\/\n+    private static void addTypeAnnotationsToSymbol(\n+            Symbol s, List<Attribute.TypeCompound> attributes) {\n+        new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+    }\n+\n+    private static class TypeAnnotationSymbolVisitor\n+            extends Types.DefaultSymbolVisitor<Void, Void> {\n+\n+        private final List<Attribute.TypeCompound> attributes;\n+\n+        private TypeAnnotationSymbolVisitor(List<Attribute.TypeCompound> attributes) {\n+            this.attributes = attributes;\n+        }\n+\n+        @Override\n+        public Void visitClassSymbol(Symbol.ClassSymbol s, Void unused) {\n+            ClassType t = (ClassType) s.type;\n+            int i = 0;\n+            ListBuffer<Type> interfaces = new ListBuffer<>();\n+            for (Type itf : t.interfaces_field) {\n+                interfaces.add(addTypeAnnotations(itf, classExtends(i++)));\n+            }\n+            t.interfaces_field = interfaces.toList();\n+            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n+            if (t.typarams_field != null) {\n+                t.typarams_field =\n+                        rewriteTypeParameters(\n+                                t.typarams_field, TargetType.CLASS_TYPE_PARAMETER_BOUND);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitMethodSymbol(Symbol.MethodSymbol s, Void unused) {\n+            Type t = s.type;\n+            if (t.hasTag(TypeTag.FORALL)) {\n+                Type.ForAll fa = (Type.ForAll) t;\n+                fa.tvars = rewriteTypeParameters(fa.tvars, TargetType.METHOD_TYPE_PARAMETER_BOUND);\n+                t = fa.qtype;\n+            }\n+            MethodType mt = (MethodType) t;\n+            ListBuffer<Type> argtypes = new ListBuffer<>();\n+            int i = 0;\n+            for (Symbol.VarSymbol param : s.params) {\n+                param.type = addTypeAnnotations(param.type, methodFormalParameter(i++));\n+                argtypes.add(param.type);\n+            }\n+            mt.argtypes = argtypes.toList();\n+            ListBuffer<Type> thrown = new ListBuffer<>();\n+            i = 0;\n+            for (Type thrownType : mt.thrown) {\n+                thrown.add(addTypeAnnotations(thrownType, thrownType(i++)));\n+            }\n+            mt.thrown = thrown.toList();\n+            mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            if (mt.recvtype != null) {\n+                mt.recvtype = addTypeAnnotations(mt.recvtype, TargetType.METHOD_RECEIVER);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVarSymbol(Symbol.VarSymbol s, Void unused) {\n+            s.type = addTypeAnnotations(s.type, TargetType.FIELD);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitSymbol(Symbol s, Void unused) {\n+            return null;\n+        }\n+\n+        private List<Type> rewriteTypeParameters(List<Type> tvars, TargetType boundType) {\n+            ListBuffer<Type> tvarbuf = new ListBuffer<>();\n+            int typeVariableIndex = 0;\n+            for (Type tvar : tvars) {\n+                Type bound = tvar.getUpperBound();\n+                if (bound.isCompound()) {\n+                    ClassType ct = (ClassType) bound;\n+                    int boundIndex = 0;\n+                    if (ct.supertype_field != null) {\n+                        ct.supertype_field =\n+                                addTypeAnnotations(\n+                                        ct.supertype_field,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++));\n+                    }\n+                    ListBuffer<Type> itfbuf = new ListBuffer<>();\n+                    for (Type itf : ct.interfaces_field) {\n+                        itfbuf.add(\n+                                addTypeAnnotations(\n+                                        itf,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++)));\n+                    }\n+                    ct.interfaces_field = itfbuf.toList();\n+                } else {\n+                    bound =\n+                            addTypeAnnotations(\n+                                    bound,\n+                                    typeParameterBound(\n+                                            boundType,\n+                                            typeVariableIndex,\n+                                            bound.isInterface() ? 1 : 0));\n+                }\n+                ((TypeVar) tvar).setUpperBound(bound);\n+                tvarbuf.add(tvar);\n+                typeVariableIndex++;\n+            }\n+            return tvarbuf.toList();\n+        }\n+\n+        private Type addTypeAnnotations(Type type, TargetType targetType) {\n+            return addTypeAnnotations(type, pos -> pos.type == targetType);\n+        }\n+\n+        private Type addTypeAnnotations(Type type, Predicate<TypeAnnotationPosition> filter) {\n+            Assert.checkNonNull(type);\n+\n+            \/\/ Find type annotations that match the given target type\n+            ListBuffer<Attribute.TypeCompound> filtered = new ListBuffer<>();\n+            for (Attribute.TypeCompound attribute : this.attributes) {\n+                if (filter.test(attribute.position)) {\n+                    filtered.add(attribute);\n+                }\n+            }\n+            if (filtered.isEmpty()) {\n+                return type;\n+            }\n+\n+            \/\/ Group the matching annotations by their type path. Each group of annotations will be\n+            \/\/ added to a type at that location.\n+            Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>>\n+                    attributesByPath = new HashMap<>();\n+            for (Attribute.TypeCompound attribute : filtered.toList()) {\n+                attributesByPath\n+                        .computeIfAbsent(attribute.position.location, k -> new ListBuffer<>())\n+                        .add(attribute);\n+            }\n+\n+            \/\/ Search the structure of the type to find the contained types at each type path\n+            Map<Type, List<Attribute.TypeCompound>> attributesByType = new HashMap<>();\n+            new TypeAnnotationLocator(attributesByPath, attributesByType).visit(type, List.nil());\n+\n+            \/\/ Rewrite the type and add the annotations\n+            type = new TypeAnnotationTypeMapping(attributesByType).visit(type, null);\n+            Assert.check(attributesByType.isEmpty(), \"Failed to apply annotations to types\");\n+\n+            return type;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> typeParameterBound(\n+                TargetType targetType, int parameterIndex, int boundIndex) {\n+            return pos ->\n+                    pos.type == targetType\n+                            && pos.parameter_index == parameterIndex\n+                            && pos.bound_index == boundIndex;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> methodFormalParameter(int index) {\n+            return pos ->\n+                    pos.type == TargetType.METHOD_FORMAL_PARAMETER && pos.parameter_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> thrownType(int index) {\n+            return pos -> pos.type == TargetType.THROWS && pos.type_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> classExtends(int index) {\n+            return pos -> pos.type == TargetType.CLASS_EXTENDS && pos.type_index == index;\n+        }\n+    }\n+\n+    \/**\n+     * Visit all contained types, assembling a type path to represent the current location, and\n+     * record the types at each type path that need to be annotated.\n+     *\/\n+    private static class TypeAnnotationLocator\n+            extends Types.DefaultTypeVisitor<Void, List<TypeAnnotationPosition.TypePathEntry>> {\n+        private final Map<List<TypeAnnotationPosition.TypePathEntry>,\n+                          ListBuffer<Attribute.TypeCompound>> attributesByPath;\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationLocator(\n+                Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>>\n+                        attributesByPath,\n+                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByPath = attributesByPath;\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            \/\/ As described in JVMS 4.7.20.2, type annotations on nested types are located with\n+            \/\/ 'left-to-right' steps starting on 'the outermost part of the type for which a type\n+            \/\/ annotation is admissible'. So the current path represents the outermost containing\n+            \/\/ type of the type being visited, and we add type path steps for every contained nested\n+            \/\/ type.\n+            List<ClassType> enclosing = List.nil();\n+            for (Type curr = t;\n+                    curr != null && curr != Type.noType;\n+                    curr = curr.getEnclosingType()) {\n+                enclosing = enclosing.prepend((ClassType) curr);\n+            }\n+            for (ClassType te : enclosing) {\n+                if (te.typarams_field != null) {\n+                    int i = 0;\n+                    for (Type typaram : te.typarams_field) {\n+                        visit(typaram, path.append(new TypeAnnotationPosition.TypePathEntry(\n+                                TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i++)));\n+                    }\n+                }\n+                visitType(te, path);\n+                path = path.append(TypeAnnotationPosition.TypePathEntry.INNER_TYPE);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(\n+                WildcardType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.type, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n+            return super.visitWildcardType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n+            return super.visitArrayType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n+            if (attributes != null) {\n+                attributesByType.put(t, attributes.toList());\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/** A type mapping that rewrites the type to include type annotations. *\/\n+    private static class TypeAnnotationTypeMapping extends Type.StructuralTypeMapping<Void> {\n+\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationTypeMapping(\n+                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        private <T extends Type> Type reannotate(T t, BiFunction<T, Void, Type> f) {\n+            \/\/ We're relying on object identify of Type instances to record where the annotations\n+            \/\/ need to be added, so we have to retrieve the annotations for each type before\n+            \/\/ rewriting it, and then add them after its contained types have been rewritten.\n+            List<Attribute.TypeCompound> attributes = attributesByType.remove(t);\n+            Type mapped = f.apply(t, null);\n+            if (attributes == null) {\n+                return mapped;\n+            }\n+            \/\/ Runtime-visible and -invisible annotations are completed separately, so if the same\n+            \/\/ type has annotations from both it will get annotated twice.\n+            TypeMetadata.Annotations existing = mapped.getMetadata(TypeMetadata.Annotations.class);\n+            if (existing != null) {\n+                existing.annotationBuffer().addAll(attributes);\n+                return mapped;\n+            }\n+            return mapped.annotatedType(attributes);\n+        }\n+\n+        @Override\n+        public Type visitClassType(ClassType t, Void unused) {\n+            return reannotate(t, super::visitClassType);\n+        }\n+\n+        @Override\n+        public Type visitWildcardType(WildcardType t, Void unused) {\n+            return reannotate(t, super::visitWildcardType);\n+        }\n+\n+        @Override\n+        public Type visitArrayType(ArrayType t, Void unused) {\n+            return reannotate(t, super::visitArrayType);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void unused) {\n+            return reannotate(t, (x, u) -> x);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":301,"deletions":0,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import static com.sun.tools.javac.code.TypeTag.DOUBLE;\n@@ -38,0 +39,1 @@\n+import static com.sun.tools.javac.code.TypeTag.LONG;\n@@ -406,1 +408,4 @@\n-        if (od <= 255) {\n+        Type constantType = types.constantType(constant);\n+        if (constantType.hasTag(LONG) || constantType.hasTag(DOUBLE)) {\n+            emitop2(ldc2w, od, constant);\n+        } else if (od <= 255) {\n@@ -408,2 +413,1 @@\n-        }\n-        else {\n+        } else {\n@@ -1075,0 +1079,1 @@\n+        case ldc2:\n@@ -1082,3 +1087,0 @@\n-        case ldc2:\n-            state.push(types.constantType((LoadableConstant)data));\n-            break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -593,9 +593,0 @@\n-\n-        private void ldc() {\n-            if (typecode == LONGcode || typecode == DOUBLEcode) {\n-                code.emitop2(ldc2w, value, PoolWriter::putConstant);\n-            } else {\n-                code.emitLdc(value);\n-            }\n-        }\n-\n@@ -617,1 +608,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -624,1 +615,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -631,1 +622,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -639,1 +630,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -642,1 +633,1 @@\n-                ldc();\n+                code.emitLdc(value);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -687,2 +687,2 @@\n-                if (preview.isEnabled() && Feature.UNNAMED_VARIABLES.allowedInSource(source)) {\n-                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UseOfUnderscoreNotAllowed);\n+                if (Feature.UNNAMED_VARIABLES.allowedInSource(source)) {\n+                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UseOfUnderscoreNotAllowedNonVariable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3216,2 +3216,6 @@\n-    as of release 21, the underscore keyword ''_'' is only allowed to declare\\n\\\n-    unnamed patterns, local variables, exception parameters or lambda parameters\n+    underscore not allowed here\\n\\\n+    as of release 9, ''_'' is a keyword, and may not be used as an identifier\\n\\\n+    as of release 22, ''_'' can be used as a name in the declaration of unnamed patterns, local variables, exception parameters or lambda parameters\n+\n+compiler.err.use.of.underscore.not.allowed.non.variable=\\\n+    underscore not allowed here\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -336,1 +336,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+compiler\/floatingpoint\/TestSubnormalFloat.java 8317810 generic-i586\n+compiler\/floatingpoint\/TestSubnormalDouble.java 8317810 generic-i586\n+\n@@ -182,3 +185,0 @@\n-gtest\/GTestWrapper.java 8306561 aix-ppc64\n-gtest\/NMTGtests.java#nmt-detail 8306561 aix-ppc64\n-gtest\/NMTGtests.java#nmt-summary 8306561 aix-ppc64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+    ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/PatchModule\/PatchModuleDupModule.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        return ProcessTools.createJavaProcessBuilder(argsList);\n+        return ProcessTools.createTestJavaProcessBuilder(argsList);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -505,1 +505,0 @@\n-java\/io\/File\/createTempFile\/SpecialTempFile.java                8274122 windows11\n@@ -588,0 +587,1 @@\n+java\/rmi\/registry\/multipleRegistries\/MultipleRegistries.java    8268182 macosx-all\n@@ -632,0 +632,1 @@\n+sun\/security\/pkcs11\/Provider\/MultipleLogins.sh                  8319128 linux-aarch64\n@@ -731,2 +732,2 @@\n-java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java             8286352 linux-all,windows-x64\n-java\/util\/concurrent\/ExecutorService\/CloseTest.java             8288899 macosx-aarch64\n+java\/util\/Locale\/LocaleProvidersRun.java                        8268379 macosx-x64\n+sun\/util\/locale\/provider\/CalendarDataRegression.java            8268379 macosx-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -378,20 +378,0 @@\n-    jdk\/incubator\/vector\/AddTest.java \\\n-    jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java \\\n-    jdk\/incubator\/vector\/ByteMaxVectorTests.java \\\n-    jdk\/incubator\/vector\/CovarOverrideTest.java \\\n-    jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java \\\n-    jdk\/incubator\/vector\/DoubleMaxVectorTests.java \\\n-    jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java \\\n-    jdk\/incubator\/vector\/FloatMaxVectorTests.java \\\n-    jdk\/incubator\/vector\/ImageTest.java \\\n-    jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java \\\n-    jdk\/incubator\/vector\/IntMaxVectorTests.java \\\n-    jdk\/incubator\/vector\/LoadJsvmlTest.java \\\n-    jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java \\\n-    jdk\/incubator\/vector\/LongMaxVectorTests.java \\\n-    jdk\/incubator\/vector\/MethodOverideTest.java \\\n-    jdk\/incubator\/vector\/MismatchTest.java \\\n-    jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java \\\n-    jdk\/incubator\/vector\/ShortMaxVectorTests.java \\\n-    jdk\/incubator\/vector\/VectorMaxConversionTests.java \\\n-    jdk\/incubator\/vector\/VectorReshapeTests.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"}]}